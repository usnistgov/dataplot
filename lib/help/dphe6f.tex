35500.      (VERSION 2023.11)   total number of lines in file (including this line)
 8.                          number of     sections below
  100.    T                  first line number of T section
16700.    U                  first line number of U section
18900.    V                  first line number of V section
22100.    W                  first line number of W section
29700.    X                  first line number of X section
30500.    Y                  first line number of Y section
32100.    Z                  first line number of Z section
33500.    MISCELLANEOUS      first line number of MISCELLANEOUS section
 
--------------------------------------------------------------
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
-------------------------  *T*  ZZZZZ--------------------
 
-----T TEST--------------------------------------
 
T TEST
 
Name:
    T TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform either a one sample t-test, an unpaired two sample t-test,
    or a paired two sample t-test.  Both one-tailed and two-tailed tests
    are supported.
 
Description:
    There are three distinct tests supported by this command.

    1) The test that the mean for a sample is equal to a specified value
       can be formulated as follows:

          H0: u = mu
          Ha: u <> mu
          Test Statistic: T = (xbar - mu)/(s*SQRT(n))
                          where xbar, s, and n denote the sample mean,
                          sample standard deviation, and sample size,
                          respectively.
          Alpha: Typically set to .05
          Critical Region: For a two-tailed test

                               T < t(alpha/2,N-1) or T > t(1-alpha/2,N-1)

                           where t is the percent point function of the
                           t distribution.

                           For a lower-tailed test

                               T < t(alpha,N-1)

                           For an upper-tailed test

                               T > t(1-alpha,N-1)

          Conclusion: Reject null hypothesis if T in critical region
 
    2) The test that the means for two independent samples (i.e.,
       unpaired) are equal can be formulated as follows:

          H0: u1 = u2
          Ha: u1 <> u2
          Test Statistic (assuming equal population variances):

                T = (X1BAR - X2BAR)/(Sp*SQRT((1/N1)+(1/N2)))

              where X1BAR, N1, X2BAR, and N2 are the sample one mean
              and sample size and X2BAR and N2 are the sample two
              mean and sample size, respectively, and where Sp is the
              pooled standard deviation:

                Sp = SQRT(((n1-1)*var1 + (n2-1)*var2)/(n1+n2-2))

              The degrees of freedom equals n1+n2-2.

          Test Statistic (assuming unequal population variances):

                T = (XBAR1 - XBAR2)/SQRT((XVAR1/N1) + (XVAR2/N2))

              where X1BAR, XVAR1, N1, X2BAR, XVAR2, and N2 are the
              sample one mean, variance, and sample size and X2BAR,
              XVAR2, and N2 are the sample two mean, variance, and
              sample size, respectively.

              The degrees of freedom equals:

                (XVAR1/N1 + XVAR2/N2)**2/DENOM

              where DENOM equals:

                (XVAR1/N1)**2/(N1-1) + (XVAR2/N2)**2/(N2-1)

          Alpha: Typically set to .05
          Critical Region:
              For a two-tailed test
                 
                  T < -t(alpha/2,df) or T > t(alpha/2,df)

              where t is the percent point function for the t
              distribution.

              For a lower-tailed test

                  T < -t(alpha,df)

              For an upper-tailed test

                  T > t(alpha,df)

          Conclusion: Reject null hypothesis if T in critical region
 
    3) Two sample test that the means for two paired samples are equal.

       The test that the means for two independent samples are equal
       can be formulated as follows:

          H0: u1 = u2
          Ha: u1 <> u2
          Test Statistic:

                T = (X1BAR - X2BAR)/(XDELSD/SQRT(N))

              where X1BAR, X2BAR, XDELSD, and N are the sample one mean,
              the sample two mean, the standard deviation of differences
              of the paired samples, and the number of paired samples,
              respectively.
            
          Alpha: Typically set to .05
          Critical Region:
              For a two-tailed test
                 
                  T < -t(alpha/2,N-1) or T > t(alpha/2,N-1)

              where t is the percent point function for the t
              distribution.

              For a lower-tailed test

                  T < -t(alpha,N-1)

              For an upper-tailed test

                  T > t(alpha,N-1)

          Conclusion: Reject null hypothesis if T in critical region
 

Syntax 1:
    <lower tailed/upper tailed> T TEST   <y>  <mu>
                                <SUBSET/EXCEPT/FOR qualification>
    where <LOWER TAILED/UPPER TAILED> is an optional keyword that
               specifies either a lower tailed or an upper tailed test;
          <y> is a response variable;
          <mu> is a parameter or number;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax performs a one sample t-test that the mean is equal
    to <mu>.  If <mu> is omitted, it is assumed to be zero.

    The response variable can be a matrix.

    If neither LOWER TAILED or UPPER TAILED is specified, the t test will
    return the results for the two-tailed case, the lower tailed case,
    and the upper tailed case.  If LOWER TAILED is specified, then only
    the results for the lower tailed case will be printed.  If UPPER
    TAILED is specified, then only the results for the upper tailed case
    will be printed.

Syntax 2:
    MULTIPLE <lower tailed/upper tailed> ONE SAMPLE T TEST
                                <y1> ... <yk> <mu>
                                <SUBSET/EXCEPT/FOR qualification>
    where <LOWER TAILED/UPPER TAILED> is an optional keyword that
               specifies either a lower tailed or an upper tailed test;
          <y1> ... <yk> is a list of one to 30 response variables;
          <mu> is a parameter or number;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax performs a one sample t-test that the mean is equal
    to <mu> for each of the response variables.  If <mu> is omitted,
    it is assumed to be zero.

    The response variables can be matrices.

    If neither LOWER TAILED or UPPER TAILED is specified, the t test will
    return the results for the two-tailed case, the lower tailed case,
    and the upper tailed case.  If LOWER TAILED is specified, then only
    the results for the lower tailed case will be printed.  If UPPER
    TAILED is specified, then only the results for the upper tailed case
    will be printed.

Syntax 3:
    <LOWER TAILED/UPPER TAILED> <PAIRED> T TEST  <y1>  <y2>
                                         <SUBSET/EXCEPT/FOR qualification>
    where <LOWER TAILED/UPPER TAILED> is an optional keyword that
               specifies either a lower tailed or an upper tailed test;
          <PAIRED> is an optional keyword that specifies whether a paired
               or unpaired t test is performed;
          <y1> is the first response variable;
          <y2> is the second response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax performs a two sample t-test.  If the keyword PAIRED is
    given, a paired t test is performed.  Otherwise an unpaired t test
    is performed.

    The response variables can be matrices.

    If neither LOWER TAILED or UPPER TAILED is specified, the t test will
    return the results for the two-tailed case, the lower tailed case,
    and the upper tailed case.  If LOWER TAILED is specified, then only
    the results for the lower tailed case will be printed.  If UPPER
    will be printed.

Syntax 4:
    MULTIPLE <LOWER TAILED/UPPER TAILED> <PAIRED> T TEST  <y1> ... <yk>
                                         <SUBSET/EXCEPT/FOR qualification>
    where <LOWER TAILED/UPPER TAILED> is an optional keyword that
               specifies either a lower tailed or an upper tailed test;
          <PAIRED> is an optional keyword that specifies whether a paired
               or unpaired t test is performed;
          <y1> ... <yk> is a list of 1 to 30 response variables;
          <y2> is the second response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax performs all the pairwise t tests for the listed
    response variables.

    If the keyword PAIRED is given, a paired t test is performed.
    Otherwise an unpaired t test is performed.

    The response variables can be matrices.

    If neither LOWER TAILED or UPPER TAILED is specified, the t test will
    return the results for the two-tailed case, the lower tailed case,
    and the upper tailed case.  If LOWER TAILED is specified, then only
    the results for the lower tailed case will be printed.  If UPPER
    TAILED is specified, then only the results for the upper tailed case
    will be printed.

Examples:
    T TEST Y
    T TEST Y   MU
    LOWER TAILED T TEST Y   MU
    MULTIPLE ONE SAMPLE T TEST Y1 TO Y5  MU
    T TEST Y1  Y2
    T TEST Y1  Y2  SUBSET TAG > 2
    UPPER TAILED PAIRED T TEST Y1  Y2
    MULTIPLE T TEST Y1  TO  Y10
 
Note:
    Sample sizes do not need to be equal unless paired t tests are
    specified.
 
Note:
    By default, Dataplot prints the test statistic for both the equal
    and unequal population variances assumptions for the two sample test.
    The following command can be used to specify this:

        SET T TEST VARIANCE EQUAL
        SET T TEST VARIANCE UNEQUAL
        SET T TEST VARIANCE BOTH
 
    The EQUAL keyword specifies that only the equal variance case will
    be printed, UNEQUAL specifies that only the unequal variances case
    will be printed, and BOTH resets the default that both the
    equal and unequal variance cases will be printed.
    
Note:
    Dataplot saves the following internal parameters after a
    t test:

        STATVAL   = the value of the test statistic
        STATCDF   = the CDF of the test statistic
        PVALUE    = the p-value for the two-sided test
        PVALUELT  = the p-value for the lower tailed test
        PVALUEUT  = the p-value for the upper tailed test
        CUTLOW50  = the 50% lower tailed critical value
        CUTUPP50  = the 50% upper tailed critical value
        CUTLOW80  = the 80% lower tailed critical value
        CUTUPP80  = the 80% upper tailed critical value
        CUTLOW90  = the 90% lower tailed critical value
        CUTUPP90  = the 90% upper tailed critical value
        CUTLOW95  = the 95% lower tailed critical value
        CUTUPP95  = the 95% upper tailed critical value
        CUTLOW99  = the 99% lower tailed critical value
        CUTUPP99  = the 99% upper tailed critical value
        CUTLO999  = the 99.9% lower tailed critical value
        CUTUP999  = the 99.9% upper tailed critical value

Note:
    The following statistics are also supported:

        LET A = ONE SAMPLE T TEST                    Y MU
        LET A = ONE SAMPLE T TEST CDF                Y MU
        LET A = ONE SAMPLE T TEST PVALUE             Y MU
        LET A = ONE SAMPLE T TEST LOWER TAIL PVALUE  Y MU
        LET A = ONE SAMPLE T TEST UPPER TAIL PVALUE  Y MU

    If MU is omitted in the above commands, it is assumed to be zero.

        LET A = TWO SAMPLE T TEST                    Y1 Y2
        LET A = TWO SAMPLE T TEST CDF                Y1 Y2
        LET A = TWO SAMPLE T TEST PVALUE             Y1 Y2
        LET A = TWO SAMPLE T TEST LOWER TAIL PVALUE  Y1 Y2
        LET A = TWO SAMPLE T TEST UPPER TAIL PVALUE  Y1 Y2

        LET A = TWO SAMPLE PAIRED T TEST                    Y1 Y2
        LET A = TWO SAMPLE PAIRED T TEST CDF                Y1 Y2
        LET A = TWO SAMPLE PAIRED T TEST PVALUE             Y1 Y2
        LET A = TWO SAMPLE PAIRED T TEST LOWER TAIL PVALUE  Y1 Y2
        LET A = TWO SAMPLE PAIRED T TEST UPPER TAIL PVALUE  Y1 Y2

    Enter HELP STATISTICS to see what commands can use these
    statistics.

Default:
    Two-tailed tests will be performed unless the LOWER TAILED or
    UPPER TAILED keywords are specified.  For the two sample test,
    an unpaired test will be assumed unless the PAIRED keyword is
    specified.
 
Synonyms:
    TTEST is a synonym for T TEST.
    1 SAMPLE is a synonym for ONE SAMPLE.
 
Related Commands:
    CONFIDENCE LIMITS       = Compute the confidence limits for the mean of
                              a sample.
    BIHISTOGRAM             = Generates a bihistogram.
    QUANTILE QUANTILE PLOT  = Generates a quantile qauntile plot.
    BOX PLOT                = Generates a box plot.
 
Reference:
    T tests are discussed in most introductory statistics books.
 
Applications:
    Confirmatory Data Analysis
 
Implementation Date:
    Pre-1987
    2011/3: Added support for paired t-test
    2011/3: Reformatted output for greater clarity
    2011/3: Support for one-tailed tests
 
Program 1:
    SKIP 25
    READ AUTO83B.DAT Y1 Y2
    SET WRITE DECIMALS 5
    T TEST Y1 Y2
 
Program 2:
    let z = normal rand numb for i = 1 1 50
    let mu0 = 0.3
    set write decimals 5
    .
    t test z mu0
    lower tailed t test z mu0
    upper tailed t test z mu0

Program 3:
    .  Example of paired t-test from p. 178 of Bowker and Lieberman
    skip 25
    read w1 w2
     73  51
     43  41
     47  43
     53  41
     58  47
     47  32
     52  24
     38  43
     61  53
     56  52
     56  57
     34  44
     55  57
     65  40
     75  68
    end of data
    set write decimals 5
    paired t test w1 w2

-----TAB EXPAND---------------------------------------------
 
TAB EXPAND
 
Name:
    TAB EXPAND (SET)
 
Type:
    Set Subcommand
 
Purpose:
    Specify how tab characters are handled on Dataplot command lines.
 
Description:
    By default, when Dataplot parses a command line it converts all
    non-printing characters, including tabs, to a single space
    character.

    This command allows you to specify how tabs are to be handled.
    You can specify that the tab character be left as is or that it be
    replaced by one to 20 space characters.

    This command is most likely to be useful when processing tabs
    contained within strings.

Syntax:
    SET TAB EXPAND <ival>
    where <ival> is a number or parameter in the range 0 to 20.

    If <ival> is 0, then the tab character is left as is.  If
    <ival> is a positive integer, then the tab character is replaced
    with <ival> spaces.  If <ival> is greater than 20, it will be set
    to 20.  Common choices for <ival> would be 3 or 5.

Examples:
    SET TAB EXPAND 0
    SET TAB EXPAND 5
 
Default:
    Tabs are replaced with a single space character.
 
Synonyms:
    None
 
Related Commands:
    LET STRING               = Define a string.
    READ STRING              = Read a string.
    STRING EXPAND WHITESPACE = Replace non-printing characters in a
                               string with a space character.
    TEXT                     = Write a text string immediately.
    TITLE                    = Specify the title for a plot.
    LEGEND                   = Specify text to be generated on subsequent
                               plots.
    LABEL                    = Specify an x- or y-axis label for a plot.
 
Applications:
    Annotating Plots
 
Implementation Date:
    2019/02
 
Program:
    . Note that "^I" denotes a tab character
    set tab expand 3
    let string s = xxxx^Iyyyy^Izzzz
    print s

-----TAB HORIZONTAL POSITION (SET)--------------------------------------
 
TAB HORIZONTAL POSITION
 
Name:
    TAB HORIONTAL POSITION (SET)
    TAB VERTICAL POSITION (SET)
    TAB COLOR (SET)
    TAB JUSTIFICATION (SET)
    TAB FONT (SET)
    TAB UNITS (SET)
    TAB VERTICAL UNITS (SET)
    TAB SIZE (SET)
    TAB WIDTH (SET)
 
Type:
    Set Subcommand
 
Purpose:
    For text written on a plot (TEXT, LEGEND, TITLE, LABEL commands),
    support the use of tabs denoted by the TAB() character sequence.
 
Description:
    In some cases, plots may be annotated with a descriptive table.  We may
    want to have columns in this table where the different columns may have
    different attributes.

    In addition to the horizontal position, you can set the vertial position,
    the color, the justification, the font, the units (i.e., screen units or
    units of the most recent plot, and the size.

    Tabs must be identified by the character sequence TAB().  Hard coded
    tab characters are converted to a single space on Dataplot command lines
    before Dataplot parses the command.  Up to 10 tab settings can be
    specified.

Syntax 1:
    SET TAB HORIZONTAL POSITION <index> <xcoor>
    where <index> is a number or parameter in the range 1 to 10;
    and   <xcoor> is number or parameter that defines the x-coordinate
                  for the text following the tab identified by <index>.
 
Syntax 2:
    SET TAB VERTICAL POSITION <index> <ycoor>
    where <index> is a number or parameter in the range 1 to 10;
    and   <ycoor> is number or parameter that defines the y-coordinate
                  for the text following the tab identified by <index>.
 
Syntax 3:
    SET TAB COLOR <index> <color>
    where <index> is a number or parameter in the range 1 to 10;
    and   <color> is literal value that defines the color for the text
                  following the tab identified by <index>.

    If the color is defined by a string, then do something like the
    following

       LET STRING S = BLUE
       SET TAB COLOR 1 ^S
 
Syntax 4:
    SET TAB JUSTIFICATION <index> <just>
    where <index> is a number or parameter in the range 1 to 10;
    and   <just> is literal value that defines the justification for
                 the text following the tab identified by <index>.

    If the justification is defined by a string, then do something like the
    following

       LET STRING S = CENTER
       SET TAB JUSTIFICATION 1 ^S

Syntax 5:
    SET TAB FONT <index> <font>
    where <index> is a number or parameter in the range 1 to 10;
    and   <font> is literal value that defines the font for
                 the text following the tab identified by <index>.

    If the font is defined by a string, then do something like the
    following

       LET STRING S = COMPLEX
       SET TAB FONT 1 ^S

Syntax 6:
    SET TAB UNITS <index> <DATA/SCREEN>
    where <index> is a number or parameter in the range 1 to 10;
    and   <DATA/SCREEN> is literal value that specifies whether the
                 the horizontal position for the text following the
                 tab identified by <index> is specified in 0 to 100
                 screen units (SCREEN) or in units of the most recent
                 plot (DATA).

    If the units are defined by a string, then do something like the
    following

       LET STRING S = DATA
       SET TAB FONT 1 ^S

Syntax 7:
    SET TAB VERTICAL UNITS <index> <DATA/SCREEN>
    where <index> is a number or parameter in the range 1 to 10;
    and   <DATA/SCREEN> is literal value that specifies whether the
                 the vertical position for the text following the
                 tab identified by <index> is specified in 0 to 100
                 screen units (SCREEN) or in units of the most recent
                 plot (DATA).

    If the units are defined by a string, then do something like the
    following

       LET STRING S = DATA
       SET TAB VERTICAL FONT 1 ^S

Syntax 8:
    SET TAB SIZE <index> <value>
    where <index> is a number or parameter in the range 1 to 10;
    and   <xcoor> is number or parameter that defines the character
                  size, in 0 to 100 screen units, for the text
                  following the tab identified by <index>.
 
Syntax 9:
    SET TAB WIDTH <index> <value>
    where <index> is a number or parameter in the range 1 to 10;
    and   <xcoor> is number or parameter that defines the character
                  width, in 0 to 100 screen units, for the text
                  following the tab identified by <index>.

    This syntax only applies if a software font is being used.

Examples:
    SET TAB HORIZONTAL POSITION 1 25
    SET TAB COLOR 1 BLUE
    SET TAB SIZE 1 2.5
    SET TAB JUSTIFICATION 1 RIGHT
    SET TAB HORIZONTAL POSITION 2 35
    SET TAB COLOR 2 RED
    SET TAB SIZE 2 3
    SET TAB JUSTIFICATION 2 LEFT
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TEXT    = Write a text string immediately.
    TITLE   = Specify the title for a plot.
    LEGEND  = Specify text to be generated on subsequent plots.
    LABEL   = Specify an x- or y-axis label for a plot.
 
Applications:
    Annotating Plots
 
Implementation Date:
    2019/02
 
Program:
    . Step 1:   Read the data and generate a fit
    .
    skip 25
    read berger1.dat y x batch
    skip 0
    .
    fit y x
    let a0 = round(a0,2)
    let a1 = round(a1,2)
    let cc = corr y x
    let cc = round(cc,2)
    .
    . Step 2:   Generate the plot
    .
    title offset 2
    title case asis
    label case asis
    legend case asis
    character case asis
    case asis
    .
    title Fit for Alaska Pipeline Data (File: BERGER1.DAT)
    x1label Lab Defect Size
    y1label Field Defect Size
    .
    line blank
    character X
    .
    plot y x
    .
    . Step 3:   Annotate the plot
    .
    set tab horizontal position 1 25
    set tab horizontal position 2 35
    set tab justification 1 right
    set tab justification 2 left
    set tab size  1 3
    .
    justification left
    move 17 85
    text a0:tab()^a0 tab()Intercept
    .
    move 17 82
    text a1:tab()^a1 tab()Slope
    .
    set carriage return gap 0.2
    set tab color 1 red
    set tab color 2 blue
    move 17 79
    text Corr:tab()^cc tab()Linearcr()Correlation

-----TABLE WIDTH-----------------------------------------------------
 
TABLE WIDTH
 
Name:
    TABLE WIDTH
 
Type:
    Support Command
 
Purpose:
    Specifies the total width and the number of digits to the right
    of the decimal point when writing numeric variables with the
    WRITE command.
 
Description:
    This is an alternative to the SET WRITE DECIMALS and
    SET WRITE FORMAT commands.  The SET WRITE DECIMALS command
    requires that all variables be printed with the same
    format.  Although the SET WRITE FORMAT allows more flexibility,
    it cannot be used for WRITE <RTF/LATEX/HMTL>.

    Up to 200 rows can be specified (if the number of variables
    being printed is greater than 200, it is recommended that
    you use the SET WRITE FORMAT command).

    A few comments on what can be specified for <ntot> and
    <nright>.  If NTOT and NRIGHT are the values for a given
    row, then the following apply:

    1) A value of -99 indicates that the default value
       should be used (this is 15 for NTOT and 7 for NWIDTH).

    2) If NRIGHT is a positive integer, then Fortran F format
       will be used (e.g.,  "3.26").

    3) If NRIGHT is 0, then an integer format will be used.

    4) If NRIGHT is -2, then a G15.7 format will be used.
       In this case, the Fortran compiler will decide between
       an F-based format or an E-based format depending on
       the partiuclar number.  If NRIGHT is between -3 and
       -20, then a Fortran E-based format (Eyy.xx where the
       absolute value of NRIGHT specifies the "xx").


Syntax:
    TABLE WIDTH   <ntot>   <nright>
    where  <ntot> is a variable that specifies the total width of
           the field for each column in the WRITE command;
    and <ntot> is a variable that specifies the number of digits to
           the right of the decimal point for each column in the
           WRITE command.

Examples:
    TABLE WIDTH 10 30
    TABLE WIDTH 1 15
    TABLE WIDTH 50 63
    TABLE WIDTH COL1 COL2
 
Default:
    Dataplot writes variables using an E15.7 format.
 
Synonyms:
    None
 
Related Commands:
    WRITE               = Writes variables, parameters, and functions
                          to the screen or to file.
    SET READ FORMAT     = Defines a Fortran like format to use in
                          subsequent writes.
    SET WRITE DECIMAL   = Specify the number of digits to the right of
                          the decimal point for subsequent writes.
 
Applications:
    Data Output
 
Implementation Date:
    6/2009
 
Program:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET Y2 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET Y3 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET X = SEQUENCE 1 1 100
    .
    LET NTOTAL = DATA  10 12 12 12
    LET NRIGHT = DATA   0  5  5  5
    TABLE WIDTH NTOTAL NRIGHT
    WRITE TEMP.DAT X Y1 Y2 Y3
 
-----TABULATION PLOT (LET)--------------------------------
 
TABULATION PLOT
 
Name:
    TABULATION PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generate a tabulation plot.

Description:
    The tabulation plot is bit of a mix between a fluctuation plot
    and a contour plot.

    Like the fluctuation plot, the tabulation plot is based on a
    statistic generated from one or more response variables.  The
    statistic is computed for one to four group-id variables and a
    grid is created so that is each combination of categories has a
    fixed position on the grid.

    For the fluctuation plot, at each grid position, two rectangles are
    drawn.  The first is drawn in a background color and is full size
    (i.e., the maximum value of the statistic).  A second rectangle is
    drawn in a foreground color with a height proportional to the value
    of the statistic for that particular combination of categories.

    For the tabulation plot, only one rectangle is drawn.  However, the
    color of the rectangle is based on the value of the statistic
    relative to a "levels" variable (hence the similarity to a
    contour plot).  The Program examples below demonstrate how to
    create and use the levels variable.

    With the CHARACTER TABULATION PLOT, the actual value of the
    statistic is printed rather than a rectangle.  This is essentially
    a graphical table.  In addition, you can specify a "background"
    character.  This is typically set to either a filled or an unfilled
    box and is used to provide highlighting.  This is demonstrated in
    one of the Program examples below.

    The appearance of the tabulation plot is controlled by appropriate
    settings for the REGION, LINE, and CHARACTER settings.  This is
    demonstrated in the Program examples below.

    The list of supported statistics can be obtained by entering

          HELP STATISTICS

    If no statistic is specified, the MEAN is assumed (note that this
    is different than the FLUCTUATION PLOT which defaults to COUNT).

Syntax 1:
    TABULATION <stat> PLOT <y1> ... <y3>  <x1> ... <xk>  <ylevel>
                       <SUBSET/EXCEPT/FOR qualification>
    where <stat> is one of the supported statistics;
          <y1> ... <y3> is a list of one to three response variables
               (depending on how many variables <stat> requires);
          <x1> ... <xk> is a list of one to four categorical variables;
          <ylevel> is a variable that defines the levels;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    If <stat> is omitted, it defaults to MEAN.  If <stat> is COUNT (or
    SIZE or NUMBER), no response variables are given.

Syntax 2:
    CHARACTER TABULATION <stat> PLOT <y1> ... <y3>
                         <x1> ... <xk> <ylevel>
                         <SUBSET/EXCEPT/FOR qualification>
    where <stat> is one of the supported statistics;
          <y1> ... <y3> is a list of one to three response variables
               (depending on how many variables <stat> requires);
          <x1> ... <xk> is a list of one to four categorical variables;
          <ylevel> is a variable that defines the levels;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    If <stat> is omitted, it defaults to MEAN.  If <stat> is COUNT (or
    SIZE or NUMBER), no response variables are given.

    This syntax generates the "character" version of the tabulation
    plot.

Examples:
    TABULATION COUNT PLOT X1 X2 X3 X4 YLEVEL
    TABULATION BINOMIAL PROBABILITY PLOT Y X1 X2 YLEVEL

Note:
    When there is a single categorical variable, the division
    is performed horizontally.

    When there are two or more categorical variables, the division
    is first performed vertically, then horizontally.  This
    vertical/horizontal subdivision is repeated until all the
    categorical variables are accommodated.

    When there are two or more categorical variables, you can
    change the vertical/horizontal order to horizontal/vertical
    by entering the command

       SET TABULATION PLOT DIRECTION X

    To restore the default order, enter

       SET TABULATION PLOT DIRECTION Y

Note:
    The following command was added

       SET TABULATION PLOT CODED <ON/OFF>

    By default (= ON), each factor variable is coded from 1 to
    NDIST with NDIST denoting the number of levels (i.e., distinct
    values for that factor variable.

    When there are more than two factor variables and some of the
    combinations of levels for the factor variables are missing, it
    is desirable to suppress this coding.  Setting this option
    to OFF will use the original units for the factor variables.
    You may want to code each of the factor variables.  For
    example, if there are four factor variables, you can do
    something like

         LET X1C = CODED X1
         LET X2C = CODED X2
         LET X3C = CODED X3
         LET X4C = CODED X4
         SET TABULATION PLOT CODED OFF
         TABULATION BINOMIAL PROBABILITY PLOT Y X1C X2C X3C X4C

Note:
    For the case where there are exactly two cross tabulation
    variables, it may be desirable to sort the rows and columns
    based on the value of the statistic.  This can be specified
    with the following commands

       SET TABULATION SORTED ON
       SET TABULATION SORTED OFF
       SET TABULATION SORTED ROW
       SET TABULATION SORTED COLUMN

     ON specifies that both the column and row direction will be
     sorted, OFF (the default) specifies that neither direction
     will be sorted, ROW specifies that the vertical direction
     will be sorted, and COLUMN specifies that the horizontal
     direction will be sorted.

     You can specify whether the sort is an ascending (the default)
     or a descending sort by entering the commands

       SET TABULATION COLUMN SORT DIRECTION <ASCENDING/DESCENDING>
       SET TABULATION ROW    SORT DIRECTION <ASCENDING/DESCENDING>

Note:
    For the case where there are exactly two cross tabulation variables
    for the CHARACTER TABULATION PLOT, it may be desirable to highlight
    the row and column minimum and maximum points.

    You can specify this with the following commands

        SET TABULATION PLOT ROW    MINMAX <ON/OFF>
        SET TABULATION PLOT COLUMN MINMAX <ON/OFF>

    The use of these commands is demonstrated in the program examples
    below.

Note:
    The appearance of the plot is controlled by appropriate settings
    for the LINE, CHARACTER, and REGION switches and the corresponding
    attribute settings for these commands.

    For the basic TABULATION PLOT, the number of traces is equal to
    the number of levels.  The settings and attributes for the first
    trace apply to the lowest level, the second trace applies to the
    second lowest level, and so on.  This is demonstrated in the
    Program 1 example.

    For the CHARACTER TABULATION PLOT, there are two sets of settings
    and attributes.  The first set applies to the background character
    (this is "highlighting" feature).  This is typically an empty or
    filled box or empty circle, but you can set it to whatever you
    like.  The second set applies to the foreground character.  This
    is demonstrated in the Program examples below.

    If the ROW MINMAX or COLUMN MINMAX option is used for the
    CHARACTER TABULATION PLOT adds two additional traces (the first
    for the minimum value and the second for the maximum value).
    For this option, the background character settings are usually
    left blank and the highlighting is applied to the row or column
    minimum/maximum values.  This is demonstrated in the program
    examples below.

Note:
    You can control the distance between the rectangles on the tabulation
    plot with the commands

         SET TABULATION PLOT X INCREMENT <value>
         SET TABULATION PLOT Y INCREMENT <value>

    The default increments are set to 0.05 (in data units).  Setting
    these values to 0 will result in rectangles with no gaps.

Note:
    The rectangles for the tabulation plot are typically drawn with a
    single color.  For the BINOMIAL PROPORTION, MEAN CONFIDENCE LIMIT,
    and MEDIAN LIMIT cases, you can shade the rectangles from lowest
    confidence value to highest confidence value.

    To turn on the uncertainty intervals for these cases, enter

        SET TABULATION PLOT UNCERTAINTY ON

    To turn off the uncertainty intervals for these cases, enter

        SET TABULATION PLOT UNCERTAINTY OFF

    To specify the number of intervals, enter

        SET TABULATION PLOT NUMBER OF UNCERTAINTY INTERVALS <value>

    where <value> is an integer value between 0 and 100.  The default
    is 50.

    Note that this option still needs algorithmic work and is not yet
    recommended for general usage.

Note:
    The CHARACTER TABULATION plot has a number of options to control
    the appearance.  To demonstrate (and simplify) the use of these
    options, the following files have been added to the "programs"
    directory (typically "/usr/local/lib/dataplot/programs" on
    Unix/Linux systems and "C:\Program Files\NIST\Dataplot\PROGRAMS"
    on Windows, though this may vary on your local implementation):

        WRIGHT6.DP    - a driver program
        WRIGLEVE.DP   - define the contour levels and the associated
                        colors and highlight styles
        WRIGOPTI.DP   - specify the options for the plot
        WRIGLEGE.DP   - create the legend for the contour levels and
                        draw horizontal/vertical separator lines
        WRIGPLCN.DP   - define the plot control options for the plot
        WRIGMARG.DP   - generate the row/column margin values

    These programs are based on the Wright brothers flight data
    data set (WRIGHT11.DAT).  The Program examples modify the
    WRIGHT6.DP macros to specify different options and show the
    resulting changes to the plot.

    Although these sample programs are specific to the WRIGHT11.DAT
    example, they can be adapted to other data sets.  Specifically,
    copy the WRIGHT6.DP and WRIGLEVE.DP macros to your own directory
    (and rename them if appropriate) and do the following:

       1) Modify the WRIGHT6.DP macro to read your data set and to
          define the strings for the axis labels and tic mark labels.
          Define the options for the WRIGOPTI.DP macro to use the
          formatting options you would like.

       2) Modify the WRIGLEVE.DP macro to define the contour levels
          for your data set.

    The Program examples below contain copies of the WRIGLEVE.DP (since
    this typically change when the data changes) and WRIGOPTI.DP 
    (to show what options can be specified) macros.  The others are not
    shown here as they are typically not modified, but they can be
    viewed with the LIST <name> command where <name> is the name of
    the desired program.

Default:
    None
 
Synonyms:
    None

Related Commands:
    FLUCTUATION PLOT              = Generate a fluctuation plot.
    STATISTIC PLOT                = Generate a statistic versus subsample
                                    plot for one index variable.
    CROSS TABULATE PLOT           = Generate a statistic versus subsample
                                    plot for two index variables.
    ASSOCIATION PLOT              = Generate an association plot.
    SIEVE PLOT                    = Generate a sieve plot.
    ROSE PLOT                     = Generate a Rose plot.
    BINARY TABULATION PLOT        = Generate a binary tabulation plot.
    ROC CURVE                     = Generate a ROC curve.
    CROSS TABULATE                = Perform a cross-tabulation.
    CHI-SQUARE INDEPENDENCE TEST  = Perform a chi-square test for
                                    independence.
    ODDS RATIO INDEPENDENCE TEST  = Perform a log(odds ratio) test for
                                    independence.
    FISHER EXACT TEST             = Perform Fisher's exact test.
    ODDS RATIO                    = Compute the bias corrected odds ratio.
    LOG ODDS RATIO                = Compute the bias corrected
                                    log(odds ratio).

Reference:
    Unwin, Theus, and Hofmann (2006), "Graphics of Large Data
    Sets: Visualizing a Million", Springer, chapter 5.

    Friendly (2000), "Visualizing Categorical Data", SAS Institute
    Inc., p. 90.

Applications:
    Graphical Analysis
 
Implementation Date:
    2009/9
    2010/1: Added "uncertainty" option for binomial proportions
    2010/1: Option to leave axis variables uncoded
    2010/6: Added CHARACTER TABULATION PLOT option
    2010/6: Support for "sorted" option for two group-id variables
    2010/8: Support for row/column "minmax" option for CHARACTER
            TABULATION PLOT case
 
Program 1:
    .  Demonstrate most basic usage
    .
    .  Step 1: Read the data
    .
    skip 25
    read wright11.dat pressure angle wing
    let angled = distinct angle
    let nangle = size angled
    let wingd = distinct wing
    let nwing = size wingd
    .
    title case asis
    title offset 2
    title Response Variable = Pressure
    label case asis
    x1label Wing Type
    y1label uc()Alc()ngle
    y1label displacement 12
    tic offset units data
    x1limits 1 nwing
    major xtic mark number nwing
    minor xtic mark number 0
    xtic mark offset 0.8 0.8
    x1tic mark label format alpha
    x1tic mark label content 1 2 3 4 5 6 7 8 9 10 11 12 13 15 16 17
    y1limits 1 nangle
    major ytic mark number nangle
    minor ytic mark number 0
    y1tic mark offset 0.8 0.8
    y1tic mark label format alpha
    y1tic mark label content 0 2.5 5 7.5 10 12.5 15 17.5 20 25 30 35 40 45
    .
    let ylevel = data 10 20 30 40 50
    region fill on all
    region fill color red orange yellow green cyan blue
    line color red orange yellow green cyan blue
    .
    tabulation mean plot pressure angle wing ylevel
    .
    box fill pattern solid
    box shadow hw 0 0
    .
    box fill color blue
    box 86 90 90 86
    move 91 87; text > 50
    .
    box fill color cyan
    box 86 86 90 82
    move 91 83; text 40 - 50
    .
    box fill color green
    box 86 82 90 78
    move 91 79; text 30 - 40
    .
    box fill color yellow
    box 86 78 90 74
    move 91 75; text 20 - 30
    .
    box fill color orange
    box 86 74 90 70
    move 91 71; text 10 - 20
    .
    box fill color red
    box 86 70 90 66
    move 91 67; text < 10

Program 2:
    .  Demonstrate the most basic format
    .
    dimension 40 columns
    .
    .  Step 1: Read the Wright brothers data and define title, axis labels,
    .          and tic mark labels
    .
    skip 25
    read wright11.dat y x1 x2
    .
    let x1d = distinct x1
    let ny = size x1d
    let x2d = distinct x2
    let nx = size x2d
    let string stitle = Wright Brothers Pressure Data
    let string sylab = uc()Alc()ngle
    let string sxlab = Wing Type
    .
    let string sy1 = 0
    let string sy2 = 2.5
    let string sy3 = 5
    let string sy4 = 7.5
    let string sy5 = 10
    let string sy6 = 12.5
    let string sy7 = 15
    let string sy8 = 17.5
    let string sy9 = 20
    let string sy10 = 25
    let string sy11 = 30
    let string sy12 = 35
    let string sy13 = 40
    let string sy14 = 45
    .
    loop for k = 1 1 13
        let string sx^k = ^k
    end of loop
    let string sx14 = 15
    let string sx15 = 16
    let string sx16 = 17
    .
    .  Step 2: Define the contouring levels and associated attributes
    .
    call wrigleve.dp
    .
    .  Step 3: Define desired options for the CHARACTER TABULATION PLOT
    .
    let highflag = 0
    call wrigopti.dp
    .
    .  Step 3: Define row/column marginal values for statistic
    .
    set let cross tabulate collapse
    let rowmean = cross tabulate ^zzzzstat y x1
    let colmean = cross tabulate ^zzzzstat y x2
    let rowmeanr = rank index rowmean
    let colmeanr = rank index colmean
    .
    .  Step 4: Set plot control options
    .
    call wrigplcn.dp
    .
    .  Step 5: Generate the character tabulation plot
    .
    .          Box around lowest and highest levels
    .
    if sortflag = 1
       set tabulation plot sort row
    else if sortflag = 2
       set tabulation plot sort column
    else if sortflag = 3
       set tabulation plot sort on
    end of if
    if direrow = 1
       set tabulation plot row sort direction descending
    end of if
    if direcol = 1
       set tabulation plot column sort direction descending
    end of if
    .
    .          Row/Column Minimum/Maximum Option
    .
    if minmax = 1
       set tabulation plot row minmax on
    end of if
    if minmax = 2
       set tabulation plot column minmax on
    end of if
    .
    character color ^scolor
    character hw ^ssize
    character ^sstyle
    line blank all
    .
    character tabulation mean plot y x1 x2 ylevel
    .
    .  Step 6: Draw row/column marginal values and legend
    .
    if margflag = 1
       call wrigmarg.dp
    end of if
    .
    if legeflag = 1
       call wriglege.dp
    end of if

Program 3:
    .  Demonstrate the "highlight" option
    .
    dimension 40 columns
    .
    .  Step 1: Read the Wright brothers data and define title, axis labels,
    .          and tic mark labels
    .
    skip 25
    read wright11.dat y x1 x2
    .
    let x1d = distinct x1
    let ny = size x1d
    let x2d = distinct x2
    let nx = size x2d
    let string stitle = Wright Brothers Pressure Data
    let string sylab = uc()Alc()ngle
    let string sxlab = Wing Type
    .
    let string sy1 = 0
    let string sy2 = 2.5
    let string sy3 = 5
    let string sy4 = 7.5
    let string sy5 = 10
    let string sy6 = 12.5
    let string sy7 = 15
    let string sy8 = 17.5
    let string sy9 = 20
    let string sy10 = 25
    let string sy11 = 30
    let string sy12 = 35
    let string sy13 = 40
    let string sy14 = 45
    .
    loop for k = 1 1 13
        let string sx^k = ^k
    end of loop
    let string sx14 = 15
    let string sx15 = 16
    let string sx16 = 17
    .
    .  Step 2: Define the contouring levels and associated attributes
    .
    call wrigleve.dp
    .
    .  Step 3: Define desired options for the CHARACTER TABULATION PLOT
    .
    let highflag = 1
    let seprow = 1
    let sepcol = 1
    call wrigopti.dp
    .
    .  Step 3: Define row/column marginal values for statistic
    .
    set let cross tabulate collapse
    let rowmean = cross tabulate ^zzzzstat y x1
    let colmean = cross tabulate ^zzzzstat y x2
    let rowmeanr = rank index rowmean
    let colmeanr = rank index colmean
    .
    .  Step 4: Set plot control options
    .
    call wrigplcn.dp
    .
    .  Step 5: Generate the character tabulation plot
    .
    .          Box around lowest and highest levels
    .
    if sortflag = 1
       set tabulation plot sort row
    else if sortflag = 2
       set tabulation plot sort column
    else if sortflag = 3
       set tabulation plot sort on
    end of if
    if direrow = 1
       set tabulation plot row sort direction descending
    end of if
    if direcol = 1
       set tabulation plot column sort direction descending
    end of if
    .
    .          Row/Column Minimum/Maximum Option
    .
    if minmax = 1
       set tabulation plot row minmax on
    end of if
    if minmax = 2
       set tabulation plot column minmax on
    end of if
    .
    character color ^scolor
    character hw ^ssize
    character ^sstyle
    line blank all
    .
    character tabulation mean plot y x1 x2 ylevel
    .
    .  Step 6: Draw row/column marginal values and legend
    .
    if margflag = 1
       call wrigmarg.dp
    end of if
    .
    if legeflag = 1
       call wriglege.dp
    end of if

Program 4:
    .  Demonstrate the "row MIN/MAX" option
    .
    dimension 40 columns
    .
    .  Step 1: Read the Wright brothers data and define title, axis labels,
    .          and tic mark labels
    .
    skip 25
    read wright11.dat y x1 x2
    .
    let x1d = distinct x1
    let ny = size x1d
    let x2d = distinct x2
    let nx = size x2d
    let string stitle = Wright Brothers Pressure Data
    let string sylab = uc()Alc()ngle
    let string sxlab = Wing Type
    .
    let string sy1 = 0
    let string sy2 = 2.5
    let string sy3 = 5
    let string sy4 = 7.5
    let string sy5 = 10
    let string sy6 = 12.5
    let string sy7 = 15
    let string sy8 = 17.5
    let string sy9 = 20
    let string sy10 = 25
    let string sy11 = 30
    let string sy12 = 35
    let string sy13 = 40
    let string sy14 = 45
    .
    loop for k = 1 1 13
        let string sx^k = ^k
    end of loop
    let string sx14 = 15
    let string sx15 = 16
    let string sx16 = 17
    .
    .  Step 2: Define the contouring levels and associated attributes
    .
    call wrigleve.dp
    .
    .  Step 3: Define desired options for the CHARACTER TABULATION PLOT
    .
    let minmax = 1
    let minmaxla = 1
    call wrigopti.dp
    .
    .  Step 3: Define row/column marginal values for statistic
    .
    set let cross tabulate collapse
    let rowmean = cross tabulate ^zzzzstat y x1
    let colmean = cross tabulate ^zzzzstat y x2
    let rowmeanr = rank index rowmean
    let colmeanr = rank index colmean
    .
    .  Step 4: Set plot control options
    .
    call wrigplcn.dp
    .
    .  Step 5: Generate the character tabulation plot
    .
    .          Box around lowest and highest levels
    .
    if sortflag = 1
       set tabulation plot sort row
    else if sortflag = 2
       set tabulation plot sort column
    else if sortflag = 3
       set tabulation plot sort on
    end of if
    if direrow = 1
       set tabulation plot row sort direction descending
    end of if
    if direcol = 1
       set tabulation plot column sort direction descending
    end of if
    .
    .          Row/Column Minimum/Maximum Option
    .
    if minmax = 1
       set tabulation plot row minmax on
    end of if
    if minmax = 2
       set tabulation plot column minmax on
    end of if
    .
    character color ^scolor
    character hw ^ssize
    character ^sstyle
    line blank all
    .
    character tabulation mean plot y x1 x2 ylevel
    .
    .  Step 6: Draw row/column marginal values and legend
    .
    if margflag = 1
       call wrigmarg.dp
    end of if
    .
    if legeflag = 1
       call wriglege.dp
    end of if

Program 5:
    .  Demonstrate the "SORT" option on both rows and columns
    .
    dimension 40 columns
    .
    .  Step 1: Read the Wright brothers data and define title, axis labels,
    .          and tic mark labels
    .
    skip 25
    read wright11.dat y x1 x2
    .
    let x1d = distinct x1
    let ny = size x1d
    let x2d = distinct x2
    let nx = size x2d
    let string stitle = Wright Brothers Pressure Data
    let string sylab = uc()Alc()ngle
    let string sxlab = Wing Type
    .
    let string sy1 = 0
    let string sy2 = 2.5
    let string sy3 = 5
    let string sy4 = 7.5
    let string sy5 = 10
    let string sy6 = 12.5
    let string sy7 = 15
    let string sy8 = 17.5
    let string sy9 = 20
    let string sy10 = 25
    let string sy11 = 30
    let string sy12 = 35
    let string sy13 = 40
    let string sy14 = 45
    .
    loop for k = 1 1 13
        let string sx^k = ^k
    end of loop
    let string sx14 = 15
    let string sx15 = 16
    let string sx16 = 17
    .
    .  Step 2: Define the contouring levels and associated attributes
    .
    call wrigleve.dp
    .
    .  Step 3: Define desired options for the CHARACTER TABULATION PLOT
    .
    let highflag = 1
    let sortflag = 3
    call wrigopti.dp
    .
    .  Step 3: Define row/column marginal values for statistic
    .
    set let cross tabulate collapse
    let rowmean = cross tabulate ^zzzzstat y x1
    let colmean = cross tabulate ^zzzzstat y x2
    let rowmeanr = rank index rowmean
    let colmeanr = rank index colmean
    .
    .  Step 4: Set plot control options
    .
    call wrigplcn.dp
    .
    .  Step 5: Generate the character tabulation plot
    .
    .          Box around lowest and highest levels
    .
    if sortflag = 1
       set tabulation plot sort row
    else if sortflag = 2
       set tabulation plot sort column
    else if sortflag = 3
       set tabulation plot sort on
    end of if
    if direrow = 1
       set tabulation plot row sort direction descending
    end of if
    if direcol = 1
       set tabulation plot column sort direction descending
    end of if
    .
    .          Row/Column Minimum/Maximum Option
    .
    if minmax = 1
       set tabulation plot row minmax on
    end of if
    if minmax = 2
       set tabulation plot column minmax on
    end of if
    .
    character color ^scolor
    character hw ^ssize
    character ^sstyle
    line blank all
    .
    character tabulation mean plot y x1 x2 ylevel
    .
    .  Step 6: Draw row/column marginal values and legend
    .
    if margflag = 1
       call wrigmarg.dp
    end of if
    .
    if legeflag = 1
       call wriglege.dp
    end of if

Program 6:
    . Name:    WRIGLEVE.DP
    . Purpose: Define the levels and associated attributes for the
    .          contouring
    .
    FEEDBACK SAVE
    FEEDBACK OFF
    .
    .  Step 1: Define the levels in YLEVEL
    .
    let ylevel = data 10 20 30 40 50
    let nlevel = size ylevel
    let nlevel2 = nlevel + 1
    .
    .  Step 2: Define the
    .
    .            1) colors for each level
    .            2) background styles for each level
    .            3) character size for background (charh1) and value (charh2)
    .
    let string color1 = red
    let string color2 = coral
    let string color3 = orange
    let string color4 = green
    let string color5 = cyan
    let string color6 = blue
    .
    let string style1 = box
    let string style2 = blank
    let string style3 = blank
    let string style4 = blank
    let string style5 = blank
    let string style6 = box
    . 
    let charh1 = 4
    let charw1 = 4
    let charh2 = 2
    let charw2 = 2
    .
    FEEDBACK RESTORE

Program 7:
    . Name:    WRIGOPTI.DP
    . Purpose: Define options for CHARACTER TABULATION PLOT for
    .          the Wright brothers data.  Modify these to modify
    .          what type of plot is drawn.  Note that certain options
    .          are incompatible, so some options may override others.
    .
    .          margflag = 1    => Print marginal (i.e., row and column)
    .                             values of statistic on right and bottom axes
    .                   = 0    => Omit these marginal statistics
    .          legeflag = 1    => Print a legend defining color labels
    .                   = 0    => Omit this legend
    .          sortflag = 0    => Unsorted
    .                   = 1    => Sort on rows only
    .                   = 2    => Sort on columns only
    .                   = 3    => Sort on both rows and columns
    .          minmax   = 1    => Highlight row minimum and maximum cells
    .                     2    => Highlight column minimum and maximum cells
    .                     0    => Do not highlight row/column minimum and
    .                             maximum cells
    .                             If "1" or "2", then turn off row/column sort
    .          highflag = 1    => Highlighting turned on
    .                   = 0    => Highlighting turned off
    .          direrow  = 0    => Row direction ascending
    .                   = 1    => Row direction descending
    .          direcol  = 0    => Column direction ascending
    .                   = 1    => Column direction descending
    .          seprow   = 0    => Omit lines separating rows
    .                   = 1    => Draw horizontal lines to separate rows
    .          sepcol   = 0    => Omit lines separating columns
    .                   = 1    => Draw lines separating columns
    .          minmaxla = 0    => Do not highlight row/column minmax
    .                             tic mark labels
    .                   = 1    => Highlight row/column minmax tic mark labels
    .          cpuflag  = 1    => Print CPU time on plot
    .                   = 0    => Do not print cpu time on plot
    .          zzzzstat =      => String defining desired statistic to plot
    .                             (typically the mean for this type of plot)
    .
    FEEDBACK SAVE
    FEEDBACK OFF
    .
    .  Step 1: Define which options you want
    .
    .          If the parameter exists (i.e., user sets before calling),
    .          then use that value.  Otherwise, use the default value.
    .
    if margflag not exist
       . let margflag = 0
       let margflag = 1
    end of if
    .
    if legeflag not exist
       . let legeflag = 0
       let legeflag = 1
    end of if
    .
    if highflag not exist
       . let highflag = 0
       let highflag = 1
    end of if
    if highflag = 0
       let legeflag = 0
    end of if
    .
    if sortflag not exist
       let sortflag = 0
       . let sortflag = 1
       . let sortflag = 2
       . let sortflag = 3
    end of if
    .
    if direrow not exist
       let direrow = 0
       . let direrow = 1
    end of if
    .
    if direcol not exist
       let direcol = 0
       . let direcol = 1
    end of if
    .
    if seprow not exist
       let seprow = 0
       . let seprow = 1
    end of if
    .
    if sepcol not exist
       let sepcol = 0
       . let sepcol = 1
    end of if
    .
    if minmaxla not exist
       let minmaxla = 0
       . let minmaxla = 1
    end of if
    if margflag = 0
       let minmaxla = 0
    end of if
    .
    if minmax not exist
       let minmax = 0
       . let minmax = 1
       . let minmax = 2
    end of if
    .
    if cpuflag not exist
       let cpuflag = 0
       . let cpuflag = 1
    end of if
    .
    if minmax > 0
       let sortflag = 0
       let highflag = 1
    end of if
    .
    let irow = 0
    if sortflag =  1
       let irow = 1
    end of if
    if sortflag =  3
       let irow = 1
    end of if
    let icol = 0
    if sortflag =  2
       let icol = 1
    end of if
    if sortflag =  3
       let icol = 1
    end of if
    .
    if zzzzstat not exist
       let string zzzzstat = MEAN
    end of if
    let string sp = sp()
    .
    FEEDBACK RESTORE

-----TABULATE--------------------------------------
 
TABULATE
 
Name:
    TABULATE
 
Type:
    Analysis Command
 
Purpose:
    Generates a tabulation of a statistic for a response variable
    with one group variables.
 
Description:
    For grouped data, we often want to compute a given statistic
    (e.g., the mean or the standard deviation) for each distinct
    group.  This command provides a convenient way to do this.
 
Syntax 1:
    TABULATE <y1> <tag>          <SUBSET/EXCEPT/FOR qualification>
    TABULATE <tag>               <SUBSET/EXCEPT/FOR qualification>
    TABULATE COUNTS <y1> <tag>   <SUBSET/EXCEPT/FOR qualification>
    TABULATE COUNTS <tag>        <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a response variable;
          <tag1> is a group identifier variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax generates a count of the number of elements in
    each group.  Specifying the response variable (<y1>) is
    optional (and usually omitted) since it is not used in the
    calculation for the counts.
 
Syntax 2:
    TABULATE <STAT> <y1> <tag>   <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a response variable;
          <tag> is a group identifier variable;
          <stat> is one of the following statistics:
              MEAN, MIDMEAN, MEDIAN, TRIMMED MEAN, WINSORIZED MEAN,
              GEOMETRIC MEAN, HARMONIC MEAN, HODGES LEHMAN,
              BIWEIGHT LOCATION,
              SUM, PRODUCT, SIZE (or NUMBER or SIZE),
              STANDARD DEVIATION, STANDARD DEVIATION OF MEAN,
              VARIANCE, VARIANCE OF THE MEAN,
              TRIMMED MEAN STANDARD ERROR,
              AVERAGE ABSOLUTE DEVIATION (or AAD),
              MEDIAN ABSOLUTE DEVIATION (or MAD),
              IQ RANGE, BIWEIGHT MIDVARIANCE, BIWEIGHT SCALE,
              PERCENTAGE BEND MIDVARIANCE, SN SCALE, QN SCALE,
              WINSORIZED VARIANCE, WINSORIZED STANDARD DEVIATION,
              RELATIVE STANDARD DEVIATION, RELATIVE VARIANCE (or
                 COEFFICIENT OF VARIATION),
              RANGE, MIDRANGE, MAXIMUM, MINIMUM, EXTREME,
              LOWER HINGE, UPPER HINGE,
              LOWER QUARTILE, UPPER QUARTILE,
              <FIRST/SECOND/THIRD/FOURTH/FIFTH/SIXTH/SEVENTH/EIGHTH/
                  NINTH/TENTH> DECILE,
              PERCENTILE, QUANTILE, QUANTILE STANDARD ERROR,
              SKEWNESS, KURTOSIS, NORMAL PPCC,
              AUTOCORRELATION, AUTOCOVARIANCE,
              CP, CPK, CNPK, CPM, CC,
              EXPECTED LOSS, PERCENT DEFECTIVE,
              SINE FREQUENCY, SINE AMPLITUDE,
              TAGUCHI SN0 (or SN), TAGUCHI SN+ (or SNL),
              TAGUCHI SN- (or SNS), TAGUCHI SN00 (or SN2);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the value of the specified statistic of
    the elements in the response variable (<y1>) for each Cdistinct
    group.
 
Syntax 3:
    TABULATE <STAT> <y1> <y2> <tag>
                    <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <tag> is a group identifier variable;
          <stat> is one of the following statistics:
              LINEAR INTERCEPT, LINEAR SLOPE, LINEAR RESSD,
              LINEAR CORRELATION,
              CORRELATION, RANK CORRELATION,
              COVARIANCE, RANK COVARIANCE,
              COMOVEMENT, RANK COMOVEMENT,
              WINSORIZED COVARIANCE, WINSORIZED COVARIANCE,
              BIWEIGHT MIDCOVARIANCE, BIWEIGHT MIDCORRELATION,
              PERCENTAGE BEND CORRELATION,
              ODDS RATIO, ODDS RATIO STANDARD ERROR,
              LOG ODDS RATIO, LOG ODDS RATIO STANDARD ERROR,
              FALSE POSITIVE, FALSE NEGATIVE,
              TRUE POSITIVE, TRUE NEGATIVE,
              TEST SENSITIVITY, TEST SPECIFICITY,
              POSITIVE PREDICTIVE VALUE, NEGATIVE PREDICTIVE VALUE,
              RELATIVE RISK,
              RATIO;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the value of the specified statistic of
    the elements in the response variables (<y1> and <y2>) for
    each distinct group.
 
Syntax 4:
    TABULATE WEIGHTED <STAT> <y1> <wt> <tag>
                  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the response variable;
          <wt> is the weights variable;
          <tag> is a group identifier variable;
          <stat> is one of the following statistics:
              MEAN, STANDARD DEVIATION (or SD), VARIANCE;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the value of the specified weighted
    statistic of the elements in the response variable (<y1>) for
    each distinct group.
 
Syntax 5:
    TABULATE DIFFERENCE OF <STAT> <y1> <y2> <tag>
                           <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <tag> is a group identifier variable;
          <stat> is one of the following statistics:
              MEAN, MIDMEAN, MEDIAN, TRIMMED MEAN, WINSORIZED MEAN,
              GEOMETRIC MEAN, HARMONIC MEAN, HODGES LEHMAN,
              MIDRANGE, BIWEIGHT LOCATION, SUM,
              STANDARD DEVIATION, STANDARD DEVIATION OF MEAN,
              VARIANCE, VARIANCE OF THE MEAN,
              AVERAGE ABSOLUTE DEVIATION (or AAD),
              MEDIAN ABSOLUTE DEVIATION (or MAD),
              IQ RANGE, BIWEIGHT MIDVARIANCE, BIWEIGHT SCALE,
              PERCENTAGE BEND MIDVARIANCE, SN SCALE, QN SCALE,
              WINSORIZED VARIANCE, WINSORIZED STANDARD DEVIATION,
              RELATIVE STANDARD DEVIATION, RELATIVE VARIANCE,
              COEFFICIENT OF VARIATION, RANGE,
              MAXIMUM, MINIMUM, EXTREME, QUANTILE,
              SKEWNESS, KURTOSIS;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the difference between two response
    variables of the specified statistic for each distinct group.

Examples:
    TABULATE MEAN Y1 TAG
    TABULATE MEDIAN Y1 TAG
    TABULATE SD Y1 TAG
    TABULATE SD Y1 TAG SUBSET TAG > 2
 
Note:
    The TABULATE command generates the computed statistics in
    tabular form.  The STATISTIC PLOT command can be used to
    generate the computed statistics in graphical form.  Enter
    HELP STATISTIC PLOT for details.

Note:
    The table of computed statistics is also written to file
    "dpst1f.dat" in the current directory.   This is useful
    for using the computed values in subsequent analysis.

    To create and read these values, enter the following
    command sequence:

        TABULATE MEAN Y X
        SKIP 1
        READ DPST1F.DAT GROUPID XMEAN
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CROSS TABULATE    = Computes a given statistic for the case
                        with two group identifier variables.
    STATISTIC PLOT    = Graph the value of a statistic for
                        grouped data.
 
Applications:
    Exploratory Data Analysis
 
Implementation Date:
    Pre-1987: Implemented for the MEAN, SD, RANGE, and COUNTS
    2002/8: List of supported statistics greatly expanded.
    2003/3: Support for "WEIGHTED" and "DIFFERENCE OF" statistics
            added.

    As statistics are added to the LET command, they are also
    added to the TABULATE command.  We do not document the
    implementation date here (the implementation date will be
    documented in the HELP for that statistic).
 
Program:
    SKIP 25
    READ GEAR.DAT DIAMETER BATCH
    TABULATE BATCH
    TABULATE MEANS DIAMETER BATCH
    TABULATE MEDIAN DIAMETER BATCH
    TABULATE SD DIAMETER BATCH
    TABULATE RANGE DIAMETER BATCH
 
-----TAN (LET)---------------------------------------------------
 
TAN
 
Name:
    TAN (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the tangent for a variable or parameter.
 
Description:
    The tangent is defined for all real x except PI/2 +/- K*PI where K
    is an integer.  The range is minus infinity to plus infinity.  By
    default, the angle is specified in radian units.  To use degree
    values, enter the command ANGLE UNITS DEGREES (ANGLE UNITS RADIANS
    resets it).
 
Syntax:
    LET <y2> = TAN(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed tangent value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TAN(-2)
    LET A = TAN(A1)
    LET X2 = TAN(X1)
    LET X2 = TAN(PI/2)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SIN      = Compute the sine.
    COS      = Compute the cosine.
    COT      = Compute the cotangent.
    SEC      = Compute the secant.
    CSC      = Compute the cosecant.
    ARCCOS   = Compute the arccosine.
    ARCSIN   = Compute the arcsine.
    ARCTAN   = Compute the arctangent.
    ARCCOT   = Compute the arccotangent.
    ARCSEC   = Compute the arcsecant.
    ARCCSC   = Compute the arcsecant.
 
Reference:
    Consult any standard trigonometry or pre-calculus textbook.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    TITLE PLOT TANGENT FROM -3.1 TO 3.1
    X1LABEL ANGLE (IN RADIANS)
    Y1LABEL TANGENT VALUE
    READ X Y TAG
    -3.1   0  1
     3.1   0  1
     1.57 10  2
     1.57 -10 2
    -1.57 10  3
    -1.57 -10 3
    END OF DATA
    YLIMITS -10 10
    XLIMITS -3 3
    XTIC OFFSET .4 .4
    LINES SOLID SOLID SOLID DOT DOT DOT
    PLOT TAN(X) FOR X = -1.57 .01 1.57 AND
    PLOT TAN(X) FOR X = 1.58 .01 3.10 AND
    PLOT TAN(X) FOR X = -1.58 -0.01 -3.10 AND
    PLOT Y X TAG
 
-----TANH (LET)---------------------------------------------------
 
 
Name:
    TANH (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the hyperbolic cotangent for a variable or parameter.
 
Description:
    The hyperbolic tangent is defined as:
        coth(x) = (e**x - e**-x)/(e**x+e**-x)
    The hyperbolic tangent is defined for all real numbers.  The range
    is -1 to 1.
 
Syntax:
    LET <y2> = TANH(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed hyperbolic cotangent value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TANH(-2)
    LET A = TANH(A1)
    LET X2 = TANH(X1)
    LET X2 = TANH(PI/2)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SIN      = Compute the sine.
    COS      = Compute the cosine.
    TAN      = Compute the tangent.
    COT      = Compute the cotangent.
    SEC      = Compute the secant.
    CSC      = Compute the cosecant.
    ARCCOS   = Compute the arccosine.
    ARCSIN   = Compute the arcsine.
    ARCTAN   = Compute the arctangent.
    ARCCOT   = Compute the arccotangent.
    ARCSEC   = Compute the arcsecant.
    ARCCSC   = Compute the arcsecant.
    SINH     = Compute the hyperbolic sine.
    COSH     = Compute the hyperbolic cosine.
    COTH     = Compute the hyperbolic cotangent.
    SECH     = Compute the hyperbolic secant.
    CSCH     = Compute the hyperbolic cosecant.
    ARCCOSH  = Compute hyperbolic arccosine.
    ARCCOTH  = Compute hyperbolic arccotangent.
    ARCCSCH  = Compute hyperbolic arccosecant.
    ARCSECH  = Compute hyperbolic arcsecant.
    ARCSINH  = Compute hyperbolic arcsine.
    ARCTANH  = Compute hyperbolic arctangent.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    TITLE PLOT HYPERBOLIC TANGENT
    READ X Y TAG
    -3   1  1
     3   1  1
    -3  -1  2
     3  -1  2
    END OF DATA
    YLIMITS -1 1
    YTIC OFFSET 0.1 0.1
    XLIMITS -3 3
    XTIC OFFSET .1 .1
    LINES SOLID DOT DOT
    PLOT TANH(X) FOR X = -3.1 .05 3.1 AND
    PLOT Y X TAG
 
-----TAGPLOT--------------------------------------------------

TAGPLOT

Name:
    TAGPLOT

Type:
    Keyword

Purpose:
    An internal variable into which the trace identifier variable is
    stored whenever some type of plot is generated.

Description:
    Dataplot uses the concept of traces.  A trace is a connected set
    of points.  That is, all points belonging to the same trace are
    drawn with the same attributes.  A plot can set attributes for up
    to 100 traces.  Although traces are most commonly used to draw
    multiple curves on a plot, there is a distinction between traces
    and curves.  Specifically, a curve can be divided into more than
    one trace.  The TAGPLOT variable identifies which trace a given
    point belongs to.  This variable can be used in any way that a
    user created variable can.  This variable is updated whenever any
    type of plot is generated.

Syntax:
    None

Examples:
    PLOT Y1 Y2 VS X SUBSET TAGPLOT > 1

Note:
    The horizontal and vertical coordinates of the points from the
    most recent plot are stored in the internal variables XPLOT and
    YPLOT.

Default:
    None

Synonyms:
    None

Related Commands:
    XPLOT     = An internal variable that contains the horizontal
                coordinates from the most recent plot.
    YPLOT     = An internal variable that contains the vertical
                coordinates from the most recent plot.
    X2PLOT    = An internal variable that contains the coordinates
                from the second horizontal axis from the most recent
                3d plot.

Applications:
    XX

Implementation Date:
    XX

Program:
    XX
 
-----TAGUCHI SN0 --------------------------------------------------
 
TAGUCHI SN0
 
Name:
    TAGUCHI SN0 (LET)
 
Type:
    LET Subcommand
 
Purpose:
    Computes the Taguchi signal-to-noise (S/N) ratio for the "target is
    better" (= "nominal is better") case with a "variance is dependent
    on the mean" subcase.
 
Description:
    For this "target is better" case, the S/N ratio is defined as:
       SN0 = -20*log10(abs(mean/standard deviation))
 
Syntax:
    LET <par> = TAGUCHI SN0 <y>  <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <par> is a parameter where the computed Taguchi S/N ratio is
              stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET TAGUCHI = TAGUCHI SN0 Y
    LET TAGUCHI = TAGUCHI SN0 Y  SUBSET TAG = 5
 
Default:
    None
 
Synonyms:
    The word TAGUCHI is optional (i.e., SN0 is a synonym for TAGUCHI
    SN0).
 
Related Commands:
    TAGUCHI SN0 PLOT   = Generates a target is better and variance is
                         independent of the mean signal-to-noise versus
                         subset plot.
    TAGUCHI SN00       = Computes the target is better and variance is
                         dependent on the mean signal-to-noise ratio.
    TAGUCHI SN+        = Computes the larger is better signal-to-noise
                         ratio.
    TAGUCHI SN-        = Computes the smaller is better signal-to-noise
                         ratio.
 
Reference:
    "Statistical Methods and Applications", Jack Elliot.  Allied
    Signal, 1987 (pp. 4-3, 4-4).
 
Applications:
    Experiment Design and Quality Control
 
Implementation Date:
    94/2
 
Program:
    SKIP 25
    READ GEAR.DAT DIAMETER BATCH
    LET A = TAGUCHI SN0 DIAMETER
 
-----TAGUCHI SN PLOT--------------------------------------------------
 
TAGUCHI SN PLOT
 
Name:
    TAGUCHI SN PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a Taguchi signal-to-noise plot for the "target is
    better" (= "nominal is better") case with a "variance is dependent
    on the mean" subcase.
 
Description:
    This primary Taguchi SN plot answers the question--"What level of
    the independent variable yields the "best" value of the response
    as measured by the largest value of the signal-to-noise (S/N)
    ratio?".  For this "target is better" case, the S/N ratio is
    defined as:
       20 * log10(abs(subsample mean/subsample standard deviation))
    The Taguchi SN plot consists of the following:
       Vertical   axis = the  Taguchi S/N value for each sub-group;
       Horizontal axis = sub-group designation.
    A reference line is drawn for the full sample S/N ratio.
 
Syntax:
    TAGUCHI SN PLOT  <y>  <x>  <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response (= dependent) variable that contains the
              raw data values;
          <x> is an independent variable that contains the sub-group
              identifications;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    TAGUCHI SN PLOT Y X
    TAGUCHI SN PLOT YIELD CATALYST
    TAGUCHI SN PLOT Y X SUBSET MATERIAL 4
 
Default:
    None
 
Synonyms:
    The word TAGUCHI is optional (i.e., SN PLOT is a synonym for
    TAGUCHI SN PLOT).
    S/N, SN0, S/N0, SNT, and S/NT are synonyms for SN.
 
Related Commands:
    TAGUCHI SN+ PLOT    = Generates a (larger is better) signal-to-
                          noise plot.
    TAGUCHI SN- PLOT    = Generates a (smaller is better) signal-to-
                          noise plot.
    TAGUCHI SN00 PLOT   = Generates a (target; variable is independent
                          of the mean) signal-to-noise plot.
    MEAN PLOT           = Generates a mean plot.
    SD PLOT             = Generates a standard deviation plot.
    R CHART             = Generates a range control chart.
    S CHART             = Generates a standard deviation control chart.
    P CHART             = Generates a p control chart.
    NP CHART            = Generates a Np control chart.
    U CHART             = Generates a U control chart.
    C CHART             = Generates a C control chart.
    CHARACTERS          = Sets the types for plot characters.
    LINES               = Sets the types for plot lines.
    SPIKES              = Sets the on/off switch for plot spikes.
    BARS                = Sets the on/off switch for plot bars.
 
Reference:
    "Statistical Methods and Applications", Jack Elliot.  Allied
    Signal, 1987 (pp. 4-3, 4-4).
 
Applications:
    Experiment Design and Quality Control
 
Implementation Date:
    88/8
 
Program:
    SKIP 25
    READ GEAR.DAT DIAMETER BATCH
    CHARACTERS X ALL
    TITLE AUTOMATIC
    X1LABEL BATCH
    Y1LABEL DIAMETER
    XTIC OFFSET 0.5 0.5
    MULTIPLOT 2 1; MULTIPLOT CORNER COORDINATES 0 0 100 100
    PLOT DIAMETER BATCH BATCH
    CHARACTER X BLANK
    LINE BLANK SOLID
    Y1LABEL SN RATIO
    TAGUCHI SN PLOT DIAMETER BATCH
    END OF MULTIPLOT
 
-----TAGUCHI SN+ --------------------------------------------------
 
TAGUCHI SN+
 
Name:
    TAGUCHI SN+ (LET)
 
Type:
    LET Subcommand
 
Purpose:
    Computes the Taguchi signal-to-noise (S/N) ratio for the "larger is
    better" case.
 
Description:
    For this "larger is better" case, the S/N ratio is defined as:
       SN+ = -10*log10(abs(SUM(1/Y**2)/N))
 
Syntax:
    LET <par> = TAGUCHI SN+ <y>  <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <par> is a parameter where the computed Taguchi S/N ratio is
              stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET TAGUCHI = TAGUCHI SN+ Y
    LET TAGUCHI = TAGUCHI SN+ Y  SUBSET TAG = 5
 
Default:
    None
 
Synonyms:
    The word TAGUCHI is optional (i.e., SN+ is a synonym for TAGUCHI
    SN+).
 
Related Commands:
    TAGUCHI SN+ PLOT   = Generates a larger is better signal-to-noise
                         versus subset plot.
    TAGUCHI SN0        = Computes the target is better and variance is
                         independent of the mean signal-to-noise ratio.
    TAGUCHI SN00       = Computes the target is better and variance is
                         dependent on the mean signal-to-noise ratio.
    TAGUCHI SN-        = Computes the smaller is better signal-to-noise
                         ratio.
 
Reference:
    "Statistical Methods and Applications", Jack Elliot.  Allied
    Signal, 1987 (pp. 4-3, 4-4).
 
Applications:
    Experiment Design and Quality Control
 
Implementation Date:
    94/2
 
Program:
    SKIP 25
    READ GEAR.DAT DIAMETER BATCH
    LET A = TAGUCHI SN+ DIAMETER
 
-----TAGUCHI SN+ PLOT--------------------------------------------------
 
TAGUCHI SN+ PLOT
 
Name:
    TAGUCHI SN+ PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a Taguchi signal-to-noise plot for the "larger is
    better" case.
 
Description:
    The Taguchi SN+ plot answers the question "What level of the
    independent variable yields the "best" value of the response (as
    measured by the largest value of the signal-to-noise ratio)?".
    The "+" in SN+ stands for "larger is better".  For this "larger is
    better" case, the signal-to-noise ratio is defined as:
       -10 * log10(abs(SUM[1/y**2]/N))
    The Taguchi SN+ plot consists of the following:
       Vertical   axis = the  Taguchi S/N value for each sub-group;
       Horizontal axis = sub-group designation.
    A reference line is drawn for the full sample S/N ratio.
 
Syntax:
    TAGUCHI SN+ PLOT  <y>  <x>  <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response (= dependent) variable that contains the
              raw data values;
          <x> is an independent variable that contains the sub-group
              identifications;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    TAGUCHI SN+ PLOT Y X
    TAGUCHI SN+ PLOT YIELD CATALYST
    TAGUCHI SN+ PLOT Y X SUBSET MATERIAL 4
 
Default:
    None
 
Synonyms:
    The word TAGUCHI is optional (i.e., SN+ PLOT is a synonym for
    TAGUCHI SN+ PLOT).
    S/N+ and SNL are synonyms for SN+.
 
Related Commands:
    TAGUCHI SN  PLOT    = Generates a (target; variable is dependent
                          on mean) signal-noise plot.
    TAGUCHI SN- PLOT    = Generates a (smaller is better) signal-to-
                          noise plot.
    TAGUCHI SN00 PLOT   = Generates a (target; variable is independent
                          of the mean) signal-to-noise plot.
    MEAN PLOT           = Generates a mean plot.
    SD PLOT             = Generates a standard deviation plot.
    R CHART             = Generates a range control chart.
    S CHART             = Generates a standard deviation control chart.
    P CHART             = Generates a p control chart.
    NP CHART            = Generates a Np control chart.
    U CHART             = Generates a U control chart.
    C CHART             = Generates a C control chart.
    CHARACTERS          = Sets the types for plot characters.
    LINES               = Sets the types for plot lines.
    SPIKES              = Sets the on/off switch for plot spikes.
    BARS                = Sets the on/off switch for plot bars.
 
Reference:
    "Statistical Methods and Applications", Jack Elliot.  Allied
    Signal, 1987 (pp. 4-3, 4-4).
 
Applications:
    Experiment Design Analysis and Quality Control
 
Implementation Date:
    88/8
 
Program:
    SKIP 25
    READ GEAR.DAT DIAMETER BATCH
    CHARACTERS X ALL
    CHARACTER SIZE 3 ALL
    TITLE AUTOMATIC
    X1LABEL BATCH
    Y1LABEL DIAMETER
    XTIC OFFSET 0.5 0.5
    TIC LABEL SIZE 3
    MULTIPLOT 2 1; MULTIPLOT CORNER COORDINATES 0 0 100 100
    PLOT DIAMETER BATCH BATCH
    CHARACTER X BLANK
    LINE BLANK SOLID
    Y1LABEL SN RATIO
    TAGUCHI SN+ PLOT DIAMETER BATCH
    END OF MULTIPLOT
 
-----TAGUCHI SN- --------------------------------------------------
 
TAGUCHI SN-
 
Name:
    TAGUCHI SN- (LET)
 
Type:
    LET Subcommand
 
Purpose:
    Computes the Taguchi signal-to-noise (S/N) ratio for the "smaller is
    better" case.
 
Description:
    For this "smaller is better" case, the S/N ratio is defined as:
       SN- = -10*log10(abs(SUM(Y**2)/N))
 
Syntax:
    LET <par> = TAGUCHI SN- <y>  <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <par> is a parameter where the computed Taguchi S/N ratio is
              stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET TAGUCHI = TAGUCHI SN- Y
    LET TAGUCHI = TAGUCHI SN- Y  SUBSET TAG = 5
 
Default:
    None
 
Synonyms:
    The word TAGUCHI is optional (i.e., SN- is a synonym for TAGUCHI
    SN-).
 
Related Commands:
    TAGUCHI SN- PLOT   = Generates a smaller is better signal-to-noise
                         versus subset plot.
    TAGUCHI SN0        = Computes the target is better and variance is
                         independent of the mean signal-to-noise ratio.
    TAGUCHI SN00       = Computes the target is better and variance is
                         dependent on the mean signal-to-noise ratio.
    TAGUCHI SN+        = Computes the larger is better signal-to-noise
                         ratio.
 
Reference:
    "Statistical Methods and Applications", Jack Elliot.  Allied
    Signal, 1987 (pp. 4-3, 4-4).
 
Applications:
    Experiment Design and Quality Control
 
Implementation Date:
    94/2
 
Program:
    SKIP 25
    READ GEAR.DAT DIAMETER BATCH
    LET A = TAGUCHI SN- DIAMETER
 
-----TAGUCHI SN- PLOT--------------------------------------------------
 
TAGUCHI SN- PLOT
 
Name:
    TAGUCHI SN- PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a Taguchi signal-to-noise plot for the "smaller is
    better" case.
 
Description:
    The Taguchi SN- plot answers the question "What level of the
    independent variable yields the "best" value of the response (as
    measured by the largest value of the signal-to-noise ratio)?".
    The "-" in SN- stands for "smaller-is-better".  For this "smaller
    is better" case, the signal-to-noise ratio is defined as:
       SN- = -10 * log10(abs([y**2]/N))
    The Taguchi SN- plot consists of the following:
       Vertical   axis = the  Taguchi S/N value for each sub-group;
       Horizontal axis = sub-group designation.
    A reference line is drawn for the full sample S/N ratio.
 
Syntax:
    TAGUCHI SN- PLOT   <y>   <x>    <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response (= dependent) variable  that contains
              the raw data values;
          <x> is an independent variable that contains the sub-group
              identifications;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    TAGUCHI SN- PLOT Y X
    TAGUCHI SN- PLOT YIELD CATALYST
    TAGUCHI SN- PLOT Y X SUBSET MATERIAL 4
 
Default:
    None
 
Synonyms:
    The word TAGUCHI is optional (i.e., SN- PLOT is a synonym for
    TAGUCHI SN- PLOT).
    S/N- and SNS are synonyms for SN-.
 
Related Commands:
    TAGUCHI SN  PLOT    = Generates a (target; variable is dependent
                          on the mean) signal-to-noise plot.
    TAGUCHI SN+ PLOT    = Generates a (larger is better) signal-to-
                          noise plot.
    TAGUCHI SN00 PLOT   = Generates a (target; variable is independent
                          of the mean) signal-to-noise plot.
    MEAN PLOT           = Generates a mean plot.
    SD PLOT             = Generates a standard deviation plot.
    R CHART             = Generates a range control chart.
    S CHART             = Generates a standard deviation control chart.
    P CHART             = Generates a p control chart.
    NP CHART            = Generates a Np control chart.
    U CHART             = Generates a U control chart.
    C CHART             = Generates a C control chart.
    CHARACTERS          = Sets the types for plot characters.
    LINES               = Sets the types for plot lines.
    SPIKES              = Sets the on/off switch for plot spikes.
    BARS                = Sets the on/off switch for plot bars.
 
Reference:
    "Statistical Methods and Applications", Jack Elliot.  Allied
    Signal, 1987 (pp. 4-3, 4-4).
 
Applications:
    Experiment Design Analysis and Quality Control
 
Implementation Date:
    88/8
 
Program:
    SKIP 25
    READ GEAR.DAT DIAMETER BATCH
    CHARACTERS X ALL
    CHARACTER SIZE 3 ALL
    TITLE AUTOMATIC
    X1LABEL BATCH
    Y1LABEL DIAMETER
    XTIC OFFSET 0.5 0.5
    TIC LABEL SIZE 3
    MULTIPLOT 2 1; MULTIPLOT CORNER COORDINATES 0 0 100 100
    PLOT DIAMETER BATCH BATCH
    CHARACTER X BLANK
    LINE BLANK SOLID
    Y1LABEL SN RATIO
    TAGUCHI SN- PLOT DIAMETER BATCH
    END OF MULTIPLOT
 
-----TAGUCHI SN00 --------------------------------------------------
 
TAGUCHI SN00
 
Name:
    TAGUCHI SN00 (LET)
 
Type:
    LET Subcommand
 
Purpose:
    Computes the Taguchi signal-to-noise (S/N) ratio for the "target is
    better" (= "nominal is better") case with a "variance is independent
    of the mean" subcase.
 
Description:
    For this "target is better" case, the S/N ratio is defined as:
       SN00 = -20*log10(abs(standard deviation))
 
Syntax:
    LET <par> = TAGUCHI SN00 <y>  <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <par> is a parameter where the computed Taguchi S/N ratio is
              stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET TAGUCHI = TAGUCHI SN00 Y
    LET TAGUCHI = TAGUCHI SN00 Y  SUBSET TAG = 5
 
Default:
    None
 
Synonyms:
    The word TAGUCHI is optional (i.e., SN00 is a synonym for TAGUCHI
    SN00).
 
Related Commands:
    TAGUCHI SN00 PLOT  = Generates a target is better and variance is
                         independent of the mean signal-to-noise versus
                         subset plot.
    TAGUCHI SN0        = Computes the target is better and variance is
                         independent of the mean signal-to-noise ratio.
    TAGUCHI SN+        = Computes the larger is better signal-to-noise
                         ratio.
    TAGUCHI SN-        = Computes the smaller is better signal-to-noise
                         ratio.
 
Reference:
    "Statistical Methods and Applications", Jack Elliot.  Allied
    Signal, 1987 (pp. 4-3, 4-4).
 
Applications:
    Experiment Design and Quality Control
 
Implementation Date:
    94/2
 
Program:
    SKIP 25
    READ GEAR.DAT DIAMETER BATCH
    LET A = TAGUCHI SN00 DIAMETER
 
-----TAGUCHI SN00 PLOT-----------------------------------------------
 
TAGUCHI SN00 PLOT
 
Name:
    TAGUCHI SN00 PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a Taguchi signal-to-noise plot for the "target is
    better" (= "nominal is better") case with a "variance is
    independent of the mean" subcase.
 
Description:
    This Taguchi SN plot answers the question--"What level of the
    independent variable yields the "best" value of the response as
    measured by the largest value of the signal-to-noise (S/N) ratio?".
   For this "target is better" case, the S/N ratio is defined as:
       SN00 = -20 * log10(abs(subsample standard deviation))
    The Taguchi SN plot consists of the following:
       Vertical   axis = the  Taguchi S/N value for each sub-group;
       Horizontal axis = sub-group designation.
    A reference line is drawn for the full sample S/N ratio.
 
Syntax:
    TAGUCHI SN00 PLOT  <y>  <x>  <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response (= dependent) variable that contains the
              raw data values;
          <x> is an independent variable that contains the sub-group
              identifications;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    TAGUCHI SN00 PLOT Y X
    TAGUCHI SN00 PLOT YIELD CATALYST
    TAGUCHI SN00 PLOT Y X SUBSET MATERIAL 4
 
Default:
    None
 
Synonyms:
    The word TAGUCHI is optional (i.e., SN00 PLOT is a synonym for
    TAGUCHI SN00 PLOT).
    SNT2, S/N2, and SN2 are synonyms for SN00.
 
Related Commands:
    TAGUCHI SN+ PLOT    = Generates a (larger is better) signal-to-
                          noise plot.
    TAGUCHI SN- PLOT    = Generates a (smaller is better) signal-to-
                          noise plot.
    TAGUCHI SN PLOT     = Generates a (target; variable is dependent
                          on the mean) signal-to-noise plot.
    MEAN PLOT           = Generates a mean plot.
    SD PLOT             = Generates a standard deviation plot.
    R CHART             = Generates a range control chart.
    S CHART             = Generates a standard deviation control chart.
    P CHART             = Generates a p control chart.
    NP CHART            = Generates a Np control chart.
    U CHART             = Generates a U control chart.
    C CHART             = Generates a C control chart.
    CHARACTERS          = Sets the types for plot characters.
    LINES               = Sets the types for plot lines.
    SPIKES              = Sets the on/off switch for plot spikes.
    BARS                = Sets the on/off switch for plot bars.
 
Reference:
    "Statistical Methods and Applications", Jack Elliot.  Allied
    Signal, 1987 (pp. 4-3, 4-4).
 
Applications:
    Experiment Design and Quality Control
 
Implementation Date:
    88/8
 
Program:
    SKIP 25
    READ GEAR.DAT DIAMETER BATCH
    CHARACTERS X ALL
    TITLE AUTOMATIC
    X1LABEL BATCH
    Y1LABEL DIAMETER
    XTIC OFFSET 0.5 0.5
    MULTIPLOT 2 1; MULTIPLOT CORNER COORDINATES 0 0 100 100
    PLOT DIAMETER BATCH BATCH
    CHARACTER X BLANK
    LINE BLANK SOLID
    Y1LABEL SN RATIO
    TAGUCHI SN00 PLOT DIAMETER BATCH
    END OF MULTIPLOT
 
-----TAIL AREA PLOT--------------------------------------
 
TAIL AREA PLOT
 
Name:
    TAIL AREA PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a tail area plot (the survival distribution function
    against the failure time).
 
Description:
    In reliability analysis, many data sets consists of a set of
    failure times.  These failure times are typically truncated at some
    limit value.  The survival distribution function (SDF) is defined
    as:
       S(t) = prob(T > t)
    where T is the lifetime of a randomly selected unit.  The
    cumulative distribution function is defined as:
       F(t) = 1 - S(t)
            = prob(T < t)
 
    A tail area plot is a plot of the empirical SDF versus failure
    time.  The failure time is plotted on the horizontal axis.  At each
    failure time, the following two points are calculated and plotted
    on the vertical axis:
       y1 = (N - I +1)/(N + 1)
       y2 = (N - I)/(N + 1)
    where N is the number of data points and I is the rank of the
    failure time.  The last failure time only calculates one of these
    points.
 
    When all of the points are connected, a staircase type plot
    results.  The vertical step is constant for the failure times,
    while the lengths of the horizontal steps are determined by the
    distances between failure times.
 
Syntax:
    TAIL AREA PLOT   <x>     <SUBSET/EXCEPT/FOR qualification>
    where <x> is a response variable containing failure times;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    TAIL AREA PLOT Y1
    TAIL AREA PLOT Y1 SUBSET TAG > 1
 
Default:
    None
 
Synonyms:
    SURVIVAL PLOT
 
Related Commands:
    LINES             = Sets the type for plot lines.
    CHARACTERS        = Sets the type for plot characters.
    WEIBULL PLOT      = Generates a Weibull plot.
    PROBABILITY PLOT  = Generates a probability plot (over 25
                        distributions.
    PLOT              = Generates a data or function plot.
 
Applications:
    Reliability
 
Implementation Date:
    88/9
 
Program:
    SKIP 25
    READ HAHN.DAT MILES  TAG
    LEGEND 1 CUT-OFF IS 135,000 MILES
    LEGEND 1 COORDINATES 20 25
    TITLE AUTOMATIC
    XLIMITS 0 150000
    TAIL AREA PLOT MILES
 
-----TCDF (LET)--------------------------------
 
TCDF
 
Name:
    TCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the t cumulative distribution function with NU degrees of
    freedom.  The degrees of freedom parameter should be a positive
    integer.
 
Description:
    The t distribution has the following probability density function:
       f(x)=(G[A]/(G[B]*SQRT(PI*NU))*(1 + x**2/NU)**-(NU+1)/2
    where
       G[A] = GAMMA[(NU+1)/2]
       G[B] = GAMMA[NU/2]
    and where x can be any real number.
 
    The cumulative distribution is the area from negative infinity to x
    (i.e., the integral of the above function).  Since this is a
    probability function, the returned value will be between 0 and 1.
 
Syntax:
    LET <y2> = TCDF(<y1>,NU)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed t cdf value is stored;
          <NU> is a positive integer number or parameter that specifies
               the degrees of freedom;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TCDF(3,10)
    LET A = TCDF(A1,10)
    LET X2 = TCDF(X1,10)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    FCDF   = Compute the F cumulative distribution function.
    FPDF   = Compute the F probability density function.
    FPPF   = Compute the F percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, 1970.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
TITLE PLOT TCDF FOR VARIOUS VALUES OF NU
    SEGMENT 1 COORDINATES 16 88 21 88; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 16 84 21 84; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 16 80 21 80; SEGMENT 3 PATTERN DOT
    SEGMENT 4 COORDINATES 16 76 21 76; SEGMENT 4 PATTERN DASH2
    LEGEND 1 NU = 5; LEGEND 1 COORDINATES 22 87
    LEGEND 2 NU = 10; LEGEND 2 COORDINATES 22 83
    LEGEND 3 NU = 20; LEGEND 3 COORDINATES 22 79
    LEGEND 4 NU = 30; LEGEND 4 COORDINATES 22 75
    YLIMITS 0 1; MAJOR YTIC NUMBER 6
    MINOR YTIC NUMBER 1; YTIC DECIMAL 1
    LINES SOLID DASH DOT DASH2
    PLOT TCDF(X,5) FOR X = -4.0 0.1 4 AND
    PLOT TCDF(X,10) FOR X = -4.0 0.1 4 AND
    PLOT TCDF(X,20) FOR X = -4.0 0.1 4 AND
    PLOT TCDF(X,30) FOR X = -4.0 0.1 4
 
-----TEKTRONIX-------------------------------------------------------
 
TEKTRONIX
 
Name:
    TEKTRONIX
 
Type:
    Output Device Command
 
Purpose:
    Direct graphical output to a Tektronix device.
 
Syntax 1:
    TEKTRONIX   <model>
    where <model> identifies a the type of Tektronix device.  The
              supported models are listed below.
 
    This form directs the Tektronix output to the terminal screen.
 
Syntax 2:
    DEVICE <1/2/3> TEKTRONIX   <model>
    where <model> identifies a the type of Tektronix device.  The
              supported models are listed below.
 
    This form designates one of Dataplot's 3 devices to be a Tektronix
    device.  Device 1 goes to the terminal while devices 2 and 3 go to
    a file.
 
Examples:
    TEKTRONIX 4014
    DEVICE 2 TEKTRONIX 4014
    DEVICE 3 TEKTRONIX 4014
 
Note:
    The following Tektronix models are supported:
 
       TEKTRONIX 4010   (also supports the 4006, 4050, and 4052)
 
       TEKTRONIX 4014   (also supports the 4015 and 4054)
 
       TEKTRONIX 4020
       TEKTRONIX 4025
 
       TEKTRONIX 4027
 
       TEKTRONIX 4005   (also supports the 4007 and 4009)
 
       TEKTRONIX 4105   (also supports the 4107 and the 4109)
       TEKTRONIX 4113
       TEKTRONIX 4115   (also supports the 4128 and the 4129)
 
       TEKTRONIX 4662   (also supports the 4663)
 
    Tektronix models not listed can typically be supported with one of
    the models listed above.  For example, the 42xx and 43xx series
    can use the 4115 driver.
 
Note:
    Many devices support Tektronix emulation (e.g., the tektool utility
    for the SUN, IBM PC using Kermit version 2.31, Falco and HDS
    terminals).  Be aware that emulators sometimes have quirks.  Also,
    the CROSS HAIR command sometimes does not work with emulators.
    The DEFINE and PREPOST commands can be useful for emulators that
    require some type of escape sequence to revert into and out of
    Tektronix mode.  See the documentation for those commands for
    details.
 
Note:
    The Dataplot post processor can translate Tektronix 4014 format
    files to various off-line devices.  However, this format does not
    support color.
 
Default:
    The default model is a Tektronix 4014.  The default screen device
    (i.e., DEVICE 1) is a Tektronix 4014.
 
Synonyms:
    None
DEVICE NOTES
    1) HARDWARE TEXT - A discrete number of hardware character sizes
       are available (between 1 and 4 depending on the model).
       Vertical strings are not rotated.  It is a low quality font.
    2) COLOR - Some models support color.  Specifically, the 4105,
       4113, 4115, 4027, and 4662 models from the above list.  They
       typically support around 8 colors (it can vary somewhat
       depending on the model).  Use the SHOW COLORS command to see
       what colors are supported.
    3) HARDWARE FILL - Most models do solid fills in software.  The
       4027, 4105, 4113, and 4115 models do solid fills in hardware.
    4) DASH PATTERNS - Unique dash patterns are generated for DASH,
       DOT, DASH2, DASH3, DASH4, and DASH5.
    5) LINE WIDTH - Thick lines are generated in software as multiple
       lines.
    6) GRAPHICS INPUT - The CROSS-HAIR command is supported for this
       device (although it tends not to work for many emulators).
 
Related Commands:
    HPGL                  = Direct graphical output to an HPGL device.
    TEKTRONIX             = Direct graphical output to a Tektronix
                            device.
    X11                   = Direct graphical output to an X11 device.
    DEVICE                = Specify certain actions for the graphics
                            output.
    REGIS                 = Direct graphical output to a Regis device.
    HP 2622               = Direct graphical output to an HP terminal.
    CALCOMP               = Direct graphical output to a Calcomp
                            device.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XX
 
-----TERMINATOR CHARACTOR-------------------------------------------

TERMINATOR CHARACTOR

Name:
    TERMINATOR CHARACTOR

Type:
    Support Command

Purpose:
    Specifies the character which upon occurrence in subsequent
    command lines automatically terminates the command statement.

Description:
    This character allows multiple command statements to be "packed"
    on a single line.  Normally, there is no reason to change the
    termination character.  However, if you have text strings that
    contain a semi-colon, it will be necessary to change it (at least
    temporarily) so that these text strings do not cause a break into
    multiple command lines.

Syntax:
    TERMINATOR CHARACTER   <character>
    where <character> is a single character that specifies the
               desired termination character.

Examples:
    TERMINATOR CHARACTOR #
    TERMINATOR CHARACTOR \
    TERMINATOR CHARACTOR

Note:
    Be aware that a separator character found in a comment line
    (lines starting with ". " or with "COMMENT ") causes all
    characters after the termination character to be treated as a
    separate command.

Note:
    The TERMINATOR CHARACTER with no arguments reverts the terminator
    character to default.

Default:
    The default terminator character is ; (a semi-colon).

Synonyms:
    SEPARATOR CHARACTER

Related Commands:
    SUBSTITUTE CHARACTER   = Specify the character for parameter
                             substitution.
    CONTINUE CHARACTER     = Specify the characters that denote a
                             continuation line.

Applications:
    XX

Implementation Date:
    XX

Program:
    XX

-----TEST SENSITIVITY (LET)--------------------------------
 
TEST SENSITIVITY
 
Name:
    TEST SENSITIVITY (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the test sensitivity between two binary variables.
 
Description:
    Given two variables with n parired observations where each
    variable has exactly two possible outcomes, we can generate
    the following 2x2 table:

                      |       Variable 2        |
        Variable 1    |   Success      Failure  |  Row Total
        ====================================================
        Success       |   N11            N12    |  N11 + N12
        Failure       |   N21            N22    |  N21 + N22
        ====================================================
        Column Total  |   N11+N21      N12+N22  |  Total

    The parameters N11, N12, N21, and N22 denote the counts
    for each category.
 
    Success and failure can denote any binary response.
    Dataplot expects "success" to be coded as "1" and "failure"
    to be coded as "0".  Some typical examples would be:

       1) Variable 1 denotes whether or not a patient has a
          disease (1 denotes disease is present, 0 denotes
          disease not present).  Variable 2 denotes the result
          of a test to detect the disease (1 denotes a positive
          result and 0 denotes a negative result).

       2) Variable 1 denotes whether an object is present or
          not (1 denotes present, 0 denotes absent). Variable 2
          denotes a detection device (1 denotes object detected
          and 0 denotes object not detected).

    In these examples, the "ground truth" is typically given
    as variable 1 while some estimator of the ground truth is
    given as variable 2.
   
    The test sensitivity is then N11/(N11+N12).  That is, the
    test sensitivity is the conditional probability that variable 2
    is a success given that variable 1 is a success.  In the context
    of the first example above, the test sensitivity is the
    probability that the test detects the disease given that
    the disease is present.

Syntax:
    LET <par> = TEST SENSITIVITY <y1> <y2>
                              <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed test sensitivity
               is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TEST SENSITIVITY Y1 Y2
    LET A = TEST SENSITIVITY Y1 Y2 SUBSET TAG > 2
 
Note:
    The two variables must have the same number of elements.
 
Note:
    There are two ways you can define the response variables:

       1) Raw data - in this case, the variables contain
          0's and 1's.

          If the data is not coded as 0's and 1's, Dataplot
          will check for the number of distinct values.  If
          there are two distinct values, the minimum value
          is converted to 0's and the maximum value is
          converted to 1's.  If there is a single distinct
          value, it is converted to 0's if it is less than
          0.5 and to 1's if it is greater than or equal to
          0.5.  If there are more than two distinct values,
          an error is returned.

       2) Summary data - if there are two observations, the
          data is assummed to be the 2x2 summary table.
          That is,

              Y1(1) = N11
              Y1(2) = N21
              Y2(1) = N12
              Y2(2) = N22
 
Note:
    The following additional commands are supported

        TABULATE TEST SENSITIVITY  Y1 Y2 X
        CROSS TABULATE TEST SENSITIVITY Y1 Y2 X1 X2

        TEST SENSITIVITY PLOT Y1 Y2 X
        TEST SENSITIVITY CROSS TABULATE PLOT Y1 Y2 X1 X2

        BOOTSTRAP TEST SENSITIVITY PLOT Y1 Y2
        JACKNIFE  TEST SENSITIVITY PLOT Y1 Y2

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TEST SPECIFICITY           = Compute the test specificity.
    FALSE NEGATIVES            = Compute the proportion of
                                 false negatives.
    FALSE POSITIVES            = Compute the proportion of
                                 false positives.
    TRUE NEGATIVES             = Compute the proportion of
                                 true negatives.
    TRUE POSITIVES             = Compute the proportion of
                                 true positives.
    ODDS RATIO                 = Compute the bias corrected
                                 log(odds ratio).
    ODDS RATIO STANDARD ERROR  = Compute the standard error of the
                                 bias corrected log(odds ratio).
    RELATIVE RISK              = Compute the relative risk.
    TABULATE                   = Compute a statistic for data with
                                 a single grouping variable.
    CROSS TABULATE             = Compute a statistic for data with
                                 two grouping variables.
    STATISTIC PLOT             = Generate a plot of a statistic for
                                 data with a single grouping
                                 variable.
    CROSS TABULATE PLOT        = Generate a plot of a statistic for
                                 data with two grouping variables.
    BOOTSTRAP PLOT             = Generate a bootstrap plot for a
                                 given statistic.
 
Reference:
    Fleiss, Levin, and Paik (2003), "Statistical Methods for
    Rates and Proportions", Third Edition, Wiley, chapter 1.
 
Applications:
    Categorical Data Analysis
 
Implementation Date:
    2007/4
 
Program:
    let n = 1
    .
    let p = 0.2
    let y1 = binomial rand numb for i = 1 1 100
    let p = 0.1
    let y2 = binomial rand numb for i = 1 1 100
    .
    let p = 0.4
    let y1 = binomial rand numb for i = 101 1 200
    let p = 0.08
    let y2 = binomial rand numb for i = 101 1 200
    .
    let p = 0.15
    let y1 = binomial rand numb for i = 201 1 300
    let p = 0.18
    let y2 = binomial rand numb for i = 201 1 300
    .
    let p = 0.6
    let y1 = binomial rand numb for i = 301 1 400
    let p = 0.45
    let y2 = binomial rand numb for i = 301 1 400
    .
    let p = 0.3
    let y1 = binomial rand numb for i = 401 1 500
    let p = 0.1
    let y2 = binomial rand numb for i = 401 1 500
    .
    let x = sequence 1 100 1 5
    .
    let a = test sensitivity y1 y2 subset x = 1
    tabulate test sensitivity y1 y2 x
    .
    label case asis
    xlimits 1 5
    major xtic mark number 5
    minor xtic mark number 0
    xtic mark offset 0.5 0.5
    ytic mark offset 0.05 0.05
    y1label Test Sensitivity
    x1label Group ID
    character x blank
    line blank solid
    .
    test sensitivity plot y1 y2 x
 
-----TEST SPECIFICITY (LET)--------------------------------
 
TEST SPECIFICITY
 
Name:
    TEST SPECIFICITY (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the test specificity between two binary variables.
 
Description:
    Given two variables with n parired observations where each
    variable has exactly two possible outcomes, we can generate
    the following 2x2 table:

                      |       Variable 2        |
        Variable 1    |   Success      Failure  |  Row Total
        ====================================================
        Success       |   N11            N12    |  N11 + N12
        Failure       |   N21            N22    |  N21 + N22
        ====================================================
        Column Total  |   N11+N21      N12+N22  |  Total

    The parameters N11, N12, N21, and N22 denote the counts
    for each category.
 
    Success and failure can denote any binary response.
    Dataplot expects "success" to be coded as "1" and "failure"
    to be coded as "0".  Some typical examples would be:

       1) Variable 1 denotes whether or not a patient has a
          disease (1 denotes disease is present, 0 denotes
          disease not present).  Variable 2 denotes the result
          of a test to detect the disease (1 denotes a positive
          result and 0 denotes a negative result).

       2) Variable 1 denotes whether an object is present or
          not (1 denotes present, 0 denotes absent). Variable 2
          denotes a detection device (1 denotes object detected
          and 0 denotes object not detected).

    In these examples, the "ground truth" is typically given
    as variable 1 while some estimator of the ground truth is
    given as variable 2.
   
    The test specificity is then N22/(N21+N22).  That is, the
    test specificity is the conditional probability that variable 2
    is a failure given that variable 1 is a failure.  In the context
    of the first example above, the test specificity is the
    probability that the test does not detect the disease given
    that the disease is not present.

Syntax:
    LET <par> = TEST SPECIFICITY <y1> <y2>
                              <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed test
               specificity is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TEST SPECIFICITY Y1 Y2
    LET A = TEST SPECIFICITY Y1 Y2 SUBSET TAG > 2
 
Note:
    The two variables must have the same number of elements.
 
Note:
    There are two ways you can define the response variables:

       1) Raw data - in this case, the variables contain
          0's and 1's.

          If the data is not coded as 0's and 1's, Dataplot
          will check for the number of distinct values.  If
          there are two distinct values, the minimum value
          is converted to 0's and the maximum value is
          converted to 1's.  If there is a single distinct
          value, it is converted to 0's if it is less than
          0.5 and to 1's if it is greater than or equal to
          0.5.  If there are more than two distinct values,
          an error is returned.

       2) Summary data - if there are two observations, the
          data is assummed to be the 2x2 summary table.
          That is,

              Y1(1) = N11
              Y1(2) = N21
              Y2(1) = N12
              Y2(2) = N22
 
Note:
    The following additional commands are supported

        TABULATE TEST SPECIFICITY  Y1 Y2 X
        CROSS TABULATE TEST SPECIFICITY Y1 Y2 X1 X2

        TEST SPECIFICITY PLOT Y1 Y2 X
        TEST SPECIFICITY CROSS TABULATE PLOT Y1 Y2 X1 X2

        BOOTSTRAP TEST SPECIFICITY PLOT Y1 Y2
        JACKNIFE  TEST SPECIFICITY PLOT Y1 Y2

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TEST SENSITIVITY           = Compute the test sensitivity.
    FALSE NEGATIVES            = Compute the proportion of
                                 false negatives.
    FALSE POSITIVES            = Compute the proportion of
                                 false positives.
    TRUE NEGATIVES             = Compute the proportion of
                                 true negatives.
    TRUE POSITIVES             = Compute the proportion of
                                 true positives.
    ODDS RATIO                 = Compute the bias corrected
                                 log(odds ratio).
    ODDS RATIO STANDARD ERROR  = Compute the standard error of the
                                 bias corrected log(odds ratio).
    RELATIVE RISK              = Compute the relative risk.
    TABULATE                   = Compute a statistic for data with
                                 a single grouping variable.
    CROSS TABULATE             = Compute a statistic for data with
                                 two grouping variables.
    STATISTIC PLOT             = Generate a plot of a statistic for
                                 data with a single grouping
                                 variable.
    CROSS TABULATE PLOT        = Generate a plot of a statistic for
                                 data with two grouping variables.
    BOOTSTRAP PLOT             = Generate a bootstrap plot for a
                                 given statistic.
 
Reference:
    Fleiss, Levin, and Paik (2003), "Statistical Methods for
    Rates and Proportions", Third Edition, Wiley, chapter 1.
 
Applications:
    Categorical Data Analysis
 
Implementation Date:
    2007/4
 
Program:
    let n = 1
    .
    let p = 0.2
    let y1 = binomial rand numb for i = 1 1 100
    let p = 0.1
    let y2 = binomial rand numb for i = 1 1 100
    .
    let p = 0.4
    let y1 = binomial rand numb for i = 101 1 200
    let p = 0.08
    let y2 = binomial rand numb for i = 101 1 200
    .
    let p = 0.15
    let y1 = binomial rand numb for i = 201 1 300
    let p = 0.18
    let y2 = binomial rand numb for i = 201 1 300
    .
    let p = 0.6
    let y1 = binomial rand numb for i = 301 1 400
    let p = 0.45
    let y2 = binomial rand numb for i = 301 1 400
    .
    let p = 0.3
    let y1 = binomial rand numb for i = 401 1 500
    let p = 0.1
    let y2 = binomial rand numb for i = 401 1 500
    .
    let x = sequence 1 100 1 5
    .
    let a = test specificity y1 y2 subset x = 1
    tabulate test specificity y1 y2 x
    .
    label case asis
    xlimits 1 5
    major xtic mark number 5
    minor xtic mark number 0
    xtic mark offset 0.5 0.5
    ytic mark offset 0.05 0.05
    y1label Test Specificity
    x1label Group ID
    character x blank
    line blank solid
    .
    test specificity plot y1 y2 x
 
-----TEXT-------------------------------------------------------
 
TEXT
 
Name:
    TEXT
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Writes out the text string at the current screen position using
    the current case, font, height, width, and justification.
 
Syntax:
    TEXT <string>
    where <string> is all the characters from the first non-blank
              character after TEXT to the last non-blank character at
              the end of the line.
 
Examples:
    TEXT NATIONAL
    TEXT ALPH() + BETA() X
    TEXT Y = INTE() F(X) DX
    TEXT Y = A XSUP()B
 
Note:
    The TEXT command can print Greek characters and a wide variety of
    mathematics and special symbols.  For a list of available symbols,
    enter the following commands:
        HELP GREEK SYMBOLS
        HELP MATH SYMBOLS
        HELP MISC SYMBOLS
        HELP SUBSCRIPTS
    These special symbols are only available if the text is drawn with
    software characters.  They are printed as spaces if hardware
    characters are used.
 
Note:
    By default, the text string is automatically converted to all
    upper case characters.  Enter HELP CASE for details on printing
    lower case characters.
 
Note:
    The MOVE command can be used to explicitly position the text
    string.  Alternatively, the CR, CRLF, LF, MARGIN, and VERTICAL
    Spacing commands can be used to automatically position successive
    TEXT commands.  See the documentation for these commands for
    details.
 
Note:
    The LEGEND command can be used to place arbritrary text lines on
    a plot.  The distinction between LEGEND and TEXT is that LEGEND
    text is not plotted until the next plot is generated while TEXT
    generates it immediately.  In addition, the LEGEND text is drawn
    on all subsequent plots until it is explicitly cleared while TEXT
    only prints the text once.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FONT               = Sets the font for TEXT characters.
    CASE               = Sets the case for TEXT characters.
    HEIGHT             = Sets the height for TEXT characters.
    WIDTH              = Sets the width for TEXT characters.
    HW                 = Sets the height and width for TEXT characters.
    VERTICAL SPACING   = Sets the vertical spacing between text lines.
    HORIZONTAL SPACING = Sets the horizontal spacing between text
                         characters.
    THICKNESS          = Sets the thickness of TEXT characters.
    COLOR              = Sets the color for TEXT characters.
    JUSTIFICATION      = Sets the justification for TEXT.
    LF                 = Sets the line feed after text.
    CR                 = Sets the carriage return after text.
    CRLF               = Sets the carriage return/line feed after text.
    MARGIN             = Sets the carriage return column after text.
    ()                 = Allows math and Greek characters in text.
    MOVE               = Moves to a point.
    CROSS-HAIR (or CH) = Activates and reads the cross-hair.
    ERASE              = Erases the screen (immediately).
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    VERTICAL SPACING 6
    CRLF ON
    MARGIN 10
    FONT DUPLEX
    .
    HW 4 2
    MOVE 5 95
    TEXT JAPAN's 6-POINT PROGRAM FOR
    MOVE 5 89
    TEXT QUALITY MANUFACTURING
    MOVE 10 80
    HW 2.6 1.3
    TEXT CIRC() QUALITY AUDITS
    TEXT CIRC() COMPANY-WIDE QUALITY CONTROL (CWQC)
    TEXT CIRC() QUALITY TRAINING AND EDUCATION
    TEXT CIRC() APPLICATION OF STATISTICAL METHODS
    TEXT CIRC() QUALITY CIRCLE ACTIVITIES
    TEXT CIRC() NATION-WIDE QUALITY CONTROL PROMOTIONAL ACTIVITIES
    HW 2 1
    MOVE 5 10
    TEXT SOURCE: Q.C. TRENDS WINTER 1985, PAGES 22-23.
 
-----THICKNESS-------------------------------------------------------
 
THICKNESS
 
Name:
    THICKNESS
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Specifies the thickness (i.e., line width) of various plot
    elements and diagrammatic graphics components.  For example:
        1) letters (from TEXT command);
        2) numerals (from TEXT command);
        3) mathematics symbols (from TEXT command);
        4) arrow head length (from ARROW command);
        5) capacitor bar thickness (from CAPACITOR command);
        6) resistor wrinkle thickness (from RESISTOR command);
        7) inductor loop thickness (from INDUCTOR COMMAND).
        8) traces drawn on plots.
 
Description:
    The thickness is in decimal units of 0 to 100.  A thickness of 0
    would be negligibly small while a thickness of 100 would be full
    screen vertical distance.
 
Syntax:
    THICKNESS   <val>
    where <val> is a decimal number or parameter in the range 0 to 100
              that specifies the desired thickness (typical values are
              between 0.1 and 0.3).
 
Examples:
    THICKNESS .5
    THICKNESS 0.2
    THICKNESS 0.3
 
Note:
    The THICKNESS command sets ALL line thicknesses to the specified
    value.  This command is appropriate for setting the default
    thickness for the subsequent graphs.  There are commands to set
    the thickness for individual elements of the graphs (see the
    RELATED COMMANDS section below).
 
Note:
    The THICKNESS command with no arguments reverts the thickness to
    the default.
 
Note:
    The thickness is achieved one of two ways:
       1) by the drawing of slightly displaced parallel lines (i.e.,
          software line thickness);
       2) Specifying a thickness to the device protocol (i.e.,
          hardware line thickness).
    Dataplot draws thick lines in hardware when it is available
    (Postscript, QMS, X11).  For these devices, it maps the thickness
    to the closest available setting on that device.
 
Note:
    The thinnest line available can vary from device to device.  This
    can result in different widths on various devices even when
    software line thickness is used.
 
Note:
    Although the thickness measure is continuous, the number of
    distinct parallel lines drawn is discrete (due to limited screen
    resolution).  The net effect is that thickness settings close to
    one another may result in the same apparent output thickness.
 
Note:
    A thickness setting above 1.0 is rare.  On most devices, a
    thickness of between 0.15 and 0.2 works well for producing bold
    lines (e.g., for lines that reproduce well when generating
    overheads and multiple copies).
 
Note:
    Dataplot occassionaly generates "spikes" when drawing thicker
    lines in software.  This is a bug.  The only patch at this time is
    to decrease the thickness (or generate the plot on on a device
    that uses hardware line thickness).
 
Default:
    The default thickness is 0.1.
 
Synonyms:
    None
 
Related Commands:
    LINE THICKNESS        = Sets thickness for plot lines (and certain
                            diagrammatic graphics).
    CHARACTER THICKNESS   = Sets thickness for plot characters.
    SPIKE THICKNESS       = Sets thickness for plot spikes.
    BAR BORDER THICKNESS  = Sets thickness for plot bars (border).
    BAR PATTERN THICKNESS = Sets thickness for plot bars (interior).
    FRAME THICKNESS       = Sets thickness for plot frame.
    TIC THICKNESS         = Sets thickness for tic marks.
    TIC LABEL THICKNESS   = Sets thickness for tic labels.
    LABEL THICKNESS       = Sets thickness for plot labels.
    TITLE THICKNESS       = Sets thickness for plot title.
    LEGEND THICKNESS      = Sets thickness for plot legends.
    SEGMENT THICKNESS     = Sets thickness for plot segments.
    ARROW THICKNESS       = Sets thickness for arrows.
    BOX THICKNESS         = Sets thickness for boxes (border).
    BOX FILL THICKNESS    = Sets thickness for boxes (interior).
    GRID THICKNESS        = Sets thickness for grids.
    REGION BORDER THICK   = Sets thickness for region (border).
    REGION PATTERN THICK  = Sets thickness for regions (interior).
 
Applications:
    Presentation Graphics
 
Implementation Date:
    Pre-1987
 
Program:
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    FONT SIMPLEX
    X1LABEL X AXIS
    Y1LABEL Y AXIS
    TITLE DEFAULT THICKNESS (0.1)
    PLOT X**2 FOR X = 1 1 9
    THICKNESS 0.15
    TITLE UC()THICKNESS 0.15
    PLOT X**2 FOR X = 1 1 9
    THICKNESS 0.2
    TITLE UC()THICKNESS 0.20
    PLOT X**2 FOR X = 1 1 9
    THICKNESS 0.3
    TITLE UC()THICKNESS 0.30
    PLOT X**2 FOR X = 1 1 9
    END OF MULTIPLOT
 
-----THRESHOLD MINIMUM (LET)---------------------------------------------------
 
THRESHOLD MINIMUM
 
Name:
    THRESHOLD MINIMUM (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Given a response variable and a threshold variable, generate a
    new coded response variable (0 => response below threshold, 1 =>
    response above threshold) and an associated group id variable
    (the group id corresponds to the row in the threshold variable).
 
Description:
    This command is primarily intended for use in generating ROC
    curves.  A ROC curve works with two variables that are coded
    as 0 and 1.  The first variable is a ground truth variable and
    the second variable is a response.  A 0 typically means some
    condition is absent while a 1 means the condition is present.
    The assignment of the 0 and 1 is somewhat arbitrary, but it should
    be coded in a consistent fashion for both the ground truth and the
    response.  The ROC curve assesses the performance of the response
    relative to the ground truth based on the 2x2 table generated by
    the cross tabulation of the ground truth and response variable.
    For the ROC curve, the response might be generated for multiple
    values of a threshold (the ROC curve is then used to assess an
    optimal threshold that balances false positives and false negatives).

    In some cases, you may be given a set of responses and a list of
    potential cutoff values.  The THRESHOLD MINIMUM command can then
    be used to create the appropriate coded response variable for the
    ROC curve.  Specifically, for each cutoff value, we compare each
    value in the response variable to the cutoff and return a 1 if the
    response is greater than or equal to the cutoff and a 0 if it less
    than the cutoff.  The coded output response variable will have
    N*NCUTOFF rows where N and NCUTOFF denote the number of rows
    in the response variable and the number of threshold values,
    respectively.  In addition, a group-id variable is returned which
    identifies the row number of the threshold value.

    The THRESHOLD MAXIMUM command is similar.  However, the coding is
    1 if the response value is less than or equal to the cutoff and
    0 if it greater than the cutoff.

Syntax 1:
    LET <y> <tag> = THRESHOLD MINIMUM <x> <xval>
                    <SUBSET/EXCEPT/FOR qualification>
    where <x> is the response variable;
          <xval> is the variable containing the cutoff values;
          <y> is the generated coded response variable;
          <tag> is the generated group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax is used when a "1" implies the response value is
    greater than or equal to the cutoff value.
 
Syntax 2:
    LET <y> <tag> = THRESHOLD MAXIMUM <x> <xval>
                    <SUBSET/EXCEPT/FOR qualification>
    where <x> is the response variable;
          <xval> is the variable containing the cutoff values;
          <y> is the generated coded response variable;
          <tag> is the generated group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax is used when a "1" implies the response value is
    less than or equal to the cutoff value.
 
Examples:
    LET Y TAG = THRESHOLD MINIMUM X XCUTOFF
    LET Y TAG = THRESHOLD MAXIMUM X XCUTOFF
    LET Y TAG = THRESHOLD MAXIMUM X XCUTOFF  SUBSET X > 0.2

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ROC CURVE  = Generate a ROC curve.
    CODE       = Generate a coded variable.
 
Applications:
    ROC Curves
 
Implementation Date:
    2011/7
 
Program:
    .  Step 1: Read the Data
    .
    .          Column 1: Ground Truth (0 => live, 1 => dead)
    .          Column 2: Method 1 (low  => live cell, high => dead cell)
    .          Column 3: Method 2 (high => live cell, low  => dead cell)
    dimension 40 columns
    read alive  percmat  intensity
     1    7.1             39.8
     1    8.5             29.6
     1   72.7              4.2
     1   32.3             12.3
     1    5.4             21.5
     1   71.1              4.4
     1  100.0             13.5
     1   55.0             22.4
     1   15.0             25.9
     1    8.7             38.5
     1    0.9             16.6
     1   19.0             48.5
     1  100.0              4.3
     1  100.0              7.9
     1    5.2             42.6
     1   21.8             47.2
     0   90.0              1.0
     0    2.0             23.5
     0   98.0              2.2
     0  100.0              6.2
     0  100.0              2.0
     0  100.0              5.6
     0  100.0              3.0
     0   30.0             14.3
     0  100.0              1.0
    end of data
    .
    .  Step 3: Generate ROC curves based on different levels of intensity
    .          and matching
    .
    multiplot corner coordinates 5 5 95 95
    multiplot scale factor 2
    multiplot 2 2
    .
    limits 0 1
    major tic mark number 6
    minor tic mark number 1
    tic mark offset 0.05 0.05
    character color black all
    character case asis all
    line blank all
    line dotted
    .
    title offset 5
    title case asis
    label case asis
    y1label Sensitivity
    x1label (1 - Specificity)
    y1label displacement 15
    x1label displacement 12
    title offset 2
    .
    .          Use intensity levels of 5%, 10%, 15%, 20%
    .
    let intcut = data 5 10 15 20
    let gt1 = combine alive alive alive alive
    let intall groupid1 = threshold minimum intensity intcut
    .
    character blank blank 5 10 15 20
    title Intensity Method
    roc curve gt1 intall groupid1
    .
    .          Use matching levels of 70, 80, 90, 95, 100 for cell 1
    .
    let matcut = data 70 80 90 95 100
    let gt2all = combine alive alive alive alive alive
    let matall groupid2 = threshold maximum percmat matcut
    let groupid2 = groupid2
    .
    character blank blank 70% 80% 90% 95% 100%
    title Percent Matching Method
    roc curve gt2all matall groupid2
    .
    end of multiplot
    .
    case asis
    just right
    height 1.5
    move 98 5
    text Sensitivity: P(alive/alive)
    move 98 2
    text Specificity: P(dead/dead)
    .
    just center
    move 50 97
    text ROC Curves
 
-----TIC COORDINATES (LET)-----------------------------------------------
 
TIC COORDINATES
 
Name:
    ...TIC <SCREEN/DATA> COORDINATES
 
Type:
    Let Subcommand
 
Purpose:
    Extract the current coordinates of the plot tic coordinates in either
    screen or data units.
 
Description:
    There may be occasions where you would like to add some text to tic
    mark labels after generating a plot.  This command can be used to
    extract the coordinate values of the tic marks from the most recent
    plot.

Syntax:
    LET <y> = <prefix>TIC <SCREEN/DATA> COORDINATES
    where
          the prefix X  refers to lower horizontal axis;
          the prefix X1 refers to the lower horizontal axis;
          the prefix X2 refers to the upper horizontal axis;
          the prefix Y  refers to the left  vertical axis;
          the prefix Y1 refers to the left  vertical axis;
          the prefix Y2 refers to the right vertical axis;
    and where <y> is a response variable where the coordinates will be saved.

    SCREEN returns the coordinates in 0 to 100 screen units and DATA returns
    the coordinates in data units of the most recent plot.

    Note that this command has no input arguments.

Examples:
    LET YCOOR = YTIC SCREEN COORDINATES
    LET YCOOR = YTIC DATA COORDINATES
    LET YCOOR = Y1TIC SCREEN COORDINATES
    LET XCOOR = XTIC SCREEN COORDINATES
 
Note:
    If no coordinates are currently defined (e.g., no plot has been
    generated yet), the response variable will be returned with zero
    elements.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    XFRAME       = Return the frame limits for the x-axis.
    YFRAME       = Return the frame limits for the x-axis.
 
Applications:
    Plotting
 
Implementation Date:
    2018/10
 
Program:
    plot x**2 for x = 1 1 9
    .
    let youts = ytic screen coordinates
    let youtd = ytic data   coordinates
    let xouts = xtic screen coordinates
    let xoutd = xtic data   coordinates
    .
    set write decimals 3
    print youts youtd xouts xoutd

-----TIC MARK-------------------------------------------------------
 
TIC MARK
 
Name:
    ...TIC MARK
 
Type:
    Plot Control Command
 
Purpose:
    Specifies whether or not tic marks will appear on the frame lines
    of subsequent plots.
 
Syntax:
    <prefix>TIC MARK   <ON or OFF>
    where
            no prefix     refers to all 4 sides;
            the prefix X  refers to both horizontal sides;
            the prefix Y  refers to both vertical sides;
            the prefix X1 refers to the lower horizontal side;
            the prefix X2 refers to the upper horizontal side;
            the prefix Y1 refers to the left  vertical   side;
            the prefix Y2 refers to the right vertical   side.
    and ON specifies that the tic marks will appear while OFF specifies
            that they will not.
 
Examples:
    TIC MARK ON
    TIC MARK OFF
    TIC MARK
    X2TIC MARK ON
    Y2TIC MARK ON
 
Note:
    The appearance of the tic mark labels is independent of the
    appearance of the tic marks and is controlled with the TIC MARK
    LABEL command.  However, no tics are drawn if the frame line is not
    drawn.
 
Note:
    A ...TIC MARK command with no arguments reverts the setting to
    default; thus X1TIC MARK with no arguments reverts the bottom
    horizontal tics to on.  A ...TIC MARK command with no prefix refers
    to all 4 sides; thus TIC MARK OFF suppresses tic marks for all 4
    frame lines.  TIC MARK with no prefix and no arguments reverts the
    tic settings on all 4 sides to default.
 
Default:
    The lower horizontal and the left vertical frame lines have tics
    while the upper horizontal and right vertical frame lines do not.
 
Synonyms:
    TICS is a synonym for TIC MARK, as in TICS ON and X2TICS OFF.
 
Related Commands:
    TIC MARK COLOR      = Sets the color for tic marks.
    TIC MARK OFFSET     = Sets the offset for the first and last tic
                           marks.
    TIC MARK POSITION   = Sets location of tic marks (inside/outside
                          through).
    TIC MARK SIZE       = Sets the size of tic marks.
    TIC MARK THICKNESS  = Sets the thickness of tic marks.
    TIC MARK LABEL      = Specifies whether tic mark labels are drawn.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    . POLLUTION SOURCE ANALYSIS, LLOYD CURRIE, DATE--1990
    . SUBSET OF CURRIE.DAT REFERENCE FILE
    .
    LET ID2 = DATA 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2
    LET LEAD = DATA ...
       164 426 59 98 312 263 607 497 213 54 160 262 547 325 419 94 70
    LET POT = DATA ...
       106 175 61 79 94 121 424 328 107 218 140 179 246 231 245 339 99
    .
    TITLE AUTOMATIC
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    X1LABEL LEAD; Y1LABEL POTASSIUM
    LINE BLANK ALL; CHARACTER CIRCLE; CHARACTER FILL ON
    PLOT POT LEAD
    .
    TIC MARKS ON
    PLOT POT LEAD
    .
    TIC MARK OFF
    PLOT POT LEAD
    .
    X1TIC MARK ON
    X2TIC MARK OFF
    Y1TIC MARK ON
    Y2TIC MARK ON
    PLOT POT LEAD
    END OF MULTIPLOT
 
-----TIC MARK COLOR--------------------------------------------------
 
TIC MARK COLOR
 
Name:
    ...TIC MARK COLOR
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the color of the tic marks on subsequent plots.
 
Description:
    Dataplot provides two methods for specifying colors.

        1. Colors can be defined by name (or by the corresponding index).
           Dataplot adopted it's named colors from the X11 project.
           Currently, 162 named colors and 100 levels of grayscale are
           supported.  Grayscale can be specified with either G0, G1, ...,
           G100 (or -1, -2, ..., -100).  Many older devices support only a
           limited number of colors.  For these devices, unsupported colors
           will be mapped to one of the available colors.  To specify a
           named color, see Syntax 1.

        2. Most modern graphics devices support full RGB (RedBlueGreen)
           color.  You can alternatively specify RGB colors by entering
           three integer values to represent the Red, Green and Blue
           components, respectively.  These values should be in the range
           0 to 255.

    When setting the tic mark RGB color, Dataplot first checks if the
    device supports RGB colors. If not, the named color will be used.  If
    the device does support RGB color, Dataplot will check if an RGB color
    has been specified.  If yes, then that RGB color is used.  If not,
    the named color will be used.

    To see the list of supported named colors (with the associated index
    number), see

    https://www.itl.nist.gov/div898/software/dataplot/refman1/ch11/homepage.htm

Syntax 1:
    <prefix>TIC MARK COLOR   <color>
    where
              no prefix     refers to all 4 sides;
              the prefix X  refers to both horizontal sides;
              the prefix Y  refers to both vertical sides;
              the prefix X1 refers to the lower horizontal side;
              the prefix X2 refers to the upper horizontal side;
              the prefix Y1 refers to the left  vertical   side;
              the prefix Y2 refers to the right vertical   side;
    and <color> is a character string that specifies the desired color.
 
Syntax 2:
    <prefix>TIC MARK RGB COLOR <red> <green> <blue>
    where
              no prefix     refers to all 4 sides;
              the prefix X  refers to both horizontal sides;
              the prefix Y  refers to both vertical sides;
              the prefix X1 refers to the lower horizontal side;
              the prefix X2 refers to the upper horizontal side;
              the prefix Y1 refers to the left  vertical   side;
              the prefix Y2 refers to the right vertical   side;
          <red> is a number or parameter that specifies the red
              component;
          <green> is a number or parameter that specifies the green
              component;
    and   <blue> is a number or parameter that specifies the blue
              component.

    To turn off the RGB color, set the values to -1 (any negative value
    will work).  Values greater than 255 will be set to 255.
 
Examples:
    TIC MARK COLOR GREEN
    TIC MARK COLOR BLUE
    TIC MARK COLOR
    X2TIC MARK COLOR GREEN
    Y2TIC MARK COLOR GREEN
    TIC MARK RGB COLOR 175 238 238
 
Note:
    It is rare to assign different colors to tic marks on the 4
    different sides.  Whatever color is chosen for one side is
    invariably chosen for all sides.  The most common form (by far) for
    this command is the first one (with no prefix) which defines the
    color uniformly for tic marks on all 4 frame sides.
 
Note:
    A ...TIC MARK COLOR command with no arguments reverts the setting
    to default; thus X1TIC MARK COLOR with no arguments reverts the
    bottom horizontal tics color to black.  A ...TIC MARK COLOR command
    with no prefix refers to all 4 sides; thus TIC MARK COLOR GREEN
    sets tic mark color to green for all 4 frame lines.  TIC MARK COLOR
    with no prefix and no arguments reverts the tic color settings on
    all 4 sides to default.
 
Default:
    All tic marks are black.
 
Synonyms:
    TICS COLOR is a synonym for TIC MARK COLOR, as in TICS COLOR GREEN
    and X2TICS COLOR YELLOW.
 
Related Commands:
    TIC MARK            = Specifies whether or not tics are drawn.
    TIC MARK OFFSET     = Sets the offset for the first and last tic
                           marks.
    TIC MARK POSITION   = Sets location of tic marks (inside/outside
                          through).
    TIC MARK SIZE       = Sets the size of tic marks.
    TIC MARK THICKNESS  = Sets the thickness of tic marks.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    Pre-1987
    2020/11: Support for RGB colors.
 
Program 1:
    . POLLUTION SOURCE ANALYSIS, LLOYD CURRIE, DATE--1990
    . SUBSET OF CURRIE.DAT REFERENCE FILE
    .
    LET ID2 = DATA 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2
    LET LEAD = DATA ...
       164 426 59 98 312 263 607 497 213 54 160 262 547 325 419 94 70
    LET POT = DATA ...
       106 175 61 79 94 121 424 328 107 218 140 179 246 231 245 339 99
    .
    TIC MARK THICKNESS 0.5
    X1LABEL LEAD
    Y1LABEL POTASSIUM
    LINE BLANK ALL
    CHARACTER CIRCLE
    CHARACTER FILL ON
    .
    TIC MARK COLOR RED
    TITLE DEMONSTRATE TIC MARK COLOR
    PLOT POT LEAD

Program 2:
    . POLLUTION SOURCE ANALYSIS, LLOYD CURRIE, DATE--1990
    . SUBSET OF CURRIE.DAT REFERENCE FILE
    .
    LET ID2 = DATA 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2
    LET LEAD = DATA ...
        164 426 59 98 312 263 607 497 213 54 160 262 547 325 419 94 70
    LET POT = DATA ...
       106 175 61 79 94 121 424 328 107 218 140 179 246 231 245 339 99
    .
    TIC MARK THICKNESS 0.5
    X1LABEL LEAD
    Y1LABEL POTASSIUM
    LINE BLANK ALL
    CHARACTER CIRCLE
    CHARACTER FILL ON
    .
    TIC MARK RGB COLOR 220 109 88
    TITLE DEMONSTRATE TIC MARK RGB COLOR
    PLOT POT LEAD
 
-----TIC MARK POSITION------------------------------------------------
 
TIC MARK POSITION
 
Name:
    ...TIC MARK POSITION
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the position for tic marks on subsequent plots.
 
Description:
    The available choices are:
      1) inside the frame;
      2) outside the frame;
      3) through the frame.
 
Syntax:
    <prefix>TIC MARK POSITION  <INSIDE/OUTSIDE/THROUGH>
    where
            no prefix     refers to all 4 sides;
            the prefix X  refers to both horizontal sides;
            the prefix Y  refers to both vertical sides;
            the prefix X1 refers to the lower horizontal side;
            the prefix X2 refers to the upper horizontal side;
            the prefix Y1 refers to the left  vertical   side;
            the prefix Y2 refers to the right vertical   side;
    and   INSIDE specifies that tics are inside the frame, OUTSIDE
            specifies that tics are outside the frame, and THROUGH
            specifies that tics are through the frame.
 
Examples:
    TIC MARK POSITION INSIDE
    TIC MARK POSITION OUTSIDE
    TIC MARK POSITION
    X2TIC MARK POSITION THROUGH
    Y2TIC MARK POSITION INSIDE
 
Note:
    It is rare to assign different positions to tic marks on the 4
    different sides.  Whatever position is chosen for one side is
    invariably chosen for all sides.  The most common form (by far) for
    this command is the first one (with no prefix) which defines the
    position uniformly for tic marks on all 4 frame sides.
 
Note:
    A ...TIC MARK POSITION command with no arguments reverts the
    setting to default; thus X1TIC MARK with no arguments reverts the
    bottom horizontal tic marks position to outside.  A ...TIC MARK
    POSITION command with no prefix refers to all 4 sides; thus TIC
    MARK POSITION INSIDE sets the tic mark position to inside on all 4
    sides.  TIC MARK POSITION with no prefix and no arguments reverts
    the tic position settings on all 4 sides to default.
 
Default:
    All tic marks are positioned outside the frame.
 
Synonyms:
    TIC POSITION is a synonym for TIC MARK POSITION.  INSDIE, OUTSIDE,
    and THROUGH can be written as IN, OUT, and THRU respectively.
 
Related Commands:
    TIC MARK            = Specifies whether or not tics are drawn.
    TIC MARK COLOR      = Sets the color for tic marks.
    TIC MARK OFFSET     = Sets the offset for the first and last tic
                           marks.
    TIC MARK SIZE       = Sets the size of tic marks.
    TIC MARK THICKNESS  = Sets the thickness of tic marks.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    . POLLUTION SOURCE ANALYSIS, LLOYD CURRIE, DATE--1990
    . SUBSET OF CURRIE.DAT REFERENCE FILE
    .
    LET LEAD = DATA ...
       164 426 59 98 312 263 607 497 213 54 160 262 547 325 419 94 70
    LET POT = DATA ...
       106 175 61 79 94 121 424 328 107 218 140 179 246 231 245 339 99
    .
    TITLE AUTOMATIC
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    X1LABEL LEAD; Y1LABEL POTASSIUM
    LINE BLANK ALL; CHARACTER CIRCLE; CHARACTER FILL ON
    TIC POSITION OUTSIDE
    PLOT POT LEAD
    .
    TIC POSITION INSIDE
    PLOT POT LEAD
    .
    TIC POSITION THRU
    PLOT POT LEAD
    .
    X1TIC POSITION INSIDE
    Y1TIC POSITION OUTSIDE
    PLOT POT LEAD
    END OF MULTIPLOT
 
-----TIC MARK SIZE--------------------------------------------------
 
TIC MARK SIZE
 
Name:
    ...TIC MARK SIZE
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the length of major tic marks to appear on subsequent
    plots.
 
Description:
    The length is in decimal units of 0 to 100 where 0 would be
    negligibly small and 100 would be full screen vertical distance.
    The tic mark sizes hold for all subsequent plots until defaulted
    (via the ...TIC MARK SIZE command with no arguments) or until
    overridden with new tic mark sizes.  The length of minor tic marks
    is automatically set to half the length of major tic marks.
 
Syntax:
    <prefix>TIC MARK SIZE   <size>
    where
            no prefix     refers to all 4 sides;
            the prefix X  refers to both horizontal sides;
            the prefix Y  refers to both vertical sides;
            the prefix X1 refers to the lower horizontal side;
            the prefix X2 refers to the upper horizontal side;
            the prefix Y1 refers to the left  vertical   side;
            the prefix Y2 refers to the right vertical   side;
    and   <size> is a number or parameter in the range 0 to 100 that
            specifies the desired tic mark size (length).
 
Examples:
    Y1TIC MARK SIZE 3
    X1TIC MARK SIZE 5
    TIC MARK SIZE SIZE 2
    TIC MARK SIZE A
 
Note:
    It is rare to assign different sizes to tic marks on the 4
    different sides.  Whatever size is chosen for one side is
    invariably chosen for all sides.  The most common form (by far) for
    this command is the last one (with no prefix) which defines the
    size uniformly for tic marks on all 4 frame sides.  An exception is
    in the multiplot case where the ratio of rows to columns is not
    close to one.  In this case, separate sizes for the vertical and
    horizontal tic marks may be required to compensate for distortion
    caused by the multiplot command.
 
Note:
    A ...TIC MARK SIZE command with no arguments reverts the size to
    default; thus X1TIC MARK SIZE with no arguments reverts the tic
    mark size for the bottom horizontal frame line to default.  A
    ...TIC MARK SIZE command with no prefix refers to tic marks on all
    4 sides; thus TIC MARK SIZE 2 assigns the size 2 to tic marks on
    all 4 sides.  TIC MARK SIZE with no prefix and no arguments reverts
    tic mark size on all 4 sides to default.
 
Default:
    All tic mark sizes are 1.
 
Synonyms:
    TIC SIZE is a synonym for TIC MARK SIZE, as in TIC SIZE 1.25 and
    X2TIC SIZE 2.
 
Related Commands:
    TIC MARK            = Specifies whether or not tics are drawn.
    TIC MARK COLOR      = Sets the color for tic marks.
    TIC MARK OFFSET     = Sets the offset for the first and last tic
                           marks.
    TIC MARK POSITION   = Sets location of tic marks (inside/outside
                          through).
    TIC MARK THICKNESS  = Sets the thickness of tic marks.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    . POLLUTION SOURCE ANALYSIS, LLOYD CURRIE, DATE--1990
    . SUBSET OF CURRIE.DAT REFERENCE FILE
    .
    LET LEAD = DATA ...
       164 426 59 98 312 263 607 497 213 54 160 262 547 325 419 94 70
    LET POT = DATA ...
       106 175 61 79 94 121 424 328 107 218 140 179 246 231 245 339 99
    .
    X1LABEL LEAD; Y1LABEL POTASSIUM
    LINE BLANK ALL; CHARACTER CIRCLE; CHARACTER FILL ON
    .
    X1TIC MARK SIZE 3.0
    Y1TIC MARK SIZE 2.0
    TITLE DEMONSTRATE TIC SIZE
    PLOT POT LEAD
 
-----TIC MARK THICKNESS-----------------------------------------------
 
TIC MARK THICKNESS
 
Name:
    ...TIC MARK THICKNESS
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the thickness of the tic marks on subsequent plots.
 
Description:
    The thickness is specified as a percentage of the vertical height
    of the device.  Line widths are typically between 0.1 and 0.3.
 
Syntax:
    <prefix>TIC MARK THICKNESS  <thick>
    where
            no prefix     refers to all 4 sides;
            the prefix X  refers to both horizontal sides;
            the prefix Y  refers to both vertical sides;
            the prefix X1 refers to the lower horizontal side;
            the prefix X2 refers to the upper horizontal side;
            the prefix Y1 refers to the left  vertical   side;
            the prefix Y2 refers to the right vertical   side;
    and   <size> is a number or parameter in the range 0 to 100 that
            specifies the desired tic mark thickness.
 
Examples:
    TIC MARK THICKNESS 0.1
    TIC MARK THICKNESS 0.2
    TIC MARK THICKNESS
    X2TIC MARK THICKNESS 0.1
    Y2TIC MARK THICKNESS 0.3
 
Note:
    It is rare to assign different thicknesses to tic marks on the 4
    different sides.  Whatever thickness is chosen for one side is
    invariable chosen for all sides.  The most common form (by far) for
    this command is the first one (with no prefix) which defines the
    thickness uniformly for tic marks on all 4 frame sides.
 
Note:
    A ...TIC MARK THICKNESS command with no arguments reverts the
    setting to default; thus X1TIC MARK THICKNESS with no arguments
    reverts the bottom horizontal tics thickness to 0.1.  A ...TIC MARK
    THICKNESS command with no prefix refers to all 4 sides; thus TIC
    MARK THICKNESS 0.2 sets tic mark thickness to 0.2 for all 4 frame
    lines.  TIC MARK THICKNESS with no prefix and no arguments reverts
    the tic thickness settings on all 4 sides to default.
 
Default:
    All tic mark thicknesses are 0.1.
 
Synonyms:
    TIC THICKNESS is a synonym for TIC MARK THICKNESS, as in TIC
    THICKNESS 0.1 and X2TIC THICKNESS 0.2.
 
Related Commands:
    TIC MARK            = Specifies whether or not tics are drawn.
    TIC MARK COLOR      = Sets the color for tic marks.
    TIC MARK OFFSET     = Sets the offset for the first and last tic
                           marks.
    TIC MARK POSITION   = Sets location of tic marks (inside/outside
                          through).
    TIC MARK SIZE       = Sets the size of tic marks.
 
Applications:
    XX
 
Implementation Date:
    89/2
 
Program:
    . POLLUTION SOURCE ANALYSIS, LLOYD CURRIE, DATE--1990
    . SUBSET OF CURRIE.DAT REFERENCE FILE
    .
    LET LEAD = DATA ...
       164 426 59 98 312 263 607 497 213 54 160 262 547 325 419 94 70
    LET POT = DATA ...
       106 175 61 79 94 121 424 328 107 218 140 179 246 231 245 339 99
    .
    X1LABEL LEAD; Y1LABEL POTASSIUM
    LINE BLANK ALL; CHARACTER CIRCLE; CHARACTER FILL ON
    .
    TIC MARK SIZE 3.0
    X1TIC MARK THICKNESS 0.5
    Y1TIC MARK THICKNESS 0.2
    TITLE DEMONSTRATE TIC SIZE
    PLOT POT LEAD
 
-----TIC MARK LABEL--------------------------------------------------
 
TIC MARK LABEL
 
Name:
    ...TIC MARK LABEL
 
Type:
    Plot Control Command
 
Purpose:
    Specifies whether or not the labels associated with the major tic
    marks will appear on subsequent plots.
 
Syntax:
    <prefix>TIC MARK LABEL   <ON or OFF>
    where
            no prefix     refers to all 4 sides;
            the prefix X  refers to both horizontal sides;
            the prefix Y  refers to both vertical sides;
            the prefix X1 refers to the lower horizontal side;
            the prefix X2 refers to the upper horizontal side;
            the prefix Y1 refers to the left  vertical   side;
            the prefix Y2 refers to the right vertical   side;
    and ON specifies that the tic mark labels will appear while OFF
            specifies that they do not.
 
Examples:
    TIC MARK LABEL ON
    TIC MARK LABEL OFF
    TIC MARK LABEL
    X2TIC MARK LABEL ON
    Y2TIC MARK LABEL ON
 
Note:
    The appearance of the tic mark labels is independent of the
    appearance of the tic marks.  However, no tic mark labels are
    drawn if the frame line is not drawn.
 
Note:
    A ...TIC MARK LABEL command with no arguments reverts the setting
    to default; thus X1TIC MARK LABEL with no arguments reverts the
    bottom horizontal tic labels to on.  A ...TIC MARK LABEL command
    with no prefix refers to all 4 sides; thus TIC MARK LABEL OFF
    suppresses the tic mark labels for all 4 frame lines.  TIC MARK
    LABEL with no prefix and no arguments reverts the tic label
    settings on all 4 sides to default.
 
Default:
    The tic mark labels appear on the left and bottom lines only.
 
Synonyms:
    TICS LABEL is a synonym for TIC MARK LABEL, as in TICS LABEL ON
    and X2TICS LABEL OFF.
 
Related Commands:
    TIC MARK LABEL ANGLE       = Sets the angle for tic labels.
    TIC MARK LABEL CASE        = Sets case for tic labels.
    TIC MARK LABEL COLOR       = Sets the color for tic labels.
    TIC MARK LABEL CONTENTS    = Specify alphanumeric values for tic
                                 labels.
    TIC MARK LABEL DECIMALS    = Sets the number of decimals for tic
                                 labels.
    TIC MARK LABEL DIRECTION   = Sets the direction (horizontal/
                                 vertical) for TIC MARK labels.
    TIC MARK LABEL DISPLACE    = Sets the distance between tic labels
                                 and the frame.
    TIC MARK LABEL FONT        = Sets the font for tic labels.
    TIC MARK LABEL FORMAT      = Sets the format (alphanumeric,
                                 exponential, power of 10) for tic
                                 labels.
    TIC MARK LABEL HW          = Sets the height and width for tic
                                 labels.
    TIC MARK LABEL JUST        = Sets the justification for tic labels.
    TIC MARK LABEL SIZE        = Sets the height for tic labels.
    TIC MARK LABEL THICKNESS   = Sets the line width for tic labels.
    TIC MARK                   = Specifies whether tic marks or drawn.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    . POLLUTION SOURCE ANALYSIS, LLOYD CURRIE, DATE--1990
    . SUBSET OF CURRIE.DAT REFERENCE FILE
    .
    LET ID2 = DATA 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2
    LET LEAD = DATA ...
       164 426 59 98 312 263 607 497 213 54 160 262 547 325 419 94 70
    LET POT = DATA ...
       106 175 61 79 94 121 424 328 107 218 140 179 246 231 245 339 99
    .
    TITLE AUTOMATIC
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    X1LABEL LEAD; Y1LABEL POTASSIUM
    LINE BLANK ALL; CHARACTER CIRCLE; CHARACTER FILL ON
    PLOT POT LEAD
    .
    TIC MARKS ON
    TIC MARK LABELS ON
    PLOT POT LEAD
    .
    TIC MARK LABELS OFF
    PLOT POT LEAD
    .
    X1TIC MARK LABELS ON
    X2TIC MARK LABELS OFF
    Y1TIC MARK LABELS ON
    Y2TIC MARK LABELS ON
    PLOT POT LEAD
    END OF MULTIPLOT
 
-----TIC MARK LABEL ANGLE---------------------------------------------
 
TIC MARK LABEL ANGLE
 
Name:
    ...TIC MARK LABEL ANGLE
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the angle of the labels associated with the major tic
    marks on subsequent plots.
 
Description:
    This command allows tic labels to be rotated from their default
    orientation.  By default, tic labels are printed horizontally
    (i.e., angle of 0.0) for both the X and Y axis.  The most common
    uses of this command are:
       1) Some analysts prefer that the vertical tic labels be drawn
          vertically;
       2) Tic labels can overlap on the horizontal axis if they are
          long or there are a large number of them.  This occurs
          often with alphabetic tic labels.  This command can be used
          to draw the horizontal labels vertically or at an angle (45
          degrees is often used).
    This command only applies if the labels are drawn with a software
    font (e.g., SIMPLEX).  The command TIC MARK LABEL DIRECTION can be
    used to set horizontal or vertical text if the tic label is drawn
    with a hardware character.
 
Syntax:
    <prefix>TIC MARK LABEL ANGLE   <angle>
    where
            no prefix     refers to all 4 sides;
            the prefix X  refers to both horizontal sides;
            the prefix Y  refers to both vertical sides;
            the prefix X1 refers to the lower horizontal side;
            the prefix X2 refers to the upper horizontal side;
            the prefix Y1 refers to the left  vertical   side;
            the prefix Y2 refers to the right vertical   side;
    and <angle> is a number or parameter that specifies the desired
            angle.
 
Examples:
    TIC MARK LABEL ANGLE 0.
    TIC MARK LABEL ANGLE 45.
    TIC MARK LABEL ANGLE
    X2TIC MARK LABEL ANGLE 90.
    Y2TIC MARK LABEL ANGLE 90.
 
Note:
    A ...TIC MARK LABEL ANGLE command with no arguments reverts the
    setting to default; thus X1TIC MARK LABEL ANGLE with no arguments
    reverts the bottom horizontal tic label angle to 0.0.  A ...TIC
    MARK LABEL ANGLE command with no prefix refers to all 4 sides; thus
    TIC MARK LABEL ANGLE 0. sets tic mark angles to 0. for all 4 frame
    lines.  TIC MARK LABEL ANGLE with no prefix and no arguments
    reverts the tic label angle to default on all 4 sides.
 
Default:
    All tic mark labels 0 degrees (i.e., horizontal).
 
Synonyms:
    TICS LABEL ANGLE is a synonym for TIC MARK LABEL ANGLE,
    as in TICS LABEL ANGLE 0. and X2TICS LABEL ANGLE 90.
 
Related Commands:
    TIC MARK LABEL             = Specifies whether or not tic mark
                                 labels or drawn.
    TIC MARK LABEL CASE        = Sets case for tic labels.
    TIC MARK LABEL COLOR       = Sets the color for tic labels.
    TIC MARK LABEL CONTENTS    = Specify alphanumeric values for tic
                                 labels.
    TIC MARK LABEL DECIMALS    = Sets the number of decimals for tic
                                 labels.
    TIC MARK LABEL DIRECTION   = Sets the direction (horizontal/
                                 vertical) for TIC MARK labels.
    TIC MARK LABEL DISPLACE    = Sets the distance between tic labels
                                 and the frame.
    TIC MARK LABEL FONT        = Sets the font for tic labels.
    TIC MARK LABEL FORMAT      = Sets the format (alphanumeric,
                                 exponential, power of 10) for tic
                                 labels.
    TIC MARK LABEL HW          = Sets the height and width for tic
                                 labels.
    TIC MARK LABEL JUST        = Sets the justification for tic labels.
    TIC MARK LABEL SIZE        = Sets the height for tic labels.
    TIC MARK LABEL THICKNESS   = Sets the line width for tic labels.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    89/2
 
Program:
    LEGEND 1 PRESENTATION GRAPHICS
    LEGEND 2 3-D BAR HISTOGRAM
    .
    LET Y = DATA 392 341 307 203 115 59 38 32 29 28
    .
    LET N = NUMBER Y
    LET X = SEQUENCE 1 1 N
    .
    LINES BLANK ALL; BAR ON ALL
    BAR WIDTH .5 ALL; BAR DIMENSION 3 ALL; BAR FILL ONTS ALL
    .
    XLIMITS 1 10; XTIC OFFSET 1 1
    MAJOR XTIC MARK NUMBER 10; MINOR XTIC MARK NUMBER 0
    X1TIC MARK LABEL FORMAT ALPHA
    X1TIC MARK LABEL CONTENT APOLLO SUN HP DEC SYM SGI IBM DG TI XEROX
    X1TIC MARK LABEL ANGLE 45
    .
    YLIMITS 0 500
    Y1TIC MARK LABEL ANGLE 90
    Y1TIC MARK LABEL JUSTIFICATION CECE
    .
    TIC MARK LABEL FONT DUPLEX
    TITLE DEMONSTRATE TIC LABEL ANGLE
    PLOT Y X X
 
-----TIC MARK LABEL CASE--------------------------------------------
 
TIC MARK LABEL CASE
 
Name:
    ...TIC MARK LABEL CASE
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the case of the labels associated with the major tic
    marks on subsequent plots.
 
Description:
    The case can be either upper, lower, or as entered on the command
    line.  This command only applies if alphabetic labels are being
    printed (i.e., the TIC LABEL CONTENT command is used).
 
    Unless ASIS is specified, the case the text is entered on the
    command line is ignored.  The UPPER or LOWER argument is used to
    specify the default case and the UC() and LC() character sequences
    within the text are used to shift case.  The ASIS clause is the
    more convenient way to enter case shifts, but this is not available
    in older versions of Dataplot.
 
Syntax:
    <prefix>TIC MARK LABEL CASE   <UPPER/LOWER/ASIS>
    where
            no prefix     refers to all 4 sides;
            the prefix X  refers to both horizontal sides;
            the prefix Y  refers to both vertical sides;
            the prefix X1 refers to the lower horizontal side;
            the prefix X2 refers to the upper horizontal side;
            the prefix Y1 refers to the left  vertical   side;
            the prefix Y2 refers to the right vertical   side;
    and UPPER specifies upper case, LOWER specifies lower case, and
            ASIS specifies that the case is preserved as entered on
            the command line.
 
Examples:
    TIC MARK LABEL CASE UPPER
    TIC MARK LABEL CASE LOWER
    TIC MARK LABEL CASE
    X2TIC MARK LABEL CASE LOWER
    Y2TIC MARK LABEL CASE LOWER
 
Note:
    The TIC MARK LABEL CASE command sets the default case.  Case
    changes signified by the LC() and UC() character sequences within
    text strings are still honored.  The UC() and LC() case shifts
    are supported for both hardware and software generated characters.
 
Note:
    For tic labels, it is often desirable to have a "blank" label.
    This is accomplished by entering SP() (the space character) for the
    label.  This works for both hardware and software generated
    characters.
 
Note:
    It is rare to assign different cases to tic mark labels on the 4
    different sides.  Whatever case is chosen for tic labels on one
    side is invariably chosen for all sides.  The most common form (by
    far) for this command is the general one (with no prefix, as in
    TIC MARK LABEL CASE LOWER) which defines the case uniformly for tic
    mark labels on all 4 frame sides.
 
Note:
    A ...TIC MARK LABEL CASE command with no arguments reverts the
    setting to default; thus X1TIC MARK LABEL CASE with no arguments
    reverts the bottom horizontal tic label case to upper.  A ...TIC
    MARK LABEL CASE command with no prefix refers to all 4 sides; thus
    TIC MARK LABEL CASE LOWER sets tic mark labels to lower case for
    all 4 frame lines.  TIC MARK LABEL CASE with no prefix and no
    arguments reverts the tic label case to default on all 4 sides.
 
Default:
    All tic mark labels are upper case.
 
Synonyms:
    TICS LABEL CASE is a synonym for TIC MARK LABEL CASE, as in TICS
    LABEL CASE UPPER and X2TICS LABEL CASE LOWER.
 
Related Commands:
    TIC MARK LABEL             = Specifies whether or not tic mark
                                 labels or drawn.
    TIC MARK LABEL ANGLE       = Sets the angle for tic labels.
    TIC MARK LABEL COLOR       = Sets the color for tic labels.
    TIC MARK LABEL CONTENTS    = Specify alphanumeric values for tic
                                 labels.
    TIC MARK LABEL DECIMALS    = Sets the number of decimals for tic
                                 labels.
    TIC MARK LABEL DIRECTION   = Sets the direction (horizontal/
                                 vertical) for TIC MARK labels.
    TIC MARK LABEL DISPLACE    = Sets the distance between tic labels
                                 and the frame.
    TIC MARK LABEL FONT        = Sets the font for tic labels.
    TIC MARK LABEL FORMAT      = Sets the format (alphanumeric,
                                 exponential, power of 10) for tic
                                 labels.
    TIC MARK LABEL HW          = Sets the height and width for tic
                                 labels.
    TIC MARK LABEL JUST        = Sets the justification for tic labels.
    TIC MARK LABEL SIZE        = Sets the height for tic labels.
    TIC MARK LABEL THICKNESS   = Sets the line width for tic labels.
 
Applications:
    XX
 
Implementation Date:
    The ASIS clause was implemented 93/7.
 
Program:
    LEGEND 1 PRESENTATION GRAPHICS
    LEGEND 2 3-D BAR HISTOGRAM
    LET Y = DATA 392 341 307 203 115 59 38 32 29 28
    LET N = NUMBER Y
    LET X = SEQUENCE 1 1 N
    .
    LINES BLANK ALL; BAR ON ALL
    BAR WIDTH .5 ALL; BAR DIMENSION 3 ALL; BAR FILL ONTS ALL
    .
    XLIMITS 1 10; XTIC OFFSET 1 1
    MAJOR XTIC MARK NUMBER 10; MINOR XTIC MARK NUMBER 0
    X1TIC MARK LABEL FORMAT ALPHA
    X1TIC MARK LABEL CONTENT Apollo Sun HP DEC SYM SGI IBM DG TI Xerox
    X1TIC MARK LABEL CASE ASIS
    YLIMITS 0 500
    .
    TITLE DEMONSTRATE TIC LABEL CASE
    PLOT Y X X
 
-----TIC MARK LABEL COLOR--------------------------------------------
 
TIC MARK LABEL COLOR
 
Name:
    ...TIC MARK LABEL COLOR
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the color of the labels associated with the major tic
    marks on subsequent plots.
 
Description:
    Dataplot provides two methods for specifying colors.

        1. Colors can be defined by name (or by the corresponding index).
           Dataplot adopted it's named colors from the X11 project.
           Currently, 162 named colors and 100 levels of grayscale are
           supported.  Grayscale can be specified with either G0, G1, ...,
           G100 (or -1, -2, ..., -100).  Many older devices support only a
           limited number of colors.  For these devices, unsupported colors
           will be mapped to one of the available colors.  To specify a
           named color, see Syntax 1.

        2. Most modern graphics devices support full RGB (RedBlueGreen)
           color.  You can alternatively specify RGB colors by entering
           three integer values to represent the Red, Green and Blue
           components, respectively.  These values should be in the range
           0 to 255.

    When setting the tic mark label RGB color, Dataplot first checks if
    the device supports RGB colors. If not, the named color will be used.
    If the device does support RGB color, Dataplot will check if an RGB
    color has been specified.  If yes, then that RGB color is used.  If
    not, the named color will be used.

    To see the list of supported named colors (with the associated index
    number), see

    https://www.itl.nist.gov/div898/software/dataplot/refman1/ch11/homepage.htm

Syntax 1:
    <prefix>TIC MARK LABEL COLOR   <color>
    where
            no prefix     refers to all 4 sides;
            the prefix X  refers to both horizontal sides;
            the prefix Y  refers to both vertical sides;
            the prefix X1 refers to the lower horizontal side;
            the prefix X2 refers to the upper horizontal side;
            the prefix Y1 refers to the left  vertical   side;
            the prefix Y2 refers to the right vertical   side;
    and <color> is a character string that specifies the desired color
            for the tic label.
 
Syntax 2:
    <prefix>TIC MARK LABEL RGB COLOR <red> <green> <blue>
    where
              no prefix     refers to all 4 sides;
              the prefix X  refers to both horizontal sides;
              the prefix Y  refers to both vertical sides;
              the prefix X1 refers to the lower horizontal side;
              the prefix X2 refers to the upper horizontal side;
              the prefix Y1 refers to the left  vertical   side;
              the prefix Y2 refers to the right vertical   side.
          <red> is a number or parameter that specifies the red
              component;
          <green> is a number or parameter that specifies the green
              component;
    and   <blue> is a number or parameter that specifies the blue
              component.

    To turn off the RGB color, set the values to -1 (any negative value
    will work).  Values greater than 255 will be set to 255.
 
Examples:
    TIC MARK LABEL COLOR GREEN
    TIC MARK LABEL COLOR
    X2TIC MARK LABEL COLOR GREEN
    Y2TIC MARK LABEL COLOR GREEN
    TIC MARK LABEL RGB COLOR 220 109 88
    TIC MARK LABEL RGB COLOR 175 238 238
 
Note:
    It is rare to assign different colors to tic mark labels on the 4
    different sides.  Whatever color is chosen for tic labels on one
    side is invariably chosen for all sides.  The most common form (by
    far) for this command is the general one (with no prefix, as in TIC
    MARK LABEL COLOR GREEN) which defines the color uniformly for tic
    mark labels on all 4 frame sides.
 
Note:
    A ...TIC MARK LABEL COLOR command with no arguments reverts the
    setting to default; thus X1TIC MARK LABEL COLOR with no arguments
    reverts the bottom horizontal tic label color to black.  A ...TIC
    MARK LABEL COLOR command with no prefix refers to all 4 sides; thus
    TIC MARK LABEL COLOR GREEN sets tic mark labels to green for all 4
    frame lines.  TIC MARK LABEL COLOR with no prefix and no arguments
    reverts the tic label color to default on all 4 sides.
 
Default:
    All tic mark labels are black.
 
Synonyms:
    TIC LABEL COLOR is a synonym for TIC MARK LABEL COLOR, as in TIC
    LABEL COLOR GREEN and X2TIC LABEL COLOR YELLOW.
 
Related Commands:
    TIC MARK LABEL             = Specifies whether or not tic mark
                                 labels or drawn.
    TIC MARK LABEL ANGLE       = Sets the angle for tic labels.
    TIC MARK LABEL CASE        = Sets case for tic labels.
    TIC MARK LABEL CONTENTS    = Specify alphanumeric values for tic
                                 labels.
    TIC MARK LABEL DECIMALS    = Sets the number of decimals for tic
                                 labels.
    TIC MARK LABEL DIRECTION   = Sets the direction (horizontal/
                                 vertical) for TIC MARK labels.
    TIC MARK LABEL DISPLACE    = Sets the distance between tic labels
                                 and the frame.
    TIC MARK LABEL FONT        = Sets the font for tic labels.
    TIC MARK LABEL FORMAT      = Sets the format (alphanumeric,
                                 exponential, power of 10) for tic
                                 labels.
    TIC MARK LABEL HW          = Sets the height and width for tic
                                 labels.
    TIC MARK LABEL JUST        = Sets the justification for tic labels.
    TIC MARK LABEL SIZE        = Sets the height for tic labels.
    TIC MARK LABEL THICKNESS   = Sets the line width for tic labels.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    Pre-1987
    2020/11: Support for RGB colors.
 
Program 1:
    LEGEND 1 PRESENTATION GRAPHICS
    LEGEND 2 3-D BAR HISTOGRAM
    LET Y = DATA 392 341 307 203 115 59 38 32 29 28
    LET N = NUMBER Y
    LET X = SEQUENCE 1 1 N
    .
    LINES BLANK ALL
    BAR ON ALL
    BAR WIDTH .5 ALL
    BAR DIMENSION 3 ALL
    BAR FILL ONTS ALL
    .
    XLIMITS 1 10
    XTIC OFFSET 1 1
    MAJOR XTIC MARK NUMBER 10
    MINOR XTIC MARK NUMBER 0
    X1TIC MARK LABEL FORMAT ALPHA
    X1TIC MARK LABEL CONTENT Apollo Sun HP DEC SYM SGI IBM DG TI Xerox
    X1TIC MARK LABEL CASE ASIS
    X1TIC MARK LABEL COLOR RED
    Y1TIC MARK LABEL COLOR BLUE
    YLIMITS 0 500
    .
    TITLE DEMONSTRATE TIC MARK LABEL COLOR
    PLOT Y X X
 
Program 2:
    LEGEND 1 PRESENTATION GRAPHICS
    LEGEND 2 3-D BAR HISTOGRAM
    LET Y = DATA 392 341 307 203 115 59 38 32 29 28
    LET N = NUMBER Y
    LET X = SEQUENCE 1 1 N
    .
    LINES BLANK ALL
    BAR ON ALL
    BAR WIDTH .5 ALL
    BAR DIMENSION 3 ALL
    BAR FILL ONTS ALL
    .
    XLIMITS 1 10
    XTIC OFFSET 1 1
    MAJOR XTIC MARK NUMBER 10
    MINOR XTIC MARK NUMBER 0
    X1TIC MARK LABEL FORMAT ALPHA
    X1TIC MARK LABEL CONTENT Apollo Sun HP DEC SYM SGI IBM DG TI Xerox
    X1TIC MARK LABEL CASE ASIS
    X1TIC MARK LABEL COLOR RED
    Y1TIC MARK LABEL COLOR BLUE
    X1TIC MARK LABEL RGB COLOR 220 109 88
    Y1TIC MARK LABEL RGB COLOR 175 238 238
    YLIMITS 0 500
    .
    TITLE DEMONSTRATE TIC MARK LABEL COLOR
    PLOT Y X X
 
-----TIC MARK LABEL CONTENTS------------------------------------------
 
TIC MARK LABEL CONTENTS
 
Name:
    ...TIC MARK LABEL CONTENTS
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the contents of the labels associated with the major tic
    marks on subsequent plots.
 
Description:
    This command is used in conjunction with the TIC MARK LABEL FORMAT
    ALPHA command to specify alphanumeric tic mark labels (the LIMITS
    and MAJOR TIC MARK NUMBER commands are also used to control the
    number of major tic marks).
 
    If the TIC MARK FORMAT command is set to either GROUP LABEL
    or VARIABLE, the tic mark label contents are obtained from the
    specified variable.  Note that the contents of the variable are
    extracted when the plot is generated, not when the TIC MARK
    LABEL CONTENT command is entered.

    Many plots can be enhanced by sorting the data according to
    some criteria. If the TIC MARK FORMAT command is set to either
    GROUP LABEL, ROW LABEL, or VARIABLE, the tic mark label contents
    can be sorted by an index variable.  This simplies the
    generation of these sorted plots.  Enter HELP SORT BY for
    details and for some examples of the use of the TIC MARK
    LABEL CONTENTS command with an index variable.  Note that
    the indexing is based on the contents of the index variable
    at the time the plot is generated, not when the TIC MARK
    LABEL CONTENTS command is entered.

Syntax 1:
    <prefix>TIC MARK LABEL CONTENTS   <lab1> <lab2>  <lab3> etc.
    where
           no prefix     refers to all 4 sides;
           the prefix X  refers to both horizontal sides;
           the prefix Y  refers to both vertical sides;
           the prefix X1 refers to the lower horizontal side;
           the prefix X2 refers to the upper horizontal side;
           the prefix Y1 refers to the left  vertical   side;
           the prefix Y2 refers to the right vertical   side.
    and <lab1>, <lab2>, and so on are the strings to use for the tic
           labels.
 
Syntax 2:
    <prefix>TIC MARK LABEL CONTENTS   <varname>
    where <varname> is the name of a numeric variable or a group
              label variable.

    This syntax applies when a TIC MARK FORMAT GROUP LABEL or a
    TIC MARK LABEL FORMAT VARIABLE command has been entered.

Syntax 3:
    <prefix>TIC MARK LABEL CONTENTS   <varname>   <indx>
    where <varname> is the name of a numeric variable or a group
              label variable;
    and    <indx> is the name of a variable that will be used to
              sort the tic label contents.

    This syntax applies when a TIC MARK FORMAT GROUP LABEL or a
    TIC MARK LABEL FORMAT VARIABLE command has been entered.

Syntax 4:
    <prefix>TIC MARK LABEL CONTENTS   <indx>
    where <indx> is the name of a variable that will be used to
              sort the tic label contents.

    This syntax applies when a TIC MARK FORMAT ROW LABEL command
    has been entered.

Examples:
    TIC MARK LABEL CONTENTS JANUARY FEBRUARY MARCH
    TIC MARK LABEL CONTENTS SMALL MEDIUM LARGE
    TIC MARK LABEL CONTENTS A B C D E F
    X2TIC MARK LABEL CONTENTS SMALL MEDIUM LARGE
    Y2TIC MARK LABEL CONTENTS SMALL MEDIUM LARGE
 
Note:
    If you want one or more of the tic labels to be blank, enter
    the label as SP().  For a multi-line label, enter CR() to
    denote a line break.

    This works for both hardware and software generated characters.
 
Note:
    A non-obvious use of this command is to generate a reverse axis.
    For example, the analyst may want the horizontal axis to go from
    1000 to 1.  This can be accomplished with the following commands
    (assume the points to be plotted are in Y and X):
        MAJOR XTIC MARK NUMBER 11
        MINOR XTIC MARK NUMBER 4
        XLIMITS -1000 0
        XTIC MARK LABEL FORMAT ALPHA
        XTIC LABEL CONTENT 1000 900 800 700 600 500 400 300 200 100 0
        LET X2 = - X
        PLOT Y X2
 
Default:
    All tic mark labels are numeric.
 
Synonyms:
    TIC LABEL CONTENTS is a synonym for TIC MARK LABEL CONTENTS, as in
    TIC LABEL CONTENTS A B C and X2TIC LABEL CONTENTS A B C.
 
Related Commands:
    TIC MARK LABEL             = Specifies whether or not tic mark
                                 labels or drawn.
    TIC MARK LABEL ANGLE       = Sets the angle for tic labels.
    TIC MARK LABEL CASE        = Sets case for tic labels.
    TIC MARK LABEL COLOR       = Sets the color for tic labels.
    TIC MARK LABEL DECIMALS    = Sets the number of decimals for tic
                                 labels.
    TIC MARK LABEL DIRECTION   = Sets the direction (horizontal/
                                 vertical) for TIC MARK labels.
    TIC MARK LABEL DISPLACE    = Sets the distance between tic labels
                                 and the frame.
    TIC MARK LABEL FONT        = Sets the font for tic labels.
    TIC MARK LABEL FORMAT      = Sets the format (alphanumeric, power
                                 of 10, exponential) for tic labels.
    TIC MARK LABEL HW          = Sets the height and width for tic
                                 labels.
    TIC MARK LABEL JUST        = Sets the justification for tic labels.
    TIC MARK LABEL SIZE        = Sets the height for tic labels.
    TIC MARK LABEL THICKNESS   = Sets the line width for tic labels.
    SORT BY                    = Sorts a group-id variable based on
                                 the values of a user-specified
                                 statistic.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    1988/2
    2004/1: Added support for group labels and numeric variables
            to specify the contents of tic mark labels.
    2006/1: Added support for the indexing of the tic mark label
            contents.
 
Program 1:
    LEGEND 1 PRESENTATION GRAPHICS
    LEGEND 2 3-D BAR HISTOGRAM
    .
    LET Y = DATA 392 341 307 203 115 59 38 32 29 28
    .
    LET N = NUMBER Y
    LET X = SEQUENCE 1 1 N
    .
    LINES BLANK ALL; BAR ON ALL
    BAR WIDTH .5 ALL; BAR DIMENSION 3 ALL; BAR FILL ONTS ALL
    .
    XLIMITS 1 10; XTIC OFFSET 1 1
    MAJOR XTIC MARK NUMBER 10; MINOR XTIC MARK NUMBER 0
    X1TIC MARK LABEL FORMAT ALPHA
    X1TIC MARK LABEL CONTENT Apollo Sun HP DEC SYM SGI IBM DG TI Xerox
    X1TIC MARK LABEL CASE ASIS
    .
    YLIMITS 0 500
    .
    TITLE DEMONSTRATE TIC LABEL CONTENT
    PLOT Y X X
 
Program 2:
    set convert character on
    skip 25
    read draft69c.dat rank day month
    .
    let ig = group label month
    x1tic mark label format group label
    x1tic mark label content ig
    x1tic mark label font simplex
    x1tic mark label angle 45
    x1tic mark label displacement 10
    let xcode = character code month
    .
    major xtic mark number 12
    minor xtic mark number 0
    xlimits 1 12
    xtic offset 0.5 0.5
    .
    char box plot
    line box plot
    fences on
    .
    box plot rank xcode

-----TIC MARK LABEL DECIMALS------------------------------------------
 
TIC MARK LABEL DECIMALS
 
Name:
    ...TIC MARK LABEL DECIMALS
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the number of digits to the right of the decimal for the
    tic mark labels on subsequent plots.
 
Description:
    This command is typically used to generate tic mark labels that
    line up neatly for presentation quality graphics.
 
Syntax:
    <prefix>TIC MARK LABEL DECIMALS   <decimal>
    where
            no prefix     refers to all 4 sides;
            the prefix X  refers to both horizontal sides;
            the prefix Y  refers to both vertical sides;
            the prefix X1 refers to the lower horizontal side;
            the prefix X2 refers to the upper horizontal side;
            the prefix Y1 refers to the left  vertical   side;
            the prefix Y2 refers to the right vertical   side;
    and <decimal> is a number or parameter that specifies the desired
            number of digits to the right of the decimal point.
 
Examples:
    TIC MARK LABEL DECIMALS 2
    TIC MARK LABEL DECIMALS 0
    TIC MARK LABEL DECIMALS 1
    X2TIC MARK LABEL DECIMALS 3
    Y2TIC MARK LABEL DECIMALS 2
 
Note:
    A ...TIC MARK LABEL DECIMALS command with no arguments reverts the
    setting to default; thus X1TIC MARK LABEL DECIMALS with no
    arguments reverts the bottom horizontal tic label decimal places to
    data dependent.  A ...TIC MARK LABEL DECIMALS command with no
    prefix refers to all 4 sides; thus TIC MARK LABEL DECIMALS 2 sets
    tic mark label decimal places to 2 for all 4 frame lines.  TIC MARK
    LABEL DECIMALS with no prefix and no arguments reverts the tic
    label decimal settings on all 4 sides to default.
 
Default:
    The number of decimals is data dependent.
 
Synonyms:
    TIC LABEL DECIMALS is a synonym for TIC MARK LABEL DECIMALS, as in
    TIC LABEL DECIMALS 2 and X2TIC LABEL DECIMALS 2.
 
Related Commands:
    TIC MARK LABEL             = Specifies whether or not tic mark
                                 labels or drawn.
    TIC MARK LABEL ANGLE       = Sets the angle for tic labels.
    TIC MARK LABEL CASE        = Sets case for tic labels.
    TIC MARK LABEL COLOR       = Sets the color for tic labels.
    TIC MARK LABEL CONTENTS    = Specify alphanumeric values for tic
                                 labels.
    TIC MARK LABEL DIRECTION   = Sets the direction (horizontal/
                                 vertical) for TIC MARK labels.
    TIC MARK LABEL DISPLACE    = Sets the distance between tic labels
                                 and the frame.
    TIC MARK LABEL FONT        = Sets the font for tic labels.
    TIC MARK LABEL FORMAT      = Sets the format (alphanumeric, power
                                 of 10, exponential) for tic labels.
    TIC MARK LABEL HW          = Sets the height and width for tic
                                 labels.
    TIC MARK LABEL JUST        = Sets the justification for tic labels.
    TIC MARK LABEL SIZE        = Sets the height for tic labels.
    TIC MARK LABEL THICKNESS   = Sets the line width for tic labels.
 
Applications:
    Presentation quality graphics.
 
Implementation Date:
    XX
 
Program:
    SKIP 25
    READ BERGER1.DAT X Y BATCH
    LINE BLANK DASH
    CHARACTER X BLANK
    YTIC LABEL DECIMALS 2
    XTIC LABEL DECIMALS 1
    XTIC OFFSET 0.2 0.2
    Y1LABEL SLOPE
    X1LABEL SAMPLE ID
    TITLE AUTOMATIC
    LINEAR SLOPE PLOT Y X BATCH
 
-----TIC MARK LABEL DIRECTION------------------------------------
 
TIC MARK LABEL DIRECTION
 
Name:
    ...TIC MARK LABEL DIRECTION
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the direction of the labels associated with the major tic
    marks on subsequent plots.
 
Syntax:
    <prefix>TIC MARK LABEL DIRECTION   <HORIZONTAL or VERTICAL>
    where
            no prefix     refers to all 4 sides;
            the prefix X  refers to both horizontal sides;
            the prefix Y  refers to both vertical sides;
            the prefix X1 refers to the lower horizontal side;
            the prefix X2 refers to the upper horizontal side;
            the prefix Y1 refers to the left  vertical   side;
            the prefix Y2 refers to the right vertical   side.
            the prefix Y2 refers to the right vertical   side;
    and HORIZONTAL specifies that the text is drawn horizontally while
            VERTICAL specifies that the text is drawn vertically.
 
Examples:
    TIC MARK LABEL DIRECTION VERTICAL
    TIC MARK LABEL DIRECTION HORIZONTAL
    TIC MARK LABEL DIRECTION
    X2TIC MARK LABEL DIRECTION VERTICAL
    Y2TIC MARK LABEL DIRECTION VERTICAL
 
Note:
    A ...TIC MARK LABEL DIRECTION command with no arguments reverts the
    setting to default; thus X1TIC MARK LABEL DIRECTION with no
    arguments reverts the bottom horizontal tic label direction to
    horizontal.  A ...TIC MARK LABEL DIRECTION command with no prefix
    refers to all 4 sides; thus TIC MARK LABEL DIRECTION VERTICAL sets
    tic mark labels to vertical for all 4 frame lines.  TIC MARK LABEL
    DIRECTION with no prefix and no arguments reverts the tic label
    direction settings on all 4 sides to default.
 
Note:
    This command applies for tic labels drawn with a hardware font.  If
    the tic label is drawn with a software font, use the TIC LABEL
    ANGLE command.  Some devices (e.g., Postscript, HP-GL) can rotate
    hardware characters while other devices (e.g., X11) cannot.
    Dataplot will draw vertical strings rotated 90 degrees on those
    devices that can rotate hardware characters.  Otherwise, it draws
    them as a column of single horizontal characters.  At this time,
    it does not support directions other than horizontal and vertical
    even for devices such as Postscript that allow arbritrary rotation
    angles for hardware text.
 
Note:
    The most common use of this command is to print the vertical axis
    tic labels vertically (YTIC LABEL DIRECTION VERTICAL).  It is also
    occasionally used to print horizontal alpanumeric labels vertically
    to avoid overlap.
 
Default:
    All tic mark labels are drawn horizontally.
 
Synonyms:
    TIC LABEL DIRECTION is a synonym for TIC MARK LABEL DIRECTION, as
    in TIC LABEL DIRECTION VERT and X2TIC LABEL DIRECTION HORI.
 
Related Commands:
    TIC MARK LABEL             = Specifies whether or not tic mark
                                 labels or drawn.
    TIC MARK LABEL ANGLE       = Sets the angle for tic labels.
    TIC MARK LABEL CASE        = Sets case for tic labels.
    TIC MARK LABEL COLOR       = Sets the color for tic labels.
    TIC MARK LABEL CONTENTS    = Specify alphanumeric values for tic
                                 labels.
    TIC MARK LABEL DECIMALS    = Sets the number of decimals for tic
                                 labels.
    TIC MARK LABEL DISPLACE    = Sets the distance between tic labels
                                 and the frame.
    TIC MARK LABEL FONT        = Sets the font for tic labels.
    TIC MARK LABEL FORMAT      = Sets the format (alphanumeric, power
                                 of 10, exponential) for tic labels.
    TIC MARK LABEL HW          = Sets the height and width for tic
                                 labels.
    TIC MARK LABEL JUST        = Sets the justification for tic labels.
    TIC MARK LABEL SIZE        = Sets the height for tic labels.
    TIC MARK LABEL THICKNESS   = Sets the line width for tic labels.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    89/2
 
Program:
    LEGEND 1 PRESENTATION GRAPHICS
    LEGEND 2 3-D BAR HISTOGRAM
    .
    LET Y = DATA 392 341 307 203 115 59 38 32 29 28
    .
    LET N = NUMBER Y
    LET X = SEQUENCE 1 1 N
    .
    LINES BLANK ALL; BAR ON ALL
    BAR WIDTH .5 ALL; BAR DIMENSION 3 ALL; BAR FILL ONTS ALL
    .
    XLIMITS 1 10; XTIC OFFSET 1 1
    MAJOR XTIC MARK NUMBER 10; MINOR XTIC MARK NUMBER 0
    X1TIC MARK LABEL FORMAT ALPHA
    X1TIC MARK LABEL CONTENT APOLLO SUN HP DEC SYM SGI IBM DG TI XEROX
    X1TIC MARK LABEL DIRECTION VERTICAL
    X1TIC MARK LABEL JUSTIFICATION LETO
    X1TIC MARK SIZE 1.8
    .
    YLIMITS 0 500
    Y1TIC MARK LABEL DIRECTION VERTICAL
    Y1TIC MARK LABEL JUSTIFICATION CECE
    .
    TITLE DEMONSTRATE TIC LABEL DIRECTION
    PLOT Y X X
 
-----TIC MARK LABEL DISPLACEMENT-----------------------------------
 
   TIC MARK LABEL DISPLACEMENT
 
Name:
    ...TIC MARK LABEL DISPLACEMENT
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the distance from the tic labels to the frame on
    subsequent plots.
 
Syntax:
    <prefix>TIC MARK LABEL DISPLACEMENT   <displacement>
    where
            no prefix     refers to all 4 sides;
            the prefix X  refers to both horizontal sides;
            the prefix Y  refers to both vertical sides;
            the prefix X1 refers to the lower horizontal side;
            the prefix X2 refers to the upper horizontal side;
            the prefix Y1 refers to the left  vertical   side;
            the prefix Y2 refers to the right vertical   side;
    and <displacement> is a number or parameter that specifies the
            desired distance from the frame to the tic label.
 
Examples:
    TIC MARK LABEL DISPLACEMENT 1
    X2TIC MARK LABEL DISPLACEMENT 2.5
    Y2TIC MARK LABEL DISPLACEMENT 3.5
 
Note:
    A ...TIC MARK LABEL DISPLACEMENT command with no arguments reverts
    the setting to default; thus X1TIC MARK LABEL DISPLACEMENT with no
    arguments reverts the bottom horizontal tic label displacement to
    2.5.  A ...TIC MARK LABEL DISPLACEMENT command with no prefix
    refers to all 4 sides; thus TIC MARK LABEL DISPLACEMENT 2 sets the
    tic mark label displacement to 2 for all 4 frame lines.  TIC MARK
    LABEL DISPLACEMENT with no prefix and no arguments reverts the tic
    label displacement settings on all 4 sides to default.
 
Default:
    The displacement is 2.5 for the horizontal axis and 3.0 for the
    vertical axis.
 
Synonyms:
    TIC LABEL DISPLACEMENT is a synonym for TIC MARK LABEL
    DISPLACEMENT, as in TIC LABEL DISPLACEMENT 2 and X2TIC LABEL
    DISPLACEMENT 2.
 
Related Commands:
    TIC MARK LABEL             = Specifies whether or not tic mark
                                 labels or drawn.
    TIC MARK LABEL ANGLE       = Sets the angle for tic labels.
    TIC MARK LABEL CASE        = Sets case for tic labels.
    TIC MARK LABEL COLOR       = Sets the color for tic labels.
    TIC MARK LABEL CONTENTS    = Specify alphanumeric values for tic
                                 labels.
    TIC MARK LABEL DECIMALS    = Sets the number of decimals for tic
                                 labels.
    TIC MARK LABEL DIRECTION   = Sets the direction (horizontal/
                                 vertical) for TIC MARK labels.
    TIC MARK LABEL FONT        = Sets the font for tic labels.
    TIC MARK LABEL FORMAT      = Sets the format (alphanumeric, power
                                 of 10, exponential) for tic labels.
    TIC MARK LABEL HW          = Sets the height and width for tic
                                 labels.
    TIC MARK LABEL JUST        = Sets the justification for tic labels.
    TIC MARK LABEL SIZE        = Sets the height for tic labels.
    TIC MARK LABEL THICKNESS   = Sets the line width for tic labels.
 
Applications:
    Presentation Graphics.
 
Implementation Date:
    XX
 
Program:
    LEGEND 1 PRESENTATION GRAPHICS
    LEGEND 2 3-D BAR HISTOGRAM
    LET Y = DATA 392 341 307 203 115 59 38 32 29 28
    LET N = NUMBER Y; LET X = SEQUENCE 1 1 N
    .
    LINES BLANK ALL; BAR ON ALL
    BAR WIDTH .5 ALL; BAR DIMENSION 3 ALL; BAR FILL ONTS ALL
    .
    XLIMITS 1 10; XTIC OFFSET 1 1
    MAJOR XTIC MARK NUMBER 10; MINOR XTIC MARK NUMBER 0
    X1TIC MARK LABEL FORMAT ALPHA
    X1TIC MARK LABEL CONTENT Apollo Sun HP DEC SYM SGI IBM DG TI Xerox
    X1TIC MARK LABEL CASE ASIS
    X1TIC MARK LABEL DISPLACEMENT 7
    YLIMITS 0 500
    Y1TIC MARK LABEL DISPLACEMENT 5
    .
    TITLE DEMONSTRATE TIC LABEL DISPLACEMENT
    PLOT Y X X
 
-----TIC MARK LABEL FONT----------------------------------------------
 
TIC MARK LABEL FONT
 
Name:
    ...TIC MARK LABEL FONT
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the font of the labels associated with the major tic
    marks on subsequent plots.
 
Description:
    Software fonts are those in which characters are drawn with move
    and draw commands.  These are also commonly referred to as stroked
    or vector fonts.  Hardware fonts are those generated by the
    output device.  Typeset fonts are publication quality fonts.  These
    are usually either defined as filled polygons or as a device
    specific bit map.  Dataplot supports 7 software fonts (these are
    various Hershey fonts) and 1 hardware font (called TEKTRONIX).
    Dataplot does not support any typeset fonts directly.  A few
    devices (specifically Postscript) may support some typeset
    fonts as hardware fonts.  Enter HELP FONTS for a list of the
    available fonts.
 
Syntax:
    <prefix>TIC MARK LABEL FONT   <font>
    where
           no prefix     refers to all 4 sides;
           the prefix X  refers to both horizontal sides;
           the prefix Y  refers to both vertical sides;
           the prefix X1 refers to the lower horizontal side;
           the prefix X2 refers to the upper horizontal side;
           the prefix Y1 refers to the left  vertical   side;
           the prefix Y2 refers to the right vertical   side;
    and <font> is a character string that specifies the desired font.
 
Examples:
    TIC MARK LABEL FONT SIMPLEX
    TIC MARK LABEL FONT DUPLEX
    TIC MARK LABEL FONT
    X2TIC MARK LABEL FONT SIMPLEX
    Y2TIC MARK LABEL FONT SIMPLEX
 
Note:
    It is rare to assign different fonts to tic mark labels on the 4
    different sides.  Whatever font is chosen for tic labels on one
    side is invariable chosen for all sides.  The most common form (by
    far) for this command is the general one (with no prefix, as in
    TIC MARK LABEL FONT SIMPLEX) which defines the font uniformly for
    tic mark labels on all 4 frame sides.
 
Note:
    A ...TIC MARK LABEL FONT command with no arguments reverts the
    setting to default; thus X1TIC MARK LABEL FONT with no arguments
    reverts the bottom horizontal tic label font to hardware
    characters.  A ...TIC MARK LABEL FONT command with no prefix refers
    to all 4 sides; thus TIC MARK LABEL FONT SIMPLEX sets tic mark
    labels to simplex for all 4 frame lines.  TIC MARK LABEL FONT with
    no prefix and no arguments reverts the tic label font settings on
    all 4 sides to default.
 
Default:
    All tic mark labels are generated with hardware characters.
 
Synonyms:
    TIC LABEL FONT is a synonym for TIC MARK LABEL FONT, as in TIC
    LABEL FONT SIMPLEX and X2TIC LABEL FONT DUPLEX.
 
Related Commands:
    TIC MARK LABEL             = Specifies whether or not tic mark
                                 labels or drawn.
    TIC MARK LABEL ANGLE       = Sets the angle for tic labels.
    TIC MARK LABEL CASE        = Sets case for tic labels.
    TIC MARK LABEL COLOR       = Sets the color for tic labels.
    TIC MARK LABEL CONTENTS    = Specify alphanumeric values for tic
                                 labels.
    TIC MARK LABEL DECIMALS    = Sets the number of decimals for tic
                                 labels.
    TIC MARK LABEL DIRECTION   = Sets the direction (horizontal/
                                 vertical) for TIC MARK labels.
    TIC MARK LABEL DISPLACE    = Sets the distance between tic labels
                                 and the frame.
    TIC MARK LABEL FORMAT      = Sets the format (alphanumeric, power
                                 of 10, exponential) for tic labels.
    TIC MARK LABEL HW          = Sets the height and width for tic
                                 labels.
    TIC MARK LABEL JUST        = Sets the justification for tic labels.
    TIC MARK LABEL SIZE        = Sets the height for tic labels.
    TIC MARK LABEL THICKNESS   = Sets the line width for tic labels.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    89/2
 
Program:
    LEGEND 1 PRESENTATION GRAPHICS
    LEGEND 2 3-D BAR HISTOGRAM
    LET Y = DATA 392 341 307 203 115 59 38 32 29 28
    LET N = NUMBER Y; LET X = SEQUENCE 1 1 N
    .
    LINES BLANK ALL; BAR ON ALL
    BAR WIDTH .5 ALL; BAR DIMENSION 3 ALL; BAR FILL ONTS ALL
    .
    XLIMITS 1 10; XTIC OFFSET 1 1
    MAJOR XTIC MARK NUMBER 10; MINOR XTIC MARK NUMBER 0
    X1TIC MARK LABEL FORMAT ALPHA
    X1TIC MARK LABEL CONTENT APOLLO SUN HP DEC SYM SGI IBM DG TI XEROX
    YLIMITS 0 500
    .
    TIC MARK LABEL FONT DUPLEX
    TITLE DEMONSTRATE TIC LABEL FONT
    PLOT Y X X
 
-----TIC MARK LABEL FORMAT--------------------------------------------
 
TIC MARK LABEL FORMAT
 
Name:
    ...TIC MARK LABEL FORMAT
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the format of the labels associated with the major
    tic marks on subsequent plots.
 
Description:
    This command has three uses.

       1) For linear scales the following formats are available:

             ALPHA - the tic labels will be user-supplied (via the TIC
                     MARK LABEL CONTENT command) alphanumeric strings.
             REAL  - linear scales are drawn with numeric values.
             EXPO  - linear scales are drawn in exponential
                     format.  The default is E15.7 format.  Use
                     the TIC MARK LABEL DECIMAL command to control
                     the number of digits (e.g., TIC MARK LABEL
                     DECIMAL 4 will use an E12.4 format.
                     This option was implemented 1997/07.

       2) Log scales can be drawn in one of 3 formats.  The available
          formats are:

             POWER - the corresponding power of 10 (e.g., 1 for 10**1)
                     is drawn for the tic label.
             REAL  - the corresponding real number (e.g., 10 for 10**1)
                     is drawn for the tic label.
             EXPO  - the tic label is drawn in exponential format (e.g.,
                     10**1).  The tic label must be drawn with a
                     software font in order for this option to work
                     correctly.

      3) You can specify a variable be used to determine the
         contents of the tic mark labels:

             GROUP LABEL - use a group label variable for the
                           tic mark labels (the variable name is
                           specified on the TIC MARK LABEL CONTENT
                           command).
             ROW LABEL   - use the row labels for the tic mark
                           labels (no TIC MARK LABEL CONTENT is
                           needed).
             VARIABLE    - use the contents of a numeric variable
                           for the tic mark labels (the variable
                           name is specified on the TIC MARK LABEL
                           CONTENT command).

                           The 2019/12 version updated this option
                           to support character variables as well
                           as numeric variables.  See Program 5
                           below for an example.

         Group labels are useful for box plots and other plots
         that are plotted against a group-id variable.  The
         VARIABLE option can be used to generate a "reverse"
         axis.  The ROW LABEL option is most commonly used for
         bar charts (and related type plots).
 
Syntax:
    <prefix>TIC MARK LABEL FORMAT   <format>
    where
            no prefix     refers to all 4 sides;
            the prefix X  refers to both horizontal sides;
            the prefix Y  refers to both vertical sides;
            the prefix X1 refers to the lower horizontal side;
            the prefix X2 refers to the upper horizontal side;
            the prefix Y1 refers to the left  vertical   side;
            the prefix Y2 refers to the right vertical   side;
    and <format> is one of ALPHA/REAL/POWER/EXPO/GROUP LABEL as
            described in the DESCRIPTION section above.
 
Examples:
    TIC MARK LABEL FORMAT REAL
    TIC MARK LABEL FORMAT POWER
    TIC MARK LABEL FORMAT
    X2TIC MARK LABEL FORMAT ALPHA
    Y2TIC MARK LABEL FORMAT EXPONENTIAL
    X1TIC MARK LABEL CONTENT EXPONENTIAL
 
Note:
    A ...TIC MARK LABEL FORMAT command with no arguments reverts the
    setting to default; thus X1TIC MARK LABEL FORMAT with no arguments
    reverts the bottom horizontal tic label to the default format.  A
    ...TIC MARK LABEL FORMAT command with no prefix refers to all 4
    sides; thus TIC MARK LABEL FORMAT REAL sets tic mark labels to real
    for all 4 frame lines.  TIC MARK LABEL FORMAT with no prefix and no
    arguments reverts the tic label format settings on all 4 sides to
    default.
 
Default:
    The tic mark labels for Linear scales are real numbers.  The tic
    mark labels for log scales are drawn with the POWER format.
 
Synonyms:
    TIC LABEL FORMAT is a synonym for TIC MARK LABEL FORMAT, as in TIC
    LABEL FORMAT REAL and X2TIC LABEL FORMAT REAL.
 
Related Commands:
    TIC MARK LABEL             = Specifies whether or not tic mark
                                 labels or drawn.
    TIC MARK LABEL ANGLE       = Sets the angle for tic labels.
    TIC MARK LABEL CASE        = Sets case for tic labels.
    TIC MARK LABEL COLOR       = Sets the color for tic labels.
    TIC MARK LABEL CONTENTS    = Specify alphanumeric values for tic
                                 labels.
    TIC MARK LABEL DECIMALS    = Sets the number of decimals for tic
                                 labels.
    TIC MARK LABEL DIRECTION   = Sets the direction (horizontal/
                                 vertical) for TIC MARK labels.
    TIC MARK LABEL DISPLACE    = Sets the distance between tic labels
                                 and the frame.
    TIC MARK LABEL FONT        = Sets the font for tic labels.
    TIC MARK LABEL HW          = Sets the height and width for tic
                                 labels.
    TIC MARK LABEL JUST        = Sets the justification for tic labels.
    TIC MARK LABEL SIZE        = Sets the height for tic labels.
    TIC MARK LABEL THICKNESS   = Sets the line width for tic labels.
 
Applications:
    Log scales, presentation graphics.
 
Implementation Date:
    1988/02
    2004/01: Added support for group labels, row labels and numeric
             variables to specify the contents of tic mark labels.
    2019/12: Added support for character variables to specify the
             contents of tic mark labels.
 
Program 1:
    LEGEND 1 PRESENTATION GRAPHICS
    LEGEND 2 3-D BAR HISTOGRAM
    LET Y = DATA 392 341 307 203 115 59 38 32 29 28
    LET N = NUMBER Y
    LET X = SEQUENCE 1 1 N
    .
    LINES BLANK ALL
    BAR ON ALL
    BAR WIDTH .5 ALL
    BAR DIMENSION 3 ALL
    BAR FILL ONTS ALL
    .
    XLIMITS 1 10
    XTIC OFFSET 1 1
    MAJOR XTIC MARK NUMBER 10
    MINOR XTIC MARK NUMBER 0
    X1TIC MARK LABEL FORMAT ALPHA
    X1TIC MARK LABEL CONTENT Apollo Sun HP DEC SYM SGI IBM DG TI Xerox
    X1TIC MARK LABEL CASE ASIS
    YLIMITS 0 500
    .
    TITLE DEMONSTRATE TIC LABEL FORMAT
    PLOT Y X X
 
Program 2:
    SERIAL READ Y
       60.   2042.  2111.   1684.  3888.  1858.  11379.  17560.  39287.
     4382.  113159.  175108.  273291.  400186.  581243.  811568.
     1121004.  1506550.  2002767.  2611612.  3369180.
    END OF DATA
    SERIAL READ X
         0.  1.  32.  243.  1024.  3125.  7776.  16807.  32768.  59049.
    100000.  161051.  248832.  371293.  537824.  759375.  1048576.
    1419857.  1889568.  2476099.  3200000.
    END OF DATA
    .
    TITLE SIZE 3
    TIC LABEL SIZE 2.5
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE LINEAR SCALE
    PLOT Y X
    TITLE LOG SCALES (POWER FORMAT)
    LOG ON
    LET X = 0.0001 SUBSET X <= 0
    PLOT Y X
    TITLE LOG SCALE (REAL FORMAT)
    TIC LABEL FORMAT REAL
    PLOT Y X
    TITLE LOG SCALE (EXPONENTIAL FORMAT)
    TIC LABEL FORMAT EXPONENTIAL
    TIC LABEL FONT SIMPLEX
    PLOT Y X
    END OF MULTIPLOT

Program 3:
    set convert character on
    skip 25
    read draft69c.dat rank day month
    .
    let ig = group label month
    x1tic mark label format group label
    x1tic mark label content ig
    x1tic mark label font simplex
    x1tic mark label angle 45
    x1tic mark label displacement 10
    let xcode = character code month
    .
    major xtic mark number 12
    minor xtic mark number 0
    xlimits 1 12
    xtic offset 0.5 0.5
    .
    char box plot
    line box plot
    fences on
    .
    box plot rank xcode

Program 4:
    . Purpose:  Test TIC MARK LABEL FORMAT VARIABLE command for
    .           bihistogram
    .
    SKIP 25
    READ AUTO83B.DAT Y1 Y2
    DELETE Y2 SUBSET Y2 < 0
    .
    TITLE AUTOMATIC
    TITLE OFFSET 2
    LABEL CASE ASIS
    Y1LABEL MPG for US Cars
    X1LABEL MPG for Japanese Cars
    .
    LET YLAB = DATA 30 20 10 0 10 20 30 40 50 60
    Y1TIC MARK LABEL FORMAT VARIABLE
    Y1TIC MARK LABEL CONTENT YLAB
    .
    BIHISTOGRAM Y1 Y2
 
Program 5:
    . Purpose:  Test TIC MARK LABEL FORMAT VARIABLE command for
    .           both numeric and character data
    .
    . Step 1:   Create some data
    .
    let y = data 6  4 9
    set string variable overwrite
    set convert character on
    read rowid ix
    1  Group_1
    2  Group_2
    3  Group_3
    end of data
    .
    set string variable append
    read iy  zz
    Row1    0
    Row5    5
    Row10  10
    end of data
    .
    . Step 2:   Set the plot control
    .
    xlimits 1 3
    major x1tic mark number 3
    minor x1tic mark number 0
    x1tic mark offset 0.8 0.8
    x1tic mark label format variable
    x1tic mark label content ix
    major x2tic mark number 3
    minor x2tic mark number 0
    x2tic marks on
    x2tic mark label on
    x2tic mark offset 0.8 0.8
    x2tic mark label format variable
    x2tic mark label content rowid
    ylimits 0 10
    major y1tic mark number 3
    minor y1tic mark number 4
    y1tic mark label format variable
    y1tic mark label content iy
    major y2tic mark number 3
    minor y2tic mark number 4
    y2tic marks on
    y2tic mark label on
    y2tic mark label format variable
    y2tic mark label content zz
    .
    bar on
    bar width 0.5
    line blank
    .
    . Step 3:   Plot the data
    .
    plot y
 
-----TIC MARK LABEL HW------------------------------------------------
 
TIC MARK LABEL HW
 
Name:
    ...TIC MARK LABEL HW
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the height and width of characters in the tic mark
    labels on subsequent plots.
 
Description:
    The height of the character is from the visible bottom of the
    character to the visible top of the character and the character
    width is from the visible left of the character to the visible
    right of the character.  The horizontal and vertical spacing
    between characters is not counted.  The size is in decimal units of
    0 to 100.  A height of 0 would be negligibly small while a height
    of 100 would be full screen vertical distance.  The tic mark label
    hw's hold for all subsequent plots until defaulted (via the ...TIC
    MARK LABEL HW command with no arguments) or overridden with a new
    tic mark label hw command (or a tic label size command).
 
Syntax:
    <prefix>TIC MARK LABEL HW   <height> <width>
    where
              no prefix     refers to all 4 sides;
              the prefix X  refers to both horizontal sides;
              the prefix Y  refers to both vertical sides;
              the prefix X1 refers to the lower horizontal side;
              the prefix X2 refers to the upper horizontal side;
              the prefix Y1 refers to the left  vertical   side;
              the prefix Y2 refers to the right vertical   side;
          <height> is a number or parameter in the range 0 to 100 that
              specifies the desired height;
    and   <width> is a number or parameter in the range 0 to 100 that
              specifies the desired width.
 
Examples:
    TIC MARK LABEL HW 1.0 0.75
    TIC MARK LABEL HW
    YTIC MARK LABEL HW 5  3
 
Note:
    This command is most typically used to correct distortions in
    character height to width ratios caused by MULTIPLOT commands with
    an unequal number of rows and columns.
 
Note:
    Hardware characters typically only allow the height to be set (and
    the width is a fixed percentage of the height).  For hardware
    characters, a TIC LABEL HW <height> <width> is equivalent to a
    TIC LABEL SIZE <height> command (i.e., the width parameter is
    ignored).
 
Note:
    A ...TIC MARK LABEL HW command with no arguments reverts the
    setting to default; thus X1TIC MARK LABEL HW with no arguments
    reverts the bottom horizontal tic label sizes to default.  A ...TIC
    MARK LABEL HW command with no prefix refers to all 4 sides; thus
    TIC MARK LABEL HW 1 0.75 sets tic mark label heights and widths to
    1 and 0.75 respectively for all 4 frame lines.  TIC MARK LABEL HW
    with no prefix and no arguments reverts the tic label hw settings
    on all 4 sides to default.
 
Default:
    Tic mark label heights and widths are 1.5 and 0.75 respectively.
 
Synonyms:
    TIC LABEL HW is a synonym for TIC MARK LABEL HW, as in TIC LABEL
    HW 1.5 1.0 and X2TIC LABEL HW 1.7 1.0.
 
Related Commands:
    TIC MARK LABEL             = Specifies whether or not tic mark
                                 labels or drawn.
    TIC MARK LABEL ANGLE       = Sets the angle for tic labels.
    TIC MARK LABEL CASE        = Sets case for tic labels.
    TIC MARK LABEL COLOR       = Sets the color for tic labels.
    TIC MARK LABEL CONTENTS    = Specify alphanumeric values for tic
                                 labels.
    TIC MARK LABEL DECIMALS    = Sets the number of decimals for tic
                                 labels.
    TIC MARK LABEL DIRECTION   = Sets the direction (horizontal/
                                 vertical) for TIC MARK labels.
    TIC MARK LABEL DISPLACE    = Sets the distance between tic labels
                                 and the frame.
    TIC MARK LABEL FONT        = Sets the font for tic labels.
    TIC MARK LABEL FORMAT      = Sets the format (alphanumeric, power
                                 of 10, exponential) for tic labels.
    TIC MARK LABEL JUST        = Sets the justification for tic labels.
    TIC MARK LABEL SIZE        = Sets the height for tic labels.
    TIC MARK LABEL THICKNESS   = Sets the line width for tic labels.
 
Applications:
    MULTIPLOT command, presentation graphics
 
Implementation Date:
    88/2
 
Program:
    LEGEND 1 PRESENTATION GRAPHICS
    LEGEND 2 3-D BAR HISTOGRAM
    LET Y = DATA 392 341 307 203 115 59 38 32 29 28
    LET N = NUMBER Y; LET X = SEQUENCE 1 1 N
    .
    LINES BLANK ALL; BAR ON ALL
    BAR WIDTH .5 ALL; BAR DIMENSION 3 ALL; BAR FILL ONTS ALL
    .
    XLIMITS 1 10; XTIC OFFSET 1 1
    MAJOR XTIC MARK NUMBER 10; MINOR XTIC MARK NUMBER 0
    X1TIC MARK LABEL FORMAT ALPHA
    X1TIC MARK LABEL CONTENT APOLLO SUN HP DEC SYM SGI IBM DG TI XEROX
    YLIMITS 0 500
    TIC MARK LABEL FONT DUPLEX
    TIC MARK LABEL HW 1.5 0.9
    TITLE DEMONSTRATE TIC LABEL HW
    PLOT Y X X
 
-----TIC MARK LABEL JUSTIFICATION-------------------------------------
 
TIC MARK LABEL JUSTIFICATION
 
Name:
    ...TIC MARK LABEL JUSTIFICATION
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the justification of the tic mark labels on subsequent
    plots (i.e., left, center, right horizontally and top, center,
    bottom vertically).
 
Description:
    For horizontal strings, the following justifications can be
    specified:
        LEFT   - left horizontally, bottom vertically
        CENTER - center horizontally, bottom vertically
        RIGHT  - right horizontally, bottom vertically
        LECE   - left horizontally, center vertically
        CECE   - center horizontally, center vertically
        RICE   - right horizontally, center vertically
        LETO   - left horizontally, top vertically
        CETO   - center horizontally, top vertically
        RITO   - right horizontally, top vertically
        LEBO   - left horizontally, bottom vertically
        CEBO   - center horizontally, bottom vertically
        RIBO   - right horizontally, bottom vertically
    The justifications for vertical strings are the same, with the
    following exceptions:
        LEFT   - center horizontally, bottom vertically
        CENTER - center horizontally, center vertically
        RIGHT  - center horizontally, top vertically
 
Syntax:
    <prefix>TIC MARK LABEL JUSTIFICATION   <just>
    where
              no prefix     refers to all 4 sides;
              the prefix X  refers to both horizontal sides;
              the prefix Y  refers to both vertical sides;
              the prefix X1 refers to the lower horizontal side;
              the prefix X2 refers to the upper horizontal side;
              the prefix Y1 refers to the left  vertical   side;
              the prefix Y2 refers to the right vertical   side;
    and   <just> is a character string that specifies the desired
              justification (the available choices are listed above).
 
Examples:
    TIC MARK LABEL JUSTIFICATION LEFT
    TIC MARK LABEL JUSTIFICATION LEBO
    TIC MARK LABEL JUSTIFICATION
    X2TIC MARK LABEL JUSTIFICATION LEFT
    Y2TIC MARK LABEL JUSTIFICATION LEFT
 
Note:
    A ...TIC MARK LABEL JUSTIFICATION command with no arguments reverts
    the setting to default; thus X1TIC MARK LABEL JUSTIFICATION with no
    arguments reverts the bottom horizontal tic label justification to
    CETO.  A ...TIC MARK LABEL JUSTIFICATION command with no prefix
    refers to all 4 sides; thus TIC MARK LABEL JUSTIFICATION LEFT sets
    tic mark labels to left for all 4 frame lines.  TIC MARK LABEL
    JUSTIFICATION with no prefix and no arguments reverts the tic label
    justification settings on all 4 sides to default.
 
Default:
    CETO for the bottom horizontal axis;
    CEBO for the top horizontal axis;
    RICE for the left vertical axis;
    LECE for the right vertical axis.
 
Synonyms:
    TIC LABEL JUSTIFICATION is a synonym for TIC MARK LABEL
    JUSTIFICATION, as in TIC LABEL JUSTIFICATION LEFT and X2TIC LABEL
    JUSTIFICATION LEFT.
 
Related Commands:
    TIC MARK LABEL             = Specifies whether or not tic mark
                                 labels or drawn.
    TIC MARK LABEL ANGLE       = Sets the angle for tic labels.
    TIC MARK LABEL CASE        = Sets case for tic labels.
    TIC MARK LABEL COLOR       = Sets the color for tic labels.
    TIC MARK LABEL CONTENTS    = Specify alphanumeric values for tic
                                 labels.
    TIC MARK LABEL DECIMALS    = Sets the number of decimals for tic
                                 labels.
    TIC MARK LABEL DIRECTION   = Sets the direction (horizontal/
                                 vertical) for TIC MARK labels.
    TIC MARK LABEL DISPLACE    = Sets the distance between tic labels
                                 and the frame.
    TIC MARK LABEL FONT        = Sets the font for tic labels.
    TIC MARK LABEL FORMAT      = Sets the format (alphanumeric, power
                                 of 10, exponential) for tic labels.
    TIC MARK LABEL HW          = Sets the height and width for tic
                                 labels.
    TIC MARK LABEL SIZE        = Sets the height for tic labels.
    TIC MARK LABEL THICKNESS   = Sets the line width for tic labels.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    The justification for vertical labels was corrected 94/6.
 
Program:
    LEGEND 1 PRESENTATION GRAPHICS
    LEGEND 2 3-D BAR HISTOGRAM
    LET Y = DATA 392 341 307 203 115 59 38 32 29 28
    LET N = NUMBER Y; LET X = SEQUENCE 1 1 N
    .
    LINES BLANK ALL; BAR ON ALL
    BAR WIDTH .5 ALL; BAR DIMENSION 3 ALL; BAR FILL ONTS ALL
    .
    XLIMITS 1 10; XTIC OFFSET 1 1
    MAJOR XTIC MARK NUMBER 10; MINOR XTIC MARK NUMBER 0
    X1TIC MARK LABEL FORMAT ALPHA
    X1TIC MARK LABEL CONTENT APOLLO SUN HP DEC SYM SGI IBM DG TI XEROX
    X1TIC MARK LABEL DIRECTION VERTICAL
    X1TIC MARK LABEL JUSTIFICATION LETO
    X1TIC MARK SIZE 1.8
    .
    YLIMITS 0 500
    Y1TIC MARK LABEL DIRECTION VERTICAL
    Y1TIC MARK LABEL JUSTIFICATION CEBO
    .
    TITLE DEMONSTRATE TIC LABEL JUSTIFICATION
    PLOT Y X X
 
-----TIC MARK LABEL SIZE---------------------------------------------
 
TIC MARK LABEL SIZE
 
Name:
    ...TIC MARK LABEL SIZE
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the size (height) of the tic mark labels on subsequent
    plots.
 
Description:
    The size is the height of the character.  The height of the
    character is from the visible bottom of the character to the
    visible top of the character (the vertical spacing between
    characters is not counted).  The height is in decimal units of 0 to
    100.  A height of 0 would be negligibly small while a height of 100
    would be full screen vertical distance.  The width of the character
    is automatically set to one half the character height.  The tic
    mark label sizes hold for all subsequent plots until defaulted (via
    the ...TIC MARK LABEL SIZE command with no arguments) or overridden
    with new tic mark label sizes.
 
Syntax:
    <prefix>TIC MARK LABEL SIZE   <size>
    where
            no prefix     refers to all 4 sides;
            the prefix X  refers to both horizontal sides;
            the prefix Y  refers to both vertical sides;
            the prefix X1 refers to the lower horizontal side;
            the prefix X2 refers to the upper horizontal side;
            the prefix Y1 refers to the left  vertical   side;
            the prefix Y2 refers to the right vertical   side;
    and  <size> is a number or parameter in the range 0 to 100 that
            specifies the desired character size (height).
 
Examples:
    TIC MARK LABEL SIZE 2
    TIC MARK LABEL SIZE
    X2TIC MARK LABEL SIZE 1.75
    Y2TIC MARK LABEL SIZE 2.8
 
Note:
    Hardware generated characters are often restricted to a few
    specific sizes.  Dataplot maps the requested size to the
    nearest hardware supported size.
 
Note:
    A ...TIC MARK LABEL SIZE command with no arguments reverts the
    setting to default; thus X1TIC MARK LABEL SIZE with no arguments
    reverts the bottom horizontal tic label size to 1.5.  A ...TIC
    MARK LABEL SIZE command with no prefix refers to all 4 sides; thus
    TIC MARK LABEL SIZE 1 sets tic mark labels to 1 for all 4 frame
    lines.  TIC MARK LABEL SIZE with no prefix and no arguments reverts
    the tic label size settings on all 4 sides to default.
 
Default:
    All tic mark label sizes are 1.5.
 
Synonyms:
    TIC LABEL SIZE is a synonym for TIC MARK LABEL SIZE, as in TIC
    LABEL SIZE 1.5 and X2TIC LABEL SIZE 1.7.
 
Related Commands:
    TIC MARK LABEL             = Specifies whether or not tic mark
                                 labels or drawn.
    TIC MARK LABEL ANGLE       = Sets the angle for tic labels.
    TIC MARK LABEL CASE        = Sets case for tic labels.
    TIC MARK LABEL COLOR       = Sets the color for tic labels.
    TIC MARK LABEL CONTENTS    = Specify alphanumeric values for tic
                                 labels.
    TIC MARK LABEL DECIMALS    = Sets the number of decimals for tic
                                 labels.
    TIC MARK LABEL DIRECTION   = Sets the direction (horizontal/
                                 vertical) for TIC MARK labels.
    TIC MARK LABEL DISPLACE    = Sets the distance between tic labels
                                 and the frame.
    TIC MARK LABEL FONT        = Sets the font for tic labels.
    TIC MARK LABEL FORMAT      = Sets the format (alphanumeric, power
                                 of 10, exponential) for tic labels.
    TIC MARK LABEL HW          = Sets the height and width for tic
                                 labels.
    TIC MARK LABEL JUST        = Sets the justification for tic labels.
    TIC MARK LABEL THICKNESS   = Sets the line width for tic labels.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    LEGEND 1 PRESENTATION GRAPHICS
    LEGEND 2 3-D BAR HISTOGRAM
    LET Y = DATA 392 341 307 203 115 59 38 32 29 28
    LET N = NUMBER Y; LET X = SEQUENCE 1 1 N
    .
    LINES BLANK ALL; BAR ON ALL
    BAR WIDTH .5 ALL; BAR DIMENSION 3 ALL; BAR FILL ONTS ALL
    .
    XLIMITS 1 10; XTIC OFFSET 1 1
    MAJOR XTIC MARK NUMBER 10; MINOR XTIC MARK NUMBER 0
    X1TIC MARK LABEL FORMAT ALPHA
    X1TIC MARK LABEL CONTENT APOLLO SUN HP DEC SYM SGI IBM DG TI XEROX
    YLIMITS 0 500
    TIC MARK LABEL SIZE 1.2
    TITLE DEMONSTRATE TIC LABEL SIZE
    PLOT Y X X
 
-----TIC MARK LABEL THICKNESS----------------------------------------
 
TIC MARK LABEL THICKNESS
 
Name:
    ...TIC MARK LABEL THICKNESS
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the thickness (i.e., line width) of the tic mark labels
    on subsequent plots.
 
Description:
    This command only applies if the tic labels are drawn with a
    software font (e.g., SIMPLEX).  It is ignored for hardware
    generated characters.  The line thickness is specified as a
    percentage of the vertical height of the device.  Line widths are
    typically between 0.1 and 0.3.
 
Syntax:
    <prefix>TIC MARK LABEL THICKNESS  <thick>
    where
            no prefix     refers to all 4 sides;
            the prefix X  refers to both horizontal sides;
            the prefix Y  refers to both vertical sides;
            the prefix X1 refers to the lower horizontal side;
            the prefix X2 refers to the upper horizontal side;
            the prefix Y1 refers to the left  vertical   side;
            the prefix Y2 refers to the right vertical   side;
    and   <thick> is a number or parameter in the range 0 to 100 that
            specifies the desired thickness.
 
Examples:
    TIC MARK LABEL THICKNESS 0.2
    TIC MARK LABEL THICKNESS
    Y2TIC MARK LABEL THICKNESS 0.2
 
Note:
    A ...TIC MARK LABEL THICKNESS command with no arguments reverts the
    setting to default; thus X1TIC MARK LABEL THICKNESS with no
    arguments reverts the bottom horizontal tic label thickness to 0.1.
    A ...TIC MARK LABEL THICKNESS command with no prefix refers to all
    4 sides; thus TIC MARK LABEL THICKNESS 0.2 sets tic mark label
    thickness to 0.2 for all 4 frame lines.  TIC MARK LABEL THICKNESS
    with no prefix and no arguments reverts the tic label thickness
    settings on all 4 sides to default.
 
Note:
    It is rare to assign different thicknesses to tic mark labels on
    the 4 different sides.  Whatever thickness is chosen for tic labels
    on one side is invariably chosen for all sides.  The most common
    form (by far) for this command is the general one (with no prefix,
    as in TIC MARK LABEL THICKNESS 0.2) which defines the thickness
    uniformly for tic mark labels on all 4 frame lines.
 
Default:
    All tic mark label thicknesses are 0.1.
 
Synonyms:
    TIC LABEL THICKNESS is a synonym for TIC MARK LABEL THICKNESS, as
    in TIC LABEL THICKNESS 0.2 and X2TIC LABEL THICKNESS 0.1.
 
Related Commands:
    TIC MARK LABEL             = Specifies whether or not tic mark
                                 labels or drawn.
    TIC MARK LABEL ANGLE       = Sets the angle for tic labels.
    TIC MARK LABEL CASE        = Sets case for tic labels.
    TIC MARK LABEL COLOR       = Sets the color for tic labels.
    TIC MARK LABEL CONTENTS    = Specify alphanumeric values for tic
                                 labels.
    TIC MARK LABEL DECIMALS    = Sets the number of decimals for tic
                                 labels.
    TIC MARK LABEL DIRECTION   = Sets the direction (horizontal/
                                 vertical) for TIC MARK labels.
    TIC MARK LABEL DISPLACE    = Sets the distance between tic labels
                                 and the frame.
    TIC MARK LABEL FONT        = Sets the font for tic labels.
    TIC MARK LABEL FORMAT      = Sets the format (alphanumeric, power
                                 of 10, exponential) for tic labels.
    TIC MARK LABEL HW          = Sets the height and width for tic
                                 labels.
    TIC MARK LABEL JUST        = Sets the justification for tic labels.
    TIC MARK LABEL SIZE        = Sets the height for tic labels.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    89/2
 
Program:
    LEGEND 1 PRESENTATION GRAPHICS
    LEGEND 2 3-D BAR HISTOGRAM
    LET Y = DATA 392 341 307 203 115 59 38 32 29 28
    LET N = NUMBER Y; LET X = SEQUENCE 1 1 N
    .
    LINES BLANK ALL; BAR ON ALL
    BAR WIDTH .5 ALL; BAR DIMENSION 3 ALL; BAR FILL ONTS ALL
    .
    XLIMITS 1 10; XTIC OFFSET 1 1
    MAJOR XTIC MARK NUMBER 10; MINOR XTIC MARK NUMBER 0
    X1TIC MARK LABEL FORMAT ALPHA
    X1TIC MARK LABEL CONTENT APOLLO SUN HP DEC SYM SGI IBM DG TI XEROX
    YLIMITS 0 500
    .
    TIC MARK LABEL FONT SIMPLEX
    TIC MARK LABEL THICKNESS 0.3
    TITLE DEMONSTRATE TIC LABEL THICKNESS
    PLOT Y X X
 
-----TIC MARK OFFSET--------------------------------------------------
 
TIC MARK OFFSET
 
Name:
    ...TIC OFFSET
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the offset of the first and last tic marks on subsequent
    plots.
 
Description:
    The offset is the distance between the tic mark and the end of the
    frame.  By default, Dataplot draws the first and last tics at the
    frame boundaries.  The TIC OFFSET command allows the analyst to
    override this default.  It is useful for generating "neat" tic
    intervals.
 
Syntax:
    <prefix>TIC OFFSET  <lower>  <upper>
    where
            no prefix     refers to all 4 sides;
            the prefix X  refers to both horizontal sides;
            the prefix Y  refers to both vertical sides;
            the prefix X1 refers to the lower horizontal side;
            the prefix X2 refers to the upper horizontal side;
            the prefix Y1 refers to the left  vertical   side;
            the prefix Y2 refers to the right vertical   side;
         <lower> is the distance from the frame boundary to the first
            tic mark (i.e., the bottom for the Y axis and the left for
            the X axis);
     and <upper> is the distance from the frame boundary to the last
            tic mark (i.e., the top for the Y axis and the right for
            the X axis).
 
Examples:
    TIC OFFSET 5 10
    TIC OFFSET 0 10
    TIC OFFSET 0 0
    X2TIC OFFSET 5
    Y2TIC OFFSET 2 3
 
Note:
    Tic offsets can be specified in either data units (the default) or
    Dataplot screen coordinates (0.0 to 100.0).  This is controlled
    with the TIC OFFSET UNITS command.
 
Note:
    If you want to set only the first tic offset, simply enter one
    value for the command.  If you only want to set the last offset,
    enter the first as a zero (e.g., TIC OFFSET 0 5).
 
Note:
    Tic offsets are added to the current limits.  That is, if you
    specify XLIMITS 1 10 and XTIC OFFSET 0.5 0.5, the frame goes from
    0.5 to 10.5.
 
Note:
    Minor tics are extended to the end of the frame.  However, they are
    limited to one cycle (i.e., to where the next major tic mark would
    occur).
 
Note:
    Tic offsets are applied to linear and log scales.  However, they
    are ignored for normal and Weibull scales.
 
Note:
    The TIC OFFSET command is useful for log scales where the data do
    not fill a full cycle.  For example, if your data range between 1
    and 1002, Dataplot uses limits of 1 and 10,000 (log scales always
    set the limit to a power of 10 regardless of the LIMITS command).
    Use the TIC OFFSET command as follows:
         YLOG ON
         YLIMITS 1 1000
         YTIC OFFSET 0 10
    This draws the last tic at 1,000 rather than 10,000 and leaves a
    little room for the 1002 value.
 
Note:
    A ...TIC OFFSET command with no arguments reverts the setting to
    default; thus X1TIC OFFSET with no arguments reverts the offsets
    to zero.  A ...TIC OFFSET command with no prefix refers to all 4
    sides; thus TIC OFFSET 2 3 sets tic mark offsets to 2 and 3 for all
    4 frame lines. TIC OFFSET with no prefix and no arguments reverts
    the tic offset settings on all 4 sides to default.
 
Default:
    All tic offsets are zero.
 
Synonyms:
    TIC OFFSET is a synonym for TIC MARK OFFSET, as in TIC OFFSET 5
    and X2TIC OFFSET 2 3.
 
Related Commands:
    TIC MARK            = Specifies whether or not tics are drawn.
    TIC MARK COLOR      = Sets the color for tic marks.
    TIC MARK POSITION   = Sets location of tic marks (inside/outside
                          through).
    TIC MARK SIZE       = Sets the size of tic marks.
    TIC MARK THICKNESS  = Sets the thickness of tic marks.
    TIC OFFSET UNITS    = Sets data or screen units for tic offsets.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    XX
 
Program:
    SKIP 25
    READ GEAR.DAT Y X
    LINE BLANK DASH
    CHARACTER X BLANK
    XLIMITS 1 10
    XTIC OFFSET 0.5 0.5
    Y1LABEL MEAN
    X1LABEL SAMPLE ID
    YLIMITS 0.992 1.000
    YTIC OFFSET 0.002 0.002
    MAJOR YTIC MARK NUMBER 5; MINOR YTIC MARK NUMBER 1
    TITLE AUTOMATIC
    MEAN PLOT Y X
 
-----TIC OFFSET UNITS--------------------------------------------
 
TIC OFFSET UNITS
 
Name:
    ...TIC OFFSET UNITS
 
Type:
    Plot Control Command
 
Purpose:
    Specifies specifies whether tic offsets are given in data units or
    in Dataplot 0 to 100 coordinates.
 
Description:
    The offset is the distance between the first or last tic mark and
    the end of the frame.
 
Syntax:
    TIC OFFSET UNITS   <DATA/ABSOLUTE>
    where DATA specifies data units and ABSOLUTE specifies Dataplot
            screen coordinates.
 
Examples:
    TIC OFFSET UNITS DATA
    TIC OFFSET UNITS ABSOLUTE
 
Note:
    Only one offset unit can be effect at a time.  That is, you cannot
    specify data units on the Y axis and absolute units on the X axis.
 
Default:
    Tic offsets are specified in data units.
 
Synonyms:
    TIC MARK OFFSET UNITS is a synonym for TIC OFFSET UNITS, as in TIC
    MARK OFFSET UNITS ABSOLUTE.
 
Related Commands:
    TIC MARK            = Specifies whether or not tics are drawn.
    TIC MARK COLOR      = Sets the color for tic marks.
    TIC MARK OFFSET     = Sets the offset for the first and last tic
                           marks.
    TIC MARK POSITION   = Sets location of tic marks (inside/outside
                          through).
    TIC MARK SIZE       = Sets the size of tic marks.
    TIC MARK THICKNESS  = Sets the thickness of tic marks.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    SKIP 25
    READ GEAR.DAT Y X
    LINE BLANK DASH
    CHARACTER X BLANK
    XLIMITS 1 10
    TIC OFFSET UNITS ABSOLUTE
    XTIC OFFSET 2 2
    Y1LABEL MEAN
    X1LABEL SAMPLE ID
    YLIMITS 0.992 1.000
    YTIC OFFSET 5 10
    MAJOR YTIC MARK NUMBER 5; MINOR YTIC MARK NUMBER 1
    TITLE AUTOMATIC
    MEAN PLOT Y X
 
-----TIETJEN-MOORE TEST------------------------------------
 
TIETJEN MOORE TEST
 
Name:
    TIETJEN MOORE TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform a Tietjen-Moore test for outliers.
 
Description:
    The Tietjen-Moore test is a generalization of the Grubbs
    test that can be used to test for multiple outliers in a
    univariate data set.  As with the Grubbs test, the Tietjen-Moore
    test assumes that the underlying distribution follows an
    approximately normal distribution.

    It is important to note that the Tietjen-Moore test requires that
    the suspected number of outliers be specified exactly.  If this
    is not known, it is recommended that the generalized extreme
    studentized deviate test be used instead (this test only requires
    an upper bound on the number of suspected outliers).

    More formally, the Tietjen-Moore test can be defined as follows.

    H0:          There are no outliers in the data set.
    Ha:          There are exactly k outliers in the data set.

    Test         Sort the n data points from the smallest to the
    Statistc:    largest so that y(i) denotes the i-th largest data
                 value.

                 The test statistic for the k largest points is

                     L(k) = SUM[i=1 to n-k][(y(i) - ybar(k))**2]/
                            SUM[i=1 to n][(y(i) - ybar)**2]

                 with ybar denoting the sample mean for the full
                 sample and ybar(k) denoting the sample mean with
                 the k largest points removed.

                 The test statistic for the k smallest points is

                     L(k) = SUM[i=k+1 to n][(y(i) - ybar(k))**2]/
                            SUM[i=1 to n][(y(i) - ybar)**2]

                 with ybar denoting the sample mean for the full
                 sample and ybar(k) denoting the sample mean with
                 the k smallest points removed.

                 To test for outliers in both tails, compute the absolute
                 residuals

                     r(i) = ABS(y(i) - ybar)

                 and then let z(i) denote the sorted absolute residuals.
                 The test statistic for this case is

                     E(k) = SUM[i=1 to n-k][(z(i)-zbar(k))**2]/
                            SUM[i=1 to n][(z(i)-zbar)**2]

                 with zbar denoting the sample mean of the absolute
                 residuals for the full sample and zbar(k) denoting the
                 sample mean of the absolute residuals with the
                 largest k points removed.

    Significance alpha
    Level:

    Critical     The critical region for the Tietjen-Moore test is
    Region:      determined by simulation.  The simulation is performed
                 by generating a standard normal random sample of size
                 n and computing the Tietjen-Moore test statistic.
                 Typically, 10,000 random samples are used.  The value of
                 the Tietjen-Moore statistic obtained from the data are
                 compared to this reference distribution.

                 Dataplot performs this simulation dynamically.  The
                 critical values obtained may differ slightly from the
                 critical values given in the Tietjen-Moore paper.

                 This is a lower one-tailed test, so we reject the
                 null hypothesis of no outliers if the test statistic
                 is less than the critical value.

    It is recommended that formal outlier tests be complented with
    graphical methods.  For example, a normal probability plot
    can be used to determine if the normality assumption is reasonable
    and also to determine an appropriate value for k.

Syntax 1:
    TIETJEN-MOORE TEST   <y>    <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable being tested;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax checks for outliers in both tails.

Syntax 2:
    TIETJEN-MOORE MINIMUM TEST   <y>    <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable being tested;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax checks the minimum values for outliers.

Syntax 3:
    TIETJEN-MOORE MAXIMUM TEST   <y>    <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable being tested;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax checks the maximum values for outliers.

Syntax 4:
    TIETJEN-MOORE MULTIPLE TEST <y1> ... <yk>   
                         <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of up to k response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax can also be used with the MINIMUM and MAXIMUM version
    of the tests.  This syntax performs a Tietjen-Moore test on <y1>,
    then on <y2>, and so on.  Up to 30 response variables may be
    specified.

    Note that the syntax

         TIETJEN-MOORE MULTIPLE TEST Y1 TO Y4

    is supported.  This is equivalent to

         TIETJEN-MOORE MULTIPLE TEST Y1 Y2 Y3 Y4

Syntax 5:
    TIETJEN-MOORE REPLICATED TEST <y> <x1> ... <xk>   
                           <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <x1> ... <xk> is a list of up to k group-id variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax can also be used with the MINIMUM and MAXIMUM version
    of the tests.  This syntax peforms a cross-tabulation of
    <x1> ... <xk> and performs a Tietjen-Moore test for each unique
    combination of cross-tabulated values.  For example, if
    X1 has 3 levels and X2 has 2 levels, there will be a total of
    6 Tietjen-Moore tests performed.

    Up to six group-id variables can be specified.

    Note that the syntax

         TIETJEN-MOORE REPLICATED TEST Y X1 TO X4

    is supported.  This is equivalent to

         TIETJEN-MOORE REPLICATED TEST Y X1 X2 X3 X4

Examples:
    TIETJEN-MOORE TEST Y1
    TIETJEN-MOORE TEST Y1 LABID
    TIETJEN-MOORE MULTIPLE TEST Y1 Y2 Y3
    TIETJEN-MOORE REPLICATED TEST Y X1 X2
    TIETJEN-MOORE TEST Y1   SUBSET TAG > 2
    TIETJEN-MOORE MINIMUM TEST Y1
    TIETJEN-MOORE MAXIMUM TEST Y1

Note:
    The number of outliers to test for is specified with the command

        LET NOUTLIER = <value>

Note:
    Masking and swamping are two issues that can affect outlier tests.

    Masking can occur when we specify too few outliers in the test. For
    example, if we are testing for a single outlier when there are in
    fact two (or more) outliers, these additional outliers may influence
    the value of the test statistic enough so that no points are
    declared as outliers.

    On the other hand, swamping can occur when we specify too many
    outliers in the test. For example, if we are testing for two
    outliers when there is in fact only a single outlier, both points
    may be declared outliers.

    The possibility of masking and swamping are an important reason
    why it is useful to complement formal outlier tests with graphical
    methods. Graphics can often help identify cases where masking or
    swamping may be an issue.

    Also, masking is one reason that trying to apply a single outlier
    test sequentially can fail. If there are multiple outliers, masking
    may cause the outlier test for the first outlier to return a
    conclusion of no outliers (and so the testing for any additional
    outliers is not done).

    The Tietjen-Moore test is used to check for exactly k outliers.  If
    k is not specified correctly, the results of the Tietjen-Moore test
    can be distorted.

    If determining k is not obvious, then the generalized extreme
    studentized deviate tests may be preferred since this test only
    requires that an upper bound on the suspected number of outliers be
    specified.

Note:
    Tests for outliers are dependent on knowing the distribution of
    the data.  The Tietjen-Moore test assumes that the data come from an
    approximately normal distribution.  For this reason, it is
    strongly recommended that the Tietjen-Moore test be complemented with
    a normal probability plot.  If the data are not approximately
    normally distributed, then the Tietjen-Moore test may be detecting
    the non-normality of the data rather than the presence of outliers.

Note:
    You can specify the number of digits in the Tietjen-Moore output with
    the command

        SET WRITE DECIMALS <value>

Note:
    The TIETJEN-MOORE TEST command automatically saves the following
    parameters:

       STATVAL    = the value of the test statistic
       PVAL       = the p-value of the test statistic
       CUTOFF0    = the 0 percent point of the reference distribution
       CUTOFF01   = the 1 percent point of the reference distribution
       CUTOFF025  = the 2.5 percent point of the reference distribution
       CUTOFF05   = the 5 percent point of the reference distribution
       CUTOFF10   = the 10 percent point of the reference distribution
       CUTOFF25   = the 25 percent point of the reference distribution
       CUTOFF50   = the 50 percent point of the reference distribution
       CUTOF100   = the 100 percent point of the reference distribution

    If the MULTIPLE or REPLICATED option is used, these values will
    be written to the file "dpst1f.dat" instead.

Note:
    In addition to the TIETJEN-MOORE TEST command, the following commands
    can also be used:

        LET A = TIETJEN-MOORE Y
        LET A = TIETJEN-MOORE MINIMUM Y
        LET A = TIETJEN-MOORE MAXIMUM Y

    In addition to the above LET command, built-in statistics are
    supported for about 17 different commands (enter HELP STATISTICS
    for details).

Default:
    None
 
Synonyms:
    MULTIPLE TIETJEN MOORE is a synonym for TIETJEN MOORE MULTIPLE
    REPLICATION TIETJEN MOORE is a synonym for TIETJEN MOORE REPLICATION
 
Related Commands:
    GRUBB TEST                  = Perform the Grubbs outlier test.
    EXTREME STUDENTIZED DEVIATE = Perform the generalized extreme
                                  studentized deviate outlier test.
    DIXON TEST                  = Perform the Dixon outlier test.
    ANDERSON DARLING TEST       = Perform the Anderson-Darling test for
                                  normality.
    WILK SHAPIRO TEST           = Perform the Wilk-Shapiro test for
                                  normality.
    PROBABILITY PLOT            = Generates a probability plot.
    HISTOGRAM                   = Generate a histogram.
    BOX PLOT                    = Generate a box plot.
 
Reference:
    Gary Tietjen and Roger Moore (August 1972), "Some Grubbs-Type
    Statistics for the Detection of Several Outliers", Technometrics,
    Vol. 14, No. 3, pp. 583-597.
 
Applications:
    Outlier Detection
 
Implementation Date:
    2009/11
 
Program:
    .  Following example from Tietjen-Moore paper
    READ Y
    -1.40
    -0.44
    -0.30
    -0.24
    -0.22
    -0.13
    -0.05
     0.06
     0.10
     0.18
     0.20
     0.39
     0.48
     0.63
     1.01
    END OF DATA
    .
    .  First generate a normal probability plot
    .
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 5
    .
    Y1LABEL Data
    X1LABEL Theoretical
    TITLE Normal Probability Plot of Semi-Diameters of Venus
    LINE BLANK
    CHAR CIRCLE
    CHAR FILL ON
    LET H = 1.2
    LET W = H*0.75
    CHAR HW H W
    .
    NORMAL PROBABILITY PLOT Y
    .
    .  Now perform the Tietjen-Moore test
    .
    SET WRITE DECIMALS 5
    LET NOUTLIER = 2
    TIETJEN-MOORE Y

    The following output is generated

                Tietjen-Moore Test for Multiple Outliers: Two-Sided Case
                                (Assumption: Normality)
     
    Response Variable: Y
     
    H0: There are no outliers
    Ha: The     2 most extreme points are outliers
    Potential Outlier Value Tested:                      -1.39999
    Potential Outlier Value Tested:                       0.06000
     
    Summary Statistics:
    Number of Observations:                                    15
    Sample Minimum:                                      -1.39999
    Sample Maximum:                                       1.01000
    Sample Mean:                                          0.01800
    Sample SD:                                            0.55094
     
    Tietjen-Moore Test Statistic Value:                   0.29199
    CDF Value:                                            0.96560
    P-Value                                               0.03440
     
     
     
    Percent Points of the Reference Distribution
    -----------------------------------
      Percent Point               Value
    -----------------------------------
                0.0    =          0.064
                1.0    =          0.237
                2.5    =          0.277
                5.0    =          0.315
               10.0    =          0.362
               25.0    =          0.435
               50.0    =          0.508
              100.0    =          0.755
     
    Conclusions (Lower 1-Tailed Test)
    ----------------------------------------------
      Alpha    CDF   Critical Value     Conclusion
    ----------------------------------------------
        10%    10%            0.362      Reject H0
         5%     5%            0.315      Reject H0
       2.5%   2.5%            0.277      Accept H0
         1%     1%            0.237      Accept H0
     
      *Critical Values Based on    10000 Monte Carlo Simulations

-----TIME-------------------------------------------------------

TIME

Name:
    TIME

Type:
    Support Command

Purpose:
    Prints out the current time of day and date.

Description:
    Dataplot prints the time and data in the format generated by the
    local operating system.  This varies between operating systems.

    The most common use of the date and time is to put identifying 
    information on a plot.  To simplify this, the current date is
    saved in a string called CURRDATE and the the current time is
    saved in a string called CURRTIME.  The program example below
    demonstrates their use.

Syntax:
    TIME

Examples:
    TIME

Note:
    This command is operating system dependent.  It is available for
    the following implementations:
       IBM PC/386
       Unix
       Cyber NOS/VE
       VAX/VMS  (coded but not tested)
    Contact your local site installer if you would like this command
    activated on your system.  Although date and time functions are
    not part of the Fortran 77 standard, most Fortran compilers 
    provide them (although not in the same way).

Default:
    None

Synonyms:
    DATE

Related Commands:
    LEGEND     = Place a text string on a plot.

Applications:
    XX

Implementation Date:
    93/2 (CURRDATE, CURRTIME added 93/8)

Program:
    TIME
    LEGEND 1 ^CURRDATE
    LEGEND 2 ^CURRTIME
    PLOT X**2 FOR X = 1 1 9
 
-----TITLE-------------------------------------------------------
 
TITLE
 
Name:
    TITLE
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the title to appear on subsequent plots.
 
Description:
    The title is the text which appears above the top horizontal frame
    line.  The title is automatically centered, so no positioning is
    needed.  The title appears on all subsequent plots until blanked
    out (via the TITLE command with no arguments) or overridden with a
    new title.
 
Syntax:
    TITLE   <text>
    where <text> is the character string to use as the title.  It
              contains all the characters from the first non-blank
              character after the word TEXT until the last non-blank
              character at the end of the line.
 
Examples:
    TITLE ASTM INTERLAB ANALYSIS
    TITLE SPECTROSCOPY ANALYSIS
    TITLE
 
Note:
    A TITLE command with no arguments blanks out the title.
 
Note:
    Titles are limited to one line.  However, the LEGEND command can be
    used to accommodate multi-line titles.  For example,
          LEGEND 1 TOP LINE OF TITLE
          LEGEND 1 COORDINATES 50 97
          LEGEND 1 JUSTIFICATION CENTER
          LEGEND 2 SECOND LINE OF TITLE
          LEGEND 2 COORDINATES 50 94
          LEGEND 2 JUSTIFICATION CENTER
 
Default:
    The title is blank.
 
Synonyms:
    None
 
Related Commands:
    TITLE AUTOMATIC     = Specifies automatically generated titles.
    TITLE CASE          = Sets the title case (upper/lower/asis).
    TITLE COLOR         = Sets the title color.
    TITLE DISPLACEMENT  = Sets the distance from the frame to the
                          title.
    TITLE FONT          = Sets the title font.
    TITLE SIZE          = Sets the title size.
    TITLE THICKNESS     = Sets the title thickness.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    LET FUNCTION F = (1/SQRT(2*PI))*EXP(-0.5*X**2)
    LET FUNCTION D1 = DERIVATIVE F WRT X
    LINES SOLID DOT DOT
    TITLE PLOT A FUNCTION AND THE DERIVATIVE
    PLOT F FOR X = -3 .1 3 AND
    PLOT D1 FOR X = -3 .1 3
    .
    PRE-SORT OFF; FRAME OFF; DEGREES
    LET THETA = SEQUENCE 0 10 1000
    LET R = 2*THETA
    LET Y = R*SIN(THETA)
    LET X = R*COS(THETA)
    TITLE A POLAR COORDINATE FUNCTION
    PLOT Y X
    PRE-SORT ON; FRAME ON; DELETE Y X
    .
    LEGEND 1 INTERLAB ANALYSIS
    SKIP 25
    READ UGIANSKY.DAT Y1 Y2 LAB
    LINES BLANK ALL
    CHARACTERS 1 2 3 4 5 6 7 8 9
    CHARACTER SIZE 4 ALL
    LIMITS 0 5.5
    TITLE YOUDEN PLOT
    PLOT Y1 Y2 LAB
    LEGEND 1; LIMITS
    .
    SKIP 25
    READ CHWIRUT1.DAT Y X LAB
    CHARACTER X ALL; CHARACTER SIZE 1.5 ALL; LINE SOLID ALL
    TITLE SHOW SPREAD DUE TO REPLICATION
    PLOT Y X X
    .
    END OF MULTIPLOT
 
-----TITLE AUTOMATIC------------------------------------------------
 
TITLE AUTOMATIC
 
Name:
    TITLE AUTOMATIC
 
Type:
    Plot Control Command
 
Purpose:
    Specifies that the title is automatically set to the command that
    generated the plot for subsequent plots.
 
Description:
    The title is the text which appears above the top horizontal frame
    line.  The automatic title holds for all subsequent plots until
    defaulted (via the TITLE command with no arguments) or overridden
    with a new title.
 
Syntax:
    TITLE AUTOMATIC
 
Examples:
    TITLE AUTOMATIC
 
Default:
    An automatic title is not generated.
 
Synonyms:
    None
 
Related Commands:
    LABEL AUTOMATIC     = Specifies automatically generated plot axis
                          labels.
    TITLE AUTOMATIC     = Specifies automatically generated titles.
    TITLE CASE          = Sets the title case (upper/lower/asis).
    TITLE COLOR         = Sets the title color.
    TITLE DISPLACEMENT  = Sets the distance from the frame to the
                          title.
    TITLE FONT          = Sets the title font.
    TITLE SIZE          = Sets the title size.
    TITLE THICKNESS     = Sets the title thickness.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    SKIP 25
    READ GEAR.DAT DIAMETER BATCH
    .
    TITLE AUTOMATIC
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    PLOT DIAMETER
    LINE SOLID SOLID DOT DOT
    TITLE MEAN CONTROL CHART
    MEAN CONTROL CHART DIAMETER BATCH
    TITLE RANGE CONTROL CHART
    RANGE CONTROL CHART DIAMETER BATCH
    TITLE S CONTROL CHART
    STANDARD DEVIATION  CONTROL CHART  DIAMETER BATCH
    END OF MULTIPLOT
 
-----TITLE CASE-------------------------------------------------------
 
TITLE CASE
 
Name:
    TITLE CASE
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the case of the title (i.e., upper, lower, or asis) to
    appear on subsequent plots.
 
Description:
    The title is the text which appears above the top horizontal frame
    line.  By default, the title is printed in all upper case
    characters regardless of how it is typed.  The title case holds for
    all subsequent plots until defaulted (via the TITLE CASE command
    with no arguments) or overridden with a new title case.
 
Syntax:
    TITLE CASE  <UPPER/LOWER/ASIS>
    where UPPER specifies the title is printed in all upper case, LOWER
            specifies that is printed in all lower case, and ASIS
            specifies that the case is preserved as entered on the
            TITLE command.
 
Examples:
    TITLE CASE LOWER
    TITLE CASE UPPER
 
Note:
    Any in-line case shifts (i.e., UC() or LC()) override the default
    case specified by the TITLE CASE command.
 
Default:
    The title case is upper.
 
Synonyms:
    None
 
Related Commands:
    TITLE               = Sets the plot title.
    LABEL CASE          = Sets the case for plot axis labels.
    LEGEND CASE         = Sets the case for plot legends.
    TITLE AUTOMATIC     = Specifies automatically generated titles.
    TITLE COLOR         = Sets the title color.
    TITLE DISPLACEMENT  = Sets the distance from the frame to the
                          title.
    TITLE FONT          = Sets the title font.
    TITLE SIZE          = Sets the title size.
    TITLE THICKNESS     = Sets the title thickness.
 
Applications:
    XX
 
Implementation Date:
    The ASIS capability was added 93/7.
 
Program:
    SKIP 25
    READ GEAR.DAT DIAMETER BATCH
    .
    TITLE CASE ASIS
    LABEL CASE ASIS
    LEGEND CASE ASIS
    TITLE  Gear Diameter Analysis
    Y1LABEL Cpk
    X1LABEL Batch
    LEGEND 1 Process Capability
    LEGEND 2 Cpk Plot
    XTIC OFFSET 0.5 0.5
    CHARACTER X BLANK
    LINE BLANK SOLID
    .
    LET LSL = 0.98
    LET USL = 1.02
    .
    CPK PLOT DIAMETER BATCH
 
-----TITLE COLOR-------------------------------------------------------
 
TITLE COLOR
 
Name:
    TITLE COLOR
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the color of the title to appear on subsequent plots.
 
Description:
    The title is the text which appears above the top horizontal frame
    line.  The title color holds for all subsequent plots until
    defaulted (via the TITLE COLOR command with no arguments) or
    overridden with new title colors.
 
    Dataplot provides two methods for specifying colors.

        1. Colors can be defined by name (or by the corresponding index).
           Dataplot adopted it's named colors from the X11 project.
           Currently, 162 named colors and 100 levels of grayscale are
           supported.  Grayscale can be specified with either G0, G1, ...,
           G100 (or -1, -2, ..., -100).  Many older devices support only a
           limited number of colors.  For these devices, unsupported colors
           will be mapped to one of the available colors.  To specify a
           named color, see Syntax 1.

        2. Most modern graphics devices support full RGB (RedBlueGreen)
           color.  You can alternatively specify RGB colors by entering
           three integer values to represent the Red, Green and Blue
           components, respectively.  These values should be in the range
           0 to 255.

    When setting the title RGB color, Dataplot first checks if the device
    supports RGB colors. If not, the named color will be used.  If the
    device does support RGB color, Dataplot will check if an RGB color
    has been specified.  If yes, then that RGB color is used.  If not,
    the named color will be used.

    To see the list of supported named colors (with the associated index
    number), see

    https://www.itl.nist.gov/div898/software/dataplot/refman1/ch11/homepage.htm

Syntax 1:
    TITLE COLOR  <color>
    where <color> is a character string that specifies the desired
              color.
 
Syntax 2:
    TITLE RGB COLOR <red> <green> <blue>
    where <red> is a number or parameter that specifies the red
              component;
          <green> is a number or parameter that specifies the green
              component;
    and   <blue> is a number or parameter that specifies the blue
              component.

    To turn off the RGB color, set the values to -1 (any negative value
    will work).  Values greater than 255 will be set to 255.
 
Examples:
    TITLE COLOR BLUE
    TITLE COLOR YELLOW
    TITLE COLOR WHITE
    TITLE RGB COLOR 220 109 88
 
Default:
    The title color is black.
 
Synonyms:
    None
 
Related Commands:
    TITLE               = Sets the plot title.
    TITLE AUTOMATIC     = Specifies automatically generated titles.
    TITLE CASE          = Sets the title case (upper/lower/asis).
    TITLE DISPLACEMENT  = Sets the distance from the frame to the
                          title.
    TITLE FONT          = Sets the title font.
    TITLE SIZE          = Sets the title size.
    TITLE THICKNESS     = Sets the title thickness.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    Pre-1987
    2020/11: Support for RGB colors.
 
Program 1:
    SKIP 25
    READ GEAR.DAT DIAMETER BATCH
    .
    TITLE COLOR BLUE
    TITLE CASE ASIS
    LABEL CASE ASIS
    LEGEND CASE ASIS
    TITLE  Gear Diameter Analysis
    Y1LABEL Cpk
    X1LABEL Batch
    LEGEND 1 Process Capability
    LEGEND 2 Cpk Plot
    XTIC OFFSET 0.5 0.5
    CHARACTER X BLANK
    LINE BLANK SOLID
    .
    LET LSL = 0.98
    LET USL = 1.02
    CPK PLOT DIAMETER BATCH
 
Program 2:
    SKIP 25
    READ GEAR.DAT DIAMETER BATCH
    .
    TITLE COLOR BLUE
    TITLE RGB COLOR 175 238 238
    TITLE CASE ASIS
    LABEL CASE ASIS
    LEGEND CASE ASIS
    TITLE  Gear Diameter Analysis
    Y1LABEL Cpk
    X1LABEL Batch
    LEGEND 1 Process Capability
    LEGEND 2 Cpk Plot
    XTIC OFFSET 0.5 0.5
    CHARACTER X BLANK
    LINE BLANK SOLID
    .
    LET LSL = 0.98
    LET USL = 1.02
    CPK PLOT DIAMETER BATCH
 
-----TITLE DISPLACEMENT------------------------------------------------
 
TITLE DISPLACEMENT
 
Name:
    TITLE DISPLACEMENT
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the title displacement for subsequent plots.
 
Description:
    The title is the text which appears above the top horizontal frame
    line.  The title displacement is the distance from the frame to the
    title.  The displacement is specified in Dataplot 0 to 100
    coordinates.  If the displacement is negative, the title appears
    inside the plot frame.  The title displacement holds for all
    subsequent plots until defaulted (via the TITLE DISPLACEMENT
    command with no arguments) or overridden with a new title
    displacement.
 
Syntax:
    TITLE DISPLACEMENT  <value>
    where <value> is a number or parameter that specifies the desired
              displacement.
 
Examples:
    TITLE DISPLACEMENT 10
    TITLE DISPLACEMENT -5
    TITLE DISPLACEMENT DEFAULT
 
Default:
    The title displacement is 3.
 
Synonyms:
    None
 
Related Commands:
    TITLE               = Sets the plot title.
    TITLE AUTOMATIC     = Specifies automatically generated titles.
    TITLE CASE          = Sets the title case (upper/lower/asis).
    TITLE COLOR         = Sets the title color.
    TITLE FONT          = Sets the title font.
    TITLE SIZE          = Sets the title size.
    TITLE THICKNESS     = Sets the title thickness.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    LET THETA = SEQUENCE 0 1 380
    LET X = SIN(THETA)
    MULTIPLOT 3 4
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    FEEDBACK OFF
    FRAME OFF
    PRE-SORT OFF
    TITLE SIZE 5
    TITLE DISPLACEMENT 2
    TITLE SIN(K*THETA) VS SIN(THETA)
    LABEL SIZE 3
    LOOP FOR K = .1 .1 1.2
        LET Y=SIN(K*THETA)
        X1LABEL K = ^K
        PLOT Y X
    END OF LOOP
    END OF MULTIPLOT
 
-----TITLE FONT-------------------------------------------------------
 
TITLE FONT
 
Name:
    TITLE FONT
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the font of the title to appear on subsequent plots.
 
Description:
    The title is the text which appears above the top horizontal frame
    line.  The title font holds for all subsequent plots until
    defaulted (via the TITLE FONT command with no arguments) or
    overridden with new title fonts.
 
Syntax:
    TITLE FONT   <font>
    where <font> is a character string that specifies the desired font.
                Enter HELP FONT for a list of available fonts.
 
Examples:
    TITLE FONT SIMPLEX
    TITLE FONT DUPLEX
 
Note:
    The FONT command is used to set the default font for a plot.  The
    TITLE FONT command is used to override the default font for the
    title only.
 
Default:
    The title font is tektronix (i.e., hardware characters).
 
Synonyms:
    None
 
Related Commands:
    TITLE               = Sets the plot title.
    TITLE AUTOMATIC     = Specifies automatically generated titles.
    TITLE CASE          = Sets the title case (upper/lower/asis).
    TITLE COLOR         = Sets the title color.
    TITLE DISPLACEMENT  = Sets the distance from the frame to the
                          title.
    TITLE SIZE          = Sets the title size.
    TITLE THICKNESS     = Sets the title thickness.
 
Applications:
    XX
 
Implementation Date:
    89/2
 
Program:
    SKIP 25
    READ GEAR.DAT DIAMETER BATCH
    .
    TITLE FONT COMPLEX
    TITLE CASE ASIS
    LABEL CASE ASIS
    LEGEND CASE ASIS
    TITLE  Gear Diameter Analysis
    Y1LABEL Cpk
    X1LABEL Batch
    LEGEND 1 Process Capability
    LEGEND 2 Cpk Plot
    XTIC OFFSET 0.5 0.5
    CHARACTER X BLANK
    LINE BLANK SOLID
    .
    LET LSL = 0.98
    LET USL = 1.02
    CPK PLOT DIAMETER BATCH
 
-----TITLE SIZE-------------------------------------------------------
 
TITLE SIZE
 
Name:
    TITLE SIZE
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the size (height) of the title to appear on subsequent
    plots.
 
Description:
    The title is the text which appears above the top horizontal frame
    line.  The height of the character is from the visible bottom of
    the character to the visible top of the character.  The vertical
    spacing between characters is not counted.  The height is in
    decimal units of 0 to 100.  A height of 0 would be negligibly small
    while a height of 100 would be full screen vertical distance.  The
    width of the character is automatically set to one half the
    character height.  The title size holds for all subsequent plots
    until defaulted (via the TITLE SIZE command with no arguments) or
    overridden with new title sizes.
 
Syntax:
    TITLE SIZE  <size>
    where <size> is a number or parameter in the range 0 to 100 that
                specifies the desired character size.
 
Examples:
    TITLE SIZE 3
    TITLE SIZE 5
    TITLE SIZE 1.5
    TITLE SIZE A
 
Note:
    Hardware generated characters are often restricted to a few
    specific sizes.  Dataplot maps the requested size to the closest
    hardware supported size.
 
Default:
    The title size is 2.
 
Synonyms:
    None
 
Related Commands:
    TITLE               = Sets the plot title.
    TITLE AUTOMATIC     = Specifies automatically generated titles.
    TITLE CASE          = Sets the title case (upper/lower/asis).
    TITLE COLOR         = Sets the title color.
    TITLE DISPLACEMENT  = Sets the distance from the frame to the
                          title.
    TITLE FONT          = Sets the title font.
    TITLE THICKNESS     = Sets the title thickness.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    LET THETA = SEQUENCE 0 1 380
    LET X = SIN(THETA)
    MULTIPLOT 3 4
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    FEEDBACK OFF
    FRAME OFF
    PRE-SORT OFF
    TITLE SIZE 5
    TITLE DISPLACEMENT 2
    TITLE SIN(K*THETA) VS SIN(THETA)
    LABEL SIZE 3
    LOOP FOR K = .1 .1 1.2
        LET Y=SIN(K*THETA)
        X1LABEL K = ^K
        PLOT Y X
    END OF LOOP
    END OF MULTIPLOT
 
-----TITLE THICKNESS--------------------------------------------------
 
TITLE THICKNESS
 
Name:
    TITLE THICKNESS
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the thickness (i.e., line width) to use for the title to
    appear on subsequent plots.
 
Description:
    The title is the text which appears above the top horizontal frame
    line.  This command only applies if the title is drawn with a
    software font (e.g., SIMPLEX).  It is ignored for hardware
    generated characters.  The line thickness is specified as a
    percentage of the vertical height of the device (i.e., 0 to 100
    units).  Line widths are typically between 0.1 and 0.3.  The title
    thickness holds for all subsequent plots until defaulted (via the
    TITLE THICKNESS command with no arguments) or overridden with a new
    title thicknesses.
 
Syntax:
    TITLE THICKNESS  <thick>
    where <thick> is a number or parameter in the range 0 to 100 that
               specifies the desired line width.
 
Examples:
    TITLE THICKNESS 0.2
    TITLE THICKNESS 0.1
 
Note:
    The THICKNESS command is used to set the default thickness for a
    plot.  The TITLE THICKNESS command is used to override the default
    thickness for the title only.
 
Default:
    The title thickness is 0.1.
 
Synonyms:
    None
 
Related Commands:
    TITLE               = Sets the plot title.
    TITLE AUTOMATIC     = Specifies automatically generated titles.
    TITLE CASE          = Sets the title case (upper/lower/asis).
    TITLE COLOR         = Sets the title color.
    TITLE DISPLACEMENT  = Sets the distance from the frame to the
                          title.
    TITLE FONT          = Sets the title font.
    TITLE SIZE          = Sets the title size.
 
Applications:
    XX
 
Implementation Date:
    89/2
 
Program:
    SKIP 25
    READ GEAR.DAT DIAMETER BATCH
    .
    TITLE FONT SIMPLEX
    TITLE THICKNESS 0.25
    TITLE CASE ASIS
    LABEL CASE ASIS
    LEGEND CASE ASIS
    TITLE  Gear Diameter Analysis
    Y1LABEL Cpk
    X1LABEL Batch
    LEGEND 1 Process Capability
    LEGEND 2 Cpk Plot
    XTIC OFFSET 0.5 0.5
    CHARACTER X BLANK
    LINE BLANK SOLID
    .
    LET LSL = 0.98
    LET USL = 1.02
    CPK PLOT DIAMETER BATCH
 
-----TNECDF (LET)--------------------------------
 
TNECDF
 
Name:
    TNECDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the truncated exponential
    cumulative distribution function.
 
Description:
    A truncated exponential distribution is an exponential
    distribution that excludes values exceeding a certain
    threshold value (i.e., truncation from above).

    The standard form of the truncated exponential distribution
    has the following cumulative distribution function:
       F(x,x0,mu.sigma) = 1/{EXP(-(x-mu)/sigma)*
                          (EXP(-(x0-mu)/sigma) - 1)}) +
                          sigma*TNEPDF(0,x0,mu,sigma)
                          mu < x < x0, sigma > 0
    where TNEPDF is the truncated exponential probability density
    function.
 
Syntax:
    LET <y> = TNECDF(<x>,<x0>,<mu>,<sigma>)
                              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed truncated exponential cdf value is
               saved;
          <x0> is a variable, a number, or a parameter that
               specifies the first shape parameter;
          <mu> is a variable, a number, or a parameter that
               specifies the second shape parameter;
          <sigma> is a variable, a number, or a parameter that
               specifies the third shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TNECDF(3,2,0.7,10)
    LET Y = TNECDF(X1,X0,SCALE,THETA)
 
Note:
    Truncating an exponential distribution from below results in
    an exponential distribution with the same scale parameter.
    The trucation point simply defines a new scale parameter.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TNEPDF = Compute the truncated exponential probability density
             function.
    TNEPPF = Compute the truncated exponential percent point
             function.
    EXPPDF = Compute the exponential probability density function.
    TNRCDF = Compute the truncated normal cumulative distribution
             function.
    DEXPDF = Compute the double exponential probability density
             function.
    WEIPDF = Compute the Weibull probability density function.
    EV1PDF = Compute the extreme value type I probability density
             function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994 (page 554).
 
Applications:
    Reliability
 
Implementation Date:
    1995/10
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    .
    LET U = 0
    LET S = 10
    LET X0 = 30
    X1LABEL U = ^u, S = ^S, X0 = ^X0
    PLOT TNECDF(X,X0,U,S) FOR X = U  0.1  X0
    LET U = 0
    LET S = 2
    LET X0 = 3
    X1LABEL U = ^u, S = ^S, X0 = ^X0
    PLOT TNECDF(X,X0,U,S) FOR X = U  0.1  X0
    LET U = 2
    LET S = 5
    LET X0 = 14
    X1LABEL U = ^u, S = ^S, X0 = ^X0
    PLOT TNECDF(X,X0,U,S) FOR X = U  0.1  X0
    LET U = 0
    LET S = 0.5
    LET X0 = 1
    X1LABEL U = ^u, S = ^S, X0 = ^X0
    PLOT TNECDF(X,X0,U,S) FOR X = U  0.1  X0
    END OF MULTIPLOT
 
-----TNEPDF (LET)--------------------------------
 
TNEPDF
 
Name:
    TNEPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the truncated exponential
    probability density function.
 
Description:
    A truncated exponential distribution is an exponential
    distribution that excludes values exceeding a certain
    threshold value (i.e., truncation from above).

    The standard form of the truncated exponential distribution
    has the following probability density function:
       f(x,x0,mu.sigma) = EXP(-(x-mu)/sigma)/
                          {sigma*(1-EXP(-(x0-mu)/sigma))}
                          mu < x < x0, sigma > 0
 
Syntax:
    LET <y> = TNEPDF(<x>,<x0>,<mu>,<sigma>)
                              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed truncated exponential pdf value is
               saved;
          <x0> is a variable, a number, or a parameter that
               specifies the first shape parameter;
          <mu> is a variable, a number, or a parameter that
               specifies the second shape parameter;
          <sigma> is a variable, a number, or a parameter that
               specifies the third shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TNEPDF(3,2,0.7,10)
    LET Y = TNEPDF(X1,X0,SCALE,THETA)
 
Note:
    Truncating an exponential distribution from below results in
    an exponential distribution with the same scale parameter.
    The trucation point simply defines a new scale parameter.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TNECDF = Compute the truncated exponential cumulative
             distribution function.
    TNEPPF = Compute the truncated exponential percent point
             function.
    EXPPDF = Compute the exponential probability density function.
    TNRCDF = Compute the truncated normal cumulative distribution
             function.
    DEXPDF = Compute the double exponential probability density
             function.
    WEIPDF = Compute the Weibull probability density function.
    EV1PDF = Compute the extreme value type I probability density
             function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994 (page 554).
 
Applications:
    Reliability
 
Implementation Date:
    1995/10
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    .
    LET U = 0
    LET S = 10
    LET X0 = 30
    X1LABEL U = ^u, S = ^S, X0 = ^X0
    PLOT TNEPDF(X,X0,U,S) FOR X = U  0.1  X0
    LET U = 0
    LET S = 2
    LET X0 = 3
    X1LABEL U = ^u, S = ^S, X0 = ^X0
    PLOT TNEPDF(X,X0,U,S) FOR X = U  0.1  X0
    LET U = 2
    LET S = 5
    LET X0 = 14
    X1LABEL U = ^u, S = ^S, X0 = ^X0
    PLOT TNEPDF(X,X0,U,S) FOR X = U  0.1  X0
    LET U = 0
    LET S = 0.5
    LET X0 = 1
    X1LABEL U = ^u, S = ^S, X0 = ^X0
    PLOT TNEPDF(X,X0,U,S) FOR X = U  0.1  X0
    END OF MULTIPLOT
 
-----TNEPPF (LET)--------------------------------
 
TNEPPF
 
Name:
    TNEPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the truncated exponential
    percent point function.
 
Description:
    A truncated exponential distribution is an exponential
    distribution that excludes values exceeding a certain
    threshold value (i.e., truncation from above).

    The standard form of the truncated exponential distribution
    is calculated numerically using a bisection method.
 
Syntax:
    LET <y> = TNEPPF(<p>,<x0>,<mu>,<sigma>)
                              <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <p> is)
               where the computed truncated exponential ppf value is
               saved;
          <x0> is a variable, a number, or a parameter that
               specifies the first shape parameter;
          <mu> is a variable, a number, or a parameter that
               specifies the second shape parameter;
          <sigma> is a variable, a number, or a parameter that
               specifies the third shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TNEPPF(0.95,2,0.7,10)
    LET Y = TNEPPF(P1,X0,SCALE,THETA)
 
Note:
    Truncating an exponential distribution from below results in
    an exponential distribution with the same scale parameter.
    The trucation point simply defines a new scale parameter.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TNECDF = Compute the truncated exponential cumulative
             distribution function.
    TNEPDF = Compute the truncated exponential probability density
             function.
    EXPPDF = Compute the exponential probability density function.
    TNRCDF = Compute the truncated normal cumulative distribution
             function.
    DEXPDF = Compute the double exponential probability density
             function.
    WEIPDF = Compute the Weibull probability density function.
    EV1PDF = Compute the extreme value type I probability density
             function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994 (page 554).
 
Applications:
    Reliability
 
Implementation Date:
    1995/10
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    .
    LET U = 0
    LET S = 10
    LET X0 = 30
    X1LABEL U = ^u, S = ^S, X0 = ^X0
    PLOT TNEPPF(P,X0,U,S) FOR P = 0  0.1  1
    LET U = 0
    LET S = 2
    LET X0 = 3
    X1LABEL U = ^u, S = ^S, X0 = ^X0
    PLOT TNEPPF(P,X0,U,S) FOR P = 0  0.1  1
    LET U = 2
    LET S = 5
    LET X0 = 14
    X1LABEL U = ^u, S = ^S, X0 = ^X0
    PLOT TNEPPF(P,X0,U,S) FOR P = 0  0.1  1
    LET U = 0
    LET S = 0.5
    LET X0 = 1
    X1LABEL U = ^u, S = ^S, X0 = ^X0
    PLOT TNEPPF(P,X0,U,S) FOR P = 0  0.1  1
    END OF MULTIPLOT
 
-----TNRCDF (LET)--------------------------------
 
TNRCDF
 
Name:
    TNRCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the truncated normal
    cumulative distribution function.
 
Description:
    A truncated normal distribution is an normal distribution that
    is restricted to lie within a finite range, i.e.,
    A <= x <= B.  A and B are the lower and upper truncation
    points, respectively.  A can be negative infinity (i.e.,
    upper trucation only) or B can be positive inifinity (i.e.,
    lower truncation only), but not both at the same time.
    threshold value (i.e., truncation from above).

    The standard form of the truncated normal distribution
    has the following cumulative distribution function:
       F(x,a,b,mu.sigma) = {PHI((x-mu)/sigma) - PHI((a-mu)/sigma)}/
             {PHI((b-mu)/sigma)-PHI((a-mu)/sigma)}
             a <= x <= b; sigma > 0
    where a and b define the truncation points, mu and sigma are
    the mean and standard deviation of the parent normal
    distribution, and PHI is the cumulative distribution function
    of the standard normal distribution.
 
Syntax:
    LET <y> = TNRCDF(<x>,<a>,<b>,<mu>,<sigma>)
                              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed truncated normal cdf value is
               saved;
          <a> is a variable, a number, or a parameter that
               specifies the lower truncation point;
          <b> is a variable, a number, or a parameter that
               specifies the upper truncation point;
          <mu> is a variable, a number, or a parameter that
               specifies the second shape parameter;
          <sigma> is a variable, a number, or a parameter that
               specifies the third shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TNRCDF(3,2,0.7,0,10)
    LET Y = TNRCDF(X1,LOWER,UPPER,LOC,SCALE)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TNRPDF = Compute the truncated normal probability density
             function.
    TNRPPF = Compute the truncated normal percent point function.
    TNEPDF = Compute the truncated normal probability density
             function.
    NORPDF = Compute the normal probability density function.
    FNRPDF = Compute the folded normal probability density function.
    TNEPDF = Compute the truncated exponential cumulative
             distribution function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994 (pp. 156-162).
 
Applications:
    Disributional Modeling
 
Implementation Date:
    1995/10
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    .
    LET U = 0
    LET S = 1
    LET A = -4
    LET B = 2
    X1LABEL A = ^A, B = ^B, U = 0, SD = 1
    PLOT TNRCDF(X,A,B,U,S) FOR X = A  0.01  B
    LET A = 0
    LET B = 99
    X1LABEL A = ^A, B = ^B, U = 0, SD = 1
    PLOT TNRCDF(X,A,B,U,S) FOR X = A  0.01  5
    LET A = -100
    LET B = 0
    X1LABEL A = ^A, B = ^B, U = 0, SD = 1
    PLOT TNRCDF(X,A,B,U,S) FOR X = -10  0.01  B
    LET U = 5
    LET S = 10
    LET A = -8
    LET B = 20
    X1LABEL A = ^A, B = ^B, U = ^U, SD = ^S
    PLOT TNRCDF(X,A,B,U,S) FOR X = A  0.01  B
    END OF MULTIPLOT

-----TNRPDF (LET)--------------------------------
 
TNRPDF
 
Name:
    TNRPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the truncated normal
    probability density function.
 
Description:
    A truncated normal distribution is an normal distribution that
    is restricted to lie within a finite range, i.e.,
    A <= x <= B.  A and B are the lower and upper truncation
    points, respectively.  A can be negative infinity (i.e.,
    upper trucation only) or B can be positive inifinity (i.e.,
    lower truncation only), but not both at the same time.
    threshold value (i.e., truncation from above).

    The standard form of the truncated normal distribution
    has the following probability density function:
       f(x,a,b,mu.sigma) = phi((x-mu)/sigma)/
             {sigma*[PHI((b-mu)/sigma)-PHI((a-mu)/sigma)]}
             a <= x <= b; sigma > 0
    where a and b define the truncation points, mu and sigma are
    the mean and standard deviation of the parent normal
    distribution, phi and PHI are the probability density function
    and cumulative distribution function of the standard normal
    distribution, respectively.
 
Syntax:
    LET <y> = TNRPDF(<x>,<a>,<b>,<mu>,<sigma>)
                              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed truncated normal pdf value is
               saved;
          <a> is a variable, a number, or a parameter that
               specifies the lower truncation point;
          <b> is a variable, a number, or a parameter that
               specifies the upper truncation point;
          <mu> is a variable, a number, or a parameter that
               specifies the second shape parameter;
          <sigma> is a variable, a number, or a parameter that
               specifies the third shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TNRPDF(3,2,0.7,0,10)
    LET Y = TNRPDF(X1,LOWER,UPPER,LOC,SCALE)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TNRCDF = Compute the truncated normal cumulative distribution
             function.
    TNRPPF = Compute the truncated normal percent point function.
    TNEPDF = Compute the truncated normal probability density
             function.
    NORPDF = Compute the normal probability density function.
    FNRPDF = Compute the folded normal probability density function.
    TNEPDF = Compute the truncated exponential cumulative
             distribution function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994 (pp. 156-162).
 
Applications:
    Disributional Modeling
 
Implementation Date:
    1995/10
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    .
    LET U = 0
    LET S = 1
    LET A = -4
    LET B = 2
    X1LABEL A = ^A, B = ^B, U = 0, SD = 1
    PLOT TNRPDF(X,A,B,U,S) FOR X = A  0.01  B
    LET A = 0
    LET B = 99
    X1LABEL A = ^A, B = ^B, U = 0, SD = 1
    PLOT TNRPDF(X,A,B,U,S) FOR X = A  0.01  5
    LET A = -100
    LET B = 0
    X1LABEL A = ^A, B = ^B, U = 0, SD = 1
    PLOT TNRPDF(X,A,B,U,S) FOR X = -10  0.01  B
    LET U = 5
    LET S = 10
    LET A = -8
    LET B = 20
    X1LABEL A = ^A, B = ^B, U = ^U, SD = ^S
    PLOT TNRPDF(X,A,B,U,S) FOR X = A  0.01  B
    END OF MULTIPLOT

-----TNRPPF (LET)--------------------------------
 
TNRPPF
 
Name:
    TNRPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the truncated normal
    percent point function.
 
Description:
    A truncated normal distribution is an normal distribution that
    is restricted to lie within a finite range, i.e.,
    A <= x <= B.  A and B are the lower and upper truncation
    points, respectively.  A can be negative infinity (i.e.,
    upper trucation only) or B can be positive inifinity (i.e.,
    lower truncation only), but not both at the same time.
    threshold value (i.e., truncation from above).

    The truncated normal percent point function is computed
    numerically using a bisection method.
 
Syntax:
    LET <y> = TNRPPF(<p>,<a>,<b>,<mu>,<sigma>)
                              <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <p> is)
               where the computed truncated normal ppf value is
               saved;
          <a> is a variable, a number, or a parameter that
               specifies the lower truncation point;
          <b> is a variable, a number, or a parameter that
               specifies the upper truncation point;
          <mu> is a variable, a number, or a parameter that
               specifies the second shape parameter;
          <sigma> is a variable, a number, or a parameter that
               specifies the third shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TNRPPF(0.95,2,0.7,0,10)
    LET Y = TNRPPF(P1,LOWER,UPPER,LOC,SCALE)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TNRCDF = Compute the truncated normal cumulative distribution
             function.
    TNRPDF = Compute the truncated normal probability density
             function.
    TNEPDF = Compute the truncated normal probability density
             function.
    NORPDF = Compute the normal probability density function.
    FNRPDF = Compute the folded normal probability density function.
    TNEPDF = Compute the truncated exponential cumulative
             distribution function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994 (pp. 156-162).
 
Applications:
    Disributional Modeling
 
Implementation Date:
    1995/10
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    .
    LET U = 0
    LET S = 1
    LET A = -4
    LET B = 2
    X1LABEL A = ^A, B = ^B, U = 0, SD = 1
    PLOT TNRPPF(P,A,B,U,S) FOR P = 0  0.01  1
    LET A = 0
    LET B = 99
    X1LABEL A = ^A, B = ^B, U = 0, SD = 1
    PLOT TNRPPF(P,A,B,U,S) FOR P = 0  0.01  1
    LET A = -100
    LET B = 0
    X1LABEL A = ^A, B = ^B, U = 0, SD = 1
    PLOT TNRPPF(P,A,B,U,S) FOR P = 0  0.01  1
    LET U = 5
    LET S = 10
    LET A = -8
    LET B = 20
    X1LABEL A = ^A, B = ^B, U = ^U, SD = ^S
    PLOT TNRPPF(P,A,B,U,S) FOR P = 0  0.01  1
    END OF MULTIPLOT

-----TO-------------------------------------------------------

TO

Name:
    TO

Type:
    Keyword

Purpose:
    The TO keyword serves 5 separate functions:
       1) In conjunction with SUBSET/EXCEPT it specifies that the
          subset of interest is an interval rather than individual
          points.
       2) In conjunction with FOR at the end of the PLOT and 3D-PLOT
          commands (when plotting a function), it specifies that the
          dummy variable is to incremented over 101 equally-spaced
          points.
       3) In conjunction with FOR at the end of the ROOTS and
          INTEGRAL sub-commands under the LET command, it is
          optionally included to indicate the interval of interest.
       4) In conjunction with FOR in all other contexts, it is
          optionally included to indicate elements of the variable
          (the rows of the column) to be included in the operation.
       5) On a few commands (READ, ANDREWS PLOT, some DEX plots), it
          indicates a range of variables to use.

Syntax:
    xx

Examples:
    PLOT Y1 Y2 VERSUS X SUBSET LAB 4 TO 7
    FIT A+EXP(-B*X) EXCEPT TEMP 0 TO 32
    PLOT SIN(X) FOR X = 0 TO 6.28
    3D-PLOT X*Y FOR X=0 TO 5 FOR Y=0 TO 5

    LET R=ROOTS X-EXP(-X) WRT X FOR X=0 TO 1
    LET A=INTEGRAL LOG(X) WRT X FOR X=1 TO 2

    PLOT Y1 Y2 Y3 VERSUS X FOR I = 1 TO 30
    HISTOGRAM Y FOR I = 20 TO 50
    FIT (A+B*X)/(C+D*X) FOR I = 101 TO 200
    SMOOTH Y FOR I = 200 TO 500
    RETAIN Y FOR I = 20 TO 100

    READ CALIB.DAT X1 TO X10
    ANDREWS PLOT X1 TO X10

Default:
    None

Synonyms:
    None

Related Commands:
    FOR       = Allows row specification of a subset.
    SUBSET    = Specifies a subset of columns to be used in graphics
                and analysis commands.
    READ      = Read data from the terminal screen or a file.
    ROOTS     = Find the real roots of a univariate function.
    INTEGRAL  = Calculate the integral of a univariate function.

Applications:
    XX

Implementation Date:
    Pre-1987

Program:
    XX
 
-----TOLERANCE LIMITS--------------------------------------
 
TOLERANCE LIMITS
 
Name:
    TOLERANCE LIMITS
 
Type:
    Analysis Command
 
Purpose:
    Generates normal and non-parameteric tolerance intervals.
 
Description:
    Tolerance intervals calculate a confidence interval that
    contains a fixed percentage (or proportion) of the data.
    This is related to, but distinct from, the confidence interval
    for the mean.
 
    There are two numbers for the tolerance interval:
   
       1) The coverage probability is the fixed percentage of
          the data to be covered.
       2) The confidence level.

    Tolerance limits are given by 

       XBAR +/-  k*s

    where XBAR is the sample mean, s is the sample standard
    deviation, and k is determined so that one can state with
    (1-alpha)% confidence that at least phi% of the data fall within
    the given limits.  The values for k, assuming a normal
    distribution, have been numerically tabulated.

    This is commonly stated as something like "a 95% confidence
    interval for 90% coverage".

    Dataplot computes the tolerance interval for three confidence
    levels (90%, 95%, and 99%) and five coverage percentages
    (50.0, 75.0, 90.0, 95.0, 99.9).

    In addition, Dataplot computes non-parametric tolerance
    intervals.  These may be preferred if the data are not
    adequately approximated by a normal distribution.  In this
    case, the tables have been developed based on the smallest
    and largest data values in the sample.
 
Syntax 1:
    TOLERANCE LIMITS   <y>  <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable,
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax generates both the normal and the non-parameteric
    tolerance limits.

Syntax 2:
    <NORMAL/LOGNORMAL/BOXCOX> TOLERANCE LIMITS  <y>
                              <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable,
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax generates only the normal tolerance limits.

    If the keyword LOGNORMAL is present, the log of the data will be
    taken, then the normal tolerance limits will be computed, and then
    the computed normal lower and upper limits will be exponentiated to
    obtain the lognormal tolerance limits.

    Similarly, if the keyword BOXCOX is present, a Box-Cox transformation
    to normality will be applied to the data before computing the normal
    tolerance limits.  The computed lower and upper limits will then
    be transformed back to the original scale.

Syntax 3:
    NONPARAMETRIC TOLERANCE LIMITS  <y>
                                    <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable,
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax generates only the nonparametric tolerance limits.

Examples:
    TOLERANCE LIMITS Y1
    TOLERANCE LIMITS Y1  SUBSET TAG > 2
    NORMAL TOLERANCE LIMITS Y1
    LOGNORMAL TOLERANCE LIMITS Y1
    NONPARAMETRIC TOLERANCE LIMITS Y1
 
Note:
    Two-sided tolerance limits are used when symmetric coverage intervals
    from the mean are desired.

    In reliability and lifetime applications, one-sided tolerance limits
    are more common.  In these cases, we typically want coverage intervals
    that are greater than a given value (lower tolerance intervals) or 
    smaller than a given value (upper tolerance intervals).  These tolerance
    intervals are equivalent to one-sided confidence limits for percentiles
    of the specified distribution.

    Dataplot can compute one-sided (or two-sided) confidence limits for
    percentiles for a number of distributions commonly used in reliability
    applications.  For example, to compute lower one-sided tolerance limits
    for the 2-parameter Weibull distribution, you can do the following

        set maximum likelihood percentiles default
        set distributional percentile lower
        weibull maximum likelihood y

        set maximum likelihood percentiles default
        set bootstrap distributional percentile lower
        bootstrap weibull maximum likelihood plot y

Note:
    The following statistics are also supported:

        LET A = NORMAL TOLERANCE K FACTOR              Y
        LET A = NORMAL TOLERANCE ONE SIDED K FACTOR    Y

        LET A = NORMAL TOLERANCE LOWER LIMIT           Y
        LET A = NORMAL TOLERANCE UPPER LIMIT           Y
        LET A = NORMAL TOLERANCE ONE SIDED LOWER LIMIT Y
        LET A = NORMAL TOLERANCE ONE SIDED UPPER LIMIT Y

        The above commands are for the raw data case (i.e., a
        a single response variable).

        LET A = SUMMARY NORMAL TOLERANCE K FACTOR              MEAN SD N
        LET A = SUMMARY NORMAL TOLERANCE ONE SIDED K FACTOR    MEAN SD N

        LET A = SUMMARY NORMAL TOLERANCE LOWER LIMIT           MEAN SD N
        LET A = SUMMARY NORMAL TOLERANCE UPPER LIMIT           MEAN SD N
        LET A = SUMMARY NORMAL TOLERANCE ONE SIDED LOWER LIMIT MEAN SD N
        LET A = SUMMARY NORMAL TOLERANCE ONE SIDED UPPER LIMIT MEAN SD N

        The above commands are for the summary data case.  The three
        arguments can be either parameters or variables.  If a
        variable rather than a parameter is given, the first element of
        the variable is extracted.  The three values denote the mean,
        standard deviation, and sample size of the original data.

    To specify the coverage and confidence, enter the commands

        LET ALPHA = <value>
        LET GAMMA = <value>

    where ALPHA specifies the confidence level and GAMMA specifies
    the coverage level.  The defaults values are 0.95 for both the
    confidence and the coverage.

    In addition to the above LET command, built-in statistics are
    supported for about 20+ different commands (enter HELP STATISTICS
    for details).

Note:
    A number of approaches have been proposed for computing the k factor
    for tolerance limits.

    For two-sided intervals, the Wald-Wolfowitz method provides the basic
    approach.  However, this method is computationally expensive.
    Weisberg and Beatty (1960) published tables based on this method.
    Gardiner and Hull (1966) proposed an approximation that replaced an
    integration with algebraic formulas.  Howe (1969) proposed a simpler
    approximation for the tolerance limits that is considered to be more
    accurate than the Weisberg and Beatty method.  Guenther (1977)
    proposed a correction term for Howe's method.

    Howe's approximation is

        k2 = z(1+gamma)/2*SQRT(nu*(1 + (1/N))/CHSPPF(1-alpha,nu))

    where

        z       = the normal percent point function
        gamma   = the coverage factor
        alpha   = the confidence factor
        CHSPPF  = the chi-square percent point function
        nu      = the degrees of freedom

    The degrees of freedom parameter is N - 1 by default.  However, if
    the standard deviation is based on historical data rather than the
    current data set, then an independent value for the degrees of
    freedom may be given.  In Dataplot, you can specify the degrees of
    freedom by entering the command

        SET TOLERANCE LIMITS DEGREES OF FREEDOM <value>

    If this command is not given, N - 1 will be used.

    The Guenther correction is

        k2* = w*k2

    where

        w = SQRT(1 + (N - 3 - CHSPPF(N-1,1-alpha))/(2*(N+1)**2))

    The details for the Gardinar method can be found in the Gardiner
    paper.

    Dataplot supports both the Gardiner method and the Howe method.  The
    default for the 2018/05 version is the Howe method.  Prior versions
    use the Gardiner method.

    To specify the method in Dataplot, enter the command

       SET TOLERANCE LIMIT METHOD <HOWE/GARDINER>

    BEATTY and WALD AND WOLFOWITZ can be used as synonyms for GARDINER.

    To specify whether the Guenther correction will be applied to Howe's
    method, enter the command

        SET GUENTHER CORRECTION <ON/OFF>

    The default is OFF.

    Dataplot supports two methods for one-sided intervals.

    The first method uses the formula

        k1 = TNCPPF(alpa,N-1,delta)/SQRT(N)

    where

       TNCPPF    = the percent point function for the non-central t
                   distribution
       delta     = z(gamma)*SQRT(N)

    The non-central t distribution can lose accuracy as N gets large.
    The second method only uses the percent point function for the normal
    distribution and has the formula

        k1 = (z(gamma) + SQRT(z(gamma)**2 - a*b))/a

    where

        a   = 1 - z(alpha)**2/(2*(N-1))
        b   = z(gamma)**2 - z(alpha)**2/N

    To specify the one-sided method, enter

       SET TOLERANCE LIMIT ONE SIDED METHOD <NONCENTRAL T/NORMAL/DEFAULT>

    The default is to use the non-central t based approximation for
    N <= 100 and to use the normal based approximation for N > 100.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CONFIDENCE LIMITS   = Generate confidence limits for the mean.
    PREDICTION LIMITS   = Generate prediction limits for the mean.
    T-TEST              = Perform a t-test.
 
Reference:
    Wilks (1941), "Determination of Sample Sizes for Setting Tolerance
    Limits",  Annals of Mathematical Statistics, Vol. 12, No. 1,
    pp. 91-96.

    Weisberg and Beatty (1960), "Tables of Tolerance-Limit Factors
    for Normal Distributions", Technometrics, Vol. 2, pp. 483-500.

    Gardiner and Hull (1966), "An Approximation to Two-Sided Tolerance
    Limits for Normal Populations", Technometrics, Vol. 8, No. 1,
    pp. 115-122.

    Howe (1969), "Two-Sided Tolerance Limits for Normal Populations -
    Some Improvements", Journal of the American Statistical Association,
    Vol. 64, pp. 610-620.

    Guenther (1977), "Sampling Inspection in Statistical Quality
    Control", Griffin's Statistical Monographs, Number 37, London.

    Natrella, (1966), "Experimental Statistics: NBS Handbook 91",
    National Institute of Standards and Technology.
 
    Hahn and Meeker (1991), "Statistical Intervals: A Guide for
    Practitioners", Wiley.
 

Applications:
    Quality Control, Reliability
 
Implementation Date:
    1998/12
    2006/03: Syntax allowing only the normal or only the
             non-parametric limits to be generated
    2014/06: Support for LOGNORMAL and BOXCOX tolerance limits
    2018/05: Support for Howe method and Guenther correction for
             two-sided limits
    2018/05: Support for normal based approximation for one-sided limits
    2018/05: Some tweaks to the output format
 
Program:
    SKIP 25
    READ ZARR13.DAT Y
    SET WRITE DECIMALS 4
    TOLERANCE LIMITS Y

-----TOPCDF (LET)--------------------------------
 
TOPCDF
 
Name:
    TOPCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Topp and Leone cumulative distribution function
    with shape parameter beta.
 
Description:
    The standard Topp and Leone distribution has the
    following cumulative distribution function:

        F(x;beta) = (2*x - x**2)**beta     0 <= x <= 1, beta > 0
 
    with beta denoting the shape parameter.

    This distribution can be extended with lower and upper
    bound parameters.  If a and b denote the lower and upper
    bounds, respectively, then the location and scale 
    parameters are:

        location = a
        scale    = b - a

   The general form of the distribution can then be found
   by using the relation

       F(x;beta,a,b) = F((x-a)/(b-a);beta,0,1)

Syntax:
    LET <y> = TOPCDF(<x>,<beta>,<a>,<b>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable containing
              values in the interval (a,b);
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed Topp and Leone cdf
              value is stored;
          <beta> is a positive number, parameter, or variable that
              specifies the shape parameter;
          <a> is a number, parameter, or variable that
              specifies the lower limit;
          <b> is a number, parameter, or variable that
              specifies the upper limit;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <a> and <b> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = TOPCDF(0.3,0.2)
    LET Y = TOPCDF(X,0.5,0,5)
    PLOT TOPCDF(X,2,0,3) FOR X = 0  0.01  3
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TOPPDF = Compute the Topp and Leone probability density
             function.
    TOPPPF = Compute the Topp and Leone percent point function.
    RGTPDF = Compute the generalized reflected Topp and Leone
             probability density function.
    GTLPDF = Compute the generalized Topp and Leone probability
             density function.
    TSPPDF = Compute the two-sided power probability density
             function.
    BETPDF = Compute the beta probability density function.
    TRIPDF = Compute the triangular probability density function.
    TRAPDF = Compute the trapezoid probability density function.
    UNIPDF = Compute the uniform probability density function.
    POWPDF = Compute the power probability density function.
    JSBPDF = Compute the Johnson SB probability density function.
 
Reference:
    Samuel Kotz and J. Rene Van Dorp 2004, "Beyond Beta:
    Other Continuous Families of Distributions with Bounded
    Support and Applications", World Scientific, chapter 2.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/2
 
Program 1:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR
    .
    LET BETA  = 0.5
    TITLE Beta = ^beta
    PLOT TOPCDF(X,BETA) FOR X = 0  0.01  1
    .
    LET BETA  = 1
    TITLE Beta = ^beta
    PLOT TOPCDF(X,BETA) FOR X = 0  0.01  1
    .
    LET BETA  = 1.5
    TITLE Beta = ^beta
    PLOT TOPCDF(X,BETA) FOR X = 0  0.01  1
    .
    LET BETA  = 2
    TITLE Beta = ^beta
    PLOT TOPCDF(X,BETA) FOR X = 0  0.01  1
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT TOPP AND LEONE CDF FUNCTIONS
 
-----TOPPDF (LET)--------------------------------
 
TOPPDF
 
Name:
    TOPPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Topp and Leone probability density function
    with shape parameter beta.
 
Description:
    The standard Topp and Leone distribution has the
    following probability density function:

       f(x;beta) = beta*(2-2*x)*(2*x-x**2)**(beta-1)
                   0 <= x <= 1, beta > 0
 
    with beta denoting the shape parameter.

    This distribution can be extended with lower and upper
    bound parameters.  If a and b denote the lower and upper
    bounds, respectively, then the location and scale 
    parameters are:

        location = a
        scale    = b - a

    The general form of the distribution can then be found
    by using the relation

        f(x;beta,a,b) = f((x-a)/(b-a);beta,0,1)/(b-a)

    Kotz and van Dorp have developed the Topp and Leone
    distribution as an extension to the triangular
    distribution.  They suggest it as an alternative for
    cases where a bounded distribution is appropriate
    (other alternatives include the uniform, triangular,
    trapezoid, beta, Johnson SB, and two-sided power
    distributions).

    The generalized Topp and Leone and reflected generalized
    Topp and Leone distributions are generalizations of the
    Topp and Leone distribution.

Syntax:
    LET <y> = TOPPDF(<x>,<beta>,<a>,<b>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable containing
              values in the interval (a,b);
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed Topp and Leone pdf value
              is stored;
          <beta> is a positive number, parameter, or variable that
              specifies the shape parameter;
          <a> is a number, parameter, or variable that
              specifies the lower limit;
          <b> is a number, parameter, or variable that
              specifies the upper limit;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <a> and <b> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = TOPPDF(0.3,0.2)
    LET Y = TOPPDF(X,0.5,0,5)
    PLOT TOPPDF(X,2,0,3) FOR X = 0  0.01  3
 
Note:
    Topp and Leone random numbers, probability plots, and
    goodness of fit tests can be generated with the commands:

       LET BETA = <value>
       LET A = <value>
       LET B = <value>
       LET Y = TOPP AND LEONE RANDOM NUMBERS FOR I = 1 1 N
       TOPP AND LEONE PROBABILITY PLOT Y
       TOPP AND LEONE PROBABILITY PLOT Y2 X2
       TOPP AND LEONE PROBABILITY PLOT Y3 XLOW XHIGH
       TOPP LEONE KOLMOGOROV SMIRNOV GOODNESS OF FIT Y
       TOPP LEONE CHI-SQUARE GOODNESS OF FIT Y2 X2
       TOPP LEONE CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    The following commands can be used to estimate the beta
    shape parameter for the Topp and Leone distribution:

       LET BETA1 = <value>
       LET BETA2 = <value>
       TOPP AND LEONE PPCC PLOT Y
       TOPP AND LEONE PPCC PLOT Y2 X2
       TOPP AND LEONE PPCC PLOT Y3 XLOW XHIGH
       TOPP AND LEONE KS PLOT Y
       TOPP AND LEONE KS PLOT Y2 X2
       TOPP AND LEONE KS PLOT Y3 XLOW XHIGH

    The default values for BETA1 and BETA2 are 0.1 and 10.

    The probability plot can then be used to estimate the
    lower and upper limits (lower limit = PPA0,
    upper limit = PPA0 + PPA1).

    The following options may be useful for these commands.

       1) Instead of generating the ppcc plot or ks plot on
          the original data, we can generate them on
          selected percentiles of the data.  For example,
          if we have 1,000 points, we can choose to generate
          the plots on 100 evenly spaced percentiles with
          the command

             SET PPCC PLOT DATA POINTS 100

          This can be used to speed up the generation of 
          the plot for larger data sets.

          The percent point function for the Topp and Leone
          distribution is available in closed form, so
          this option is typically not needed.

       2) For the ks plot, we can fix the location and scale.
          This is equivalent to assuming that the lower and
          upper limits are known (e.g., we could use the
          data minimum and maximum as the lower and upper
          limit values).  Given that the lower and upper
          limits are LOWLIM and UPPLIM, enter the commands

             LET KSLOC   = LOWLIM
             LET KSSCALE = UPPLIM

          The ppcc plot is invariant to location and scale,
          so we cannot fix the lower and upper limits.

    The maximum likelihood estimate of beta can be computed
    with the command

        TOPP AND LEONE MAXIMUM LIKELIHOOD Y

    The maximum likelihood estimate of beta is;

        betahat = N/{SUM[i=1 to N][LOG(1/(2*X(i) - X(i)**2)]}

    If the range of the data is outside the (0,1) interval,
    the data is standardized by subtracting the data minimum
    and dividing by the data maximum minus the data minimum.

    The BOOTSTRAP DISTRIBUTION command can be used to find
    uncertainty intervals for the ppcc plot, ks plot, and
    maximum likelihood estimates.
       
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TOPCDF = Compute the Topp and Leone cumulative distribution
             function.
    TOPPPF = Compute the Topp and Leone percent point function.
    RGTPDF = Compute the generalized reflected Topp and Leone
             probability density function.
    GTLPDF = Compute the generalized Topp and Leone probability
             density function.
    TSPPDF = Compute the two-sided power probability density
             function.
    BETPDF = Compute the beta probability density function.
    TRIPDF = Compute the triangular probability density function.
    TRAPDF = Compute the trapezoid probability density function.
    UNIPDF = Compute the uniform probability density function.
    POWPDF = Compute the power probability density function.
    JSBPDF = Compute the Johnson SB probability density function.
 
Reference:
    Samuel Kotz and J. Rene Van Dorp 2004, "Beyond Beta:
    Other Continuous Families of Distributions with Bounded
    Support and Applications", World Scientific, chapter 2.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/2
 
Program 1:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR
    .
    LET BETA  = 0.5
    TITLE Beta = ^beta
    PLOT TOPPDF(X,BETA) FOR X = 0  0.01  1
    .
    LET BETA  = 1
    TITLE Beta = ^beta
    PLOT TOPPDF(X,BETA) FOR X = 0  0.01  1
    .
    LET BETA  = 1.5
    TITLE Beta = ^beta
    PLOT TOPPDF(X,BETA) FOR X = 0  0.01  1
    .
    LET BETA  = 2
    TITLE Beta = ^beta
    PLOT TOPPDF(X,BETA) FOR X = 0  0.01  1
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Topp and Leone Probability Density Functions
 
Program 2:
    let beta = 2.2
    let y = topp and leone rand numb for i = 1 1 200
    .
    let betasav = beta
    topp and leone ppcc plot y
    just center
    move 50 5
    let beta = shape
    text maxppcc = ^maxppcc, Beta = ^beta
    move 50 2
    text Betasav = ^betasav
    .
    char x
    line blank
    topp and leone prob plot y
    move 50 5
    text PPA0 = ^ppa0, PPA1 = ^ppa1
    move 50 2
    let upplim = ppa0 + ppa1
    text Lower Limit = ^ppa0, Upper Limit = ^upplim
    char blank
    line solid
    .
    let ksloc = ppa0
    let ksscale = upplim
    topp and leone kolm smir goodness of fit y
    .
    topp and leone mle y

-----TOPPPF (LET)--------------------------------
 
TOPPPF
 
Name:
    TOPPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Topp and Leone percent point function
    with shape parameter beta.
 
Description:
    The standard Topp and Leone distribution has the
    following percent point function:

        G(p;beta) = 1 - SQRT(1 - p**(1/beta))
                    0 <= p <= 1, beta > 0
 
    with beta denoting the shape parameter.

    This distribution can be extended with lower and upper
    bound parameters.  If a and b denote the lower and upper
    bounds, respectively, then the location and scale 
    parameters are:

        location = a
        scale    = b - a

   The general form of the distribution can then be found
   by using the relation

       G(p;beta,a,b) = a + (b-a)*G(p;beta,0,1)

Syntax:
    LET <y> = TOPPPF(<p>,<beta>,<a>,<b>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or variable containing
              values in the interval (0,1);
          <y> is a variable or a parameter (depending on what
              <p> is) where the computed Topp and Leone ppf
              value is stored;
          <beta> is a positive number, parameter, or variable that
              specifies the shape parameter;
          <a> is a number, parameter, or variable that
              specifies the lower limit;
          <b> is a number, parameter, or variable that
              specifies the upper limit;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <a> and <b> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = TOPPPF(0.3,0.2)
    LET Y = TOPPPF(P,0.5,0,5)
    PLOT TOPPPF(P,2,0,3) FOR P = 0  0.01  1
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TOPCDF = Compute the Topp and Leone cumulative distribution
             function.
    TOPPDF = Compute the Topp and Leone probability density
             function.
    RGTPDF = Compute the generalized reflected Topp and Leone
             probability density function.
    GTLPDF = Compute the generalized Topp and Leone probability
             density function.
    TSPPDF = Compute the two-sided power probability density
             function.
    BETPDF = Compute the beta probability density function.
    TRIPDF = Compute the triangular probability density function.
    TRAPDF = Compute the trapezoid probability density function.
    UNIPDF = Compute the uniform probability density function.
    POWPDF = Compute the power probability density function.
    JSBPDF = Compute the Johnson SB probability density function.
 
Reference:
    Samuel Kotz and J. Rene Van Dorp 2004, "Beyond Beta:
    Other Continuous Families of Distributions with Bounded
    Support and Applications", World Scientific, chapter 2.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/2
 
Program 1:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR
    .
    LET BETA  = 0.5
    TITLE Beta = ^beta
    PLOT TOPPPF(P,BETA) FOR P = 0  0.01  1
    .
    LET BETA  = 1
    TITLE Beta = ^beta
    PLOT TOPPPF(P,BETA) FOR P = 0  0.01  1
    .
    LET BETA  = 1.5
    TITLE Beta = ^beta
    PLOT TOPPPF(P,BETA) FOR P = 0  0.01  1
    .
    LET BETA  = 2
    TITLE Beta = ^beta
    PLOT TOPPPF(P,BETA) FOR P = 0  0.01  1
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT TOPP AND LEONE PPF FUNCTIONS
 
-----TPDF (LET)--------------------------------
 
TPDF
 
Name:
    TPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the t probability density function with NU degrees of
    freedom.  The degrees of freedom parameter should be a positive
    integer.
 
Description:
    The t distribution has the following probability density
    function:
       f(x)=(G[A]/(G[B]*SQRT(PI*NU))*(1 + x**2/NU)**-(NU+1)/2
    where
       G[A] = GAMMA[(NU+1)/2]
       G[B] = GAMMA[NU/2]
    and where x can be any real number.  The TPDF function evaluates
    this function for a given x value.
 
Syntax:
    LET <y2> = TPDF(<y1>,NU)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed t pdf value is stored;
          <NU> is a positive number or parameter that specifies the
               degrees of freedom;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TPDF(3,10)
    LET A = TPDF(A1,10)
    LET X2 = TPDF(X1,10)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
    FCDF   = Compute the F cumulative distribution function.
    FPDF   = Compute the F probability density function.
    FPPF   = Compute the F percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    TCDF   = Compute the T cumulative distribution function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, 1970.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    TITLE PLOT TPDF FOR VARIOUS VALUES OF NU
    SEGMENT 1 COORDINATES 71 88 76 88; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 71 84 76 84; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 71 80 76 80; SEGMENT 3 PATTERN DOT
    SEGMENT 4 COORDINATES 71 76 76 76; SEGMENT 4 PATTERN DASH2
    LEGEND 1 NU = 5; LEGEND 1 COORDINATES 77 87
    LEGEND 2 NU = 10; LEGEND 2 COORDINATES 77 83
    LEGEND 3 NU = 20; LEGEND 3 COORDINATES 77 79
    LEGEND 4 NU = 30; LEGEND 4 COORDINATES 77 75
    YLIMITS 0 0.4; MAJOR YTIC NUMBER 5
    MINOR YTIC NUMBER 1; YTIC DECIMAL 1
    LINES SOLID DASH DOT DASH2
    PLOT TPDF(X,5) FOR X = -4 0.1 4 AND
    PLOT TPDF(X,10) FOR X = -4 0.1 4 AND
    PLOT TPDF(X,20) FOR X = -4 0.1 4 AND
    PLOT TPDF(X,30) FOR X = -4 0.1 4
 
-----TPPF (LET)--------------------------------
 
TPPF
 
Name:
    TPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the t percent point function with NU degrees of freedom.
    The degrees of freedom parameter should be a positive integer.
 
Description:
    The t distribution has the following probability density function:
       f(x)=(G[A]/(G[B]*SQRT(PI*NU))*(1 + x**2/NU)**-(NU+1)/2
    where
       G[A] = GAMMA[(NU+1)/2]
       G[B] = GAMMA[NU/2]
    and where x can be any real number.
 
    The percent point function is the inverse of the cumulative
    distribution function.  The cumulative distribution sums the
    probability from 0 to the given x value.  The percent point
    function takes a cumulative probability value and computes the
    corresponding x value.
 
Syntax:
    LET <y2> = TPPF(<y1>,NU)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed t ppf value is stored;
          <NU> is a positive integer number or parameter that specifies
               the degrees of freedom;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TPPF(0.9,10)
    LET A = TPPF(A1,10)
    LET X2 = TPPF(X1,10)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPDF = Compute the chi-square probability density function.
    FCDF   = Compute the F cumulative distribution function.
    FPDF   = Compute the F probability density function.
    FPPF   = Compute the F percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    TCDF   = Compute the T cumulative distribution function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, 1970.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    TITLE PLOT TPPF FOR VARIOUS VALUES OF NU
    SEGMENT 1 COORDINATES 16 88 21 88; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 16 84 21 84; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 16 80 21 80; SEGMENT 3 PATTERN DOT
    SEGMENT 4 COORDINATES 16 76 21 76; SEGMENT 4 PATTERN DASH2
    LEGEND 1 NU = 5; LEGEND 1 COORDINATES 22 87
    LEGEND 2 NU = 10; LEGEND 2 COORDINATES 22 83
    LEGEND 3 NU = 20; LEGEND 3 COORDINATES 22 79
    LEGEND 4 NU = 30; LEGEND 4 COORDINATES 22 75
    XLIMITS 0 1; MAJOR XTIC NUMBER 6
    MINOR XTIC NUMBER 1; XTIC DECIMAL 1
    LINES SOLID DASH DOT DASH2
    PLOT TPPF(X,5) FOR X = 0.01 .01 0.99 AND
    PLOT TPPF(X,10) FOR X = 0.01 .01 0.99 AND
    PLOT TPPF(X,20) FOR X = 0.01 .01 0.99 AND
    PLOT TPPF(X,30) FOR X = 0.01 .01 0.99
 
-----TRACDF (LET)--------------------------------
 
TRACDF
 
Name:
    TRACDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the trapezoidal cumulative distribution function.
 
Description:
    The trapezoidal distribution has the following cumulative
    distribution function:

       F(x|a,b,c,d) = 0                                        x < a
                    = ((b-a)/(d+c-b-a))*((x-a)/(b-a))**2       a <= x < b
                    = ((b-a) + 2*(x-b))/(d+c-b-a)              b <= x < c
                    = 1 - ((d-c)/(d+c-b-a))*((d-x)/(d-c))**2   c <= x < d
                    = 1                                        x >= d

Syntax:
    LET <y> = TRACDF(<x>,<a>,<b>,<c><d>)
                             <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter containing values in
              the interval (a,d);
          <a> is a number, parameter, or variable that specifies the
              first shape parameter;
          <b> is a number, parameter, or variable that specifies the
              second shape parameter;
          <c> is a number, parameter, or variable that specifies the
              third shape parameter;
          <d> is a number, parameter, or variable that specifies the
              fourth shape parameter;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TRACDF(0.5,0,0.25,0.75,1)
    LET A = TRACDF(0.5,A,B,C,D)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TRAPDF = Compute the trapezoidal probability density function.
    TRAPPF = Compute the trapezoidal percent point function.
    TRIPDF = Compute the triangular probability density function.
    UNIPDF = Compute the uniform probability density function.
    SEMPDF = Compute the semi-circular probability density function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "Generalized Trapezoidal Distributions", van Dorp and Kotz,
    Metrika, Vol. 58, Issue 1, July, 2003.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2004/1
 
Program:
    TITLE TRAPEZOIDAL DISTRIBUTION
    LET A = 0
    LET B = 1
    LET C = 5
    LET D = 10
    PLOT TRACDF(X,A,B,C,D) FOR X = A 0.1 10
 
-----TRAN (LET)--------------------------------
 
TRAN
 
Name:
    TRAN (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the transport integral.
 
Description:
    The transport integral of order n is defined as:

        J(x,n) = INTEGRAL[t**n*EXP(t)/((exp(t) - 1)**2)dt]   x >= 0

    where the integral is defined from 0 to x and n, a
    non-negative integer, is the order of the transport
    integral.  Dataplot supports values of n from 2 to 9.

    Dataplot computes this function using ACM Algorithm 757 (see
    Reference: below).
 
Syntax:
    LET <y> = TRAN(<x>,<ord>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative number, variable or parameter;
          <ord> is a non-negative integer number, parameter, or
               variable in the range 2 to 9; 
          <y> is a variable or a parameter (depending on what <x> 
               and <ord> are) where the computed transport integral
               values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TRAN(2.3,2)
    LET A = TRAN(X,A1)
    LET X2 = TRAN(X1,4) FOR X1 = 0.1 0.1 3.0
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ABRAM      = Compute the Abramowitz function.
    CLAUSN     = Compute the Clausen integral.
    DEBYE      = Compute the Debye function.
    EXP3       = Compute the cubic exponential integral.
    GOODST     = Compute the Goodwin and Stanton integral.
    LOBACH     = Compute the Lobachevski integral.
    SYNCH1     = Compute the synchrotron radiation function.
    SYNCH2     = Compute the synchrotron radiation function.
    STROM      = Compute the Stromgren integral.
 
Reference:
    "ACM Transactions of Mathematical Software", Allan MacLead,
    Vol. 22, No. 3, September, 1996, pp. 288-301.
 
Applications:
    Special Functions
 
Implementation Date:
    1999/6
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    TITLE ORDER 2
    PLOT TRAN(X,2) FOR X = 0 0.01 10
    TITLE ORDER 3
    PLOT TRAN(X,3) FOR X = 0 0.01 10
    TITLE ORDER 4
    PLOT TRAN(X,4) FOR X = 0 0.01 10
    TITLE ORDER 5
    PLOT TRAN(X,5) FOR X = 0 0.01 10
    END OF MULTIPLOT
    MOVE 50 97
    CENTER JUSTIFICATION
    TEXT TRANSPORT INTEGRALS

-----TRANSFORM POINTS--------------------------------------------------
 
TRANSFORM POINTS
 
Name:
    TRANSFORM POINTS
 
Type:
    LET Subcommand
 
Purpose:
    Given a set of (X,Y) pairs, perform a location, scaling, and
    rotation transformation.
 
Description:
    The location transformation is

        X' = X - Tx
        Y' = Y - Ty

    with Tx and Ty denoting the X and Y translation, respectively.

    The scaling transformation is

        X' = X*Sx
        Y' = Y*Sy

    with Sx and Sy denoting the X and Y scaling, respectively.

    The rotation transformation is

        X' = COS(THETA)*X + SIN(THETA)*Y
        Y' = -SIN(THETA)*X + COS(THETA)*Y

    with THETA denoting the angle of rotation (in radians).

Syntax:
    LET <yout> <xout>= TRANSFORM POINTS <y> <x> <ty> <tx> <sy> <sx> <theta>
                       <SUBSET/EXPCEPT/FOR qualification>
    where <y> is a variable containing the x-coordinates of the data points
               being transformed;
          <x> is a variable containing the y-coordinates of the data points
               being transformed;
          <ty> is a parameter containg the y-cooredinate translation;
          <tx> is a parameter containg the x-cooredinate translation;
          <sy> is a parameter containg the y-cooredinate scaling;
          <sx> is a parameter containg the x-cooredinate scaling;
          <theta> is a parameter that contains the angle of rotation;
               of the polygon;
          <yout> is a variable containing the y-coordinates of the
               transformed points;
          <xout> is a variable containing the x-coordinates of the
               transformed points;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y2 X2 = TRANSFORM POINTS Y X TY TX SY SX THETA

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    POINTS IN POLYGON  = Determine whether points are in the interior
                         of a convex polygon.
    CONVEX HULL        = Determine the convex hull of a set of points.
    TRANSFORM POINTS   = Perform location, scale, and rotation
                         transformation for a set of points.
    EXTREME POINTS     = Determine the extreme points of a set of points.
    LINE INTERSECTIONS = Determine the intersection points for a set of
                         lines.
    PARALLEL LINE      = Determine the coordinates for a point that defines
                         a parallel line determined by a point and a line
                         defined by two points.
    PERPINDICULAR LINE = Determine the coordinates for a point that defines
                         a perpindicular line determined by a point and a line
                         defined by two points.

Applications:
    Computational Geometry
 
Implementation Date:
    2012/10
 
Program:
    read x y
      0.5333000E+02  0.2357000E+02
      0.5037000E+02  0.1668000E+02
      0.1686000E+02 -0.6469000E+02
      0.5521000E+02  0.2713000E+02
      0.1395000E+02 -0.6794000E+02
      0.5414000E+02  0.2781000E+02
      0.2704000E+02 -0.4195000E+02
      0.1830000E+02 -0.6416000E+02
     -0.8881000E+02 -0.2991900E+03
      0.6442000E+02  0.5613000E+02
     -0.1728800E+03 -0.5288300E+03
      0.4743000E+02  0.1766000E+02
      0.3282400E+03  0.4791700E+03
      0.2137600E+03  0.1424400E+03
      0.2067600E+03  0.1877700E+03
      0.3593000E+02 -0.2923600E+03
      0.3637600E+03  0.3094700E+03
      0.2974600E+03  0.6332000E+02
      0.1759800E+03 -0.1644000E+03
      0.4257500E+03  0.3561300E+03
      0.6733000E+02  0.9115000E+02
      0.5081000E+02  0.2532000E+02
     -0.2029900E+03 -0.5509600E+03
      0.7737000E+02  0.6375000E+02
      0.3363100E+03  0.3074700E+03
      0.1296400E+03 -0.1771600E+03
      0.2421000E+02 -0.5091200E+03
      0.1670100E+03 -0.1446500E+03
      0.2401100E+03 -0.3796800E+03
      0.5067400E+03  0.4129400E+03
      0.5173100E+03  0.4183700E+03
      0.8339000E+02 -0.6446200E+03
      0.1908800E+03  0.3463800E+03
      0.1629900E+03  0.3044400E+03
     -0.1138500E+03 -0.4050300E+03
      0.2787200E+03  0.4979900E+03
     -0.7125000E+02 -0.4863700E+03
      0.2147300E+03  0.1820300E+03
     -0.1757900E+03 -0.5140500E+03
     -0.1993500E+03 -0.5823900E+03
      0.1438700E+03  0.2333900E+03
      0.2134000E+02 -0.6915000E+02
     -0.4354000E+02 -0.4289700E+03
      0.3219800E+03  0.4268300E+03
      0.2507000E+02 -0.2689300E+03
     -0.8324000E+02 -0.5685300E+03
      0.8540000E+02 -0.4379000E+03
      0.7870000E+02 -0.3830800E+03
     -0.1064000E+02 -0.6613600E+03
      0.2023700E+03 -0.3954000E+02
      0.2877000E+02 -0.3549000E+02
      0.1908000E+02 -0.5440000E+02
      0.3766000E+02 -0.1542000E+02
      0.5360000E+02  0.1845000E+02
     -0.1782900E+03 -0.5311500E+03
     -0.9508000E+02 -0.5267900E+03
      0.1183700E+03 -0.6679000E+02
      0.4384000E+02 -0.4773700E+03
      0.1847200E+03 -0.5284000E+02
      0.1714300E+03  0.3265600E+03
      0.1928600E+03  0.3423200E+03
     -0.1705300E+03 -0.4889800E+03
      0.4415000E+02  0.8400000E+01
     -0.1434000E+03 -0.4216400E+03
      0.6579000E+02  0.2837000E+02
    end of data
    .
    let tx = -614.1127
    let ty = -368.6171
    let sx = 0.0008
    let sy = 0.0029
    let theta = 1.1723
    .
    let yt2 xt2 = transform points y x ty tx sy sx theta
    .
    multiplot scale factor 2
    multiplot corner coordinates 5 5 95 95
    multiplot 2 2
    .
    line blank
    character circle
    character hw 1 0.75
    character fill on
    title offset 2
    title case asis
    .
    title Original Data
    plot y x
    .
    title Transformed Data
    tic mark offset units data
    tic mark offset 0.05 0.05
    limits 0 1
    major tic mark number 6
    plot yt2 xt2
  
-----TRANSLATE-------------------------------------------------------

TRANSLATE

Name:
    TRANSLATE

Type:
    Support Command

Purpose:
    Create a user defined string translation for the graphics output.

Description:
    This command is used primarily to handle problems caused by
    communications hardware or software that eats up certain
    characters.  In particular, escape characters are sometimes lost
    (the Tektronix devices make heavy use of the escape character).

Syntax:
    TRANSLATE <old> TO <new>
    where <old> is the original string to be translated;
    and   <new> is the string that it is translated to.

Examples:
    TRANSLATE ESC FF TO ESC ESC FF

Note:
    The following non-printing characters are recognized:
       NUL  = Null character (ASCII 0)
       SOH  = Start of heading (ASCII 1)
       STX  = Start of text (ASCII 2)
       ETX  = End of text (ASCII 3)
       EOT  = End of transmission (ASCII 4)
       ENQ  = Enquiry (ASCII 5)
       ACK  = Acknowledge (ASCII 6)
       BEL  = Ring Bell (ASCII 7)
       BS   = Backspace (ASCII 8)
       HTX  = Horizontal tab (ASCII 9)
       LF   = Line feed (ASCII 10)
       VT   = Vertical tab (ASCII 11)
       FF   = Form Feed (ASCII 12)
       CR   = Carriage return (ASCII 13)
       SO   = Shift out (ASCII 14)
       SI   = Shift in (ASCII 15)
       DLE  = Data link escape (ASCII 16)
       DC1  = Device control 1 (ASCII 17)
       DC2  = Device control 2 (ASCII 18)
       DC3  = Device control 3 (ASCII 19)
       DC4  = Device control 4 (ASCII 20)
       NAK  = Negative acknowledge (ASCII 21)
       SYN  = Synchronous idle (ASCII 22)
       ETB  = End of transmission block (ASCII 23)
       CAN  = Cancel (ASCII 24)
       EM   = End of medium (ASCII 25)
       SUB  = Substitute (ASCII 26)
       ESC  = Escape (ASCII 27)
       FS   = File separator (ASCII 28)
       GS   = Group separator (ASCII 29)
       RS   = Record separator (ASCIII 30)
       US   = Unit separator (ASCII 31)
       SP   = Space (ASCII 32)
       SPA  = Space (ASCII 32)
       BL   = Space (ASCII 32)
       BLA  = Space (ASCII 32)

Default:
    None

Synonyms:
    None

Related Commands:
    DEFINE    = Equate a name with a character sequence.

Applications:
    Graphics Terminals

Implementation Date:
    Pre-1987

Program:
    XX
 
-----TRAPDF (LET)--------------------------------
 
TRAPDF
 
Name:
    TRAPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the trapezoidal probability density function.
 
Description:
    The trapezoidal distribution has the following probability density
    function:

       f(x|a,b,c,d) = u*((x-a)/(b-a))       a <= x < b
                    = u                     b <= x < c
                    = u*((d-x)/(d-c))       c <= x < d
                    = 0                     elsewhere

    where

       u = 2/(d + c - b - a)
       a <= b <= c <= d

    Trapezoidal distributions may be appropriate for modeling
    processes that can be represented by the following three stages:

      1) a growth stage
      2) a period of relative stability stage
      3) a decay stage

    The trapezoidal model is probably the simplest model of this
    type (i.e., the growth and decline stages are linear and the
    stability stage is constant).  The generalized trapezoidal
    distribution allows more flexibility in modeling these stages.

    The uniform (no growth or  decay stages) and triangular
    (no stable stage) distributions are special cases of the
    trapezoidal distribution.
 
Syntax:
    LET <y> = TRAPDF(<x>,<a>,<b>,<c><d>)
                             <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter containing values in
              the interval (a,d);
          <a> is a number, parameter, or variable that specifies the
              first shape parameter;
          <b> is a number, parameter, or variable that specifies the
              second shape parameter;
          <c> is a number, parameter, or variable that specifies the
              third shape parameter;
          <d> is a number, parameter, or variable that specifies the
              fourth shape parameter;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TRAPDF(0.5,0,0.25,0.75,1)
    LET A = TRAPDF(0.5,A,B,C,D)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TRACDF = Compute the trapezoidal cumulative distribution function.
    TRAPPF = Compute the trapezoidal percent point function.
    TRIPDF = Compute the triangular probability density function.
    UNIPDF = Compute the uniform probability density function.
    SEMPDF = Compute the semi-circular probability density function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "Generalized Trapezoidal Distributions", van Dorp and Kotz,
    Metrika, Vol. 58, Issue 1, July, 2003.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2004/1
 
Program:
    TITLE TRAPEZOIDAL DISTRIBUTION
    LET A = 0
    LET B = 1
    LET C = 5
    LET D = 10
    PLOT TRAPDF(X,A,B,C,D) FOR X = A 0.1 10
 
-----TRAPPF (LET)--------------------------------
 
TRAPPF
 
Name:
    TRAPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the trapezoidal percent point function.
 
Description:
    The trapezoidal distribution has the following cumulative
    distribution function:

       F(x|a,b,c,d) = 0                                        x < a
                    = ((b-a)/(d+c-b-a)*((x-a)/(b-a))**2        a <= x < b
                    = ((b-a) + 2*(x-b))/(d+c-b-a)              b <= x < c
                    = 1 - ((d-c)/(d+c-b-a))*((d-x)/(d-c))**2   c <= x < d
                    = 1                                        x > d

    The algorithm for the trapezoid percent point function is
    to compute the cumulative distribution function at the points
    a, b, c, and d.  This is used to determine which of the four
    intervals contains the percent point value.  Then the appropriate
    equation above is inverted to find the value of the percent
    point function.
 
Syntax:
    LET <y> = TRAPPF(<p>,<a>,<b>,<c><d>)
                             <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, number, or parameter containing values in
              the interval (0,1);
          <a> is a number, parameter, or variable that specifies the
              first shape parameter;
          <b> is a number, parameter, or variable that specifies the
              second shape parameter;
          <c> is a number, parameter, or variable that specifies the
              third shape parameter;
          <d> is a number, parameter, or variable that specifies the
              fourth shape parameter;
          <y> is a variable or a parameter (depending on what <p> is)
              where the computed pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TRAPPF(0.95,0,0.25,0.75,1)
    LET A = TRAPPF(0.05,A,B,C,D)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TRACDF = Compute the trapezoidal cumulative distribution function.
    TRAPDF = Compute the trapezoidal probability density function.
    TRIPDF = Compute the triangular probability density function.
    UNIPDF = Compute the uniform probability density function.
    SEMPDF = Compute the semi-circular probability density function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "Generalized Trapezoidal Distributions", van Dorp and Kotz,
    Metrika, Vol. 58, Issue 1, July, 2003.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2004/1
 
Program:
    TITLE TRAPEZOIDAL DISTRIBUTION
    LET A = 0
    LET B = 1
    LET C = 5
    LET D = 10
    PLOT TRAPPF(P,A,B,C,D) FOR P = 0  0.01  1
 
-----TRIANGLE-------------------------------------------------------
 
TRIANGLE
 
Name:
    TRIANGLE
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Draws a triangle.
 
Description:
    The 3 pairs of coordinates define the (x,y) values for each of the
    3 vertices (respectively) of the triangle.
 
Syntax:
    TRIANGLE   <x1>   <y1>   <x2>   <y2>   <x3>   <y3>
    where <x1> is a decimal number or parameter in the range 0 to 100
              that specifies the x coordinate of the first vertex;
          <y1> is a decimal number or parameter in the range 0 to 100
              that specifies the y coordinate of the first vertex;
          <x2> is a decimal number or parameter in the range 0 to 100
              that specifies the x coordinate of the second vertex;
          <y2> is a decimal number or parameter in the range 0 to 100
              that specifies the y coordinate of the second vertex;
          <x3> is a decimal number or parameter in the range 0 to 100
              that specifies the x coordinate of the third vertex;
    and   <y3> is a decimal number or parameter in the range 0 to 100
              that specifies the y coordinate of the third vertex.
 
Examples:
    TRIANGLE 50 50 60 50 55 55
    TRIANGLE 20 50 50 50 35 80
    TRIANGLE 40 40 60 60 50 30
    TRIANGLE X1 Y1 X2 Y2 X3 Y3
    TRIANGLE 20 20 40 40 40 60
 
Note:
    The line style (i.e., solid, dash), color, and thickness are
    controlled by the LINE, LINE COLOR, and LINE THICKNESS commands.
    The REGION FILL command can be used to generate solid filled
    triangles while the REGION PATTERN command can be used to generate
    hatch filled patterns.
 
Note:
    If you use a software font, triangles can be embedded in text
    (e.g., the LEGEND or TEXT command) by entering the string TRIA().
    To get filled triangles, enter LEGEND FILL SOLID (for legends) or
    FILL ON (for TEXT).  Triangles can also be used as plot characters
    (e.g., CHARACTERS TRIANGLE), in which case the attributes are set
    with the various CHARACTER commands.
 
Note:
    The keywords DATA and RELATIVE were added to the TRIANGLE
    command 7/1997.  These keywords are independent and can
    be used separately or together.  For example, 
    TRIANGLE DATA, TRIANGLE RELATIVE, or TRIANGLE DATA RELATIVE.
    The word DATA should come before the word RELATIVE if both
    appear.

    DATA means that the coordinates are specified in terms of
    the data units of the most recent plot rather than Dataplot
    0 to 100 screen units.

    RELATIVE means that the coordinates of the first point
    are drawn in absolute coordinates an all subsequent points
    in the figure are relative to that first point.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CIRCLE           = Draws a circle.
    POINT            = Draws a point.
    ARROW            = Draws an arrow.
    BOX              = Draws a box.
    HEXAGON          = Draws a hexagon.
    SEMI-CIRCLE      = Draws a semi-circle.
    ARC              = Draws an arc.
    ELLIPSE          = Draws an ellipse.
    OVAL             = Draws an oval.
    DIAMOND          = Draws a diamond.
    DRAW             = Draws a line.
    MOVE             = Moves to a point.
    LINES            = Sets the line type for figures and plot lines.
    LINE THICKNESSES = Sets the line thickness for figures and  plot
                       lines.
    LINE COLOR       = Sets the line colors for figures and plot lines.
    REGION           = Sets the region fill switch on or off.
    CROSS-HAIR       = Activates and reads the cross-hair.
    TEXT             = Writes a text string.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    TRIANGLE 10 10 20 10 15 20
    TRIANGLE 60 10 80 3 65 30
    .
    THICKNESS 0.5
    TRIANGLE 10 30 20 21 13 43
    THICKNESS 0.2
    .
    LINE DASH
    TRIANGLE 10 50 20 50 15 60
    LINE SOLID
    .
    LINE COLOR G50
    THICKNESS 0.5
    TRIANGLE 10 80 20 75 12 93
    THICKNESS 0.2
    LINE COLOR BLACK
    .
    REGION FILL ON
    TRIANGLE 30 30 40 25 33 44
    REGION FILL COLOR G50
    TRIANGLE 50 50 70 45 55 63
    REGION FILL COLOR BLACK
    REGION FILL ONTS
    TRIANGLE 40 70 55 62 48 84
    REGION FILL ONF
    REGION PATTERN D1D2
    TRIANGLE 85 10 95 3 88 19
    REGION PATTERN BLANK
    .
    FONT SIMPLEX; THICKNESS 0.2; HEIGHT 3
    MOVE 40 85
    FILL ON
    TEXT TRIA() DRAW A TRIANGLE WITH THE TEXT COMMAND
 
-----TRIANGULAR SOLUTION (LET)-------------------------------------
 
TRIANGULAR SOLUTION
 
Name:
    TRIANGULAR SOLUTION (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Solve a system of linear equations in the following form:
          A*X=B
    where A is an upper triangular (or lower triangular) matrix of
    coefficients, B is a vector of constants, and X are the variables
    to be solved for.
 
Description:
    An upper triangular matrix is one with all zeros below the
    diagonal.  Likewise, a lower triangular matrix is one with all
    zeros above the diagonal.  For example, the Cholesky decomposition
    factors a positive definite matrix (such as a variance-covariance)
    into an upper triangular matrix and its transpose.  Solving an
    upper triangular system allows some simplifications that provide a
    faster solution than the standard LU decomposition used by the
    MATRIX SOLUTION command.  The TRIANGULAR SOLUTION command checks
    whether the matrix is upper or lower triangular by scanning the
    upper half of the matrix.  If a non-zero element is found, the
    matrix is assumed to be upper triangular.  Otherwise it is
    assumed to be lower triangular.
 
Syntax:
    LET <resp> = TRIANGULAR SOLUTION <mat1> <vector>
               <SUBSET/EXCEPT/FOR qualification>
    where <mat1> is a triangular matrix (either upper or lower)
                 containing the coefficients of the equation;
          <vector> is an array of constants (i.e., the values for the
                 right hand side of the equation;
          <resp> is a vector where the resulting matrix solution is
                 saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional (and
                 rarely used in this context).
 
Examples:
    LET X = TRIANGULAR SOLUTION A B
 
Note:
    Dataplot uses a LINPACK routine to solve the triangular system.
 
Note:
    Matrices used to solve systems of linear equations must have the
    same number of rows and columns.  An error message is printed if
    they do not.
 
Note:
    Matrices are created with either the READ MATRIX command or the
    MATRIX DEFINITION command.  Enter HELP MATRIX DEFINITION and HELP
    READ MATRIX for details.
 
Note:
    The columns of a matrix are accessible as variables by appending an
    index to the matrix name.  For example, the 4x4 matrix C has
    columns C1, C2, C3, and C4.  These columns can be operated on like
    any other Dataplot variable.
 
Note:
    The maximum size matrix that Dataplot can handle is set when
    Dataplot is built on a particular site.  The default maximums are
    100 columns and 500 rows.  Earlier versions may be 20 rows and 20
    columns or 100 rows and 100 columns.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    MATRIX ADDITION      = Perform a matrix addition.
    MATRIX ADJOINT       = Compute the adjoint matrix of a matrix.
    MATRIX COFACTOR      = Compute a matrix cofactor.
    MATRIX DEFINITION    = Set a matrix definition.
    MATRIX DETERMINANT   = Compute a matrix determinant.
    MATRIX EIGENVALUES   = Compute the matrix eigenvalues.
    MATRIX EIGENVECTORS  = Compute the matrix eigenvectors.
    MATRIX EUCLID NORM   = Compute the matrix Euclidean norm.
    MATRIX INVERSE       = Compute a matrix inverse.
    MATRIX MINOR         = Compute a matrix minor.
    MATRIX MULTIPLICAT   = Perform a matrix multiplication.
    MATRIX NUMB OF COLU  = Compute the number of columns in a matrix.
    MATRIX NUMB OF ROWS  = Compute the number of rows in a matrix.
    MATRIX RANK          = Compute the rank of a matrix.
    MATRIX SIMPLEX SOLU  = Compute a matrix simplex solution.
    MATRIX SOLUTION      = Solve a system of linear equations.
    MATRIX SPECTRAL NORM = Compute the matrix spectral norm.
    MATRIX SPECTRAL RADI = Compute the matrix spectral radius.
    MATRIX SUBMATRIX     = Define a matrix submatrix.
    MATRIX SUBTRACTION   = Perform a matrix subtraction.
    MATRIX TRACE         = Compute a matrix trace.
    MATRIX TRANSPOSE     = Compute a matrix transpose.
    CORRELATION MATRIX   = Compute the correlation matrix of a matrix.
    VARIANCE-COVA MATRIX = Compute the variance-covariance matrix of a
                           matrix.
    PRINCIPLE COMPONENTS = Compute the principle components of a
                           matrix.
    SINGULAR VALUES      = Compute the singular values of a matrix.
    SINGULAR VALUE DECOM = Compute the singular value decomposition of
                           a matrix.
    SINGULAR VALUE FACT  = Compute the singular value factorization of
                           a matrix.
    TRIANGULAR INVERSE   = Compute a triangular matrix inverse.
    TRIDIAGONAL SOLUTION = Solve a tridiagonal system of linear
                           equations.
 
Reference:
    "LINPACK User's Guide", Dongarra, Bunch, Moler, Stewart.  Siam,
    1979.
 
    "Numerical Recipes: The Art of Scientific Programming (FORTRAN
    Version)", Press, Flannery, Teukolsky, and Vetterling.  Cambridge
    University Press, 1989 (chapter 2).
 
Applications:
    Linear Algebra
 
Implementation Date:
    93/10
 
Program:
    DIMENSION 100 COLUMNS
    READ MATRIX A
    2.0  2.0  -4.0
    0.0 -1.0   2.0
    0.0  0.0   5.0
    END OF DATA
    LET B = DATA 2.0 5.0 0.0
    LET X = TRIANGULAR SOLVE A B
    PRINT X
 
-----TRIANGULAR INVERSE (LET)----------------------------------------
 
TRIANGULAR INVERSE
 
Name:
    TRIANGULAR INVERSE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the inverse of a triangular matrix.
 
Description:
    The inverse is the matrix that when multiplied by the original
    matrix yields the identity matrix (i.e., AA'=I where I has one's on
    the diagonal and zero's everywhere else).
 
    An upper triangular matrix is one with all zeros below the
    diagonal.  Likewise, a lower triangular matrix is one with all
    zeros above the diagonal.  For example, the Cholesky decomposition
    factors a positive definite matrix (such as a variance-covariance)
    into an upper triangular matrix and its transpose.  Finding the
    inverse of a triangular system allows some simplifications that
    provide a faster solution that the standard LU decomposition used
    by the MATRIX INVERSE command.  The TRIANGULAR INVERSE command
    checks whether the matrix is upper or lower triangular by scanning
    the upper half of the matrix.  If a non-zero element is found, the
    matrix is assumed to be upper triangular.  Otherwise it is
    assumed to be lower triangular.
 
Syntax:
    LET <mat2> = TRIANGULAR INVERSE <mat1>
               <SUBSET/EXCEPT/FOR qualification>
    where <mat1> is a matrix for which the inverse is to be computed;
          <mat2> is a matrix where the resulting inverse is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional (and
                 rarely used in this context).
 
Examples:
    LET C = TRIANGULAR INVERSE A
 
Note:
    Dataplot uses a LINPACK routine to find the inverse of the
    triangular system.
 
Note:
    Matrices for which the inverse to be computed  must have the same
    number of rows and columns.  An error message is printed if they do
    not.
 
Note:
    Matrices are created with either the READ MATRIX command or the
    MATRIX DEFINITION command.  Enter HELP MATRIX DEFINITION and HELP
    READ MATRIX for details.
 
Note:
    The columns of a matrix are accessible as variables by appending an
    index to the matrix name.  For example, the 4x4 matrix C has
    columns C1, C2, C3, and C4.  These columns can be operated on like
    any other Dataplot variable.
 
Note:
    The maximum size matrix that Dataplot can handle is set when
    Dataplot is built on a particular site.  The default maximums are
    100 columns and 500 rows.  Earlier versions may be 20 rows and 20
    columns or 100 rows and 100 columns.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    MATRIX ADDITION      = Perform a matrix addition.
    MATRIX ADJOINT       = Compute the adjoint matrix of a matrix.
    MATRIX COFACTOR      = Compute a matrix cofactor.
    MATRIX DEFINITION    = Set a matrix definition.
    MATRIX DETERMINANT   = Compute a matrix determinant.
    MATRIX EIGENVALUES   = Compute the matrix eigenvalues.
    MATRIX EIGENVECTORS  = Compute the matrix eigenvectors.
    MATRIX EUCLID NORM   = Compute the matrix Euclidean norm.
    MATRIX INVERSE       = Compute the inverse of a matrix.
    MATRIX MINOR         = Compute a matrix minor.
    MATRIX MULTIPLICAT   = Perform a matrix multiplication.
    MATRIX NUMB OF COLU  = Compute the number of columns in a matrix.
    MATRIX NUMB OF ROWS  = Compute the number of rows in a matrix.
    MATRIX RANK          = Compute the rank of a matrix.
    MATRIX SIMPLEX SOLU  = Compute a matrix simplex solution.
    MATRIX SOLUTION      = Solve a system of linear equations.
    MATRIX SPECTRAL NORM = Compute the matrix spectral norm.
    MATRIX SPECTRAL RADI = Compute the matrix spectral radius.
    MATRIX SUBMATRIX     = Define a matrix submatrix.
    MATRIX SUBTRACTION   = Perform a matrix subtraction.
    MATRIX TRACE         = Compute a matrix trace.
    MATRIX TRANSPOSE     = Compute a matrix transpose.
    CORRELATION MATRIX   = Compute the correlation matrix of a matrix.
    VARIANCE-COVA MATRIX = Compute the variance-covariance matrix of a
                           matrix.
    PRINCIPLE COMPONENTS = Compute the principle components of a
                           matrix.
    SINGULAR VALUES      = Compute the singular values of a matrix.
    SINGULAR VALUE DECOM = Compute the singular value decomposition of
                           a matrix.
    SINGULAR VALUE FACT  = Compute the singular value factorization of
                           a matrix.
    TRIANGULAR SOLUTION  = Solve a triangular system of linear
                           equations.
    TRIDIAGONAL SOLUTION = Solve a tridiagonal system of linear
                           equations.
 
Reference:
    "LINPACK User's Guide", Dongarra, Bunch, Moler, Stewart.  Siam,
    1979.
 
    "Numerical Recipes: The Art of Scientific Programming (FORTRAN
    Version)", Press, Flannery, Teukolsky, and Vetterling.  Cambridge
    University Press, 1989 (chapter 2).
 
Applications:
    Linear Algebra
 
Implementation Date:
    93/10
 
Program:
    READ MATRIX A
    2.0  2.0  -4.0
    0.0 -1.0   2.0
    0.0  0.0   5.0
    END OF DATA
    LET AINV = TRIANGULAR INVERSE A
    PRINT AINV
 
-----TRICDF (LET)--------------------------------
 
TRICDF
 
Name:
    TRICDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the triangular probability density function.
 
Description:
    The triangular distribution has the following probability density
    function:
       f(x) = 2*(x-a)/[(b-a)*(c-a)]       a <= x <= c
            = 2*(b-x)/[(b-a)*(b-c)]       c <  x <= b
    The parameter c is the shape parameter, a is the location
    parameter, and b is the upper limit.  The scale parameter is
    (b-a)/2.  Dataplot defines the standard distribution for a equal
    -1 and b equal 1.  For this case, the triangular distribution
    reduces to:
       f(x) = (x+1)/(c+1)                -1 <= x <= c
            = (1-x)/(1-c)                 c <  x <= 1
    Some references define the standard distribution with a equal 0
    and b equal 1.
 
    The cumulative distribution is the area from a to x (i.e., the
    integral of the above function).  For the standard distribution,
    it has the formula:

       F(x) = (x+1)**2/[2*(c+1)]          -1 <= x <= c
            = 1 - (1-x)**2/[2*(1-c)]       c <  x <= 1
Syntax:
    LET <y> = TRICDF(<y>,<c>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter containing values in
              the interval (-1,1);
          <c> is a number, parameter, or variable containing values in
              the interval (-1,1);
          <y> is a variable or a parameter (depending on what <x> and
              <c> are) where the computed pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TRICDF(0.5,0)
    LET X2 = TRICDF(X1,0.5)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TRIPDF = Compute the triangular probability density function.
    TRIPPF = Compute the triangular percent point function.
    UNICDF = Compute the uniform cumulative distribution function.
    UNIPDF = Compute the uniform probability density function.
    UNIPPF = Compute the uniform percent point function.
    UNISF  = Compute the uniform sparsity function.
    SEMCDF = Compute the semi-circular cumulative distribution
             function.
    SEMPDF = Compute the semi-circular probability density function.
    SEMPPF = Compute the semi-circular percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
 
Reference:
    "Statistical Distributions", 2nd. Edition, Evans, Hastings, and
    Peacock, John Wiley and Sons (chapter 39).
 
Applications:
    XX
 
Implementation Date:
    94/9
 
Program:
    TITLE TRIANGULAR DISTRIBUTIONS
    PLOT TRICDF(X,0) FOR X = -1 .1 1 AND
    PLOT TRICDF(X,0.5) FOR X = -1 .1 1 AND
    PLOT TRICDF(X,-0.5) FOR X = -1 .1 1
 
-----TRICOMI (LET)--------------------------------
 
TRICOMI
 
Name:
    TRICOMI (LET)
 
Type:
    Library Function
 
Purpose:
    Compute Tricomi's form of the incomplete gamma function.
 
Description:
    Tricomi's form of the incomplete gamma function is defined as:
        TRICOMI(X,A) = (X**(-A)/GAMMA(A))*INTEGRAL(T**(A-1)*EXP(-T))dt
                                                   X >= 0,  A > 0
    where the integral is taken from 0 to x and GAMMA is the gamma
    function.
 
Syntax:
    LET <y2> = TRICOMI(<y1>,<a>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a non-negative number, variable or parameter;
          <a> is a positive number, parameter, or variable; 
          <y2> is a variable or a parameter (depending on what <y1> 
               and <a> are) where the computed values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TRICOMI(2.3,1)
    LET A = TRICOMI(X,A1)
    LET X2 = TRICOMI(X1,4.2)
 
Note:
    Dataplot uses the routine DGAMIT from the SLATEC Common
    Mathematical Library to compute this function.  SLATEC is a large
    set of high quality, portable, public domain Fortran routines for
    various mathematical capabilities maintained by seven federal
    laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GAMMAI     = Compute the incomplete gamma function.
    GAMMAR     = Compute the reciprocal gamma function.
    GAMMA      = Compute the gamma function.
    LOGGAMMA   = Compute the log (to base e) gamma function.
    GAMMAIP    = Compute an alternate form of the incomplete gamma
                 function.
    GAMMAIC    = Compute the complementary incomplete Gamma function.
    DIGAMMA    = Compute the digamma function.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE TRICOMI'S INCOMPLETE GAMMA FUNCTIONS
    LINE SOLID DASH DOT
    PLOT TRICOMI(X,0.5) FOR X = 0.01 0.01 5 AND
    PLOT TRICOMI(X,1) FOR X = 0.01 0.01 5 AND
    PLOT TRICOMI(X,3) FOR X = 0.1 0.1 10 AND
    PLOT TRICOMI(X,5) FOR X = 0.1 0.1 10
 
-----TRICUBE (LET)----------------------------------------------
 
TRICUBE
 
Name:
    TRICUBE (LET)
 
Type:
    Subcommand under LET
 
Purpose:
    Carry out a tricube transformation (also called a triweight
    transformation).
 
Description:
    The triweight transformation is most often applied to the residuals
    from a (linear or non-linear) fit.  The tricube transformation has
    the advantage that it allows the analyst to carry out subsequent
    weighted linear or non-linear fits that are robust and resistive to
    outliers in the data.  The tricube transformation is defined as
    follows:
       1) m      = the median absolute residual (from some previous fit)
       2) cutoff = 6 * m
       3) T(res) = (1- (res/cutoff)**3 )**3     if abs(res) < cutoff
          T(res) = 0                            if abs(res) >= cutoff
    The transformed residuals are then usually used as weights in a
    subsequent fit.  This subsequent fit will be robust.  The following
    is a typical sequence using TRICUBE--
       FIT Y = A+B*EXP(-C*X)  Carry out an unweighted (that is,
                              equally-weighted) fit.
       LET W = TRICUBE RES    Use the residuals from the unweighted fit
                              to create robust/resistive weights.
       WEIGHTS W              The next fit will be a weighted fit with
                              the weights found in W.
       FIT Y = A+B*EXP(-C*X)  Carry out a weighted fit using robust
                              tricubed weights.
 
Syntax:
    LET <v1> = TRICUBE <v2>   <SUBSET/EXCEPT/FOR qualification>
    where <v2> is the input variable of residuals from a previous fit;
          <v1> is an output variable where the tricube-transformed
               values are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET W = TRICUBE RES
    LET W2 = TRICUBE RES
 
Default:
    None
 
Synonyms:
    TRIWEIGHT for TRICUBE
 
Related Commands:
    FIT             = Carries out a least squares fit.
    RES             = A variable containing the residuals from a FIT.
    WEIGHTS         = Specifies the weights variable.
    BIWEIGHT (LET)  = Carry out a biweight transformation
 
Reference:
    "Graphical Methods for Data Analysis", Chambers, Cleveland, Kleiner,
    and Tukey, Wadsworth, 1983 (page 122).
 
Applications:
    Robust Fitting
 
Implementation Date:
    88/7
 
Program:
    LET X = DATA 1 2 3 4 5 6 7 8 9 10
    LET Y = DATA 2 4 60 7 9 12 14 15 18 20
    FIT Y = A+B*X
    LET PRED2 = PRED
    CHARACTER CIRCLE BLANK BLANK
    LINE BLANK SOLID DASH
    SEGMENT 1 COORDINATES 65 85 70 85
    SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 65 81 70 81
    SEGMENT 2 PATTERN DASH
    LEGEND 1 ORIGINAL FIT
    LEGEND 2 BIWEIGHT FIT
    LEGEND 1 COORDINATES 72 84
    LEGEND 2 COORDINATES 72 80
    TITLE AUTOMATIC
    LET B = TRIWEIGHT RES
    WEIGHTS B
    FIT Y = A+B*X
    PLOT Y PRED2 PRED VS X
 
-----TRIGAMMA (LET)--------------------------------
 
TRIGAMMA
 
Name:
    TRIGAMMA (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the trigamma function.
 
Description:
    The digamma function is the logarithmic derivative of the gamma
    function defined as:

        digamma(x) = GAMMA'(x)/GAMMA(x)

    where GAMMA is the gamma function and GAMMA' is the derivative of
    the gamma function.

    The trigamma function is the derivative of the digamma function and
    is defined as

        trigamma(x) = digamma'(x)
                    = d^2/dx^2 LN(GAMMA(x))
                    = SUM[n = 0 to infinity][1/(x+n)**2]

  This function is defined for positive numbers.
 
Syntax:
    LET <y> = TRIGAMMA(<x>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, variable or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed trigamma values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TRIGAMMA(1)
    LET X2 = TRIGAMMA(X1)
    LET X2 = TRIGAMMA(X1-4)
 
Note:
    Dataplot uses the routine DPSIFN from the SLATEC Common Mathematical
    Library to compute this function.  SLATEC is a large set of high
    quality, portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal laboratories.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GAMMA      = Compute the gamma function.
    DIGAMMA    = Compute the digamma function.
    LOGGAMMA   = Compute the log (to base e) gamma function.
 
Reference:
    D. E. Amos (1983), "A portable Fortran subroutine for derivatives of
    the Psi function", Algorithm 610, ACM Transactions on Mathematical
    Software 9, 4, pp. 494-502.

    Abramowitz and Stegun, "Handbook of Mathematical Functions, Applied
    Mathematics Series, Vol. 55", National Bureau of Standards, 1964
    (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    2014/12
 
Program:
    TITLE CASE ASIS
    TITLE Trigamma Function
    PLOT TRIGAMMA(X) FOR X = 0.2 0.1 4
 
-----TRILINEAR PLOT--------------------------------------
 
TRILINEAR PLOT
 
Name:
    TRILINEAR PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a trilinear plot.
 
Description:
    The trilinear plot is used for the special case where
    all rows of 3 variables are positive and sum to 1 (or
    100 if percentages are used).

    The plot frame is an equilateral triangle.  The plot
    coordinates for point (x1,x2,x3) is determined by drawing
    a line from each vertex to the opposite side of the
    triangle such that the line is perpindicular to the
    opposite side.  The intersection of these 3 lines defines
    the plot point.

    In Dataplot,

       1) Variable 1 is plotted from the bottom side (= 0)
          to the center, top vertex (= 1).

       2) Variable 2 is plotted from the right side (= 0)
          to the left, bottom vertex (= 1).

       3) Variable 3 is plotted from the left side (= 0)
          to the right, bottom vertex (= 1).


Syntax 1:
    TRILINEAR PLOT <y1> <y2> <y3> <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable containing the values for the first
               component;
          <y2> is a variable containing the values for the second
               component;
          <y3> is a variable containing the values for the third
               component;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    In this syntax, there is a single curve.

Syntax 2:
    TRILINEAR PLOT <y1> <y2> <y3> <groupid>
                   <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable containing the values for the first
               component;
          <y2> is a variable containing the values for the second
               component;
          <y3> is a variable containing the values for the third
               component;
          <groupid> is a group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for the case where there are multiple
    curves on the same plot.

Examples:
    TRILINEAR PLOT Y1 Y2 Y3
    TRILINEAR PLOT Y1 X1 Z1
    TRILINEAR PLOT Y1 X1 Z1 BATCH
 
Note:
    If the TIC MARK LABELS are ON, the 0 and 1 (or 100) label
    is plotted.  No tic marks or intermediate values are
    plotted.  However, if a GRID ON command is entered, grid
    lines will be drawn.
 
    Axis labels are not generated.  You can use the LEGEND
    command to add labels if desired.

    See the Program section below for an example.

Note:
    As with the PLOT command, the CHARACTER and LINE commands
    (and the associated attribute setting commands) can be
    used to control the appearance of the plot.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    PLOT            = Generates a data or function plot.
    LINES           = Sets the type for plot lines.
    CHARACTER       = Sets the type for plot characters.
 
Reference:
    Wainer (1997), "Visual Revelations: Graphical Tales of Fate
    and Deception from Napolean Bonaporte to Ross Perot",
    Copernicus, pp. 111-118.

Applications:
    Data Analysis
 
Implementation Date:
    2006/12
     
Program:
    read y1 y2 y3
    0.2 0.5 0.3
    0.3 0.6 0.1
    0.4 0.1 0.5
    0.5 0.2 0.3
    0.2 0.2 0.6
    0.3 0.4 0.3
    0.8 0.1 0.1
    end of data
    .
    let n = size y1
    char circ
    line blank all
    char size 1 all
    char fill on all
    xlimits 0 1
    major x1tic mark number 6
    grid on
    grid pattern dotted
    x1tic marks on
    x1tic mark labels on
    .
    frame corner coordinates 20 18 80 88
    .
    legend case asis
    legend justification center
    legend 1 Component A
    legend 2 Component B
    legend 3 Component C
    legend 1 coordinates 50 95
    legend 2 coordinates 20 11
    legend 3 coordinates 80 11
    .
    trilinear plot y1 y2 y3
 
-----TRIMMED MEAN (LET)-----------------------------------------
 
TRIMMED MEAN
 
Name:
    TRIMMED MEAN (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the trimmed mean for a variable.
 
Description:
    The mean is the sum of the observations divided by the number of
    observations.  The mean can be heavily influenced by extreme values
    in the tails of a variable.  The trimmed mean compensates for this
    by dropping a certain percentage of values on the tails.  For
    example, the 50% trimmed mean is the mean of the values between
    the upper and lower quartiles.  The 90% trimmed mean is the mean
    of the values after truncating the lowest and highest 5% of the
    values.
 
Syntax:
    LET <par> = TRIMMED MEAN <y1> <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the response variable;
          <par> is a parameter where the computed trimmed mean is
                stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TRIMMED MEAN Y1
    LET A = TRIMMED MEAN Y1 SUBSET TAG > 2
 
Note:
    The analyst must specify the percentages to trim in each tail.
    This is done by defining the internal variables P1 (the lower
    tail) and P2 (the upper tail).  For example, to trim 10% off each
    tail, do the following:

        LET P1 = 10
        LET P2 = 10
        LET A = TRIMMED MEAN Y
 
Note:
    Support for the trimmed mean has been added to the following
    plots and commands:

        LET P1 = 10
        LET P2 = 10

        TRIMMED MEAN PLOT Y X
        CROSS TABULATE TRIMMED MEAN PLOT Y X1 X2
        BOOTSTRAP TRIMMED MEAN PLOT Y
        JACKNIFE TRIMMED MEAN PLOT Y
        DEX TRIMMED MEAN PLOT Y X1 ... XK
        TRIMMED MEAN BLOCK PLOT Y X1 .... XK
        TRIMMED MEAN INFLUENCE CURVE Y
 
        TABULATE TRIMMED MEAN Y X1
        CROSS TABULATE TRIMMED MEAN Y X1 X2
        LET Y2 = CROSS TABULATE TRIMMED MEAN Y X1 X2
        LET V = MATRIX <COLUMN/ROW> TRIMMED MEAN M
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TRIMMED MEAN PLOT    = Generate a trimmed mean vs. subset plot.
    MEAN                 = Compute the mean.
    WINDSORIZED MEAN     = Compute the Windsorized mean.
    MEDIAN               = Compute the median.
    STANDARD DEVIATION   = Compute the standard deviation.
    TRIMMED SD           = Compute the trimmed standard deviation.
 
Applications:
    Robust Data Analysis
 
Implementation Date:
    Pre-1987
 
Program:
    LET Y1 = CAUCHY RANDOM NUMBERS FOR I = 1 1 100
    LET P1 = 10
    LET P2 = 10
    LET A1 = TRIMMED MEAN Y1
 
-----TRIMMED MEAN PLOT-------------------------------------------
 
TRIMMED MEAN PLOT
 
Name:
    TRIMMED MEAN PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a trimmed mean plot.
 
Description:
    A trimmed mean plot is a plot consisting of subsample trimmed
    means versus subsample index.  The subsample trimmed mean is the
    mean of the data with 100p1% of the data deleted from the bottom
    and 100p2% of the data deleted from the top of the ascendingly-
    ordered data set.  The trimmed mean plot is used to answer the
    question--"Does the subsample location change over different
    subsamples?".  It consists of:
       Vertical   axis = subsample trimmed mean;
       Horizontal axis = subsample index.
    The trimmed mean plot yields 2 traces:
       1. a subsample trimmed mean trace; and
       2. a full-sample trimmed mean reference line.
    Like usual, the appearance of these 2 traces is
    controlled by the first 2 settings of the LINES,
    CHARACTERS, SPIKES, BARS, and similar attributes.
 
Syntax:
    TRIMMED MEAN PLOT <y> <x>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response (= dependent) variable;
          <x> is the subsample identifier variable (this variable
             appears on the horizontal axis);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    TRIMMED MEAN PLOT Y X
    TRIMMED MEAN PLOT Y X1
 
Note:
    The analyst usually precedes the TRIMMED MEAN PLOT command with 2
    LET commands of the following type:
        LET P1 = .05
        LET P2 = .10
    where P1 and P2 are both between 0 and 1 so as to indicate the
    amount of data to be trimmed from the left and right respectively.
    In the example here, P1 = .05 and P2 = .10 indicates that 5% of
    the smallest data and 10% of the largest data should be trimmed
    off before forming the mean.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHARACTERS         = Sets the type for plot characters.
    LINES              = Sets the type for plot lines.
    MEAN   PLOT        = Generates a mean plot.
    MEDIAN PLOT        = Generates a median plot.
    MIDMEAN PLOT       = Generates a midmean plot.
    MIDRANGE PLOT      = Generates a midrange plot.
    WINDSOR MEAN PLOT  = Generates a Windsorized mean plot.
    SD   PLOT          = Generates a standard deviation plot.
    BOX PLOT           = Generates a box plot.
    XBAR CHART         = Generates an xbar control chart.
    PLOT               = Generates a data or function plot.
 
Applications:
    Quality Control
 
Implementation Date:
    88/2
 
Program:
    SKIP 25
    READ GEAR.DAT Y X
    LET P1 = 10
    LET P2 = 10
    LINE BLANK DASH
    CHARACTER X BLANK
    XTIC OFFSET 0.2 0.2
    Y1LABEL TRIMMED MEAN
    X1LABEL SAMPLE ID
    TITLE AUTOMATIC
    TRIMMED MEAN PLOT Y X
 
-----TRIMMED MEAN CONFIDENCE LIMITS------------------------------------
 
TRIMMED MEAN CONFIDENCE LIMITS
 
Name:
    TRIMMED MEAN CONFIDENCE LIMITS
 
Type:
    Analysis Command
 
Purpose:
    Generates a trimmed mean based confidence interval for the
    location of a variable.
 
Description:
    Mosteller and Tukey (see Reference section below) define
    two types of robustness:

      1) resistance means that changing a small part, even by a
         large amount, of the data does not cause a large change
         in the estimate

      2) robustness of efficiency means that the statistic has
         high efficiency in a variety of situations rather than
         in any one situation.  Efficiency means that the estimate
         is close to optimal estimate given that we distribution
         that the data comes from.  A useful measure of efficiency
         is:

              Efficiency = (lowest variance feasible)/
                           (actual variance)
   
    Many statistics have one of these properties.  However,
    it can be difficult to find statistics that are both
    resistant and have robustness of efficiency.

    Standard confidence intervals are based on the mean and
    variance.  These are the optimal estimators if the data
    are in fact from a Gaussian population.  However, they
    lack both resistance and robustness of efficiency.  The
    trimmed mean is computed by removing a specified percentage
    of data values in each tail.  The trimmed mean is less
    affected by outliers (i.e., resistance) than the mean.
    On the other hand, it uses more information than the median
    (i.e., robustness of efficiency) than the median.  That is,
    the trimmed mean provides a location measure that is more
    resistant than the mean, but has more robustness of efficiency
    than the median.

    The trimmed mean confidence interval for the population trimmed
    mean location is defined by:

       xbar(t) +/- TPPF(1-alpha/2,n-g-1)*s(w)/[(1-lambda)*SQRT(n)]

    where

       xbar(t)  = sample trimmed mean
       TPPF     = the t percent point function
       s(w)     = the sample Winsorized standard deviation
       alpha    = the significance level
       n        = the sample size
       p1       = fraction trimmed from lower tail
       p2       = fraction trimmed from upper tail
       g        = integer portion of (P1+P2)*N
       lambda   = p1 + p2

Syntax:
    TRIMMED MEAN CONFIDENCE LIMITS  <y> 
                                    <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable,
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET P1 = 10
    LET P2 = 10
    TRIMMED MEAN CONFIDENCE LIMITS Y1

    LET P1 = 20
    LET P2 = 20
    TRIMMED MEAN CONFIDENCE LIMITS Y1  SUBSET TAG > 2
 
Note:
    The trimming percentages are specified with the LET command.
    Specifically, define the parameters P1 (lower trimming
    percentage) and P2 (upper trimming percentage).  For example,

       LET P1 = 10
       LET P2 = 10

Note:
    A table of confidence intervals is printed for alpha levels of
    50.0, 75.0, 90.0, 95.0, 99.0, 99.9, 99.99, and 99.999.  The sample
    trimmed mean estimate and sample trimmed mean standard error
    are also printed.  The t-value and t-value X standard error
    are printed in the table.
 
Note:
    You can also compute a confidence interval using the
    TRIMMED MEAN BOOTSTRAP PLOT.  Wilcox recommends using the
    "percentile t bootstrap" method (this is a refinement of the
    trimmed mean bootstrap estimate).  The "percentile t bootstrap"
    is not currently supported in Dataplot.

Default:
    None
 
Synonyms:
    TRIMMED MEAN CONFIDENCE INTERVAL
 
Related Commands:
    CONFIDENCE LIMITS          = Compute a Gaussian based confidence
                                 limit.
    BIWEIGHT CONFIDENCE LIMITS = Compute a trimmed mean based confidence
                                 limit.
    T-TEST                     = Perform a t-test.
    TRIMMED MEAN PLOT          = Generate a trimmed mean (versus
                                 subset plot).
    TRIMMED MEAN               = Compute a trimmed mean.
    WINSORIZED MEAN            = Compute a Winsorized mean.
 
Reference:
    "Introduction to Robust Estimation and Hypothesis Testing",
    Rand R. wilcox, Academic Press, 1997.
 
Applications:
    Robust Data Analysis
 
Implementation Date:
    2003/2
 
Program:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET Y2 = LOGISTIC RANDOM NUMBERS FOR I = 1 1 100
    LET Y3 = CAUCHY RANDOM NUMBERS FOR I = 1 1 100
    LET Y4 = DOUBLE EXPONENTIAL RANDOM NUMBERS FOR I = 1 1 100
    LET P1 = 10
    LET P2 = 10
    TRIMMED MEAN CONFIDENCE LIMITS Y1
    TRIMMED MEAN CONFIDENCE LIMITS Y2
    TRIMMED MEAN CONFIDENCE LIMITS Y3
    TRIMMED MEAN CONFIDENCE LIMITS Y4
 
-----TRIMMED STANDARD DEVIATION (LET)--------------------------------
 
TRIMMED STANDARD DEVIATION
 
Name:
    TRIMMED STANDARD DEVIATION (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the trimmed standard deviation for a variable.
 
Description:
    The standard deviation of a variable is defined as

        s = SQRT{SUM[i=1 to n][(X(i) - xbar)**2]/(n-1)}

    with n and xbar denoting the sample size and the sample
    mean, respectively.  The standard deviation can be heavily
    influenced by extreme values.  The trimmed standard deviation
    compensates for this by dropping a certain percentage of values
    from the tails.  For example, the 50% trimmed standard deviation
    is the standard deviation of the values between the upper and
    lower quartiles.  The 90% trimmed standard deviation is the
    standard deviation of the values after truncating the lowest
    and highest 5% of the values.
 
Syntax:
    LET <a> = TRIMMED STANDARD DEVIATION <y>
              <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <a> is a parameter where the computed trimmed standard
                deviation is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TRIMMED STANDARD DEVIATION Y1
    LET A = TRIMMED STANDARD DEVIATION Y1 SUBSET TAG > 2
 
Note:
    The analyst must specify the percentages to trim in each tail.
    This is done by defining the internal variables P1 (the lower
    tail) and P2 (the upper tail).  For example, to trim 10% off each
    tail, do the following:

        LET P1 = 10
        LET P2 = 10
        LET A = TRIMMED STANDARD DEVIATION Y
 
Note:
    Support for the trimmed standard deviation has been added
    to the following plots and commands:

        LET P1 = 10
        LET P2 = 10

        TRIMMED STANDARD DEVIATION PLOT Y X
        CROSS TABULATE TRIMMED STANDARD DEVIATION PLOT Y X1 X2
        BOOTSTRAP TRIMMED STANDARD DEVIATION PLOT Y
        JACKNIFE TRIMMED STANDARD DEVIATION PLOT Y
        DEX TRIMMED STANDARD DEVIATION PLOT Y X1 ... XK
        TRIMMED STANDARD DEVIATION BLOCK PLOT Y X1 .... XK
        TRIMMED STANDARD DEVIATION INFLUENCE CURVE Y
 
        TABULATE TRIMMED STANDARD DEVIATION Y X1
        CROSS TABULATE TRIMMED STANDARD DEVIATION Y X1 X2
        LET Y2 = CROSS TABULATE TRIMMED STANDARD DEVIATION Y X1 X2
        LET V = MATRIX <COLUMN/ROW> TRIMMED STANDARD DEVIATION M
 
Default:
    None
 
Synonyms:
    TRIMMED SD
 
Related Commands:
    STATISTIC PLOT       = Generate a statistic vs. subset plot.
    STANDARD DEVIATION   = Compute the standard deviation.
    WINSORIZED SD        = Compute the Winsorized sd.
    BIWEIGHT SCALE       = Compute the biweight scale statistic.
    TRIMMED MEAN         = Compute the trimmed mean.
 
Applications:
    Robust Data Analysis
 
Implementation Date:
    2007/5
 
Program:
    LET Y1 = CAUCHY RANDOM NUMBERS FOR I = 1 1 100
    LET P1 = 10
    LET P2 = 10
    LET A1 = TRIMMED STANDARD DEVIATION Y1
 
-----TRIMMED MEAN STANDARD ERROR (LET)-------------------------------
 
TRIMMED MEAN STANDARD ERROR
 
Name:
    TRIMMED MEAN STANDARD ERROR (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the standard error of the trimmed mean for a variable.
 
Description:
    The mean is the sum of the observations divided by the number of
    observations.  The mean can be heavily influenced by extreme values
    in the tails of a variable.  The trimmed mean compensates for this
    by dropping a certain percentage of values on the tails.  For
    example, the 50% trimmed mean is the mean of the values between
    the upper and lower quartiles.  The 90% trimmed mean is the mean
    of the values after truncating the lowest and highest 5% of the
    values.
 
    Mosteller and Tukey (see Reference section below) define
    two types of robustness:

      1) resistance means that changing a small part, even by a
         large amount, of the data does not cause a large change
         in the estimate

      2) robustness of efficiency means that the statistic has
         high efficiency in a variety of situations rather than
         in any one situation.  Efficiency means that the estimate
         is close to optimal estimate given that we know what
         distribution that the data comes from.  A useful measure
         of efficiency is:

              Efficiency = (lowest variance feasible)/
                           (actual variance)
   
    Many statistics have one of these properties.  However,
    it can be difficult to find statistics that are both
    resistant and have robustness of efficiency.

    For location estimaors, the mean is the optimal estimator for
    Gaussian data.  However, it is not resistant and it does not
    have robustness of efficiency. The trimmed mean estimator is
    both resistant and robust of efficiency.

    The standard error of the trimmed mean can be used to estimate
    the uncertainty of the trimmed mean estimate (and to create
    confidence intervals).  The trimmed mean standard error is
    defined as:

         se(tm) = s(w)/[(1 - (gamma1 + gamma2))*SQRT(n)

    where s(w) is the Winsorized standard deviation (enter
    HELP WINSORIZED STANDARD DEVIATION for details), gamma1 is the
    lower trimming fraction, gamma2 is the upper trimming fraction,
    and n is the sample size.

    Tukey and Mclaughlin suggest the following confidence
    interval for the trimmed mean:

         Xbar(t) +/- t(1-alpha/2,n-2*g-1)*se(tm)

    where alpha is the desired significance level, t is the
    student t-distribution, and g = [gamma*n] (the integer portion
    of the trimming fraction times the sample size).  Note that
    we are assuming equal trimming on both tails (gamma = .10 means
    we trim 10% on both tails).
    
    An alternative method for confidence intervals is to use
    the BOOTSTRAP TRIMMED MEAN PLOT command and use appropriate
    percentiles of the generated bootstrap trimmed mean values.
    Wilcox suggests a refinement of the standard bootstrap,
    which he calls he percentile t bootstrap, which has better
    performance than the standard bootstrap.   Dataplot does
    not currently support this refinement.

Syntax:
    LET <par> = TRIMMED MEAN STANDARD ERROR <y1> 
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the response variable;
          <par> is a parameter where the computed trimmed mean
                standard error is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TRIMMED MEAN STANDARD ERROR Y1
    LET A = TRIMMED MEAN STANDARD ERROR Y1 SUBSET TAG > 2
 
Note:
    The analyst must specify the percentages to trim in each tail.
    This is done by defining the internal variables P1 (the lower
    tail) and P2 (the upper tail).  For example, to trim 10% off each
    tail, do the following:

        LET P1 = 10
        LET P2 = 10
        LET A = TRIMMED MEAN STANDARD ERROR Y
 
Note:
    Support for the trimmed mean standard error has been added
    to the following plots and commands:

       TRIMMED MEAN STANDARD ERROR PLOT
       CROSS TABULATE TRIMMED MEAN STANDARD ERROR PLOT
       BOOTSTRAP TRIMMED MEAN STANDARD ERROR PLOT
       JACKNIFE TRIMMED MEAN STANDARD ERROR PLOT
       DEX TRIMMED MEAN STANDARD ERROR PLOT
       TRIMMED MEAN STANDARD ERROR INFLUENCE CURVE
       TRIMMED MEAN STANDARD ERROR INTERACTION STATISTIC PLOT

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TRIMMED MEAN          = Compute the trimmed mean.
    MEAN                  = Compute the mean.
    WINSORIZED MEAN       = Compute the Winsorized mean.
    MEDIAN                = Compute the median.
    STATISTIC PLOT        = Generate a statistic versus group
                            plot for a given statistic.
    CROSS TABULATE PLOT   = Generate a statistic versus group
                            plot for a given statistic and two
                            group variables.
    BOOTSTRAP PLOT        = Generate a bootstrap plot for a
                            given statistic.
    DEX PLOT              = Generate various types of design
                            of experiment plots.
    INFLUENCE CURVE       = Generate an influence curve for a
                            given statistic.
    INTERACTION STAT PLOT = Generate an interaction plot for a
                            given statistic.
 
Reference:
    "Introduction to Robust Estimation and Hypothesis Testing",
    Rand Wilcox, Academic Press, 1997.

    "Less Vunerable Confidence and Significance Procedures for
    Location Based on a Single Sample: Trimming/Winsorization",
    Tukey and McLaughlin, Sankhya A 25, 331-352.

    "Data Analysis and Regression: A Second Course in Statistics",
    Mosteller and Tukey, Addison-Wesley, 1977, pp. 203-209.

Applications:
    Robust Data Analysis
 
Implementation Date:
    2002/7
 
Program 1:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET Y2 = LOGISTIC RANDOM NUMBERS FOR I = 1 1 100
    LET Y3 = CAUCHY RANDOM NUMBERS FOR I = 1 1 100
    LET Y4 = DOUBLE EXPONENTIAL RANDOM NUMBERS FOR I = 1 1 100
    LET A1 = TRIMMED MEAN STANDARD ERROR Y1
    LET A2 = TRIMMED MEAN STANDARD ERROR Y2
    LET A3 = TRIMMED MEAN STANDARD ERROR Y3
    LET A4 = TRIMMED MEAN STANDARD ERROR Y4
 
Program 2:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    MULTIPLOT SCALE FACTOR 2
    X1LABEL DISPLACEMENT 12
    .
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 200
    LET Y2 = CAUCHY RANDOM NUMBERS FOR I = 1 1 200
    LET P1 = 10
    LET P2 = 10
    .
    BOOTSTRAP SAMPLES 500
    BOOTSTRAP TRIMMED MEAN STANDARD ERROR PLOT Y1
    X1LABEL B025 = ^B025, B975=^B975
    HISTOGRAM YPLOT
    X1LABEL
    .
    BOOTSTRAP BIWEIGHT MIDVARIANCE PLOT Y1
    X1LABEL B025 = ^B025, B975=^B975
    HISTOGRAM YPLOT
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 46
    TEXT TRIMMED MEAN SE BOOTSTRAP: CAUCHY
    MOVE 50 96
    TEXT TRIMMED MEAN SE BOOTSTRAP: NORMAL
 
-----TRIPDF (LET)--------------------------------
 
TRIPDF
 
Name:
    TRIPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the triangular probability density function.
 
Description:
    The triangular distribution has the following probability density
    function:
       f(x) = 2*(x-a)/[(b-a)*(c-a)]       a <= x <= c
            = 2*(b-x)/[(b-a)*(b-c)]       c <  x <= b
    The parameter c is the shape parameter, a is the location
    parameter, and b is the upper limit.  The scale parameter is
    (b-a)/2.  Dataplot defines the standard distribution for a equal
    -1 and b equal 1.  For this case, the triangular distribution
    reduces to:
       f(x) = (x+1)/(c+1)                -1 <= x <= c
            = (1-x)/(1-c)                 c <  x <= 1
    Some references define the standard distribution with a equal 0
    and b equal 1.
 
Syntax:
    LET <y> = TRIPDF(<y>,<c>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter containing values in
              the interval (-1,1);
          <c> is a number, parameter, or variable containing values in
              the interval (-1,1);
          <y> is a variable or a parameter (depending on what <x> and
              <c> are) where the computed pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TRIPDF(0.5,0)
    LET X2 = TRIPDF(X1,0.5)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TRICDF = Compute the triangular cumulative distribution function.
    TRIPPF = Compute the triangular percent point function.
    UNICDF = Compute the uniform cumulative distribution function.
    UNIPDF = Compute the uniform probability density function.
    UNIPPF = Compute the uniform percent point function.
    UNISF  = Compute the uniform sparsity function.
    SEMCDF = Compute the semi-circular cumulative distribution
             function.
    SEMPDF = Compute the semi-circular probability density function.
    SEMPPF = Compute the semi-circular percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
 
Reference:
    "Statistical Distributions", 2nd. Edition, Evans, Hastings, and
    Peacock, John Wiley and Sons (chapter 39).
 
Applications:
    XX
 
Implementation Date:
    94/9
 
Program:
    TITLE TRIANGULAR DISTRIBUTIONS
    PLOT TRIPDF(X,0) FOR X = -1 .1 1 AND
    PLOT TRIPDF(X,0.5) FOR X = -1 .1 1 AND
    PLOT TRIPDF(X,-0.5) FOR X = -1 .1 1
 
-----TRIPPF (LET)--------------------------------
 
TRIPPF
 
Name:
    TRIPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the triangular percent point function.
 
Description:
    The triangular distribution has the following probability density
    function:
       f(x) = 2*(x-a)/[(b-a)*(c-a)]       a <= x <= c
            = 2*(b-x)/[(b-a)*(b-c)]       c <  x <= b
    The parameter c is the shape parameter, a is the location
    parameter, and b is the upper limit.  The scale parameter is
    (b-a)/2.  Dataplot defines the standard distribution for a equal
    -1 and b equal 1.  For this case, the triangular distribution
    reduces to:
       f(x) = (x+1)/(c+1)                -1 <= x <= c
            = (1-x)/(1-c)                 c <  x <= 1
    Some references define the standard distribution with a equal 0
    and b equal 1.
 
    The percent point function is the inverse of the cumulative
    distribution function.  The cumulative distribution sums the
    probability from 0 to the given x value (i.e., the integral of the
    above function).  The percent point function takes a cumulative
    probability value and computes the corresponding x value.  For the
    standard distribution, it has the formula:
       G(p) = -1 + SQRT(2*p(c+1))         0 <= p <= 0.5
            = 1 - SQRT(2*(1-p)*(1-c))     0.5 < p <= 1
    The input value is a real number between 0 and 1 (since it
    corresponds to a probability).  The output value will be a real
    number in the interval (-1,1).
 
Syntax:
    LET <y> = TRIPPF(<p>,<n>)  <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, variable or parameter in the range 0 to 1;
          <y> is a variable or a parameter (depending on what <p> is)
              where the computed triangular ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TRIPPF(0.9,0)
    LET X2 = TRIPPF(0.95,0.5)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TRICDF = Compute the triangular cumulative distribution function.
    TRIPDF = Compute the triangular probability density function.
    UNICDF = Compute the uniform cumulative distribution function.
    UNIPDF = Compute the uniform probability density function.
    UNIPPF = Compute the uniform percent point function.
    UNISF  = Compute the uniform sparsity function.
    SEMCDF = Compute the semi-circular cumulative distribution
             function.
    SEMPDF = Compute the semi-circular probability density function.
    SEMPPF = Compute the semi-circular percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
 
Reference:
    "Statistical Distributions", 2nd. Edition, Evans, Hastings, and
    Peacock, John Wiley and Sons (chapter 39).
 
Applications:
    XX
 
Implementation Date:
    94/9
 
Program:
    XLIMITS 0 1
    MAJOR XTIC NUMBER 6
    MINOR XTIC NUMBER 1
    XTIC DECIMAL 1
    YLIMITS 0 1
    YTIC OFFSET 0.05 0.05
    TITLE TRIANGULAR PERCENT POINT FUNCTIONS
    PLOT TRIPPF(P,0) FOR P = 0.01 .01 0.99 AND
    PLOT TRIPPF(P,0.5) FOR P = 0.01 .01 0.99 AND
    PLOT TRIPPF(P,0.5) FOR P = 0.01 .01 0.99
 
-----TRIWEIGHT (LET)---------------------------------------------

TRIWEIGHT

Name:
    TRIWEIGHT (LET)
 
Type:
    Subcommand under LET
 
Purpose:
    Carry out a triweight transformation (also called a tricube
    transformation) of residuals from a (linear or non-linear) fit.
 
Description:
    The triweight transformation has the advantage that it allows the
    analyst to carry out subsequent weighted linear or non-linear fits
    that are robust and resistive to outliers in the data.  The
    triweight transformation is defined as follows:
       1) m      = the median absolute residual (from a previous fit)
       2) cutoff = 6 * m
       3) T(res) = (1- (res/cutoff)**3 )**3 if abs(res) < cutoff
          T(res) = 0                        if abs(res) >= cutoff
    The transformed residuals are then usually used as weights in a
    subsequent fit.  This subsequent fit will be robust.  The
    following is a typical sequence using TRIWEIGHT:
       FIT Y = A+B*EXP(-C*X)  To carry out an unweighted (that is,
                              equally-weighted) fit.
       LET W = TRIWEIGHT RES  To use the residuals from the unweighted
                              fit to create robust/resistive weights.
       WEIGHTS W              To tell Dataplot that the next fit is a
                              weighted fit with the weights in W.
       FIT Y = A+B*EXP(-C*X)  To carry out a weighted fit using robust
                              triweighted weights.
 
Syntax:
    LET <v1> = TRIWEIGHT <v2>   <SUBSET/EXCEPT/FOR qualification>
    where <v1> is the output variable containing the
               triweight-transformed values;
          <v2> is the input variable of residuals from a previous fit;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET W = TRIWEIGHT RES
    LET W2 = TRIWEIGHT RES   SUBSET GROUP > 2
 
Default:
    None
 
Synonyms:
    TRICUBE for TRIWEIGHT
 
Related Commands:
    FIT             = Carries out a least squares fit.
    RES             = A variable containing the residuals from a FIT.
    WEIGHTS         = Specifies the weights variable.
    BIWEIGHT (LET)  = Carry out a biweight transformation.
 
Reference:
    "Graphical Methods for Data Analysis", Chambers, Cleveland,
    Kleiner, and Tukey.  Wadsworth, 1983 (page 121).
 
Applications:
    Robust Fitting
 
Implementation Date:
    88/3

Program:
    LET X = DATA 1 2 3 4 5 6 7 8 9 10
    LET Y = DATA 2 4 60 7 9 12 14 15 18 20
    FIT Y = A+B*X
    PLOT Y PRED VS X
    LET WT = TRIWEIGHT RES
    WEIGHTS WT
    FIT Y = A+B*X
    PLOT Y PRED VS X
 
-----TRUE NEGATIVE (LET)--------------------------------
 
TRUE NEGATIVE
 
Name:
    TRUE NEGATIVE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the proportion of true negatives between two
    binary variables.
 
Description:
    Given two variables with n parired observations where each
    variable has exactly two possible outcomes, we can generate
    the following 2x2 table:

                      |       Variable 2        |
        Variable 1    |   Success      Failure  |  Row Total
        ====================================================
        Success       |   N11            N12    |  N11 + N12
        Failure       |   N21            N22    |  N21 + N22
        ====================================================
        Column Total  |   N11+N21      N12+N22  |  Total

    The parameters N11, N12, N21, and N22 denote the counts
    for each category.
 
    Success and failure can denote any binary response.
    Dataplot expects "success" to be coded as "1" and "failure"
    to be coded as "0".  Some typical examples would be:

       1) Variable 1 denotes whether or not a patient has a
          disease (1 denotes disease is present, 0 denotes
          disease not present).  Variable 2 denotes the result
          of a test to detect the disease (1 denotes a positive
          result and 0 denotes a negative result).

       2) Variable 1 denotes whether an object is present or
          not (1 denotes present, 0 denotes absent). Variable 2
          denotes a detection device (1 denotes object detected
          and 0 denotes object not detected).

    In these examples, the "ground truth" is typically given
    as variable 1 while some estimator of the ground truth is
    given as variable 2.
   
    The proportion of true negatives is then N22/N (i.e., the
    number of cases where variable 1 and variable 2 are both
    "failures").  In the context of the first examples above,
    the test does not detect the disease when it was in fact
    not present.

Syntax:
    LET <par> = TRUE NEGATIVE <y1> <y2>
                              <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed true negative
               proportion is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TRUE NEGATIVE Y1 Y2
    LET A = TRUE NEGATIVE Y1 Y2 SUBSET TAG > 2
 
Note:
    The two variables must have the same number of elements.
 
Note:
    There are two ways you can define the response variables:

       1) Raw data - in this case, the variables contain
          0's and 1's.

          If the data is not coded as 0's and 1's, Dataplot
          will check for the number of distinct values.  If
          there are two distinct values, the minimum value
          is converted to 0's and the maximum value is
          converted to 1's.  If there is a single distinct
          value, it is converted to 0's if it is less than
          0.5 and to 1's if it is greater than or equal to
          0.5.  If there are more than two distinct values,
          an error is returned.

       2) Summary data - if there are two observations, the
          data is assummed to be the 2x2 summary table.
          That is,

              Y1(1) = N11
              Y1(2) = N21
              Y2(1) = N12
              Y2(2) = N22
 
Note:
    This commands returns the proportion of true negatives.
    If you need raw counts or percentages, you can enter
    the commands

        LET N = SIZE Y1
        LET TRUEPOS = TRUE NEGATIVE Y1 Y2
        LET TPCOUNT = N*TRUEPOS
        LET TPPERC = 100*TRUEPOS

Note:
    This command has been extended to support the case
    for RxC tables where R denotes the number of categories
    for variable one and C denotes the number of categories
    for variable two.  Note that Dataplot assumes that the
    categories can be meaningfully ordered (Dataplot assumes
    a "small" to "large" ordering).

    In this case, if variable one denotes "ground truth" and
    variable two denotes the estimate of ground truth, then
    we define:

       1) A correct value is the case where the estimated
          category is the same as the ground truth category.

          For this case, we do not distinguish between
          "true positives" and "true negatives" as we do
          for the 2x2 case.

       2) A false positive is the case where the estimated
          category is too large.

       3) A false negative is the case where the estimated
          category is too small.

    So the number of true negatives is simply the number of
    times where the value for variable two is equal to
    the corresponding value for variable one.  As another
    way of thinking of this, if you generate a cross-tabulation
    of the two variables, the number of true negatives is the
    sum of the elements on the diagonal in this table.
    The TRUE POSITIVE and TRUE NEGATIVE commands are treated
    as synonyms for the RxC case.

    The RxC case is currently only supported for raw data.

Note:
    The following additional commands are supported

        TABULATE TRUE NEGATIVE  Y1 Y2 X
        CROSS TABULATE TRUE NEGATIVE Y1 Y2 X1 X2

        TRUE NEGATIVES PLOT Y1 Y2 X
        CROSS TABULATE TRUE NEGATIVES PLOT Y1 Y2 X1 X2

        BOOTSTRAP TRUE NEGATIVES PLOT Y1 Y2
        JACKNIFE  TRUE NEGATIVES PLOT Y1 Y2

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TRUE POSITIVES             = Compute the proportion of
                                 true positives.
    FALSE POSITIVES            = Compute the proportion of
                                 false positives.
    FALSE NEGATIVES            = Compute the proportion of
                                 false negatives.
    TEST SENSITIVITY           = Compute the test sensitivity.
    TEST SPECIFICITY           = Compute the test specificity.
    ODDS RATIO                 = Compute the bias corrected
                                 log(odds ratio).
    ODDS RATIO STANDARD ERROR  = Compute the standard error of the
                                 bias corrected log(odds ratio).
    RELATIVE RISK              = Compute the relative risk.
    TABULATE                   = Compute a statistic for data with
                                 a single grouping variable.
    CROSS TABULATE             = Compute a statistic for data with
                                 two grouping variables.
    STATISTIC PLOT             = Generate a plot of a statistic for
                                 data with a single grouping
                                 variable.
    CROSS TABULATE PLOT        = Generate a plot of a statistic for
                                 data with two grouping variables.
    BOOTSTRAP PLOT             = Generate a bootstrap plot for a
                                 given statistic.
 
Reference:
    Fleiss, Levin, and Paik (2003), "Statistical Methods for
    Rates and Proportions", Third Edition, Wiley, chapter 1.
 
Applications:
    Categorical Data Analysis
 
Implementation Date:
    2007/4
 
Program:
    let n = 1
    .
    let p = 0.2
    let y1 = binomial rand numb for i = 1 1 100
    let p = 0.1
    let y2 = binomial rand numb for i = 1 1 100
    .
    let p = 0.4
    let y1 = binomial rand numb for i = 101 1 200
    let p = 0.08
    let y2 = binomial rand numb for i = 101 1 200
    .
    let p = 0.15
    let y1 = binomial rand numb for i = 201 1 300
    let p = 0.18
    let y2 = binomial rand numb for i = 201 1 300
    .
    let p = 0.6
    let y1 = binomial rand numb for i = 301 1 400
    let p = 0.45
    let y2 = binomial rand numb for i = 301 1 400
    .
    let p = 0.3
    let y1 = binomial rand numb for i = 401 1 500
    let p = 0.1
    let y2 = binomial rand numb for i = 401 1 500
    .
    let x = sequence 1 100 1 5
    .
    let a = true negatives y1 y2 subset x = 1
    tabulate true negatives y1 y2 x
    .
    label case asis
    xlimits 1 5
    major xtic mark number 5
    minor xtic mark number 0
    xtic mark offset 0.5 0.5
    ytic mark offset 0.05 0.05
    y1label Proportion of True Negatives
    x1label Group ID
    character x blank
    line blank solid
    .
    true negatives plot y1 y2 x
 
-----TRUE POSITIVE (LET)--------------------------------
 
TRUE POSITIVE
 
Name:
    TRUE POSITIVE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the proportion of true positives between two
    binary variables.
 
Description:
    Given two variables with n parired observations where each
    variable has exactly two possible outcomes, we can generate
    the following 2x2 table:

                      |       Variable 2        |
        Variable 1    |   Success      Failure  |  Row Total
        ====================================================
        Success       |   N11            N12    |  N11 + N12
        Failure       |   N21            N22    |  N21 + N22
        ====================================================
        Column Total  |   N11+N21      N12+N22  |  Total

    The parameters N11, N12, N21, and N22 denote the counts
    for each category.
 
    Success and failure can denote any binary response.
    Dataplot expects "success" to be coded as "1" and "failure"
    to be coded as "0".  Some typical examples would be:

       1) Variable 1 denotes whether or not a patient has a
          disease (1 denotes disease is present, 0 denotes
          disease not present).  Variable 2 denotes the result
          of a test to detect the disease (1 denotes a positive
          result and 0 denotes a negative result).

       2) Variable 1 denotes whether an object is present or
          not (1 denotes present, 0 denotes absent). Variable 2
          denotes a detection device (1 denotes object detected
          and 0 denotes object not detected).

    In these examples, the "ground truth" is typically given
    as variable 1 while some estimator of the ground truth is
    given as variable 2.
   
    The proportion of true positives is then N11/N (i.e., the
    number of cases where variable 1 and variable 2 are both
    "successes").  In the context of the first examples above,
    the test detected the disease when it was in fact present.

Syntax:
    LET <par> = TRUE POSITIVE <y1> <y2>
                              <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed true positive
               proportion is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TRUE POSITIVE Y1 Y2
    LET A = TRUE POSITIVE Y1 Y2 SUBSET TAG > 2
 
Note:
    The two variables must have the same number of elements.
 
Note:
    There are two ways you can define the response variables:

       1) Raw data - in this case, the variables contain
          0's and 1's.

          If the data is not coded as 0's and 1's, Dataplot
          will check for the number of distinct values.  If
          there are two distinct values, the minimum value
          is converted to 0's and the maximum value is
          converted to 1's.  If there is a single distinct
          value, it is converted to 0's if it is less than
          0.5 and to 1's if it is greater than or equal to
          0.5.  If there are more than two distinct values,
          an error is returned.

       2) Summary data - if there are two observations, the
          data is assummed to be the 2x2 summary table.
          That is,

              Y1(1) = N11
              Y1(2) = N21
              Y2(1) = N12
              Y2(2) = N22
 
Note:
    This commands returns the proportion of true positives.
    If you need raw counts or percentages, you can enter
    the commands

        LET N = SIZE Y1
        LET TRUEPOS = TRUE POSITIVE Y1 Y2
        LET TPCOUNT = N*TRUEPOS
        LET TPPERC = 100*TRUEPOS

Note:
    This command has been extended to support the case
    for RxC tables where R denotes the number of categories
    for variable one and C denotes the number of categories
    for variable two.  Note that Dataplot assumes that the
    categories can be meaningfully ordered (Dataplot assumes
    a "small" to "large" ordering).

    In this case, if variable one denotes "ground truth" and
    variable two denotes the estimate of ground truth, then
    we define:

       1) A correct value is the case where the estimated
          category is the same as the ground truth category.

          For this case, we do not distinguish between
          "true positives" and "true negatives" as we do
          for the 2x2 case.

       2) A false positive is the case where the estimated
          category is too large.

       3) A false negative is the case where the estimated
          category is too small.

    So the number of true positives is simply the number of
    times where the value for variable two is equal to
    the corresponding value for variable one.  As another
    way of thinking of this, if you generate a cross-tabulation
    of the two variables, the number of true positives is the
    sum of the elements on the diagonal in this table.
    The TRUE POSITIVE and TRUE NEGATIVE commands are treated
    as synonyms for the RxC case.

    The RxC case is currently only supported for raw data.

Note:
    The following additional commands are supported

        TABULATE TRUE POSITIVE  Y1 Y2 X
        CROSS TABULATE TRUE POSITIVE Y1 Y2 X1 X2

        TRUE POSITIVES PLOT Y1 Y2 X
        CROSS TABULATE TRUE POSITIVES PLOT Y1 Y2 X1 X2

        BOOTSTRAP TRUE POSITIVES PLOT Y1 Y2
        JACKNIFE  TRUE POSITIVES PLOT Y1 Y2

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TRUE NEGATIVES             = Compute the proportion of
                                 true negatives.
    FALSE POSITIVES            = Compute the proportion of
                                 false positives.
    FALSE NEGATIVES            = Compute the proportion of
                                 false negatives.
    TEST SENSITIVITY           = Compute the test sensitivity.
    TEST SPECIFICITY           = Compute the test specificity.
    ODDS RATIO                 = Compute the bias corrected
                                 log(odds ratio).
    ODDS RATIO STANDARD ERROR  = Compute the standard error of the
                                 bias corrected log(odds ratio).
    RELATIVE RISK              = Compute the relative risk.
    TABULATE                   = Compute a statistic for data with
                                 a single grouping variable.
    CROSS TABULATE             = Compute a statistic for data with
                                 two grouping variables.
    STATISTIC PLOT             = Generate a plot of a statistic for
                                 data with a single grouping
                                 variable.
    CROSS TABULATE PLOT        = Generate a plot of a statistic for
                                 data with two grouping variables.
    BOOTSTRAP PLOT             = Generate a bootstrap plot for a
                                 given statistic.
 
Reference:
    Fleiss, Levin, and Paik (2003), "Statistical Methods for
    Rates and Proportions", Third Edition, Wiley, chapter 1.
 
Applications:
    Categorical Data Analysis
 
Implementation Date:
    2007/4
 
Program:
    let n = 1
    .
    let p = 0.2
    let y1 = binomial rand numb for i = 1 1 100
    let p = 0.1
    let y2 = binomial rand numb for i = 1 1 100
    .
    let p = 0.4
    let y1 = binomial rand numb for i = 101 1 200
    let p = 0.08
    let y2 = binomial rand numb for i = 101 1 200
    .
    let p = 0.15
    let y1 = binomial rand numb for i = 201 1 300
    let p = 0.18
    let y2 = binomial rand numb for i = 201 1 300
    .
    let p = 0.6
    let y1 = binomial rand numb for i = 301 1 400
    let p = 0.45
    let y2 = binomial rand numb for i = 301 1 400
    .
    let p = 0.3
    let y1 = binomial rand numb for i = 401 1 500
    let p = 0.1
    let y2 = binomial rand numb for i = 401 1 500
    .
    let x = sequence 1 100 1 5
    .
    let a = true positives y1 y2 subset x = 1
    tabulate true positives y1 y2 x
    .
    label case asis
    xlimits 1 5
    major xtic mark number 5
    minor xtic mark number 0
    xtic mark offset 0.5 0.5
    ytic mark offset 0.05 0.05
    y1label Proportion of True Positives
    x1label Group ID
    character x blank
    line blank solid
    .
    true positives plot y1 y2 x
 
-----TRUNCATED INFORMATIVE QUANTILE PLOT-------------------------------
 
TRUNCATED INFORMATIVE QUANTILE PLOT
 
Name:
    TRUNCATED INFORMATIVE QUANTILE PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a truncated informative quantile plot.
 
Description:
    Given a response variable, the truncated informative quantile plot
    can be used to identify which location-scale distribution best fits
    that data.  In the context of the MIL-HANDBOOK-17, it is used to
    distinguish whether the data is most consistent with a normal, a
    2-parameter lognormal, or a 2-parameter Weibull distribution.

    A univariate location-scale parametric distribution is one where
    the cumulative distribution function can be described as

        F(x) = F0((x-a)/b)

    with a and b denoting the location and scale parameters, respectively
    and F0 denotes the "standard" distribution (i.e., the location
    parameter is 0 and the scale parameter is 1).  This means the
    distribution has no shape parameters.  The 2-parameter lognormal is
    handled by taking the log of the data and then using the normal
    distribution.  Similarly, the 2-parameter Weibull is handled by
    taking the log of the data and using the Gumbel distribution.

    The estimated IQ function is defined by

        IQhat(u) = (Qhat(u) - Q^(0.5))/(2*(Qhat(0.75) - Qhat(0.25)))

    where Q(u) is the estimated quantile function (enter
    HELP EMPIRICAL QUANTILE PLOT for details).  The corresponding exact
    function, denoted by IQ(u), replaces Qhat with Q in the above formula.
    The estimated IQhat values are determined from the data while the
    exact IQ values are determined from a theoretical location-scale
    distribution (e.g., the normal, uniform, or Gumbel).

    The estimated truncated IQ function is defined by

        TIQhat(u) = -1         if IQhat(u) <= -1
                  = IQhat(u)   if -1 < IQhat(u) <= 1
                  = 1          if IQhat(u) > 1

    This command plots the estimated truncated IQ function versus u and
    also plots the IQ function versus u for a specified theoretical
    distribution.  The curve based on the data is compared to the curve
    for the theoretical distribution.  The curve based on the data will
    typically be less smooth.  However, the curves can be compared for
    general shape and tail behavior.

    Although the MIL-HANDBOOK-17 is primarily concerned with the normal,
    2-parameter lognormal, and 2-parameter Weibull distributions, Dataplot
    supports this command for 19 different distributions.

    These plots are suggested as exploratory data analysis techniques
    in the MIL-HANDBK-17 (2002 edition).  They were originally suggested
    by Parzen (see References below).

Syntax:
    <dist> TRUNCATED INFORMATIVE QUANTILE PLOT  <y>
                                 <SUBSET/EXCEPT/FOR qualification>
    where <dist> specifies the theoretical distribution and is one of:
                 NORMAL
                 LOGNORMAL
                 UNIFORM
                 GUMBEL
                 WEIBULL
                 LOGISTIC
                 DOUBLE EXPONENTIAL
                 CAUCHY
                 SEMICIRCULAR
                 COSINE
                 ANGLIT
                 HYPERBOLIC SECANT
                 HALF-NORMAL
                 ARCSINE
                 EXPONENTIAL
                 HALF-CAUCHY
                 SLASH
                 RAYLEIGH
                 MAXWELL
          <y> is a response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    Note that the 2-parameter lognormal is handled by taking the log of
    the data and then using the normal distribution.  The 2-parameter
    Weibull is handled by taking the log of the data and then using the
    Gumbel distribution.  The log of the data will be taken by the
    Dataplot code, so you should not take the log of the data before
    entering this command.

Examples:
    NORMAL TRUNCATED INFORMATIVE QUANTILE PLOT Y1
    WEIBULL TRUNCATED INFORMATIVE QUANTILE PLOT Y1
 
Default:
    None
 
Synonyms:
    TIQ is a synonym for TRUNCATED INFORATIVE QUANTILE.
 
Related Commands:
    LINES                       = Sets the type for plot lines.
    CHARACTERS                  = Sets the type for plot characters.
    EMPIRICAL QUANTILE PLOT     = Generate a empirical quantile plot.
    EMPIRICAL CDF PLOT          = Generates a tail area plot.
    KAPLAN MEIER PLOT           = Generates a Kaplan Meier plot.
    PROBABILITY PLOT            = Generates a probability plot.
    PLOT                        = Generates a data or function plot.

References:
    "MIL-HDBK-17-1F Volume 1: Guidelines for Characterization of
    Structural Materials", Depeartment of Defense, pp. 8-38, 8-39, 2002.
 
    Parzen (1983), "Informative Quantile Functions and Identification of
    Probability Distribution Types", Technical Report No. A-26, Texas A&M
    University.
 
Applications:
    Reliability
 
Implementation Date:
    2017/03
 
Program:
    . Step 1:   Define some default plot control features
    .
    title offset 2
    title case asis
    case asis
    label case asis
    line color blue red
    multiplot scale factor 2
    multiplot corner coordinates 5 5 95 95
    .
    . Step 3:   Demonstrate TIQ PLOT
    .
    y1label IQ(u)
    x1label u
    title automatic
    line solid solid
    line color black red
    character blank all
    .
    delete x
    let n = 1000
    let x1 = normal random numbers for i = 1 1 n
    let x2 = exponential random numbers for i = 1 1 n
    let x3 = double exponential random numbers for i = 1 1 n
    let gamma = 2.7
    let x4 = weibull random numbers for i = 1 1 n
    multiplot 2 2
    .
    title ^n Normal Random Numbers
    normal tiq plot x1
    .
    title ^n Exponential Random Numbers
    exponential tiq plot x2
    .
    title ^n Double Exponential Random Numbers
    double exponential tiq plot x3
    .
    title ^n Weibull Random Numbers
    weibull tiq plot x4
    .
    end of multiplot
    .
    let x1 = uniform random numbers for i = 1 1 n
    let x2 = cosine random numbers for i = 1 1 n
    let x3 = rayleigh exponential random numbers for i = 1 1 n
    let sigma = 2.7
    let x4 = lognormal random numbers for i = 1 1 n
    multiplot 2 2
    .
    title ^n Uniform Random Numbers
    uniform tiq plot x1
    .
    title ^n Cosine Random Numbers
    cosine tiq plot x2
    .
    title ^n rayleigh Random Numbers
    rayleigh tiq plot x3
    .
    title ^n Lognormal Random Numbers
    lognormal tiq plot x4
    .
    end of multiplot
    .
    let x1 = gumbel random numbers for i = 1 1 n
    let x2 = logistic random numbers for i = 1 1 n
    let x3 = maxwell random numbers for i = 1 1 n
    let x4 = slash random numbers for i = 1 1 n
    .
    multiplot 2 2
    .
    title ^n Gumbel Random Numbers
    gumbel tiq plot x1
    .
    title ^n Logistic Random Numbers
    logistic tiq plot x2
    .
    title ^n Maxwell Random Numbers
    maxwell tiq plot x3
    .
    title ^n slash Random Numbers
    slash tiq plot x4
    .
    end of multiplot
    .
    let x1 = cauchy random numbers for i = 1 1 n
    let r = 1
    let x2 = semi-circular random numbers for i = 1 1 n
    let x3 = anglit random numbers for i = 1 1 n
    let x4 = arcsine random numbers for i = 1 1 n
    multiplot 2 2
    .
    title ^n Cauchy Random Numbers
    cauchy tiq plot x1
    .
    title ^n Anglit Random Numbers
    anglit tiq plot x3
    .
    title ^n Arcsine Random Numbers
    arcsine tiq plot x4
    .
    end of multiplot
    .
    let x1 = half-normal random numbers for i = 1 1 n
    let x2 = half-cauchy random numbers for i = 1 1 n
    let x3 = hyperbolic secant exponential random numbers for i = 1 1 n
    multiplot 2 2
    .
    title ^n Half-Normal Random Numbers
    half-normal tiq plot x1
    .
    title ^n Half-Cauchy Random Numbers
    half-cauchy tiq plot x2
    .
    title ^n Hyperbolic Secant Random Numbers
    hyperbolic secant tiq plot x3
    .
    end of multiplot

-----TSOCDF (LET)--------------------------------
 
TSOCDF
 
Name:
    TSOCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the two-sided ogive cumulative distribution function
    with shape parameters n and theta.
 
Description:
    The two-sided ogive cumulative distribution function can be
    computed using the following relation to the ogive cumulative
    distribution function:

       F(x;n,theta) = theta*G(x/theta;n)                  0 < x < theta
                    = 1 - (1-theta)*G((1-x)/(1-theta);n)  theta <= x < 1

    with F and G denoting the cumulative distribution functions of
    the two-sided ogive and the ogive distributions, respectively.
    This relation is given on page 230 of Kotz and Van Dorp (see 
    Reference section below).

    Enter HELP OGICDF for the formula for the Ogive cumulative
    distribution function.

    This distribution can be extended with lower and upper
    bound parameters.  If a and b denote the lower and upper
    bounds, respectively, then the location and scale 
    parameters are:

        location = a
        scale    = b - a

    The general form of the distribution can then be found
    by using the relation

        F(x;n,theta,a,b) = F((x-a)/(b-a);n,theta,0,1)

    Kotz and Van Dorp note that the two-sided ogive distribution
    is smooth at the reflection point (x = theta).  This is in
    contrast to the two-sided slope and two-sided power distributions,
    which are not smooth at the relection point.

Syntax:
    LET <y> = TSOCDF(<x>,<n>,<theta>,<a>,<b>) 
                           <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable containing
               values in the interval (a,b);
          <y> is a variable or a parameter (depending on what
               <x> is) where the computed two-sided ogive cdf
               value is stored;
          <n> is a number, parameter, or variable in the
               interval (0,2) that specifies the first shape
               parameter;
          <theta> is a number, parameter, or variable in the
               interval (a,b) that specifies the second shape
               parameter;
          <a> is a number, parameter, or variable that
               specifies the lower bound;
          <b> is a number, parameter, or variable that
               specifies the upper bound;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <a> and <b> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = TSOCDF(0.3,1.2,0.3)
    LET Y = TSOCDF(X,1.5,2.2,0,5)
    PLOT TSOCDF(X,1.5,2.2,0,5) FOR X = 0  0.01  5

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TSOPDF = Compute the two-sided ogive probability density function.
    TSOPPF = Compute the two-sided ogive percent point function.
    OGIPDF = Compute the ogive probability density function.
    TSSPDF = Compute the two-sided slope probability density function.
    TSPPDF = Compute the two-sided power probability density function.
    POWPDF = Compute the power probability density function.
    SLOPDF = Compute the slope probability density function.
    BETPDF = Compute the Beta probability density function.
    JSBPDF = Compute the Johnson SB probability density function.
 
Reference:
    Samuel Kotz and J. Rene Van Dorp 2004, "Beyond Beta:
    Other Continuous Families of Distributions with Bounded
    Support and Applications", World Scientific, chapter 8.
 
Applications:
    Distributional modeling
 
Implementation Date:
    2007/10
 
Program:
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 3
    TITLE OFFSET 2
    TITLE CASE ASIS
    LABEL CASE ASIS
    CASE ASIS
    .
    LET THETAV = DATA 0.25  0.50 0.75
    LET NV = DATA 0.5  1.5  2.5
    .
    LOOP FOR K = 1 1 3
       LET THETA = THETAV(K)
       LOOP FOR L = 1 1 3
          LET N = NV(L)
          TITLE Theta = ^THETA, N = ^N
          PLOT TSOCDF(X,N,THETA) FOR X = 0  0.01  0.99
       END OF LOOP
    END OF LOOP
    .
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT Two-Sided Ogive Cumulative Distribution Functions

-----TSOPDF (LET)--------------------------------
 
TSOPDF
 
Name:
    TSOPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the two-sided ogive probability density function
    with shape parameters n and theta.
 
Description:
    The standard two-sided ogive distribution has the
    following probability density function:

        f(x;n,theta) = n*(x/theta)**(n-1)*{(4*n-2)/(3*n-1) -
                       ((2*n-2)/(3*n-1))*(x/theta)**n}
                       0 <= x <= theta, n >= 0.5

                       n*((1-x)/(1-theta))**(n-1)*
                       {(4*n-2)/(3*n-1) -
                       ((2*n-2)/(3*n-1))*((1-x)/(1-theta))**n}
                       theta <= x <= 1, n >= 0.5

    The <i>n</i> denoting the shape parameter and theta denoting
    the reflection parameter.

    This distribution can be extended with lower and upper
    bound parameters.  If a and b denote the lower and upper
    bounds, respectively, then the location and scale 
    parameters are:

        location = a
        scale    = b - a

    The general form of the distribution can then be found
    by using the relation

        f(x;n,theta,a,b) = f((x-a)/(b-a);n,theta,0,1)/(b-a)

    Kotz and Van Dorp note that the two-sided Ogive distribution
    is smooth at the reflection point (x = theta).  This is in
    contrast to the two-sided slope and two-sided power distributions,
    which are not smooth at the relection point.

Syntax:
    LET <y> = TSOPDF(<x>,<n>,<theta>,<a>,<b>) 
                           <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable containing
               values in the interval (a,b);
          <y> is a variable or a parameter (depending on what
               <x> is) where the computed two-sided ogive pdf
               value is stored;
          <n> is a number, parameter, or variable in the
               interval (0,2) that specifies the first shape
               parameter;
          <theta> is a number, parameter, or variable in the
               interval (a,b) that specifies the second shape
               parameter;
          <a> is a number, parameter, or variable that
               specifies the lower bound;
          <b> is a number, parameter, or variable that
               specifies the upper bound;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <a> and <b> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = TSOPDF(0.3,1.2,0.3)
    LET Y = TSOPDF(X,1.5,2.2,0,5)
    PLOT TSOPDF(X,1.5,2.2,0,5) FOR X = 0  0.01  5
 
Note:
    Two-sided slope random numbers, probability plots, and
    goodness of fit tests can be generated with the commands:

       LET THETA = <value>
       LET N = <value>
       LET A = <value>
       LET B = <value>
       LET Y = TWO-SIDED SLOPE RANDOM NUMBERS FOR I = 1 1 N
       TWO-SIDED SLOPE PROBABILITY PLOT Y
       TWO-SIDED SLOPE PROBABILITY PLOT Y2 X2
       TWO-SIDED SLOPE PROBABILITY PLOT Y3 XLOW XHIGH
       TWO-SIDED SLOPE KOLMOGOROV SMIRNOV GOODNESS OF FIT Y
       TWO-SIDED SLOPE CHI-SQUARE GOODNESS OF FIT Y2 X2
       TWO-SIDED SLOPE CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    Note that

       A <= data minimum < THETA < data maximum <= B

    The following commands can be used to estimate the n and theta
    shape parameters for the two-sided ogive distribution:

       LET A = <value>
       LET B = <value>
       LET THETA1 = <value>
       LET THETA2 = <value>
       LET N1 = <value>
       LET N2 = <value>
       TWO-SIDED SLOPE PPCC PLOT Y
       TWO-SIDED SLOPE PPCC PLOT Y2 X2
       TWO-SIDED SLOPE PPCC PLOT Y3 XLOW XHIGH
       TWO-SIDED SLOPE KS PLOT Y
       TWO-SIDED SLOPE KS PLOT Y2 X2
       TWO-SIDED SLOPE KS PLOT Y3 XLOW XHIGH

    Note that for the two-sided ogive distribution, the
    shape parameter theta is bounded by the minimum and
    maximum of the data.  In the above commands, there
    are two approaches to dealing with this.

       1) Specify the values for A and B (i.e., the
          LET A = <value> and LET B = <value> commands).

          The advantage of this approach is that theta is
          estimated in units of the data.  The disadvantage
          is that we lose the invariance of location and
          scale for the PPCC plot (i.e., we cannot obtain
          estimates of A and B).

       2) Use A = 0 and B = 1 (i.e., the standard form of
          the distribution).  This restricts the value of
          theta to the (0,1) interval.

          The advantage of this approach is that we maintain 
          the invariance of location and scale for the
          PPCC plot and can obtain indpendent estimates for
          A and B.  

          The disadvantage of this approach is that we
          have to scale the estimate of theta if the data
          are outside of the (0,1) interval.

          To scale the estimate of theta in this method,
          do something like the following:

              DELETE A B
              LET YMIN = MINIMUM Y
              LET YMAX = MAXIMUM Y
              TWO-SIDED OGIVE PPCC PLOT Y
              LET N = SHAPE1
              LET THETA = SHAPE2
              TWO SIDED OGIVE PROBABILITY PLOT Y
              LET A = PPA0
              LET B = A + PPA1
              LET A = MIN(A,YMIM)
              LET B = MAX(B,YMAX)
              LET THETA = A + (B-A)*THETA

          We include a check to make sure that the estimated
          values for A and B are permissable (i.e., A <= YMIN
          and B >= YMAX).

    The default values for N1 and N2 are 0.05 and 2.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TSOCDF = Compute the two-sided ogive cumulative distribution
             function.
    TSOPPF = Compute the two-sided ogive percent point function.
    OGIPDF = Compute the ogive probability density function.
    TSSPDF = Compute the two-sided slope probability density function.
    TSPPDF = Compute the two-sided power probability density function.
    POWPDF = Compute the power probability density function.
    SLOPDF = Compute the slope probability density function.
    BETPDF = Compute the Beta probability density function.
    JSBPDF = Compute the Johnson SB probability density function.
 
Reference:
    Samuel Kotz and J. Rene Van Dorp 2004, "Beyond Beta:
    Other Continuous Families of Distributions with Bounded
    Support and Applications", World Scientific, chapter 8.
 
Applications:
    Distributional modeling
 
Implementation Date:
    2007/10
 
Program 1:
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 3
    TITLE OFFSET 2
    TITLE CASE ASIS
    LABEL CASE ASIS
    CASE ASIS
    .
    LET THETAV = DATA 0.25  0.50 0.75
    LET NV = DATA 0.5  1.5  2.5
    .
    LOOP FOR K = 1 1 3
       LET THETA = THETAV(K)
       LOOP FOR L = 1 1 3
          LET N = NV(L)
          TITLE Theta = ^THETA, N = ^N
          PLOT TSOPDF(X,N,THETA) FOR X = 0  0.01  0.99
       END OF LOOP
    END OF LOOP
    .
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT Two-Sided Ogive Probability Density Functions
 
Program 2:
    let n = 2.3
    let theta = 2.5
    let a = 0
    let b = 5
    let nsv = n
    let thetasv = theta
    .
    let y = two-sided ogive rand numb for i = 1 1 200
    let ymin = minimum y
    let ymax = maximum y
    .
    let theta1 = 1.5
    let theta2 = 4
    let n1 = 1.1
    let n2 = 5
    two-sided ogive ppcc plot y
    let n = shape1
    let theta = shape2
    justification center
    move 50 6
    text Thetahat = ^theta, ^Nhat = ^n
    move 50 3
    text Theta = ^thetasv, N = ^Nsv
    .
    character x
    line bl
    two-sided ogive probability plot y
    let a = ppa0
    let b = ppa0 + ppa1
    let a = min(a,ymin)
    let b = max(b,ymax)
    move 50 6
    text Lower Limit = ^a, Upper Limit = ^b
    move 50 3
    text PPCC = ^ppcc
    char bl
    line so
    .
    let ksloc = ppa0
    let ksscale = (b-a)
    two-sided ogive kolm smir goodness of fit y
    .
    relative hist y
    line color blue
    limits freeze
    pre-erase off
    plot tsopdf(x,n,theta,a,b) for x = a 0.01 b
    limits
    pre-erase on
    line color black all

-----TSOCDF (LET)--------------------------------
 
TSOCDF
 
Name:
    TSOCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the two-sided ogive cumulative distribution function
    with shape parameters n and theta.
 
Description:
    The two-sided ogive cumulative distribution function can be
    computed using the following relation to the ogive cumulative
    distribution function:

       F(x;n,theta) = theta*G(x/theta;n)                  0 < x < theta
                    = 1 - (1-theta)*G((1-x)/(1-theta);n)  theta <= x < 1

    with F and G denoting the cumulative distribution functions of
    the two-sided ogive and the ogive distributions, respectively.
    This relation is given on page 230 of Kotz and Van Dorp (see 
    Reference section below).

    Enter HELP OGICDF for the formula for the Ogive cumulative
    distribution function.

    This distribution can be extended with lower and upper
    bound parameters.  If a and b denote the lower and upper
    bounds, respectively, then the location and scale 
    parameters are:

        location = a
        scale    = b - a

    The general form of the distribution can then be found
    by using the relation

        F(x;n,theta,a,b) = F((x-a)/(b-a);n,theta,0,1)

    Kotz and Van Dorp note that the two-sided ogive distribution
    is smooth at the reflection point (x = theta).  This is in
    contrast to the two-sided slope and two-sided power distributions,
    which are not smooth at the relection point.

Syntax:
    LET <y> = TSOCDF(<x>,<n>,<theta>,<a>,<b>) 
                           <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable containing
               values in the interval (a,b);
          <y> is a variable or a parameter (depending on what
               <x> is) where the computed two-sided ogive cdf
               value is stored;
          <n> is a number, parameter, or variable in the
               interval (0,2) that specifies the first shape
               parameter;
          <theta> is a number, parameter, or variable in the
               interval (a,b) that specifies the second shape
               parameter;
          <a> is a number, parameter, or variable that
               specifies the lower bound;
          <b> is a number, parameter, or variable that
               specifies the upper bound;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <a> and <b> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = TSOCDF(0.3,1.2,0.3)
    LET Y = TSOCDF(X,1.5,2.2,0,5)
    PLOT TSOCDF(X,1.5,2.2,0,5) FOR X = 0  0.01  5

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TSOPDF = Compute the two-sided ogive probability density function.
    TSOPPF = Compute the two-sided ogive percent point function.
    OGIPDF = Compute the ogive probability density function.
    TSSPDF = Compute the two-sided slope probability density function.
    TSPPDF = Compute the two-sided power probability density function.
    POWPDF = Compute the power probability density function.
    SLOPDF = Compute the slope probability density function.
    BETPDF = Compute the Beta probability density function.
    JSBPDF = Compute the Johnson SB probability density function.
 
Reference:
    Samuel Kotz and J. Rene Van Dorp 2004, "Beyond Beta:
    Other Continuous Families of Distributions with Bounded
    Support and Applications", World Scientific, chapter 8.
 
Applications:
    Distributional modeling
 
Implementation Date:
    2007/10
 
Program:
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 3
    TITLE OFFSET 2
    TITLE CASE ASIS
    LABEL CASE ASIS
    CASE ASIS
    .
    LET THETAV = DATA 0.25  0.50 0.75
    LET NV = DATA 0.5  1.5  2.5
    .
    LOOP FOR K = 1 1 3
       LET THETA = THETAV(K)
       LOOP FOR L = 1 1 3
          LET N = NV(L)
          TITLE Theta = ^THETA, N = ^N
          PLOT TSOCDF(X,N,THETA) FOR X = 0  0.01  0.99
       END OF LOOP
    END OF LOOP
    .
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT Two-Sided Ogive Cumulative Distribution Functions

-----TSPCDF (LET)--------------------------------
 
TSPCDF
 
Name:
    TSPCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the two-sided power cumulative distribution function
    with shape parameters THETA and N.
 
Description:
    The two-sided power distribution has the following
    cumulative distribution function:
       F((X,THETA,N) = THETA*(X/THETA)**N          0 <= X <= THETA
                     = 1 - (1-THETA)*((1-X)/(1-THETA))**N
                     0 <= THETA <= 1, N > 0
 
Syntax:
    LET <y2> = TSPCDF(<y1>,<theta>,<n>) 
                           <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a number, parameter, or variable containing
               values in the interval (0, 1);
          <y2> is a variable or a parameter (depending on what
               <y1> is) where the computed two-sided power cdf
               value is stored;
          <theta> is a number, parameter, or variable in the
               interval (0, 1) that specifies the first shape
               parameter;
          <n> is a positive number, parameter, or variable that
               specifies the second shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TSPCDF(0.3,0.2,1.2)
    LET A = TSPCDF(A1,0.5,2)
    LET X2 = TSPCDF(X1,0.8,0.5)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TSPPDF = Compute the two-sided power probability density
             function.
    TSPPPF = Compute the two-sided power percent point function.
    POWPDF = Compute the power probability density function.
    BETPDF = Compute the Beta probability density function.
    JSBPDF = Compute the Johnson SB probability density function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "The Standard Two-Sided Power Distribution and its
    Properties with Applications in Financial Engineering",
    J. Rene Van Dorp and Samuel Kotz, American Statistician,
    Volume 56, Number 2, May, 2002.
 
Applications:
    Distributional modeling
 
Implementation Date:
    2002/5
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LET THETA = 0.5
    LET N = 4
    X1LABEL THETA = ^THETA, N = ^N
    PLOT TSPCDF(X,THETA,N) FOR X = 0.01 0.01 0.99
    LET THETA = 0.25
    LET N = 2
    X1LABEL THETA = ^THETA, N = ^N
    PLOT TSPCDF(X,THETA,N) FOR X = 0.01 0.01 0.99
    LET THETA = 0.75
    LET N = 1.5
    X1LABEL THETA = ^THETA, N = ^N
    PLOT TSPCDF(X,THETA,N) FOR X = 0.01 0.01 0.99
    LET THETA = 0.75
    LET N = 0.5
    X1LABEL THETA = ^THETA, N = ^N
    PLOT TSPCDF(X,THETA,N) FOR X = 0.01 0.01 0.99
    END OF MULTIPLOT
 
-----TSPPDF (LET)--------------------------------
 
TSPPDF
 
Name:
    TSPPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the two-sided power probability density function
    with shape parameters THETA and N.
 
Description:
    The two-sided power distribution has the following
    probability density function:
       f((X,THETA,N) = N*(X/THETA)**(N-1)          0 < X <= THETA
                     = N*((1-X)/(1-THETA))**(N-1)  THETA <= X < 1
                     0 <= THETA <= 1, N > 0
 
Syntax:
    LET <y2> = TSPPDF(<y1>,<theta>,<n>) 
                           <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a number, parameter, or variable containing
               values in the interval (0, 1);
          <y2> is a variable or a parameter (depending on what
               <y1> is) where the computed two-sided power pdf
               value is stored;
          <theta> is a number, parameter, or variable in the
               interval (0, 1) that specifies the first shape
               parameter;
          <n> is a positive number, parameter, or variable that
               specifies the second shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TSPPDF(0.3,0.2,1.2)
    LET A = TSPPDF(A1,0.5,2)
    LET X2 = TSPPDF(X1,0.8,0.5)
 
Note:
    Two-sided power random numbers, probability plots, and
    goodness of fit tests can be generated with the commands:

       LET THETA = <value>
       LET N = <value>
       LET A = <value>
       LET B = <value>
       LET Y = TWO-SIDED POWER RANDOM NUMBERS FOR I = 1 1 N
       TWO-SIDED POWER PROBABILITY PLOT Y
       TWO-SIDED POWER PROBABILITY PLOT Y2 X2
       TWO-SIDED POWER PROBABILITY PLOT Y3 XLOW XHIGH
       TWO-SIDED POWER KOLMOGOROV SMIRNOV GOODNESS OF FIT Y
       TWO-SIDED POWER CHI-SQUARE GOODNESS OF FIT Y2 X2
       TWO-SIDED POWER CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    Note that

       A <= data minimum < THETA < data maximum <= B

    The following commands can be used to estimate the theta
    and n shape parameters for the two-sided power distribution:

       LET A = <value>
       LET B = <value>
       LET THETA1 = <value>
       LET THETA2 = <value>
       LET N1 = <value>
       LET N2 = <value>
       TWO-SIDED POWER PPCC PLOT Y
       TWO-SIDED POWER PPCC PLOT Y2 X2
       TWO-SIDED POWER PPCC PLOT Y3 XLOW XHIGH
       TWO-SIDED POWER KS PLOT Y
       TWO-SIDED POWER KS PLOT Y2 X2
       TWO-SIDED POWER KS PLOT Y3 XLOW XHIGH

    Note that for the two-sided power distribution, the
    shape parameter theta is bounded by the minimum and
    maximum of the data.  In the above commands, there
    are two approaches to dealing with this.

       1) Specify the values for A and B (i.e., the
          LET A = <value> and LET B = <value> commands).

          The advantage of this approach is that theta is
          estimated in units of the data.  The disadvantage
          is that we lose the invariance of location and
          scale for the PPCC plot (i.e., we cannot obtain
          estimates of A and B).

       2) Use A = 0 and B = 1 (i.e., the standard form of
          the distribution).  This restricts the value of
          theta to the (0,1) interval.

          The advantage of this approach is that we maintain 
          the invariance of location and scale for the
          PPCC plot and can obtain indpendent estimates for
          A and B.  

          The disadvantage of this approach is that we
          have to scale the estimate of theta if the data
          are outside of the (0,1) interval.

          To scale the estimate of theta in this method,
          do something like the following:

              DELETE A B
              LET YMIN = MINIMUM Y
              LET YMAX = MAXIMUM Y
              TWO-SIDED POWER PPCC PLOT Y
              LET THETA = SHAPE1
              LET N = SHAPE2
              TWO SIDED PROBABILITY PLOT Y
              LET A = PPA0
              LET B = A + PPA1
              LET A = MIN(A,YMIM)
              LET B = MAX(B,YMAX)
              LET THETA = A + (B-a)*THETA

          We include a check to make sure that the estimated
          values for A and B are permissable (i.e., A <= YMIN
          and B >= YMAX).

    The default values for N1 and N2 are 0.1 and 10.

    Kotz and Van Dorp describe a maximum likelihood method for
    estimating the parameters for this distribution.  The
    method is rather involved and not given here (see
    chapter 4 of their book).

    Note that the ML method is only reliable for the case
    where N > 1.  To determine if N > 1, generate a
    relative histogram of the data.  If there is a mode
    (i.e.,  /\ ), then the ML should be reliable.  However,
    if there is an anit-mode (i.e., \/ ), then this
    indicates that N < 1 and the ML method should not be
    used.

    To generate the maximum likelihood estimates, enter
    the command

        TWO-SIDED POWER MAXIMUM LIKELIHOOD Y

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TSPCDF = Compute the two-sided power cumulative distribution
             function.
    TSPPPF = Compute the two-sided power percent point function.
    POWPDF = Compute the power probability density function.
    BETPDF = Compute the Beta probability density function.
    JSBPDF = Compute the Johnson SB probability density function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "The Standard Two-Sided Power Distribution and its
    Properties with Applications in Financial Engineering",
    J. Rene Van Dorp and Samuel Kotz, American Statistician,
    Volume 56, Number 2, May, 2002.
 
Applications:
    Distributional modeling
 
Implementation Date:
    2002/5
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LET THETA = 0.5
    LET N = 4
    X1LABEL THETA = ^THETA, N = ^N
    PLOT TSPPDF(X,THETA,N) FOR X = 0.01 0.01 0.99
    LET THETA = 0.25
    LET N = 2
    X1LABEL THETA = ^THETA, N = ^N
    PLOT TSPPDF(X,THETA,N) FOR X = 0.01 0.01 0.99
    LET THETA = 0.75
    LET N = 1.5
    X1LABEL THETA = ^THETA, N = ^N
    PLOT TSPPDF(X,THETA,N) FOR X = 0.01 0.01 0.99
    LET THETA = 0.75
    LET N = 0.5
    X1LABEL THETA = ^THETA, N = ^N
    PLOT TSPPDF(X,THETA,N) FOR X = 0.01 0.01 0.99
    END OF MULTIPLOT
 
-----TSPPPF (LET)--------------------------------
 
TSPPPF
 
Name:
    TSPPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the two-sided power percent point function
    with shape parameters THETA and N.
 
Description:
    The two-sided power distribution has the following
    percent point function:
       G(P,THETA,N) = THETA*(P/THETA)**(1/N)      0 < P <= THETA
                    = 1 - (1-THETA)*((1-P)/(1-THETA))**(1/N)
                                                  THETA < P <= 1
                     0 <= THETA <= 1, N > 0
 
Syntax:
    LET <y2> = TSPPPF(<p>,<theta>,<n>) 
                           <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or variable containing
               values in the interval (0, 1);
          <y2> is a variable or a parameter (depending on what
               <y1> is) where the computed two-sided power ppf
               value is stored;
          <theta> is a number, parameter, or variable in the
               interval (0, 1) that specifies the first shape
               parameter;
          <n> is a positive number, parameter, or variable that
               specifies the second shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = TSPPPF(0.05,0.2,1.2)
    LET A = TSPPPF(A1,0.5,2)
    LET X2 = TSPPPF(P1,0.8,0.5)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TSPCDF = Compute the two-sided power cumulative distribution
             function.
    TSPPDF = Compute the two-sided power probability density
             function.
    POWPDF = Compute the power probability density function.
    BETPDF = Compute the Beta probability density function.
    JSBPDF = Compute the Johnson SB probability density function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "The Standard Two-Sided Power Distribution and its
    Properties with Applications in Financial Engineering",
    J. Rene Van Dorp and Samuel Kotz, American Statistician,
    Volume 56, Number 2, May, 2002.
 
Applications:
    Distributional modeling
 
Implementation Date:
    2002/5
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LET THETA = 0.5
    LET N = 4
    X1LABEL THETA = ^THETA, N = ^N
    PLOT TSPPPF(P,THETA,N) FOR P = 0 0.01 1
    LET THETA = 0.25
    LET N = 2
    X1LABEL THETA = ^THETA, N = ^N
    PLOT TSPPPF(P,THETA,N) FOR P = 0 0.01 1
    LET THETA = 0.75
    LET N = 1.5
    X1LABEL THETA = ^THETA, N = ^N
    PLOT TSPPPF(P,THETA,N) FOR P = 0 0.01 1
    LET THETA = 0.75
    LET N = 0.5
    X1LABEL THETA = ^THETA, N = ^N
    PLOT TSPPPF(P,THETA,N) FOR P = 0 0.01 1
    END OF MULTIPLOT
 
-----TSSCDF (LET)--------------------------------
 
TSSCDF
 
Name:
    TSSCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the two-sided slope cumulative distribution
    function with shape parameters alpha and theta.
 
Description:
    The standard two-sided slope distribution has the
    following cumulative distribution function:

        F(x;alpha,theta,a,b) =
            alpha*((x-a)/(b-a)) +
            (1-alpha)*((b-a)/(theta-a))*((x-a)/(b-a))**2
            a <= x <= theta

            1 - alpha*((b-x)/(b-a)) -
            (1-alpha)*((b-a)/(b-theta))*((b-x)/(b-a))**2
            theta < x <= b

            0 <= alpha <= 2

    This distribution can be extended with lower and upper
    bound parameters.  If a and b denote the lower and upper
    bounds, respectively, then the location and scale 
    parameters are:

        location = a
        scale    = b - a

    The general form of the distribution can then be found
    by using the relation

        F(x;alpha,theta,a,b) = f((x-a)/(b-a);alpha,theta,0,1)
 
Syntax:
    LET <y> = TSSCDF(<x>,<alpha>,<theta>,<a>,<b>) 
                           <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable containing
               values in the interval (a,b);
          <y> is a variable or a parameter (depending on what
               <x> is) where the computed two-sided slope pdf
               value is stored;
          <alpha> is a number, parameter, or variable in the
               interval (0,2) that specifies the first shape
               parameter;
          <theta> is a number, parameter, or variable in the
               interval (a,b) that specifies the second shape
               parameter;
          <a> is a number, parameter, or variable that
               specifies the lower bound;
          <b> is a number, parameter, or variable that
               specifies the upper bound;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <a> and <b> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = TSSCDF(0.3,1.2,0.3)
    LET Y = TSSCDF(X,1.5,2.2,0,5)
    PLOT TSSCDF(X,1.5,2.2,0,5) FOR X = 0  0.01  5
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TSSPDF = Compute the two-sided slope probability density
             function.
    TSSPPF = Compute the two-sided slope percent point function.
    SLOPDF = Compute the slope probability density function.
    TSPPDF = Compute the two-sided power probability density
             function.
    TSOPDF = Compute the two-sided ogive probability density
             function.
    POWPDF = Compute the power probability density function.
    BETPDF = Compute the Beta probability density function.
    JSBPDF = Compute the Johnson SB probability density function.
 
Reference:
    Samuel Kotz and J. Rene Van Dorp 2004, "Beyond N:
    Other Continuous Families of Distributions with Bounded
    Support and Applications", World Scientific, chapter 8.
 
Applications:
    Distributional modeling
 
Implementation Date:
    2007/10
 
Program:
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 3
    TITLE OFFSET 2
    TITLE CASE ASIS
    LABEL CASE ASIS
    CASE ASIS
    .
    LET THETAV = DATA 0.25  0.50 0.75
    LET ALPHAV = DATA 0.5  1.0  1.5
    .
    LOOP FOR K = 1 1 3
       LET THETA = THETAV(K)
       LOOP FOR L = 1 1 3
          LET ALPHA = ALPHAV(L)
          TITLE Theta = ^THETA, Alpha = ^ALPHA
          PLOT TSSCDF(X,ALPHA,THETA) FOR X = 0  0.01  1
       END OF LOOP
    END OF LOOP
    .
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT Two-Sided Slope Cumulative Distribution Functions
 
-----TSSPDF (LET)--------------------------------
 
TSSPDF
 
Name:
    TSSPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the two-sided slope probability density function
    with shape parameters alpha and theta.
 
Description:
    The standard two-sided slope distribution has the
    following probability density function:

        f(x;alpha,theta,a,b) =
            alpha/(b-a) + 2*(1-alpha)*(x-a)/{(b-a)*(theta-a)}
            a <= x <= theta, 0 <= alpha <= 2

        f(x;alpha,theta,a,b) =
            alpha/(b-a) + 2*(1-alpha)*(b-x)/{(b-a)*(b-theta)}
            theta < x <= b, 0 <= alpha <= 2

    This distribution can be extended with lower and upper
    bound parameters.  If a and b denote the lower and upper
    bounds, respectively, then the location and scale 
    parameters are:

        location = a
        scale    = b - a

    The general form of the distribution can then be found
    by using the relation

        f(x;alpha,theta,a,b) = f((x-a)/(b-a);alpha,theta,0,1)/(b-a)
 
Syntax:
    LET <y> = TSSPDF(<x>,<alpha>,<theta>,<a>,<b>) 
                           <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable containing
               values in the interval (a,b);
          <y> is a variable or a parameter (depending on what
               <x> is) where the computed two-sided slope pdf
               value is stored;
          <alpha> is a number, parameter, or variable in the
               interval (0,2) that specifies the first shape
               parameter;
          <theta> is a number, parameter, or variable in the
               interval (a,b) that specifies the second shape
               parameter;
          <a> is a number, parameter, or variable that
               specifies the lower bound;
          <b> is a number, parameter, or variable that
               specifies the upper bound;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <a> and <b> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = TSSPDF(0.3,1.2,0.3)
    LET Y = TSSPDF(X,1.5,2.2,0,5)
    PLOT TSSPDF(X,1.5,2.2,0,5) FOR X = 0  0.01  5
 
Note:
    Two-sided slope random numbers, probability plots, and
    goodness of fit tests can be generated with the commands:

       LET THETA = <value>
       LET ALPHA = <value>
       LET A = <value>
       LET B = <value>
       LET Y = TWO-SIDED SLOPE RANDOM NUMBERS FOR I = 1 1 N
       TWO-SIDED SLOPE PROBABILITY PLOT Y
       TWO-SIDED SLOPE PROBABILITY PLOT Y2 X2
       TWO-SIDED SLOPE PROBABILITY PLOT Y3 XLOW XHIGH
       TWO-SIDED SLOPE KOLMOGOROV SMIRNOV GOODNESS OF FIT Y
       TWO-SIDED SLOPE CHI-SQUARE GOODNESS OF FIT Y2 X2
       TWO-SIDED SLOPE CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    Note that

       A <= data minimum < THETA < data maximum <= B

    The following commands can be used to estimate the theta
    and alpha shape parameters for the two-sided slope
    distribution:

       LET A = <value>
       LET B = <value>
       LET THETA1 = <value>
       LET THETA2 = <value>
       LET ALPHA1 = <value>
       LET ALPHA2 = <value>
       TWO-SIDED SLOPE PPCC PLOT Y
       TWO-SIDED SLOPE PPCC PLOT Y2 X2
       TWO-SIDED SLOPE PPCC PLOT Y3 XLOW XHIGH
       TWO-SIDED SLOPE KS PLOT Y
       TWO-SIDED SLOPE KS PLOT Y2 X2
       TWO-SIDED SLOPE KS PLOT Y3 XLOW XHIGH

    Note that for the two-sided slope distribution, the
    shape parameter theta is bounded by the minimum and
    maximum of the data.  In the above commands, there
    are two approaches to dealing with this.

       1) Specify the values for A and B (i.e., the
          LET A = <value> and LET B = <value> commands).

          The advantage of this approach is that theta is
          estimated in units of the data.  The disadvantage
          is that we lose the invariance of location and
          scale for the PPCC plot (i.e., we cannot obtain
          estimates of A and B).

       2) Use A = 0 and B = 1 (i.e., the standard form of
          the distribution).  This restricts the value of
          theta to the (0,1) interval.

          The advantage of this approach is that we maintain 
          the invariance of location and scale for the
          PPCC plot and can obtain indpendent estimates for
          A and B.  

          The disadvantage of this approach is that we
          have to scale the estimate of theta if the data
          are outside of the (0,1) interval.

          To scale the estimate of theta in this method,
          do something like the following:

              DELETE A B
              LET YMIN = MINIMUM Y
              LET YMAX = MAXIMUM Y
              TWO-SIDED SLOPE PPCC PLOT Y
              LET ALPHA = SHAPE1
              LET THETA = SHAPE2
              TWO SIDED SLOPE PROBABILITY PLOT Y
              LET A = PPA0
              LET B = A + PPA1
              LET A = MIN(A,YMIM)
              LET B = MAX(B,YMAX)
              LET THETA = A + (B-A)*THETA

          We include a check to make sure that the estimated
          values for A and B are permissable (i.e., A <= YMIN
          and B >= YMAX).

    The default values for ALPHA1 and ALPHA2 are 0.05 and 2.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TSSCDF = Compute the two-sided slope cumulative distribution
             function.
    TSSPPF = Compute the two-sided slope percent point function.
    SLOPDF = Compute the slope probability density function.
    TSPPDF = Compute the two-sided power probability density
             function.
    TSOPDF = Compute the two-sided ogive probability density
             function.
    POWPDF = Compute the power probability density function.
    BETPDF = Compute the Beta probability density function.
    JSBPDF = Compute the Johnson SB probability density function.
 
Reference:
    Samuel Kotz and J. Rene Van Dorp 2004, "Beyond N:
    Other Continuous Families of Distributions with Bounded
    Support and Applications", World Scientific, chapter 8.
 
Applications:
    Distributional modeling
 
Implementation Date:
    2007/10
 
Program 1:
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 3
    TITLE OFFSET 2
    TITLE CASE ASIS
    LABEL CASE ASIS
    CASE ASIS
    .
    LET THETAV = DATA 0.25  0.50 0.75
    LET ALPHAV = DATA 0.5  1.0  1.5
    .
    LOOP FOR K = 1 1 3
       LET THETA = THETAV(K)
       LOOP FOR L = 1 1 3
          LET ALPHA = ALPHAV(L)
          TITLE Theta = ^THETA, Alpha = ^ALPHA
          PLOT TSSPDF(X,ALPHA,THETA) FOR X = 0  0.01  1
       END OF LOOP
    END OF LOOP
    .
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT Two-Sided Slope Probability Density Functions
 
Program 2:
    let a = 0
    let b = 4
    let alpha = 1.3
    let theta = 1.7
    let alphasv = alpha
    let thetasv = theta
    .
    let y = two-sided slope random numbers for i = 1 1 200
    let ymin = minimum y
    let ymax = maximum y
    .
    two-sided slope ppcc plot y
    let alpha = shape1
    let theta = shape2
    justification center
    move 50 6
    text Alphahat = ^alpha, Thetahat = ^theta
    move 50 3
    text Alpha = ^alphasv, Theta = ^thetasv
    .
    char x
    line bl
    two-sided slope prob plot y
    move 50 6
    let ahat = ppa0
    let bhat = ppa0 + ppa1
    let ahat = min(ahat,ymin)
    let bhat = max(bhat,ymax)
    text Lower Limit = ^ppa0, Upper Limit = ^bhat
    move 50 3
    text PPCC = ^ppcc
    .
    two sided slope kolm smir goodness of fit y

-----TSSPPF (LET)--------------------------------
 
TSSPPF
 
Name:
    TSSPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the two-sided slope percent point function
    with shape parameters alpha and theta.
 
Description:
    The percent point function for the standard two-sided slope
    distribution can be found by solving the following
    quadratic equation:

       {-alpha +/- SQRT(alpha**2 + 4*p*(1-alpha)/theta)}/
       {2*(1-alpha)/theta}
       0 <= p <= theta

       {2*c1+alpha) +/- 
       SQRT((-2*c1-alpha)**2 - 4*c1*(c1+alpha+p-1))}/{2*c1}
       theta < p <= 1

    where

       c1=(1-alpha)/(1-theta)

    The above equations have two possible roots.  The
    root that lies in the (0,1) interval is the one that
    is kept.

    This distribution can be extended with lower and upper
    bound parameters.  If a and b denote the lower and upper
    bounds, respectively, then the location and scale 
    parameters are:

        location = a
        scale    = b - a

    The general form of the distribution can then be found
    by using the relation

        G(p;alpha,theta,a,b) = a + (b-a)*G(p;alpha,theta,0,1)
 
Syntax:
    LET <y> = TSSPPF(<p>,<alpha>,<theta>,<a>,<b>) 
                           <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or variable containing
               values in the interval (0,1);
          <y> is a variable or a parameter (depending on what
               <p> is) where the computed two-sided slope ppf
               value is stored;
          <alpha> is a number, parameter, or variable in the
               interval (0,2) that specifies the first shape
               parameter;
          <theta> is a number, parameter, or variable in the
               interval (a,b) that specifies the second shape
               parameter;
          <a> is a number, parameter, or variable that
               specifies the lower bound;
          <b> is a number, parameter, or variable that
               specifies the upper bound;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <a> and <b> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = TSSPPF(0.95,1.2,0.3)
    LET Y = TSSPPF(P,1.5,2.2,0,5)
    PLOT TSSPPF(X,1.5,2.2,0,5) FOR P = 0  0.01  1
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TSSCDF = Compute the two-sided slope cumulative distribution
             function.
    TSSPDF = Compute the two-sided slope probability density
             function.
    SLOPDF = Compute the slope probability density function.
    TSPPDF = Compute the two-sided power probability density
             function.
    TSOPDF = Compute the two-sided ogive probability density
             function.
    POWPDF = Compute the power probability density function.
    BETPDF = Compute the Beta probability density function.
    JSBPDF = Compute the Johnson SB probability density function.
 
Reference:
    Samuel Kotz and J. Rene Van Dorp 2004, "Beyond N:
    Other Continuous Families of Distributions with Bounded
    Support and Applications", World Scientific, chapter 8.
 
Applications:
    Distributional modeling
 
Implementation Date:
    2007/10
 
Program:
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 3
    TITLE OFFSET 2
    TITLE CASE ASIS
    LABEL CASE ASIS
    CASE ASIS
    .
    LET THETAV = DATA 0.25  0.50 0.75
    LET ALPHAV = DATA 0.5  1.0  1.5
    .
    LOOP FOR K = 1 1 3
       LET THETA = THETAV(K)
       LOOP FOR L = 1 1 3
          LET ALPHA = ALPHAV(L)
          TITLE Theta = ^THETA, Alpha = ^ALPHA
          PLOT TSSPPF(P,ALPHA,THETA) FOR P = 0  0.01  1
       END OF LOOP
    END OF LOOP
    .
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT Two-Sided Slope Percent Point Functions
 
-----TOTAL TIME ON TEST PLOT--------------------------------------
 
TOTAL TIME ON TEST PLOT
 
Name:
    TOTAL TIME ON TEST PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a total time on test plot.
 
Description:
    For uncensored data, the total time on test statistic for uncensored
    data is (where X is ascending sorted order):

        TTT(i) = SUM[j=1 to i][(N-j+1)*(X(j) - X(j-1))]

    where X(0) is defined to be zero.

    The scaled total time to test is then defined as

        TTT*(i) = TTT(i)/TTT(n)

    The scaled total time on test lies between 0 and 1.

    For type I and type II censored data, the scaled total time on
    test is defined as

        TTT*(i) = TTT(i)/TTT(r)

    where r is the index of the maximum uncensored failure time.
    Progressive censoring is not currently supported.

    The TOTAL TIME ON TEST PLOT is then a plot of TTT*(i) against
    i/n (or i/r for censored data).  In addition, a reference line
    is plotted from (0,0) to (1,1).

    The primary purpose of this plot is to distinguish between a
    constant hazard function, an increasing hazard function or a
    decreasing hazard function.  If the plot shows the data being nearly
    concave and mostly above the 45 degree line, this indicates the data
    is from a distribution with an increasing hazard function.  If the
    plot shows the data being nearly convex and mostly below the 45
    degree line, this indicates the data is from a distribution with a
    decreasing hazard function.  If the plot shows the data randomly
    around the 45 degree line, this indicates the data is from a
    distribution with a constant hazard function (i.e., an exponential
    distribution).

Syntax 1:
    TOTAL TIME ON TEST PLOT <y>    <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable containing failure times;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for uncensored data.

Syntax 2:
    TOTAL TIME ON TEST PLOT <y> <tag>    <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable containing failure times;
          <tag> is a tag variable indicating whether the times
              in <y> are failure times or censoring times;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax is used for censored data.

Examples:
    TOTAL TIME ON TEST PLOT Y
    TOTAL TIME ON TEST PLOT Y CENSOR

Note:
    If any of the response values are negative, an error is returned.

Note:
    If the censoring variable is included, a value of 0 indicates a
    censored value and a value of 1 indicates an uncensored value.

    Dataplot will check the number of distinct values in the censoring
    variable.  If there is only one distinct value, then all observations
    are treated as uncensored.  If there are two distinct values, then
    the smaller value indicates censored data and the larger value
    indicates uncensored data.  If there are more than two distinct
    values, an error is returned.

Default:
    None
 
Synonyms:
    TTT PLOT is a synonym for TOTAL TIME ON TEST PLOT
 
Related Commands:
    LINES              = Sets the type for plot lines.
    CHARACTERS         = Sets the type for plot characters.
    KAPLAN MIER PLOT   = Generate a Kaplan Mier plot.
    DUANE PLOT         = Generate a Duane plot.
    EMPIRICAL CDF PLOT = Generates an empirical cdf plot.
    TAIL AREA PLOT     = Generates a tail area plot.
    ... HAZARD PLOT    = Generates a hazard plot.
    PROBABILITY PLOT   = Generates a probability plot.
    PLOT               = Generates a data or function plot.
 
References:
    Rinne (2010), "Location–Scale Distributions: Linear Estimation
    and Probability Plotting Using MATLAB,".

    Epstein and Sobel (1953), "Life Testing," Journal of the American
    Statistical Association, 48, 486–502.

    Barlow and Campo (1975), "Time on Test Processes and Applications to
    Failure data analysis," in Barlow, Fusssell and Singpurwalla (eds.)
    "Reliability and Fault Tree Analysis," SIAM, Philadelphia, 451–481.

Applications:
    Reliability
 
Implementation Date:
    2020/06
 
Program 1:
    SKIP 25
    READ HAHN.DAT MILES TAG
    LET CENSOR = TAG
    LET CENSOR = 0 SUBSET TAG = 2
    .
    TITLE CASE ASIS
    TITLE Total Time on Test Plot for HAHN.DAT
    LABEL CASE ASIS
    Y1LABEL TTT*(i)
    X1LABEL i/n
    .
    TOTAL TIME ON TEST PLOT MILES CENSOR
 
Program 2:
    . Step 1:   Define some data
    .
    let n = 100
    let gamma = 0.5
    let y1 = weibull rand numb for i = 1 1 n
    let gamma = 1.0
    let y2 = weibull rand numb for i = 1 1 n
    let gamma = 2.0
    let y3 = weibull rand numb for i = 1 1 n
    .
    . Step 2:   Plot the data
    .
    case asis
    title case asis
    label case asis
    title offset 2
    tic offset units screen
    tic mark offset 3 3
    .
    ylimits 0 1
    major y1tic mark number 6
    minor y1tic mark number 3
    y1label TTT(i)
    .
    xlimits 0 1
    major x1tic mark number 6
    minor x1tic mark number 3
    x1label i/n
    x2label Circle: Gamma = 0.5, Square: Gamma = 1.0, Triangle: Gamma = 2.0
    .
    title Scaled Total Time On Test Plot
    .
    character circle blank
    character fill on
    character hw 1.0 0.75
    line solid dotted
    .
    title Total Time on Test Plot for Weibull Distributions
    total time on test plot y1
    .
    pre-erase off
    frame off
    tic mark off
    tic mark labels off
    title
    label
    .
    character square
    total time on test plot y2
    .
    character triangle
    total time on test plot y3

-----TOTAL TIME ON TEST (LET)-------------------------------------
 
TOTAL TIME ON TEST
 
Name:
    TOTAL TIME ON TEST (LET)
    SCALED TOTAL TIME ON TEST (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the total time on test for a set of failure times.
 
Description:
    For uncensored data, the total time on test statistic for uncensored
    data is (where X is ascending sorted order):

        TTT(i) = SUM[j=1 to i][(N-j+1)*(X(j) - X(j-1))]

    where X(0) is defined to be zero.

    The scaled total time to test is then defined as

        TTT*(i) = TTT(i)/TTT(n)

    The scaled total time on test lies between 0 and 1.

    For type I and type II censored data, the scaled total time on
    test is defined as

        TTT*(i) = TTT(i)/TTT(r)

    where r is the index of the maximum uncensored failure time.
    Progressive censoring is not currently supported.

Syntax 1:
    LET <y> = TOTAL TIME ON TEST <x>  <tag>
                              <SUBSET/EXCEPT/FOR qualification>
    where <x> is the variable containing the failure times;
          <tag> is a variable that indicates whether the corresponding
              element of <x> is a failure time or a censoring
              time;
          <y> is a variable where the total time on test values are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax returns the unscaled values.

Syntax 2:
    LET <y> = SCALED TOTAL TIME ON TEST <x>  <tag>
                                        <SUBSET/EXCEPT/FOR qualification>
    where <x> is the variable containing the failure times;
          <tag> is a variable that indicates whether the corresponding
              element of <x> is a failure time or a censoring
              time;
          <y> is a variable where the total time on test values are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax returns the scaled values.

Examples:
    LET Y = TOTAL TIME ON TEST  X CENSOR
 
Note:
    If any of the response values are negative, an error is returned.

Note:
    For the censoring variable, a value of 0 indicates a censored value
    and a value of 1 indicates an uncensored value.

    Dataplot will check the number of distinct values in the censoring
    variable.  If there is only one distinct value, then all observations
    are treated as uncensored.  If there are two distinct values, then
    the smaller value indicates censored data and the larger value
    indicates uncensored data.  If there are more than two distinct
    values, an error is returned.

    For uncensored data, you can do something like the following

        LET N = SIZE X
        LET CENSOR = 1 FOR I = 1 1 N
        LET TTT = SCALED TOTAL TIME ON TEST X CENSOR

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    HAZARD                   = Compute the hazard for a variable.
    CUMULATIVE HAZARD        = Compute the cumulative hazard for a
                               variable.
    INTERARRIVAL TIME        = Compute the interarrival times of a
                               variable.
    TOTAL TIME ON TEST PLOT  = Generate a total time on test plot.
    HAZARD PLOT              = Generate a hazard plot.
    PROBABILITY PLOT         = Generate a probability plot.
    WEIBULL PLOT             = Generate a Weibull plot.
 
Applications:
    Reliability
 
Implementation Date:
    2020/06
 
Program 1:
    SKIP 25
    READ HAHN.DAT Y TAG
    LET TAG = 0 SUBSET TAG = 2
    LET Z = SCALED TOTAL TIME ON TEST Y TAG
 
Program 2:
    . Step 1:   Define some data
    .
    let n = 100
    let gamma = 0.5
    let y1 = weibull rand numb for i = 1 1 n
    let gamma = 1.0
    let y2 = weibull rand numb for i = 1 1 n
    let gamma = 2.0
    let y3 = weibull rand numb for i = 1 1 n
    let tag = 1 for i = 1 1 n
    .
    . Step 2:   Compute the total time to failure values
    .
    let z1 = scaled total time on test y1 tag
    let z2 = scaled total time on test y2 tag
    let z3 = scaled total time on test y3 tag
    .
    set write decimals 3
    print y1 y2 y3 z1 z2 z3

-----TUKEY MEAN DIFFFERENCE PLOT--------------------------------------
 
TUKEY MEAN-DIFFERENCE PLOT
 
Name:
    TUKEY MEAN-DIFFERENCE PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a Tukey mean-difference plot.
 
Description:
    The Tukey mean-difference plot is an adaption of the
    quantile-quantile plot.

    A quantile-quantile plot (or q-q plot) is a graphical data analysis
    technique for comparing the distributions of 2 data sets.  The
    quantile-quantile plot is a graphical alternative for the various
    classical 2-sample tests (e.g., t for location, F for dispersion).

    The plot consists of the following:

       Vertical axis   = estimated quantiles from data set 1;
       Horizontal axis = estimated quantiles from data set 2.

    The "quantiles" of a distribution are the distribution's "percent
    points" (e.g., .5 quantile = 50% point = median).  The advantage of
    the quantile-quantile plot is 2-fold:

       1) the sample sizes do not need to be identical;
       2) many distributional aspects can be simultaneously tested.
          For example, shifts in location, shifts in dispersion,
          changes in symmetry/skewness, outliers, etc.

    The quantile-quantile plot has 2 components:

       1) the quantile points themselves;
       2) a 45 degree reference line.

    Given a q-q plot, assume its y coordinates are in T(i) and
    its x coordinates are in D(i), then the Tukey mean-difference
    is defined as:

       Vertical axis   = T(i) - D(i);
       Horizontal axis = (T(i) + D(i)/2.

    The Tukey mean-difference plot also plots a horizontal
    reference line at zero.

    That is, it plots the difference of the quantiles against
    their average.  The advantage of the Tukey mean-difference
    compared to the q-q plot is that it converts interpretation
    of the differences around a 45 degree diagonal line to
    interpretation of differences around a horizontal zero
    line.  However, the Tukey mean-difference plot should only
    be applied if the two variables are on a common scale.

    Like usual, the appearance of the 2 components is controlled by
    the first 2 settings of the CHARACTERS and LINES commands.  It is
    typical for the response points to be represented as some
    character, say X's, with no connecting line, and the reference
    line as a connected line with no character.  This is
    demonstrated in the sample program below.
 
Syntax 1:
    TUKEY MEAN DIFFERENCE PLOT <y1> <y2> 
               <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    HIGHLIGHT TUKEY MEAN DIFFERENCE PLOT <y1> <y2> <tag>
                                    <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <tag> is a group-id variable that defines the highlighting;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax can be used to plot different plot points with
    different attributes.  For example, it can used to highlight
    groups in the data or to emphasize the extremes.

Examples:
    TUKEY MEAN DIFFERENCE PLOT Y1 Y2
    TUKEY MEAN DIFFERENCE PLOT RUN1 RUN2
    TUKEY MEAN DIFFERENCE PLOT BATCH1 BATCH2
    TUKEY MEAN DIFFERENCE PLOT Y1 Y2 SUBSET AUTO 4
    TUKEY MEAN DIFFERENCE PLOT Y1 Y2 SUBSET STATE 25
 
Note:
    One of the distributions can be a theoretical distribution.  For
    example, the following program generates a Tukey mean-difference
    plot of a data set against a normal distribution.

        LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
        LET X = SEQUENCE .01 .01 .99
        LET Y2 = NORPPF(X)
        TUKEY MEAN DIFFERENCE PLOT Y1 Y2

    This same technique can be used other distributions (use the proper
    PPF function). 

Note:
    For large data sets, it may be impractical to generate the plot for
    each individual point.  As an alternative, you can generate the plot
    for a user specified number of quantiles.  To do this, enter the
    command

        SET QUANTILE QUANTILE PLOT NUMBER OF PERCENTILES <value>

    where <value> specifies the desired number of quantiles.  This is
    demonstrated in the Program 2 example below.

Default:
    None
 
Synonyms:
    TUKEY M-D PLOT is a synonym for TUKEY MEAN DIFFERENCE PLOT.
 
Related Commands:
    CHARACTERS               = Sets the type for plot characters.
    LINES                    = Sets the type for plot lines.
    QUANTILE-QUANTILE PLOT   = Generates a q-q plot.
    BOX PLOT                 = Generates a box plot.
    BIHISTOGRAM              = Generates a bihistogram.
    PLOT                     = Generates a data or function plot.
    PROBABILITY PLOT         = Generates a probability plot.
    T-TEST                   = Carries out a 2-sample t test.
    F-TEST                   = Carries out a 2-sample F test.
 
References:
    William S. Cleveland (1993), "Visualizing Data", Hobart Press.
 
    Chambers, Cleveland, Kleiner, and Tukey (1983), "Graphical Methods
    of Data Analysis", Wadsworth, pp. 48-57.
 
Applications:
    Exploratory Data Analysis
 
Implementation Date:
    2000/01
    2011/02: Support for highlight option
    2016/06: Support for SET QUANTILE QUANTILE PLOT NUMBER OF PERCENTILES
 
Program 1:
    SKIP 25
    READ AUTO83B.DAT Y1 Y2
    DELETE Y2 SUBSET Y2 < 0
    .
    LINE BLANK SOLID
    CHARACTER CIRCLE BLANK
    CHARACTER FILL ON OFF
    TIC OFFSET UNITS DATA
    YTIC OFFSET 0 2
    TITLE AUTOMATIC
    LABEL CASE ASIS
    Y1LABEL Difference of Percentiles
    X1LABEL Average of Percentiles
    .
    TUKEY MEAN DIFFERENCE PLOT Y1 Y2
 
Program 2:
    LET Y1 = NORMAL RANDOM NUMBER FOR I = 1 1 1000000
    LET Y2 = DOUBLE EXPONENTIAL RANDOM NUMBER FOR I = 1 1 1000000
    .
    LINE BLANK SOLID
    CHARACTER CIRCLE BLANK
    CHARACTER FILL ON OFF
    CHARACTER HW 0.5 0.375
    TITLE AUTOMATIC
    TITLE OFFSET 2
    LABEL CASE ASIS
    Y1LABEL Normal Random Numbers
    X1LABEL Double Exponential Random Numbers
    .
    SET QUANTILE QUANTILE PLOT NUMBER OF PERCENTILES 1000
    TUKEY MEAN DIFFERENCE PLOT Y1 Y2
 
Program 3:
    SKIP 25
    READ AUTO83B.DAT Y1 Y2
    DELETE Y2 SUBSET Y2 < 0
    .
    LINE BLANK BLANK SOLID
    CHARACTER CIRCLE CIRCLE BLANK
    CHARACTER FILL ON ON OFF
    CHARACTER HW 0.5 0.375 ALL
    CHARACTER COLOR BLACK RED
    TITLE AUTOMATIC
    TITLE OFFSET 2
    TIC MARK OFFSET UNITS SCREEN
    YTIC MARK OFFSET 5 5
    .
    LET N2 = SIZE Y2
    LET TAG = 1 FOR I = 1 1 N2
    LET TAG = 2 SUBSET Y2 > 32
    .
    HIGHLIGHT TUKEY MEAN DIFFERENCE PLOT Y2 Y1 TAG
 
-----TWO FACTOR PLOT--------------------------------------
 
TWO FACTOR PLOT
 
Name:
    TWO FACTOR PLOT
 
Type:
    Graphics Command
 
Purpose:
    Given a response variable and associated variables containing
    laboratory id's and material id's, generate either a "laboratories
    within materials" or a "materials" within laboratories" plot.

Description:
    This is essentially a run sequence plot sorted by the two factor
    variables.

    This plot is motivated by the desire to plot residuals for the
    "phase 3" analysis related to the ASTM E691 standard.  The phase
    3 analysis is a row-linear model for the data in a E691 study and
    was proposed by John Mandel (see the References below) as an
    additional step in the E691 analysis.  In particular, Mandel
    recommended a plot of the standardized residuals from the row-linear
    model (specific plots for the h- and k-statistics are implemented
    with the H CONSISTENCY PLOT and K CONSISTENCY PLOT commands).

    Although motivated by the E691 analysis, this plot can be used for
    any two factor data set from a full factorial design (i.e., all
    combinations of levels from the two factors are included).  If there
    is replication within a cell, the mean of the replicates will be
    used.

Syntax:
    TWO FACTOR PLOT <y>  <labid>  <matid>
                         <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <labid> is a variable that specifies the lab-id;
          <matid> is a variable that specifies the material-id;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Examples:
    TWO FACTOR PLOT Y LABID MATID

Note:
    If there is replication within the cells and you would like
    to plot something other than the mean value, you can use the
    LET CROSS TABULATE command.  For example, to plot the standard
    deviations, do something like

       SET LET CROSS TABULATE COLLAPSE
       LET YSD = CROSS TABULATE SD Y X1 X2
       LET X1D = CROSS TABULATE GROUP ONE X1 X2
       LET X2D = CROSS TABULATE GROUP TWO X1 X2
       TWO FACTOR PLOT YSD X1D X2D

Note:
    There are two formats for the plots.  By default, the values are
    plotted linearly.  That is, given three laboratories and three
    materials, the x-axis is laid out as

       LAB:  1  2  3  1  2  3  1  2  3
       MAT:  1  1  1  2  2  2  3  3  3
       X:    1  2  3  4  5  6  7  8  9

    Alternatively, you can stack the lab values so that the x-axis is
    laid out as

       LAB:  1  1  1
             2  2  2
             3  3  3
       MAT:  1  2  3
       X:    1  2  3

    To specify the stacked alternative, enter the command

       SET TWO FACTOR PLOT TYPE STACKED

    To reset the line linear option, enter the command

       SET TWO FACTOR PLOT TYPE DEFAULT

Note:
    By default, the x-axis is defined by "laboratories within
    materials".

    To define the x-axis as "materials within laboratories",
    enter the command

        SET TWO FACTOR PLOT MATERIALS WITHIN LABORATORIES

    To reset the default, enter

        SET TWO FACTOR PLOT LABORATORIES WITHIN MATERIALS

    We find it useful to generate both versions of the plot.  Although
    the information being displayed is the same, different types of
    patterns may be clearer in one or the other of these plots.

Note:
    For better separation between laboratories (or materials), you
    can enter the command

        SET TWO FACTOR PLOT GAP <value>

    where <value> is a non-negative integer.  So in the above
    example,

        SET TWO FACTOR PLOT GAP 1

    yields

       LAB:  1  2  3  1  2  3  1  2  3
       MAT:  1  1  1  2  2  2  3  3  3
       X:    1  2  3  5  6  7  9 10 11

Note:
    In some studies, the number of laboratories may be fairly
    large.  In these cases, you may want to split the laboratories
    into multiple plots for better resolution.

    To address this, the following commands were added

        SET TWO FACTOR PLOT LABORATORY FIRST <value>
        SET TWO FACTOR PLOT LABORATORY LAST  <value>
        SET TWO FACTOR PLOT MATERIAL   FIRST <value>
        SET TWO FACTOR PLOT MATERIAL   LAST  <value>

    These commands allow you to specify the range of laboratories
    (or materials) to be displayed.  Note that these commands limit
    you to contiguous ranges of laboratories or materials.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    E691 INTERLAB       = Perform an interlaboratory analysis based
                          on the E691 standard.
    H CONSISTENCY PLOT  = Generate an h-consistency plot.
    TWO WAY ROW PLOT    = Generate a plot based on Mandel's row
                          linear analysis for two-way tables.

References:
    "Standard Practice for Conducting an Interlaboratory Study
    to Determine the Precision of a Test Method", ASTM
    International, 100 Barr Harbor Drive, PO BOX C700,
    West Conshohoceken, PA 19428-2959, USA.
 
    Mandel (1994), "Analyzing Interlaboratory Data According to ASTM
    Standard E691", Quality and Statistics: Total Quality Management,
    ASTM STP 1209, Kowalewski, Ed., American Society for Testing and
    Materials, Philadelphia, PA 1994, pp. 59-70.

    Mandel (1993), "Outliers in Interlaboratory Testing", Journal of
    Testing and Evaluation, Vol. 21, No. 2, pp. 132-135.

    Mandel (1995), "Structure and Outliers in Interlaboratory Studies",
    Journal of Testing and Evaluation, Vol. 23, No. 5, pp. 364-369.

    Mandel (1991), "Evaluation and Control of Measurements", Marcel
    Dekker, Inc.

Applications:
    Interlaboratory Studies
 
Implementation Date:
    2015/5
 
Program:
    . Step 1:   Read the data
    .
    dimension 40 columns
    skip 25
    read mandel7.dat y x1 x2
    .
    let nlab = unique x1
    let nmat = unique x2
    let ntot = nlab*nmat
    .
    variable label y Stress
    variable label x1 Lab-ID
    variable label x2 Rubber
    let nlab = unique x1
    let ncol = unique x2
    .
    . Step 2:   Define some default plot control settings
    .
    case asis
    title case asis
    title offset 2
    label case asis
    tic mark offset units screen
    tic mark offset 3 3
    .
    . Step 3:   Generate the two way row plot
    .
    x1label Column Average
    character blank all
    line dash all
    loop for k = 1 1 nlab
        let kindex = (k-1)*2 + 1
        let plot character kindex = ^k
        let plot line      kindex = blank
    end of loop
    .
    set two way plot factor label value
    set two way plot factor decimal 4
    set two way plot anova table on
    set two way plot anova table decimals 4
    set write decimals 4
    title Stress in Kg/cm**2 at 100% Elongation for Natural Rubber Vulcaizates
    y1label Data by Laboratory
    .
    two way row    plot y x1 x2
    .
    . Step 4:   Now generate the two factor plot of the residuals
    .
    skip 1
    read dpst3f.dat labid matid junk1 junk2 junk3 resstd
    skip 0
    y1label Standardized Residuals
    x1label Lab-ID/Rubber-ID
    legend 1 MATERIAL:
    legend 2 LAB:
    legend 1 justification right
    legend 2 justification right
    legend 1 coordinates 14 15
    legend 2 coordinates 14 12
    legend 1 size 1.7
    legend 2 size 1.7
    .
    x1label
    x1tic mark label off
    xlimits 1 ntot
    major x1tic mark number ntot
    minor x1tic mark number 0
    x1tic mark offset 1 1
    .
    line blank
    character blank
    spike on
    spike base 0
    two factor plot resstd labid matid
    line solid
    drawdata 1 0 ntot 0
    .
    . Step 5:   Draw lines separating the labs and add tic labels
    .           to identify labs/materials
    .
    let ycoorz = 16
    let xcoor = 1
    justification center
    height 0.7
    .
    loop for k = 1 1 ntot
        moveds xcoor ycoorz
        let ktemp = mod(k-1,nmat) + 1
        text ^ktemp
        let xcoor = xcoor + 1
    end of loop
    .
    height 1.5
    let ycoorz = 12
    let xcoor = (nmat/2)+0.5
    line color red
    line dash
    loop for k = 1 1 nlab
        moveds xcoor ycoorz
        let ival = k
        text ^ival
        if k < nlab
           let xcoor2 = xcoor + (nmat/2)
           drawdsds xcoor2 20 xcoor2 90
        end of if
        let xcoor = xcoor + nmat
    end of loop
    line color black
    line blank

-----TWO SAMPLE LINEAR RANK SUM TEST---------------------------------
 
TWO SAMPLE LINEAR RANK SUM TEST
 
Name:
    TWO SAMPLE LINEAR RANK SUM TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform a two sample two sample linear rank sum test for various
    scores.
 
Description:
    Given two samples, Y1 and Y2, with sample sizes n1 and n2,
    respectively, combine the two samples into a single sample and
    determine the ranks of the combined samples.

    Two sample linear rank sum tests are then based on the statistic

        S = SUM[i=1 to n][tag(i)*a(R(i))]

    with n denoting the combined sample size and R(i) denoting the
    rank of the i-th observation.  The variable tag is an indicator
    variable that has the value 1 for the observations from the smaller
    sample size and the value 0 for the observations from the larger
    sample size (if n1 = n2, tag will be set to 1 for the sample that
    the first observation comes from).  The a(R(i)) is a score function
    based on the ranks.  The supported score functions are described in
    a Note section below.

    The following test statistic is based on asymptotic normality

        z = (S - E0(S))/SD0(S)

    where

        E0(S)  = the expected value of S under the null hypothesis
               = (n1/n)*SUM[i=1 to n][a(R(i))]
        SD0(S) = the standard deviation of S under the null hypothesis
               = (n1*n2/(n*(n-1))*SUM[i=1 to n][(a(R(i) - abar)**2]
        abar   = the average score
               = SUM[i=1 to n][a(R(i))]/n

    Note that n1 denotes the sample size for the smaller sample, not
    necessarily the sample size of Y1.

    Tied ranks use the average rank of the tied values.

Syntax 1:
    <LOWER TAILED/UPPER TAILED> TWO SAMPLE LINEAR RANK SUM TEST <y1> <y2>
                                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If LOWER TAILED is specified, a lower tailed test is performed.  If
    UPPER TAILED is specified, an upper tailed test is performed.  If
    neither LOWER TAILED or UPPER TAILED is specified, a two-tailed test
    is performed.

Syntax 2:
    <LOWER TAILED/UPPER TAILED> TWO SAMPLE LINEAR RANK SUM TEST
                                <y1>  ... <yk>
                                <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of two or more response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax performs all the two-way two sample linear rank sum tests
    for the listed variables.  This syntax supports the TO syntax.

    If LOWER TAILED is specified, a lower tailed test is performed.  If
    UPPER TAILED is specified, an upper tailed test is performed.  If
    neither LOWER TAILED or UPPER TAILED is specified, a two-tailed test
    is performed.

Examples:
    TWO SAMPLE LINEAR RANK SUM TEST Y1  Y2
    TWO SAMPLE LINEAR RANK SUM TEST Y1  Y2 Y3
    TWO SAMPLE LINEAR RANK SUM TEST Y1  TO Y6
    TWO SAMPLE LINEAR RANK SUM TEST Y1  Y2  SUBSET Y2 > 0
    LOWER TAILED TWO SAMPLE LINEAR RANK SUM TEST Y1  Y2
    UPPER TAILED TWO SAMPLE LINEAR RANK SUM TEST Y1  Y2

Note:
    To specify the scoring function, enter the command

       SET LINEAR RANK SUM TEST SCORE <case>

    where <case> is one of the following

       1. WILCOX

          This option uses Wilcoxon scores

              a(R(i)) = R(i)

          That is, the Wilcoxon scores are simply the ranks.  Using
          this score is essentially a rank sum test (also known as the
          Mann-Whitney test).

          This score is primarily used to test for equal locations.

       2. MEDIAN

          This option uses median scores

              a(R(i)) = 1    if R(i) >  (n+1)/2
                      = 0    if R(i) <= (n+1)/2

          That is, ranks greater than the median rank are scored as a 1
          and ranks less than or equal to the median rank are scored as 0.
          Using this score is essentially a 2-sample median test.  Median
          scores work best for distributions that are symmetric and
          heavy-tailed.

          This score is primarily used to test for equal locations.

       3. VAN DER WAERDEN

          This option uses the Van Der Waerden scores

              a(R(i)) = NORPPF(R(i)/(n+1))

          with NORPPF denoting the percent point function of the
          standard normal distribution.  Van Der Waerden scores are
          the percentiles of a standard normal distribution.  Using
          this score is essentially a 2-sample Van Der Waerden test.

          This score is primarily used to test for equal locations.

       4. SAVAGE

          This option uses the Savage scores

              a(R(i)) = SUM[j = 1 to R(i)][1/(n-j+1)] - 1

          Savage scores are the expected values of exponential order
          statistics minus 1 (to center the scores around 0).  Savage
          scores are typically used to test location differences in
          extreme value distributions and to test scale differences in
          exponential distributions.

       5. MOOD

          This option uses the Mood scores

              a(R(i)) = (R(i) - (n+1)/2)**2

          Mood scores are the square of the difference between the
          observation rank and the average rank.

          This score is primarily used to test for equal scales.

       6. ANSARI BRADLEY

          This option uses the Ansari-Bradley scores

              a(R(i)) = (n+1)/2 + ABS(R(i) - (n+1)/2)

          This score is often given in a different form, but the form
          given here is useful for computational purposes.

          This score is primarily used to test for equal scales.

       7. KLOTZ

          This option uses the Klotz scores

              a(R(i)) = (NORPPF(R(i)/(n+1))**2

          This score is the square of the Van Der Waerden score.
          Using this score is essentially a 2-sample Klotz test.

          This score is primarily used to test for equal scales.

       8. CONOVER

          This option uses the Conover scores

              a(R(i)) = (R(U(i))**2

          where

              U(i) = ABS(Yi(j) - Ybar(j))

          That is, the Conover scores are the squared ranks of the
          absolute deviations from the group mean.  Using this score
          is essentially a 2-sample squared ranks test.

          This score is primarily used to test for equal scales.

Note:
    The following parameters are saved after the two sample
    linear rank test is performed.

         STATVAL   - value of the test statistic
         STATCDF   - CDF of the test statistic
         PVALUE    - p-value of the two tailed test statistic
         PVALUELT  - p-value of the lower tailed test statistic
         PVALUEUT  - p-value of the upper tailed test statistic

         CUTUPP90  - 90%   upper critical value
         CUTUPP95  - 95%   upper critical value
         CUTUP975  - 97.5% upper critical value
         CUTUPP99  - 99%   upper critical value
         CUTUP995  - 99.5% upper critical value
         CUTUP999  - 99.9% upper critical value

         CUTLOW10  - 10%   lower critical value
         CUTLOW05  - 5%    lower critical value
         CUTLO025  - 2.5%  lower critical value
         CUTLOW01  - 1%    lower critical value
         CUTLO005  - 0.5%  lower critical value
         CUTLO001  - 0.1%  lower critical value

Note:
    In addition to the TWO SAMPLE LINEAR RANK SUM TEST command, the
    following commands can also be used:

        LET STATVAL = TWO SAMPLE LINEAR RANK SUM TEST        Y1 Y2
        LET STATCDF = TWO SAMPLE LINEAR RANK SUM TEST CDF    Y1 Y2
        LET PVALUE  = TWO SAMPLE LINEAR RANK SUM TEST PVALUE Y1 Y2
        LET PVALUE  = TWO SAMPLE LINEAR RANK SUM LOWER TAIL TEST PVALUE Y1 Y2
        LET PVALUE  = TWO SAMPLE LINEAR RANK SUM UPPER TAIL TEST PVALUE Y1 Y2

    In addition to the above LET commands, built-in statistics are
    supported for 30+ different commands (enter HELP STATISTICS for
    details).

Default:
    The default score function is WILCOX
 
Synonyms:
    2 SAMPLE is a synonym for TWO SAMPLE
 
Related Commands:
    RANK SUM TEST           = Perform a 2-sample rank sum test for location
    MEDIAN TEST             = Perform a k-sample medians test
    VAN DER WAERDEN TEST    = Perform a k-sample Van Der Waerden test
    SIEGEL TUKEY TEST       = Perform a 2-sample Siegel Tukey test
    SQUARED RANKS TEST      = Perform a k-sample squared ranks test for
                              homogeneous variances.
    KLOTZ TEST              = Perform a k-sample Klotz test for
                              homogeneous variances.

Applications:
    Two Sample Analysis
 
Implementation Date:
    2023/07:
 
Program:
    . Step 1:   Read the data
    .
    skip 25
    read shoemake.dat y1 y2
    skip 0
    let y x = stack y1 y2
    .
    . Step 2:   Generate the statistics
    .
    set linear rank sum test score van der waerden
    let statval = linear rank sum test                        y1 y2
    let statcdf = linear rank sum test cdf                    y1 y2
    let pvalue  = linear rank sum test pvalue                 y1 y2
    let pvallt  = linear rank sum test lower tail pvalue      y1 y2
    let pvalut  = linear rank sum test upper tail pvalue      y1 y2
    let statval = round(statval,2)
    let statcdf = round(statcdf,2)
    let pvalue  = round(pvalue,2)
    let pvallt  = round(pvallt,2)
    let pvalut  = round(pvalut,2)
    .
    print "Van Der Waerden Scores:"
    print "Test Statistic:                        ^statval"
    print "Test Statistic CDF:                    ^statcdf"
    print "Test Statistic P-Value:                ^pvalue"
    print "Test Statistic Lower Tailed P-Value:   ^pvallt"
    print "Test Statistic Upper Tailed P-Value:   ^pvalut"
    .
    two sample linear rank sum test                y1 y2
    van der waerden test                           y  x
    .
    set linear rank sum test score wilcox
    two sample linear rank sum test                y1 y2
    t test                                         y1 y2
    .
    set linear rank sum test score klotz
    two sample linear rank sum test                y1 y2
    klotz test                                     y1 y2

-----TWO SAMPLE PERMUATION TEST---------------------------------
 
TWO SAMPLE PERMUATION TEST
 
Name:
    TWO SAMPLE <STATISTIC> PERMUATION TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform a two sample permutation test for a specified statistic.
 
Description:
    Given random variables Y1 and Y2 with sample sizes n1 and n2,
    respectiively, permutation tests are performed as follows

       1. Compute the desired statistic for the original data.

       2. Combine the 2 data sets into a single data set.

       3. Generate a permutation of the combined data.  Then compute the
          desired statistic (the first n1 permuted values constitute the
          first response variable and the following n2 permuted values
          constitute the second response variable).

       4. Repeat step 3 NITER number of times.

    The NITER computed statistics represent the reference distribution.
    The statistic for the original data is compared to this reference
    distribution.  For example, the cut-offs for a two-sided 95% test are
    obtained from the 2.5% and 97.5% percentiles of the reference
    distribution.

    The permutation test is based on all possible permutations of the
    data.  However, the number of permutations ((n1+n2)!/(n1!n2!)) grows
    rapidly as the sample sizes increase.  However, sampling a subset
    of all possible permutations provides a reasonable approximation
    for the permutation test.  By default, Dataplot generates 4,000
    iterations.  To change this, enter the command

          SET PERMUTATION TEST SAMPLE SIZE <value>

    If <value> is less than 100, it will be set to 100.  If <value>
    is greater than 100,000, it will be set to 100,000.

    The specified statistic should be one that can be computed from a
    single response variable (e.g., MEAN, MEDIAN, VARIANCE).  By default,
    Dataplot will compute the difference of the statistic between the
    two samples.  For scale statistics (e.g., STANDARD DEVIATION,
    VARIANCE), it is often preferred to compute the ratio rather than
    the difference.  To specify the ratio be computed, enter

         SET PERMUTATION TEST RATIO

    To reset the default, enter

         SET PERMUTATION TEST DIFFERENCE

    Permutation tests assume the observations are independent.  However,
    no distributional assumptions are made about the response variables.

Syntax 1:
    <LOWER TAILED/UPPER TAILED> TWO SAMPLE PERMUATION TEST <y1> <y2>
                                <SUBSET/EXCEPT/FOR qualification>
    where <stat> is the desired statistic;
          <y1> is the first response variable;
          <y2> is the second response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If LOWER TAILED is specified, a lower tailed test is performed.  If
    UPPER TAILED is specified, an upper tailed test is performed.  If
    neither LOWER TAILED or UPPER TAILED is specified, a two-tailed test
    is performed.

    To see a list of supported statistics, enter HELP STATISTICS.

Syntax 2:
    <LOWER TAILED/UPPER TAILED> TWO SAMPLE <stat> PERMUATION TEST
                                <y1>  ... <yk>
                                <SUBSET/EXCEPT/FOR qualification>
    where <stat> is the desired statistic;
          <y1> ... <yk> is a list of two or more response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax performs all the two-way two sample permutation tests
    for the listed variables.  This syntax supports the TO syntax.

    If LOWER TAILED is specified, a lower tailed test is performed.  If
    UPPER TAILED is specified, an upper tailed test is performed.  If
    neither LOWER TAILED or UPPER TAILED is specified, a two-tailed test
    is performed.

    To see a list of supported statistics, enter HELP STATISTICS.

Examples:
    TWO SAMPLE MEAN PERMUATION TEST Y1  Y2
    TWO SAMPLE MEDIAN PERMUATION TEST Y1  Y2
    TWO SAMPLE MEDIAN PERMUATION TEST Y1  Y2  SUBSET Y2 > 0
    LOWER TAILED TWO SAMPLE MEDIAN PERMUATION TEST Y1  Y2
    UPPER TAILED TWO SAMPLE MEDIAN PERMUATION TEST Y1  Y2

    SET PERMUTATION TEST RATIO
    TWO SAMPLE STANDARD DEVIATION PERMUATION TEST Y1  Y2

Note:
    This routine uses a random permutation algorithm suggested by Knuth.
    Specifically, it adapts the RANDPERM routine of Knoble. 

Note:
    The following parameters are saved after the two sample
    permutation test is performed.

         STATVAL   - value of the test statistic
         STATCDF   - CDF of the test statistic
         PVALUE    - p-value of the two tailed test statistic
         PVALUELT  - p-value of the lower tailed test statistic
         PVALUEUT  - p-value of the upper tailed test statistic

         P80       - 80%   upper critical value
         P90       - 90%   upper critical value
         P95       - 95%   upper critical value
         P975      - 97.5% upper critical value
         P99       - 99%   upper critical value
         P995      - 99.5% upper critical value
         P999      - 99.9% upper critical value

         P20       - 20%   lower critical value
         P10       - 10%   lower critical value
         P05       - 5%    lower critical value
         P025      - 2.5%  lower critical value
         P01       - 1%    lower critical value
         P005      - 0.5%  lower critical value
         P001      - 0.1%  lower critical value

Default:
    The difference (or the ratio) of the statistic for the two
    samples will generated for 4,000 permutations.
 
Synonyms:
    2 SAMPLE is a synonym for TWO SAMPLE
 
Related Commands:
    LINEAR RANK SUM TEST    = Perform a 2-sample linear rank sum test.
    T TEST                  = Perform a 2-sample t test.
    RANK SUM TEST           = Perform a 2-sample rank sum test for location
    MEDIAN TEST             = Perform a k-sample medians test
    VAN DER WAERDEN TEST    = Perform a k-sample Van Der Waerden test
    SIEGEL TUKEY TEST       = Perform a 2-sample Siegel Tukey test
    SQUARED RANKS TEST      = Perform a k-sample squared ranks test for
                              homogeneous variances.
    KLOTZ TEST              = Perform a k-sample Klotz test for
                              homogeneous variances.
    BIHISTOGRAM             = Generate a bihistogram.
    QUANTILE QUANTILE PLOT  = Generate a quantile-quantile plot.

References:
    Higgins (2004), "Introduction to Modern Nonparametric Statistics,"
    Duxbury Press, Chapter 2.

    Knuth (1998), "The Art of Computer Programming: Volume 2 Seminumerical
    Algorithms, Third Edition", Section 3.4.2, Addison-Wesley.

    Knoble RANDPERM algorithm downloaded from:
    "http://coding.derkeiler.com/Archive/Fortran/comp.lang.fortran/
    2006-03/msg00748.html"

Applications:
    Two Sample Analysis
 
Implementation Date:
    2023/08:
 
Program:
    set random number generator fibbonacci congruential
    seed 32119
    .
    .           Read the data
    .
    skip 25
    read auto83b.dat y1 y2
    retain y2 subset y2 >= 0
    .
    .           Perform the permutation test
    .
    lower tailed two sample mean permutation test              y1 y2
    upper tailed two sample mean permutation test              y1 y2
    two sample mean permutation test                           y1 y2
    .
    .           Plot the results
    .
    title offset 7
    title case asis
    label case asis
    y1label Count
    x1label Difference of Means for Permutations
    
    let statval = round(statval,3)
    let p025 = round(p025,3)
    let p975 = round(p975,3)
    let pval = round(pvalue2t,3)
    let statcdf = round(statcdf,3)
    .
    x2label color red
    x2label Difference of Means for Original Sample: ^statval
    x3label color blue
    x3label 2.5 Percentile: ^P025, 97.5 Percentile: ^P975
    xlimits -15 5
    let niter = 4000
    skip 1
    read dpst1f.dat z
    title Histogram of Difference of Means for ^niter Permutationscr() ...
          (Pvalue: ^pval, CDF: ^statcdf)
    .
    histogram z
    .
    line color red
    line dash
    drawdsds statval 20 statval 90
    line color blue
    line dash
    drawdsds p025 20 p025 90
    drawdsds p975 20 p975 90

-----TWO WAY PLOT--------------------------------------
 
TWO WAY PLOT
 
Name:
    TWO WAY <ROW/COLUMN> PLOT
 
Type:
    Graphics Command
 
Purpose:
    Given a response variable and associated variables containing
    laboratory id's and material id's, generate a plot of each
    laboratory against the column average.  In addition, perform
    a row linear (or column linear) analysis of variance.

Description:
    This plot was developed in the context of an interlaboratory
    analysis as defined by the ASTM E691 standard

       "Standard Practice for Conducting an Interlaboratory Study
       to Determine the Precision of a Test Method", ASTM
       International, 100 Barr Harbor Drive, PO BOX C700,
       West Conshohoceken, PA 19428-2959, USA.

    This standard addresses the situation where there are two factors
    (material and laboratory) and there is a full factorial balanced
    design (i.e., each combination of material and laboratory is run
    with an equal number of replications).  The E691 INTERLAB command
    generates the tables described in the standard.

    John Mandel proposed that a "phase 3" (see Analyzing Interlaboratory
    Data According to ASTM Standard E691) to examine the underlying
    mathematical model may sometimes be useful.

    The standard two-way additive ANOVA model is

        y(ij) = M + (R(i) - M) + (C(j) - M) + d*(ij)
              = R(i) + C(j) - M + d*(ij)

    where

        M      = overall mean
        R(i)   = average of all elements of the i-th laboratory
        C(j)   = average of all elements of the j-th material
        d*(ij) = the error term including both random error and
                 "interaction" effects

    The main row effect is R(i) - M and the main column effect is
    C(j) - M.

    For the case where there is significant (in the sense of being
    much larger than the random error) interaction, Mandel introduced
    the "row-linear" model

        y(ij) = R(i) + B(i)*(C(j) - M) + d(ij)

    That is, you essentially generate a linear fit for a specific
    laboratory across the various materials.  This model effectively
    partitions the d*(ij) into a "systematic" and a "random" component

        d*(ij) = (B(i) - 1)*(C(j) - M)  +  d(ij)

    where d(ij) is the random component and the rest is the systematic
    component.  If the row-linear model is appropriate, then the
    systematic component should be much larger than the random
    component.  Essentially, the systematic component is fitting a
    linear function of each laboratory against the average of all
    laboratories.  The B(i) in the above equation are the slopes
    of the linear fits.

    This command generates a plot of the linear fits for each row.
    Specifically, for each lab i plot

        Y(ij) versus C(j)  for j = 1 to number of materials

    That is, you plot a given laboratory's value against the average
    of all laboratories for each material.

    Alternatively you can plot (see Note section below)

        Y(ij) - C(j) versus C(j) for all j

    That is, plot the deviations from the column average versus the
    column average.

    In either case, the fitted lines are overlaid on the data points.
    The fundamental linearity is the same in either version of the
    plot.

    If the row-linear model is appropriate, the points for each
    laboratory should be approximately linear.  If the slopes are
    all approximately equal to one, this implies that the row-linear
    model reduces to the additive model.

    In addition, this command generates the following tables:

        1. The first table contains the following columns:

           Column 1: Lab-ID
           Column 2: the height of the fit (the height is the predicted
                     value at xbar where xbar is the mean of the
                     material values for a given laboratory)
           Column 3: the slope of the fit
           Column 4: the residual standard deviation of the fit
           Column 5: the standard error of the slope
           Column 6: the correlation coefficient

           The number of rows in the table is equal to the number of
           laboratories.

         2. The second table contains the average over all laboratories
            for each value of the material.

         3. The third table contains an analysis of variance table
            for the row-linear model.  Specifically, it partitions
            the error sum of squares into a residuals component and
            a slopes (i.e., the sum of squares accounted for by the
            row-linear structure).

    Similarly, you can create a "column linear" model

        y(ij) = C(j) + B(j)*(R(i) - M) + d(ij)

    In the context of the E691 standard, the row linear model, where
    the rows denote laboratories, is typically of more interest.

    Mandel goes on further to discuss "concurrent" models.  In some cases,
    the slopes will exhibit a systematic pattern.  If we generate a plot
    of the slopes versus the heights and this plot indicates a linear
    pattern, this is evidence of a concurrent model.  When the concurrent
    model is appropriate, the fitted lines generated by the TWO WAY ROW
    PLOT command tend towards a common point.  Call the y-coordinate
    of the common point y0.  Then the concurrent model is

        y(ij) = y0 + (R(i) - y0)*(C(j) - y0)/(M - y0) + d(ij)

    If y0 is zero, then the concurrent model reduces to the standard
    multiplicative model

        y(ij) = R(i)*C(j)/M + d(ij)

    Concurrent models can be useful when you have both row and column
    linearity.  Note that the ANOVA table generated by this command
    further partitions the slopes sum of squares into "Concurrence" and
    "Non-Concurrence" parts.

    Although motivated by the E691 analysis, this plot can be used for
    any two factor data set from a full factorial design (i.e., all
    combinations of levels from the two factors are included).  If there
    is replication within a cell, the mean of the replicates will be
    used.  If there are any missing cells, an error will be reported
    and no plots or tables will be generated.

    The above is only a brief outline of row-linear models.  For
    more detailed discussion and derivations, consult Mandel's
    publications in the Reference section below.

Syntax 1:
    TWO WAY ROW PLOT <y>  <labid>  <matid>
                          <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <labid> is a variable that specifies the lab-id;
          <matid> is a variable that specifies the material-id;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax plots and fits the row-linear model.

Syntax 2:
    TWO WAY COLUMN PLOT <y>  <labid>  <matid>
                             <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <labid> is a variable that specifies the lab-id;
          <matid> is a variable that specifies the material-id;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax plots and fits the column-linear model.

Examples:
    TWO WAY ROW PLOT Y LABID MATID
    TWO WAY COLUMN PLOT Y LABID MATID
    TWO WAY ROW PLOT Y LABID MATID > 2

Note:
    To plot the deviations from the column average versus the
    column average (rather than the raw data), enter the command

         SET TWO WAY PLOT Y AXIS DEVIATION

    To reset the default, enter

         SET TWO WAY PLOT Y AXIS RAW

Note:
    If the fitted lines are basically parallel and the slopes
    are all approximately equal to one, then the row-linear model
    reduces to the standard additive model.  That is, the error will
    be predominately the "random" component and the "systematic"
    error is minimal.

    Next, compare the "standard deviation of the slopes" to the standard
    deviations of the individual fits (i.e., the RESSD column in Table 1).
    If the standard deviation of the slopes is significantly larger
    than the RESSD values, this is evidence that there is a systematic
    effect for the laboratories and that the additive model is not
    applicable.  The square of the correlation coefficients of the fits
    gives an indication of how much of the variablity is accounted for
    by the linear fit (i.e., the systematic component) and how much is
    random.

    If there is evidence of a systematic effect, then plot the
    fit slopes versus the fit heights.  If this plots shows
    approximate linearity, then this is evidence for concurrence
    in the data.

    This is only a brief overview of the interpretation of
    row linear models.  Consult the Mandel publications listed
    in the References section for a more complete discussion.

Note:
    The TWO WAY PLOT command is typically preceded by an E691 INTERLAB
    (HELP E691 INTERLAB for details) command.  The documenation for the
    E691 INTERLAB command discusses a number of plots that are
    typically generated for an E691 analysis.  Specifically, plots
    of the h- and k-consistency statistics are highly recommended.

    The following additional plots are recommended for the analysis of
    row linear models.

       1. Plot the residuals from the row linear fit.  Mandel
          recommends plotting the standardized residuals rather
          than the raw residuals.  The standardized residuals are
          the raw residuals divided by the residual standard
          deviation of the fit.

          Enter HELP TWO FACTOR PLOT for an example of plotting
          these residuals.

       2. Plot the slopes of the fits versus the heights of the
          fits.  An approximately linear relationship for this
          plot is evidence of "concurrence".

Note:
    The columns printed in table 1 are also written to the file
    dpst1f.dat.  The columns printed in table 2 are also written
    to dpst2f.dat.

    The following are written to dpst3f.dat:

        Column 1:  row-id
        Column 2:  column-id
        Column 3:  Y(ij)
                   (this is after replications have been averaged)
        Column 4:  predicted values for the row linear fits
        Column 5:  raw residuals for the row linear fits
        Column 6:  standardized residuals for the row linear fits

    This information is written to files to make it easier to
    generate some of the complimentary plots useful in analyzing
    row linear models.

Note:
    By default, the values for the factor variable (column 1 in
    tables 1 and 2) are coded.  That is, the minimum value is set
    to 1, the next smallest values is set to 2, and so on.  If you
    want the actual value to be printed in these tables, enter the
    command

        SET TWO WAY PLOT FACTOR LABEL VALUE

    To reset the default, enter the command

        SET TWO WAY PLOT FACTOR LABEL CODED

Note:
    The SET WRITE DECIMALS command can be used to control
    how many digits to the right of the decimal point are used
    in the tables generated by this command.  Specifically,
    a positive integer will print the number in decimal format.
    For example, SET WRITE DECIMAL 2 will generate numbers of the
    form 32.46.  If you enter a negative integer, then the numbers
    will be written in exponential format where the postive value
    of the given number of decimals will specify the number of
    significant digits in the exponential number.  For example,
    SET WRITE DECIMALS -7 will generate numbers of the form
    0.2093738E+07.  A SET WRITE DECIMAL 0 command specifies that
    the numbers will be written as integers.

    The factor variable (i.e., column 1 in tables 1 and 2) is
    often an integer value.  The following command allows you
    to specify a different number of digits for this column

        SET TWO WAY PLOT FACTOR DECIMAL <value>

    This command follows the same rules as the SET WRITE DECIMAL
    command and is typically set to 0.  If you want this column
    to use the value given by the SET WRITE DECIMALS command (the
    default), enter

        SET TWO WAY PLOT FACTOR DECIMAL -99

Note:
    If you want to suppress the fit table (table 1), enter the command

        SET TWO WAY PLOT FIT TABLE OFF

    To restore the default of printing the fit table, enter

        SET TWO WAY PLOT FIT TABLE ON

Note:
    If you want to suppress the column averages table (table 2), enter
    the command

        SET TWO WAY PLOT AVERAGES TABLE OFF

    To restore the default of printing the column averages table, enter

        SET TWO WAY PLOT AVERAGES TABLE ON

Note:
    If you want to suppress the ANOVA table (table 3), enter the command

        SET TWO WAY PLOT ANOVA TABLE OFF

    To restore the default of printing the ANOVA table, enter

        SET TWO WAY PLOT ANOVA TABLE ON

    The sum of squares and mean sum of squares columns in the ANOVA table
    can be quite large.  For this reason, you may want these to be written
    in exponential format.  To specify the number of decimals for these
    columns, enter the command

        SET TWO WAY PLOT ANOVA TABLE DECIMAL <value>

    This command follows the same rules as the SET WRITE DECIMAL
    command and is often set to -7.  If you want this column
    to use the value given by the SET WRITE DECIMALS command (the
    default), enter

        SET TWO WAY PLOT ANOVA TABLE DECIMAL -99

Note:
    In chapter 9 of Mandel's "Evaluation and Control of Measurements"
    book, Mandel discusses the relationship between the biplot and the
    row/column model.  The biplot is a graphical method introduced by
    Gabriel that can be used as a diagnostic to determine whether row
    linear or column linear relationships exist.  The paper by Bradu and
    Gabriel given in the References section also discusses Mandel's
    row/column models in the context of the biplot.

Related Commands:
    E691 INTERLAB       = Perform an interlaboratory analysis based
                          on the E691 standard.
    H CONSISTENCY PLOT  = Generate h-consistency statistic plots.
    K CONSISTENCY PLOT  = Generate k-consistency statistic plots.
    TWO FACTOR PLOT     = Generate a run sequence plot with two
                          factor variables.

References:
    "Standard Practice for Conducting an Interlaboratory Study
    to Determine the Precision of a Test Method", ASTM
    International, 100 Barr Harbor Drive, PO BOX C700,
    West Conshohoceken, PA 19428-2959, USA.
 
    Mandel (1961), "Non-Additivity in Two-Way Analysis of
    Variance", Journal of the American Statistical
    Association, Vol. 56, pp. 878-888.

    Mandel (1995), "Structure and Outliers in Interlaboratory Studies",
    Journal of Testing and Evaluation, Vol. 23, No. 5, pp. 364-369.

    Mandel (1994), "Models and Interactions", Journal of Test and
    Evaluation, Vol. 19, No. 5, pp. 398-402.

    Mandel (1994), "Analyzing Interlaboratory Data According to ASTM
    Standard E691", Quality and Statistics: Total Quality Management,
    ASTM STP 1209, Kowalewski, Ed., American Society for Testing and
    Materials, Philadelphia, PA 1994, pp. 59-70.

    Mandel (1994), "Analysis of Two-Way Layouts", Chapman & Hall,
    New York.

    Mandel (1993), "Outliers in Interlaboratory Testing", Journal of
    Testing and Evaluation, Vol. 21, No. 2, pp. 132-135.

    Mandel (1991), "Evaluation and Control of Measurements", Marcel
    Dekker, Inc.

    Bradu and Gabriel (1978), "The Biplot as a Diagnostic Tool for
    Models of Two-Way Tables", Technometrics, Vol. 20, No. 1, pp. 47-68.

Applications:
    Interlaboratory Studies
 
Implementation Date:
    2015/6
 
Program 1:
    . Step 1:   Read the data
    .
    dimension 40 columns
    skip 25
    read mandel8.dat y x1 x2
    .
    variable label y Compressive Strength
    variable label x1 Lab-ID
    variable label x2 Temperature
    .
    . Step 2:   Define some default plot control settings
    .
    case asis
    title case asis
    title offset 2
    label case asis
    tic mark offset units screen
    tic mark offset 3 3
    .
    . Step 3:   Generate the plot
    .
    x1label Column Average
    character blank all
    line dash all
    loop for k = 1 1 10
        let kindex = (k-1)*2 + 1
        let plot character kindex = ^k
        let plot line      kindex = blank
    end of loop
    .
    set two way plot factor label value
    set two way plot factor decimal 0
    set two way plot anova table decimals -7
    set write decimals 4
    title Compressive Strength of Rubber
    y1label Data by Rows
    .
    two way row plot y x1 x2
    .
    . Step 4:   Generate the slope versus height plot
    .
    skip 1
    read dpst1f.dat junk height slope
    .
    fit slope height
    let htmin = minimum height
    let htmax = maximum height
    let function f = a0 + a1*x
    .
    character circle
    character hw 1 0.75
    character fill on
    line blank dash
    y1label Slope
    x1label Height
    title 
    .
    xlimits 4500 6000
    .
    plot slope height and
    plot f for x = htmin 0.1 htmax

-----TYPE-----------------------------------------------------
 
TYPE
 
Name:
    TYPE
 
Type:
    Let Subcommand
 
Purpose:
    Return the type of a previously defined variable, parameter,
    string or matrix.
 
Description:
    Dataplot maintains an internal name table for variables, parameters,
    strings, and matrices.  It may occassionally be useful to determine
    the type of a name in this table.

    This command will return a string with one of the following values:

        NONE       => The name was not found
        VARIABLE   => The name was found as a variable
        PARAMETER  => The name was found as a parameter
        STRING     => The name was found as a string or function
        MATRIX     => The name was found as a matrix

    Dataplot names are currently limited to a maximum of eight
    characters and should consist of alphabetic or numeric characters.
    Names should not include spaces or special characters.

    The TYPE command is most commonly used in general purpose macros
    to test if input variables, parameters, and strings are of the
    right type.

Syntax:
    LET <sout> = TYPE  <string>
    where <string> is literal text that specifies the name to search for;
    and   <sout> is a string that specifies the type for the given name.

Examples:
    LET SY = TYPE Y
 
Note:
    Character variables are stored in the "dpchzf.dat" file and are
    not stored in the internal Dataplot name table.  The TYPE command
    does not search for names in "dpchzf.dat".
 
Note:
    Strings in Dataplot maintain their case.  Be aware that the returned
    type is given in upper case.  So when using the type string with
    the IF command, be sure to specify the value as upper case.  That
    is, use

        if sy = VARIABLE

    rather than

        if sy = variable

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LET FUNCTION        = Defines a function.
    LET STRING          = Defines a string.
    IF EXIST            = Determine whether a parameter or a string is
                          currently defined.
    SUBTRING            = Extract a substring from an existing string.
    STRING INDEX        = Extract the start/stop positions of a substring
                          within a string.
    STRING CONCATENATE  = Concatenate one or more previously defined
                          strings.
    STRING LENGTH       = Return the length of a string.
    STRING EDIT         = Edit a string.
    STRING REPLACE      = Insert the contents of one string into another
                          string at a specified position.
    STRING MERGE        = Insert a string into another string without
                          overwrite.
    LOWER CASE          = Convert a string to lower case.
    UPPER CASE          = Convert a string to upper case.
    CHARACTER           = Convert numeric values to strings based on
                          the ASCII collating sequence.
    ICHAR               = Convert a string to numeric values based on
                          the ASCII collating sequence.
 
Applications:
    Data Management
 
Implementation Date:
    2014/12
 
Program:
    SKIP 25
    READ BERGER1.DAT Y X BAT
    LET STRING STITLE BERGER Data
    READ MATRIX M
    1 2 3
    4 5 6
    END OF DATA
    LET A = 2
    .
    LET SY = TYPE Y
    LET SX = TYPE X
    LET SZ = TYPE Z
    LET SA = TYPE A
    LET SM = TYPE M
    LET SS = TYPE STITLE
    PRINT SY SX SZ SA SM SS
    .
    IF SY = VARIABLE
       IF SX = VARIABLE
          FIT Y X
       END OF IF
    END OF IF
    .
    IF SA = PARAMETER
       PRINT A
    END OF IF
-------------------------------------------------------------




































































































-------------------------  *U*  ZZZZZ--------------------

-----U CHART-----------------------------------------------------

U CHART

Name:
    U CHART
 
Type:
    Graphics Command
 
Purpose:
    Generates a (Poison) proportion control chart.
 
Description:
    A P chart is a data analysis analysis technique for determining if
    a measurement process has gone out of statistical control.  The U
    chart is sensitive to changes in the normalized number of
    defectives.  Normalized means that the number of defectives is
    divided by the unit area.  You can also normalize to compensate for
    unequal sample sizes (see the Note below).  The "U" in U chart
    stands for "unit" as in number of defectives per unit size".  The
    U control chart consists of:
       Vertical   axis = the normalized number of defectives (number
                         of defectives/area for the sub-group) for
                         each sub-group;
       Horizontal axis = sub-group designation.
 
    In addition, horizontal lines are drawn at the mean number of
    defectives and at the upper and lower control limits.  The 
    distribution of the number of defective items is assumed to be
    Poisson.  This assumption is the basis for calculating the control
    limits.  The control limits are calculated as:
         UCL = ubar + 3*sqrt(ubar/A)
         LCL = ubar - 3*sqrt(ubar/A)
    where ubar is the total number of defects divided by the total 
    area and A is the area corresponding to a given sub-group.  Also,
    zero serves as a lower bound on the LCL.
Syntax:
    U CHART  <y1>  <y2>  <x>   <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable containing the number of defective items
               in each sub-group;
          <y2> is a variable containing the total area in each
               sub-group;
          <x>  is a variable containing the sub-group identifier
               (usually 1, 2, 3, ...);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    U CHART Y1 Y2 X
    U CHART D A X
 
Note:
    The U chart and C chart are related to one another. The distinction
    is that the C chart is used when material being measured is
    constant in area and the sub-groups have equal size.  The U chart
    is used when either of these assumptions is not valid.
 
    If the area is constant but the sample size is unequal, simply use
    the sample size as the <area> variable.  If the sample sizes are
    equal but the areas vary, use the area without modification as the
    <area> variable.  If both the area and sample size vary, use the
    product of the sample size and area as the <area> variable.

Note:
    The attributes of the 4 traces that make up the C control chart are
    controlled by the standard LINES, CHARACTERS, SPIKES, and BAR
    commands.  Trace 1 is the response variable, trace 2 is the mean
    line, and traces 3 and 4 are the upper and lower control limits.
    Some analysts prefer to draw the response variable as a character
    or spike rather than a connected line.
 
Default:
    None
 
Synonyms:
    U CHART for U CONTROL CHART
 
Related Commands:
    C CHART             = Generates a C control chart.
    P CHART             = Generates a P control chart.
    NP CHART            = Generates an Np control chart.
    XBAR CHART          = Generates an xbar control chart.
    R CHART             = Generates a range control chart.
    S CHART             = Generates a standard deviation control chart.
 
    CHARACTERS          = Sets the types for plot characters.
    LINES               = Sets the types for plot lines.
    SPIKES              = Sets the on/off switches for plot spikes.
    BARS                = Sets the on/off switches for plot bars.
    PLOT                = Generates a data or function plot.
    LAG PLOT            = Generates a lag plot.
    4-PLOT              = Generates a 4-plot for univariate analysis.
    ANOP PLOT           = Generates an ANOP plot.
 
Reference:
    "Guide to Quality Control", Karou Ishikawa, Asian Productivity
    Organization, 1982 (Chapter 8).
 
Applications:
    Quality Control
 
Implementation Date:
    88/2
 
Program:
    SKIP 25
    READ CCU.DAT X NUMDEF SIZE
    .
    LINES SOLID SOLID DOT DOT
    XLIMITS 0 20
    XTIC OFFSET 0 1
    YTIC OFFSET 1
    .
    TITLE AUTOMATIC
    Y1LABEL NORMALIZED NUMBER OF DEFECTIVES
    XLABEL SAMPLE ID
    U CHART NUMDEF  SIZE X
 
-----ULTRASPH (LET)--------------------------------
 
ULTRASPH
 
Name:
    ULTRASPH (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the ultraspherical (or Gegenbauer) polynomial of order N.
 
Description:
    From Abramowitz and Stegum (see Reference below), a system of
    nth degree polynomials f(x,n) is called orthogonal on the
    interval a<=x<=b with respect to a weight function w(x) if it
    satisfies the equation:
        INTEGRAL[w(x)*f(x,n)*f(x,m)]dx = 0   m<>n, (m,n = 0, 1, 2, ...

    Ultraspherical polynomials use the weight function
    (1-x**2)**(alpha-1/2) and are orthogonal for -1<=x<=1.
    Ultraspherical polynomials can also be defined by the following
    equation:
        Cn,alpha(x) = K*
                 [n/2]
                  SUM[(-1)**m*(2*x)**(n-2m)*G(alpha+n+m)/(m!*(n-2m)!)]
                  m=0
    where K = (1/G(alpha)), G is the gamma function (see the
    documentation for the GAMMA command for details), and [] signifies
    the integer portion, and alpha is a shape parameter.

    Dataplot uses the following recurrence relation to compute the
    ultraspherical polynomial:
       Cn,alpha(x) = Pn(x,alpha-1/2,alpha-1/2)*
               [G(alpha+1/2)*G(2*alpha+n)/(G(2*alpha)*G(alpha+n+1/2))]
    where Pn is the Jacobi polynomial (see the documentation for the
    JACOBI command for details) and G is the gamma function.  Dataplot
    uses ACM algorithm 332 with suggestions given in Remark on
    Algorithm 332 (see Reference section below) to calculate the
    Jacobi polynomials.  This algorithm calculates Jacobi polynomials
    for orders 0 to 25.  Therefore, the ultraspherical polynomials
    are also restricted to orders 0 to 25.
 
Syntax:
    LET <y> = ULTRASPH(<x>,<n>,<a>)
                                   <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable in the range (-1,1);
          <n> is a non-negative integer number, parameter, or variable
              that specifies the order of the ultraspherical
              polynomial;
          <a> is a number, parameter, or variable that specifies the
              shape parameter;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed Laguerre polynomial value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ULTRASPH(0.5,4,2.5)
    LET X2 = ULTRASPH(X1,10,0.5)
    LET X2 = ULTRASPH(X1,N,A)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHEBT    = Compute the Chebychev polynomial first kind, order N.
    CHEBU    = Compute the Chebychev polynomial second kind, order N.
    HERMITE  = Compute the Hermite polynomial of order N.
    JACOBIP  = Compute the Jacobi polynomial of order N.
    LAGUERRE = Compute the Laguerre polynomial of order N.
    LEGENDRE = Compute the Legendre polynomial of order N.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 22).

    "Algorithm 332: Jacobi Polynomials", Witte, Communication of the
    ACM, Vol. 11. June, 1968 (page 436).

    "Remark On Algorithm 332", Skivgaard, Communication of the ACM,
    Vol. 18, February, 1975 (pp. 116-117).

Applications:
    Mathematics
 
Implementation Date:
    95/7
 
Program:
    TITLE SIZE 3
    TITLE CASE ASIS; LABEL CASE ASIS; LINE SOLID DASH DOT DASH2
    TITLE Ultraspherical (or Gegenbauer) polynomials (order 1 thru 5)
    Y1LABEL Cn(X,alpha)
    X1LABEL X
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    LET ALPHA = 0.5
    X2LABEL Alpha = ^ALPHA
    PLOT ULTRASPH(X,1,^ALPHA) FOR X = -0.9 .01 0.9 AND
    PLOT ULTRASPH(X,2,^ALPHA) FOR X = -0.9 .01 0.9 AND
    PLOT ULTRASPH(X,3,^ALPHA) FOR X = -0.9 .01 0.9 AND
    PLOT ULTRASPH(X,4,^ALPHA) FOR X = -0.9 .01 0.9 AND
    PLOT ULTRASPH(X,5,^ALPHA) FOR X = -0.9 .01 0.9
    .
    LET ALPHA = 1
    X2LABEL Alpha = ^ALPHA
    PLOT ULTRASPH(X,1,^ALPHA) FOR X = -0.9 .01 0.9 AND
    PLOT ULTRASPH(X,2,^ALPHA) FOR X = -0.9 .01 0.9 AND
    PLOT ULTRASPH(X,3,^ALPHA) FOR X = -0.9 .01 0.9 AND
    PLOT ULTRASPH(X,4,^ALPHA) FOR X = -0.9 .01 0.9 AND
    PLOT ULTRASPH(X,5,^ALPHA) FOR X = -0.9 .01 0.9
    .
    LET ALPHA = 2
    X2LABEL Alpha = ^ALPHA
    PLOT ULTRASPH(X,1,^ALPHA) FOR X = -0.9 .01 0.9 AND
    PLOT ULTRASPH(X,2,^ALPHA) FOR X = -0.9 .01 0.9 AND
    PLOT ULTRASPH(X,3,^ALPHA) FOR X = -0.9 .01 0.9 AND
    PLOT ULTRASPH(X,4,^ALPHA) FOR X = -0.9 .01 0.9 AND
    PLOT ULTRASPH(X,5,^ALPHA) FOR X = -0.9 .01 0.9
    .
    LET ALPHA = 5
    X2LABEL Alpha = ^ALPHA
    PLOT ULTRASPH(X,1,^ALPHA) FOR X = -0.9 .01 0.9 AND
    PLOT ULTRASPH(X,2,^ALPHA) FOR X = -0.9 .01 0.9 AND
    PLOT ULTRASPH(X,3,^ALPHA) FOR X = -0.9 .01 0.9 AND
    PLOT ULTRASPH(X,4,^ALPHA) FOR X = -0.9 .01 0.9 AND
    PLOT ULTRASPH(X,5,^ALPHA) FOR X = -0.9 .01 0.9
    .
    END OF MULTIPLOT
 
-----UNICDF (LET)--------------------------------
 
UNICDF
 
Name:
    UNICDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard uniform cumulative distribution function.
 
Description:
    The standard uniform distribution has the following probability
    density function:
       f(x) = 1            for 0 <= x <= 1
    The cumulative distribution is the area from negative infinity to x
    (i.e., the integral of the above function).  It has the formula:
       F(x) = x            for 0 <= x <= 1
 
Syntax:
    LET <y2> = UNICDF(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, a number, or a parameter containing
              values between 0 and 1;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed uniform cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = UNICDF(3)
    LET X2 = UNICDF(X1)
 
Note:
    The general uniform distribution has the following probability
    density function:
       f(x) = 1/(2h)         for a-h <= x <= a+h
    where a and h are the location and scale parameters respectively.
    The general uniform cumulative distribution has the formula:
       F(x) = (x-a-h)/(2h)   for a-h <= x <= a+h
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    UNIPDF = Compute the uniform probability density function.
    UNIPPF = Compute the uniform percent point function.
    UNISF  = Compute the uniform sparsity function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    SEMCDF = Compute the semi-circular cumulative distribution
             function.
    SEMPDF = Compute the semi-circular probability density function.
    SEMPPF = Compute the semi-circular percent point function.
 
Reference:
    "Continuous Univariate Distributions - 2", Johnson and Kotz,
    Houghton Mifflin, 1970 (chapter 25).
 
Applications:
    XX
 
Implementation Date:
    94/4
 
Program:
    YLIMITS 0 1
    MAJOR YTIC NUMBER 6
    MINOR YTIC NUMBER 1
    YTIC DECIMAL 1
    XLIMITS 0 1
    XTIC OFFSET 0.05 0.05
    TITLE AUTOMATIC
    PLOT UNICDF(X) FOR X = 0 0.01 1
 
-----UNICHAZ (LET)--------------------------------
 
UNICHAZ
 
Name:
    UNICHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard uniform cumulative hazard function.
 
Description:
    The standard uniform distribution has the following cumulative
    hazard function:
       H(x) = -log(1-x)            for 0 <= x < 1

Syntax:
    LET <y2> = UNICHAZ(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, a number, or a parameter containing
              values between 0 and 1;
          <y2> is a variable or a parameter (depending on what <y1>
               is) where the computed uniform cumulative hazard
               value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = UNICHAZ(0.7)
    LET X2 = UNICHAZ(X1)
 
Note:
    The general uniform distribution has the following hazard
    function:
       H(x) = -log((b-x)/(b-a))    for a <= x < b
    where a and b are the lower and upper limits of the uniform
    distribution.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    UNICDF = Compute the uniform cumulative distribution function.
    UNIHAZ = Compute the uniform hazard function.
    UNIPDF = Compute the uniform probability density function.
    UNIPPF = Compute the uniform percent point function.
    UNISF  = Compute the uniform sparsity function.
 
Reference:
    "Statistical Distributions, 2nd. Ed.", Evans, Hastings, and
    Peacock, John Wiley and Sons, 1993.
 
Applications:
    Reliability
 
Implementation Date:
    1998/5
 
Program:
    XLIMITS 0 1
    XTIC OFFSET 0.05 0.05
    TITLE AUTOMATIC
    PLOT UNICHAZ(X) FOR X = 0 0.01 0.99
 
-----UNIHAZ (LET)--------------------------------
 
UNIHAZ
 
Name:
    UNIHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard uniform hazard function.
 
Description:
    The standard uniform distribution has the following hazard
    function:
       h(x) = 1/(1-x)            for 0 <= x < 1
 
Syntax:
    LET <y2> = UNIHAZ(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, a number, or a parameter containing
              values between 0 and 1;
          <y2> is a variable or a parameter (depending on what <y1>
               is) where the computed uniform hazard value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = UNIHAZ(0.7)
    LET X2 = UNIHAZ(X1)
 
Note:
    The general uniform distribution has the following hazard
    function:
       h(x) = 1/(b - x)         for a <= x < b
    where a and b are the lower and upper limits of the uniform
    distribution.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    UNICDF  = Compute the uniform cumulative distribution function.
    UNICHAZ = Compute the uniform cumulative hazard function.
    UNIPDF  = Compute the uniform probability density function.
    UNIPPF  = Compute the uniform percent point function.
    UNISF   = Compute the uniform sparsity function.
 
Reference:
    "Statistical Distributions, 2nd. Ed.", Evans, Hastings, and
    Peacock, John Wiley and Sons, 1993.
 
Applications:
    Reliability
 
Implementation Date:
    1998/5
 
Program:
    XLIMITS 0 1
    XTIC OFFSET 0.05 0.05
    TITLE AUTOMATIC
    PLOT UNIHAZ(X) FOR X = 0 0.01 0.99
 
-----UNIFORM CHISQUARE (LET)-----------------------------------------
 
UNIFORM CHISQUARE
 
Name:
    UNIFORM CHISQUARE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Given a vector of counts, compute the difference from uniformity
    based on the chi-square statistic.
 
Description:
    In spatial analysis, it is sometimes desired to determine if the
    points in the given space are consistent with a uniform
    distribution.  One such measure is based on the chi-square statistic
    which is defined as

        CHISQ = SUM[i=1 to k][X(i) - EXP)**2/EXP]

    where

        EXP = SUM[i=1 to k][X(i)]/k

Syntax:
    LET <a> = UNIFORM CHISQUARE <y>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <a> is a parameter where the computed statistic is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = UNIFORM CHISQUARE Y1
    LET A = UNIFORM CHISQUARE Y1  SUBSET TAG > 2

Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    UNIFORM CHI SQUARE
 
Related Commands:
    VARIATIONAL DISTANCE       = Compute the variational distance of
                                 a variable containing a set of counts.
    RELATIVE DISPERSION INDEX  = Compute the relative dispersion index of
                                 a variable containing a set of counts.
    GOODNESS OF FIT            = Perform a goodness of fit test.
 
Reference:
    Kashiwagi, Fagan, Douglas, Yamamoto, Heckert, Leigh, Obrzut, Du, Lin-Gibson,
    Mu, Winey, Haggennueller (2007), "Relationship between dispersion metric and
    properties of PMMA/SWNT nanocomposites", Polymer Journal, Vol. 48,
    pp. 4855 - 4866.

Applications:
    Spatial Statistics
 
Implementation Date:
    2014/3
 
Program:
    LET Y  = UNIFORM RANDOM NUMBERS FOR I = 1 1 1000
    LET Y1 X1 = BINNED Y
    LET Y  = NORMAL RANDOM NUMBERS FOR I = 1 1 1000
    LET Y2 X2 = BINNED Y
    LET Y  = EXPONENTIAL RANDOM NUMBERS FOR I = 1 1 1000
    LET Y3 X3 = BINNED Y
    LET A1 = UNIFORM CHISQUARE Y1
    LET A2 = UNIFORM CHISQUARE Y2
    LET A3 = UNIFORM CHISQUARE Y3
    SET WRITE DECIMALS 4
    PRINT A1 A2 A3
 
-----UNIFORM ORDER STATISTICS MEDIANS (LET)--------------------------
 
UNIFORM ORDER STATISTICS MEDIANS

    Enter HELP ORDER STATISTICS MEDIANS.  The order statistics
    medians can be generated for the normal, uniform, half-normal,
    extreme value type I, extreme value type II, and Weibull 
    distributions.
 
-----UNIPDF (LET)--------------------------------
 
UNIPDF
 
Name:
    UNIPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard uniform probability density function.
 
Description:
    The standard uniform distribution has the following probability
    density function:
       f(x) = 1            for 0 <= x <= 1
    This distribution has a mean of 0.5 and a standard deviation of
    1/(2sqrt(3)).
 
Syntax:
    LET <y2> = UNIPDF(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, a number, or a parameter containing
              values between 0 and 1;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed uniform pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = UNIPDF(3)
    LET X2 = UNIPDF(X1)
 
Note:
    The general uniform distribution has the following probability
    density function:
       f(x) = 1/(2h)         for a-h <= x <= a+h
    where a and h are the location and scale parameters respectively
    (h is 1/2 and a is 0.5 for the standard uniform distribution).
    This distribution has a mean of a and a standard deviation of
    h/sqrt(3).
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    UNICDF = Compute the uniform cumulative distribution function.
    UNIPPF = Compute the uniform percent point function.
    UNISF  = Compute the uniform sparsity function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    SEMCDF = Compute the semi-circular cumulative distribution
             function.
    SEMPDF = Compute the semi-circular probability density function.
    SEMPPF = Compute the semi-circular percent point function.
 
Reference:
    "Continuous Univariate Distributions - 2", Johnson and Kotz,
    Houghton Mifflin, 1970 (chapter 25).
 
Applications:
    XX
 
Implementation Date:
    94/4
 
Program:
    XLIMITS 0 1
    XTIC OFFSET 0.05 0.05
    TITLE AUTOMATIC
    PLOT UNIPDF(X) FOR X = 0 0.01 1
 
-----UNIPPF (LET)--------------------------------
 
UNIPPF
 
Name:
    UNIPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard uniform percent point function.
 
Description:
    The standard uniform distribution has the following probability
    density function:
       f(x) = 1            for 0 <= x <= 1
 
    The percent point function is the inverse of the cumulative
    distribution function.  The cumulative distribution sums the
    probability from 0 to the given x value (i.e., the integral of the
    above function).  The percent point function takes a cumulative
    probability value and computes the corresponding x value.  It has
    the formula:
       G(p) = p
    The input value is a real number between 0 and 1 (since it
    corresponds to a probability).  The output value can be any real
    number.
 
Syntax:
    LET <y2> = UNIPPF(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter in the range 0 to 1;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed uniform ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = UNIPPF(0.9)
    LET X2 = UNIPPF(X1)
 
Note:
    The general uniform distribution has the following probability
    density function:
       f(x) = 1/(2h)         for a-h <= x <= a+h
    where a and h are the location and scale parameters respectively
    (h is 1/2 and a is 0.5 for the standard uniform distribution).
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    UNICDF = Compute the uniform cumulative distribution function.
    UNIPDF = Compute the uniform probability density function.
    UNISF  = Compute the uniform sparsity function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    SEMCDF = Compute the semi-circular cumulative distribution
             function.
    SEMPDF = Compute the semi-circular probability density function.
    SEMPPF = Compute the semi-circular percent point function.
 
Reference:
    "Continuous Univariate Distributions - 2", Johnson and Kotz,
    Houghton Mifflin, 1970 (chapter 25).
 
Applications:
    Distributional Modeling
 
Implementation Date:
    94/4
 
Program:
    XLIMITS 0 1
    MAJOR XTIC NUMBER 6
    MINOR XTIC NUMBER 1
    XTIC DECIMAL 1
    YLIMITS 0 1
    YTIC OFFSET 0.05 0.05
    TITLE AUTOMATIC
    PLOT UNIPPF(X) FOR X = 0.01 .01 0.99
 
-----UNIQUE (LET)---------------------------------------------------
 
UNIQUE
 
Name:
    UNIQUE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the number of distinct values in a variable.
 
Description:
    This command is the equivalent of

         LET YD = DISTINCT Y
         LET ND = SIZE YD

    However, in some cases you may just need the number of distinct
    values, not the values themselves.  This is the case where the
    UNIQUE command is useful.
 
Syntax:
    LET <par> = UNIQUE <y>  <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the number of distinct values
              is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET NBATCH = UNIQUE BATCH
 
Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

    The UNIQUE command is not typically used in the context of these
    other commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SIZE           = Compute the number of elements in a variable.
    DISTINCT       = Extract the distinct values from a variable.
 
Applications:
    Data Management
 
Implementation Date:
    2011/7
 
Program:
    SKIP 25
    READ GEAR.DAT Y X
    LET ND = UNIQUE X
    XLIMITS 1 ND
    MAJOR XTIC MARK NUMBER ND
    MINOR XTIC MARK NUMBER 0
    TIC MARK OFFSET UNITS DATA
    XTIC MARK OFFSET 0.5 0.5
    Y1LABEL Mean
    X1LABEL Batch
    LABEL CASE ASIS
    MEAN PLOT Y X
 
-----UNISF (LET)--------------------------------
 
UNISF
 
Name:
    UNISF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard uniform sparsity function.
 
Description:
    The standard uniform distribution has the following probability
    density function:
       f(x) = 1            for 0 <= x <= 1
 
    The sparsity function is the derivative of the percent point
    function, which is the inverse of the cumulative distribution
    function.  The cumulative distribution sums the probability from 0
    to the given x value (i.e., the integral of the
    above function).  The percent point function takes a cumulative
    probability value and computes the corresponding x value.  The
    sparsity function has the formula:
       sf(p) = 1
    The input value is a real number between 0 and 1 (since it
    corresponds to a probability).  The output value can be any real
    number.
 
Syntax:
    LET <y2> = UNISF(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter in the range 0 to 1;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed uniform ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = UNISF(0.9)
    LET X2 = UNISF(X1)
 
Note:
    The general uniform distribution has the following probability
    density function:
       f(x) = 1/(2h)         for a-h <= x <= a+h
    where a and h are the location and scale parameters respectively
    (h is 1/2 and a is 0.5 for the standard uniform distribution).
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    UNICDF = Compute the uniform cumulative distribution function.
    UNIPDF = Compute the uniform probability density function.
    UNIPPF = Compute the uniform percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    SEMCDF = Compute the semi-circular cumulative distribution
             function.
    SEMPDF = Compute the semi-circular probability density function.
    SEMPPF = Compute the semi-circular percent point function.
 
Reference:
    "Continuous Univariate Distributions - 2", Johnson and Kotz,
    Houghton Mifflin, 1970 (chapter 25).
 
Applications:
    Distributional Modeling
 
Implementation Date:
    94/4
 
Program:
    XLIMITS 0 1
    MAJOR XTIC NUMBER 6
    MINOR XTIC NUMBER 1
    XTIC DECIMAL 1
    TITLE AUTOMATIC
    PLOT UNISF(X) FOR X = 0.01 .01 0.99
 
-----UNSTACK-------------------------------------------------------
 
UNSTACK
 
Name:
    UNSTACK
 
Type:
    LET Subcommand
 
Purpose:
    Given a response variable and an associated group-id variable,
    create a separate response variable corresponding to each unique
    value of the group-id variable.
 
Description:
    Many commands in Dataplot expect the data to be in the form of a
    single response variable and a group-id variable (e.g., BOX PLOT,
    MEAN PLOT, SD PLOT, TABULATE).  Therefore it is common for data
    to be created in this form for usage in Dataplot.

    However, there may be occasions where it is more convenient to work
    with the data were the data for each group is in a separate response
    variable.  This command performs this conversion.

    Currently, group-id variables with up to 99 distinct values are
    supported (if the group-id variable has more than 99 distinct values,
    an error message will be generated).

    This command is the reverse of the STACK command which converts from
    the multi-column form to the single response variable with group-id
    variable form.

Syntax:
    LET <z> = UNSTACK <y> <x>    <SUBSET/EXPCEPT/FOR qualification>
    where <y> is a response variable;
          <x> is a group-id variable;
          <z> is the base name for the generated response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    The <z> is the base name for the new response variables.  So if
    Z is the base name and there are five distinct values in the group-id
    variable, this command will generate the new response variables Z1,
    Z2, Z3, Z4 and Z5.  The Z variable will contain the distinct values
    of the group-id variable.
 
Examples:
    LET Z = UNSTACK Y X
    LET Z = UNSTACK Y X  SUBSET X > 2
 
Note:
    The distinct values of the group-id variable are sorted.  For example,
    if the group-id variable contains the distinct values 2, 6, and 8 and
    Z is the base name, the response variable Z1 will contain the response
    values associated with 2, Z2 will contain the response values
    associated with 6 and Z3 will contain the response values associated
    with 8.  This will be the case regardless of how the original response
    and group-id variables are ordered.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    STACK         = Convert a response variable and an associated
                    group-id variable to multiple response variables.
 
Applications:
    Data Management
 
Implementation Date:
    2016/09
 
Program:
    dimension 100 columns
    skip 25
    read gear.dat y x
    .
    let z = unstack y x
    set write decimals 4
    print z1 z2 z3 z4 z5 z6 z7 z8 z9 z10
    print z

-----UPPER CASE-----------------------------------------------------
 
UPPER CASE
 
Name:
    UPPER CASE
 
Type:
    Let Subcommand
 
Purpose:
    Convert a string to all upper case characters.
 
Syntax:
    LET <sout> = UPPER CASE  <sorg>
    where <sout> is the resulting all upper case string;
    and   <sorg> is the name of the original string.
 
Examples:
    LET SOUT = UPPER CASE S1
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LOWER CASE          = Convert a string to lower case.
    LET FUNCTION        = Defines a function.
    LET STRING          = Defines a string.
    READ STRING         = Reads a string from a file.
    SUBSTITUTE CHARACTE = Substitute the value of a string or parameter.
    &                   = Concatenate two strings.
    SUBTRING            = Extract a substring from an existing string.
    STRING INDEX        = Extract the start/stop positions of a substring
                          within a string.
    STRING CONCATENATE  = Concatenate one or more previously defined
                          strings.
    STRING EDIT         = Edit a string.
    STRING MERGE        = Insert a string into another string without
                          overwrite.
    STRING REPLACE      = Insert a string into another string with
                          overwrite.
    STRING LENGTH       = Return the length of a string.
    CHARACTER           = Convert numeric values to strings based on
                          the ASCII collating sequence.
    ICHAR               = Convert a string to numeric values based on
                          the ASCII collating sequence.
    GROUP LABEL         = Define the text for group labels.
 
Applications:
    Data Management
 
Implementation Date:
    11/2008
 
Program:
    LET STRING S1 = file23.dat
    LET SOUT = UPPER CASE S1

    The resulting string is FILE23.DAT.

-----UPPER HINGE (LET)-------------------------------------------
 
UPPER HINGE
 
Name:
    UPPER HINGE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the upper hinge of a variable.
 
Description:
    The upper hinge is a pseudo-75% point of a sample (see Tukey,
    EDA).  Specifically, it is the median of the points between the
    median and the maximum point.
 
Syntax:
    LET <par> = UPPER HINGE <x1> <SUBSET/EXCEPT/FOR qualification>
    where <x1> is the variable for which the upper hinge is to be
               computed;
          <par> is a parameter where the computed upper hinge is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET UH = UPPER HINGE Y1
    LET UH = UPPER HINGE Y1 SUBSET TAG > 2
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    UPPER HINGE PLOT    = Generates an upper hinge (vs subsample) plot.
    UPPER QUARTILE      = Compute the upper quartile of a variable.
    LOWER HINGE         = Compute the lower hinge of a variable.
    LOWER QUARTILE      = Compute the lower quartile of a variable.
    MEAN                = Compute the mean of a variable.
    STANDARD DEVIATION  = Compute the standard deviation of a variable.
 
Reference:
    "Exploratory Data Analysis", John Tukey, Addison-Wesley, 1977.
 
Applications:
    Exploratory Data Analysis
 
Implementation Date:
    XX
 
Program:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 1000
    LET HINGE = UPPER HINGE Y1
 
-----UPPER HINGE PLOT--------------------------------------------
 
UPPER HINGE PLOT
 
Name:
    UPPER HINGE PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates an upper hinge plot.
 
Description:
    An upper hinge plot is a plot consisting of subsample upper hinge
    versus subsample index.  The subsample upper hinge is the a
    pseudo-75% point of the subsample (see Tukey, EDA).  The upper
    hinge plot is used to answer the question-- "Does the subsample
    variation change over different subsamples?".  It consists of:
       Vertical   axis = subsample upper hinge;
       Horizontal axis = subsample index.
    The upper hinge plot yields 2 traces:
       1. a subsample upper hinge trace; and
       2. a full-sample upper hinge reference line.
    Like usual, the appearance of these 2 traces is
    controlled by the first 2 settings of the LINES,
    CHARACTERS, SPIKES, BARS, and similar attributes.
 
Syntax:
    UPPER HINGE PLOT  <y>  <x>  <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response (= dependent) variable;
          <x> is the subsample identifier variable (this variable
              appears on the horizontal axis);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    UPPER HINGE PLOT Y X
    UPPER HINGE PLOT Y X1
 
Default:
    None
 
Synonyms:
    UH PLOT
 
Related Commands:
    CHARACTERS              = Sets the type for plot characters.
    LINES                   = Sets the type for plot lines.
    UPPER HINGE  PLOT       = Generates a upper hinge plot.
    LOWER QUARTILE  PLOT    = Generates a lower quartile plot.
    UPPER QUARTILE  PLOT    = Generates a upper quartile plot.
    MINIMUM  PLOT           = Generates a minimum plot.
    MAXIMUM  PLOT           = Generates a maximum plot.
    RANGE  PLOT             = Generates a range plot.
    FIRST DECILE  PLOT      = Generates a first decile plot.
    SECOND DECILE  PLOT     = Generates a second decile plot.
    NINTH DECILE  PLOT      = Generates a ninth decile plot.
    STANDARD DEVIATION PLOT = Generates a standard deviation
                              plot.
    VARIANCE  PLOT          = Generates a variance plot.
    MEAN PLOT               = Generates a mean plot.
    MEDIAN PLOT             = Generates a median plot.
    BOX PLOT                = Generates a box plot.
    S CHART                 = Generates a standard deviation
                              control chart.
    PLOT                    = Generates a data or function plot.
 
Applications:
    Quality Control
 
Implementation Date:
    88/2
 
Program:
    LET Y = DATA 2 4 6 11 12 21 25 28 29
    LET X = DATA 1 1 1 2 2 3 3 3 3
    UPPER HINGE PLOT Y X
 
-----UPPER QUARTILE (LET)--------------------------------------------
 
UPPER QUARTILE
 
Name:
    UPPER QUARTILE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the upper quartile of a variable.
 
Description:
    The upper quartile is the 75% point of a sample.
 
Syntax:
    LET <par> = UPPER QUARTILE <x1> <SUBSET/EXCEPT/FOR qualification>
    where <x1> is the variable for which the upper quartile is to be
              computed;
          <par> is a parameter where the computed upper quartile is
              saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET UQ = UPPER QUARTILE Y1
    LET UQ = UPPER QUARTILE Y1  SUBSET TAG = 2
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    UPPER QUARTILE PLOT  = Generates an upper quartile (vs subsample)
                           plot.
    UPPER HINGE          = Compute the upper hinge of a variable.
    LOWER HINGE          = Compute the lower hinge of a variable.
    LOWER QUARTILE       = Compute the lower quartile of a variable.
    MEAN                 = Compute the mean of a variable.
    STANDARD DEVIATION   = Compute the standard deviation of a
                           variable.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 1000
    LET QUARTILE = UPPER QUARTILE Y1
 
-----UPPER QUARTILE PLOT-----------------------------------------
 
UPPER QUARTILE PLOT
 
Name:
    UPPER QUARTILE PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates an upper quartile plot.
 
Description:
    An upper quartile plot is a plot consisting of subsample upper
    quartile versus subsample index.  The subsample upper quartile is
    the estimated 75% point of the subsample.  The upper quartile plot
    is used to answer the question--"Does the subsample variation
    change over different subsamples?".  It consists of:
       Vertical   axis = subsample upper quartile;
       Horizontal axis = subsample index.
    The upper quartile plot yields 2 traces:
       1. a subsample upper quartile trace; and
       2. a full-sample upper quartile reference line.
    Like usual, the appearance of these 2 traces is
    controlled by the first 2 settings of the LINES,
    CHARACTERS, SPIKES, BARS, and similar attributes.
 
Syntax:
    UPPER QUARTILE PLOT <y> <x> <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response (= dependent) variable;
          <x> is the subsample identifier variable (this variable
              appears on the horizontal axis);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    UPPER QUARTILE PLOT Y X
    UPPER QUARTILE PLOT Y X1
 
Default:
    None
 
Synonyms:
    UQ PLOT
 
Related Commands:
    CHARACTERS              = Sets the type for plot characters.
    LINES                   = Sets the type for plot lines.
    LOWER QUARTILE  PLOT    = Generates a lower quartile plot.
    LOWER HINGE  PLOT       = Generates a lower hinge plot.
    UPPER HINGE  PLOT       = Generates a upper hinge plot.
    MINIMUM  PLOT           = Generates a minimum plot.
    MAXIMUM  PLOT           = Generates a maximum plot.
    RANGE  PLOT             = Generates a range plot.
    FIRST DECILE  PLOT      = Generates a first decile plot.
    SECOND DECILE  PLOT     = Generates a second decile plot.
    NINTH DECILE  PLOT      = Generates a ninth decile plot.
    STANDARD DEVIATION PLOT = Generates a standard deviation plot.
    VARIANCE  PLOT          = Generates a variance plot.
    MEAN PLOT               = Generates a mean plot.
    MEDIAN PLOT             = Generates a median plot.
    BOX PLOT                = Generates a box plot.
    S CHART                 = Generates a standard deviation control
                              chart.
    PLOT                    = Generates a data or function plot.
 
Applications:
    Quality Control
 
Implementation Date:
    88/2
 
Program:
    LET Y = DATA 2 4 6 11 12 21 25 28 29
    LET X = DATA 1 1 1 2 2 3 3 3 3
    UPPER QUARTILE PLOT Y X
 
-----UTSCDF (LET)--------------------------------
 
UTSCDF
 
Name:
    UTSCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the uneven two-sided power cumulative distribution
    function.
 
Description:
    The uneven two-sided power distribution has the following
    cumulative distribution function:

    F(x,a,b,d,n1,n3,alpha) = 0         x < a

                             = [alpha*(b-a)*n3/
                               (alpha*(b-a)*n3+(d-b)*n1)]
                               *((x-a)/(b-a))**n1
                               a <= x <  b

                             = 1 - [(d-b)*n1/
                               (alpha*(b-a)*n3+(d-b)*n1)]
                               *((d-x)/(d-b))**n3
                               b <= x <  d

                             = 1          x >= d
    where

           a <= b <= d; n1, n3, alpha > 0

    The case where a = 0 and d = 1 is referred to as the
    standard uneven two-sided power distribution.  The
    a and b parameters are lower and upper limit parameters.
    These are related to location and scale parameters as
    follows

        loc   = a
        scale = d - a

    Kotz and Van Dorp show that the standard uneven two-sided
    power cumulative distribution can also be given as

    F(x,theta,n1,n3,pi1) = pi1*(x/theta)**n1      0 <= x < theta


                         = 1 - (1 - pi1)*((1-x)/(1-theta))**n3
                           theta <= x < 1

    where

        theta = b
        pi1   = alpha*theta*n3/(alpha*theta*n3 + (1-theta)*n1)
              = theta*alpha*n3/(theta*(alpha*n3 -n1) + n1)
        0 <= pi1 <= 1

    Kotz and Van Dorp use this form to derive some of the 
    properties of this distribution.

    The unveven two-sided power distribution is a generalization
    of the two-sided power distribution.  It is also related
    to the generalized trapezoidal distribution (the center
    part of the generalized trapezoid distribution shrinks to
    a single point).  See Van Dorp and Kotz for details.
 
    The special case where alpha = 1 is referred to as the
    generalized two-sided power distribution.

Syntax:
    LET <y> = UTSCDF(<x>,<a>,<b>,<d>,<n1>,<n3>,<alpha>)
                             <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter containing values in
              the interval (a,d);
          <a> is a number, parameter, or variable that specifies the
              first shape parameter;
          <b> is a number, parameter, or variable that specifies the
              second shape parameter;
          <d> is a number, parameter, or variable that specifies the
              third shape parameter;
          <n1> is a number, parameter, or variable that specifies the
              fourth shape parameter;
          <n3> is a number, parameter, or variable that specifies the
              fifth shape parameter;
          <alpha> is a number, parameter, or variable that specifies
              the sixth shape parameter;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = UTSCDF(0.65,0,0.2,1,2,2,0.5)
    LET Y = UTSCDF(X,0,0.8,1,2,2,0.5)
    LET Y = UTSCDF(X,A,B,D,N1,N3,ALPHA)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    UTSPDF = Compute the uneven two-sided power probability
             density function.
    UTSPPF = Compute the uneven two-sided power percent point
             function.
    TSPPDF = Compute the two-sided power probability density
             function.
    POWPDF = Compute the power probability density function.
    GTRPDF = Compute the generalized trapezoidal probability
             density function.
    TRAPDF = Compute the trapezoidal probability density function.
    TOPPDF = Compute the Topp and Leone probability density
             function.
    RGTPDF = Compute the reflected generalized Topp and Leone
             probability density function.
    TRIPDF = Compute the triangular probability density function.
    UNIPDF = Compute the uniform probability density function.
 
Reference:
    Kotz and Van Dorp (2004), "Beyond Beta: Other Continuous
    Families of Distributions with Bounded Support and
    Applications", World Scientific Publishing Company,
    Chapter 6.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    MULTIPLOT 2 2
    LET A = 0
    LET B = 0.4
    LET D = 1.0
    LET N1 = 2
    LET N3 = 0.5
    LET A2 = A - 0.01
    LET D2 = D - 0.01
    .
    LET ALPHA = 0.5
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSCDF(X,A,B,D,N1,N3,ALPHA) FOR X = A2 0.01 D2
    .
    LET ALPHA = 1.0
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSCDF(X,A,B,D,N1,N3,ALPHA) FOR X = A2 0.01 D2
    .
    LET ALPHA = 2.0
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSCDF(X,A,B,D,N1,N3,ALPHA) FOR X = A2 0.01 D2
    .
    LET ALPHA = 5.0
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSCDF(X,A,B,D,N1,N3,ALPHA) FOR X = A2 0.01 D2
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Uneven Two-Sided Power Cumulative Distribution Functions
    .
    MULTIPLOT 2 2
    LET N1 = 0.5
    LET N3 = 2
    .
    LET ALPHA = 0.5
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSCDF(X,A,B,D,N1,N3,ALPHA) FOR X = A2 0.01 D2
    .
    LET ALPHA = 1.0
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSCDF(X,A,B,D,N1,N3,ALPHA) FOR X = A2 0.01 D2
    .
    LET ALPHA = 2.0
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSCDF(X,A,B,D,N1,N3,ALPHA) FOR X = A2 0.01 D2
    .
    LET ALPHA = 5.0
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSCDF(X,A,B,D,N1,N3,ALPHA) FOR X = A2 0.01 D2
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Uneven Two-Sided Power Cumulative Distribution Functions
    .
    MULTIPLOT 2 2
    LET N1 = 2
    LET N3 = 2
    .
    LET ALPHA = 0.5
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSCDF(X,A,B,D,N1,N3,ALPHA) FOR X = A2 0.01 D2
    .
    LET ALPHA = 1.0
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSCDF(X,A,B,D,N1,N3,ALPHA) FOR X = A2 0.01 D2
    .
    LET ALPHA = 2.0
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSCDF(X,A,B,D,N1,N3,ALPHA) FOR X = A2 0.01 D2
    .
    LET ALPHA = 5.0
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSCDF(X,A,B,D,N1,N3,ALPHA) FOR X = A2 0.01 D2
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Uneven Two-Sided Power Cumulative Distribution Functions

-----UTSPDF (LET)--------------------------------
 
UTSPDF
 
Name:
    UTSPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the uneven two-sided power probability density
    function.
 
Description:
    The uneven two-sided power distribution has the following
    probability density function:

    f(x,a,b,d,n1,n3,alpha) = [alpha*n1*n3/
                               (alpha*(b-a)*n3+(d-b)*n1)]
                               *((x-a)/(b-a))**(n1-1)
                               a <= x <  b

                             = [n1*n3/(alpha*(b-a)*n3+(d-b)*n1)]
                               *((d-x)/(d-b))**(n3-1)
                               b <= x <  d

                             = 0                   x < a, x >= d
    where

           a <= b <= d, n1, n3, alpha > 0

    The parameters a and d are lower and upper limit
    parameters.  The b parameter is a threshold parameter
    (the distribution has a discontinuity at this point).
    The alpha parameter is referred to as a jump paramter
    (It controls the size of the discontinuity at x = b.
    If alpha = 1, there is no discontinuity at x = b).  The
    n1 and n3 parameters are shape parameters.

    The case where a = 0 and d = 1 is referred to as the
    standard uneven two-sided power distribution.  The
    a and d parameters are lower and upper limit parameters.
    These are related to location and scale parameters as
    follows

        loc   = a
        scale = d - a

    Kotz and Van Dorp show that the standard uneven two-sided
    power distribution can also be given as

    f(x,theta,n1,n3,pi1) = pi1*(n1/theta)*(x/theta)**(n1-1)
                           0 <= x < theta


                         = (1-pi1)*(n3/(1-theta))*
                           ((1-x)/(1-theta))**(n1-1)
                           theta <= x < 1

    where

        theta = b
        pi1   = alpha*theta*n3/(alpha*theta*n3 + (1-theta)*n1)
              = theta*alpha*n3/(theta*(alpha*n3 -n1) + n1)
        0 <= pi1 <= 1

    Kotz and Van Dorp use this form to derive some of the 
    properties of this distribution.

    The unveven two-sided power distribution is a generalization
    of the two-sided power distribution.  It is also related
    to the generalized trapezoidal distribution (the center
    part of the generalized trapezoid distribution shrinks to
    a single point).  See Van Dorp and Kotz for details.
 
    The special case where alpha = 1 is referred to as the
    generalized two-sided power distribution.

Syntax:
    LET <y> = UTSPDF(<x>,<a>,<b>,<d>,<n1>,<n3>,<alpha>)
                             <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter containing values in
              the interval (a,d);
          <a> is a number, parameter, or variable that specifies the
              first shape parameter;
          <b> is a number, parameter, or variable that specifies the
              second shape parameter;
          <d> is a number, parameter, or variable that specifies the
              third shape parameter;
          <n1> is a number, parameter, or variable that specifies the
              fourth shape parameter;
          <n3> is a number, parameter, or variable that specifies the
              fifth shape parameter;
          <alpha> is a number, parameter, or variable that specifies
              the sixth shape parameter;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = UTSPDF(0.65,0,0.2,1,2,2,0.5)
    LET Y = UTSPDF(X,0,0.8,1,2,2,0.5)
    LET Y = UTSPDF(X,A,B,D,N1,N3,ALPHA)
 
Note:
    Uneven two-sided power random numbers, probability plots,
    and goodness of fit tests can be generated with the commands:

       LET A = <value>
       LET B = <value>
       LET D = <value>
       LET N1 = <value>
       LET N3 = <value>
       LET ALPHA = <value>
       LET Y = UNEVEN TWO-SIDED POWER RANDOM NUMBERS FOR I = 1 1 N
       UNEVEN TWO-SIDED POWER PROBABILITY PLOT Y
       UNEVEN TWO-SIDED POWER PROBABILITY PLOT Y2 X2
       UNEVEN TWO-SIDED POWER PROBABILITY PLOT Y3 XLOW XHIGH
       UNEVEN TWO-SIDED POWER KOLMOGOROV SMIRNOV GOODNESS OF FIT Y
       UNEVEN TWO-SIDED POWER CHI-SQUARE GOODNESS OF FIT Y2 X2
       UNEVEN TWO-SIDED POWER CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    Note that

       A <= data minimum < B < data maximum <= D

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    UTSCDF = Compute the uneven two-sided power cumulative
             distribution function.
    UTSPPF = Compute the uneven two-sided power percent point
             function.
    TSPPDF = Compute the two-sided power probability density
             function.
    POWPDF = Compute the power probability density function.
    GTRPDF = Compute the generalized trapezoidal probability
             density function.
    TRAPDF = Compute the trapezoidal probability density function.
    TOPPDF = Compute the Topp and Leone probability density
             function.
    RGTPDF = Compute the reflected generalized Topp and Leone
             probability density function.
    TRIPDF = Compute the triangular probability density function.
    UNIPDF = Compute the uniform probability density function.
 
Reference:
    Kotz and Van Dorp (2004), "Beyond Beta: Other Continuous
    Families of Distributions with Bounded Support and
    Applications", World Scientific Publishing Company,
    Chapter 6.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    MULTIPLOT 2 2
    LET A = 0
    LET B = 0.4
    LET D = 1.0
    LET N1 = 2
    LET N3 = 0.5
    LET A2 = A - 0.01
    LET D2 = D - 0.01
    .
    LET ALPHA = 0.5
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSPDF(X,A,B,D,N1,N3,ALPHA) FOR X = A2 0.01 D2
    .
    LET ALPHA = 1.0
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSPDF(X,A,B,D,N1,N3,ALPHA) FOR X = A2 0.01 D2
    .
    LET ALPHA = 2.0
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSPDF(X,A,B,D,N1,N3,ALPHA) FOR X = A2 0.01 D2
    .
    LET ALPHA = 5.0
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSPDF(X,A,B,D,N1,N3,ALPHA) FOR X = A2 0.01 D2
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Uneven Two-Sided Power Probability Density Functions
    .
    MULTIPLOT 2 2
    LET N1 = 0.5
    LET N3 = 2
    .
    LET ALPHA = 0.5
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSPDF(X,A,B,D,N1,N3,ALPHA) FOR X = A2 0.01 D2
    .
    LET ALPHA = 1.0
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSPDF(X,A,B,D,N1,N3,ALPHA) FOR X = A2 0.01 D2
    .
    LET ALPHA = 2.0
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSPDF(X,A,B,D,N1,N3,ALPHA) FOR X = A2 0.01 D2
    .
    LET ALPHA = 5.0
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSPDF(X,A,B,D,N1,N3,ALPHA) FOR X = A2 0.01 D2
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Uneven Two-Sided Power Probability Density Functions
    .
    MULTIPLOT 2 2
    LET N1 = 2
    LET N3 = 2
    .
    LET ALPHA = 0.5
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSPDF(X,A,B,D,N1,N3,ALPHA) FOR X = A2 0.01 D2
    .
    LET ALPHA = 1.0
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSPDF(X,A,B,D,N1,N3,ALPHA) FOR X = A2 0.01 D2
    .
    LET ALPHA = 2.0
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSPDF(X,A,B,D,N1,N3,ALPHA) FOR X = A2 0.01 D2
    .
    LET ALPHA = 5.0
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSPDF(X,A,B,D,N1,N3,ALPHA) FOR X = A2 0.01 D2
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Uneven Two-Sided Power Probability Density Functions

-----UTSPPF (LET)--------------------------------
 
UTSPPF
 
Name:
    UTSPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the uneven two-sided power cumulative distribution
    function.
 
Description:
    The uneven two-sided power distribution has the following
    cumulative distribution function:

    G(x,a,b,d,n1,n3,alpha) = a + (b-a)*(p/(c1/c3))**(1/n1)
                               0 <= p < cutoff

                             = d - (d-b)*((1-p)/(c2/c3))**(1/n3)
                               cutoff <= p <= 1

    where

        a <= b <= d, n1, n3, alpha > 0
        c1     = alpha*(b-a)*n3
        c2     = (d-b)*n1
        c3     = alpha*(b-a)*n3 + (d-b)*n1
        cutoff = UTSCDF(b,a,b,d,n1,n3,alpha)

    The unveven two-sided power distribution is a generalization
    of the two-sided power distribution.  It is also related
    to the generalized trapezoidal distribution (the center
    part of the generalized trapezoid distribution shrinks to
    a single point).  See Van Dorp and Kotz for details.
 
    The special case where alpha = 1 is referred to as the
    generalized two-sided power distribution.
 
Syntax:
    LET <y> = UTSPPF(<p>,<a>,<b>,<d>,<n1>,<n3>,<alpha>)
                             <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, number, or parameter containing values in
              the interval (0,1);
          <a> is a number, parameter, or variable that specifies the
              first shape parameter;
          <b> is a number, parameter, or variable that specifies the
              second shape parameter;
          <d> is a number, parameter, or variable that specifies the
              third shape parameter;
          <n1> is a number, parameter, or variable that specifies the
              fourth shape parameter;
          <n3> is a number, parameter, or variable that specifies the
              fifth shape parameter;
          <alpha> is a number, parameter, or variable that specifies
              the sixth shape parameter;
          <y> is a variable or a parameter (depending on what <p> is)
              where the computed ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = UTSPPF(0.95,0,0.2,1,2,2,0.5)
    LET Y = UTSPPF(P,0,0.8,1,2,2,0.5)
    LET Y = UTSPPF(P,A,B,D,N1,N3,ALPHA)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    UTSCDF = Compute the uneven two-sided power cumulative
             distribution function.
    UTSPDF = Compute the uneven two-sided power probability
             density function.
    TSPPDF = Compute the two-sided power probability density
             function.
    POWPDF = Compute the power probability density function.
    GTRPDF = Compute the generalized trapezoidal probability
             density function.
    TRAPDF = Compute the trapezoidal probability density function.
    TOPPDF = Compute the Topp and Leone probability density
             function.
    RGTPDF = Compute the reflected generalized Topp and Leone
             probability density function.
    TRIPDF = Compute the triangular probability density function.
    UNIPDF = Compute the uniform probability density function.
 
Reference:
    Kotz and Van Dorp (2004), "Beyond Beta: Other Continuous
    Families of Distributions with Bounded Support and
    Applications", World Scientific Publishing Company,
    Chapter 6.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    MULTIPLOT 2 2
    LET A = 0
    LET B = 0.4
    LET D = 1.0
    LET N1 = 2
    LET N3 = 0.5
    .
    LET ALPHA = 0.5
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSPPF(P,A,B,D,N1,N3,ALPHA) FOR P = 0.01  0.01  0.99
    .
    LET ALPHA = 1.0
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSPPF(P,A,B,D,N1,N3,ALPHA) FOR P = 0.01  0.01  0.99
    .
    LET ALPHA = 2.0
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSPPF(P,A,B,D,N1,N3,ALPHA) FOR P = 0.01  0.01  0.99
    .
    LET ALPHA = 5.0
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSPPF(P,A,B,D,N1,N3,ALPHA) FOR P = 0.01  0.01  0.99
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Uneven Two-Sided Power Percent Point Functions
    .
    MULTIPLOT 2 2
    LET N1 = 0.5
    LET N3 = 2
    .
    LET ALPHA = 0.5
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSPPF(P,A,B,D,N1,N3,ALPHA) FOR P = 0.01  0.01  0.99
    .
    LET ALPHA = 1.0
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSPPF(P,A,B,D,N1,N3,ALPHA) FOR P = 0.01  0.01  0.99
    .
    LET ALPHA = 2.0
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSPPF(P,A,B,D,N1,N3,ALPHA) FOR P = 0.01  0.01  0.99
    .
    LET ALPHA = 5.0
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSPPF(P,A,B,D,N1,N3,ALPHA) FOR P = 0.01  0.01  0.99
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Uneven Two-Sided Power Percent Point Functions
    .
    MULTIPLOT 2 2
    LET N1 = 2
    LET N3 = 2
    .
    LET ALPHA = 0.5
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSPPF(P,A,B,D,N1,N3,ALPHA) FOR P = 0.01  0.01  0.99
    .
    LET ALPHA = 1.0
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSPPF(P,A,B,D,N1,N3,ALPHA) FOR P = 0.01  0.01  0.99
    LET ALPHA = 2.0
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSPPF(P,A,B,D,N1,N3,ALPHA) FOR P = 0.01  0.01  0.99
    .
    LET ALPHA = 5.0
    TITLE N1 = ^n1, N3 = ^n3, Alpha = ^alpha
    PLOT UTSPPF(P,A,B,D,N1,N3,ALPHA) FOR P = 0.01  0.01  0.99
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Uneven Two-Sided Power Percent Point Functions

-------------------------------------------------------------
 
 
 
 







































































-------------------------  *V*  ZZZZZ--------------------
 
-----VALUE COUNT (LET)---------------------------------------------------
 
VALUE COUNT
 
Name:
    VALUE COUNT (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the number of elements in a variable that are equal to a
    specified value.
 
Syntax:
    LET <par> = VALUE COUNT <x1>  <SUBSET/EXCEPT/FOR qualification>
    where <x1> is the variable for which the size is to be computed;
          <par> is a parameter where the size is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET XVALUE = 6
    LET NVAL = VALUE COUNT Y
 
Note:
    The value that is being checked is specified by entering the command

       LET XVALUE = <value>

    before entering the VALUE COUNT command.

Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

    Note that the VALUE COUNT statistic can also be computed using

         LET VALCNT = SIZE Y  SUBSET Y = VALUE

    However, the VALUE COUNT command becomes more convenient when used with
    these various statistics.  In particular, it is useful for obtaining
    counts with the various cross tabulation statistics.  This is
    demonstrated in the Program 2 example below.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SIZE           = Compute the number of elements in a vector.
 
Applications:
    Data Management
 
Implementation Date:
    2014/04
 
Program 1:
    let y = normal rand numb for i = 1 1 100
    let y2 = y
    let y2 =  3 subset y >  3
    let y2 = -3 subset y < -3
    .
    let xvalue = 3
    let nouth = value count y2
    let xvalue = -3
    let noutl = value count y2
    .
    set write decimals 3
    print nouth noutl

Program 2:
    skip 25
    read ripken.dat y x1 x2
    let yout = y
    let yout = -1 subset y < 0.2
    let yout =  1 subset y > 0.4
    .
    set let cross tabulate collapse
    let x1id  = cross tabulate group one   x1 x2
    let x2id  = cross tabulate group two   x1 x2
    let ycnt  = cross tabulate size x1 x2
    let xvalue = -1
    let ylow  = cross tabulate value count yout x1 x2
    let xvalue =  1
    let yhigh = cross tabulate value count yout x1 x2
    .
    set write decimals 0
    print ycnt ylow yhigh x1id x2id
 
-----VAN DER WAERDEN SCORE (LET)-----------------------------------------------
 
VAN DER WAERDEN SCORE
 
Name:
    VAN DER WAERDEN SCORE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the Van de Waerden scores of a variable.
 
Description:
    The Van der Waerden scores are defined as

        s(R(j)) = NORPPF(R(j)/(n+1))

    where R(j) is the rank of the j-th observation, n is the number of
    observations and NORPPF is the percent point function of the normal
    distribution.

    Van der Waerden scores are used in the VAN DER WAERDEN command to test
    whether k samples have equal location.  This test is an alternative to
    the Kruskal Wallis test.

Syntax:
    LET <s> = VAN DER WAERDEN SCORE <y>  <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <s> is a variable where the computed Van der Waerden scores are
              saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET VSCORE = VAN DER WAERDEN SCORE Y
 
Note:
    Ties are assigned an average rank.  For example, if the 2nd and 3rd
    highest values are equal, each is assigned a rank of 2.5.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    KRUSKAL WALLIS TEST     = Perform a Kruskal Wallis test for equal
                              locations.
    KLOTZ TEST              = Perform a Klotz test for equal variances.
    MEDIAN TEST             = Perform a median test.
    ANOVA                   = Perform a fixed effects analysis of variance.
    MOOD SCORES             = Generate mood scores.
    MEDIAN SCORES           = Generate median scores.
    KLOTZ SCORES            = Generate Klotz scores.
    SAVAGE SCORES           = Generate Savage scores.
    CONOVER SCORES          = Generate Conover scores.
    ANSARI BRADLEY SCORES   = Generate Ansari Bradley scores.
    PLACEMENT SCORES        = Generate placement scores.
    RANK                    = Generate the ranks of a variable. 
 
Reference:
    W. J. Conover, (1999).  "Practical Nonparameteric Statistics",
    Third Edition, Wiley, pp. 396-406.

Applications:
    Nonparametric statistics
 
Implementation Date:
    2023/06
 
Program:
    . Step 1:   Define the data
    .
    let y1 = data 16.55 15.36 15.94 16.43 16.01
    let y2 = data 16.05 15.98 16.10 15.88 15.91
    let n1 = size y1
    let n2 = size y2
    let n = n1 + n2
    .
    . Step 2:   Combine into single array
    .
    let y tag = stack y1 y2
    if n1 <= n2
       let tag = tag - 1
       let n1t = n1
    else
       let tag = 0 subset tag = 2
       let n1t = n2
    end of if
    .
    . Step 3:   Compute the Van der Waerden scores
    .
    let vscore = van der waerden scores y
    .
    . Step 4:   Two-Sample Linear Rank Test
    .
    let temp = tag*vscore
    let s = sum temp
    .
    let aval = sum ymood
    let smean = (n1t/n)*aval
    let meanrank = mean vscore
    let temp = (vscore - meanrank)**2
    let aval = sum temp
    let svar = ((n1*n2)/(n*(n-1)))*aval
    let statval = (s - smean)/sqrt(svar)
    let statval = round(statval,3)
    let cv = norppf(0.975)
    let upplim = round(cv,2)
    let lowlim = -upplim
    feedback off
    print "Two Sample Linear Rank Sum Test Based on Van der Waerden Scores"
    print "H0: Locations are Equal"
    print "Ha: Locations are Not Equal"
    print "alpha: 0.05"
    print "Test Statistic: ^statval"
    print "Lower Critical Value: ^lowlim"
    print "Upper Critical Value: ^upplim"
    if statval < cv
       print "Conclusion: Accept H0"
    else
       print "Conclusion: Reject H0"
    end of if
 
-----VAN DER WAERDEN TEST-----------------------------------------
 
VAN DER WAERDEN
 
Name:
    VAN DER WAERDEN
 
Type:
    Analysis Command
 
Purpose:
    Perform a Van Der Waerden (normal scores) test that k
    population distribution functions are equal.
 
Description:
    Analysis of Variance (ANOVA) is a data analysis technique
    for examining the significance of the factors (= independent
    variables) in a multi-factor model.  The one factor model can
    be thought of as a generalization of the two sample t-test.
    That is, the two sample t-test is a test of the hypothesis
    that two population means are equal.  The one factor ANOVA
    tests the hypothesis that k population means are equal.

    The standard ANOVA assumes that the errors (i.e., residuals)
    are normally distributed.  If this normality assumption
    is not valid, an alternative is to use a non-parametric
    test.

    The most common non-parametric test for the one-factor model
    is the Kruskal-Wallis test.  The Kruskal-Wallis is based
    on the ranks of the data.  The Van Der Waerden converts
    the ranks to quantiles of the standard normal distribution
    (details given below).  These are called normal scores and
    the test is computed from these normal scores.

    The advantage of the Van Der Waerden test is that it provides
    the high efficiency of the standard ANOVA analysis when the
    normality assumptions are in fact satisfied, but it also
    provides the robustness of the Kruskal-Wallis test when the
    normality assumptions are not satisfied.

    Let N(i) (i = 1, 2, ..., k) represent the sample sizes for
    each of the k groups (i.e., samples) in the data.  Let N
    denote the sample size for all groups.  Let X(ij) represent
    the ith value in the jth group.  Then compute the normal
    scores as follows:

       A(ij) = NORPPF(R(X(ij))/(N+1))

    with R(X(ij)) and NORPPF denoting the rank of observation X(ij)
    and the normal percent point function, respectively.

    The average of the normal scores for each sample can then be
    computed as

       Abar(i) = (1/n(i))*SUM[j=1 to n(i)][A(ij)]   i = 1, 2, ..., k

    The variance of the normal scores can be computed as

       S**2 = (1/(N-1))*SUM[i=1 to k]SUM[j=1 to n(i)][A(ij)**2]

    The Van Der Waerden test can then be defined as follows.

        H0: All of the k population distribution functions are
            identical
        HA: At least one of the populations tends to yield larger
            observations than at least one of the other populations
        Test Statistic: T1 = (1/S**2)*SUM[i=1 to k][n(i)*(Abar(i))**2]
        Significance Level: ALPHA
        Critical Region: T1 > CHIPPF(ALPHA,K-1) where CHIPPF
                         is the chi-square percent point function.
        Conclusion: Reject the null hypothesis if the test
                    statistic is in the critical region.

Syntax:
    VAN DER WAERDEN  <y>  <x>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response (= dependent) variable;
          <x> is the factor (= independent) variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    VAN DER WAERDEN Y X
    VAN DER WAERDEN Y X  SUBSET X = 1 TO 4
 
Note:
    If the hypothesis of identical distributions is rejected,
    you can perform a multiple comparisons procedure to
    determine which pairs of populations tend to differ.

    The populations i and j seem to be different if the
    following inequality is satisfied:

       |Abar(i) - Abar(j)| > TPPF(1-(alpha/2))*
                             SQRT(S**2*(N-1-T1)/(N-k))*
                             SQRT((1/N(i)) + (1/N(j)))

    with TPPF and T1 denoting the t percent point function and
    the Van Der Waerden test statistic, respectively.

    Dataplot writes all the pairwise multiple comparisons to
    the file "dpst1f.dat" in the current directory.

Note:
    Dataplot writes the following information to the file
    "dpst2f.dat" in the current directory:

       Column 1  = Index
       Column 2  = Raw Data Value
       Column 3  = Rank
       Column 4  = Normal Score
       Column 5  = Group Average of the Normal Scores (Abar(i))
       Column 6  = Group Sample Sizes (n(i))

Default:
    None
 
Synonyms:
    NORMAL SCORES TEST is a synonym for VAN DER WAERDEN TEST
 
Related Commands:
    ANOVA                 = Perform an analysis of variance.
    KRUSKAL WALLIS        = Perform a Kruskal-Wallis test.
    FRIEDMAN              = Perform a Friedman test.
    MEDIAN POLISH         = Perform a median polish (robust two-factor
                            ANOVA).
    BOX PLOT              = Generate a box plot.
    RANK SUM TEST         = Perform a rank sum test.
    SIGNED RANK TEST      = Perform a signed rank test.
 
Reference:
    W. J. Conover, (1999).  "Practical Nonparameteric Statistics",
    Third Edition, Wiley, pp. 396-406.

Applications:
    Analysis of Variance
 
Implementation Date:
    2004/10
 
Program:
    SKIP 25
    READ SPLETT2.DAT Y MACHINE
    VAN DER WAERDEN Y MACHINE

-----VARIABLE TO MATRIX--------------------------------------------
 
VARIABLE TO MATRIX
 
Name:
    VARIABLE TO MATRIX
 
Type:
    LET Subcommand
 
Purpose:
    Convert a variable to a matrix.
 
Description:
    There may be times when it is desirable to convert a variable
    (i.e., a single column vector) to a matrix.  This command provides
    a simple and convenient method for converting a variable to a
    matrix.

    With this command, you specify the desired number of rows
    in the matrix.  Dataplot then divides the number of observations
    in the variable by the requested number of rows to obtain the
    number of columns in the matrix.  If this division does not
    result in an integer value, the last column of the matrix will
    be filled with the "missing value".  To set this value, enter

         SET STATISTIC MISSING VALUE <value>

Syntax:
    LET <m> = VARIABLE TO MATRIX <y> <nrow>
              <SUBSET/EXPCEPT/FOR qualification>
    where <y> is the response variable;
          <nrow> is a parameter that specifies the number of rows
              for the matrix;
          <m> is a matrix that will contain the resulting matrix;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET M = VARIABLE TO MATRIX Y NROW
 
Note:
    By default, the matrix is created in row order from the variable.
    To create the variable in row order, enter the command

        SET VARIABLE TO MATRIX ROW

    To restore column order, enter

        SET VARIABLE TO MATRIX COLUMN

Note:
    It is also sometimes desirable to convert a matrix to a
    variable.  This can be done with the command

        LET Y = MATRIX TO VARIABLE M

    where M is a previously created matrix.

Default:
    None.
 
Synonyms:
    None
 
Related Commands:
    MATRIX TO VARIABLE   = Convert a matrix to a variable.
    CREATE MATRIX        = Create a matrix from a list of variables.
 
Applications:
    Data Management
 
Implementation Date:
    2010/11
 
Program 1:
    LET Y = SEQUENCE 1 1 10
    LET NROW = 3
    SET STATISTIC MISSING VALUE -1
    .
    LET M = VARIABLE TO MATRIX Y NROW
    SET WRITE DECIMALS 1
    PRINT M
    .
    SET VARIABLE TO MATRIX ROW
    LET M = VARIABLE TO MATRIX Y NROW
    SET WRITE DECIMALS 1
    PRINT M

Program 2:
    . Zarthan Company example from
    . Neter, Wasserman, Kutner, "Applied Linear Statistical Models"
    .
    .  Y = Sales
    .  X1  = Target Population (in thousands)
    .  X2  = Per Capita Discretionary Income (dollars)
    .
    DIMENSION 200 COLUMNS
    READ DISTRICT Y X1 X2
     1  162  274  2450
     2  120  180  3254
     3  223  375  3802
     4  131  205  2838
     5   67   86  2347
     6  169  265  3782
     7   81   98  3008
     8  192  330  2450
     9  116  195  2137
    10   55   53  2560
    11  252  430  4020
    12  232  372  4427
    13  144  236  2660
    14  103  157  2088
    15  212  370  2605
    END OF DATA
    FIT Y X1 X2
    .
    READ DPST4F.DAT  TEMP
    LET NROW = 3
    LET COV = VARIABLE TO MATRIX TEMP NROW
    SET WRITE DECIMALS -7
    PRINT COV

-----VARIANCE (LET)-----------------------------------------
 
VARIANCE
 
Name:
    VARIANCE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the variance of a variable.
 
Description:
    The variance is a common measure of the spread of a distribution
    or a variable.  The formula is;
        var = SUM(Xi - Xmean)**2/(N-1)
 
Syntax:
    LET <par> = VARIANCE <y> <SUBSET/EXCEPT/FOR qualification>
    where <y> is the variable for which the variance is to be computed;
          <par> is a parameter where the computed variance is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET V = VARIANCE Y1
    LET V = VARIANCE Y1  SUBSET TAG > 0
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    MEAN               = Compute the mean of a variable.
    STANDARD DEVI      = Compute the standard deviation of a variable.
    RANGE              = Compute the range of a variable.
    WEIGHTED VARIANCE  = Compute the variance of a variable.
    VARIANCE PLOT      = Generate a variance (versus subset) plot.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET VAR = VARIANCE Y1
 
-----VARIANCE PLOT-----------------------------------------------
 
VARIANCE PLOT
 
Name:
    VARIANCE PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a variance plot.
 
Description:
    A variance plot is a plot consisting of subsample variances versus
    subsample index.  The subsample variance is the variance (with
    divisor ni-1) of the data in the subsample.  The variance plot is
    used to answer the question-- "Does the subsample variation change
    over different subsamples?".  It consists of:
       Vertical   axis = subsample variance;
       Horizontal axis = subsample index.
    The variance plot yields 2 traces:
       1. a subsample variance trace; and
       2. a full-sample variance reference line.
    Like usual, the appearance of these 2 traces is
    controlled by the first 2 settings of the LINES,
    CHARACTERS, SPIKES, BARS, and similar attributes.
 
Syntax:
    VARIANCE PLOT   <y>   <x>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response (= dependent) variable;
          <x> is the subsample identifier variable (this variable
              appears on the horizontal axis);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    VARIANCE PLOT Y X
    VARIANCE PLOT Y X1
 
Default:
    None
 
Synonyms:
    VAR PLOT
    V PLOT
 
Related Commands:
    CHARACTERS                = Sets the type for plot characters.
    LINES                     = Sets the type for plot lines.
    STANDARD DEVIATION PLOT   = Generates a standard deviation plot.
    STAND DEVI OF MEAN PLOT   = Generates a standard deviation of the
                                mean plot.
    VARIANCE OF MEAN PLOT     = Generates variance of the mean plot.
    RANGE PLOT                = Generates a range plot.
    MEAN PLOT                 = Generates a mean plot.
    MEDIAN PLOT               = Generates a median plot.
    BOX PLOT                  = Generates a box plot.
    S CHART                   = Generates a standard deviation control
                                chart.
    PLOT                      = Generates a data or function plot.
 
Applications:
    Quality Control
 
Implementation Date:
    88/2
 
Program:
    SKIP 25
    READ GEAR.DAT DIAMETER BATCH
    LINE BLANK DASH
    CHARACTER X BLANK
    XTIC OFFSET 0.2 0.2
    Y1LABEL VARIANCE
    X1LABEL BATCH
    TITLE VARIANCE PLOT
    VARIANCE PLOT DIAMETER BATCH
 
-----VARIANCE OF THE MEAN (LET)----------------------------
 
VARIANCE OF THE MEAN
 
Name:
    VARIANCE OF THE MEAN (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the variance of the mean of a variable.
 
Description:
    The variance of the mean is:
        var of mean = (s/SQRT(N))**2
    where s is the standard deviation of the variable and N is the
    number of observations.
 
Syntax:
    LET <par> = VARIANCE OF THE MEAN <y>
                <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <par> is a parameter where the computed variance of the mean
              is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET VARM = VARIANCE OF THE MEAN Y1
    LET VARM = VARIANCE OF THE MEAN Y1 SUBSET TAG > 2
 
Default:
    None
 
Synonyms:
    VARIANCE OF MEAN
    VARIANCE MEAN
 
Related Commands:
    VARIANCE OF THE MEAN PLOT = Generates a variance of the mean versus
                                subset plot.
    MEAN                      = Compute the mean of a variable.
    VARIANCE                  = Compute the variance of a variable.
    STANDARD DEVIATION        = Compute the standard deviation of a
                                variable.
 
Applications:
    XX
 
Implementation Date:
    94/2
 
Program:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET SD = VARIANCE OF THE MEAN Y1
 
-----VARIANCE OF THE MEAN PLOT----------------------------
 
VARIANCE OF THE MEAN PLOT
 
Name:
    VARIANCE OF THE MEAN PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a variance of the mean plot.
 
Description:
    A variance of the mean plot is a plot consisting of subsample
    variances of the mean versus subsample index.  The subsample
    variance of the mean is the subsample variance divided by the
    subsample size.  The variance of the mean plot is used to answer
    the question-- "Does the subsample variation of the mean change
    over different subsamples?".   It consists of:
       Vertical   axis = subsample variance of the mean;
       Horizontal axis = subsample index.
    The variance of the mean plot yields 2 traces:
       1. a subsample variance of the mean trace; and
       2. a full-sample variance of the mean reference line.
    Like usual, the appearance of these 2 traces is
    controlled by the first 2 settings of the LINES,
    CHARACTERS, SPIKES, BARS, and similar attributes.
 
Syntax:
    VARIANCE OF THE MEAN PLOT <y> <x> <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response (= dependent) variable;
          <x> is the subsample identifier variable (this variable
              appears on the horizontal axis);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    VARIANCE OF THE MEAN PLOT Y X
    VARIANCE OF THE MEAN PLOT Y X1
 
Default:
    None
 
Synonyms:
    VARIANCE OF MEAN PLOT
    VARM PLOT
    VM PLOT
 
Related Commands:
    CHARACTERS                = Sets the type for plot characters.
    LINES                     = Sets the type for plot lines.
    STANDARD DEVIATION PLOT   = Generates a standard deviation plot.
    VARIANCE  PLOT            = Generates a variance plot.
    STAND DEVI OF MEAN PLOT   = Generates standard deviation of mean
                                plot.
    RANGE PLOT                = Generates a range plot.
    MEAN PLOT                 = Generates a mean plot.
    MEDIAN PLOT               = Generates a median plot.
    BOX PLOT                  = Generates a box plot.
    S CHART                   = Generates a standard deviation control
                                chart.
    PLOT                      = Generates a data or function plot.
 
Applications:
    Quality Control
 
Implementation Date:
    88/2
 
Program:
    SKIP 25
    READ GEAR.DAT DIAMETER BATCH
    LINE BLANK DASH
    CHARACTER X BLANK
    XTIC OFFSET 0.2 0.2
    Y1LABEL VARIANCE OF THE MEAN
    X1LABEL BATCH
    TITLE VARIANCE OF THE MEAN PLOT
    VARIANCE OF THE MEAN PLOT DIAMETER BATCH
 
-----VARIANCE-COVARIANCE MATRIX (LET)----------------------------------
 
VARIANCE-COVARIANCE MATRIX
 
Name:
    VARIANCE-COVARIANCE MATRIX (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the variance-covariance matrix of a matrix.
 
Description:
    The variance-covariance matrix computes the covariance between each
    of the columns of a data matrix.  That is, row i and column j of the
    variance-covariance matrix is the covariance between column i and
    column j of the original matrix. The diagonal elements (i.e., i=j)
    are the variances of the columns. The variance-covariance matrix is
    symmetric (since the variance-covariance of column i with column j
    is the same as the variance-covariance of column j with column i).
 
Syntax:
    LET <mat2> = VARIANCE-COVARIANCE MATRIX <mat1>
                 <SUBSET/EXCEPT/FOR qualification>
    where <mat1> is a data matrix;
          <mat2> is a matrix where the resulting variance-covariances
                 are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional (and
                 rarely used in this context).
 
Examples:
    LET C = VARIANCE-COVARIANCE MATRIX A
 
Note:
    By default, the covariance matrices are computed on the columns.
    That is, element (i,j) of the covariance matrix is the covariance
    between column i and column j of the input matrix.

    To specify a covariance matrix based on rows rather than columns,
    enter the command 

         SET MATRIX COVARIANCE DIRECTION ROW

    To reset column based correlations, enter

         SET MATRIX COVARIANCE DIRECTION COLUMN

Note:
    The command

       SET COVARIANCE TYPE <DEFAULT/RANK/WINSOR/BIWEIGHT>

    can be used to specify the type of covariances computed.
    Specifically,

        DEFAULT      - generate the standard covariance
        RANK         - generate ranked covariances
        WINSOR       - generate Winsorized covariances
        BIWEIGHT     - generate biweight midcovariances

Note:
    Matrices are created with either the READ MATRIX command or the
    MATRIX DEFINITION command.  Enter HELP MATRIX DEFINITION and HELP
    READ MATRIX for details.
 
Note:
    The columns of a matrix are accessible as variables by appending an
    index to the matrix name.  For example, the 4x4 matrix C has
    columns C1, C2, C3, and C4.  These columns can be operated on like
    any other Dataplot variable.
 
Note:
    The maximum size matrix that Dataplot can handle is set when
    Dataplot is built on a particular site.  The default maximums are
    100 columns and 500 rows.  Earlier versions may be 20 rows and 20
    columns or 100 rows and 100 columns.
 
    Note: This has been increased. Enter HELP DIMENSION MATRIX
    for details.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CORRELATION MATRIX          = Compute the correlation matrix of a
                                  matrix.
    PRINCIPLE COMPONENTS        = Compute the principle components of a
                                  matrix.
    PARTIAL CORRELATION MATRIX  = Generate the partial correlation matrix.
    RANK COVARIANCE             = Compute the rank covariance of two
                                  variables.
    WINSORIZED COVARIANCE       = Compute the Winsorized covariance of two
                                  variables.
    BIWEIGHT MIDCOVARIANCE      = Compute the biweight mid-covariance of
                                  two variables.
 
Applications:
    Linear Algebra
 
Implementation Date:
    87/10
    2002/7: SET COVARIANCE TYPE command implemented 2002/7.
 
Program:
    .  This data is from page 202 of
    .
    .  Peavy, Bremer, Varner, Hogben (1986), "OMNITAB 80:
    .  An Interpretive System for Statistical and Numerical
    .  Data Analysis," NBS Special Publication 701.
    .
    .  Original source of the data is from
    .  Draper and Smith (1981), "Applied Regression Analysis",
    .  Wiley, p. 373.
    .
    dimension 40 columns
    .
    read matrix m
    42.2  11.2  31.9  167.1
    48.6  10.6  13.2  174.4
    42.6  10.6  28.7  160.8
    39.0  10.4  26.1  162.0
    34.7   9.3  30.1  140.8
    44.5  10.8   8.5  174.6
    39.1  10.7  24.3  163.7
    40.1  10.0  18.6  174.5
    45.9  12.0  20.4  185.7
    end of data
    .
    set write decimals 4
    let cov = covariance matrix m
    print cov
 
-----VARIANCE INFLATION FACTORS (LET)---------------------------------
 
VARIANCE INFLATION FACTORS
 
Name:
    VARIANCE INFLATION FACTORS (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute variance inflation factors for a regression design matrix.
 
Description:
    Variance inflation factors are a measure of the multi-colinearity
    in a regression design matrix (i.e., the independent variables).

    Multi-colinearity results when the columns of X have significant
    interdependence (i.e., one or more columns of X is close to a
    linear combination of the other columns).  Multi-colinearity
    can result in numerically unstable estimates of the regression
    coefficients (small changes in X can result in large changes
    to the estimated regression coefficients).

    Pairwise colinearity can be determined from viewing a correlation
    matrix of the independent variables.  However, correlation
    matrices will not reveal higher order colinearity.

    There are a number of approaches to dealing with
    multi-colinearity.  Some of these include:

        1) Delete one or more of the independent variables from
           the fit.
        2) Perform a principal components regression.
        3) Compute the regression using a singular value
           decomposition approach.  Note that Dataplot uses
           a modified Gram-Schmidt method (Dataplot can perform
           a singular value decomposition, however this has not
           been incorporated into the fit).

    Variance inflation factors are one measure that can be used to
    detect multi-colinearity (condition indices are another).

    Variance inflation factors are a scaled version of the
    multiple correlation coefficient between variable j and
    the rest of the independent variables.  Specifically,

        VIF(j) = 1/(1 - R(j)**2)

    where R(j) is the multiple correlation coefficient.

    Variance inflation factors are often given as the reciprocal
    of the above formula.  In this case, they are referred to
    as the tolerances.

    If R(j) equals zero (i.e., no correlation between X(j) and the
    remaining independent variables), then VIF(j) equals 1.  This
    is the minimum value.  Neter, Wasserman, and Kutner (see
    Reference below) recommend looking at the largest VIF value.
    A value greater than 10 is an indiciation of potential
    multi-colinearity problems.

Syntax:
    LET <y1> = VARIANCE INFLATION FACTORS <mat1>
               <SUBSET/EXCEPT/FOR qualification>
    where <mat1> is the design matrix for which the variance inflation
                factors are to be computed;
          <y1> is a vector where the resulting variance inflation
                factors are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional (and
                rarely used in this context).
 
Examples:
    LET Y = VARIANCE INFLATION FACTORS X
 
Note:
    Matrices are created with either the READ MATRIX, CREATE MATRIX,
    or MATRIX DEFINITION command.  Enter HELP MATRIX DEFINITION,
    HELP CREATE MATRIX, and HELP READ MATRIX for details.
 
Note:
    The columns of a matrix are accessible as variables by appending an
    index to the matrix name.  For example, the 4x4 matrix C has
    columns C1, C2, C3, and C4.  These columns can be operated on like
    any other Dataplot variable.
 
Note:
    The maximum size matrix that Dataplot can handle is set when
    Dataplot is built on a particular site.  Enter the command
    HELP MATRIX DIMENSION for details on the maximum size matrix
    that can be accomodated.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CONDITION INDICES        = Compute condition indices of a regresion
                               design matrix.
    CREATE MATRIX            = Create a matrix from a list of
                               variables.
    FIT                      = Perform a least squares fit.
    CATCHER MATRIX           = Compute the catcher matrix.
    PARTIAL REGRESSION PLOT  = Compute the catcher matrix.
 
Reference:
    "Applied Linear Statistical Models", 3rd ed., Neter, Wasserman,
    and Kunter, 1990, Irwin.
 
    "Efficient Computing of Regression Diagnostics", Velleman and
    Welsch, American Statistician, November, 1981, Vol. 35, No. 4,
    pp. 234-242.
 
Applications:
    Regression Diagnostics
 
Implementation Date:
    2002/6
 
Program:
    DIMENSION 100 COLUMNS
    SKIP 25
    READ HALD647.DAT Y X1 X2 X3 X4
    SKIP 0
    LET N = SIZE X1
    LET X0 = SEQUENCE 1 1 N
    LET Z = CREATE MATRIX X0 X1 X2 X3 X4
    LET V = VARIANCE INFLATION FACTORS Z
    SET WRITE DECIMALS 2
    PRINT V
 
-----VARIABLE LABEL--------------------------------------------------
 
VARIABLE LABEL
 
Name:
    VARIABLE LABEL
 
Type:
    Support Command
 
Purpose:
    Define long labels associated with variable names.
 
Description:
    Variable names are limited to 8 characters in Dataplot.
    Variable labels allow longer, more descriptive names.
    The variable label can have up to 52 characters and may
    include spaces.

    Currently, variable labels can be used in the following
    ways in Dataplot:

    1) The multi-plotting commands (SCATTER PLOT MATRIX,
       FACTOR PLOT, and CONDITION PLOT) automatically make use of
       variable labels.

    2) You can use the "^" to substitute a variable label
       for a variable name in text strings.  For example,

           LET Y = NORMAL RAND NUMBERS FOR I = 1 1 100
           VARIABLE LABEL Y NORMAL RANDOM NUMBERS
           Y1LABEL ^Y
           PLOT Y

       Previously, Dataplot only supported substitutions
       for parameters and strings.  Now, if a variable name
       is found, it checks to see if a label has been defined.
       If yes, the label is substituted for the variable name.
       If not, the variable label is left as is (with the
       "^" removed).
      
     3) The X1LABEL AUTOMATIC and Y1LABEL AUTOMATIC commands
        will now substitute the variabe label for the variable
        name on the x and y axes respectively.  Note that
        Y1LABEL AUTOMATIC and X1LABEL AUTOMATIC only apply to
        the PLOT command.

Syntax 1:
    VARIABLE LABEL <var name> <text>
 
    where <var name> is the variable having a label defined;
    and   <text> defines the variable label and contains all the
             from <var name> until the end of the command line
             (the variable label will be truncated after 52
             characters).

    Note that the variable specified in <var name> must already
    exist.

Examples:
    LET Y = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    VARIABLE LABEL Y NORMAL RANDOM NUMERS
    Y1LABEL ^Y
    PLOT Y
 
Note:
    The variable labels may have up to 52 characters.
 
Default:
    All variable labels are blank.
 
Synonyms:
    None
 
Related Commands:
    ^                     = Substitution character.
    X1LABEL AUTOMATIC     = Automatic label for x axis.
    Y1LABEL AUTOMATIC     = Automatic label for y axis.
    SCATTER PLOT MATRIX   = Generate a scatter plot matrix.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    2000/1
 
Program:
    LET Y = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    VARIABLE LABEL Y NORMAL RANDOM NUMERS
    Y1LABEL ^Y
    PLOT Y

-----VARIATIONAL DISTANCE (LET)-----------------------------------------
 
VARIATIONAL DISTANCE
 
Name:
    VARIATIONAL DISTANCE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Given a vector of counts, compute the difference from uniformity
    based on the variational distance.
 
Description:
    In spatial analysis, it is sometimes desired to determine if the
    points in the given space are consistent with a uniform
    distribution.  One such measure is based on the variational distance
    which is defined as

        d = 0.5*SUM[k=0 to infinity][|P(Unif=k) - P(data=k)|]

    Given that the points have been converted to a set of N counts, X(k),
    this formula becomes


        d = 0.5*SUM[k=1 to N][|((1/N) - X(k))/SUM[k=1 to N][X(k)]|]

    The value of the variational distance is between zero and one with
    values closer to zero indicating greater consistency with a uniform
    distribution.

Syntax:
    LET <a> = VARIATIONAL DISTANCE <y>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <a> is a parameter where the computed statistic is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = VARIATIONAL DISTANCE Y1
    LET A = VARIATIONAL DISTANCE Y1  SUBSET TAG > 2
 
Note:
    The relative dispersion index is a scaled version of the variational
    distance.  Enter HELP RELATIVE DISPERSION INDEX for details.

Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    RELATIVE DISPERSION INDEX  = Compute the relative dispersion index of
                                 a variable containing a set of counts.
    UNIFORM CHISQUARE STAT     = Compute the chi-square statistic for 
                                 uniformity for a variable containing a
                                 set of counts.
    GOODNESS OF FIT            = Perform a goodness of fit test.
 
Reference:
    Kashiwagi, Fagan, Douglas, Yamamoto, Heckert, Leigh, Obrzut, Du, Lin-Gibson,
    Mu, Winey, Haggennueller (2007), "Relationship between dispersion metric and
    properties of PMMA/SWNT nanocomposites", Polymer Journal, Vol. 48,
    pp. 4855 - 4866.

Applications:
    Spatial Statistics
 
Implementation Date:
    2014/3
 
Program:
    LET Y  = UNIFORM RANDOM NUMBERS FOR I = 1 1 1000
    LET Y1 X1 = BINNED Y
    LET Y  = NORMAL RANDOM NUMBERS FOR I = 1 1 1000
    LET Y2 X2 = BINNED Y
    LET Y  = EXPONENTIAL RANDOM NUMBERS FOR I = 1 1 1000
    LET Y3 X3 = BINNED Y
    LET A1 = VARIATIONAL DISTANCE Y1
    LET A2 = VARIATIONAL DISTANCE Y2
    LET A3 = VARIATIONAL DISTANCE Y3
 
-----VECTOR (LET)-----------------------------------------------------
 
VECTOR
The following are Dataplot vector commands:
    VECTOR ADDITION           = Carries out a vector addition.
    VECTOR SUBTRACTION        = Carries out a vector subtraction.
    VECTOR DOT PRODUCT        = Computes a vector dot product.
    VECTOR LENGTH             = Computes the vector length.
    VECTOR DISTANCE           = Computes the vector distance.
    VECTOR ANGLE              = Computes the vector angle.
 In addition, the VECTOR PLOT command can be used to plot vectors.
 
-----VECTOR ADDITION (LET)---------------------------------------
 
VECTOR ADDITION (LET)
 
Name:
    VECTOR ADDITION
 
Type:
    Subcommand under LET
 
Purpose:
    Carry out the addition of 2 vectors (with real elements).
 
Syntax:
    LET <v3>   = VECTOR ADDITION <v1> <v2>
                      <SUBSET/EXCEPT/FOR/qualification>
    where <v1> is the variable whose elements are the (real) elements of
               the first vector;
          <v2> is the variable whose elements are the (real) elements of
               the second vector;
          <v3> is the variable whose elements are the (real) elements of
               the resultant vector;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional and
               rarely used in this context.
 
Examples:
    LET Y3  = VECTOR ADDITION Y1 Y2
    LET Y3  = VECTOR ADDITION Y1 Y2 SUBSET Y1 > 10
    LET Y3  = VECTOR ADDITION Y1 Y2 FOR I = 1 1 3
 
Note:
    The vector (x1, x2, ... ,xn) represents the line segment from the
    origin (0,0,...,0) to the point (x1, x2, ..., xn).  That is, each
    element of the vector represents the corresponding value on the
    corresponding axis.  Vectors are sometimes represented in terms of
    the unit coordinate vectors.  For example, for the 3d case:
        i = (1,0,0)
        j = (0,1,0)
        l = (0,0,1)
    Then the vector x=(x1,x2,x3) can be written as a=x1*i + x2*j + x3*k.
 
Note:
    Storagewise, a Dataplot "variable" and a mathematical "vector" are
    identical.  The ordering of elements within a Dataplot variable is
    identical to the ordering of elements within a mathematical vector.
    Thus to store the vector with elements 4 11 37 8 19 in the variable
    Y, do the following:
          SERIAL READ Y
          4 11 37 8 19
          END OF DATA
    or
          LET Y = DATA 4 11 37 8 19
 
Default:
    None
 
Synonyms:
    The command LET Y = VECTOR ADDITION Y1 Y2 is equivalent to the
    command LET Y = Y1 + Y2.
 
Related Commands:
    LET                       = Evaluates general functions.
    VECTOR SUBTRACTION        = Carries out a vector subtraction.
    VECTOR DOT PRODUCT        = Computes a vector dot product.
    VECTOR LENGTH             = Computes the vector length.
    VECTOR DISTANCE           = Computes the vector distance.
    VECTOR ANGLE              = Computes the vector angle.
    COMPLEX ADDITION          = Carries out a complex addition.
    POLYNOMIAL ADDITION       = Carries out a polynomial addition.
    SET UNION                 = Carries out a set union.
    LOGICAL AND               = Carries out a logical and.
    MATRIX ADDITION           = Carries out a matrix addition.
    PLOT                      = Plots data or functions.
 
Applications:
    Mathematics
 
Implementation Date:
    87/10
 
Program:
    .  THE VECTOR PARAMETERIZATION OF A LINE IS:
    .     R(T) = R0 + T*D
    .  WHERE R0 IS AN INITIAL POSITION, D IS A VECTOR (FROM R0), AND
    .  T IS A SCALAR (OFTEN THOUGHT OF AS TIME).
    LET R0 = DATA 1 -1 2
    LET D = DATA 2 -3 1
    LOOP FOR T = 1 1 10
        LET TEMP = T*D
        LET RNEW = VECTOR ADDITION R0 TEMP
        PRINT T RNEW
    END OF LOOP
 
-----VECTOR ANGLE (LET)------------------------------------------
 
VECTOR ANGLE (LET)
 
Name:
    VECTOR ANGLE
 
Type:
    Subcommand under LET
 
Purpose:
    Compute the angle between 2 vectors with real elements.
 
Description:
    The vector angle is defined to be the angle between 0 and 180
    degrees that satisfies the relationship:
        cosine(theta) = dot product (v1,v2)/(||v1||x||v2||)
    where ||.|| refers to the vector length.
 
    The units for the output (radians, degrees, or grads) are dictated
    by the prior user-defined setting of the ANGLE UNITS command, the
    RADIANS command, the DEGREES command, or the GRADS command.  The
    default angle units is radians.
 
Syntax:
    LET <p> = VECTOR ANGLE <v1> <v2>  <SUBSET/EXCEPT/FOR/qualification>
    where <v1> is the variable whose elements are the (real) elements of
               the first vector;
          <v2> is the variable whose elements are the (real) elements of
               the second vector;
          <p>  is a parameter whose value is the computed angle between
               <v1> and <v2>;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional and
               rarely used in this context.
 
Examples:
    LET THETA  = VECTOR ANGLE Y1 Y2
    LET THETA  = VECTOR ANGLE Y1 Y2 SUBSET Y1 > 10
    LET THETA  = VECTOR ANGLE Y1 Y2 FOR I = 1 1 3
 
Note:
    The vector (x1, x2, ... ,xn) represents the line segment from the
    origin (0,0,...,0) to the point (x1, x2, ..., xn).  That is, each
    element of the vector represents the corresponding value on the
    corresponding axis.  Vectors are sometimes represented in terms of
    the unit coordinate vectors.  For example, for the 3d case:
        i = (1,0,0)
        j = (0,1,0)
        l = (0,0,1)
    Then the vector x=(x1,x2,x3) can be written as a=x1*i + x2*j + x3*k.
 
Note:
    Storagewise, a Dataplot "variable" and a mathematical "vector" are
    identical.  The ordering of elements within a Dataplot variable is
    identical to the ordering of elements within a mathematical vector.
    Thus to store the vector with elements 4 11 37 8 19 in the variable
    Y, do the following:
          SERIAL READ Y
          4 11 37 8 19
          END OF DATA
    or
          LET Y = DATA 4 11 37 8 19
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ANGLE UNITS               = Sets the angle units to radians,
                                degrees, or grads.
    RADIANS                   = Sets the angle units to radians.
    DEGREES                   = Sets the angle units to degrees.
    GRADS                     = Sets the angle units to grads.
    LET                       = Evaluates general functions.
    VECTOR ADDITION           = Carries out a vector addition.
    VECTOR SUBTRACTION        = Carries out a vector subtraction.
    VECTOR DOT PRODUCT        = Computes a vector dot product.
    VECTOR LENGTH             = Computes the vector length.
    VECTOR DISTANCE           = Computes the vector distance.
    PLOT                      = Plots data or functions.
 
Applications:
    Mathematics
 
Implementation Date:
    87/10
 
Program:
    LET Y1 = DATA 4 2 3 1 6
    LET Y2 = DATA 1 2 4 6 3
    LET A = VECTOR ANGLE Y1 Y2
    WRITE Y1 Y2 A
 
-----VECTOR ARROW--------------------------------------------------

VECTOR ARROW

Name:
    VECTOR ARROW

Type:
    Support Command

Purpose:
    Specifies the following two attributes for the arrow heads on
    vector plots:
       1) Whether the base of the triangle that forms the arrow
          head is drawn or not;
       2) Whether the arrow heads are drawn at a fixed size or
          proportional to the largest vector.

Syntax 1:
    VECTOR ARROW  <FIXED/VARIABLE>
    where FIXED specifies that all the arrow heads are drawn the same
            size and VARIABLE specifies that the arrow heads are
            drawn proportional to the longest vector.

    For VARIABLE, the arrow head corresponding to the largest vector
    length is drawn at the size given by the CHARACTER SIZE (or
    CHARACTER HW) command.  All other vectors multiply the character
    size by the ratio
        vector length / maximum vector length

Syntax 2:
    VECTOR ARROW  <OPEN/CLOSED>
    where CLOSED specifies that the base of the arrow head is drawn
            while OPEN specifies that it is not.

Examples:
    VECTOR ARROW OPEN
    VECTOR ARROW CLOSED
    VECTOR ARROW FIXED
    VECTOR ARROW VARIABLE

Default:
    Vectors are drawn with a fixed size and with the base.

Synonyms:
    None

Related Commands:
    VECTOR PLOT    = Generates a vector plot.
    VECTOR FORMAT  = Specifies the data format for vector plots.

Applications:
    XX

Implementation Date:
    92/8

Program:
    READ Y1 X1 Y2 X2
      0.1000000E+02 -0.1524000E+02  0.1051449E+02 -0.1734317E+02
      0.1000000E+02 -0.1397000E+02  0.1094621E+02 -0.1644858E+02
      0.1000000E+02 -0.1143000E+02  0.1378484E+02 -0.1588376E+02
      0.1000000E+02 -0.1016000E+02  0.1672586E+02 -0.1649936E+02
      0.1000000E+02 -0.8890000E+01  0.1808503E+02 -0.1553822E+02
      0.1000000E+02 -0.7620000E+01  0.1995356E+02 -0.1463254E+02
      0.1000000E+02 -0.6350000E+01  0.2206867E+02 -0.1353830E+02
      0.1000000E+02 -0.5080000E+01  0.2215228E+02 -0.1128796E+02
      0.1000000E+02 -0.3810000E+01  0.1978718E+02 -0.8024862E+01
      0.1000000E+02 -0.2540000E+01  0.1635728E+02 -0.4799302E+01
      0.1000000E+02 -0.1270000E+01  0.1361335E+02 -0.2298972E+01
      0.1000000E+02  0.0000000E+00  0.1239326E+02 -0.5136330E+00
      0.1000000E+02  0.1270000E+01  0.1173628E+02  0.1501220E+01
      0.1000000E+02  0.2540000E+01  0.1153493E+02  0.2589486E+01
      0.1000000E+02  0.3810000E+01  0.1203320E+02  0.3974670E+01
      0.1000000E+02  0.5080000E+01  0.1404934E+02  0.5650798E+01
      0.1000000E+02  0.6350000E+01  0.1606889E+02  0.7883220E+01
      0.1000000E+02  0.7620000E+01  0.1955596E+02  0.1140826E+02
      0.1000000E+02  0.8890000E+01  0.2272479E+02  0.1506554E+02
      0.1000000E+02  0.1016000E+02  0.2338944E+02  0.1776808E+02
      0.1000000E+02  0.1143000E+02  0.2053801E+02  0.1859783E+02
      0.1000000E+02  0.1270000E+02  0.1738284E+02  0.1887298E+02
      0.1000000E+02  0.1397000E+02  0.1535987E+02  0.1946041E+02
      0.1000000E+02  0.1524000E+02  0.1346489E+02  0.1979359E+02
    END OF DATA
    .
    CHARACTER VECTOR ALL
    CHARACTER HW 3.0 6.0 ALL
    VECTOR FORMAT POINT
    .
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    VECTOR ARROW OPEN; VECTOR ARROW FIXED
    TITLE VECTOR ARROW OPEN, FIXED
    VECTOR PLOT Y1 X1 Y2 X2
    VECTOR ARROW CLOSED; VECTOR ARROW FIXED
    TITLE VECTOR ARROW CLOSED, FIXED
    VECTOR PLOT Y1 X1 Y2 X2
    VECTOR ARROW CLOSED; VECTOR ARROW VARIABLE
    TITLE VECTOR ARROW CLOSED, VARIABLE
    VECTOR PLOT Y1 X1 Y2 X2
    VECTOR ARROW OPEN; VECTOR ARROW VARIABLE
    TITLE VECTOR ARROW OPEN, VARIABLE
    VECTOR PLOT Y1 X1 Y2 X2
    END OF MULTIPLOT
 
-----VECTOR CROSS PRODUCT (LET)------------------------------------
 
VECTOR CROSS PRODUCT (LET)
 
Name:
    VECTOR CROSS PRODUCT
 
Type:
    Subcommand under LET
 
Purpose:
    Compute the cross product (= vector product) of 2 vectors with real
    elements.
 
Description:
    The cross product is only defined for vectors of length 3.  It is
    a vector (also of length 3) that is perpendicular to both of the
    original vectors.  The formula for the cross product of the vector X
    with elements x1, x2, and x3 with the vector Y with elements y1, y2,
    and y3 is:
        X x Y = ((x2y3 - x3y2), (x3y1 - x1y3), (x1y2 - x2y1))
 
    An error message is generated for vectors that are not of length 3.
 
Syntax:
    LET <p> = VECTOR CROSS PRODUCT <v1> <v2>
             <SUBSET/EXCEPT/FOR/qualification>
    where <v1> is the variable whose elements are the (real) elements of
               the first vector;
          <v2> is the variable whose elements are the (real) elements of
               the second vector;
          <v3> is the variable whose elements are the (real) elements of
               the resultant vector;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional and
               rarely used in this context.
 
Examples:
    LET DP  = VECTOR CROSS PRODUCT Y1 Y2
    LET DP  = VECTOR CROSS PRODUCT Y1 Y2 SUBSET Y1 > 10
    LET DP  = VECTOR CROSS PRODUCT Y1 Y2 FOR I = 1 1 3
 
Note:
    The vector (x1, x2, ... ,xn) represents the line segment from the
    origin (0,0,...,0) to the point (x1, x2, ..., xn).  That is, each
    element of the vector represents the corresponding value on the
    corresponding axis.  Vectors are sometimes represented in terms of
    the unit coordinate vectors.  For example, for the 3d case:
        i = (1,0,0)
        j = (0,1,0)
        l = (0,0,1)
    Then the vector x=(x1,x2,x3) can be written as a=x1*i + x2*j + x3*k.
 
Note:
    Storagewise, a Dataplot "variable" and a mathematical "vector" are
    identical.  The ordering of elements within a Dataplot variable is
    identical to the ordering of elements within a mathematical vector.
    Thus to store the vector with elements 4 11 37 8 19 in the variable
    Y, do the following:
          SERIAL READ Y
          4 11 37 8 19
          END OF DATA
    or
          LET Y = DATA 4 11 37 8 19
 
Default:
    None
 
Synonyms:
    INNER PRODUCT for DOT PRODUCT
 
Related Commands:
    LET                       = Evaluates general functions.
    VECTOR ADDITION           = Carries out a vector addition.
    VECTOR SUBTRACTION        = Carries out a vector subtraction.
    VECTOR DOT PRODUCT        = Computes a vector dot product.
    VECTOR LENGTH             = Computes the vector length.
    VECTOR DISTANCE           = Computes the vector distance.
    VECTOR ANGLE              = Computes the vector angle.
    PLOT                      = Plots data or functions.
    COMPLEX MULTIPLICATION    = Carries out a complex multiplication.
    POLYNOMIAL MULTIPLICATION = Carries out a polynomial multiplication.
    SET CARTESIAN PRODUCT     = Carries out a set cartesian product.
    MATRIX MULTIPLICATION     = Carries out a matrix multiplication.
 
Applications:
    Mathematics
 
Implementation Date:
    93/10
 
Program:
    LET Y1 = DATA 4 2 3
    LET Y2 = DATA 1 2 4
    LET A = VECTOR CROSS PRODUCT Y1 Y2
    WRITE Y1 Y2 A
 
-----VECTOR DISTANCE (LET)---------------------------------------
 
VECTOR DISTANCE (LET)
 
Name:
    VECTOR DISTANCE
 
Type:
    Subcommand under LET
 
Purpose:
    Compute the (Euclidean) distance between 2 vectors with real
    elements.
 
Description:
    The formula for the vector distance is:
         D = SQRT(SUM((Y1(I) - Y2(I))**2))
 
Syntax:
    LET <p> = VECTOR DISTANCE <v1>  <v2>
             <SUBSET/EXCEPT/FOR/qualification>
    where <v1> is the variable whose elements are the (real) elements of
               the first vector;
          <v2> is the variable whose elements are the (real) elements of
               the second vector;
          <p>  is a parameter where the computed distance is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional and
               rarely used in this context.
 
Examples:
    LET THETA  = VECTOR DISTANCE Y1 Y2
    LET THETA  = VECTOR DISTANCE Y1 Y2 SUBSET Y1 > 10
    LET THETA  = VECTOR DISTANCE Y1 Y2 FOR I = 1 1 3
 
Note:
    The vector (x1, x2, ... ,xn) represents the line segment from the
    origin (0,0,...,0) to the point (x1, x2, ..., xn).  That is, each
    element of the vector represents the corresponding value on the
    corresponding axis.  Vectors are sometimes represented in terms of
    the unit coordinate vectors.  For example, for the 3d case:
        i = (1,0,0)
        j = (0,1,0)
        l = (0,0,1)
    Then the vector x=(x1,x2,x3) can be written as a=x1*i + x2*j + x3*k.
 
Note:
    Storagewise, a Dataplot "variable" and a mathematical "vector" are
    identical.  The ordering of elements within a Dataplot variable is
    identical to the ordering of elements within a mathematical vector.
    Thus to store the vector with elements 4 11 37 8 19 in the variable
    Y, do the following:
          SERIAL READ Y
          4 11 37 8 19
          END OF DATA
    or
          LET Y = DATA 4 11 37 8 19
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LET                       = Evaluates general functions.
    VECTOR ADDITION           = Carries out a vector addition.
    VECTOR SUBTRACTION        = Carries out a vector subtraction.
    VECTOR DOT PRODUCT        = Computes a vector dot product.
    VECTOR LENGTH             = Computes the vector length.
    VECTOR DISTANCE           = Computes the vector distance.
    VECTOR ANGLE              = Computes the vector angle.
    PLOT                      = Plots data or functions.
    SET CARDINALITY           = Computes the set cardinality.
    MATRIX DETERMINANT        = Computes the matrix determinant.
    MATRIX EUCLIDEAN  RADIUS  = Computes the matrix euclidean norm.
    MATRIX SPECTRAL NORM      = Computes the matrix spectral norm.
    MATRIX SPECTRAL  RADIUS   = Computes the matrix spectral radius.
 
Applications:
    Mathematics
 
Implementation Date:
    87/10
 
Program:
    LET Y1 = DATA 4 2 3 1 6
    LET Y2 = DATA 1 2 4 6 3
    LET A = VECTOR DISTANCE Y1 Y2
    WRITE Y1 Y2 A
 
-----VECTOR DOT PRODUCT (LET)------------------------------------
 
VECTOR DOT PRODUCT (LET)
 
Name:
    VECTOR DOT PRODUCT
 
Type:
    Subcommand under LET
 
Purpose:
    Compute the dot product (= inner product) of 2 vectors with real
    elements.
 
Description:
    The formula for the vector dot product is:
         D = SUM(Y1(i)*Y2(i))
 
Syntax:
    LET <p> = VECTOR DOT PRODUCT <v1> <v2>
             <SUBSET/EXCEPT/FOR/qualification>
    where <v1> is the variable whose elements are the (real) elements of
               the first vector;
          <v2> is the variable whose elements are the (real) elements of
               the second vector;
          <p>  is the parameter whose value is the computed dot product
               of <v1> and <v2>;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional and
               rarely used in this context.
 
Examples:
    LET DP  = VECTOR DOT PRODUCT Y1 Y2
    LET DP  = VECTOR DOT PRODUCT Y1 Y2 SUBSET Y1 > 10
    LET DP  = VECTOR DOT PRODUCT Y1 Y2 FOR I = 1 1 3
 
Note:
    The vector (x1, x2, ... ,xn) represents the line segment from the
    origin (0,0,...,0) to the point (x1, x2, ..., xn).  That is, each
    element of the vector represents the corresponding value on the
    corresponding axis.  Vectors are sometimes represented in terms of
    the unit coordinate vectors.  For example, for the 3d case:
        i = (1,0,0)
        j = (0,1,0)
        l = (0,0,1)
    Then the vector x=(x1,x2,x3) can be written as a=x1*i + x2*j + x3*k.
 
Note:
    Storagewise, a Dataplot "variable" and a mathematical "vector" are
    identical.  The ordering of elements within a Dataplot variable is
    identical to the ordering of elements within a mathematical vector.
    Thus to store the vector with elements 4 11 37 8 19 in the variable
    Y, do the following:
          SERIAL READ Y
          4 11 37 8 19
          END OF DATA
    or
          LET Y = DATA 4 11 37 8 19
 
Default:
    None
 
Synonyms:
    INNER PRODUCT for DOT PRODUCT
 
Related Commands:
    LET                       = Evaluates general functions.
    VECTOR ADDITION           = Carries out a vector addition.
    VECTOR SUBTRACTION        = Carries out a vector subtraction.
    VECTOR CROSS PRODUCT      = Computes a vector cross product.
    VECTOR LENGTH             = Computes the vector length.
    VECTOR DISTANCE           = Computes the vector distance.
    VECTOR ANGLE              = Computes the vector angle.
    PLOT                      = Plots data or functions.
    COMPLEX MULTIPLICATION    = Carries out a complex multiplication.
    POLYNOMIAL MULTIPLICATION = Carries out a polynomial multiplication.
    SET CARTESIAN PRODUCT     = Carries out a set cartesian product.
    MATRIX MULTIPLICATION     = Carries out a matrix multiplication.
 
Applications:
    Mathematics
 
Implementation Date:
    87/10
 
Program:
    LET Y1 = DATA 4 2 3 1 6
    LET Y2 = DATA 1 2 4 6 3
    LET A = VECTOR DOT PRODUCT Y1 Y2
    WRITE Y1 Y2 A
 
-----VECTOR FORMAT--------------------------------------------------

VECTOR FORMAT

Name:
    VECTOR FORMAT

Type:
    Support Command

Purpose:
    Specifies the format of the data for the VECTOR PLOT command.

Description:
    Vectors can be defined in three ways:
       1) As a pair of points;
       2) As a starting point and the change in the vertical and
          horizontal directions;
       3) As a starting point and an angle and a vector length.

Syntax:
    VECTOR FORMAT  <POINT/DELTA/ANGLE>
    where POINT specifies a pair of points, DELTA specifies a
             starting point and horizontal and vertical changes, and
             ANGLE specifies a starting point and an angle and a
             vector length.

Examples:
    VECTOR FORMAT POINT
    VECTOR FORMAT DELTA
    VECTOR FORMAT ANGLE

Default:
    Vectors are specified as pairs of points.

Synonyms:
    None

Related Commands:
    VECTOR PLOT  = Generates a vector plot.

Applications:
    XX

Implementation Date:
    92/8

Program:
    READ Y1 X1 Y2 X2
      0.1000000E+02 -0.1524000E+02  0.1051449E+02 -0.1734317E+02
      0.1000000E+02 -0.1397000E+02  0.1094621E+02 -0.1644858E+02
      0.1000000E+02 -0.1143000E+02  0.1378484E+02 -0.1588376E+02
      0.1000000E+02 -0.1016000E+02  0.1672586E+02 -0.1649936E+02
      0.1000000E+02 -0.8890000E+01  0.1808503E+02 -0.1553822E+02
      0.1000000E+02 -0.7620000E+01  0.1995356E+02 -0.1463254E+02
      0.1000000E+02 -0.6350000E+01  0.2206867E+02 -0.1353830E+02
      0.1000000E+02 -0.5080000E+01  0.2215228E+02 -0.1128796E+02
      0.1000000E+02 -0.3810000E+01  0.1978718E+02 -0.8024862E+01
      0.1000000E+02 -0.2540000E+01  0.1635728E+02 -0.4799302E+01
      0.1000000E+02 -0.1270000E+01  0.1361335E+02 -0.2298972E+01
      0.1000000E+02  0.0000000E+00  0.1239326E+02 -0.5136330E+00
      0.1000000E+02  0.1270000E+01  0.1173628E+02  0.1501220E+01
      0.1000000E+02  0.2540000E+01  0.1153493E+02  0.2589486E+01
      0.1000000E+02  0.3810000E+01  0.1203320E+02  0.3974670E+01
      0.1000000E+02  0.5080000E+01  0.1404934E+02  0.5650798E+01
      0.1000000E+02  0.6350000E+01  0.1606889E+02  0.7883220E+01
      0.1000000E+02  0.7620000E+01  0.1955596E+02  0.1140826E+02
      0.1000000E+02  0.8890000E+01  0.2272479E+02  0.1506554E+02
      0.1000000E+02  0.1016000E+02  0.2338944E+02  0.1776808E+02
      0.1000000E+02  0.1143000E+02  0.2053801E+02  0.1859783E+02
      0.1000000E+02  0.1270000E+02  0.1738284E+02  0.1887298E+02
      0.1000000E+02  0.1397000E+02  0.1535987E+02  0.1946041E+02
      0.1000000E+02  0.1524000E+02  0.1346489E+02  0.1979359E+02
    END OF DATA
    .
    CHARACTER VECTOR ALL
    CHARACTER HW 0.3 0.6 ALL
    VECTOR ARROW OPEN
    VECTOR FORMAT POINT
    VECTOR PLOT Y1 X1 Y2 X2
 
-----VECTOR LENGTH (LET)-----------------------------------------
 
VECTOR LENGTH (LET)
 
Name:
    VECTOR LENGTH
 
Type:
    Subcommand under LET
 
Purpose:
    Compute the length (or norm) of a vector with real elements.
 
Description:
    The formula for vector length is:
        ||V|| = SQRT(SUM(Yi**2))
 
Syntax:
    LET <p> = VECTOR LENGTH <v>  <SUBSET/EXCEPT/FOR qualification>
    where <v> is the variable whose elements are the (real) elements of
              the vector;
          <p> is the parameter where the computed length is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional and
               rarely used in this context.
 
Examples:
    LET L  = VECTOR LENGTH Y
    LET L  = VECTOR LENGTH Y SUBSET Y > 10
    LET L  = VECTOR LENGTH Y FOR I = 1 1 3
 
Note:
    The vector (x1, x2, ... ,xn) represents the line segment from the
    origin (0,0,...,0) to the point (x1, x2, ..., xn).  That is, each
    element of the vector represents the corresponding value on the
    corresponding axis.  Vectors are sometimes represented in terms of
    the unit coordinate vectors.  For example, for the 3d case:
        i = (1,0,0)
        j = (0,1,0)
        l = (0,0,1)
    Then the vector x=(x1,x2,x3) can be written as a=x1*i + x2*j + x3*k.
 
Note:
    Storagewise, a Dataplot "variable" and a mathematical "vector" are
    identical.  The ordering of elements within a Dataplot variable is
    identical to the ordering of elements within a mathematical vector.
    Thus to store the vector with elements 4 11 37 8 19 in the variable
    Y, do the following:
          SERIAL READ Y
          4 11 37 8 19
          END OF DATA
    or
          LET Y = DATA 4 11 37 8 19
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LET                       = Evaluates general functions.
    VECTOR ADDITION           = Carries out a vector addition.
    VECTOR SUBTRACTION        = Carries out a vector subtraction.
    VECTOR DOT PRODUCT        = Computes a vector dot product.
    VECTOR DISTANCE           = Computes the vector distance.
    VECTOR ANGLE              = Computes the vector angle.
    PLOT                      = Plots data or functions.
    SET CARDINALITY           = Computes the set cardinality.
    MATRIX DETERMINANT        = Computes the matrix determinant.
    MATRIX EUCLIDEAN  NORM    = Computes the matrix euclidean norm.
    MATRIX SPECTRAL NORM      = Computes the matrix spectral norm.
    MATRIX SPECTRAL  RADIUS   = Computes the matrix spectral radius.
 
Applications:
    Mathematics
 
Implementation Date:
    87/10
 
Program:
    LET Y = DATA 4 2 3 1 6
    LET L = VECTOR LENGTH Y
    WRITE Y L
    .  FIND THE DIRECTION COSINES AND DIRECTION ANGLES
    LET N = SIZE Y
    LOOP FOR K = 1 1 N
        LET TEMP = Y(1)
        LET TEMP = TEMP/L
        LET DIRCOS(K) = TEMP
        LET TEMP = ARCCOS(TEMP)
        LET DIRANGLE(K) = TEMP
    END OF LOOP
    WRITE DIRCOS DIRANGLE
 
-----VECTOR PERCENTILE (LET)-----------------------------------------
 
VECTOR PERCENTILE
 
Name:
    VECTOR PERCENTILE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Generate a vector of percentiles from a response variable.
 
Description:
    For response variables with a large number of rows, many desired
    graphs and statistical tests may become impractical.  One approach
    to dealing with this is to replace the response variable with a
    specified number of percentiles of the data.  For example, we
    might replace 1,000,000 or more rows of data with 1,000 or 10,000
    percentiles.  This approach can make certain analysis more practical
    without removing too much information.  One limitation of this
    approach is that we are throwing away the order of the data.  So
    for graphs and tests were order is important, this approach is not
    valid.  However, for many graphs and tests, this can make dealing
    with large data sets more managable.

    The p-th percentile of a data set is defined as that value where p
    percent of the data is below that value and (1-p) percent of the data
    is above that value.  For example, the 50th percentile is the median.
 
    The default method for computing percentiles in Dataplot is
    based on the order statistic.  The formula is:

       X(p) = (1 - r)*X(NI1) + r*X(NI2)

    where

       X are the observations sorted in ascending order
       NI1 = INT(p*(N+1))
       NI2 = NI1 + 1
       r = p*(N+1) - INT(p*(N+1))

    If p is < 1/(N+1), then X(1) is returned.  If p > N/(N+1), then X(N)
    is returned.

    The above is for a single percentile.  For the VECTOR PERCENTILE
    command, you specify the number of percentiles that you would like
    to compute.  Dataplot will then generate the appropriate values for p
    in the above formulas.

Syntax 1:
    LET <y> = VECTOR PERCENTILE <x> <nperc>
                                <SUBSET/EXCEPT/FOR qualification>
    where <x> is the response variable;
          <nperc> is a number or parameter that specifies the number of
              percentiles to generate;
          <y> is a variable where the computed percentiles are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y = VECTOR PERCENTILE X 1000
    LET Y = VECTOR PERCENTILE X 10000
    LET Y = VECTOR PERCENTILE X NPERC
    LET Y = VECTOR PERCENTILE X NPERC  SUBSET X > 0

Note:
    Note that there are a number of other ways of calculating percentiles
    in common use.  Hyndman and Fan (1996) in an American Statistician
    article evaluated nine different methods (we will refer to these as R1
    through R9) for computing percentiles relative to six desirable
    properties. Their goal was to advocate a "standard" definition for
    percentiles that would be implemented in statistical software. Although
    this has not in fact happened, the article does provide a useful
    summary and evaluation of various methods for computing percentiles.
    Most statistical and spreadsheet software use one of the methods
    described in Hyndman and Fan.

    The default method used by Dataplot described above corresponds to
    method R6 of Hyndman and Fan.  The description of the methods
    here will be in terms of the quantile q = p/100 (where p is
    the desired percentile).

    The method advocated by Hyndman and Fan is R8. For the R8 method,

       X(q) = X(NI1) + r*(X(NI2) - X(NI1))

    where

       X are the observations sorted in ascending order
       NI1 = INT(q*(N+(1/3)) + (1/3))
       NI2 = NI1 + 1
       r = q*(N+1) - INT(q*(N+1))

    If q <= (2/3)/(N+(1/3)) the minimum value will be returned and
    if q >= (N-(1/3))/(N+(1/3)) the maximum value will be returned.

    Method R7 (this is the default method in R and Excel) is calculated by

       X(q) = X(NI1) + r*(X(NI2) - X(NI1))

    where

       X are the observations sorted in ascending order
       NI1 = INT(q*(N-1) + 1)
       NI2 = NI1 + 1
       r = q*(N+1) - INT(q*(N+1))

    If q = 1, then X(N) is returned.

    The R6, R7, and R8 methods give fairly similar, but not exactly the
    same (particularly for small samples), results.  For most purposes,
    any of these three methods should be acceptable.

Note:
    The following command is used to determine which method
    is used to compute the percentile:

         SET QUANTILE METHOD <ORDER/R6/R7/R8>

    R6 is equivalent to ORDER.

Default:
    The ORDER STATISTIC (R6) method is the default method for calculating
    percentiles.
 
Synonyms:
    None
 
Related Commands:
    PERCENTILE          = Compute a specified percentile.
    QUANTILE            = Compute a specified quantile.
    MEDIAN              = Compute the median.
    LOWER QUARTILE      = Compute the lower quartile.
    UPPER QUARTILE      = Compute the upper quartile.
    FIRST DECILE        = Compute the first decile (the 10th percentile).
 
Reference:
    Hyndman and Fan (November 1996), "Sample Quantiles in Statistical
    Packages", The American Statistician, Vol. 50, No. 4, pp. 361-365.

Applications:
    Data Analysis
 
Implementation Date:
    2016/06
 
Program:
    . Step 1:   Generate the raw data
    .
    let y = normal rand numb for i = 1 1 1000000
    .
    . Step 2:   Compute the desired percentiles
    .
    let nperc = 1000
    let yperc = vector percentiles y nperc
    .
    . Step 3:   Plot the percentiles
    .
    character circle
    character hw 1 0.75
    character fill on
    line blank
    title Plot of 1,000 Percentiles Based on 1,000,000 Points
    y1label Percentile Value
    .
    plot yperc

-----VECTOR PLOT--------------------------------------
 
VECTOR PLOT
 
Name:
    VECTOR PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a vector plot.
 
Description:
    A vector plot is a plot in which pairs of points are drawn as
    vectors.  That is, an arrow is drawn from the first point to the
    second point.  Several formats for storing the vectors are
    supported.
 
Syntax 1:
    VECTOR PLOT <y1> <x1> <y2> <x2> <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable containing the y coordinates for the
               first point;
          <x1> is a variable containing the x coordinates for the
               first point;
          <y2> is a variable containing the y coordinates for the
               second point;
          <x2> is a variable containing the x coordinates for the
               second point;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    VECTOR PLOT <y1> <x1> <ydelta> <xdelta>
               <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable containing the y coordinates for the
               first point;
          <x1> is a variable containing the x coordinates for the
               first point;
          <ydelta> is a variable containing the change in the vertical
               direction from the first point to the second point;
          <xdelta> is a variable containing the change in the
               horizontal direction from the first point to the second
               point;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 3:
    VECTOR PLOT <y1> <x1> <angle> <length>
               <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable containing the y coordinates for the
               first point;
          <x1> is a variable containing the x coordinates for the
               first point;
          <angle> is a variable containing the angle between the two
               points;
          <length> is a variable containing the length of the vector
               between the two points;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    VECTOR PLOT Y1 X1 Y2 X2
 
    VECTOR FORMAT DELTA
    VECTOR PLOT Y1 X1 YDEL XDEL
 
    VECTOR FORMAT ANGLE
    VECTOR PLOT Y1 X1 ANGLE LENGTH
 
Note:
    The VECTOR FORMAT command specifies which syntax to use.  The
    default is syntax 1 (i.e., specify the coordinates of the two
    points).  VECTOR FORMAT DELTA specifies syntax 2 and VECTOR FORMAT
    ANGLE specifies syntax 3.
 
Note:
    The line style, thickness, and color of the line segment portion of
    the arrow are set by the LINE, LINE THICKNESS, and LINE COLOR
    commands respectively.  The size of the arrowhead is set by the
    CHARACTER HW or CHARACTER SIZE command.  The CHARACTER FILL command
    specifies whether the arrow head is filled or hollow.
 
Note:
    The following two commands affect the appearance of the arrow head.
           VECTOR ARROW <FIXED or VARAIABLE>
           VECTOR ARROW <OPEN or CLOSED>
    Entering FIXED means all the arrow heads are drawn the same size.
    Entering VARIABLE means that the size of the arrow head is scaled
    to the length of the longest vector.  The arrow head is drawn as a
    triangle.  Entering OPEN specifies that the base of the triangle is
    not drawn while entering CLOSED specifies that it is.  The defaults
    are FIXED and CLOSED.
 
Note:
    The VECTOR PLOT command currently supports only 2D plots.  A 3D
    vector plot can be generated with a little more effort.   You can
    do something like the following:
        READ X Y Z TAG
        x1 y1 z1  1
        x2 y2 z2  1
        x3 y3 z3  2
        x4 y4 z4  2
          ...
        END OF DATA
        CHARACTER VECTOR ALL
        3D-PLOT Z Y X TAG
    The key is that the TAG variable identifies pairs of points (i.e.,
    the starting point and the ending point).  Setting the character
    type to VECTOR specifies that an arrow is drawn between pairs of
    points with the same value for TAG.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    VECTOR FORMAT   = Specify the data format for vector plots.
    VECTOR ARROW    = Specify the attributes of the arrow for vector
                      plots.
    LINES           = Sets the type for plot lines.
    LINE COLOR      = Sets the color for plot lines.
    LINE THICKNESS  = Sets the thickness for plot lines.
    CHARACTER       = Sets the type for plot characters.
    CHARACTER HW    = Sets the height and width for plot characters.
    CHARACTER SIZE  = Sets the size for plot characters.
    CHARACTER FILL  = Sets the fill switch for plot characters.
    CHARACTER COLOR = Sets the color for plot characters.
    PLOT            = Generates a data or function plot.
 
Applications:
    XX
 
Implementation Date:
    92/10
 
Program:
    LET X1 = SEQUENCE 1 1 10 FOR I = 1 1 100
    LET Y1 = SEQUENCE 1 10 1 10
    LET XDELTA = UNIFORM RANDOM NUMBERS FOR I = 1 1 100
    LET YDELTA = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET YDELTA = YDELTA/3
    .
    CHARACTER VECTOR ALL
    CHARACTER HW 0.3 0.6 ALL
    VECTOR ARROW OPEN
    LIMITS 1 10
    TIC OFFSET 1 1
    .
    VECTOR FORMAT DELTA
    VECTOR PLOT Y1 X1 YDELTA XDELTA
 
-----VECTOR SUBTRACTION (LET)------------------------------------
 
VECTOR SUBTRACTION (LET)
 
Name:
    VECTOR SUBTRACTION
 
Type:
    Subcommand under LET
 
Purpose:
    Carry out the subtraction of 2 vectors (with real elements).
 
Syntax:
    LET <v3> = VECTOR SUBTRACTION <v1> <v2>
                      <SUBSET/EXCEPT/FOR/qualification>
    where <v1> is the variable whose elements are the (real) elements of
               the first vector;
          <v2> is the variable whose elements are the (real) elements of
               the second vector;
          <v3> is the variable whose elements are the (real) elements of
               the resultant vector;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional and
               rarely used in this context.
 
Examples:
    LET Y3  = VECTOR SUBTRACTION Y1 Y2
    LET Y3  = VECTOR SUBTRACTION Y1 Y2 SUBSET Y1 > 10
    LET Y3  = VECTOR SUBTRACTION Y1 Y2 FOR I = 1 1 3
 
Note:
    The vector (x1, x2, ... ,xn) represents the line segment from the
    origin (0,0,...,0) to the point (x1, x2, ..., xn).  That is, each
    element of the vector represents the corresponding value on the
    corresponding axis.  Vectors are sometimes represented in terms of
    the unit coordinate vectors.  For example, for the 3d case:
        i = (1,0,0)
        j = (0,1,0)
        l = (0,0,1)
    Then the vector x=(x1,x2,x3) can be written as a=x1*i + x2*j + x3*k.
 
Note:
    Storagewise, a Dataplot "variable" and a mathematical "vector" are
    identical.  The ordering of elements within a Dataplot variable is
    identical to the ordering of elements within a mathematical vector.
    Thus to store the vector with elements 4 11 37 8 19 in the variable
    Y, do the following:
          SERIAL READ Y
          4 11 37 8 19
          END OF DATA
    or
          LET Y = DATA 4 11 37 8 19
 
Default:
    None
 
Synonyms:
    The command LET Y3 = VECTOR SUBTRACTION Y1 Y2 is equivalent to the
    command LET Y3 = Y2 - Y1.
 
Related Commands:
    LET                       = Evaluates general functions.
    VECTOR ADDITION           = Carries out a vector addition.
    VECTOR DOT PRODUCT        = Computes a vector dot product.
    VECTOR LENGTH             = Computes the vector length.
    VECTOR DISTANCE           = Computes the vector distance.
    VECTOR ANGLE              = Computes the vector angle.
    COMPLEX SUBTRACTION       = Carries out a complex subtraction.
    SET INTERSECTION          = Carries out a set intersection.
    LOGICAL OR                = Carries out a logical or.
    MATRIX SUBTRACTION        = Carries out a matrix subtraction.
    PLOT                      = Plots data or functions.
 
Applications:
    Mathematics
 
Implementation Date:
    87/10
 
Program:
    LET Y1 = DATA 4 2 3 1 6
    LET Y2 = DATA 1 2 4 6 3
    LET Y3 = VECTOR SUBTRACTION Y1 Y2
    SET WRITE DECIMALS 0
    WRITE Y1 Y2 Y3
 
-----VERSUS-------------------------------------------------------

VERSUS

Name:
    VERSUS

Type:
    Keyword

Purpose:
    Allows one or more variables to be plotted against one another
    (in the PLOT command).

Syntax:
    None

Examples:
    PLOT Y1 Y2 Y3 Y4 Y5 VERSUS X
    PLOT Y PRED VERSUS X
    PLOT Y1 VERSUS X1  Y2 VERSUS X2

Default:
    None

Synonyms:
    VS or VS. can be used as abbreviations for VERSUS.

Related Commands:
    PLOT    = Generate a data or function plot.

Applications:
    XX

Implementation Date:
    XX

Program:
    . POLLUTION SOURCE ANALYSIS, LLOYD CURRIE, DATE--1990
    . SUBSET OF CURRIE.DAT REFERENCE FILE
    .
    LET LEAD = DATA ...
      164 426 59 98 312 263 607 497 213 54 160 262 547 325 419 94 70
    LET POT = DATA ...
      106 175 61 79 94 121 424 328 107 218 140 179 246 231 245 339 99
    LET N = SIZE LEAD; LET X = SEQUENCE 1 1 N
    .
    LINE BLANK ALL
    CHARACTER CIRCLE SQUARE
    CHARACTER FILL ON ON
    LEGEND 1 CIRC() - POTASSIUM
    LEGEND 2 SQUA() - LEAD
    LEGEND FONT SIMPLEX
    LEGEND FILL ON
    X1LABEL SEQUENCE
    TITLE AUTOMATIC
    PLOT POT LEAD VS X
 
-----VERTICAL SPACING-------------------------------------------------
 
VERTICAL SPACING
 
Name:
    VERTICAL SPACING
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Specifies the vertical spacing between text lines from subsequent
    TEXT commands.
 
Description:
    The vertical spacing between text lines is from the visible bottom
    of a character on one line to the visible top of a character on the
    next line.  The height of the characters themselves is not counted
    (that is controlled by the HEIGHT command).  The vertical spacing
    is in decimal units of 0 to 100.  A vertical spacing of 0 would be
    negligibly small while a vertical spacing of 100 would be full
    screen vertical distance.
 
Syntax:
    VERTICAL SPACING   <n>
    where <n> is a decimal number or parameter in the decimal range 0
              to 100 that specifies the desired vertical spacing.
 
Examples:
    VERTICAL SPACING 10
    VERTICAL SPACING 3
    VERTICAL SPACING 2.55
    VERTICAL SPACING H
 
Note:
    The VERTICAL SPACING command with no arguments reverts the vertical
    spacing to the default.
 
Default:
    The vertical spacing is 1.0.
 
Synonyms:
    None
 
Related Commands:
    TEXT               = Writes a text string.
    TITLE SIZE         = Sets the height of the plot title.
    LABEL SIZE         = Sets the height of the plot labels.
    LEGEND SIZE        = Sets the height of the plot legends.
    TIC LABEL SIZE     = Sets the height of the plot tic mark labels.
    LEGEND HW          = Sets the height and width of the plot legends.
    TIC LABEL HW       = Sets the height and width of the plot tic
                         mark labels.
    HEIGHT             = Sets the height for TEXT characters.
    WIDTH              = Sets the width for TEXT characters.
    HW                 = Sets the height and width for TEXT characters.
    HORIZONTAL SPACING = Sets the horizontal spacing between text
                         characters.
    FONT               = Sets the font for TEXT characters.
    CASE               = Sets the case for TEXT characters.
    THICKNESS          = Sets the thickness of TEXT characters.
    COLOR              = Sets the color for TEXT characters.
    JUSTIFICATION      = Sets the justification for TEXT characters.
    CR                 = Sets the carriage return position after text.
    LF                 = Sets the line feed position after text.
    CRLF               = Sets the carriage return/line feed position
                         after text.
    MARGIN             = Sets the carriage return column after text.
    ()                 = Allows math and Greek characters in text.
    MOVE               = Moves to a point.
    CROSS-HAIR (or CH) = Activates and reads the cross-hair.
    ERASE              = Erases the screen (immediately).
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    MOVE 5 95
    MARGIN 5
    VERTICAL SPACING 6
    CRLF ON
    FONT DUPLEX
    .
    HW 4 2
    TEXT JAPAN's 6-POINT PROGRAM FOR
    VERTICAL SPACING 10
    MARGIN 10
    VERTICAL SPACING 4
    TEXT QUALITY MANUFACTURING
    HW 2.4 1.2
    TEXT CIRC() QUALITY AUDITS
    TEXT CIRC() COMPANY-WIDE QUALITY CONTROL (CWQC)
    TEXT CIRC() QUALITY TRAINING AND EDUCATION
    TEXT CIRC() APPLICATION OF STATISTICAL METHODS
    TEXT CIRC() QUALITY CIRCLE ACTIVITIES
    VERTICAL SPACING 20
    MARGIN 5
    TEXT CIRC() NATION-WIDE QUALITY CONTROL PROMOTIONAL ACTIVITIES
    HW 2 1
    TEXT SOURCE: Q.C. TRENDS WINTER 1985, PAGES 22-23.
 
-----VERTICALLY-----------------------------------------------------

VERTICALLY
Name:
    VERTICALLY
Note:
    ******* THIS COMMAND IS NOT CURRENTLY OPERATIONAL ********
Type:
    Keyword
Purpose:
    Causes traces to be plotted vertically (rather than horizontally)
    on plots.
Syntax:
    None
Examples:
    PLOT Y = 3 VERTICALLY FOR X = 0 1 10
    PLOT SIN(X) VERTICALLY FOR X = 0 .1 6
Default:
    None
Synonyms:
    None
Related Commands:
    PLOT    = Generates a data or function plot.
Applications:
    XX
Implementation Date:
    XX
Program:
    XX
 
-----VIOLIN PLOT-------------------------------------------------------
 
VIOLIN PLOT
 
Name:
    VIOLIN PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a violin plot.
 
Description:
    A violin plot is a combination of a box plot and a kernel
    density plot.  Specifically, it starts with a box plot.
    It then adds a rotated kernel density plot to each side of the
    box plot.

    Enter HELP BOX PLOT and HELP KERNEL DENSITY PLOT for
    details on the construction of box plots and kernel density
    plots, respectively.

    For the violin plot to appear as it should, the VIOLIN PLOT
    command is usually preceded by the two commands:

       CHARACTERS VIOLIN PLOT
       LINES VIOLIN PLOT

    These commands automatically define proper values for the 25
    components of the violin plot.  Note that traces 2 thru 25
    correspond to the definitions for the traces in the standard
    box plot (HELP BOX PLOT for details).  Trace 1 draws the
    kernel density portion.

    After the violin plot is formed,
    the analyst should redefine plot characters and lines via the
    usual CHARACTERS and LINES commands.
 
Syntax:
    VIOLIN PLOT   <y>   <x>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response (= dependent) variable;
          <x> is an independent variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    VIOLIN PLOT Y X
    VIOLIN PLOT Y X  SUBSET X > 2
 
Note:
    Outliers on the box plot can be identified by entering the
    FENCES ON command.  If the inter-quartile range (i.e., the
    difference between the 25% point and the 75% point) is IQ,
    then values that are between 1.5 and 3.0 times the IQ above
    (or below) the 75% point (or the 25%) point are drawn as circles
    and points that are more than 3.0 times the IQ above (or below)
    the 75% point (or the 25%) are drawn as large circles.
 
Note:
    An alternate form for the appearance of the violin plot can
    be generated by entering the commands CHARACTERS VIOLIN BOX PLOT
    and LINES VIOLIN BOX PLOT.  These draw the traditional form of
    the box plot rather than the streamlined Tufte form of the
    box plot.

    You can also define your own plot symbols with the standard
    CHARACTER and LINE commands (e.g., you may prefer to use a dash
    (-) rather than the default X.
 
Note:
    The width of the box is proportional to the number of data
    points in that box.  This only applies if the lines and
    characters are set to LINES VIOLIN BOX PLOT and
    CHARACTERS VIOLIN BOX PLOT, respectively.  For the default
    lines and character settings (LINE VIOLIN PLOT, CHARACTERS
    VIOLIN PLOT), the width of the box is not relevant.

Note:
    The following commands can be used to set ooptions for the
    kernel density plot:

        KERNEL DENSITY POINTS <value>
        KERNEL DENSITY WIDTH  <value>

    Enter HELP KERNEL DENSITY PLOT for details on these commands.

References:
    "Violin Plots: A Box Plot-Density Trace Synergism",
    Jerry L. Hintze and Ray D. Nelson, The American Statistician,
    May 1998 Vol. 52, No. 2, 181-184.

Default:
    None
 
Synonyms:
    CHARARCTER VIOLIN TUFTE BOX PLOT is equivalent to CHARACTER
    VIOLIN PLOT.  Similarly, LINES VIOLIN TUFTE BOX PLOT is
    equivalent to LINE VIOLIN PLOT.
 
Related Commands:
    BOX PLOT             = Generate a box plot.
    KERNEL DENSITY PLOT  = Generate a kernel density plot.
    CHARACTERS           = Sets the types for plot characters.
    LINES                = Sets the types for plot lines.
    REGION               = Sets the types for plot regions.
    PLOT                 = Generates a data or function plot.
 
Applications:
    Exploratory Data Analysis, Comparing Distributions
 
Implementation Date:
    2/2003
 
Program:
    SKIP 25
    READ DRAFT69B.DAT Y XJUNK X
    .
    CHARACTER VIOLIN PLOT
    LINE VIOLIN PLOT
    XLIMITS 1 12
    MAJOR XTIC MARK NUMBER 12
    MINOR XTIC MARK NUMBER 0
    XTIC OFFSET 1 1
    X1TIC MARK LABEL FORMAT ALPHA
    X1TIC MARK LABEL CONTENT JAN FEB MAR APR MAY JUN JUL AUG SEP OCT ...
       NOV DEC
    Y1LABEL DRAFT RANK
    KERNEL DENSITY POINTS 32
    .
    VIOLIN PLOT Y X
 
-----VISIBLE-------------------------------------------------------
 
VISIBLE
 
Note:
    ***** This command is not currently operational *****
 
Name:
    VISIBLE
 
Type:
    Plot Control Command
 
Purpose:
    Specifies whether or not "hidden lines" will be visible on
    subsequent 3-dimensional plots generated with the 3D-PLOT command.
 
Syntax:
    VISIBLE   <ON or OFF>
    where ON specifies that hidden lines will be visible while OFF
             specifies that they will not be visible.
 
Examples:
    VISIBLE ON
    VISIBLE OFF
    VISIBLE
 
Note:
    The VISIBLE command with no arguments is equivalent to the VISIBLE
    ON command.
 
Default:
    Hidden lines will be visible.
 
Synonyms:
    None
 
Related Commands:
    3D-PLOT            = Generates a 3-d data or function plot.
    EYE COORDINATES    = Sets the eye location for 3-d plots.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XX
 
-----VONCDF (LET)---------------------------------------
 
VONCDF
 
Name:
    VONCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Von Mises probability density function.
 
Description:
    The Von Mises distribution has the following probability density
    function:
       f(x) = EXP(b*COS(x-a)]/[2*PI*I0(b)]   -PI <= x <= PI
    where I0 is the modified Bessel function of order zero.  The
    parameter b is the shape (or concentration) parameter and a is the
    location parameter.  Dataplot evaluates the case where the
    location parameter is zero.
 
    The Von Mises distribution is a circular function with a period of
    2*PI.  If the input argument is outside the interval (-PI,PI), 
    Dataplot converts it to the equivalent argument in that interval.
    The shape parameter must be non-negative.

    A shape parameter of 0 reduces to a rectangular distribution on
    the (-PI,PI) interval.  The Von Mises distribution approaches a
    normal distribution as b gets large.  As b approaches infinity,
    the density concentrates to a single point (the location parameter
    a).

    The cumulative distribution is the area from -PI to x (i.e., the
    integral of the above function).

Syntax:
    LET <y> = VONCDF(<x>,<b>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter containing values in
              the interval (-PI,PI);
          <b> is a non-negative number, parameter, or variable;
          <y> is a variable or a parameter (depending on what <x> and
              <b> are) where the computed cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = VONCDF(0.5,0)
    LET X2 = VONCDF(X1,4)
 
Note:
    Dataplot uses the ACM algorithm 518 (see the REFERENCE section
    below) to calculate the Von Mises cdf function.  For values of b
    less than 50, a series expansion in terms of modified Bessel
    functions is used.  For larger values, a normal approximation is
    used.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    VONPDF = Compute the Von Mises probability density function.
    VONPPF = Compute the Von Mises percent point function.
    SEMCDF = Compute the semi-circular cumulative distribution
             function.
    SEMPDF = Compute the semi-circular probability density function.
    SEMPPF = Compute the semi-circular percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
 
Reference:
    "Algorithm 518, Incomplete Bessel Function I0: The Von Mises
    Distribution", Hill, ACM Transactions on Mathematical Software,
    Vol. 3, No. 3, September 1977, Pages 279-284.

    "Algorithm AS 86: The Von Mises Distribution Function", Mardia,
    Applied Statistics, 24, 1975 (pp. 268-272).

    "Statistical Distributions", 2nd. Edition, Evans, Hastings, and
    Peacock, John Wiley and Sons, 1993, (chapter 39).
 
Applications:
    XX
 
Implementation Date:
    94/10
 
Program:
    TITLE VON MISES DISTRIBUTIONS
    PLOT VONCDF(X,0) FOR X = -PI 0.1 PI AND
    PLOT VONCDF(X,0.5) FOR X = -3.1 0.1 3.1 AND
    PLOT VONCDF(X,1) FOR X = -3.1 0.1 3.1 AND
    PLOT VONCDF(X,2) FOR X = -3.1 0.1 3.1 AND
    PLOT VONCDF(X,4) FOR X = -3.1 0.1 3.1 AND
    PLOT VONCDF(X,500) FOR X = -0.5 0.01 0.5
 
-----VONPDF (LET)---------------------------------------
 
VONPDF
 
Name:
    VONPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Von Mises probability density function.
 
Description:
    The Von Mises distribution has the following probability density
    function:
       f(x) = EXP(b*COS(x-a)]/[2*PI*I0(b)]   -PI <= x <= PI
    where I0 is the modified Bessel function of order zero.  The
    parameter b is the shape (or concentration) parameter and a is the
    location parameter.  Dataplot evaluates the case where the
    location parameter is zero.
 
    The Von Mises distribution is a circular function with a period of
    2*PI.  If the input argument is outside the interval (-PI,PI), 
    Dataplot converts it to the equivalent argument in that interval.
    The shape parameter must be non-negative.

    A shape parameter of 0 reduces to a rectangular distribution on
    the (-PI,PI) interval.  The Von Mises distribution approaches a
    normal distribution as b gets large.  As b approaches infinity,
    the density concentrates to a single point (the location parameter
    a).

Syntax:
    LET <y> = VONPDF(<x>,<b>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter containing values in
              the interval (-PI,PI);
          <b> is a non-negative number, parameter, or variable;
          <y> is a variable or a parameter (depending on what <x> and
              <b> are) where the computed pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = VONPDF(0.5,0)
    LET X2 = VONPDF(X1,4)
 
Note:
    For values of b less than the logarithm of the largest double
    precision number (this is approximately 700 for 32 bit machines),
    the Von Mises probability is calculated from the definition.  The
    DBESI0 routine from the SLATEC library is used to calculate the
    modified Bessel function.  For b values larger than this, a 
    normal approximation with a standard deviation of SQRT(b-0.5) is
    used (see the Mardia paper listed in the REFERENCE section below).

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    VONCDF = Compute the Von Mises cumulative distribution function.
    VONPPF = Compute the Von Mises percent point function.
    SEMCDF = Compute the semi-circular cumulative distribution
             function.
    SEMPDF = Compute the semi-circular probability density function.
    SEMPPF = Compute the semi-circular percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
 
Reference:
    "Algorithm AS 86: The Von Mises Distribution Function", Mardia,
    Applied Statistics, 24, 1975 (pp. 268-272).

    "Algorithm 518, Incomplete Bessel Function I0: The Von Mises
    Distribution", Hill, ACM Transactions on Mathematical Software,
    Vol. 3, No. 3, September 1977, Pages 279-284.

    "Statistical Distributions", 2nd. Edition, Evans, Hastings, and
    Peacock, John Wiley and Sons, 1993, (chapter 39).
 
Applications:
    XX
 
Implementation Date:
    94/10
 
Program:
    TITLE VON MISES DISTRIBUTIONS
    PLOT VONPDF(X,0) FOR X = -PI 0.1 PI AND
    PLOT VONPDF(X,0.5) FOR X = -3.1 0.1 3.1 AND
    PLOT VONPDF(X,1) FOR X = -3.1 0.1 3.1 AND
    PLOT VONPDF(X,2) FOR X = -3.1 0.1 3.1 AND
    PLOT VONPDF(X,4) FOR X = -3.1 0.1 3.1 AND
    PLOT VONPDF(X,500) FOR X = -0.5 0.01 0.5
 
-----VONPPF (LET)--------------------------------
 
VONPPF
 
Name:
    VONPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Von Mises percent point function.
 
Description:
    The Von Mises distribution has the following probability density
    function:
       f(x) = EXP(b*COS(x-a)]/[2*PI*I0(b)]   -PI <= x <= PI
    where I0 is the modified Bessel function of order zero.  The
    parameter b is the shape (or concentration) parameter and a is the
    location parameter.  Dataplot evaluates the case where the
    location parameter is zero.
 
    The Von Mises distribution is a circular function with a period of
    2*PI.  If the input argument is outside the interval (-PI,PI), 
    Dataplot converts it to the equivalent argument in that interval.
    The shape parameter must be non-negative.

    A shape parameter of 0 reduces to a rectangular distribution on
    the (-PI,PI) interval.  The Von Mises distribution approaches a
    normal distribution as b gets large.  As b approaches infinity,
    the density concentrates to a single point (the location parameter
    a).
 
    The percent point function is the inverse of the cumulative
    distribution function.  The cumulative distribution sums the
    probability from 0 to the given x value (i.e., the integral of the
    above function).  The percent point function takes a cumulative
    probability value and computes the corresponding x value.
 
Syntax:
    LET <y> = VONPPF(<p>,<b>)  <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, variable or parameter in the range 0 to 1;
          <b> is a non-negative number, parameter, or variable;
          <y> is a parameter or variable (depending on what <p> and
              <b> are) where the computed ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = VONPPF(0.9,1)
    LET X2 = VONPPF(0.95,2)
 
Note:
    Dataplot uses a bisection method to compute the Von Mises percent
    point function.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    VONCDF = Compute the Von Mises cumulative distribution function.
    VONPDF = Compute the Von Mises probability density function.
    SEMCDF = Compute the semi-circular cumulative distribution
             function.
    SEMPDF = Compute the semi-circular probability density function.
    SEMPPF = Compute the semi-circular percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
 
Reference:
    "Algorithm 518, Incomplete Bessel Function I0: The Von Mises
    Distribution", Hill, ACM Transactions on Mathematical Software,
    Vol. 3, No. 3, September 1977, Pages 279-284.

    "Algorithm AS 86: The Von Mises Distribution Function", Mardia,
    Applied Statistics, 24, 1975 (pp. 268-272).

    "Statistical Distributions", 2nd. Edition, Evans, Hastings, and
    Peacock, John Wiley and Sons, 1993, (chapter 39).
 
Applications:
    XX
 
Implementation Date:
    94/10
 
Program:
    XLIMITS 0 1
    MAJOR XTIC NUMBER 6
    MINOR XTIC NUMBER 1
    XTIC DECIMAL 1
    YLIMITS 0 1
    YTIC OFFSET 0.05 0.05
    TITLE TRIANGULAR PERCENT POINT FUNCTIONS
    PLOT VONPPF(P,0) FOR P = 0.01 .01 0.99 AND
    PLOT VONPPF(P,0.5) FOR P = 0.01 .01 0.99 AND
    PLOT VONPPF(P,0.5) FOR P = 0.01 .01 0.99
 
---------------------------------------------------------
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 




















































































-------------------------  *W*  ZZZZZ--------------------
 
-----WALCDF (LET)--------------------------------
 
WALCDF
 
Name:
    WALCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Wald cumulative distribution function with shape
    parameter gamma.
 
Description:
    The  inverse Gaussian distribution has the following probability
    density function:
        pdf(x) = (1/sqrt(2*PI))*(sqrt(MU)/GAMMA)*(X**-1.5)*
                   (exp(-1/(2*MU*X))*(((X-MU)/GAMMA)**2)
    where GAMMA and MU are the shape and location parameters
    respectively.  It is defined for any non-negative real number.  The
    cumulative distribution is the area from 0 to x (i.e., the integral
    of the above function).  It has the form:
        igcdf(x) = norcdf((1/GAMMA)*(sqrt(X/MU) - sqrt(MU/X)) -
                   exp(2/GAMMA**2)*
                   norcdf((-1/GAMMA)*(sqrt(X/MU) + sqrt(mu/x)))
 
    The Wald cdf function is defined in terms of the inverse Gaussian
    cdf function.  Specifically,
        walcdf(x,GAMMA) = 1 - igcdf(1/x,GAMMA)
    It has the further restriction that MU = 1.
 
Syntax:
    LET <y2> = WALCDF(<y1>,GAMMA)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter containing positive values;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed Wald cdf value is stored;
          <GAMMA> is a positive number or parameter that specifies the
               shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = WALCDF(3,10)
    LET A = WALCDF(A1,10)
    LET X2 = WALCDF(X1,10)
 
Note:
    The Wald distribution approaches normality as gamma approaches
    infinity.  It is highly skewed and long tailed for small values of
    GAMMA.  It is symmetric and short tailed for large values of GAMMA.
 
Note:
    The mean of the Wald distribution is 1 and the standard deviation is
    1/GAMMA**2.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    FCDF   = Compute the F cumulative distribution function.
    FPDF   = Compute the F probability density function.
    FPPF   = Compute the F percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    TCDF   = Compute the T cumulative distribution function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    WALPDF = Compute the Wald probability density function.
    WALPPF = Compute the Wald percent point function.
    FLPDF  = Compute the Fatigue Life probability density function.
    FLPPF  = Compute the Fatigue Life percent point function.
    FLCDF  = Compute the Fatigue Life cumulative distribution function.
    IGPDF  = Compute the Inverse Gaussian probability density function.
    IGPPF  = Compute the Inverse Gaussian percent point function.
    IGCDF  = Compute the Inverse Gaussian cumulative distribution
             function.
    RIGPDF = Compute the Reciprocal Inverse Gaussian probability
             density function.
    RIGPPF = Compute the Reciprocal Inverse Gaussian percent point
             function.
    RIGCDF = Compute the Reciprocal Inverse Gaussian  cumulative
             distribution function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, 1970.
 
Applications:
    Reliability Analysis
 
Implementation Date:
    90/5
 
Program:
    TITLE PLOT WALCDF FOR VARIOUS VALUES OF GAMMA
    SEGMENT 1 COORDINATES 69 38 74 38; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 69 34 74 34; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 69 30 74 30; SEGMENT 3 PATTERN DOT
    SEGMENT 4 COORDINATES 69 26 74 26; SEGMENT 4 PATTERN DASH2
    LEGEND 1 GAMMA = 1; LEGEND 1 COORDINATES 75 37
    LEGEND 2 GAMMA = 2; LEGEND 2 COORDINATES 75 33
    LEGEND 3 GAMMA = 5; LEGEND 3 COORDINATES 75 29
    LEGEND 4 GAMMA = .5; LEGEND 4 COORDINATES 75 25
    YLIMITS 0 1; MAJOR YTIC NUMBER 6
    MINOR YTIC NUMBER 1; YTIC DECIMAL 1
    XLIMITS 0 3
    LINES SOLID DASH DOT DASH2
    PLOT WALCDF(X,1) FOR X = 0.01 0.01 3 AND
    PLOT WALCDF(X,2) FOR X = 0.5 0.01 2 AND
    PLOT WALCDF(X,5) FOR X = 0.9 0.01 1.1 AND
    PLOT WALCDF(X,0.5) FOR X = 0.1 0.01 3
 
-----WALCHAZ (LET)--------------------------------
 
WALCHAZ
 
Name:
    WALCHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Wald cumulative hazard function with shape parameter
    gamma.
 
Description:
    The  Wald distribution has the following cumulative hazard function:
        H(x) = -LOG[1 - WALCDF(x,gamma)]      x >= 0, gamma > 0
    where gamma is the shape parameter and WALCDF is the cumulative
    distribution function of the Wald distribution function
    respectively.
 
Syntax:
    LET <y> = WALCHAZ(<x>,GAMMA)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable or a parameter containing positive values;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed Wald cumulative hazard values are
               stored;
          <GAMMA> is a positive number or parameter that specifies the
               shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = WALCHAZ(3,10)
    LET A = WALCHAZ(A1,10)
    LET X2 = WALCHAZ(X1,10)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WALCDF  = Compute the Wald cumulative distribution function.
    WALPDF  = Compute the Wald probability density function.
    WALPPF  = Compute the Wald percent point function.
    WALHAZ  = Compute the Wald hazard function.
    CHSPDF  = Compute the chi-square probability density function.
    FPDF    = Compute the F probability density function.
    NORPDF  = Compute the normal probability density function.
    TPDF    = Compute the T probability density function.
    WEIPDF  = Compute the Weibull probability density function.
    FLPDF   = Compute the Fatigue Life probability density function.
    IGPDF   = Compute the Inverse Gaussian probability density function.
    RIGPDF  = Compute the Reciprocal Inverse Gaussian probability
              density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994.
 
Applications:
    Reliability Analysis
 
Implementation Date:
    1998/4
 
Program:
    TITLE AUTOMATIC
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT 2 2
    PLOT WALCHAZ(X,1) FOR X = 0.01 0.01 3
    PLOT WALCHAZ(X,2) FOR X = 0.5 0.01 2
    PLOT WALCHAZ(X,3) FOR X = 0.7 0.01 1.3
    PLOT WALCHAZ(X,0.5) FOR X = 0.1 0.01 3
    END OF MULTIPLOT
 
-----WALHAZ (LET)--------------------------------
 
WALHAZ
 
Name:
    WALHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Wald hazard function with shape parameter gamma.
 
Description:
    The  Wald distribution has the following hazard function:
        h(x) = WALPDF(x,gamma)/(1 - WALCDF(x,gamma))
                                    x >= 0, gamma > 0
    where gamma is the shape parameter and WALPDF and WALCDF are
    the probability density and cumulative distribution functions
    of the Wald distribution function respectively.
 
Syntax:
    LET <y> = WALHAZ(<x>,GAMMA)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable or a parameter containing positive values;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed Wald hazard values are stored;
          <GAMMA> is a positive number or parameter that specifies the
               shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = WALHAZ(3,10)
    LET A = WALHAZ(A1,10)
    LET X2 = WALHAZ(X1,10)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WALCDF  = Compute the Wald cumulative distribution function.
    WALPDF  = Compute the Wald probability density function.
    WALPPF  = Compute the Wald percent point function.
    WALCHAZ = Compute the Wald cumulative hazard function.
    CHSPDF  = Compute the chi-square probability density function.
    FPDF    = Compute the F probability density function.
    NORPDF  = Compute the normal probability density function.
    TPDF    = Compute the T probability density function.
    WEIPDF  = Compute the Weibull probability density function.
    FLPDF   = Compute the Fatigue Life probability density function.
    IGPDF   = Compute the Inverse Gaussian probability density function.
    RIGPDF  = Compute the Reciprocal Inverse Gaussian probability
              density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994.
 
Applications:
    Reliability Analysis
 
Implementation Date:
    1998/4
 
Program:
    TITLE AUTOMATIC
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT 2 2
    PLOT WALHAZ(X,1) FOR X = 0.01 0.01 3
    PLOT WALHAZ(X,2) FOR X = 0.5 0.01 2
    PLOT WALHAZ(X,3) FOR X = 0.7 0.01 1.3
    PLOT WALHAZ(X,0.5) FOR X = 0.1 0.01 3
    END OF MULTIPLOT
 
-----WALPDF (LET)--------------------------------
 
WALPDF
 
Name:
    WALPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Wald probability density function with shape parameter
    gamma.
 
Description:
    The  inverse Gaussian distribution has the following probability
    density function:
        pdf(x) = (1/sqrt(2*PI))*(sqrt(MU)/GAMMA)*(X**-1.5)*
                   (exp(-1/(2*MU*X))*(((X-MU)/GAMMA)**2)
    where GAMMA and MU are the shape and location parameters
    respectively.  It is defined for any non-negative real number.  The
    Wald distribution is a reparameterization of the inverse Gaussian
    distribution.  Specifically,
        walpdf(x,GAMMA) = igpdf(x,1/GAMMA**2)
    There is a further constraint that MU = 1. The WALPDF function
    evaluates this function for a given positive x value.
 
Syntax:
    LET <y2> = WALPDF(<y1>,GAMMA)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter containing positive values;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed Wald pdf values are stored;
          <GAMMA> is a positive number or parameter that specifies the
               shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = WALPDF(3,10)
    LET A = WALPDF(A1,10)
    LET X2 = WALPDF(X1,10)
 
Note:
    The Wald distribution approaches normality as gamma approaches
    infinity.  It is highly skewed and long tailed for small values of
    GAMMA.  It is symmetric and short tailed for large values of GAMMA.
 
Note:
    The mean of the Wald distribution is 1 and the standard deviation is
    1/GAMMA**2.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    FCDF   = Compute the F cumulative distribution function.
    FPDF   = Compute the F probability density function.
    FPPF   = Compute the F percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    TCDF   = Compute the T cumulative distribution function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    WALPPF = Compute the Wald percent point function.
    WALCDF = Compute the Wald cumulative distribution function.
    FLPDF  = Compute the Fatigue Life probability density function.
    FLPPF  = Compute the Fatigue Life percent point function.
    FLCDF  = Compute the Fatigue Life cumulative distribution function.
    IGPDF  = Compute the Inverse Gaussian probability density function.
    IGPPF  = Compute the Inverse Gaussian percent point function.
    IGCDF  = Compute the Inverse Gaussian cumulative distribution
             function.
    RIGPDF = Compute the Reciprocal Inverse Gaussian probability density
             function.
    RIGPPF = Compute the Reciprocal Inverse Gaussian percent point
             function.
    RIGCDF = Compute the Reciprocal Inverse Gaussian cumulative
             distribution function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, 1970.
 
Applications:
    Reliability Analysis
 
Implementation Date:
    90/5
 
Program:
    TITLE PLOT WALPDF FOR VARIOUS VALUES OF GAMMA
    SEGMENT 1 COORDINATES 69 88 74 88; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 69 84 74 84; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 69 80 74 80; SEGMENT 3 PATTERN DOT
    SEGMENT 4 COORDINATES 69 76 74 76; SEGMENT 4 PATTERN DASH2
    LEGEND 1 GAMMA = 1; LEGEND 1 COORDINATES 75 87
    LEGEND 2 GAMMA = 2; LEGEND 2 COORDINATES 75 83
    LEGEND 3 GAMMA = 3; LEGEND 3 COORDINATES 75 79
    LEGEND 4 GAMMA = .5; LEGEND 4 COORDINATES 75 75
    LINES SOLID DASH DOT DASH2
    PLOT WALPDF(X,1) FOR X = 0.01 0.01 3 AND
    PLOT WALPDF(X,2) FOR X = 0.5 0.01 2 AND
    PLOT WALPDF(X,3) FOR X = 0.7 0.01 1.3 AND
    PLOT WALPDF(X,0.5) FOR X = 0.1 0.01 3
 
-----WALPPF (LET)--------------------------------
 
WALPPF
 
Name:
    WALPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Wald percent point function with shape parameter gamma.
 
Description:
    The  inverse Gaussian distribution has the following probability
    density function:
        pdf(x) = (1/sqrt(2*PI))*(sqrt(MU)/GAMMA)*(X**-1.5)*
                   (exp(-1/(2*MU*X))*(((X-MU)/GAMMA)**2)
    where GAMMA and MU are the shape and location parameters
    respectively.  It is defined for any non-negative real number.
 
    The percent point function is the inverse of the cumulative
    distribution function (cdf).  The cdf sums the probability from 0
    to the given x value.  The percent point function takes the
    cumulative probability and computes the x value.
 
    The Wald percent point function is defined in terms of the inverse
    Gaussian percent point function.  Specifically,
        walppf(p,GAMMA) = igppf(p,1/GAMMA**2)
 
Syntax:
    LET <y2> = WALPPF(<y1>,GAMMA)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter containing values in the
               range 0 to 1;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed Wald ppf value is stored;
          <GAMMA> is a positive number or parameter that specifies the
               shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = WALPPF(0.9,10)
    LET A = WALPPF(A1,10)
    LET X2 = WALPPF(X1,10)
 
Note:
    The Wald distribution approaches normality as gamma approaches
    infinity.  It is highly skewed and long tailed for small values of
    GAMMA.  It is symmetric and short tailed for large values of GAMMA.
 
Note:
    The mean of the Wald distribution is 1 and the standard deviation is
    1/GAMMA**2.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    FCDF   = Compute the F cumulative distribution function.
    FPDF   = Compute the F probability density function.
    FPPF   = Compute the F percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    TCDF   = Compute the T cumulative distribution function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    WALPDF = Compute the Wald probability density function.
    WALCDF = Compute the Wald cumulative distribution function.
    FLPDF  = Compute the Fatigue Life probability density function.
    FLPPF  = Compute the Fatigue Life percent point function.
    FLCDF  = Compute the Fatigue Life cumulative distribution function.
    IGPDF  = Compute the Inverse Gaussian probability density function.
    IGPPF  = Compute the Inverse Gaussian percent point function.
    IGCDF  = Compute the Inverse Gaussian cumulative distribution
             function.
    RIGPDF = Compute the Reciprocal Inverse Gaussian probability
             density function.
    RIGPPF = Compute the Reciprocal Inverse Gaussian percent point
             function.
    RIGCDF = Compute the Reciprocal Inverse Gaussian cumulative
             distribution function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, 1970.
 
Applications:
    Reliability Analysis
 
Implementation Date:
    90/5
 
Program:
    TITLE PLOT WALPPF FOR VARIOUS VALUES OF GAMMA
    SEGMENT 1 COORDINATES 16 88 21 88; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 16 84 21 84; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 16 80 21 80; SEGMENT 3 PATTERN DOT
    SEGMENT 4 COORDINATES 16 76 21 76; SEGMENT 4 PATTERN DASH2
    LEGEND 1 GAMMA = 1; LEGEND 1 COORDINATES 22 87
    LEGEND 2 GAMMA = 2; LEGEND 2 COORDINATES 22 83
    LEGEND 3 GAMMA = 5; LEGEND 3 COORDINATES 22 79
    LEGEND 4 GAMMA = .5; LEGEND 4 COORDINATES 22 75
    XLIMITS 0 1; MAJOR XTIC NUMBER 6
    MINOR XTIC NUMBER 1; XTIC DECIMAL 1
    LINES SOLID DASH DOT DASH2
    YLIMITS 0 4; MAJOR YTIC MARK NUMBER 5; YTIC OFFSET 0 0.2
    PLOT WALPPF(X,1) FOR X = 0.01 .01 0.95 AND
    PLOT WALPPF(X,2) FOR X = 0.01 .01 0.99 AND
    PLOT WALPPF(X,5) FOR X = 0.01 .01 0.99 AND
    PLOT WALPPF(X,0.5) FOR X = 0.01 .01 0.95
 
-----WAKCDF (LET)--------------------------------
 
WAKCDF
 
Name:
    WAKCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Wakeby probability density function.
 
Description:
    The Wakeby distribution is defined by the transformation

        X = xi + (alpha/beta)*{1 - (1-U)**beta} -
            (gamma/delta)*{1 - (1-U)**(-delta)}

    where U is a standard uniform random variable.  That is,
    the above equation defines the percent point function for
    the Wakeby distribution.

    The parameters beta, gamma and delta are shape parameters.
    The parameter xi is a location parameter and the parameter
    alpha is a location parameter.

    The following restrictions apply to the parameters of this
    distribution:

        1. beta + delta >= 0
        2. Either beta + delta > 0 or beta = gamma = deleta = 0
        3. If gamma > 0, then delta > 0
        4. gamma >= 0
        5. alpha + gamma >= 0

    The domain of the Wakeby distribution is

        1. xi to infinity
           if delta >= 0 and gamma > 0
        2. xi to xi + (alpha/beta) - (gamma/delta)
           if delta < 0 or gamma = 0

    With three shape parameters, the Wakeby distribution can model
    a wide variety of shapes.

    The cumulative distribution function is computed by numerically
    inverting the percent point function given above.

Syntax:
    LET <y> = WAKCDF(<x>,<beta>,<gamma>,<delta>,<xi>,<alpha>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed Wakeby cdf value is stored;
          <beta> is a number, parameter, or variable that specifies the
              first shape parameter;
          <gamma> is a number, parameter, or variable that specifies the
              second shape parameter;
          <delta> is a number, parameter, or variable that specifies the
              third shape parameter;
          <xi> is a number, parameter, or variable that specifies the
              location parameter;
          <alpha> is a number, parameter, or variable that specifies the
              scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <xi> and <alpha> are omitted, they default to 0 and 1, respectively.

Examples:
    LET A = WAKCDF(1.3,2.5,6)
    LET A = WAKCDF(13,2.5,6,0,10)
    PLOT WAKCDF(X,2.5,6) FOR X = -10  0.1  10
 
Note:
    The cumulative distribution function for the Wakeby distribution
    is computed using the CDFWAK routine written by Hosking (see the
    Reference section below).

    Hoskings report and associated Fortran code can be downloaded from
    the Statlib archive at

        http://lib.stat.cmu.edu/

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WAKPDF = Compute the Wakeby probability density function.
    WAKPPF = Compute the Wakeby percent point function.
    GEPPDF = Compute the generalized Pareto probability density function.
    GEVPDF = Compute the generalized extreme value probability density
             function.
    WEIPDF = Compute the Weibull probability density function.
    LGNPDF = Compute the lognormal probability density function.
    LAMPDF = Compute the Tukey lambda probability density function.
    GLDPDF = Compute the generalized Tukey lambda probability density
             function.
    GHPDF  = Compute the g and h probability density function.
 
Reference:
    Johnson, Kotz, and Balakrishnan (1994), "Continuous Univariate
    Distribution--Volume 1", Second Edition, Wiley, pp. 44-47.

    J. R. M. Hosking (2000), "Research Report: Fortran Routines for
    use with the Method of L-Moments", IBM Research Division, T. J.
    Watson Research Center, Yorktown Heights, NY 10598.

    Hoskings (1990), "L-moments: Analysis and Estimation of Distribution
    using Linear Combinations of Order Statistics", Journal of the Royal
    Statistical Society, Series B, 52, pp. 105-124.

Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program:
    let xi = 0
    let alpha = 10
    let beta = 5
    let gamma = 1
    let delta = 0.3
    .
    plot wakcdf(x,beta,gamma,delta,xi,alpha) for x = .01 .01 15

-----WAKPDF (LET)--------------------------------
 
WAKPDF
 
Name:
    WAKPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Wakeby probability density function.
 
Description:
    The Wakeby distribution is defined by the transformation

        X = xi + (alpha/beta)*{1 - (1-U)**beta} -
            (gamma/delta)*{1 - (1-U)**(-delta)}

    where U is a standard uniform random variable.  That is,
    the above equation defines the percent point function for
    the Wakeby distribution.

    The parameters beta, gamma and delta are shape parameters.
    The parameter xi is a location parameter and the parameter
    alpha is a location parameter.

    The following restrictions apply to the parameters of this
    distribution:

        1. beta + delta >= 0
        2. Either beta + delta > 0 or beta = gamma = deleta = 0
        3. If gamma > 0, then delta > 0
        4. gamma >= 0
        5. alpha + gamma >= 0

    The domain of the Wakeby distribution is

        1. xi to infinity
           if delta >= 0 and gamma > 0
        2. xi to xi + (alpha/beta) - (gamma/delta)
           if delta < 0 or gamma = 0

    With three shape parameters, the Wakeby distribution can model
    a wide variety of shapes.

    The cumulative distribution function is computed by numerically
    inverting the percent point function given above.  The probability
    density function is then found by using the following relation
    (given on page 46 of Johnson, Kotz, and Balakrishnan):

        f(x) =  (1 - F(x))**(DELTA+1)*(ALPHA*t + GAMMA)**(-1)

    where F is the cumulative distribution function and

        t = (1 - F(x))**(beta + delta)

Syntax:
    LET <y> = WAKPDF(<x>,<beta>,<gamma>,<delta>,<xi>,<alpha>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed Wakeby pdf value is stored;
          <beta> is a number, parameter, or variable that specifies the
              first shape parameter;
          <gamma> is a number, parameter, or variable that specifies the
              second shape parameter;
          <delta> is a number, parameter, or variable that specifies the
              third shape parameter;
          <xi> is a number, parameter, or variable that specifies the
              location parameter;
          <alpha> is a number, parameter, or variable that specifies the
              scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <xi> and <alpha> are omitted, they default to 0 and 1, respectively.

Examples:
    LET A = WAKPDF(1.3,2.5,6)
    LET A = WAKPDF(13,2.5,6,0,10)
    PLOT WAKPDF(X,2.5,6) FOR X = -10  0.1  10
 
Note:
    Wakeby uniform random numbers, probability plots, and
    goodness of fit tests can be generated with the commands:

       LET BETA = <value>
       LET GAMMA = <value>
       LET DELTA = <value>
       LET Y = WAKEBY  RANDOM NUMBERS FOR I = 1 1 N
       WAKEBY PROBABILITY PLOT Y
       WAKEBY PROBABILITY PLOT Y2 X2
       WAKEBY PROBABILITY PLOT Y3 XLOW XHIGH
       WAKEBY KOLMOGOROV SMIRNOV GOODNESS OF FIT Y
       WAKEBY CHI-SQUARE GOODNESS OF FIT Y2 X2
       WAKEBY CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    The parameters of the Wakeby distribution can be estimated
    by the method of L-moments using the command

       WAKEBY MAXIMUM LIKELIHOOD Y

Note:
    The cumulative distribution function for the Wakeby distribution
    is computed using the CDFWAK routine written by Hosking (see the
    Reference section below).  Dataplot also uses Hoskings code for
    computing the L-moments parameter estimates.

    Hoskings report and associated Fortran code can be downloaded from
    the Statlib archive at

        http://lib.stat.cmu.edu/

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WAKCDF = Compute the Wakeby cumulative distribution function.
    WAKPPF = Compute the Wakeby percent point function.
    GEPPDF = Compute the generalized Pareto probability density function.
    GEVPDF = Compute the generalized extreme value probability density
             function.
    WEIPDF = Compute the Weibull probability density function.
    LGNPDF = Compute the lognormal probability density function.
    LAMPDF = Compute the Tukey lambda probability density function.
    GLDPDF = Compute the generalized Tukey lambda probability density
             function.
    GHPDF  = Compute the g and h probability density function.
 
Reference:
    Johnson, Kotz, and Balakrishnan (1994), "Continuous Univariate
    Distribution--Volume 1", Second Edition, Wiley, pp. 44-47.

    J. R. M. Hosking (2000), "Research Report: Fortran Routines for
    use with the Method of L-Moments", IBM Research Division, T. J.
    Watson Research Center, Yorktown Heights, NY 10598.

    Hoskings (1990), "L-moments: Analysis and Estimation of Distribution
    using Linear Combinations of Order Statistics", Journal of the Royal
    Statistical Society, Series B, 52, pp. 105-124.

Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program:
    let xi = 0
    let alpha = 10
    let beta = 5
    let gamma = 1
    let delta = 0.3
    .
    plot wakpdf(x,beta,gamma,delta,xi,alpha) for x = .01 .01 15
    .
    let y = wakeby rand numb for i = 1 1 1000
    class lower 0
    let a = maximum y
    class upper a
    relative hist y
    limits freeze
    pre-erase off
    plot wakpdf(x,beta,gamma,delta,xi,alpha) for x = .01 .01 15
    limits
    pre-erase on
    .
    let xisv = xi
    let alphasv = alpha
    let betasv = beta
    let gammasv = gamma
    let deltasv = delta
    .
    wakeby mle y
    let xi    = xilmom
    let alpha = alphalmo
    let beta  = betalmom
    let gamma = gammalmo
    let delta = deltalmo
    .
    wakeby kolmogorov smirnov goodness of fit y
    .
    char x
    line blank
    y1label Data
    x1label Theoretical
    wakeby probability plot y

-----WAKPPF (LET)--------------------------------
 
WAKPPF
 
Name:
    WAKPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Wakeby percent point function.
 
Description:
    The Wakeby distribution is defined by the transformation

        X = xi + (alpha/beta)*{1 - (1-U)**beta} -
            (gamma/delta)*{1 - (1-U)**(-delta)}

    where U is a standard uniform random variable.  That is,
    the above equation defines the percent point function for
    the Wakeby distribution.

    The parameters beta, gamma and delta are shape parameters.
    The parameter xi is a location parameter and the parameter
    alpha is a location parameter.

    The following restrictions apply to the parameters of this
    distribution:

        1. beta + delta >= 0
        2. Either beta + delta > 0 or beta = gamma = deleta = 0
        3. If gamma > 0, then delta > 0
        4. gamma >= 0
        5. alpha + gamma >= 0

    The domain of the Wakeby distribution is

        1. xi to infinity
           if delta >= 0 and gamma > 0
        2. xi to xi + (alpha/beta) - (gamma/delta)
           if delta < 0 or gamma = 0

    With three shape parameters, the Wakeby distribution can model
    a wide variety of shapes.

Syntax:
    LET <y> = WAKPPF(<p>,<beta>,<gamma>,<delta>,<xi>,<alpha>)
              <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or variable in the interval (0,1);
          <y> is a variable or a parameter (depending on what
              <p> is) where the computed Wakeby ppf value is stored;
          <beta> is a number, parameter, or variable that specifies the
              first shape parameter;
          <gamma> is a number, parameter, or variable that specifies the
              second shape parameter;
          <delta> is a number, parameter, or variable that specifies the
              third shape parameter;
          <xi> is a number, parameter, or variable that specifies the
              location parameter;
          <alpha> is a number, parameter, or variable that specifies the
              scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <xi> and <alpha> are omitted, they default to 0 and 1, respectively.

Examples:
    LET A = WAKPPF(1.3,2.5,6)
    LET A = WAKPPF(13,2.5,6,0,10)
    PLOT WAKPPF(X,2.5,6) FOR X = -10  0.1  10
 
Note:
    The percent point function for the Wakeby distribution is computed
    using the QUAWAK routine written by Hosking (see the Reference section
    below).

    Hoskings report and associated Fortran code can be downloaded from
    the Statlib archive at

        http://lib.stat.cmu.edu/

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WAKPDF = Compute the Wakeby probability density function.
    WAKCDF = Compute the Wakeby cumulative distribution function.
    GEPPDF = Compute the generalized Pareto probability density function.
    GEVPDF = Compute the generalized extreme value probability density
             function.
    WEIPDF = Compute the Weibull probability density function.
    LGNPDF = Compute the lognormal probability density function.
    LAMPDF = Compute the Tukey lambda probability density function.
    GLDPDF = Compute the generalized Tukey lambda probability density
             function.
    GHPDF  = Compute the g and h probability density function.
 
Reference:
    Johnson, Kotz, and Balakrishnan (1994), "Continuous Univariate
    Distribution--Volume 1", Second Edition, Wiley, pp. 44-47.

    J. R. M. Hosking (2000), "Research Report: Fortran Routines for
    use with the Method of L-Moments", IBM Research Division, T. J.
    Watson Research Center, Yorktown Heights, NY 10598.

    Hoskings (1990), "L-moments: Analysis and Estimation of Distribution
    using Linear Combinations of Order Statistics", Journal of the Royal
    Statistical Society, Series B, 52, pp. 105-124.

Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program:
    let xi = 0
    let alpha = 10
    let beta = 5
    let gamma = 1
    let delta = 0.3
    .
    plot wakppf(p,beta,gamma,delta,xi,alpha) for p = 0.01  0.01  0.99

-----WARCDF (LET)--------------------------------
 
WARCDF
 
Name:
    WARCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Waring cumulative distribution function.
 
Description:
    The Waring distribution has the following probability
    mass function:

       p(x,c,a) = (c-a)(a+x-1)!c!/[c(a-1)!(c+x)!]
                  x = 0, 1, 2, ...

    where c and a are positive shape parameters with c being
    larger than a.

    The Waring distribution is mathematically equivalent to
    the beta-geometric distribution (shifted to start at x = 0)
    where

        beta  = a
        alpha = c - a

    Dataplot uses this equivalence to compute the Waring
    cumulative distribution function.  Enter HELP BGECDF for
    details of the beta-geometric distribution.

 
Syntax:
    LET <y2> = WARCDF(<y1>,<c>,<a>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a positive integer number, parameter, or variable;
          <c> is a positive number, parameter, or variable that
               specifies the first shape parameter;
          <a> is a positive number, parameter, or variable that
               specifies the second shape parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed Waring cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If the <a> parameter is omitted or set to 1, this routine
    calculates the Yule cumulative distribution function.  If <a> is
    larger than <c>, an error message is printed.

Examples:
    LET A = WARCDF(3,3,0.5)
    LET A = WARCDF(10,2)
    LET X2 = WARCDF(X1,C,A)

Note:
    The Waring distribution is a generalization of the Yule 
    distribution.  The Yule distribution is a special case of
    the Waring distribution with a = 1.  The Yule distribution
    is often given in the following form:

       p(x,p) = p(p!)(x-1)!/(y+p)!              y = 1, 2, ...

    where p is a positive parameter.

    In the Dataplot WARPDF routine, if the a parameter is omitted
    or set to 1, the formula for the Yule distribution is used
    rather than the Waring distribution formula.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WARPDF = Compute the Waring probability mass function.
    WARPPF = Compute the Waring percent point function.
    BGEPDF = Compute the beta-geometric probability mass function.
    GEOPDF = Compute the geometric probability mass function.
    NBPDF  = Compute the negative binomial probability mass
             function.
    DLGPDF = Compute the logarithmic series probability mass
             function.
 
Reference:
    "Discrete Univariate Distributions", 2nd. ed., Johnson, Kotz,
    and Kemp, John Wiley & Sons, 1994 (pp. 274-279).

    J. O. Irwin (1963), "The Place of Mathematics in Medical and
    Biological Statistics", Journal of the Royal Statistical
    Society, Series A, 126, pp. 1-44.

Applications:
    Distributional Modeling
 
Implementation Date:
    1995/4
    2006/7: Use BGECDF to compute the probabilities
 
Program 1:
    LET ZA = DATA 0.5 0.5 0.5 0.5 2.0 2.0 2.0 2.0 4.0 4.0 4.0 4.0
    LET ZC = DATA 0.6 1.0 1.5 2.0 2.1 3.0 4.0 5.0 4.1 5.0 6.0 8.0
    TITLE AUTOMATIC
    XTIC OFFSET 0.5 0.5
    SPIKE ON
    LINE BLANK
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    MULTIPLOT 4 3
    LOOP FOR K = 1 1 12
       LET A = ZA(K)
       LET C = ZC(K)
       X1LABEL A = ^A
       X2LABEL C = ^C
       PLOT WARCDF(X,C,A) FOR X = 0 1 30
    END OF LOOP
    END OF MULTIPLOT
 
Program 2:
    LET Z = SEQUENCE 0.2 0.2 2.4
    TITLE AUTOMATIC
    XTIC OFFSET 0.5 0.5
    SPIKE ON
    LINE BLANK
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    MULTIPLOT 4 3
    LOOP FOR K = 1 1 12
       LET P = Z(K)
       X1LABEL YULE DISTRIBUTION, P = ^P
       PLOT WARCDF(X,P) FOR X = 1 1 50
    END OF LOOP
    END OF MULTIPLOT

-----WARPDF (LET)--------------------------------
 
WARPDF
 
Name:
    WARPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Waring probability mass function.
 
Description:
    The Waring distribution has the following probability
    mass function:

       p(x,c,a) = (c-a)(a+x-1)!c!/[c(a-1)!(c+x)!]
                  x = 0, 1, 2, ...

    where c and a are positive shape parameters with c being
    larger than a.

    The Waring distribution is mathematically equivalent to
    the beta-geometric distribution (shifted to start at x = 0)
    where

        beta  = a
        alpha = c - a

    Dataplot uses this equivalence to compute the Waring
    probability mass function.  Enter HELP BGEPDF for details
    of the beta-geometric distribution.

Syntax:
    LET <y2> = WARPDF(<y1>,<c>,<a>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a positive integer number, parameter, or variable;
          <c> is a positive number, parameter, or variable that
               specifies the first shape parameter;
          <a> is a positive number, parameter, or variable that
               specifies the second shape parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed Waring pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If the <a> parameter is omitted or set to 1, this routine
    calculates the Yule probability mass function.  If <a> is
    larger than <c>, an error message is printed.

Examples:
    LET A = WARPDF(3,3,0.5)
    LET A = WARPDF(10,2)
    LET X2 = WARPDF(X1,C,A)

Note:
    The Waring distribution is a generalization of the Yule 
    distribution.  The Yule distribution is a special case of
    the Waring distribution with a = 1.  The Yule distribution
    is often given in the following form:

       p(x,p) = p(p!)(x-1)!/(y+p)!              y = 1, 2, ...

    where p is a positive parameter.

    In the Dataplot WARPDF routine, if the a parameter is omitted
    or set to 1, the formula for the Yule distribution is used
    rather than the Waring distribution formula.
 
Note:
    For a number of commands utilizing the Waring distribution,
    it is convenient to bin the data.  There are two basic ways
    of binning the data.

      1) For some commands (histograms, maximum likelihood
         estimation), bins with equal size widths are
         required.  This can be accomplished with the
         following commands:

            LET AMIN = MINIMUM Y
            LET AMAX = MAXIMUM Y
            LET AMIN2 = AMIN - 0.5
            LET AMAX2 = AMAX + 0.5
            CLASS MINIMUM AMIN2
            CLASS MAXIMUM AMAX2
            CLASS WIDTH 1
            LET Y2 X2 = BINNED

      2) For some commands, unequal width bins may be
         helpful.  In particular, for the chi-square goodness
         of fit, it is typically recommended that the minimum
         class frequency be at least 5.  In this case, it may
         be helpful to combine small frequencies in the tails.
         Unequal class width bins can be created with the
         commands

            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = INTEGER FREQUENCY TABLE Y

         If you already have equal width bins data, you can
         use the commands
         
            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = COMBINE FREQUENCY TABLE Y2 X2

         The MINSIZE parameter defines the minimum class
         frequency.  The default value is 5.

Note:
    You can generate Waring random numbers, probability plots,
    and chi-square goodness of fit tests with the following
    commands:

       LET A = <value>
       LET C = <value>
       LET Y = WARING RANDOM NUMBERS FOR I = 1 1 N

       WARING PROBABILITY PLOT Y
       WARING PROBABILITY PLOT Y2 X2
       WARING PROBABILITY PLOT Y3 XLOW XHIGH

       WARING CHI-SQUARE GOODNESS OF FIT Y
       WARING CHI-SQUARE GOODNESS OF FIT Y2 X2
       WARING CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    For maximim likelihood estimation for the Waring
    distribution, it is recommended that you use the

       SET BETA GEOMETRIC DEFINITION SHIFTED
       BETA GEOMETRIC MAXIMUM LIKELIHOOD Y
       BETA GEOMETRIC MAXIMUM LIKELIHOOD Y X

    You can then convert the estimates for alpha and beta
    to c and a:

       a = beta
       c = alpha + beta

    Enter HELP BGEPDF for details.

    You can generate estimates of a and c based on the
    maximum ppcc value or the minimum chi-square goodness of fit
    with the commands

        LET A1 = <value>
        LET A2 = <value>
        LET C1 = <value>
        LET C2 = <value>
        WARING KS PLOT Y
        WARING KS PLOT Y2 X2
        WARING KS PLOT Y3 XLOW XHIGH
        WARING PPCC PLOT Y
        WARING PPCC PLOT Y2 X2
        WARING PPCC PLOT Y3 XLOW XHIGH

    The default values of a1 and a2 are 0.5 and 5,
    respectively.  The default values for c1 and c2 are
    0.5 and 5, respectively.  Due to the discrete nature of the
    percent point function for discrete distributions, the
    ppcc plot will not be smooth.  For that reason, if there is
    sufficient sample size the KS PLOT (i.e., the minimum
    chi-square value) is typically preferred.  However, it may
    sometimes be useful to perform one iteration of the PPCC PLOT
    to obtain a rough idea of an appropriate neighborhood for the
    shape parameters since the minimum chi-square statistic can
    generate extremely large values for non-optimal values of
    the shape parameters.  Also, since the data is integer values,
    one of the binned forms is preferred for these commands.


Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WARCDF                   = Compute the Waring cumulative
                               distribution function.
    WARPPF                   = Compute the Waring percent point
                               function.
    BGEPDF                   = Compute the beta-geometric
                               probability mass function.
    GEOPDF                   = Compute the geometric probability
                               mass function.
    NBPDF                    = Compute the negative binomial
                               probability mass function.
    DLGPDF                   = Compute the logarithmic series
                               probability mass function.
    BBNPPF                   = Compute the beta-binomial (Waring)
                               probability mass function.
    BNBPPF                   = Compute the beta-negative binomial
                               (generalized Waring) probability mass
                               function.
    INTEGER FREQUENCY TABLE  = Generate a frequency table at
                               integer values with unequal bins.
    COMBINE FREQUENCY TABLE  = Convert an equal width frequency
                               table to an unequal width frequency
                               table.
    KS PLOT                  = Generate a minimum chi-square plot.
    PPCC PLOT                = Generate a ppcc plot.
    PROBABILITY PLOT         = Generate a probability plot.
    MAXIMUM LIKELIHOOD       = Perform maximum likelihood
                               estimation for a distribution.
 
Reference:
    "Discrete Univariate Distributions", 2nd. ed., Johnson, Kotz, and
    Kemp, John Wiley & Sons, 1994 (pp. 274-279).

    J. O. Irwin (1963), "The Place of Mathematics in Medical and
    Biological Statistics", Journal of the Royal Statistical
    Society, Series A, 126, pp. 1-44.

Applications:
    Distributional Modeling
 
Implementation Date:
    1995/4
    2006/7: Use beta-geometric to compute the probabilities
 
Program 1:
    LET ZA = DATA 0.5 0.5 0.5 0.5 2.0 2.0 2.0 2.0 4.0 4.0 4.0 4.0
    LET ZC = DATA 0.6 1.0 1.5 2.0 2.1 3.0 4.0 5.0 4.1 5.0 6.0 8.0
    TITLE AUTOMATIC
    XTIC OFFSET 0.5 0.5
    SPIKE ON
    LINE BLANK
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    MULTIPLOT 4 3
    LOOP FOR K = 1 1 12
       LET A = ZA(K)
       LET C = ZC(K)
       X1LABEL A = ^A
       X2LABEL C = ^C
       PLOT WARPDF(X,C,A) FOR X = 0 1 30
    END OF LOOP
    END OF MULTIPLOT
 
Program 2:
    LET Z = SEQUENCE 0.2 0.2 2.4
    TITLE AUTOMATIC
    XTIC OFFSET 0.5 0.5
    SPIKE ON
    LINE BLANK
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    MULTIPLOT 4 3
    LOOP FOR K = 1 1 12
       LET P = Z(K)
       X1LABEL YULE DISTRIBUTION, P = ^P
       PLOT WARPDF(X,P) FOR X = 1 1 50
    END OF LOOP
    END OF MULTIPLOT

-----WARPPF (LET)--------------------------------
 
WARPPF
 
Name:
    WARPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Waring percent point function.
 
Description:
    The Waring distribution has the following probability
    mass function:

       p(x,c,a) = (c-a)(a+x-1)!c!/[c(a-1)!(c+x)!]
                  x = 0, 1, 2, ...

    where c and a are positive shape parameters with c being
    larger than a.

    The Waring distribution is mathematically equivalent to
    the beta-geometric distribution (shifted to start at x = 0)
    where

        beta  = a
        alpha = c - a

    Dataplot uses this equivalence to compute the Waring
    percent point function.  Enter HELP BGEPPF for details
    of the beta-geometric distribution.

 
Syntax:
    LET <y2> = WARPPF(<y1>,<c>,<a>) <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a non-negative integer number, parameter, or
              variable;
          <c> is a positive number, parameter, or variable that
              specifies the first shape parameter;
          <a> is a positive number, parameter, or variable that
              specifies the second shape parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
              where the computed Waring ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If the <a> parameter is omitted or set to 1, this routine
    calculates the Yule cumulative distribution function.  If <a> is
    larger than <c>, an error message is printed.

Examples:
    LET A = WARPPF(0.9,5,2)
    LET A = WARPPF(0.9,3)
    LET X2 = WARPPF(P,C,A)
 
Note:
    The Waring distribution is a generalization of the Yule 
    distribution.  The Yule distribution is a special case of
    the Waring distribution with a = 1.  The Yule distribution
    is often given in the following form:

       p(x,p) = p(p!)(x-1)!/(y+p)!              y = 1, 2, ...

    where p is a positive parameter.

    In the Dataplot WARPDF routine, if the a parameter is omitted
    or set to 1, the formula for the Yule distribution is used
    rather than the Waring distribution formula.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WARCDF = Compute the Waring cumulative distribution function.
    WARPPF = Compute the Waring percent point function.
    BGEPDF = Compute the beta-geometric probability mass function.
    GEOPDF = Compute the geometric probability mass function.
    NBPDF  = Compute the negative binomial probability mass
             function.
    DLGPDF = Compute the logarithmic series probability mass
             function.
 
Reference:
    "Discrete Univariate Distributions", 2nd. ed., Johnson, Kotz,
    and Kemp, John Wiley & Sons, 1994 (pp. 274-279).
 
    J. O. Irwin (1963), "The Place of Mathematics in Medical and
    Biological Statistics", Journal of the Royal Statistical
    Society, Series A, 126, pp. 1-44.

Applications:
    Distributional Modeling
 
Implementation Date:
    1995/4
    2006/7: Use the BGAPPF routine to compute the percent point
            function
 
Program 1:
    LET ZA = DATA 0.5 0.5 0.5 0.5 2.0 2.0 2.0 2.0 4.0 4.0 4.0 4.0
    LET ZC = DATA 0.6 1.0 1.5 2.0 2.1 3.0 4.0 5.0 4.1 5.0 6.0 8.0
    TITLE AUTOMATIC
    XTIC OFFSET 0.1 0.1
    SPIKE ON
    LINE BLANK
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    MULTIPLOT 3 3
    LOOP FOR K = 1 1 12
       LET A = ZA(K)
       LET C = ZC(K)
       X1LABEL A = ^A
       X2LABEL C = ^C
       PLOT WARPPF(P,C,A) FOR P = 0.05 0.05 0.95
    END OF LOOP
    END OF MULTIPLOT
 
Program 2:
    LET Z = SEQUENCE 0.2 0.2 2.4
    TITLE AUTOMATIC
    XTIC OFFSET 0.1 0.1
    SPIKE ON
    LINE BLANK
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    .
    MULTIPLOT 4 3
    LOOP FOR K = 1 1 12
       LET P = Z(K)
       X1LABEL YULE DISTRIBUTION, P = ^P
       PLOT WARPPF(X,P) FOR X = 0.1 0.1 .91
    END OF LOOP
    END OF MULTIPLOT

-----WCACDF (LET)--------------------------------
 
WCACDF
 
Name:
    WCACDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard wrapped-up Cauchy cumulative distribution
    function.
 
Description:
    The standard form of the wrapped-up Cauchy distribution has the
    following cumulative distribution function:
       F(x,p) = (1/2*PI)*
                ARCTAN{[-SIN(x/2)-p*SIN(x/2)]/[-COS(x/2)+p*COS(x/2)]}-
                ARCTAN{[SIN(x/2)+p*SIN(x/2)]/[-COS(x/2)+p*COS(x/2)]}
                0 <= x < 2*PI

    where p is a shape parameter.  For PI < x < 2*PI, the cdf is
    1 - WCACDF(2*PI-x) where WCACDF is the formula given above.
 
    This distribution can be used as an alternative to the
    Von Mises distribution for symmetric, circular data.

Syntax:
    LET <y> = WCACDF(<x>,<p>)   <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed wrapped-up Cauchy cdf value is stored;
          <p> is a number, parameter, or variable that defines the
               shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = WCACDF(3,0.5)
    LET Y = WCACDF(X1,P)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WCAPDF = Compute the wrapped-up Cauchy probability density
             function.
    WCAPPF = Compute the wrapped-up Cauchy percent point function.
    FCAPDF = Compute the folded Cauchy probability density function.
    HCAPDF = Compute the half Cauchy probability density function.
    CAUPDF = Compute the Cauchy probability density function.
    FNRPDF = Compute the folded normal probability density function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994, (pp. 327-329).
 
Applications:
    Circular Distributions
 
Implementation Date:
    1995/10
 
Program:
    X1LABEL X
    Y1LABEL PROBABILITY
    LET TWOPI = 2*PI
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    LET P = 0.1
    TITLE WRAPPED CAUCHY DISTRIBUTION: P = ^P
    PLOT WCACDF(X,P) FOR X = 0  0.01 TWOPI
    LET P = 0.5
    TITLE WRAPPED CAUCHY DISTRIBUTION: P = ^P
    PLOT WCACDF(X,P) FOR X = 0  0.01 TWOPI
    LET P = 0.9
    TITLE WRAPPED CAUCHY DISTRIBUTION: P = ^P
    PLOT WCACDF(X,P) FOR X = 0  0.01 TWOPI
    LET P = 0
    TITLE WRAPPED CAUCHY DISTRIBUTION: P = ^P
    PLOT WCACDF(X,P) FOR X = 0  0.01 TWOPI
    END OF MULTIPLOT

-----WCAPDF (LET)--------------------------------
 
WCAPDF
 
Name:
    WCAPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard wrapped-up Cauchy probability density
    function.
 
Description:
    The standard form of the wrapped-up Cauchy distribution has the
    following probability density function:
       f(x,p) = (1 - p**2)/[2*PI*(1+p**2-2*p*COS(x))]  0 <= x < 2*PI
    where p is a shape parameter.
 
    This distribution can be used as an alternative to the
    Von Mises distribution for symmetric, circular data.

Syntax:
    LET <y> = WCAPDF(<x>,<p>)   <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed wrapped-up Cauchy pdf value is stored;
          <p> is a number, parameter, or variable that defines the
               shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = WCAPDF(3,0.5)
    LET Y = WCAPDF(X1,P)
 
Note:
    The general form of the wrapped-up Cauchy distribution has the
    following probability density function:
       f(x,p,mu) = (1 - p**2)/[2*PI*(1+p**2-2*p*COS(x-mu))]
                                              0 <= x < 2*PI
    where p is a shape parameter and mu is a location parameter.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WCACDF = Compute the wrapped-up Cauchy cumulative distribution
             function.
    WCAPPF = Compute the wrapped-up Cauchy percent point function.
    FCAPDF = Compute the folded Cauchy probability density function.
    HCAPDF = Compute the half Cauchy probability density function.
    CAUPDF = Compute the Cauchy probability density function.
    FNRPDF = Compute the folded normal probability density function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994, (pp. 327-329).
 
Applications:
    Circular Distributions
 
Implementation Date:
    1995/10
 
Program:
    X1LABEL X
    Y1LABEL PROBABILITY
    LET TWOPI = 2*PI
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    LET P = 0.1
    TITLE WRAPPED CAUCHY DISTRIBUTION: P = ^P
    PLOT WCAPDF(X,P) FOR X = 0  0.01 TWOPI
    LET P = 0.5
    TITLE WRAPPED CAUCHY DISTRIBUTION: P = ^P
    PLOT WCAPDF(X,P) FOR X = 0  0.01 TWOPI
    LET P = 0.9
    TITLE WRAPPED CAUCHY DISTRIBUTION: P = ^P
    PLOT WCAPDF(X,P) FOR X = 0  0.01 TWOPI
    LET P = 0
    TITLE WRAPPED CAUCHY DISTRIBUTION: P = ^P
    PLOT WCAPDF(X,P) FOR X = 0  0.01 TWOPI
    END OF MULTIPLOT

-----WCAPPF (LET)--------------------------------
 
WCAPPF
 
Name:
    WCAPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard wrapped-up Cauchy percent point function.
 
Description:
    The standard form of the wrapped-up Cauchy distribution is
    computed numerically using a bisection method.
 
    This distribution can be used as an alternative to the
    Von Mises distribution for symmetric, circular data.

Syntax:
    LET <y> = WCAPPF(<x>,<p>)   <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed wrapped-up Cauchy ppf value is stored;
          <p> is a number, parameter, or variable that defines the
               shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = WCAPPF(0.95,0.5)
    LET Y = WCAPPF(P1,P)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WCACDF = Compute the wrapped-up Cauchy cumulative distribution
             function.
    WCAPPF = Compute the wrapped-up Cauchy percent point function.
    FCAPDF = Compute the folded Cauchy probability density function.
    HCAPDF = Compute the half Cauchy probability density function.
    CAUPDF = Compute the Cauchy probability density function.
    FNRPDF = Compute the folded normal probability density function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994, (pp. 327-329).
 
Applications:
    Circular Distributions
 
Implementation Date:
    1995/10
 
Program:
    Y1LABEL X
    X1LABEL PROBABILITY
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    LET P = 0.1
    TITLE WRAPPED CAUCHY DISTRIBUTION: P = ^P
    PLOT WCAPPF(X,P) FOR X = 0  0.01 1
    LET P = 0.5
    TITLE WRAPPED CAUCHY DISTRIBUTION: P = ^P
    PLOT WCAPPF(X,P) FOR X = 0  0.01 1
    LET P = 0.9
    TITLE WRAPPED CAUCHY DISTRIBUTION: P = ^P
    PLOT WCAPPF(X,P) FOR X = 0  0.01 1
    LET P = 0
    TITLE WRAPPED CAUCHY DISTRIBUTION: P = ^P
    PLOT WCAPPF(X,P) FOR X = 0  0.01 1
    END OF MULTIPLOT

-----WEB---------------------------------------------------
 
WEB
 
Name:
    WEB
 
Type:
    Support Command
 
Purpose:
    Initiate a browser to access web pages from within Dataplot.
 
Description:
    The WEB comamnd is used to access a web page from within Dataplot.

    This command is host dependent (it utilizes a "system" call to
    initiate the browser).  It is currently supported for Linux/Unix,
    Mac OS X, and Windows platforms.  See the Note section below for
    SET commands that allow you to specify which browser to use.

    There are three special forms of the command.

       1. The WEB HELP command is used to access the Dataplot Reference
          Manual (and other Dataplot documentation) on the web.   This
          is an alternative to the Dataplot HELP command which accesses
          ASCII text files.

          The Dataplot web site is at the following URL:

              http://www.itl.nist.gov/div898/software/dataplot/

          The Dataplot Reference Manual is available at the following URL:

              http://www.itl.nist.gov/div898/dataplot/software/document.htm

       2. The WEB HANDBOOK command is used to access the NIST/SEMATECH
          Engineering Statistics Handbook.

          The NIST/SEMATECH Engineering Statistics Handbook (we will refer
          to this as the e-Handbook) can be found at the following URL:

              http://www.itl.nist.gov/div898/handbook/

          The e-Handbook is a web based guide to the use of statistics in
          engineering applications.  The WEB HANDBOOK command provides a
          useful complement to the Dataplot HELP and WEB HELP commands.
          That is, the HELP and WEB HELP commands are primarily concerned
          with dicussing how statistical techniques are implemented within
          Dataplot whereas the e-Handbook provides a more tutorial
          discussion of these techniques.  In addition, it provides an
          overview of many common application areas commonly used in
          engineering and scientific applications.

       3. The WEB SEARCH command is used to perform a web search.

Syntax 1:
    WEB <url address>
    where <url address> is the URL of the web page you would like
          to view.
 
    If the <url address> is omitted, then the NIST homepage is
    acessed.  In addition, a few specific keywords are supported:

         NIST      - accesses the NIST web page.
         SED       - accesses the NIST Statistical Engineering Division
                     web page.
         ITL       - accesses the NIST Information Technology Laboratory
                     web page.
         SEMATECH  - accesses the SEMATECH web page.
         JJF       - accesses Jim Filliben's home page
                     (accessible only from within NIST).
         FILLIBEN  - accesses Jim Filliben's home page
                     (accessible only from within NIST).
         HECKERT   - accesses Alan Heckert's home page
                     (accessible only from within NIST)

    The WEB command with no arguments takes you to the
    NIST web site.

Syntax 2:
    WEB HELP  <key1> ... <keyn>
    where <key1> ... <keyn> is a list of keywords that specify a command
          or a topic for which help is needed.
 
    The WEB HELP command with no arguments takes you to the
    introductory page for the Dataplot Reference Manual.

    The <key1> ... <keyn> is matched against a file (refman.tex in the
    Dataplot help directory) of keywords that specifies the appropriate
    Dataplot URL.  Although this command is used by the Dataplot GUI,
    it can also be entered by the end-user.  To see a list of supported
    keywords, enter

        LIST REFMAN.TEX

    The online Reference Manual is a combination of HTML and
    PDF files.  To view the PDF files, you need a plug-in for your
    browser that can read PDF files.
 
Syntax 3:
    WEB HANDBOOK  <key1> ... <keyn>
    where <key1> ... <keyn> is a list of keywords that specify the name
          of the topic for which you would like to access an appropriate
          page of the e-Handbook.

    The <key1> ... <keyn> is matched against a file (handbk.tex in the
    Dataplot help directory) of keywords that specifies the appropriate
    e-Handbook URL.  Although this command is used by the Dataplot GUI,
    it can also be entered by the end-user.  To see a list of supported
    keywords, enter

        LIST HANDBK.TEX

Syntax 4:
    WEB SEARCH <key1> ... <keyn>
    where <key1> ... <keyn> is a list of keywords for the search.
 
    Each keyword can have up to 8 characters and keywords are
    separated either by spaces or hyphens.  If no keywords are
    given, you will be taken to the search engine home page.

    The following command can be used to specify the desired
    search engine

       SET SEARCH ENGINE <GOOGLE/BING/YAHOO/WOW/DUCK>

    where

       GOOGLE   => the Google search engine
       BING     => the Bing (Microsoft) search engine
       Yahoo    => the Yahoo search engine
       WOW      => the WOW (AOL) search engine
       DUCK     => the duckduckgo search engine

    This can be used for any generic search.  Specifically, it can be
    used as an alternative to the WEB HELP command.  The WEB HELP
    command requires a specific match of keywords.  So if you are
    unsure of the specific command name, you can perform a more
    generic search by using WEB SEARCH Dataplot <keywords>.

Examples:
    WEB SED
    WEB http://www.itl.nist.gov/div898/software/dataplot/
    WEB http://www.itl.nist.gov/
 
    WEB HELP
    WEB HELP PLOT
    WEB HELP FIT
    WEB HELP LET
    WEB HELP 3D-PLOT
    WEB HELP READ
    WEB HELP GRAPHICS
    WEB HELP ANALYSIS

    WEB HANDBOOK
    WEB HANDBOOK RELIABILITY
    WEB HANDBOOK EDA
    WEB HANDBOOK REGRESSION
    WEB HANDBOOK BLOCK PLOT

    WEB SEARCH Dataplot PPCC PLOT
    WEB SEARCH QUANTILE QUANTILE PLOTS
 
Note:
    If you wish to specify which browser to use, you can enter the
    following command:

       SET BROWSER <name>

    where <name> is the string that activates your preferred
    browser.  It is recommended that you enclose <name> in
    double quotes.

    For Linux/Unix and Mac OS X platforms, Dataplot will by default
    use

       firefox

    If you have a different preference for the default, you can
    add an appropriate SET BROWSER command to your dplogf.tex file.

    For Windows platforms, the default DPLOGF.TEX file contains a
    section that allows you to set the default browser.  This file is
    typically in one of the following directories (the drive may
    be different if you selected a non-default location and 
    "Program Files" may have a different spelling on non-English
    machines):

       c:\Program Files\NIST\Dataplot          - 32-bit machines
       c:\Program Files (x86)\NIST\Dataplot    - 64-bit machines

    In this file, look for the lines

        LET IOPS = ...
        LET IBROWSE = ...

    The IOPS parameter specifies whether you have a 32-bit machine
    or a 64-bit machine.  The IBROWSE can be set to 1, 2, 3, 4, or
    5 for Internet Explorer, Firefox, Seamonkey, Chrome, or Opera,
    respectively.  Based on the settings for these two switches,
    the DPLOGF.TEX will issue the appropriate SET BROWSER command.
    You can of course modify this section to use any browser of
    your choosing.

    Alternatively, you can enter the following operating system
    command under Unix (for the c-shell):

         setenv BROWSER <name>

    On Windows platforms, you can enter the following operating
    system command (add this to a batch file that initiates
    Dataplot):

         SET BROWSER=<name>

Note:
    The default URL for the WEB command is the NIST home page on
    the public NIST web server (http://www.nist.gov/).  You can
    change this default by entering the following Dataplot command:

      SET URL  <location of desired web page>

    For example, you may want to change the default to local
    site's main web page.

    If you need to enter this command, you should consider putting it in
    your DPLOGF.TEX startup file to make it the default for your system.

    Alternatively, you can enter the following operating system
    command under Linux/Unix (this is for the c-shell):

         setenv URL <location of Dataplot web pages>

    On Windows platforms, you can enter the following operating
    system command:

         SET URL=<location of Dataplot web pages>

Note:
    The default URL for the WEB HELP command is the Dataplot
    home page on the public NIST web server.  If you have
    installed the Dataplot web pages on a local system (it is
    available upon request) for faster performance, you should
    enter the following Dataplot command:

      SET Dataplot URL  <location of Dataplot web pages>

    If you need to enter this command, you should consider putting it in
    your DPLOGF.TEX startup file to make it the default for your system.

    Alternatively, you can enter the following operating system
    command under Linux/Unix (this is for the c-shell):

         setenv DPURL <location of Dataplot web pages>

    On Windows platforms, you can enter the following operating
    system command (typically you would put this in a batch file
    that initiates Dataplot:

         SET DPURL=<location of Dataplot web pages>

Note:
    The default URL for the WEB HANDBOOK command is the Handbook
    home page on the public NIST web server.  If you have
    installed the Handbook web pages on a local system for faster
    performance, you should enter the following Dataplot command:

      SET HANDBOOK URL  <location of Handbook web pages>

    For example, you would enter something like

       SET HANDOOK URL http://ketone.cam.nist.gov/cf/handbook/

    If you need to enter this command, you should consider putting it
    in you DPLOGF.TEX startup file to make it the default for your
    system.

Note:
    The documentation for the WEB HELP facility can lag behind the
    inclusion of new capabilities.  The NEWS command documents new
    capabilities in Dataplot.  If you do not find the topic under
    WEB HELP, be sure to check the NEWS file.
 
Note:
    In general, the on-line Reference Manual is intended to provide
    detailed information for a specific command.  It is not intended as
    a tutorial for learning how to use Dataplot.
 
Note:
    On Unix platforms using the Netscape browser, you can send the
    WEB request to a currently open browser.  This can significantly
    improve performance.  

    To use a currently open Netscape browser, enter the command

         SET NETSCAPE OLD

    To open a new browser, even if a browser is currently open,
    enter the command

         SET NETSCAPE NEW

    The default is NEW.  This option is ignored for non-Netscape
    browsers and on the Windows platforms.

    Since the Netscape browser is an obsolete browser, the above
    section is no longer relevant.  It is browser and platform
    dependent whether a WEB command will display results in a
    currently open browser or open up a new browser.  Modern
    browsers almost all support "tabbing", so for many, if not
    most, modern browsers the WEB command results will display
    in a new tab if a browser is currently running.  However,
    Dataplot does not issue any commands to force this.

Note:
    For the WEB SEARCH command, the following command can be
    used

        SET WEB SEARCH DATAPLOT <ON/OFF>

    If ON, then the WEB SEARCH command will automatically include
    DATAPLOT as a keyword in the search.  If OFF, DATAPLOT will not
    automatically include DATAPLOT as a keyword.

    This command is useful if you are primarily using the WEB
    SEARCH command to locate relevant Dataplot documentation.

    The default is OFF.

Default:
    None
 
Synonyms:
    ?? is a synonym for WEB HELP

    ???? is a synonym for WEB HANDBOOK
    HANDBOOK is a synonym for WEB HANDBOOK
    HB is a synonym for WEB HANDBOOK
    WHB is a synonym for WEB HANDBOOK

    W is a synonym for WEB

    ????? is a synonym for WEB SEARCH
    WS is a synonym for WEB SEARCH
 
Related Commands:
    HELP         = Access the Dataplot help files.
    NEWS         = Access the Dataplot news file.
    PROBE        = Displays the value of an internal variable.
    SET          = Sets the value of an internal variable.
 
Applications:
    On-Line Help
 
Implementation Date:
    1997/07: Original implementation of the WEB and WEB HELP commands
    2000/01: Implementation of the WEB HANDBOOK command
    2015/11: Implementation of the WEB SEARCH command
    2018/04: Added various synonyms
 
Program 1:
    WEB
    WEB http://www.itl.nist.gov/software/dataplot/
    WEB SEARCH PPCC PLOT
 
Program 2:
    WEB HANDBOOK
    WEB HANDBOOK RELIABILITY
    WEB HANDBOOK DUANE PLOT
    DUANE PLOT Y
 
Program 3:
    WEB HELP
    WEB HELP GRAPHICS
    WEB HELP PLOT
    PLOT X**2 FOR X = 1 1 9
 
-----WEIBULL ADJUSTED RANKS (LET)------------------------------------
 
WEIBULL ADJUSTED RANKS
 
Name:
    WEIBULL ADJUSTED RANKS (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the Weibull adjusted ranks in preparation for a Weibull
    plot.
 
Syntax 1:
    LET <resp> = WEIBULL ADJUSTED RANKS <y1>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a response variable;
          <resp> is a variable where the adjusted Weibull ranks are
               saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    LET <resp> = WEIBULL ADJUSTED RANKS <y1> <tag>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a response variable;
          <tag> is a variable containing 1's (the data point is included
               in the analysis) and 0's (the data point is excluded from
               the analysis);
          <resp> is a variable where the adjusted Weibull ranks are
               saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y3 = WEIBULL ADJUSTED RANKS Y1 Y2
 
Note:
    A tag variable (syntax 2) is used to indicate censored items.
    Values not equal to 1 are considered censored.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WEIBULL PLOT   = Generates a Weibull plot.
 
Reference:
    "Weibull Analysis Handbook", Abernathy, et. al., pages 20-21.
 
Applications:
    Reliability
 
Implementation Date:
    XX
 
Program:
    LET TIME = DATA 90 96 100 30 49 45 10 82
    LET FAILMODE = DATA 1 1 0 1 1 0 0 1
    LET X = WEIBULL ADJUSTED RANKS TIME FAILMODE
    PRINT X
 
-----WEIBULL MOMENT ESTIMATES (LET)-------------------------------------
 
WEIBULL MOMENT ESTIMATES
 
Name:
    WEIBULL MOMENT ESTIMATES (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Estimate the parameters of the Weibull distribution based on summary
    statistics.
 
Description:
    In most cases, we prefer to estimate the parameters of the Weibull
    distribution using the WEIBULL MLE Y command.  However, this assumes
    that we have the full data set.  In some cases, we may only have
    summary statistics available.

    The input array, say X, should contain the following values:

        X(1) = the sample mean
        X(2) = the sample standard deviation
        X(3) = the sample skewness
        X(4) = the sample minimum
        X(5) = the sample size

    If one of the values is not available, then you can enter either
    CPUMIN or the statistic missing value.  For example, if the skewness
    is not available, you can do one of the following:

        PROBE CPUMIN
        LET CPUMIN = PROBVAL
        LET X(3) = CPUMIN

    or

        SET STATISTIC MISSING VALUE -9999
        LET X(3) = -9999

    The following output vector, say Y, is returned:

        Y(1) = 3-parameter moment estimate for location
        Y(2) = 3-parameter moment estimate for scale
        Y(3) = 3-parameter moment estimate for shape
        Y(4) = 3-parameter modified moment estimate for location
        Y(5) = 3-parameter modified moment estimate for scale
        Y(6) = 3-parameter modified moment estimate for shape
        Y(7) = 2-parameter moment estimate for scale
        Y(8) = 2-parameter moment estimate for shape

    Any of these moment estimates that cannot be computed will be set to
    CPUMIN.  This can happen if certain summary statistics are not provided
    or if the equation solvers are not able to find a solution.

    The 3-parameter moment and modified moment estimates are computed using
    the codes provided on pages 341-342 of Cohen and Whitten.  The
    2-parameter moment estimates are computed using the equations on page 322
    of Bury.

Syntax:
    LET <y> = WEIBULL MOMENT ESTIMATES  <x>
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is the variable containing the summary statistics;
          <y> is a variable containing the Weibull moment estimates;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional and rarely
          used for this command.
 
Examples:
    LET Y = WEIBULL MOMENT ESTIMATES X
 
Default:
    None
 
Synonyms:
    None
 
Reference:
    Cohen and Whitten (1988), "Parameter Estimation in Reliability and Life
    Span Models", Marcel Dekker, p. 31 and pp. 341-344.

    Bury (1999), "Statistical Distributions in Engineering", Cambridge
    University Press, Chapter 17.

Related Commands:
    GAMMA MOMEMENT ESTIMATE        = Generate moment estimates for the
                                     gamma distribution.
    LOGNORMAL MOMEMENT ESTIMATE    = Generate moment estimates for the
                                     lognormal distribution.
    INVERSE GAUSSIAN MOME ESTIMATE = Generate moment estimates for the
                                     inverse gaussian distribution.
    MAXIMUM LIKELIHOOD             = Perform maximum likelihood estimation
                                     for various distributions.
    BEST DISTRIBUTIONAL FIT        = Perform a best distributional fit
                                     analysis.
    PPCC PLOT                      = Generate a probability plot
                                     correlation coefficient plot.
    PROBABILITY PLOT               = Generate a probability plot.
 
Applications:
    Reliability
 
Implementation Date:
    2012/6
 
Program:
    SKIP 25
    READ WEIBBURY.DAT Y
    .
    .  COMPUTE SUMMARY STATISTICS
    .
    LET YMEAN = MEAN Y
    LET YSD   = SD   Y
    LET YMIN  = MINI Y
    LET YSKEW = SKEW Y
    LET N     = SIZE Y
    LET Z     = COMBINE YMEAN YSD YMIN YSKEW N
    .
    .  COMPUTE WEIBULL PARAMETER ESTIMATES
    .
    LET X = WEIBULL MOMENT ESTIMATES Z
    LET LOCMOM   = X(1)
    LET SCALEMOM = X(2)
    LET SHAPEMOM = X(3)
    LET LOCMMOM  = X(4)
    LET SCALMMOM = X(5)
    LET SHAPMMOM = X(6)
    LET SCAL2MOM = X(7)
    LET SHAP2MOM = X(8)
    .
    .  NOW PRINT RESULTS
    .
    SET WRITE DECIMALS 4
    FEEDBACK OFF
    WRITE "WEIBULL PARAMETER ESTIMATES FROM SUMMARY DATA"
    WRITE " "
    WRITE " "
    WRITE "SUMMARY STATISTICS:"
    WRITE "SAMPLE MEAN:         ^YMEAN"
    WRITE "SAMPLE SD:           ^YSD"
    WRITE "SAMPLE SKEWNESS:     ^YSKEW"
    WRITE "SAMPLE MINIMUM:      ^YMIN"
    WRITE "SAMPLE SIZE:         ^N"
    WRITE " "
    WRITE " "
    IF SCALEMOM > 0
       WRITE "3-PARAMETER WEIBULL MOMENT ESTIMATES:"
       WRITE "LOCATION:            ^LOCMOM"
       WRITE "SCALE:               ^SCALEMOM"
       WRITE "SHAPE:               ^SHAPEMOM"
       WRITE " "
       WRITE " "
    END OF IF
    IF SCALMMOM > 0
       WRITE "3-PARAMETER WEIBULL MODIFIED MOMENT ESTIMATES:"
       WRITE "LOCATION:            ^LOCMMOM"
       WRITE "SCALE:               ^SCALMMOM"
       WRITE "SHAPE:               ^SHAPMMOM"
       WRITE " "
       WRITE " "
    END OF IF
    IF SCAL2MOM > 0
       WRITE "2-PARAMETER WEIBULL MOMENT ESTIMATES:"
       WRITE "SCALE:               ^SCAL2MOM"
       WRITE "SHAPE:               ^SHAP2MOM"
    END OF IF
    FEEDBACK ON

-----WEIBULL PLOT----------------------------------------------------
 
WEIBULL PLOT
 
Name:
    WEIBULL PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a Weibull plot.
 
Description:
    A Weibull plot is a graphical data analysis technique for
    determining if a 2-parameter (location t0 = 0) Weibull
    distribution provides a good distributional model for the data.  A
    good distributional fit is indicated by linearity in the Weibull
    plot.  It consists of:
       Vertical   axis = cumulative percent occurred (in a
                         loge(loge(1/(1-p)))) scale where
                         p = (i-.3)/(n+.4) );
       Horizontal axis = failure time (in a log10 scale).
 
    For the general (3-parameter) Weibull distribution, the cumulative
    distribution function (F(t), the density function f(t), and the
    percent point function G(p) are (respectively):
          F(t) = p = 1 - exp(-(z**beta))
          f(t)     = (beta/nu) * z**(beta-1) * exp(-(z**beta))
          G(p) = t = t0 + nu * (loge(1/(1-p)))**(1/beta)
    with
          z = (t-t0)/nu
    Namewise,
       t0   = location parameter (smallest allowable t);
       nu   = scale parameter    (= "characteristic life", note that
                                 t0+nu falls at the 63.2% point
                                 irrespective of beta);
       beta = shape parameter    (specifies the member of the Weibull
                                 family).
    For the 2-parameter (t0 = 0) Weibull distribution, simplifications
    occur and so the percent point function G(p) reduces to:
       G(p) = t = nu * (loge(1/(1-p)))**(1/beta)
    which by rearrangement becomes
       loge(loge(1/(1-p))) = beta * loge(G(p)/nu)
       loge(loge(1/(1-p))) = beta * loge(t/nu)
       loge(loge(1/(1-p))) = -beta*loge(nu) + beta*loge(t)
    After a minor adjustment to take loge(t) to log10(t), this last
    expression defines the resulting Weibull plot.  That is, the left
    side appears vertically on the Weibull plot and the right side
    appears horizontally.
 
    If the data follows a 2-parameter distribution, then the plot will
    be near-linear and the slope of the plot will be identically beta
    (the shape parameter).  For the Weibull plot, both beta and eta are
    estimated (behind the scenes) by least squares.
 
    In addition to the raw data, three other lines are drawn on the
    plot:
       1. A fitted line to the raw data;
       2. A horizontal line at the 63.2% point;
       3. A vertical line at ...
 
Syntax 1:
    WEIBULL PLOT   <y>     <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable (e.g., days to failure);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    WEIBULL PLOT  <y>   <tag>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable (e.g., days to failure);
          <tag> is a 0 or 1 indicator variable where 1 indicates that
                the item failed by the failure mode of interest and 0
                indicates that the item failed but by some other
                failure mode which is not of interest;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    WEIBULL PLOT Y
    WEIBULL PLOT Y1
    WEIBULL PLOT Y TAG
    WEIBULL PLOT Y1 IND
    WEIBULL PLOT Y SUBSET MATERIAL 4
    WEIBULL PLOT Y TAG SUBSET MATERIAL 5 SUBSET PROCESS 3
 
Note:
    The value of beta indicates the current status of the failures:
       beta  .  hazard function . failure type
       ........................................
       < 1   .   decreasing     .  infant mortality
       1     .   constant       .  exponential
       > 1   .   increasing     .  old-age wear out
 
Note:
    The following parameters are automatically produced by Dataplot
    when using the WEIBULL PLOT command:
       ETA    = estimated "characteristic life"
       BETA   = estimated shape parameter
       SDETA  = estimated standard deviation of eta
       SDBETA = estimated standard deviation of beta
       BPT1   = estimated  0.1% point of failure times
       BPT5   = estimated  0.5% point of failure times
       B1     = estimated    1% point of failure times
       B5     = estimated    5% point of failure times
       B10    = estimated   10% point of failure times
       B20    = estimated   20% point of failure times
       B50    = estimated   50% point of failure times
       B80    = estimated   80% point of failure times
       B90    = estimated   90% point of failure times
       B95    = estimated   95% point of failure times
       B99    = estimated   99% point of failure times
       B995   = estimated 99.5% point of failure times
       B999   = estimated 99.9% point of failure times
 
Note:
    The attributes of the 4 lines on the Weibull plot can be specified
    via the LINES and CHARACTER commands (along with their attribute
    setting commands).
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHARACTERS         = Sets the type for plot characters.
    LINES              = Sets the type for plot lines.
    WEIBULL PPCC PLOT  = Generates a Weibull probability plot
                         correlation coefficient plot.
    WEIBULL PROB PLOT  = Generates a (fixed GAMMA) Weibull probability
                         plot.
    NORMAL PLOT        = Generates a Normal plot.
    HISTOGRAM          = Generates a histogram.
    BOX PLOT           = Generates a box plot.
    PLOT               = Generates a data or function plot.
 
Applications:
    Reliability and Life Testing
 
Implementation Date:
    88/2
 
Program 1:
    . EXAMPLE 1--SEE ABERNATHY, PAGES 17, 18, 19.
    LET Y = DATA 90 96 30 49 82
    LINE SOLID DASH DOT DOT
    TITLE AUTOMATIC
    WEIBULL PLOT Y
    STATUS
 
Program 2:
    . EXAMPLE 2--SEE ABERNATHY, PAGES 17, 20, 23
    LET Y = DATA 90 96 100 30 49 45 10 82
    LET TAG = DATA 1 1 0 1 1 0 0 1
    TITLE AUTOMATIC
    LINE SOLID DASH DOT DOT
    WEIBULL PLOT Y TAG
 
-----WEIBULL SCALE--------------------------------------------------
 
WEIBULL SCALE
 
Name:
    ...WEIBULL SCALE
 
Type:
    Plot Control Command
 
Purpose:
    Specifies whether or not a Weibull scale is to appear on plot axes
    of subsequent plots.
 
Description:
    A Weibull scale is ....
 
Syntax:
    <prefix>WEIBULL SCALE  <ON or OFF>
    where
            no prefix     refers to all 4 sides;
            the prefix X  refers to both horizontal sides;
            the prefix Y  refers to both vertical sides;
            the prefix X1 refers to the lower horizontal side;
            the prefix X2 refers to the upper horizontal side;
            the prefix Y1 refers to the left  vertical   side;
            the prefix Y2 refers to the right vertical   side;
    and   ON specifies that the axes will have a Weibull scale while
            OFF specifies that it will have a linear scale.
 
Examples:
    YWEIBULL SCALE ON
    XWEIBULL SCALE ON
    YWEIBULL SCALE OFF
    XWEIBULL SCALE OFF
 
Default:
    The default is a linear scale.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    LOG                 = Sets the on/off switch for a log scale.
    WEIBULL PLOT        = Generates a Weibull plot.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XX
 
-----WEICDF (LET)--------------------------------
 
WEICDF
 
Name:
    WEICDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the Weibull cumulative distribution
    function with tail length parameter GAMMA.
 
Description:
    For the minimum order statistic, the standard form of the
    Weibull probability density function is:
       f(x) = gamma*x**(gamma-1)*exp(-(x**gamma))    x > 0
    For the maximum order statistic, the standard form of the
    Weibull probability density function is:
       f(x) = gamma*(-x)**(gamma-1)*exp(-((-x)**gamma))    x < 0
    In either case, GAMMA should be positive.  The cumulative
    distribution is the area from 0 to x (for the first form) or from
    minus infinity to x (for the second form).  That is, it is the
    integrals of the above functions.  Since this is a probability
    function, the returned value will be between 0 and 1.
 
Syntax:
    LET <y2> = WEICDF(<y1>,GAMMA) <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, number, or parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed Weibull cdf value is stored;
          <GAMMA> is a positive number or parameter that specifies the
               tail length parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = WEICDF(3,2)
    LET A = WEICDF(A1,8)
    LET X2 = WEICDF(X1,4)
 
Note:
    The SET MINMAX command specifies whether the minimum or maximum
    order statistic form is used.  Entering SET MINMAX 2 specifies the
    maximum order statistic while entering SET MINMAX specifies the
    minimum order statistic.
 
Note:
    For the minimum order statistic, the general form of the
    Weibull probability density function is:
       f(x) = (gamma/alpha)*((x-u)/alpha)**(gamma-1)*
                 exp(-((x-u)/alpha)**gamma))    x > u
    For the maximum order statistic, the general form of the
    Weibull probability density function is:
       f(x) = (gamma/alpha)*((-x-u)/alpha)**(gamma-1)*
                 exp(-((-x-u)/alpha)**gamma))   x < u
    where u is the location parameter and alpha is the scale parameter.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    FCDF   = Compute the F cumulative distribution function.
    FPDF   = Compute the F probability density function.
    FPPF   = Compute the F percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    TCDF   = Compute the T cumulative distribution function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, 1970.
 
Applications:
    Reliability Analysis
 
Implementation Date:
    XX
 
Program:
    TITLE PLOT WEICDF FOR VARIOUS VALUES OF GAMMA
    SEGMENT 1 COORDINATES 69 38 74 38; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 69 34 74 34; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 69 30 74 30; SEGMENT 3 PATTERN DOT
    SEGMENT 4 COORDINATES 69 26 74 26; SEGMENT 4 PATTERN DASH2
    LEGEND 1 GAMMA = 1; LEGEND 1 COORDINATES 75 37
    LEGEND 2 GAMMA = 2; LEGEND 2 COORDINATES 75 33
    LEGEND 3 GAMMA = 5; LEGEND 3 COORDINATES 75 29
    LEGEND 4 GAMMA = .5; LEGEND 4 COORDINATES 75 25
    YLIMITS 0 1; MAJOR YTIC NUMBER 6
    MINOR YTIC NUMBER 1; YTIC DECIMAL 1
    XLIMITS 0 3
    LINES SOLID DASH DOT DASH2
    PLOT WEICDF(X,1) FOR X = 0.01 0.01 3 AND
    PLOT WEICDF(X,2) FOR X = 0.01 0.01 3 AND
    PLOT WEICDF(X,5) FOR X = 0.4 0.01 1.6 AND
    PLOT WEICDF(X,0.5) FOR X = 0.05 0.01 2
 
-----WEICHAZ (LET)--------------------------------
 
WEICHAZ
 
Name:
    WEICHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Weibull cumulative hazard function with tail
    length parameter GAMMA.
 
Description:
    For the minimum order statistic, the standard form of the
    Weibull cumulative hazard function is:

       H(x,gamma) = x**gamma     x > 0, gamma > 0

    For the maximum order statistic, the standard form of the
    Weibull hazard function is:

       H(x,gamma) = (-x)**gamma     x < 0, gamma > 0

Syntax:
    LET <y> = WEICHAZ(<x>,<gamma>,<loc>,<scale>)
                                 <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed Weibull cumulative hazard value
               is stored;
          <gamma> is a positive number, parameter, or variable that
               specifies the tail length parameter;
          <loc> is a positive number, parameter, or variable that
               specifies the location parameter;
          <scale> is a positive number, parameter, or variable that
               specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The location and scale parameters are optional.

Examples:
    LET A = WEICHAZ(3,2)
    LET Y = WEICHAZ(X,4)
    LET Y = WEICHAZ(X,2,0,5)
    PLOT WEICHAZ(X,2) FOR X = 0.01 0.01 10
 
Note:
    The SET MINMAX command specifies whether the minimum or maximum
    order statistic form is used.  Entering SET MINMAX 2 specifies the
    maximum order statistic while entering SET MINMAX specifies the
    minimum order statistic.
 
Note:
    For the minimum order statistic, the general form of the
    Weibull hazard function is:

       H(x,gamma,u,beta) = ((x-u)/beta)**gamma
                           x > u, gamma > 0, beta > 0

    For the maximum order statistic, the general form of the
    Weibull probability density function is:

       H(x,gamma,u,beta) = ((-x-u)/beta)**gamma
                           x < u, gamma > 0, beta > 0

    where u is the location parameter and beta is the scale parameter.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WEIHAZ  = Compute the Weibull hazard function.
    WEICDF  = Compute the Weibull cumulative distribution function.
    WEIPDF  = Compute the Weibull probability density function.
    WEIPPF  = Compute the Weibull percent point function.
    EXPHAZ  = Compute the exponential cumulative hazard function.
    EV1HAZ  = Compute the extreme value type I hazard function.
    EV2HAZ  = Compute the extreme value type II hazard function.
    LGNHAZ  = Compute the lognormal hazard function.
 
Reference:
    "Continuous Univariate Distributions--Vol. I", 2nd. Ed., Johnson,
    Kotz, and Balakrishnan, John Wiley and Sons, 1994.
 
    "Statistical Distributions", 2nd. Edition, Evans, Hastings, and
    Peacock, Wiley and Sons, 1993 (chapter 18).
 
Applications:
    Reliability Analysis
 
Implementation Date:
    1998/5
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    SET MINMAX 1
    X1LABEL GAMMA = 1
    PLOT WEICHAZ(X,1) FOR X = 0.01 0.01 3
    X1LABEL GAMMA = 2
    PLOT WEICHAZ(X,2) FOR X = 0.01 0.01 3
    X1LABEL GAMMA = 5
    PLOT WEICHAZ(X,5) FOR X = 0.01 0.01 3
    X1LABEL GAMMA = 0.5
    PLOT WEICHAZ(X,0.5) FOR X = 0.01 0.01 3
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT WEIBULL HAZARD PLOTS
 
-----WEIHAZ (LET)--------------------------------
 
WEIHAZ
 
Name:
    WEIHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Weibull hazard function with tail length parameter
    GAMMA.
 
Description:
    For the minimum order statistic, the standard form of the
    Weibull hazard function is:

       h(x,gamma) = gamma*x**(gamma - 1)     x > 0, gamma > 0

    For the maximum order statistic, the standard form of the
    Weibull hazard function is:

       h(x,gamma) = gamma*(-x)**(gamma - 1)  x < 0, gamma > 0

Syntax:
    LET <y> = WEIHAZ(<x>,<gamma>,<loc>,<scale>)
                                 <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed Weibull hazard value is stored;
          <gamma> is a positive number, parameter, or variable that
               specifies the tail length parameter;
          <loc> is a positive number, parameter, or variable that
               specifies the location parameter;
          <scale> is a positive number, parameter, or variable that
               specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The location and scale parameters are optional.

Examples:
    LET A = WEIHAZ(3,2)
    LET Y = WEIHAZ(X,4)
    LET Y = WEIHAZ(X,2,0,5)
    PLOT WEIHAZ(X,2) FOR X = 0.01 0.01 10
 
Note:
    The SET MINMAX command specifies whether the minimum or maximum
    order statistic form is used.  Entering SET MINMAX 2 specifies the
    maximum order statistic while entering SET MINMAX specifies the
    minimum order statistic.
 
Note:
    For the minimum order statistic, the general form of the
    Weibull hazard function is:

       h(x,gamma,u,beta) = gamma*(x-u)**(gamma - 1)/(beta**gamma)
                           x > u, gamma > 0, beta > 0

    For the maximum order statistic, the general form of the
    Weibull probability density function is:

       h(x,gamma,u,beta) = gamma*(-(-x-u))**(gamma - 1)/(beta**gamma)
                           x < u, gamma > 0, beta > 0

    where u is the location parameter and beta is the scale parameter.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WEICHAZ = Compute the Weibull cumulative hazard function.
    WEICDF  = Compute the Weibull cumulative distribution function.
    WEIPDF  = Compute the Weibull probability density function.
    WEIPPF  = Compute the Weibull percent point function.
    EXPHAZ  = Compute the exponential cumulative hazard function.
    EV1HAZ  = Compute the extreme value type I hazard function.
    EV2HAZ  = Compute the extreme value type II hazard function.
    LGNHAZ  = Compute the lognormal hazard function.
 
Reference:
    "Continuous Univariate Distributions--Vol. I", 2nd. Ed., Johnson,
    Kotz, and Balakrishnan, John Wiley and Sons, 1994.
 
    "Statistical Distributions", 2nd. Edition, Evans, Hastings, and
    Peacock, Wiley and Sons, 1993 (chapter 18).
 
Applications:
    Reliability Analysis
 
Implementation Date:
    1998/5
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    SET MINMAX 1
    X1LABEL GAMMA = 1
    PLOT WEIHAZ(X,1) FOR X = 0.01 0.01 3
    X1LABEL GAMMA = 2
    PLOT WEIHAZ(X,2) FOR X = 0.01 0.01 3
    X1LABEL GAMMA = 5
    PLOT WEIHAZ(X,5) FOR X = 0.01 0.01 3
    X1LABEL GAMMA = 0.5
    PLOT WEIHAZ(X,0.5) FOR X = 0.01 0.01 3
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT WEIBULL HAZARD PLOTS
 
-----WEIPDF (LET)--------------------------------
 
WEIPDF
 
Name:
    WEIPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the Weibull probability density
    function with tail length parameter GAMMA.
 
Description:
    For the minimum order statistic, the standard form of the
    Weibull probability density function is:
       f(x) = gamma*x**(gamma-1)*exp(-(x**gamma))    x > 0
    For the maximum order statistic, the standard form of the
    Weibull probability density function is:
       f(x) = gamma*(-x)**(gamma-1)*exp(-((-x)**gamma))    x < 0
    In either case, GAMMA should be positive.
 
Syntax:
    LET <y2> = WEIPDF(<y1>,GAMMA) <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, number, or parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed Weibull pdf value is stored;
          <GAMMA> is a positive number or parameter that specifies the
               tail length parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = WEIPDF(3,2)
    LET A = WEIPDF(A1,4)
    LET X2 = WEIPDF(X1,8)
 
Note:
    The SET MINMAX command specifies whether the minimum or maximum
    order statistic form is used.  Entering SET MINMAX 2 specifies the
    maximum order statistic while entering SET MINMAX specifies the
    minimum order statistic.
 
Note:
    For the minimum order statistic, the general form of the
    Weibull probability density function is:
       f(x) = (gamma/alpha)*((x-u)/alpha)**(gamma-1)*
                 exp(-((x-u)/alpha)**gamma))    x > u
    For the maximum order statistic, the general form of the
    Weibull probability density function is:
       f(x) = (gamma/alpha)*((-x-u)/alpha)**(gamma-1)*
                 exp(-((-x-u)/alpha)**gamma))   x < u
    where u is the location parameter and alpha is the scale parameter.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
    FCDF   = Compute the F cumulative distribution function.
    FPDF   = Compute the F probability density function.
    FPPF   = Compute the F percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    TCDF   = Compute the T cumulative distribution function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPPF = Compute the Weibull percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, 1970.
 
Applications:
    Reliability Analysis
 
Implementation Date:
    Pre-1987
 
Program:
    TITLE PLOT WEIPDF FOR VARIOUS VALUES OF GAMMA
    SEGMENT 1 COORDINATES 69 88 74 88; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 69 84 74 84; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 69 80 74 80; SEGMENT 3 PATTERN DOT
    SEGMENT 4 COORDINATES 69 76 74 76; SEGMENT 4 PATTERN DASH2
    LEGEND 1 GAMMA = 1; LEGEND 1 COORDINATES 75 87
    LEGEND 2 GAMMA = 2; LEGEND 2 COORDINATES 75 83
    LEGEND 3 GAMMA = 5; LEGEND 3 COORDINATES 75 79
    LEGEND 4 GAMMA = 0.5; LEGEND 4 COORDINATES 75 75
    LINES SOLID DASH DOT DASH2
    PLOT WEIPDF(X,1) FOR X = 0.01 0.01 3 AND
    PLOT WEIPDF(X,2) FOR X = 0.01 0.01 3 AND
    PLOT WEIPDF(X,5) FOR X = 0.4 0.01 1.6 AND
    PLOT WEIPDF(X,0.5) FOR X = 0.05 0.01 2
 
-----WEIPPF (LET)--------------------------------
 
WEIPPF
 
Name:
    WEIPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the Weibull percent point function
    with tail length parameter GAMMA.
 
Description:
    For the minimum order statistic, the standard form of the
    Weibull probability density function is:
       f(x) = gamma*x**(gamma-1)*exp(-(x**gamma))    x > 0
    For the maximum order statistic, the standard form of the
    Weibull probability density function is:
       f(x) = gamma*(-x)**(gamma-1)*exp(-((-x)**gamma))    x < 0
    In either case, GAMMA should be positive.  The percent point
    function is the inverse of the cumulative distribution function.
    The cumulative distribution sums the probability from 0 to the
    given x value.  The percent point function takes a cumulative
    probability value and computes the corresponding x value.
 
Syntax:
    LET <y2> = WEIPPF(<y1>,GAMMA) <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, number, or parameter containing values
               between 0 and 1;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed Weibull ppf value is stored;
          <GAMMA> is a positive number or parameter that specifies the
               tail length parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = WEIPPF(0.9,2)
    LET A = WEIPPF(A1,8)
    LET X2 = WEIPPF(X1,4)
 
Note:
    The SET MINMAX command specifies whether the minimum or maximum
    order statistic form is used.  Entering SET MINMAX 2 specifies the
    maximum order statistic while entering SET MINMAX specifies the
    minimum order statistic.
 
Note:
    For the minimum order statistic, the general form of the
    Weibull probability density function is:
       f(x) = (gamma/alpha)*((x-u)/alpha)**(gamma-1)*
                 exp(-((x-u)/alpha)**gamma))    x > u
    For the maximum order statistic, the general form of the
    Weibull probability density function is:
       f(x) = (gamma/alpha)*((-x-u)/alpha)**(gamma-1)*
                 exp(-((-x-u)/alpha)**gamma))   x < u
    where u is the location parameter and alpha is the scale parameter.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPDF = Compute the chi-square probability density function.
    FCDF   = Compute the F cumulative distribution function.
    FPDF   = Compute the F probability density function.
    FPPF   = Compute the F percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    TCDF   = Compute the T cumulative distribution function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, 1970.
 
Applications:
    Reliability Analysis
 
Implementation Date:
    XX
 
Program:
    TITLE PLOT WEIPPF FOR VARIOUS VALUES OF GAMMA
    SEGMENT 1 COORDINATES 16 88 21 88; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 16 84 21 84; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 16 80 21 80; SEGMENT 3 PATTERN DOT
    SEGMENT 4 COORDINATES 16 76 21 76; SEGMENT 4 PATTERN DASH2
    LEGEND 1 GAMMA = 1; LEGEND 1 COORDINATES 22 87
    LEGEND 2 GAMMA = 2; LEGEND 2 COORDINATES 22 83
    LEGEND 3 GAMMA = 5; LEGEND 3 COORDINATES 22 79
    LEGEND 4 GAMMA = 0.5; LEGEND 4 COORDINATES 22 75
    XLIMITS 0 1; MAJOR XTIC NUMBER 6
    MINOR XTIC NUMBER 1; XTIC DECIMAL 1
    LINES SOLID DASH DOT DASH2
    YLIMITS 0 5; MAJOR YTIC MARK NUMBER 6; YTIC OFFSET 0 0.3
    PLOT WEIPPF(X,1) FOR X = 0.01 .01 0.99 AND
    PLOT WEIPPF(X,2) FOR X = 0.01 .01 0.99 AND
    PLOT WEIPPF(X,5) FOR X = 0.01 .01 0.99 AND
    PLOT WEIPPF(X,0.5) FOR X = 0.01 .01 0.90
 
-----WEIGHTED AVERAGE ABSOLUTE VALUE (LET)--------------------------
 
WEIGHTED AVERAGE ABSOLUTE VALUE
 
Name:
    WEIGHTED AVERAGE ABSOLUTE VALUE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the weighted average absolute value of a variable.
 
Description:
    The weighted average absolute value is defined as

        WAV = SUM[i=1 to N][W(i)*|X(i)|]/SUM[i=1 to N][W(i)]

    where X is the response variable and W is the weights variable.
    The response variable and weights variable must have the same
    number of observations.

    For this command, the weights are not normalized.  However, at least
    one of the weights must be positive and none of the weights can be
    negative.  Otherwise, an error message is reported.
 
Syntax:
    LET <par> = WEIGHTED AVERAGE ABSOLUTE VALUE <x> <w>
                <SUBSET/EXCEPT/FOR qualification>
    where <x> is the response variable;
          <w> is the weights variable;
          <par> is a parameter where the weighted average absolute value
              is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = WEIGHTED AVERAGE ABSOLUTE VALUE Y1 WEIGHT
    LET A = WEIGHTED AVERAGE ABSOLUTE VALUE Y1 WEIGHT  SUBSET Y1 > 0
 
Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WEIGHTED SUM                 = Compute the weighted sum of a variable.
    WEIGHTED SUM OF SQUARES      = Compute the weighted sum of squares of a
                                   variable.
    WEIGHTED SUM OF ABSO VALUES  = Compute the weighted sum of absolute
                                   values of a variable.
    WEIGHTED SUM OF DEVIATIONS   = Compute the weighted sum of deviations
             FROM THE MEAN         from the mean of a variable.
    WEIGHTED MEAN                = Compute the weighted mean of a variable.
    WEIGHTED STAND DEVI          = Compute the weighted standard deviation of
                                   a variable.
    WEIGHTED VARIANCE            = Compute the weighted variance of a
                                   variable.
 
Applications:
    Data Analysis
 
Implementation Date:
    2012/06
 
Program:
    LET Y = DATA 2 3 -5 7 11 13 -17 19 23
    LET W = DATA 1 1 0 0 4 1 2 1 0
    .
    LET A = WEIGHTED AVERAGE ABSOLUTE VALUE Y W
 
-----WEIGHTED CORRELATION (LET)--------------------------------
 
WEIGHTED CORRELATION
WEIGHTED COVARIANCE
WEIGHTED COSINE DISTANCE
WEIGHTED COSINE SIMILARITY
 
Name:
    WEIGHTED CORRELATION (LET)
    WEIGHTED COVARIANCE (LET)
    WEIGHTED COSINE DISTANCE (LET)
    WEIGHTED COSINE SIMILARITY (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the weighted correlation coefficient between two variables.
 
Description:
    Given paired response variables X and Y of length N and a weights
    variable W, the weighted covariance is computed with the formula

        COV(X,Y;W) = SUM[i=1 to N][W(i)*(X(i) - M(X;W))*(Y(i) - M(Y;W))/
                     SUM[i=1 to N][W(i)]

    where M denotes the weighted mean.

        M(X;W) = SUM[i=1 to N][W(i)*X(i)/W(i)]

    The weighted correlation coefficient is computed with the formula

         r   = Sxy/SQRT(Sxx*Syy)
             = COV(X,Y;W)/SQRT(COV(X,X;W)*COV(Y,Y;W))

    where

         Sxx = SUM[i=1 to N][W(i)*(X(i)-M(X;W))**2]
         Syy = SUM[i=1 to N][W(i)*(Y(i)-M(Y;W))**2]
         Sxy = SUM[i=1 to N][(W(i)*(X(i)-M(X;W))*(Y(i)-M(Y;W))]

    where X and Y are paired repsonse variables of length N, W is the
    weights variable and M denotes the weighted mean.

    The cosine similarity, which is equivalent to the reflective
    correlation coefficient, is defined as
 
        Cosine Similarity = SUM[i=1 to n][X(i)*Y(i)]/
                            {SQRT(SUM{i=1 to n][X(i)**2])*
                            SQRT(SUM{i=1 to n][Y(i)**2])}

    The cosine distance is then defined as

        Cosine Distance = 1 - Cosine Similarity

    The weighted cosine similarity is defined as

        Cosine Similarity = SUM[i=1 to n][W(i)*X(i)*Y(i)]/
                            {SQRT(SUM{i=1 to n][W(i)*X(i)**2])*
                            SQRT(SUM{i=1 to n][W(i)*Y(i)**2])}

    The weighted cosine distance is then defined as

        Weighted Cosine Distance = 1 - Weighted Cosine Similarity

    A weighted linear regression is sometimes used when the error
    variances are not homogeneous (e.g, variances are often higher in
    one or both tails).  In these cases, you may also want to obtain a
    weighted correlation coefficient using the same weights as the linear
    fit.

    The Alaska pipeline case study in the NIST/SEMATECH e-Handbook of
    Statistical Methods gives an example of how weights can be
    determined.  Although this is done in the context of a regression
    analysis, the same approach applies to weighted correlation and
    weighted covariance.  See

       https://www.itl.nist.gov/div898/handbook/pmd/section6/pmd625.htm

    If you have grouped data (i.e., a bivariate frequency table), use the
    GROUPED CORRELATION command.  Grouped correlation is similar to
    weighted correlation, but a different computational formula is used.

Syntax 1:
    LET <par> = WEIGHTED CORRELATION <y1> <y2> <weights>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <weights> is the weights variable;
          <par> is a parameter where the computed weighted correlation is
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    LET <par> = WEIGHTED COVARIANCE <y1> <y2> <weights>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <weights> is the weights variable;
          <par> is a parameter where the computed weighted covariance is
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 3:
    LET <par> = WEIGHTED COSINE DISTANCE <y1> <y2> <weights>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <weights> is the weights variable;
          <par> is a parameter where the computed weighted cosine
               distance is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 4:
    LET <par> = WEIGHTED COSINE SIMILARITY <y1> <y2> <weights>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <weights> is the weights variable;
          <par> is a parameter where the computed weighted cosine
               similarity is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = WEIGHTED CORRELATION Y1 Y2 WEIGHTS
    LET A = WEIGHTED COVARIANCE  Y1 Y2 WEIGHTS
    LET A = WEIGHTED COSINE DISTANCE  Y1 Y2 WEIGHTS
    LET A = WEIGHTED COSINE SIMILARITY  Y1 Y2 WEIGHTS
 
Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GROUPED CORRELATION         = Compute the correlation coefficient
                                  based on bivariate frequency data.
    WEIGHED COSINE DISTANCE     = Compute the weighted cosine distance.
    CORRELATION                 = Compute the correlation of two variables.
    COVARIANCE                  = Compute the covariance of two variables.
    CORRELATION MATRIX          = Generate a correlation matrix.
    RANK CORRELATION            = Compute the rank correlation of two
                                  variables.
    KENDALLS TAU                = Compute the Kendall tau correlation of
                                  two variables.
    WINSORIZED CORRELATION      = Compute the Winsorized correlation of
                                  two variables.
    BIWEIGHT MIDCORRELATION     = Compute the biweight mid-correlation of
                                  two variables.
    PERCENTAGE BEND CORRELATION = Compute the percentage bend correlation
                                  of two variables.
    COVARIANCE                  = Compute the covariance of two variables.
    PARTIAL CORRELATION         = Compute the partial correlation of
                                  three variables.
    PARTIAL CORRELATION MATRIX  = Generate the partial correlation matrix.
 
Reference:
    "Re: Compute a weighted correlation", sci.tech-archive.net
    http://sci.tech-archive.net/Archive/sci.stat.math/2006-02/msg00171.html

Applications:
    Linear Regression
 
Implementation Date:
    2018/10
 
Program:
    . Step 1:   Read the data
    .
    skip 25
    read berger1.dat y x batch
    .
    . Step 2:   Compute both the unweighted and weighted correlations
    .
    .           Weights from e-Handbook case study of Alaska pipeline data
    .
    let wt = 1/(x**(1.5))
    let corr = correlation y x
    let wtcorr = weighted correlation y x wt
    let cov = covariance y x
    let wtcov = weighted covariance y x wt
    .
    set write decimals 3
    print "Unweighted correlation:  ^corr"
    print "Weighted correlation:    ^wtcorr"
    print "Unweighted covariance:   ^cov"
    print "Weighted covariance:     ^wtcov"
 
-----WEIGHTED MEAN (LET)----------------------------------------------
 
WEIGHTED MEAN
 
Name:
    WEIGHTED MEAN (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the weighted mean of a variable.
 
Description:
    The standard formula for the mean is:
        mean = sum(Xi)/n
    while the formula for the weighted mean is:
        mean = sum(Wi * Xi)/sum of weights
    where Wi is the weight for the ith observation.  Weighted means
    are often used for frequency data.
 
Syntax:
    LET <par> = WEIGHTED MEAN <x1> <weights>
               <SUBSET/EXCEPT/FOR qualification>
    where <x1> is the variable for which the weighted mean is to be
               computed;
          <weights> is a variable containing the weights;
          <par> is a parameter where the weighted mean is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET MEAN = WEIGHTED MEAN Y1 WEIGHT
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    MEAN                 = Compute the mean of a variable.
    MEDIAN               = Compute the median of a variable.
    STANDARD DEVIATION   = Compute the standard deviation of a
                           variable.
    VARIANCE             = Compute the variance of a variable.
    WEIGHTED SUM         = Compute the weighted sum of a variable.
    WEIGHTED STAND DEVI  = Compute the weighted standard deviation of
                           a variable.
    WEIGHTED VARIANCE    = Compute the weighted variance of a
                           variable.
 
Applications:
    Data Analysis
 
Implementation Date:
    Pre-1987
 
Program:
    LET Y = DATA 2 3 5 7 11 13 17 19 23
    LET W = DATA 1 1 0 0 4 1 2 1 0
    LET A = WEIGHTED MEAN Y W
 
-----WEIGHTED ORDER STATISTIC MEAN (LET)-------------------------------
 
WEIGHTED ORDER STATISTIC MEAN
 
Name:
    WEIGHTED ORDER STATISTIC MEAN (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the weighted order statistic mean of a variable.
 
Description:
    The formula for the weighted order statistic mean is

        WOS = SUM[i=1 to N][(W(i)*X(i()]/SUM[i=1 to N][W(i)]

    with X(i) and W(i) denoting the response variable and the
    weights variable respectively.

    Note that the X(i) will be sorted while the W(i) will not be
    sorted before applying this formula.  That is, the W(i) weight
    applies to the i-th order statistic, not the i-th response
    value.  This is the main distinction between this command and
    the WEIGHTED MEAN command.

Syntax:
    LET <par> = WEIGHTED ORDER STATISTIC MEAN <y> <w>
                <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <w> is the weights varialbe;
          <par> is a parameter where the weighted order statistic mean
              is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET WOS = WEIGHTED ORDER STATISTIC MEAN Y1 WEIGHT
    LET WOS = WEIGHTED ORDER STATISTIC MEAN Y1 SUBSET TAG = 1
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WEIGHTED MEAN        = Compute the weighted mean of a variable.
    WEIGHTED SUM         = Compute the weighted sum of a variable.
    WEIGHTED STAND DEVI  = Compute the weighted standard deviation of
                           a variable.
    MEAN                 = Compute the mean of a variable.
    CONSENSUS MEANS      = Perform a consensus means analysis.
 
Applications:
    Consensus Means
 
Implementation Date:
    2012/11
 
Program:
    let y = data 1 4 9 16 25
    let w = data 0 1 1 1 0
    .
    let b = weighted order statistic mean y w
    .
    title case asis
    title offset 2
    title Bootstrap Plot for Weighted Order Statistic Means
    label case ais
    y1label Weighted Order Statistic Mean
    x1label Bootstrap Sample
    .
    bootstrap sample 1000
    set write decimals 5
    bootstrap weighted order statistic mean plot y w
 
-----WEIGHTED STANDARD DEVIATION (LET)--------------------------------
 
WEIGHTED STANDARD DEVIATION
 
Name:
    WEIGHTED STANDARD DEVIATION (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the weighted standard deviation of a variable.
 
Description:
    The standard formula for the standard deviation is:
        sd = SQRT(SUM((Xi-xmean)**2)/(n-1))
    while the formula for the weighted standard deviation is:
        wsd = SQRT(SUM(Wi*(Xi-wmean)**2)/(sum of weights - 1))
    where Wi is the weight for the ith observation and wmean is the
    weighted mean.  Weighted standard deviations are often used for
    frequency data.
 
Syntax:
    LET <par> = WEIGHTED STANDARD DEVIATION <x1>
              <SUBSET/EXCEPT/FOR qualification>
    where <x1> is the variable for which the weighted standard
              deviation is to be computed;
          <weights> is a variable containing the weights;
          <par> is a parameter where the weighted standard deviation
               is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET STANDARD DEVIATION = WEIGHTED MEAN Y1 WEIGHT
    LET STANDARD DEVIATION = WEIGHTED MEAN Y1 WEIGHT SUBSET TAG > 2
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    MEAN                 = Compute the mean of a variable.
    MEDIAN               = Compute the median of a variable.
    STANDARD DEVIATION   = Compute the standard deviation of a
                           variable.
    VARIANCE             = Compute the variance of a variable.
    WEIGHTED MEAN        = Compute the weighted mean of a variable.
    WEIGHTED VARIANCE    = Compute the weighted variance of a variable.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    LET Y = DATA 2 3 5 7 11 13 17 19 23
    LET W = DATA 1 1 0 0 4 1 2 1 0
    LET A = WEIGHTED STANDARD DEVIATION Y W
 
-----WEIGHTED SUM (LET)----------------------------------------------
 
WEIGHTED SUM
 
Name:
    WEIGHTED SUM (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the weighted sum of a variable.
 
Description:
    The weighted sum is defined as

        WS = SUM[i=1 to N][W(i)*X(i)]

    where X is the response variable and W is the weights variable.
    The response variable and weights variable must have the same
    number of observations.

    For this command, the weights are not normalized.  However, at least
    one of the weights must be positive and none of the weights can be
    negative.  Otherwise, an error message is reported.
 
Syntax:
    LET <par> = WEIGHTED SUM <x> <w>    <SUBSET/EXCEPT/FOR qualification>
    where <x> is the response variable;
          <w> is the weights variable;
          <par> is a parameter where the weighted sum is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = WEIGHTED SUM Y1 WEIGHT
    LET A = WEIGHTED SUM Y1 WEIGHT  SUBSET Y1 > 0
 
Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WEIGHTED SUM OF SQUARES      = Compute the weighted sum of squares of a
                                   variable.
    WEIGHTED SUM OF ABSO VALUES  = Compute the weighted sum of absolute
                                   values of a variable.
    WEIGHTED AVER OF ABSO VALUES = Compute the weighted average of absolute
                                   values of a variable.
    WEIGHTED SUM OF DEVIATIONS   = Compute the weighted sum of deviations
             FROM THE MEAN         from the mean of a variable.
    WEIGHTED MEAN                = Compute the weighted mean of a variable.
    WEIGHTED STAND DEVI          = Compute the weighted standard deviation of
                                   a variable.
    WEIGHTED VARIANCE            = Compute the weighted variance of a
                                   variable.
 
Applications:
    Data Analysis
 
Implementation Date:
    2012/06
 
Program:
    LET Y = DATA 2 3 5 7 11 13 17 19 23
    LET W = DATA 1 1 0 0 4 1 2 1 0
    .
    LET A = WEIGHTED SUM Y W
 
-----WEIGHTED SUM OF ABSOLUTE VALUES (LET)---------------------------
 
WEIGHTED SUM OF ABSOLUTE VALUES
 
Name:
    WEIGHTED SUM OF ABSOLUTE VALUES (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the weighted sum of absolute values of a variable.
 
Description:
    The weighted sum of absolute values is defined as

        WSA = SUM[i=1 to N][W(i)*|X(i)|]

    where X is the response variable and W is the weights variable.
    The response variable and weights variable must have the same
    number of observations.

    For this command, the weights are not normalized.  However, at least
    one of the weights must be positive and none of the weights can be
    negative.  Otherwise, an error message is reported.
 
Syntax:
    LET <par> = WEIGHTED SUM OF ABSOLUTE VALUES <x> <w>
                <SUBSET/EXCEPT/FOR qualification>
    where <x> is the response variable;
          <w> is the weights variable;
          <par> is a parameter where the weighted sum of absolute values
              is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = WEIGHTED SUM OF ABSOLUTE VALUES Y1 WEIGHT
    LET A = WEIGHTED SUM OF ABSOLUTE VALUES Y1 WEIGHT  SUBSET Y1 > 0
 
Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WEIGHTED SUM                 = Compute the weighted sum of a variable.
    WEIGHTED SUM OF SQUARES      = Compute the weighted sum of squares of a
                                   variable.
    WEIGHTED AVER OF ABSO VALUES = Compute the weighted average of absolute
                                   values of a variable.
    WEIGHTED SUM OF DEVIATIONS   = Compute the weighted sum of deviations
             FROM THE MEAN         from the mean of a variable.
    WEIGHTED MEAN                = Compute the weighted mean of a variable.
    WEIGHTED STAND DEVI          = Compute the weighted standard deviation of
                                   a variable.
    WEIGHTED VARIANCE            = Compute the weighted variance of a
                                   variable.
 
Applications:
    Data Analysis
 
Implementation Date:
    2012/06
 
Program:
    LET Y = DATA 2 3 -5 7 11 13 -17 19 23
    LET W = DATA 1 1 0 0 4 1 2 1 0
    .
    LET A = WEIGHTED SUM OF ABSOLUTE VALUES Y W
 
-----WEIGHTED SUM OF DEVIATIONS FROM THE MEAN (LET)-------------------
 
WEIGHTED SUM OF DEVIATIONS FROM THE MEAN
 
Name:
    WEIGHTED SUM OF DEVIATIONS FROM THE MEAN (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the weighted sum of deviations from the mean of a variable.
 
Description:
    The weighted sum of deviations from the mean is defined as

        WDEV = SUM[i=1 to N][W(i)*(X(i) - XBAR)]

    where X is the response variable, W is the weights variable, and
    XBAR is the sample mean.  The response variable and weights variable
    must have the same number of observations.

    For this command, the weights are not normalized.  However, at least
    one of the weights must be positive and none of the weights can be
    negative.  Otherwise, an error message is reported.
 
Syntax:
    LET <par> = WEIGHTED SUM OF DEVIATIONS FROM THE MEAN <x> <w>
                <SUBSET/EXCEPT/FOR qualification>
    where <x> is the response variable;
          <w> is the weights variable;
          <par> is a parameter where the weighted sum of deviations
              from the mean is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = WEIGHTED SUM OF DEVIATIONS FROM THE MEAN Y1 WEIGHT
    LET A = WEIGHTED SUM OF DEVIATIONS FROM THE MEAN Y1 WEIGHT  SUBSET Y1 > 0
 
Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WEIGHTED SUM                 = Compute the weighted sum of a variable.
    WEIGHTED SUM OF SQUARES      = Compute the weighted sum of squares of a
                                   variable.
    WEIGHTED SUM OF ABSO VALUES  = Compute the weighted sum of absolute
                                   values of a variable.
    WEIGHTED AVER OF ABSO VALUES = Compute the weighted average of absolute
                                   values of a variable.
    WEIGHTED MEAN                = Compute the weighted mean of a variable.
    WEIGHTED STAND DEVI          = Compute the weighted standard deviation of
                                   a variable.
    WEIGHTED VARIANCE            = Compute the weighted variance of a
                                   variable.
 
Applications:
    Data Analysis
 
Implementation Date:
    2012/06
 
Program:
    LET Y = DATA 2 3 5 7 11 13 17 19 23
    LET W = DATA 1 1 0 0 4 1 2 1 0
    .
    LET A = WEIGHTED SUM OF DEVIATIONS FROM THE MEAN Y W
 
-----WEIGHTED SUM OF SQUARES (LET)--------------------------------------
 
WEIGHTED SUM OF SQUARES
 
Name:
    WEIGHTED SUM OF SQUARES (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the weighted sum of squares of a variable.
 
Description:
    The weighted sum of squares is defined as

        WSS = SUM[i=1 to N][W(i)*X(i)**2]

    where X is the response variable and W is the weights variable.
    The response variable and weights variable must have the same
    number of observations.

    For this command, the weights are not normalized.  However, at least
    one of the weights must be positive and none of the weights can be
    negative.  Otherwise, an error message is reported.
 
Syntax:
    LET <par> = WEIGHTED SUM OF SQUARES <x> <w> 
                <SUBSET/EXCEPT/FOR qualification>
    where <x> is the response variable;
          <w> is the weights variable;
          <par> is a parameter where the weighted sum of squares is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = WEIGHTED SUM OF SQUARES Y1 WEIGHT
    LET A = WEIGHTED SUM OF SQUARES Y1 WEIGHT  SUBSET Y1 > 0
 
Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WEIGHTED SUM                 = Compute the weighted sum of a variable.
    WEIGHTED SUM OF ABSO VALUES  = Compute the weighted sum of absolute
                                   values of a variable.
    WEIGHTED AVER OF ABSO VALUES = Compute the weighted average of absolute
                                   values of a variable.
    WEIGHTED SUM OF DEVIATIONS   = Compute the weighted sum of deviations
             FROM THE MEAN         from the mean of a variable.
    WEIGHTED MEAN                = Compute the weighted mean of a variable.
    WEIGHTED STAND DEVI          = Compute the weighted standard deviation of
                                   a variable.
    WEIGHTED VARIANCE            = Compute the weighted variance of a
                                   variable.
 
Applications:
    Data Analysis
 
Implementation Date:
    2012/06
 
Program:
    LET Y = DATA 2 3 5 7 11 13 17 19 23
    LET W = DATA 1 1 0 0 4 1 2 1 0
    .
    LET A = WEIGHTED SUM OF SQUARES Y W
 
-----WEIGHTED SUM OF SQUARED DEVIATIONS FROM MEAN (LET)--------------
 
WEIGHTED SUM OF SQUARED DEVIATIONS FROM MEAN
 
Name:
    WEIGHTED SUM OF SQUARED DEVIATIONS FROM MEAN (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the weighted sum of squared deviations from the mean of a
    variable.
 
Description:
    The weighted sum of squared deviations from the mean is defined as

        WDEV = SUM[i=1 to N][W(i)*(X(i) - XBAR)**2]

    where X is the response variable and W is the weights variable.
    The response variable and weights variable must have the same
    number of observations.

    For this command, the weights are not normalized.  However, at least
    one of the weights must be positive and none of the weights can be
    negative.  Otherwise, an error message is reported.
 
Syntax:
    LET <par> = WEIGHTED SUM OF SQUARED DEVIATIONS FROM THE MEAN <x> <w>
                <SUBSET/EXCEPT/FOR qualification>
    where <x> is the response variable;
          <w> is the weights variable;
          <par> is a parameter where the weighted sum of squared deviations
              from the mean is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = WEIGHTED SUM OF SQUARED EVIATIONS FROM MEAN Y1 WEIGHT
    LET A = WEIGHTED SUM OF SQUARED DEVIATIONS FROM MEAN Y1 WEIGHT  SUBSET Y1 > 0
 
Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WEIGHTED SUM OF DEVI FROM MEAN  = Compute the weighted sum of deviations
                                      from the mean values of a variable.
    WEIGHTED SUM                    = Compute the weighted sum of a
                                      variable.
    WEIGHTED SUM OF SQUARES         = Compute the weighted sum of squares
                                      of a variable.
    WEIGHTED SUM OF ABSO VALUES     = Compute the weighted sum of absolute
                                      values of a variable.
    WEIGHTED AVER OF ABSO VALUES    = Compute the weighted average of absolute
                                      values of a variable.
    WEIGHTED MEAN                   = Compute the weighted mean of a variable.
    WEIGHTED STAND DEVI             = Compute the weighted standard deviation of
                                      a variable.
    WEIGHTED VARIANCE               = Compute the weighted variance of a
                                      variable.
 
Applications:
    Data Analysis
 
Implementation Date:
    2012/06
 
Program:
    LET Y = DATA 2 3 5 7 11 13 17 19 23
    LET W = DATA 1 1 0 0 4 1 2 1 0
    .
    LET A = WEIGHTED SUM OF DEVIATIONS FROM THE MEAN Y W
 
-----WEIGHTED TRIMMED MEAN (LET)------------------------------------
 
WEIGHTED TRIMMED MEAN
 
Name:
    WEIGHTED TRIMMED MEAN (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the weighted trimmed mean of a variable.
 
Description:
    The mean is the sum of the observations divided by the number of
    observations.  The mean can be heavily influenced by extreme values
    in the tails of a variable.  The trimmed mean compensates for this
    by dropping a certain percentage of values on the tails.  For
    example, the 50% trimmed mean is the mean of the values between
    the upper and lower quartiles.  The 90% trimmed mean is the mean
    of the values after truncating the lowest and highest 5% of the
    values.

    In some cases, you can also apply weights in computing the
    means.  For example, this may be done when your data is
    in the form of a frequency table (i.e., the frequencies define
    the weights).

    The weighted trimmed mean is used to apply weights to the
    trimmed mean command.
 
    The formula for computing the weighted trimmed mean is

        WTM = SUM[i=kstrt to kstop][W(i)*X(i)]/SUM[i=kstrt to kstop][W(i)]

    where X is the sorted response variable, W is the weights variable, and
    kstrt and kstop define the indices of the first and last observations
    that are not trimmed.  The response variable and weights variable must
    have the same number of observations.

    At least one of the weights must be positive and none of the weights
    can be negative.  Otherwise, an error message is reported.
 
Syntax:
    LET <par> = WEIGHTED TRIMMED MEAN <x> <w>
                <SUBSET/EXCEPT/FOR qualification>
    where <x> is the response variable;
          <w> is the weights variable;
          <par> is a parameter where the weighted trimmed mean is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = WEIGHTED TRIMMED MEAN Y1 WEIGHT
    LET A = WEIGHTED TRIMMED MEAN Y1 WEIGHT  SUBSET Y1 > 0
 
Note:
    The analyst must specify the percentages to trim in each tail.
    This is done by defining the internal variables P1 (the lower
    tail) and P2 (the upper tail).  For example, to trim 10% off each
    tail, do the following:

        LET P1 = 10
        LET P2 = 10
        LET A = WEIGHTED TRIMMED MEAN Y W
 
Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TRIMMED MEAN                 = Compute the trimmed mean of a variable.
    WEIGHTED MEAN                = Compute the weighted mean of a variable.
    WEIGHTED SUM                 = Compute the weighted sum of a variable.
    WEIGHTED SUM OF SQUARES      = Compute the weighted sum of squares of a
                                   variable.
    WEIGHTED SUM OF ABSO VALUES  = Compute the weighted sum of absolute
                                   values of a variable.
    WEIGHTED AVER OF ABSO VALUES = Compute the weighted average of absolute
                                   values of a variable.
    WEIGHTED SUM OF DEVIATIONS   = Compute the weighted sum of deviations
             FROM THE MEAN         from the mean of a variable.
    WEIGHTED STAND DEVI          = Compute the weighted standard deviation of
                                   a variable.
    WEIGHTED VARIANCE            = Compute the weighted variance of a
                                   variable.
 
Applications:
    Data Analysis
 
Implementation Date:
    2012/06
 
Program:
    let y = double exponential random numbers for i = 1 1 10000
    set histogram empty bins off
    set histogram class width normal corrected
    let y2 x2 = binned y
    .
    let ymean = mean y
    let ymed  = median y
    let wmean = weighted mean x2 y2
    let p1 = 10
    let p2 = 10
    let wtrim = weighted trimmed mean x2 y2
    .
    set write decimals 3
    print ymean ymed wmean wtrim

-----WEIGHTED VARIANCE (LET)--------------------------------
 
WEIGHTED VARIANCE
 
Name:
    WEIGHTED VARIANCE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the weighted variance of a variable.
 
Description:
    The formula for the variance is:
        var = SUM((Xi-xmean)**2)/(n-1)
    while the formula for the weighted variance is:
        wvar = SUM(Wi*(Xi-wmean)**2)/(sum of weights - 1)
    where Wi is the weight for the ith observation and wmean is the
    weighted mean.  Weighted variances are often used for frequency
    data.
 
Syntax:
    LET <par> = WEIGHTED VARIANCE <x1>
              <SUBSET/EXCEPT/FOR qualification>
    where <x1> is the variable for which the weighted variance is to
              be computed;
          <weights> is a variable containing the weights;
          <par> is a parameter where the weighted variance is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET VAR = WEIGHTED VARIANCE Y1 WEIGHT
    LET VAR = WEIGHTED VARIANCE Y1 WEIGHT  SUBSET TAG > 2
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    MEAN                 = Compute the mean of a variable.
    MEDIAN               = Compute the median of a variable.
    STANDARD DEVIATION   = Compute the standard deviation of a
                           variable.
    VARIANCE             = Compute the variance of a variable.
    WEIGHTED MEAN        = Compute the weighted mean of a variable.
    WEIGHTED STAND DEVI  = Compute the weighted standard deviation of
                           a variable.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    LET Y = DATA 2 3 5 7 11 13 17 19 23
    LET W = DATA 1 1 0 0 4 1 2 1 0
    LET A = WEIGHTED VARIANCE Y W
 
-----WEIGHTS-------------------------------------------------------

WEIGHTS

Name:
    WEIGHTS

Type:
    Support Command

Purpose:
    Specifies the weights for subsequent FIT commands.

Description:
    Weighted fits are typically used in the following two cases:
       1) When the analyst has pre-specified weights;
       2) To perform various types of robust fitting.

    For case 1, the weights are values which reflect the analyst's
    confidence in the precision of the response value:
       1) high-precision response values are assigned high weights;
       2) middle-precision response values are assigned middle
          weights;
       3) low-precision response values are assigned low weights.
    If no weights are specified via the WEIGHTS command, the FIT 
    command defaults to equal weights.  The WEIGHTS command is used
    to incorporate additional information (namely, the nature of the
    error structure) into the fitting process.  The net result is
    improved least squares fitting estimates.

    Least squares fitting generates optimal fits given independent
    normally distributed errors with constant variance.  However, if
    the errors do not satisfy these assumptions, then the least
    squares estimates may be unduly affected.  Robust fitting methods
    attempt to generate good fits for a range of error distributions.
    In particular, they protect against heavy tailed distributions
    which have outliers relative to a normal distribution.  Robust
    estimates should be stable if a few values are changed
    significantly or if a large number of values are changed by a
    small amount.  One class of robust methods works by
    down-weighting large residuals.  This is discussed in more detail
    in a NOTE sections below.

    The desired weight values must be placed in a variable by the
    analyst.  This is most commonly done via the SERIAL READ, the
    READ, or the LET commands.  For example, to specify that 25, 25,
    50, 80, and 70.5 are to be the weight values in a linear fit of Y
    on X, one could enter the following sequence of commands:
       LET X2 = DATA 25 25 50 80 70.5
       WEIGHTS X2
       FIT Y = A+B*X

Syntax:
    WEIGHTS   <x>
    where <x> specifies the name of a pre-existing variable which
              contains the desired weights.

Examples:
    WEIGHTS X2
    WEIGHTS W
    WEIGHTS Z

Note:
    There are several approaches to robust estimation.  These
    include:
        1) M-estimators are maximum likelihood estimators that
           minimize the sum of a function of the residuals.
        2) R-estimators are based on ranks.
        3) L-estimators are linear functions of the sample order
           statistics (this includes least median squares
           regression).
    M-estimators can typically be approximated through a technique
    called iteratively re-weighted least squares (or IRLS).  The
    basic algorithm is to start with a least squares fit, weight the 
    residuals by some formula, and then apply a weighted fit.  The
    new residuals are then weighted by the same formula.  This
    continues until the residuals reach some type of convergence
    criterion.  The Heiberger and Becker article (see the REFERENCE
    section below) describe a sophisticated function for doing this
    with the S statistical package.  However, the basic steps can be
    applied to any program that supports weighted least squares. 

    There is no single weighting scheme that works best in all cases.
    Various weighting schemes have been proposed and used.  The 
    Heiberger and Becker article gives 10 of the more popular ones.

    The program examples below show an example of this.  The second 
    program example is a macro (called IRLS.DP) that performs the
    irls.  The program 1 example is a driver that specifies the fit
    to use and the desired weighting function.  The IRLS.DP macro can
    be modified in a straightforward manner:
        1) Additional weighting schemes can be added (or ones that
           you don't use can be deleted).
        2) The maximum number of iterations and the convergence
           criterion can be changed to suit your preference.

    Dataplot does not support the other approaches to robust 
    estimation at this time.

Note:
    Least absolute deviations (LAD) is another robust method.  This
    method minimizes:
        ABSOLUTE VALUE(Y - YPRED)
    Although LAD is usually estimated with linear programming 
    techniques, it can also be estimated with the irls algorithm.
    The program 2 example uses a method of Tukey (see the Mosteller
    and Tukey book in the REFERENCE section below).  This method
    gives small residuals a weight of 1 (otherwise small residuals
    tend to have unduly large weights).

Note:
    Robust methods based on weighting the residuals provide
    protection against outliers in the dependent variable.  However,
    it does not necessarily protect against outliers in the
    independent variables.  Points with high leverage (see the
    documentation for the FIT command) can exert enough influence on
    the fit that they will have small residuals even though they
    might be outliers.  The Hamilton book (see the REFERENCE section
    below) offers the following suggestion for this problem:
      1) Let h(i) be the leverage for the ith case.  The leverage
         values are written to a file for linear and multi-linear
         fits (see the documentation for the FIT command for
         details).  Let CH be the 90th percentile of the h(i).  In
         Dataplot, do:
            FIT ...
            SKIP 1
            READ DPST3F.DAT JUNK HI
            LET CH = NINTH DECILE HI
      2) Calculate a weight based on leverage as follows (assume the
         HI and CH were calculated as in step 1):
            LET WEIGHTH = HI
            LET WEIGHTH = 1 SUBSET HI <= CH
            LET WEIGHTH = (CH/HI)**2  SUBSET HI > CH
      3) In the IRLS algorithm, multiply the robustness weights by
         WEIGHTH.  The WEIGHTH values are only computed once, but
         they are multiplied by the robustness weights at each
         iteration in the IRLS.

Note:
    Robust techniques generally involve a trade-off between
    efficiency and robustness.  Efficiency refers to how well the
    method performs when the errors do in fact satisfy the least
    squares assumptions.  Robustness refers to the performance over a
    range of error distributions.  The trade-off is usually handled
    by specifying a tuning constant.  Most of the tuning constants in
    the program 2 example are chosen to yield 95% efficiency.

Note:
    The LET subcommands BIWEIGHT and TRICUBE provide built-in
    weighting functions.  See the documentation for these commands
    for details.

Note:
    Weighted fits can be applied to both linear and non-linear fits.
    The LOWESS command automatically performs biweight weighting.
    The other smooth and fit commands in Dataplot (PRE-FIT, SPLINE
    FIT, SMOOTH) do not support weighted fitting at this time, so the
    irls algorithm cannot be used.

Default:
    None (i.e., all values are assigned equal weights).

Synonyms:
    None

Related Commands:
    FIT               = Perform weighted (or unweighted) linear or
                        non-linear fits.
    BIWEIGHT (LET)    = Perform robust fit via biweight residuals.
    TRICUBE  (LET)    = Perform robust fit via tricube residuals.

REFERENCES
    "Applied Linear Statistical Models", 3rd ed., Neter, Wasserman,
    and Kunter, 1990, Irwin (provides the details of weighted least
    squares).

    "Data Analysis and Regression", Mosteller and Tukey, Addison-
    Wesley, 1977 (chapter 14).

    "Regression With Graphics", Hamilton, Wadsworth, 1992.

    "Design of an S Function for Robust Regression Using Iteratively
    Reweighted Least Squares", Heiberger and Becker, Journal of 
    Computational and Graphical Statistics, September, 1992.

Applications:
    Robust fitting

Implementation Date:
    XX

Program 1:
    LET X = DATA 1 2 3 4 5 6 7 8 9 10
    LET Y = DATA 2 4 60 7 9 12 14 15 18 20
    .
    LET STRING F = FIT Y X
    CHARACTER CIRCLE BLANK
    LINE BLANK SOLID
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    FIT Y X
    TITLE LEAST SQUARES FIT
    PLOT Y PRED VS X
    LET METHOD = 5
    CALL IRLS.DP
    TITLE HUBER WEIGHTS
    PLOT Y PRED VS X 
    LET METHOD = 1
    CALL IRLS.DP
    TITLE ANDREW'S WEIGHTS
    PLOT Y PRED VS X 
    LET METHOD = 11
    CALL IRLS.DP
    TITLE TUKEY's LAD
    PLOT Y PRED VS X 
    END OF MULTIPLOT

Program 2 (the IRLS.DP macro used by program example 1):
    FEEDBACK OFF
    .
    .  Compute iteratively re-weighted least squares in Dataplot.
    .  1) The parameter METHOD should be defined before calling this
    .     macro.  It can have one of the following values:
    .        1   = Andrew's method
    .        2   = Tukey's bisquare
    .        3   = Cauchy
    .        4   = Hampel
    .        5   = Huber
    .        6   = Logistic
    .        7   = median
    .        8   = Welsch
    .        9   = fair
    .       10   = Talworth
    .       11   = Tukey's approximation for least absolute deviation
    .      You can modify this macro to include other methods as well.
    .      In addition, you can modify the tuning constant.  Most of 
    .      these are chosen so that the method is 95% efficient for
    .      error terms that are in fact normally distributed.
    .  2)  The following assumes that a string F has been defined
    .      before calling this macro to define the type of fit.  E.g., 
    .           LET STRING F = FIT Y X
    .  3)  The convergence criterion and the maximum number of
    .      iterations can be modified.
    .   4) The following algorithm is used:
    .      a) Perform an initial unweighted least squares estimate
    .      b) Scale the residuals:
    .            Ui = Ei/s
    .         where s = Median Absolute Deviation/0.6745
    .      c) Apply the specified weight function
    .      d) Check for convergence
    .
    WEIGHT
    ^F
    LET MAXITER = 10
    LOOP FOR K = 1 1 MAXITER
        LET RESOLD = RES
        LET MED = MEDIAN RES
        LET TEMP = ABS(RES - MED)
        LET MAD = MEDIAN TEMP
        LET S = MAD/0.6745
        LET U = RES/S
        IF METHOD = 1
          LET C = 1.339
          LET TAG = ABS(U/C)
          LET WT = 1 SUBSET U = 0
          LET WT = 0 SUBSET TAG > PI
          LET WT = SIN(TAG)/TAG  SUBSET TAG <= PI
        END OF IF
        IF METHOD = 2
          LET C = 4.685
          LET TAG = ABS(U/C)
          LET WT = 0 SUBSET TAG > 1
          LET WT = (1 - TAG**2)**2  SUBSET TAG <= 1
        END OF IF
        IF METHOD = 3
          LET C = 2.385
          LET WT = 1/(1 + (u/c)**2)
        END OF IF
        IF METHOD = 4
          LET C = 8
          LET A = 2
          LET B = 4
          LET TAG = ABS(U)
          LET WT = 1 SUBSET U <= A
          LET WT = A/TAG  SUBSET TAG > A   SUBSET TAG <= B
          LET WT = (A/TAG)*((C-TAG)/(C-B)) SUBSET TAG > B SUBSET TAG <= C
          LET WT = 0 SUBSET U > C
        END OF IF
        IF METHOD = 5
          LET C = 1.345
          LET TAG = ABS(U)
          LET WT = 1 SUBSET TAG <= C
          LET WT = C/TAG  SUBSET TAG > C
        END OF IF
        IF METHOD = 6
          LET C = 1.205
          LET TAG = ABS(U/C)
          LET WT = 1 SUBSET U = 0
          LET WT = TANH(TAG)/TAG  SUBSET TAG <> 0
        END OF IF
        IF METHOD = 7
          LET TAG = ABS(U)
          LET WT = 1/0.000001 SUBSET U = 0
          LET WT = 1/TAG SUBSET U <> 0
        END OF IF
        IF METHOD = 8
          LET C = 2.985
          LET TAG = (U/C)**2
          LET WT = EXP(-0.5*TAG)
        END OF IF
        IF METHOD = 9
          LET C = 1.4
          LET WT = 1/(1 + (u/c))**2
        END OF IF
        IF METHOD = 10
          LET C = 2.795
          LET TAG = ABS(U)
          LET WT = 1 SUBSET TAG <= C
          LET WT = 0 SUBSET TAG > C
        END OF IF
        IF METHOD = 11
          LET TEMP = ABS(RES)
          LET C = MEDIAN TEMP
          LET TAG = ABS(Y - PRED)
          LET WT = C/TAG  SUBSET TAG > C
          LET WT = 1 SUBSET TAG <= C
        END OF IF
        WEIGHTS WT
        ^F
        .
        LET DELTA = (RESOLD - RES)**2
        LET NUM = SUM DELTA
        LET NUM = SQRT(NUM)
        LET DELTA2 = RESOLD*RESOLD
        LET DENOM = SUM DELTA2
        LET CONV = NUM/DENOM
        IF CONV <= 0.0001 
          BREAK LOOP
        END OF IF
    END OF LOOP
 
-----WELCH SATTERTHWAITE (LET)------------------------------------------
 
WELCH SATTERTHWAITE
 
Name:
    GUM WELCH SATTERTHWAITE (LET)
    VARIANCES WELCH SATTERTHWAITE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute effective degrees of freedm based on the Welch-Satterthwaite
    equation.
 
Description:
    The Welch-Saitterthwaite equation is used to calculate the
    approximate degrees of freedom for a linear combination of
    independent sample variances.  If the various variances are
    not independent, then the Welch-Satterthwaite approximation
    may not be valid.

    Dataplot supports two versions of the Welch-Saitterthwaite
    approximation.

       1. In performing uncertainty analysis, type A (random)
          and type B (systematic) errors often need to be
          combined.  One issue in combining these uncertainties
          is how to determine the effective degrees of freedom.

          Degrees of freedom for type A uncertainties are the degrees
          of freedom for the repspective type A standard deviations.
          Degrees of freedom for type B uncertainties are often
          available from published reports, certificates, or they may
          be supplied by a vendor.  In cases where a type B component
          is being provided by scientific judgement or the degrees of
          freedom are otherwise not known, it is typical to assume
          infinite degrees of freedom (for practical purposes, infinite
          degrees of freedom may simply be given as a large value
          such as 10,000).

          The Welch-Satterthwaite approximation for the degrees of
          freedom for the standard uncertainty is

             nu = u**4/SUM[i=1 to k][a(i)**4*s(i)**4/nu(i)]

          where

             k       = the number of components
             s(i)    = the standard deviation of the i-th component
             nu(i)   = the degrees of freedom of the i-th component
             a(i)    = the sensitivity coefficient of the i-th component
             u       = the standard uncertainty
                     = SQRT(SUM[i=1 to k][a(i)**2*s(i)**2])

          For this command, the s(i), nu(i), and a(i) are given as inputs
          and u will be computed from the a(i) and s(i) components.

          The sensitivity coefficients are derived from partial
          derivatives of the measurement equation.  For the case of
          additive, independent uncertainties, these can often be set
          to 1.

          The NIST/SEMATACH e-Handbook of Statistical Methods gives some
          examples of this.  In particular, it shows some examples of
          determining the sensitivity coefficients.

       2. Given n variances, s(i)**2, with their associated degrees of
          freedom, nu(i), we want to compute the pooled standard deviation
          and the associated degrees of freedom for the linear combination

              SUM[i=1 to n][k(i)*s(i)**2]

          where k(i) is typically 1/(nu(i) + 1).  The Welch-Saitterwaithe
          approximation for the effective degrees of freedom is given by

              nu = (SUM[i=1 to n][k(i)*s(i)**2))**2/
                   SUM[i=1 to n][(k(i)*s(i)**2)**2/nu(i)]

          A pooled standard deviation is then computed as

              s(pooled) = SQRT{SUM[i=1 to n][nu(i)-1)*s(i)**2]/
                               SUM[i=1 to n][nu(i)-1]}
 
Syntax 1:
    LET <df> = GUM WELCH SATTERTHWAITE <ysd> <ydf> <ysens>
    where <ysd> is a variable containing the standard deviatins
               for the various components of uncertainty;
          <ydf> is a variable containing the degrees of freedom
               for the various components of uncertainty;
          <ysens> is a variable containing the sensitivity coefficients
               for the various components of uncertainty;
    and where <df> is a parameter where the computed degrees of freedom
               is saved.

Syntax 2:
    LET <df> <poolsd> = VARIANCES WELCH SATTERTHWAITE <yvar> <ydf>
    where <yvar> is a variable containing the variances for the various
               components of uncertainty;
          <ydf> is a variable containing the degrees of freedom
               for the various components of uncertainty;
          <df> is a parameter where the computed degrees of freedom
               is saved;
    and where <poolsd> is a parameter where the computed pooled
               standard deviation is saved.

Examples:
    LET IDF = GUM WELCH SATTERTHWAITE YSD YDF YA
    LET IDF POOLSD = VARIANCES WELCH SATTERTHWAITE YVAR YDF
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    T TEST                = Perform a two sample t-test.
    CONSENSUS MEANS       = Compute a consensus mean and its
                            associated uncertainty.
 
Reference:
    Satterthwaite (1946), "An Approximate Distribution of Variance
    Components", Biometrics Bulletin, 2: 110-114.

    Welch (1947), "The Generalization of Students's Problem when Several
    Different Population Variances are Involved", Biometrika, 34: 28-35.

    "Guide to the Expression of Uncertainty in Measurement", ISO,
    Geneva (1993).

    "NIST/SEMATECH Handbook of Statistical Methods", Measurement Process
    Characterization chapter,
    http://www.itl.nist.gov/div898/handbook/mpc/mpc.htm", June, 2003.
 
Applications:
    Uncertainty Analysis
 
Implementation Date:
    2017/01
    2017/07: Updated the formula for the pooled standard deviation
 
Program 1:
    SKIP 25
    READ AUTO83B.DAT Y1 Y2
    LET N1 = SIZE Y1
    LET NU1 = N1 - 1
    LET VAR1 = VARIANCE Y1
    LET N2 = SIZE Y2
    LET NU2 = N2 - 1
    LET VAR2 = VARIANCE Y2
    LET YVAR = DATA VAR1 VAR2
    LET YDF = DATA NU1 NU2
    LET DF POOLSD = VARIANCES WELCH SATTERTHWAITE YVAR YDF
    LET DF = ROUND(DF,2)
    LET POOLSD = ROUND(POOLSD,2)
    PRINT "Degrees of Freedom:   ^DF"
    PRINT "Pooled SD:            ^POOLSD"

Program 2:
    LET YSD = DATA 0.00371 0.00191  0.00191 0.00006
    LET YDF = DATA 2 1000 1000 1000
    LET YA  = DATA 1 1 1 1
    LET DF = GUM WELCH SATTERTHWAITE YSD YDF YA
    LET DF = ROUND(DF,2)
    PRINT "Degrees of Freedom:   ^DF"

-----WIDTH-------------------------------------------------------
 
WIDTH
 
Name:
    WIDTH
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Specifies the width of various diagrammatic graphics components:
        1) letters (from the TEXT command);
        2) numerals (from the TEXT command);
        3) mathematics symbols (from the TEXT command);
        4) arrow head width (from the ARROW command).
 
Description:
    The width of the character is from the visible left of the
    character to the visible right of the character.  The horizontal
    spacing between characters is not counted (that is controlled by
    the HORIZONTAL SPACING command).  The width is in decimal units of
    0 to 100.  A width of 0 would be negligibly small while a width of
    100 would be full screen horizontal distance.
 
Syntax:
    WIDTH   <n>
    where <n> is a number or parameter in the decimal range 0 to 100
              that specifies the desired width.
 
Examples:
    WIDTH 8
    WIDTH 2
    WIDTH 2.15
    WIDTH W
 
Note:
    The WIDTH command with no arguments reverts the width to the
    default.
 
Note:
    This command is only used for software characters (see the
    documentation for the FONT command).  It is ignored for hardware
    characters.
 
Default:
    The width is 1/2 the size of the HEIGHT.
 
Synonyms:
    None
 
Related Commands:
    TEXT               = Writes a text string.
    TITLE SIZE         = Sets the height of the plot title.
    LABEL SIZE         = Sets the height of the plot labels.
    LEGEND SIZE        = Sets the height of the plot legends.
    TIC LABEL SIZE     = Sets the height of the plot tic mark labels.
    LEGEND HW          = Sets the height and width of the plot legends.
    TIC LABEL HW       = Sets the height and width of the plot tic
                         mark labels.
    HEIGHT             = Sets the height for TEXT characters.
    HW                 = Sets the height and width for TEXT characters.
    VERTICAL SPACING   = Sets the vertical spacing between text lines.
    HORIZONTAL SPACING = Sets the horizontal spacing between text
                         characters.
    FONT               = Sets the font for TEXT characters.
    CASE               = Sets the case for TEXT characters.
    THICKNESS          = Sets the thickness of TEXT characters.
    COLOR              = Sets the color for TEXT characters.
    JUSTIFICATION      = Sets the justification for TEXT characters.
    CR                 = Sets the carriage return position after text.
    LF                 = Sets the line feed position after text.
    CRLF               = Sets the carriage return/line feed position
                         after text.
    MARGIN             = Sets the carriage return column after text.
    ()                 = Allows math and Greek characters in text.
    MOVE               = Moves to a point.
    CROSS-HAIR (or CH) = Activates and reads the cross-hair.
    ERASE              = Erases the screen (immediately).
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    VERTICAL SPACING 6
    CRLF ON
    MARGIN 10
    FONT DUPLEX
    .
    HEIGHT 4
    WIDTH 1.2
    MOVE 5 95
    TEXT JAPAN's 6-POINT PROGRAM FOR QUALITY MANUFACTURING
    MOVE 10 80
    HEIGHT 2.6
    WIDTH 1.6
    TEXT CIRC() QUALITY AUDITS
    TEXT CIRC() COMPANY-WIDE QUALITY CONTROL (CWQC)
    TEXT CIRC() QUALITY TRAINING AND EDUCATION
    TEXT CIRC() APPLICATION OF STATISTICAL METHODS
    TEXT CIRC() QUALITY CIRCLE ACTIVITIES
    WIDTH 1.2
    TEXT CIRC() NATION-WIDE QUALITY CONTROL PROMOTIONAL ACTIVITIES
    WIDTH 1
    MOVE 5 10
    TEXT SOURCE: Q.C. TRENDS WINTER 1985, PAGES 22-23.
 
-----WILK SHAPIRO NORMALITY TEST------------------------------------
 
WILK SHAPIRO NORMALITY TEST
 
Name:
    WILKS SHAPIRO NORMALITY TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform a Wilks Shapiro test for normality.
 
Description:
    The Wilks Shapiro test statistic is defined as:

        W = {SUM(w(i)X'(i)}**2/[SUM(X(i)-XBAR)**2]

    where the summation is from 1 to n and n is the number of 
    observations.  The array X contains the original data,
    X' are the ordered data, XBAR is the sample mean of the
    data, and

        w'=(w1, w2,  ... , wn)
          =M'V**(-1)[(M'V**(-1))(V**(-1)M)]**(-1/2)

    M denotes the expected values of standard normal order
    statistics for a sample of size n and V is the corresponding
    covariance matrix.
 
    W may be thought of as the squared correlation coefficient
    between the ordered sample values (X') and the w(i).  The
    w(i) are approximately proportional to the normal scores
    M(i).  W is a measure of the straightness of the normal
    probability plot, and small values indicate departures from
    normality.  Note that the Dataplot PPCC PLOT command is
    based on a similar concept.  

    Monte Carlo simulations studies have indicated that the
    Wilks-Shapiro test has good power properties for a wide
    range of alternative distributions.

Syntax:
    WILKS SHAPIRO NORMALITY TEST   <y>  
                  <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable being tested;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    WILKS SHAPIRO NORMALITY TEST Y1
    WILKS SHAPIRO NORMALITY TEST Y1   SUBSET TAG > 2
 
Note:
    Dataplot uses Algorithm AS R94 (SWILK sub routine) from the
    Applied Statistics Journal, 1995, Vol. 44, No. 4.  This
    routine should produce accurate critical values for N <= 5,000.

Note:
    The following statistics are also supported:

        LET A = WILK SHAPIRO TEST         Y
        LET A = WILK SHAPIRO TEST PVALUE  Y

    In addition to the above LET command, built-in statistics are
    supported for about 20+ different commands (enter HELP STATISTICS
    for details).

Default:
    None
 
Synonyms:
    The following are synonyms for the WILKS SHAPIRO NORMALITY TEST.

        WILKS SHAPIRO TEST Y
        WILKS SHAPIRO Y
 
Related Commands:
    ANDERSON DARLING TEST      = Compute the Anderson-Darling test for
                                 normality.
    CHI-SQUARE GOODNES OF FIT  = Compute the Chi-Square goodness
                                 of fit test.
    KOLMOGOROV-SMIRNOV         = Compute the Kolmogorov-Smirnov
        GOODNES OF FIT           goodness of fit test.
    PROBABILITY PLOT           = Generates a probability plot.
    PPCC PLOT                  = Generates a ppcc plot.
 
Reference:
    Shapiro, S. S. and Wilk, M. B. (1965).  Biometrika, 52,
    591-611.
 
Applications:
    Distributional Fitting, Assumption Testing
 
Implementation Date:
    2000/1
 
Program:
    SKIP 25
    READ ZARR13.DAT Y
    WILKS SHAPIRO NORMALITY TEST Y
       
        The following output is generated:
      
                   WILKS SHAPIRO TEST FOR NORMALITY
      
     1. STATISTICS:
           NUMBER OF OBSERVATIONS                =      195
           LOCATION PARAMETER                    =    9.261460
           SCALE PARAMETER                       =   0.2278881E-01
      
           WILKS SHAPIRO TEST STATISTIC VALUE =   0.9982718
      
     2. CRITICAL VALUES:
           P-VALUE      =   0.9992256
      
     3. CONCLUSIONS:
           AT THE 90% LEVEL, WE ACCEPT THE NORMALITY ASSUMPTION.
           AT THE 95% LEVEL, WE ACCEPT THE NORMALITY ASSUMPTION.
           AT THE 97.5% LEVEL, WE ACCEPT THE NORMALITY ASSUMPTION.
           AT THE 99% LEVEL, WE ACCEPT THE NORMALITY ASSUMPTION.
 
-----WINDOW COORDINATES----------------------------------------------
 
WINDOW COORDINATES
 
Name:
    WINDOW COORDINATES
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the region of the graphics device to use for any
    subsequent graphics or diagrammatic graphics commands.
 
Description:
    By default, Dataplot uses the entire device when generating
    graphics and diagrammatic graphics.  Dataplot defines a 0 to 100
    coordinate system in both the horizontal and vertical direction on
    the device.  In certain instances, it is desirable to restrict the
    output to a specific area of the device.  Two common reasons for
    doing this are:
      1) To generate multiple plots per page.  Although the MULTIPLOT
         command can automatically generate multiple plots per page,
         the WINDOW COORDINATES and FRAME COORDINATES commands provide
         more control over where an individual plot appears.
      2) To generate a plot with a specific aspect ratio.  For example,
         the analyst may want a square plot.  Be aware that since
         Dataplot uses a percentage coordinate system, the neccesary
         window coordinates may differ depending on the specific
         device.
    The window is defined by specifying the coordinates for the lower
    left and upper right corners.  A new 0 to 100 coordinate system
    is defined within this sub-region.  Commands based on Dataplot's
    0 to 100 coordinate system are then relative to the sub-region, not
    the full screen.
 
Syntax:
    WINDOW COORDINATES  <x1>  <y1>  <x2>  <y2>
    where <x1> is a number or parameter in the range 0 to 100 that
               specifies the left horizontal coordinate;
          <y1> is a number or parameter in the range 0 to 100 that
               specifies the left vertical coordinate;
          <x2> is a number or parameter in the range 0 to 100 that
               specifies the right horizontal coordinate;
    and   <y2> is a number or parameter in the range 0 to 100 that
               specifies the right vertical coordinate;
 
Examples:
    WINDOW COORDINATES 0 0 50 50   --set window to lower left quadrant
    WINDOW COORDINATES 0 50 50 100 --set window to upper left quadrant
    WINDOW COORDINATES 0 50 100 100--set window to top half
    WINDOW COORDINATES 30 30 70 50 --set window to (30,30) and (70,50)
    WINDOW COORDINATES             --set window to full screen
 
Note:
    Character sizes and line widths are specified as a percentage of
    the vertical size of the device (i.e., in Dataplot's 0 to 100
    coordinate system).  When a window is specified, these values
    for character sizes and line widths are relative to the sub-region
    rather than the full device area.
 
Note:
    Coordinates less than 0 or greater than 100 are in fact accepted.
    However, graphics output that falls outside the 0 to 100 range on
    the full device is clipped.
 
Note:
    The WINDOW COORDINATES command with no arguments reverts the window
    coordinates to default.
 
Default:
    The full device area is used (i.e., (0,0) and (100,100)).
 
Synonyms:
    WINDOW CORNER COORDINATES
 
Related Commands:
    FRAME CORNER COORDINATES  = Define the corners for the plot frame.
    MULTIPLOT                 = Generate multiple plots per page.
    PRE-ERASE                 = Specify whether an initial page erase
                                is generated before a plot.
 
Applications:
    Multiplotting
 
Implementation Date:
    Pre-1987
 
Program:
    DIMENSION 100 COLUMNS
    SKIP 25
    COLUMN LIMITS 20 132
    READ AUTO79.DAT Y1 TO Y9
    LET N = SIZE Y1; LET CAR = SEQUENCE 1 1 N
    LET ZX = DATA 0.5 9.5; LET ZY = DATA 0.5 0.5
    .
    TITLE PROFILE PLOT
    XLIMITS 1 9; XTIC OFFSET 0.5 0.5; MAJOR XTIC MARK NUMBER 9
    YLIMITS 0 1
    ERASE; PRE-ERASE OFF
    .
    WINDOW CORNER COORDINATES 0 50 50 100
    PROFILE PLOT Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9  SUBSET CAR 1
    .
    WINDOW CORNER COORDINATES 50 50 100 100
    SPIKE ON
    PROFILE PLOT Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9  SUBSET CAR 1
    .
    WINDOW CORNER COORDINATES 0 0 50 50
    LINE BLANK; SPIKE BASE 0.5
    PROFILE PLOT Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9  SUBSET CAR 1
    LINE SOLID; SPIKE OFF; PLOT ZY ZX
    .
    WINDOW CORNER COORDINATES 50 0 100 50
    LINE BLANK; SPIKE OFF
    BAR ON; BAR BASE 0.5; BAR FILL ON; BAR WIDTH 0.2
    PROFILE PLOT Y1 Y2 Y3 Y4 Y5 Y6 Y7 Y8 Y9  SUBSET CAR 1
    LINE SOLID; BAR OFF; PLOT ZY ZX
 
-----WINDOW STATISTIC PLOT---------------------------------------
 
WINDOW STATISTIC PLOT
 
Name:
    ... WINDOW STATISTIC PLOT
 
Type:
    Graphics Command
 
Purpose:
    Plots the value of a statistic for a response variable over
    contiguous groups in the data.  Optionally, the window statistic
    can be plotted against a group-id variable.
 
Description:
    The <stat> STATISTIC PLOT can be used to plot the value of a
    statistic versus the index of a group-id variable.  So if
    you have 10 groups in your data, there will be 10 values of
    the statistic computed.

    The <stat> WINDOW STATISTIC PLOT is a variant of the
    <stat> STATISTIC PLOT.  However, they differ in how the groups are
    determined.  For the STATISTIC PLOT, response values are grouped by
    the unique values of the group-id variable.  The group-id variable
    does not need to be sorted.  With the WINDOW STATISTIC PLOT, groups
    are formed from a user specified number of contiguous rows of the
    response variable.  That is, if the user specifies a group size of
    100, then rows 1 to 100 form the first group, rows 101 to 200 form
    the second group, and so on.

    This plot is motivated by large data sets.  When the number of points
    to be plotted is very large, it may become impractical to generate a
    run sequence plot of all the raw data.  Either the details get lost or
    the Postscript file becomes unrealistically large.  An alternative is
    to plot various summary statistics for subsets of the data.  For
    example, you can plot the mean, standard deviaiton, minimum, and
    maximum values for each of the slices of the data.

    To specify the size of the slices, enter the command

      LET NSIZE = <value>

    If this command is not given, NSIZE will be set to N/100 for N > 1000
    and to N/10 for N <= 1000.

    There are two cases.

       1. If no group-id variable is given, then plot

              S(Y(i)) versus i

          where

              S(Y(i)) = the value of the statistic for observations
                        in group i
              i       = the group index

          A reference line will be drawn at the mean value of
          the computed statistics.

          The appearance of these two traces is controlled by the first
          two settings of the LINES, CHARACTERS, SPIKES, BARS, and
          and associated attribute setting commands.  Groups are
          formed from contiguous rows in the response variable based
          on the user specified value of NSIZE.

          This is the typical use of this command.
 
       2. If a group-id variable is given, then case 1 will be repeated
          for unique values of the group-id variable.  As case 1
          implicitly forms groups, this syntax is typically not used.

Syntax 1:
    <stat> WINDOW STATISTIC PLOT  <y1> ... <yk>
                                  <SUBSET/EXCEPT/FOR qualification>
    where <stat> is one of Dataplot's supported statistics;
          <y1> ... <yk> is a list of 1 to 3 response variables
              (<stat> determines how many response variables);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    For a list of supported statistics, enter

          HELP STATISTICS

    This is the commonly used syntax for this command.

Syntax 2:
    <stat> WINDOW STATISTIC PLOT  <y1> ... <yk> <x>
                                      <SUBSET/EXCEPT/FOR qualification>
    where <stat> is one of Dataplot's supported statistics;
          <y1> ... <yk> is a list of 1 to 3 response variables
              (<stat> determines how many response variables);
          <x> is a group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for the case where there is a group-id
    variable.  This syntax is not typically used as the WINDOW PLOT
    implicitly forms groups in the data.

Examples:
    MEAN WINDOW STATISTIC PLOT Y
    MEAN WINDOW STATISTIC PLOT Y SUBSET Y > 0
    MINIMUM WINDOW STATISTIC PLOT Y
    SD WINDOW STATISTIC PLOT Y
    CORRELATION WINDOW STATISTIC PLOT Y1 Y2
 
Note:
    The word STATISTIC is required in this command (i.e., WINDOW PLOT
    is not a synonym for WINDOW STATISTIC PLOT).  This is to avoid
    conflicts with other commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WINDOW <STATISTIC>         = Compute the value of a statistic for
                                 slices of the data.
    MOVING STATISTIC PLOT      = Generate a plot of the moving value of a
                                 statistic.
    CUMULATIVE STATISTIC PLOT  = Generate a plot of the cumulative value
                                 of a statistic.
    STATISTIC PLOT             = Generate a statistic versus index plot.
    CHARACTERS                 = Sets the type for plot characters.
    LINES                      = Sets the type for plot lines.
 
Applications:
    Exploratory Data Analysis
 
Implementation Date:
    2016/6

    The list of supported statistics is frequently updated.  Enter HELP
    STATISTICS for a current list of supported statistics.
 
Program:
    let y = double exponential random numbers for i = 1 1 1000000
    .
    line blank solid
    character X blank
    tic mark offset units screen
    tic mark offset 5 5
    title case asis
    title offset 2
    case asis
    .
    multiplot 2 2
    multiplot scale factor 2
    multiplot corner coordinates 5 5 95 95
    let nsize = 10000
    .
    title Mean
    mean window statistic plot y
    title SD
    sd window statistic plot y
    title Minimum
    minimum window statistic plot y
    title Maximum
    maximum window statistic plot y
    .
    end of multiplot
    .
    justification center
    move 50 98
    text Value of Statistics for Slices of 10,000 Rows
    move 50 96
    text 1,000,000 Double Exponential Random Numbers

-----WINDOW <STATISTIC> (LET)---------------------------------------
 
WINDOW (LET)
 
Name:
    WINDOW <STATISTIC> (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute a statistic for fixed size intervals of the response variable.
 
Description:
    This command can be used to compute the value of a statistic for
    groups of a response variable.  The following commands are similar

       LET NSIZE = 10
       LET YSTAT = WINDOW MEAN Y

       LET YSTAT = CROSS TABULATE MEAN Y X

    The distinction is in how the groups are formed.  For the
    LET ... = CROSS TABULATE command, the groups are formed based on the
    distinct values of the group-id variable (X in the above example).
    For the LET .. = WINDOW command, groups are formed from contiguous
    rows of the response variable.  The LET NSIZE command is used to
    specify the size of each group.

    This can in fact be used for any supported statistic (enter
    HELP STATISTIC for a list of supported statistics).

Syntax:
    LET <yout> = WINDOW <stat> <y1> ... <yk>
                               <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of one to three response variables
              (depending on what <stat> is);
          <stat> is one of the supported statistics (HELP STATISTICS
              for a list);
          <yout> is a variable where the computed values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y2 = WINDOW MAD Y
    LET Y2 = WINDOW MEDIAN Y
    LET Y2 = WINDOW SD Y  SUBSET Y > 0

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WINDOW PLOT          = Plot the value of a statistic over contiguous
                           groups in the response variable.
    CROSS TABULATE (LET) = Compute a statistic, or a cumulative
                           statistic, across groups.
    MOVING               = Compute a moving statistic.
    CUMULATIVE           = Compute a cumulative statistic.
 
Applications:
    Data Analysis
 
Implementation Date:
    2016/06
 
Program:
    skip 25
    read gear.dat y
    let nsize = 20
    let ymean = window mean y
    set write decimals 4
    print ymean

-----WINSORIZE (LET)-----------------------------------------
 
WINSORIZE
 
Name:
    WINSORIZE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Winsorize a variable.
 
Description:
    The computation of many statistics can be heavily influenced by extreme
    values.  One approach to providing a more robust computation of the
    statistic is to Winsorized the data before computing the statistic.

    To Winsorized the data, tail values are set equal to some specified
    percentile of the data.  For example, for a 90% Winsorization, the bottom
    5% of the values are set equal to the value corresponding to the 5th
    percentile while the upper 5% of the values are set equal to the value
    corresponding to the 95th percentile.

    Note that Winsorization is not equivalent to simply throwing some
    of the data away.  This is because the order statistics are not
    independent.

Syntax:
    LET <y2> = WINSORIZE <y1>      <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the response variable;
          <y2> is a variable where the computed Winsorized values are
                stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Examples:
    LET Y2 = WINSORIZE Y1
    LET Y2 = WINSORIZE Y1 SUBSET TAG > 2

Note:
    The analyst must specify the percentages to Winsorize in each tail.
    This is done by defining the internal variables P1 (the lower
    tail) and P2 (the upper tail).  For example, to Winsorize 10% of
    each tail, do the following:
        LET P1 = 10
        LET P2 = 10
        LET Y2 = WINSORIZE Y1

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WINSORIZED MEAN                = Compute a Winsorized mean.
    WINSORIZED VARIANCE            = Compute the Winsorized variance.
    WINSORIZED STANDARD DEVIATION  = Compute a Winsorized standard deviation.
    WINSORIZED COVARIANCE          = Compute a Winsorized covariance.
    WINSORIZED CORRELATION         = Compute a Winsorized correlation.
    VARIANCE                       = Compute the variance.
    BIWEIGHT MIDVARIANCE           = Compute the biweight midvariance.
 
Reference:
    "Introduction to Robust Estimation and Hypothesis Testing",
    Rand Wilcox, Academic Press, 1997.

Applications:
    Robust Data Analysis
 
Implementation Date:
    7/2002
 
Program:
    LET Y1 = CAUCHY RANDOM NUMBERS FOR I = 1 1 100
    LET P1 = 10
    LET P2 = 10
    LET Y2 = WINSORIZE Y1
    LET A1 = EXTREME Y1
    LET A2 = EXTREME Y2

-----WINSORIZED CORRELATION (LET)-----------------------------------------
 
WINSORIZED CORRELATION
 
Name:
    WINSORIZED CORRELATION (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the Winsorized correlation of a variable.
 
Description:
    The standard correlation estimate can be heavily influenced by extreme
    values.  The Winsorized correlation compensates for this by setting the
    tail values equal to a certain percentile value.  For example, for a
    90% Winsorized correlation, the bottom 5% of the values are set equal to
    the value corresponding to the 5th percentile while the upper 5% of
    the values are set equal to the value corresponding to the 95th
    percentile.  Then the standard correlation formula (HELP CORRELATION
    for details) is applied.
 
Syntax:
    LET <par> = WINSORIZED CORRELATION <y1> <y2>
                           <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Winsorized correlation is
                stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = WINSORIZED CORRELATION Y1 Y2
    LET A = WINSORIZED CORRELATION Y1 Y2 SUBSET TAG > 2
 
Note:
    The analyst must specify the percentages to Winsorize in each tail.
    This is done by defining the internal variables P1 (the lower
    tail) and P2 (the upper tail).  For example, to Winsorize 10% of
    each tail, do the following:
        LET P1 = 10
        LET P2 = 10
        LET A = WINSORIZED CORRELATION Y1 Y2
 
Note:
    Support for the Winsorized correlation has been added to the 
    following plots and commands:

       WINSORIZED CORRELATION PLOT
       BOOTSTRAP WINSORIZED CORRELATION PLOT
       JACKNIFE WINSORIZED CORRELATION PLOT
       CROSS TABULATE WINSORIZED CORRELATION PLOT
       WINSORIZED CORRELATION INTERACTION STATISTIC PLOT

Note:
    The CORRELATION MATRIX command generates pairwise correlation
    estimates of the columns in a matrix.  By default, this command
    generates the standard correlation estimate.  The command

       SET CORRELATION TYPE  <type>

    can be used to specify an alternate correlation measure to
    compute in the CORRELATION MATRIX command.  The following
    types are supported:

        DEFAULT    - use the standard estimate
        WINSOR     - use the Winsorized correlation estimate
        BIWEIGHT   - use the biweight midcorrelation estimate
        RANK       - use the rank correlation estimate

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WINSORIZE                      = Winsorize a variable.
    WINSORIZED STANARD DEVIATION   = Compute a Winsorized standard deviation.
    WINSORIZED MEAN                = Compute a Winsorized mean.
    WINSORIZED VARIANCE            = Compute a Winsorized covariance.
    WINSORIZED COVARIANCE          = Compute a Winsorized covariance.
    VARIANCE                       = Compute the variance.
    BIWEIGHT MIDCOVARIANCE         = Compute the biweight midcovariance.
 
Reference:
    "Introduction to Robust Estimation and Hypothesis Testing",
    Rand Wilcox, Academic Press, 1997.

Applications:
    Robust Data Analysis
 
Implementation Date:
    7/2002
 
Program:
    DIMENSION 20 COLUMNS
    SKIP 25
    COLUMN LIMITS 20 80
    READ AUTO79.DAT Y1 TO Y12
    LET A1 = CORRELATION Y1 Y2
    LET P1 = 10
    LET P2 = 10
    LET A2 = WINSORIZED CORRELATION Y1 Y2

-----WINSORIZED COVARIANCE (LET)-----------------------------------------
 
WINSORIZED COVARIANCE
 
Name:
    WINSORIZED COVARIANCE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the Winsorized covariance of a variable.
 
Description:
    The standard covariance estimate can be heavily influenced by extreme
    values.  The Winsorized covariance compensates for this by setting the
    tail values equal to a certain percentile value.  For example, for a
    90% Winsorized covariance, the bottom 5% of the values are set equal to
    the value corresponding to the 5th percentile while the upper 5% of
    the values are set equal to the value corresponding to the 95th
    percentile.  Then the standard covariance formula (HELP COVARIANCE
    for details) is applied.
 
Syntax:
    LET <par> = WINSORIZED COVARIANCE <y1> <y2>
                           <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Winsorized covariance is
                stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = WINSORIZED COVARIANCE Y1 Y2
    LET A = WINSORIZED COVARIANCE Y1 Y2 SUBSET TAG > 2
 
Note:
    The analyst must specify the percentages to Winsorize in each tail.
    This is done by defining the internal variables P1 (the lower
    tail) and P2 (the upper tail).  For example, to Winsorize 10% of
    each tail, do the following:
        LET P1 = 10
        LET P2 = 10
        LET A = WINSORIZED COVARIANCE Y1 Y2
 
Note:
    Support for the Winsorized covariance has been added to the 
    following plots and commands:

       WINSORIZED COVARIANCE PLOT
       BOOTSTRAP WINSORIZED COVARIANCE PLOT
       JACKNIFE WINSORIZED COVARIANCE PLOT
       CROSS TABULATE WINSORIZED COVARIANCE PLOT
       WINSORIZED COVARIANCE INTERACTION STATISTIC PLOT

Note:
    The COVARIANCE MATRIX command generates pairwise covariance
    estimates of the columns in a matrix.  By default, this command
    generates the standard covariance estimate.  The command

       SET COVARIANCE TYPE  <type>

    can be used to specify an alternate covariance measure to
    compute in the COVARIANCE MATRIX command.  The following
    types are supported:

        DEFAULT    - use the standard estimate
        WINSOR     - use the Winsorized covariance estimate
        BIWEIGHT   - use the biweight midcovariance estimate
        RANK       - use the rank covariance estimate

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WINSORIZE                      = Winsorize a variable.
    WINSORIZED STANARD DEVIATION   = Compute a Winsorized standard deviation.
    WINSORIZED MEAN                = Compute a Winsorized mean.
    WINSORIZED VARIANCE            = Compute a Winsorized covariance.
    WINSORIZED CORRELATION         = Compute a Winsorized correlation.
    VARIANCE                       = Compute the variance.
    BIWEIGHT MIDVARIANCE           = Compute the biweight midvariance.
 
Reference:
    "Introduction to Robust Estimation and Hypothesis Testing",
    Rand Wilcox, Academic Press, 1997.

Applications:
    Robust Data Analysis
 
Implementation Date:
    7/2002
 
Program:
    DIMENSION 20 COLUMNS
    SKIP 25
    COLUMN LIMITS 20 80
    READ AUTO79.DAT Y1 TO Y12
    LET A1 = COVARIANCE Y1 Y2
    LET P1 = 10
    LET P2 = 10
    LET A2 = WINSORIZED COVARIANCE Y1 Y2

-----WINSORIZED MEAN (LET)-----------------------------------------
 
WINSORIZED MEAN
 
Name:
    WINSORIZED MEAN (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the Winsorized mean for a variable.
 
Description:
    The mean is the sum of the observations divided by the number of
    observations.  The mean can be heavily influenced by extreme values
    in the tails of a variable.  The Winsorized mean compensates for
    this by setting the tail values equal to a certain percentile
    value.  For example, for a 90% Winsorized mean, the bottom 5%
    of the values are set equal to the value corresponding to the
    5th percentile while the upper 5% of the values are set equal to
    the value corresponding to the 95th percentile.
 
Syntax:
    LET <par> = WINSORIZED MEAN <y1> <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the response variable;
          <par> is a parameter where the computed Winsorized mean is
                stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = WINSORIZED MEAN Y1
    LET A = WINSORIZED MEAN Y1 SUBSET TAG > 2
 
Note:
    The analyst must specify the percentages to Winsorize in each tail.
    This is done by defining the internal variables P1 (the lower
    tail) and P2 (the upper tail).  For example, to Winsorize 10% off
    each tail, do the following:
        LET P1 = 10
        LET P2 = 10
        LET A = WINSORIZED MEAN Y
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WINSORIZED MEAN PLOT = Generate a Winsorized mean vs. subset plot.
    MEAN                 = Compute the mean.
    TRIMMED MEAN         = Compute the trimmed mean.
    MEDIAN               = Compute the median.
    STANDARD DEVIATION   = Compute the standard deviation.
 
Reference:
    "Introduction to Robust Estimation and Hypothesis Testing",
    Rand Wilcox, Academic Press, 1997.

Applications:
    Data Analysis
 
Implementation Date:
    Pre-1987
 
Program:
    LET Y1 = CAUCHY RANDOM NUMBERS FOR I = 1 1 100
    LET P1 = 10
    LET P2 = 10
    LET A1 = WINSORIZED MEAN Y1
 
-----WINSORIZED MEAN PLOT---------------------------------------
 
WINSORIZED MEAN PLOT
 
Name:
    WINSORIZED MEAN PLOT
 
Type:
    Support Command
 
Purpose:
    Generates a Windsorized mean plot.
 
Description:
    A Windsorized mean plot is a plot consisting of subsample
    Windsorized means versus subsample index.  The subsample
    Windsorized mean is the mean of the data with 100p1% of the bottom
    data replaced by the next larger value, and with 100p2% of the top
    data replaced by the next smaller value, in the ascendingly
    ordered data set.  The Windsorized mean plot is used to answer the
    question--"Does the subsample location change over different
    subsamples?".  It consists of:
       Vertical   axis = subsample Windsorized mean;
       Horizontal axis = subsample index.
    The Windosrized mean plot yields 2 traces:
       1. a subsample Windsorized mean trace; and
       2. a full-sample Windsorized mean reference line.
    Like usual, the appearance of these 2 traces is
    controlled by the first 2 settings of the LINES,
    CHARACTERS, SPIKES, BARS, and similar attributes.
 
Syntax:
    WINSORIZED MEAN PLOT <y> <x>   <SUBSET/EXCEPT/FOR/qualification>
    where <y> is the response (= dependent) variable;
          <x> is the subsample identifier variable (this variable
              appears on the horizontal axis);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    WINSORIZED MEAN PLOT Y X
    WINSORIZED MEAN PLOT Y X1
 
Note:
    The analyst usually precedes the WINDSORIZED MEAN PLOT command
    with 2 LET commands of the following type:
        LET P1 = 5
        LET P2 = 10
    where P1 and P2 are both between 0 and 100 and indicate the amount
    of data to be Windsorized from the left and right, respectively.
    In the example here, P1 = 5 and P2 = 10 indicates that 5% of
    the smallest data are replaced by the next larger value and 10% of
    the largest data are replaced by the next smaller value before
    forming the mean.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHARACTERS         = Sets the type for plot characters.
    LINES              = Sets the type for plot lines.
    SD   PLOT          = Generates a standard deviation plot.
    VARIANCE   PLOT    = Generates a variance plot.
    RANGE      PLOT    = Generates a range plot.
    MEAN   PLOT        = Generates a mean plot.
    MEDIAN PLOT        = Generates a median plot.
    MIDMEAN PLOT       = Generates a midmean plot.
    MIDRANGE PLOT      = Generates a midrange plot.
    TRIMMED MEAN PLOT  = Generates a trimmed mean plot.
    BOX PLOT           = Generates a box plot.
    XBAR CHART         = Generates an xbar control chart.
    PLOT               = Generates a data or function plot.
 
Reference:
    "Introduction to Robust Estimation and Hypothesis Testing",
    Rand Wilcox, Academic Press, 1997.

Applications:
    Robust Data Analysis
 
Implementation Date:
    88/2
 
Program:
    SKIP 25
    READ GEAR.DAT Y X
    LET P1 = 10
    LET P2 = 10
    LINE BLANK DASH
    CHARACTER X BLANK
    XTIC OFFSET 0.2 0.2
    Y1LABEL WINSORIZED MEAN
    X1LABEL SAMPLE ID
    TITLE AUTOMATIC
    WINSORIZED MEAN PLOT Y X
 
-----WINSORIZED STANDARD DEVIATION (LET)------------------------------------
 
WINSORIZED STANDARD DEVIATION
 
Name:
    WINSORIZED STANDARD DEVIATION (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the Winsorized standard deviation of a variable.
 
Description:
    The standard variance estimate can be heavily influenced by extreme
    values.  The Winsorized standard deviation compensates for this by
    setting the tail values equal to a certain percentile value.  For example,
    for a 90% Winsorized standard deviation, the bottom 5% of the values are
    set equal to the value corresponding to the 5th percentile while the upper
    5% of the values are set equal to the value corresponding to the 95th
    percentile.  Then the regular standard deviation formula (HELP STANDARD
    DEVIATION for details) is applied.
 
Syntax:
    LET <par> = WINSORIZED STANDARD DEVIATION <y1>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the response variable;
          <par> is a parameter where the computed Winsorized standard
                deviation is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = WINSORIZED STANDARD DEVIATION Y1
    LET A = WINSORIZED STANDARD DEVIATION Y1 SUBSET TAG > 2
 
Note:
    The analyst must specify the percentages to Winsorize in each tail.
    This is done by defining the internal variables P1 (the lower
    tail) and P2 (the upper tail).  For example, to Winsorize 10% of
    each tail, do the following:
        LET P1 = 10
        LET P2 = 10
        LET A = WINSORIZED STANDARD DEVIATION Y
 
Note:
    Support for the Winsorized standard deviation has been added to the 
    following plots and commands:

       WINSORIZED STANDARD DEVIATION PLOT
       BOOTSTRAP WINSORIZED STANDARD DEVIATION PLOT
       JACKNIFE WINSORIZED STANDARD DEVIATION PLOT
       CROSS TABULATE WINSORIZED STANDARD DEVIATION PLOT
       DEX WINSORIZED STANDARD DEVIATION PLOT
       WINSORIZED STANDARD DEVIATION INTERACTION STATISTIC PLOT
       WINSORIZED STANDARD DEVIATION INFLUENCE CURVE

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WINSORIZE                      = Winsorize a variable.
    WINSORIZED VARIANCE            = Compute a Winsorized variance.
    WINSORIZED MEAN                = Compute a Winsorized mean.
    WINSORIZED COVARIANCE          = Compute a Winsorized covariance.
    WINSORIZED CORRELATION         = Compute a Winsorized correlation.
    VARIANCE                       = Compute the variance.
    BIWEIGHT MIDVARIANCE           = Compute the biweight midvariance.
 
Reference:
    "Introduction to Robust Estimation and Hypothesis Testing",
    Rand Wilcox, Academic Press, 1997.

Applications:
    Robust Data Analysis
 
Implementation Date:
    7/2002
 
Program 1:
    LET Y1 = CAUCHY RANDOM NUMBERS FOR I = 1 1 100
    LET A1 = STANDARD DEVIATION Y1
    LET P1 = 10
    LET P2 = 10
    LET A2 = WINSORIZED STANDARD DEVIATION Y1
 
Program 2:
    SKIP 25
    READ SPLETT2.DAT Y MACHINE
    XTIC OFFSET 0.5 0.5
    LABEL CASE ASIS
    X1LABEL Machine Manfufacturer
    Y1LABEL Absorbed Energy
    LET P1 = 10
    LET P2 = 10
    WINSORIZED STANDARD DEVIATION PLOT Y MACHINE

-----WINSORIZED VARIANCE (LET)-----------------------------------------
 
WINSORIZED VARIANCE
 
Name:
    WINSORIZED VARIANCE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the Winsorized variance of a variable.
 
Description:
    The variance estimate can be heavily influenced by extreme
    values.  The Winsorized variance compensates for this by setting the
    tail values equal to a certain percentile value.  For example, for a
    90% Winsorized variance, the bottom 5% of the values are set equal to
    the value corresponding to the 5th percentile while the upper 5% of
    the values are set equal to the value corresponding to the 95th
    percentile.  Then the standard variance formula (HELP VARIANCE
    for details) is applied.
 
Syntax:
    LET <par> = WINSORIZED VARIANCE <y1> <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the response variable;
          <par> is a parameter where the computed Winsorized variance is
                stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = WINSORIZED VARIANCE Y1
    LET A = WINSORIZED VARIANCE Y1 SUBSET TAG > 2
 
Note:
    The analyst must specify the percentages to Winsorize in each tail.
    This is done by defining the internal variables P1 (the lower
    tail) and P2 (the upper tail).  For example, to Winsorize 10% of
    each tail, do the following:
        LET P1 = 10
        LET P2 = 10
        LET A = WINSORIZED VARIANCE Y
 
Note:
    Support for the Winsorized variance has been added to the 
    following plots and commands:

       WINSORIZED VARIANCE PLOT
       BOOTSTRAP WINSORIZED VARIANCE PLOT
       JACKNIFE WINSORIZED VARIANCE PLOT
       CROSS TABULATE WINSORIZED VARIANCE PLOT
       DEX WINSORIZED VARIANCE PLOT
       WINSORIZED VARIANCE INTERACTION STATISTIC PLOT
       WINSORIZED VARIANCE INFLUENCE CURVE

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WINSORIZE                      = Winsorize a variable.
    WINSORIZED STANDARD DEVIATION  = Compute a Winsorized standard deviation.
    WINSORIZED MEAN                = Compute a Winsorized mean.
    WINSORIZED COVARIANCE          = Compute a Winsorized covariance.
    WINSORIZED CORRELATION         = Compute a Winsorized correlation.
    VARIANCE                       = Compute the variance.
    BIWEIGHT MIDVARIANCE           = Compute the biweight midvariance.
 
Reference:
    "Introduction to Robust Estimation and Hypothesis Testing",
    Rand Wilcox, Academic Press, 1997.

Applications:
    Robust Data Analysis
 
Implementation Date:
    7/2002
 
Program 1:
    LET Y1 = CAUCHY RANDOM NUMBERS FOR I = 1 1 100
    LET A1 = VARIANCE Y1
    LET P1 = 10
    LET P2 = 10
    LET A2 = WINSORIZED VARIANCE Y1
 
Program 2:
    SKIP 25
    READ SPLETT2.DAT Y MACHINE
    XTIC OFFSET 0.5 0.5
    LABEL CASE ASIS
    X1LABEL Machine Manfufacturer
    Y1LABEL Absorbed Energy
    LET P1 = 10
    LET P2 = 10
    WINSORIZED VARIANCE PLOT Y MACHINE

-----WISHART RANDOM NUMBER-------------------------------
 
WISHART RANDOM NUMBER
 
Name:
    WISHART RANDOM NUMBER GENERATOR
 
Type:
    Let Subcommand
 
Purpose:
    Generate the sample variance-covariance matrix from a
    random sample of size n that is distributed as a p-variate
    normal N(p)(mu,sigma).
 
Description:
    The Wishart distribution is a k-dimensional generalization 
    of the chi-square distribution.  The chi-square distribution
    is the sum of squared normal variates.  The Wishart
    distribution is the sum of squared multivariate normal
    variates.  The Wishart distribution has applications in
    Bayesian analysis.

    In order to generate the Wishart variates, you need to
    specify the following:

       1) sigma - the pxp variance-covariance matrix of the
          multivariate normal distribution
       2) mu - the vector of length p that defines the location
          parameters of the multivariate normal distribution
       3) n - the sample size

    What is returned is a pxp sample variance-covariance matrix.

Syntax:
    LET <mat> = WISHART RANDOM NUMBERS <mu> <sigma> <n>
    where <mu> is a variable containing the desired location
               parameters;
          <sigma> is a matrix containing the desired
               variance-covariance matrix;
          <n> is a number or parameter specifying the sample size;
    and where <mat> is a matrix where the resulting Wishart
               random numbers are stored.
 
    The number of rows in <mu> must equal the number of rows
    and columns in the <sigma> matrix.  The <sigma> matrix must
    be a valid variance-covariance matrix (i.e., symmetric and
    positive definite).

Examples:
    LET MU = -5 0 5
    READ MATRIX SIGMA
    1   0.5  0.5
    0.5  1   0.5
    0.5 0.5   1
    END OF DATA
    LET N = 500
    LET M = WISHART RANDOM NUMBERS MU SIGMA N
 
Note:
    Dataplot generates the Wishart matrix using algorithm
    AS 53 (routine WSHRT) from the Applied Statistics journal.
    See the Reference below for details.

Note:
    As with univariate random numbers, the Wishart random numbers
    are built on an underlying uniform random number generator.
    Dataplot supports a number of different uniform random number
    generators.  For details, enter

       HELP SET RANDOM NUMBER GENERATOR

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    RANDOM NUMBERS                = Generate random numbers for 60+
                                    univariate distributions.
    SET RANDOM NUMBER GENERATOR   = Specify which univariate generator
                                    to use.
    MULTIVARIATE NORM RAND NUMB   = Generate multivariate normal
                                    random numbers.
    MULTIVARIATE T RANDOM NUMBERS = Generate multivariate t random
                                    numbers.
    INDEPENDENT UNIFORM RAND NUMB = Generate random numbers for
                                    independent uniform distributions.
    MULTINOMIAL RANDOM NUMBERS    = Generate random numbers for a
                                    multinomial distribution.
    DIRICHLET RANDOM NUMBERS      = Generate random numbers for a
                                    Dirichlet distribution.
 
Reference:
    "Algorithm AS 53: Wishart Variate Generator", Smith and
    Hocking, Applied Statistics, 1972, Vol. 21, No. 3.

Applications:
    Bayesian Analysis
 
Implementation Date:
    2003/3
 
Program:
    dimension 100 columns
    .
    .  Test Wishart random numbers
    .
    read matrix sigma
     1.0        -0.707107  0.0  0.0 0.0
    -0.707107    1.0       0.5  0.5 0.5
     0.0         0.5       1.0  0.5 0.5
     0.0         0.5       0.5  1.0 0.5
     0.0         0.5       0.5  0.5 1.0
    end of data
    .
    let mu = data 0 0 0 0 0
    let n = 200
    .
    let w = wishart random numbers mu sigma n
    .
    set write decimals 3
    print w
 
-----WORKSPACE SWITCHES (SET)--------------------------------------------
 
WORKSPACE SWITCHES
 
Name:
    WORKSPACE SWITCHES (SET)
 
Type:
    Set Subcommand
 
Purpose:
    Probe for values pertaining to the Dataplot workspace.
 
Description:
    Certain limits pertaining to Dataplot's workspace can be extracted
    using the PROBE command.  Note that these settings cannot be modified
    with the SET command.  If higher limits are needed, the file DPCOPA.INC
    needs to be modified and the Dataplot executable then needs to be
    rebuilt from the source code.

    The list of available workspace switches is

        MAXNK   - The maximum total number of observations (i.e., the
                  number of rows times the number of columns).
        NK      - The current total number of observations.
        MAXCOL  - The maximum number of columns allowed.  This can be
                  modified by the DIMENSION command.  The default value
                  is 10.
        NUMCOL  - The number of columns currently defined.
        MAXN    - The maximum number of observations per variable.  This
                  can be modified by the DIMENSION command.
        N       - The current number of observations per variable.
        MAXNAM  - The maximum number of names (this includes variables,
                  parameters, strings, functions, and matrices).
        NUMNAM  - The number of names currently defined.
        MAXCHF  - The maximum number of characters for all functions and
                  strings.
        NUMCHF  - The number of characters used for all currently defined
                  strings and functions.
        MAXFUN  - The maximum number of functions and strings allowed.
        NUMFUN  - The number of currently defined strings and functions.
        MAXCHM  - The maximum number of characters used in printing the most
                  recently defined model.
        MAXWID  - The maximum width of a command line.
        IWIDTH  - The width of the current command line.
        MAXWSV  - The maximum width of a saved line.
        IWIDSV  - The width of the current saved line.
        NPLOTP  - The number of plot points on the most recent plot.

Syntax:
    PROBE <WORKSPACE SWITCH>
    where <WORKSPACE SWITCH> is one of the names listed above.
 
Examples:
    PROBE NK
    PROBE NUMCOL
    PROBE MAXCOL
    PROBE MAXNAM
    PROBE NUMNAM

Default:
    The defaults for certain limits are defined when the Dataplot source
    is compiled.
 
Synonyms:
    None
 
Related Commands:
    DIMENSION         = Set the row/column dimensions for Dataplot's
                        work space.
    SYSTEM LIMITS     = Parameters defining certain Dataplot limits.
    MACHINE CONSTANTS = Return the values for certain machine constants.

Applications:
    Debugging
 
Implementation Date:
    Pre-1987
 
Program:
    SKIP 25
    READ BERGER1.DAT Y X BAT
    PLOT Y VS X
    .
    PROBE NUMNAM
    PROBE NUMCOL
    PROBE N
    PROBE NK
 
-----WRITE-------------------------------------------------------
 
WRITE
 
Name:
    WRITE
 
Type:
    Support Command
 
Purpose:
    Writes variables (vectors), parameters (scalars), functions
    (including strings), and matrices to the screen or to a file.

Syntax 1:
    WRITE <variable list>      <SUBSET/EXCEPT/FOR qualification>
    where <variable list> is a list of parameters, variables, strings,
             or matrices (separated by spaces);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    WRITE <file name>  <variable list>
                       <SUBSET/EXCEPT/FOR qualification>
    where <file name> specifies the name of the output file;
          <variable list> is a list of parameters, variables, strings,
             or matrices (separated by spaces);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If the file name does not contain a period, place a period (no
    spaces) at the end of the file name.
 
Syntax 3:
    WRITE VARIABLES ALL

    This syntax writes all currently defined variables (up to
    25 variables may be printed).  Although this command was
    implemented primarily for the Tcl/Tk graphical interface,
    it can also be used directly.

Syntax 4:
    WRITE <HTML/LATEX/RTF> <file name>  <variable list>
                           <SUBSET/EXCEPT/FOR qualification>
    where <file name> specifies the name of the output file;
          <HTML/LATEX/RTF> specifies that variables will be written
              HTML (HTML), LaTex (LATEX), or Rich Text Format (RTF)
              format;
          <variable list> is a list of variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used to write variables in either HTML, LaTex,
    or RTF format.  It is restricted to variables only (i.e., no
    parameters, strings, or matrices).  In addition, HTML format
    is limited to 15 variables and LaTex and RTF format are
    limited to 7 variables.  LaTex and RTF have a fixed width
    pages which is why we currently restrict the number of
    columns.

    This option is useful when you want to display output for
    web pages or you want to import output into documents.  The
    output from the WRITE comamnd will be generated as a "table".

Syntax 5:
    <WRITE1/WRITE2/WRITE3> <file name>  <variable list>
                           <SUBSET/EXCEPT/FOR qualification>
    where <file name> specifies the name of the output file;
          <variable list> is a list of parameters, variables, strings,
             or matrices (separated by spaces);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is similar to the standard WRITE command.  However, there
    are some distinctions between how WRITE1, WRITE2, and WRITE3 work
    compared to WRITE.  This is discussed in a Note section below.
 
Syntax 6:
    HEAD <variable list>
    where <variable list> is a list of parameters, variables, strings,
             or matrices (separated by spaces).

    This syntax will print the first 10 rows of variables.  To
    modify the number of rows HEAD will print, enter

       SET HEAD LINES <value>

Syntax 7:
    HEAD <file name>  <variable list>
    where <file name> specifies the name of the output file;
    and   <variable list> is a list of parameters, variables, strings,
             or matrices (separated by spaces).
 
    This syntax will print the first 10 rows of variables.  To
    modify the number of rows HEAD will print, enter

       SET HEAD LINES <value>

    If the file name does not contain a period, place a period (no
    spaces) at the end of the file name.

Syntax 8:
    TAIL <variable list>
    where <variable list> is a list of parameters, variables, strings,
             or matrices (separated by spaces).

    This syntax will print the last 10 rows of variables.  To
    modify the number of rows TAIL will print, enter

       SET TAIL LINES <value>

Syntax 9:
    TAIL <file name>  <variable list>
    where <file name> specifies the name of the output file;
    and   <variable list> is a list of parameters, variables, strings,
             or matrices (separated by spaces).
 
    This syntax will print the last 10 rows of variables.  To
    modify the number of rows TAIL will print, enter

       SET TAIL LINES <value>

    If the file name does not contain a period, place a period (no
    spaces) at the end of the file name.

Examples:
    WRITE OUT. Y1 Y2 Y3 X
    WRITE DATA.SAVE X Y PRED RES
    WRITE X Y PRED RES
 
Note:
    The following methods can be used to control the format of
    the output.

       1) The default is to print in exponential format.

       2) You can enter the command

             SET WRITE DECIMALS <value>

          where <value> is an integer in the range 0 to 12.  This
          specifies the number of digits to the right of the decimal
          point (use 0 to print data as integers).

          The primary drawback of this option is that all
          variables will be written with the same value.

       3) To specify an explcit format, enter 

             SET WRITE FORMAT  <string>

          where <string> is a Fortran-like format statement.
          Currently, only F, E, and X format are supported (you
          can use Fxx.0 to print integer values, although the
          decimal point will still be printed).

          Although this provides a flexible option, one drawback is
          that it cannot be used for the <HTML/LATEX/RTF> option.

          Enter HELP WRITE FORMAT for details.

       4) You can specify the total width and the number of
          digits to the right of the decimal point by entering
          the command

             TABLE WIDTH  <ntot>  <nright>

          where <ntot> and <nright> are variables that contain
          the total number of digits and the number of digits
          to the right of the decimal point, respectively.

          That is row 1 of <ntot> and <nright> applies to the
          first variable printed, row 2 applies to the second
          variable printed, and so on.  Up to 200 rows may be
          specified.

          A few comments on what may be specified (assume NTOT
          and NRIGHT are the values for a given row).

          a) A value of -99 indicates that the default value
             should be used (15 for NTOT, 7 for NRIGHT).

          b) If NRIGHT is 0, then an integer format will be used.

          c) If NRIGHT is a positive integer, then a Fortran F
             format will be used.  For example, NTOT = 4 and
             NRIGHT = 2 will print something like "3.26".

          d) If NRIGHT is between -3 and and -20, a Fortran E
             format (i.e., scientific notation) will be used
             and NRIGHT specifies the number of digits in the
             mantissa.

          e) If NRIGHT is -2, then a G15.7 format will be used.
             With the G format, the Fortran compiler will
             decide, at runtime, whether an F format or an
             E format is more appropriate for a given number.

    The precedence order is:

        1. First check to see if a SET WRITE FORMAT command was
           given (this step will be skipped if writing HTML,
           LaTex, or RTF format).

        2. Next check to see if a TABLE WIDTH option was given.
           This option does apply to HTML, LaTex, and RTF output.

        3. Next check to see if a SET WRITE DECIMALS option was given.

        4. If none of the above options were given, use the default
           format (i.e., scientific notation).

Note:
    By default, Dataplot will open the output file before performing
    the WRITE and then close the output file after performing the
    WRITE.  This means that the output file will contain the contents of
    a single WRITE command (and the content will start in row 1 of
    the output file).  If the file already exists (before the WRITE
    command) it is overwritten.

    However, sometimes you may want to append the output of several
    WRITE commands to the same output file.

    The SET WRITE REWIND OFF command suppresses the automatic closing
    of the file after the WRITE command.  So a typical sequence
    would be something like

         SET WRITE REWIND OFF
         WRITE FILE.OUT  ....
         WRITE FILE.OUT  ....
         WRITE FILE.OUT  ....
         SET WRITE REWIND ON
         WRITE FILE.OUT  " "

    We specify the final write (just a blank line) after the
    SET WRITE REWIND command in order to insure that the ouput
    file is closed.

    Note that Dataplot currently only uses a single unit number
    for the WRITE command.  This means that if you use the
    SET WRITE REWIND OFF command, you should write to the same
    file until the SET WRITE REWIND comamnd has been entered and
    the current file has been closed (i.e., the final WRITE after
    the SET WRITE REWIND ON command).  If you try to write to
    multiple output files after a SET WRITE REWIND OFF, the
    results may be unpredictable.

Note:
    Dataplot writes to an ASCII text file.  With one exception, no
    method of writing binary files is currently supported.

    The one exception is that you can use the command

        SET WRITE FORMAT UNFORMATTED

    to write variables in an unformatted Fortran file.  Note that
    this is not a portable format.  Its primary use is to speed up
    the read time for large files that will be read many times on
    the same system.

    It is not appropriate for archiving data since Fortran unformatted
    files are compiler dependent.
 
Note:
    The WRITE command supports the "TO" syntax.  For example,

        WRITE FILE.OUT X1 X2 Y1 TO Y8 Y15

    The "Y1 TO Y8" will write variables Y1, Y2, Y3, Y4, Y5, Y6,
    Y7, and Y8.

Note:
    When writing variables, you can specify a title for the output
    by entering the command

       SET TABLE TITLE <string>

    You can also specify whether rule lines are drawn above and
    below the variable names in the output by entering the command

       SET TABLE BORDER <ON/OFF>

    The default is ON.

    If the VARIABLE LABEL command has been used to define labels
    for the variables, these will be used instead of the variable
    names in the header line.  These variable labels will be
    truncated if they are longer than the width of the field
    (variable labels can be 24 characters long while fields in the
    WRITE command are ofter set to 15 or less).

    If you want to suppress the variable names, enter the command

        SET TABLE HEADER OFF

    To restore the default of printing the variable names, enter

        SET TABLE HEADER ON

Note:
    Literal text can be written by enclosing it in double quotes.  For
    example,

        WRITE "Enter the value for X"
 
Note:
    Dataplot has no restrictions on the file name other than it be a
    valid file name on the local operating system and that it contain
    a period "." in the file name itself or as a trailing character.
    Dataplot strips off trailing periods on those systems where it is
    appropriate to do so.  On systems where trailing periods can be a
    valid file name (e.g., Unix), Dataplot opens the file with the
    trailing period.
 
Note:
    File names are case sensitive on Unix file systems.  For Unix,
    Dataplot opens the file as given.  All other currently supported
    systems are not case sensitive regarding file names.
 
    As a further caution for Unix hosts, certain expansion characters
    (specifically ~ to refer to your home directory) are interperted
    by the shell and are not recognized by the Fortran compiler.  These
    expansion characters are interperted as literal characters and do
    not yield the intended file name.
 
Note:
    The 2016/07 version of Dataplot added the following command

        SET WRITE HEADER FILE <file>

    If you specify a header file, the contents of that file will be
    added to the beginning of the file specified on the WRITE command.

Note:
    The 2018/10 version of Dataplot added support for writing row labels,
    group labels, and character variables.

    To print row labels, use ROWLABEL as the variable name.  This is
    demonstrated in the Program 2 and Program 3 examples below.  The
    Program 2 example also shows how to print character fields as coded
    numeric variables while Program 3 prints the original character
    values.

    The Program 4 example demonstrates writing a group label variable.

Note:
    The 2018/12 version of Dataplot added support for the WRITE1, WRITE2,
    and WRITE3 commands.

    The behavior of the WRITE command is:

        1. Open the file (it will be closed first if it is already open).

        2. Write the specified data to the specified file.

        3. Close the file.

    There are two primary limitations for the WRITE command.

        1. There is no "append" mode.  That is, the current WRITE command
           will overwrite the previous contents of the file.

           This limitation can be mitigated to some extent with the
           SET WRITE REWIND command described above.  Note however that
           the SET WRITE REWIND settings apply to all subsequent WRITE
           commands.

        2. There is only one "active" write file at any given time.

    The following is an example of where these limitations may come into
    play.  Suppose we are processing a list of files and performing a
    FIT to the variables in these files.  We would like to save the
    residual and predicted values for each fit to a file.  However, we
    would also like to save some summary information about each fit to
    another file.  This was the situation that the WRITE1/WRITE2/WRITE3
    commands are intended to address.

    Specifically, the behavior of WRITE1/WRITE2/WRITE3 is

         1. Check if the file specified on WRITE1 (or WRITE2 or WRITE3) is
            already open.  If not, open the file.  However, if the file is
            already open do not close or rewind the file.

         2. Write the desired information to the specified file.

         3. Do not close the file.

            If you need to close the file (e.g., to view the contents),
            you can do something like the following

               WRITE1 FILE1.OUT ...
                   ...
               WRITE1 FILE1.OUT ...
               PROBE IWRIN1
               LET IFLAG = CLOSE PROBEVAL
               LIST FILE1.OUT

            For WRITE2 and WRITE3, use IWRIN2 and IWRIN3, respectively.

    The WRITE1, WRITE2, and WRITE3 units are treated independently of
    each other.  That is, you can concurrently maintain append access to
    three distinct files while still using the WRITE command in the
    normal way.

    An example of using WRITE1 is given in the Program 5 example below.

Note:
    If you enter a single variable name with no arguments and that
    variable name is not a recognized command, Dataplot will interpret
    that as WRITE command.  For example, entering

         Y

    will be interpreted as

         WRITE Y

    If a single word command is entered, Dataplot first tries to
    process it as a command.  If the command is successfully executed
    or it generates an error message, nothing further is done.  However,
    if no match is found and no error is generated, Dataplot will
    prepend a WRITE to the command and re-process it.  Specifically,
    R, REPEAT, X, S, SAVE, L, and LIST are valid commands without
    arguments.  A number of other commands without arguments (e.g.,
    NLIST or FIT) will generate an error.  So, for example, if you have
    a variable called R you need to enter WRITE R rather than just R.

    This only applies to single word commands.  Entering

        Y1 Y2 Y3

    will not be interpreted as

        WRITE Y1 Y2 Y3

Note:
    The 2020/05 version of Dataplot added the following command

        SET WRITE CSV <ON/OFF>

    Setting this to ON will write the file as a comma separated values
    (CSV) file.  This option in intended primarily for the case where you
    want to import the file into another program that expects ASCII files
    to be in CSV format.

Default:
    None
 
Synonyms:
    PRINT is a synonym for WRITE.
    WRITE ALL VARIABLES is a synonym for WRITE VARIABLES ALL.
 
Related Commands:
    SET WRITE FORMAT    = Define a Fortran like format for writing
                          data.
    SET WRITE DECIMALS  = Specify the number of digits to the right of
                          the decimal point when printing numbers.
    SET WRITE REWIND    = Specify if the output file is rewound
                          before writing.
    WRITE ROW           = Write data with a row orientation rather than
                          column orientation.
    READ                = Read variables, parameters, strings, and
                          matrices from a file.
 
Applications:
    Data Output
 
Implementation Date:
    Pre-1987
    1997/12: Implemented Syntax 3.
    2003/09: Support for HTML and LaTex output.
    2009/04: Support for RTF output.
    2009/04: Maximum number of variables for the WRITE command
             increased to 1024.
    2018/10: Support for writing group labels
    2018/10: Support for writing row labels, character data
    2018/12: Support for WRITE1, WRITE2, and WRITE3
    2019/11: Support for HEAD and TAIL options
    2019/12: Support for interpreting single word commands as
             implicit WRITE commands
 
Program 1:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET Y2 = EXPONENTIAL RANDOM NUMBERS FOR I = 1 1 100
    LET Y3 = UNIFORM RANDOM NUMBERS FOR I = 1 1 100
    WRITE RANDOM.DAT Y1 Y2 Y3
 
Program 2:
    SET CONVERT CHARACTER CATEGORICAL
    SET ROW LABEL COLUMN 1
    READ TEST_CHAR.DAT IROW Y X1 X2
    .
    SET WRITE DECIMALS 1
    WRITE ROWLABEL Y X1 X2

Program 3:
    SET CONVERT CHARACTER ON
    SET ROW LABEL COLUMN 1
    READ TEST_CHAR.DAT IROW Y X1 X2
    .
    SET WRITE DECIMALS 1
    WRITE ROWLABEL Y X1 X2

Program 4:
    set convert character on
    skip 25
    read draft69c.dat rank day month
    .
    let ig = group label month
    set write decimals 2
    write rank day month ig

Program 5:
    skip 25
    read berger1.dat y x batch
    set write decimals 5
    .
    fit y x
    write1 fit_summary.out "a0: ^a0, a1: ^a1"
    write1 fit_summary.out "ressd: ^ressd"
    .
    write fit_data.txt y x pred res
    .
    let corr = correlation y x
    write1 fit_summary.out " "
    write1 fit_summary.out " "
    write1 fit_summary.out "Correlation: ^corr "
    probe iwrin1
    let iflag = close probeval
    list fit_summary.out
    .
    write "Summary of fit statistics written to fit_summary.out"
    write "Fit data, predicted values, residuals written to fit_data.txt"

-----WRITE DECIMALS (SET)-------------------------------------------
 
WRITE DECIMALS (SET)
 
Name:
    WRITE DECIMALS (SET)
 
Type:
    Subcommand under SET
 
Purpose:
    This command specifies the number of digits to print to the right
    of the decimal point in subsequent WRITE commands.
 
Syntax:
    SET WRITE DECIMALS   <n>
    where <n> is an integer number or parameter that specifies the
              number of digits.
 
Examples:
    SET WRITE DECIMALS 2
    SET WRITE DECIMALS 1
    SET WRITE DECIMALS DEFAULT
 
Default:
    Data dependent.
 
Synonyms:
    None
 
Related Commands:
    WRITE           = Writes data to the terminal or to a file.
    WRITE REWIND    = Specify file rewind when writing to file.
 
Applications:
    Input/Output
 
Implementation Date:
    1988/03
 
Program:
    SET WRITE DECIMALS 2
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    WRITE RANDOM.DAT Y1
 
-----WRITE EXCEL-------------------------------------------------
 
WRITE EXCEL
 
Name:
    WRITE EXCEL
 
Type:
    Support Command
 
Purpose:
    Writes variables (vectors) to an Excel file.

Description:
    Spreadsheet programs are a popular method for saving data.  Most
    spreadsheet programs support the Microsoft Excel file format.

    Dataplot does not natively support reading or writing to Excel format
    files.  The WRITE EXCEL command works as follows

        1. Dataplot writes the name of the Excel file to line 1
           of the file "dpst5f.dat".  It writes the name of the
           Excel sheet to line 2 of "dpst5f.dat".  The default
           sheet name is "Sheet1".  To change the sheet name, enter
           the command

               SET EXCEL SHEET <sheet-name>

        2. Dataplot writes the contents of the variables to the
           file "dpst1f.dat".

        3. Dataplot then invokes a Python script to read the variables
           saved in "dpst1f.dat" and write them to the Excel file
           listed in "dpst5f.dat".

           The Python script, "write_excel.py", is located in the
           "scripts" subdirectory of the Dataplot auxiliary directory.
           This script uses the Pandas function "pandas.read_csv"
           to read the data from "dpst1f.dat".  It then uses the
           Pandas function "dataframe.to_excel" to write the data
           to Excel.

    This command assumes that Python and the Python package Pandas
    are already installed on your local platform.  Dataplot does not
    check if Python is installed and it does not initiate the
    Python installation if it is not already installed.

    As Python is used by many popular applications on Linux platforms,
    most Linux platforms will already have Python installed.  However,
    this is not the case for Windows and MacOS platforms.

    If you need to install Python, there are a number of Python
    distributions (see https://wiki.python.org/moin/PythonDistributions).
    However, the most common are ActivePython from ActiveState and
    Anaconda from Continuum Analytics.  Dataplot does not depend on a
    specific Python distribution and we make no recommendation for the
    preferred distribution.

    If you infrequently need to write Excel files and do not already
    have Python installed on your local platform, it may be simpler
    to write the Dataplot files to an ASCII file with the WRITE
    command and then import the ASCII file within the spreadsheet
    program.  However, if you anticipate the need for frequently
    writing Dataplot generated data to a spreadsheet, then going
    through the Python installation is probably worth the effort.

Syntax:
    WRITE EXCEL <fname> <variable list>
                <SUBSET/EXCEPT/FOR qualification>
    where <fname> is the name of the Excel file to write to;
          <variable list> is a list of variables to write;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Examples:
    WRITE EXCEL FILE.XLSX Y1 Y2 Y3 X
    WRITE EXCEL FILE.XLSX Y1 Y2 Y3 X  SUBSET X > 0

Note:
    Excel (or some other spreadsheet program) does not need to be
    installed on your local platform.  For example, you can create
    the Excel file on a Linux platform and then move the Excel file
    to a Windows platform to view in Excel.

Note:
    If Python is not installed on your default path, you can specify it
    using the SET PYTHON PATH command. For example, the following is for
    the Anaconda installation of Python 3 under Windows (where Anaconda
    is installed for the single user heckert)

       set python path c:\Users\heckert\AppData\Local\Continum\anaconda3\

    There are several different Python distributions. The appropriate
    Python path will depend on the specific distribution you used to
    install Python and whether you choose to install it for a single user
    or for all users. 

Note:
    On Windows platforms, the "write_excel.py" script will be copied to
    the current directory.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    READ EXCEL  = Read variables from an Excel file.
    PYTHON      = Run a user specified Python script from within Dataplot.
    WRITE       = Write variables, strings, parameters and matrices.
 
Applications:
    Data Output
 
Implementation Date:
    2020/02

Program:
    rm dpzchf.dat
    .
    SET CONVERT CHARACTER ON
    READ IMONTH VALUE1 VALUE2 VALUE3
    January    21205    1  100
    February   19867    2  200
    March      24991    3  300
    April      16523    4  400
    May        17341    5  500
    June       27912    6  600
    July       29105    7  700
    August     28766    8  800
    September  23332    9  900
    October    20211   10 1000
    November   18298   11 1100
    December   13112   12 1200
    END OF DATA
    .
    write excel test.xlsx  imonth value1 value2 value3
    list excel test.xlsx

-----WRITE FEEDBACK (SET)-------------------------------------------
 
WRITE FEEDBACK (SET)
 
Name:
    WRITE FEEDBACK (SET)
 
Type:
    Subcommand under SET
 
Purpose:
    When the FEEDBACK switch is ON, force the output to print.

Description:
    In certain cases, you may not see certain output to the screen even
    though the FEEDBACK switch is ON.  In most cases, you should not need
    to use this command.  However, if you are not seeing output that you
    expect to see, you can try entering

         SET WRITE FEEDBACK ON

    to see if that corrects the issue.

Syntax:
    SET WRITE FEEDBACK  <ON/OFF>
    where ON specifies that output to the screen should be written
             when the FEEDBACK switch is ON and OFF specifies that
             the default behavior will be used.
 
Examples:
    SET WRITE FEEDBACK ON
    SET WRITE FEEDBACK OFF
 
Default:
    OFF
 
Synonyms:
    YES and TRUE are synonyms for ON
    NO, NONE, FALSE are synonyms for OFF
 
Related Commands:
    WRITE           = Writes data to the terminal or to a file.
    FEEDBACK        = Specify the feedback switch.
 
Applications:
    Input/Output
 
Implementation Date:
    2018/11
 
Program:
    XX
 
-----WRITE FORMAT (SET)-------------------------------------------
 
WRITE FORMAT (SET)
 
Name:
    WRITE FORMAT (SET)
 
Type:
    Subcommand under SET
 
Purpose:
    Sets the (optional) Fortran format for the WRITE command.
 
Description:
    Any Fortran-like format must contain only F (floating-point), E
    (exponential), and X (blanks) specifications.  I (integer), D
    (double-precision), H (hollerith), etc. specifications are not
    permitted.  The restriction against I format is no restriction at
    all.  Simply use the corresponding F format (thus I2 becomes F2.0,
    I8 becomes F8.0, etc.).
 
Syntax:
    SET WRITE FORMAT   <s>
    where <s> is a string containing a Fortran format.
 
Examples:
    SET WRITE FORMAT 4F10.0
    SET WRITE FORMAT 5X,F6.0,F6.2,4X,2F5.0
    SET WRITE FORMAT 10X,3E12.4,5X,F10.0
    SET WRITE FORMAT DEFAULT
 
    SET WRITE FORMAT 3F10.0
    WRITE CALIB.DAT X Y Z
 
Note:
    Support was added for writing Fortran unformatted data files.
    This was done primarily for sites that have created "mega" size
    versions of Dataplot where the time entailed in reading and writing
    large data files becomes important.  For standard size Dataplot
    (typically a maximum of 10,000 rows with 10 columns for 100,000
    data points total), the use of the SET READ FORMAT and SET WRITE
    FORMAT commands provides adequate performance.  However, the
    unformatted read and write capability is available regardless of
    the workspace size.  The advantage of unformatted read and writes
    is that the data files are much smaller (typically by a factor of
    10 or more) and reading and writing the data is significantly
    faster.  The disadvantage is that unformatted files are binary, and
    thus cannot be modified or viewed with a standard text editor.
    Also, Fortran unformatted files are NOT transportable across
    different computer systems.  Unformatted Fortran files are NOT
    equivalent to C language byte stream files (these types of files
    are not currently supported in Dataplot).

    An unformatted write is accomplished by entering the command:

       SET WRITE FORMAT UNFORMATTED

    and then entering a standard WRITE command.  For example,

       WRITE LARGE.DAT X1 X2 X3

    There are 2 ways to create the unformatted file in Fortran.  For
    example, suppose X and Y are to be written to an unformatted
    file.  The WRITE can be generated by:

    a)    WRITE(IUNIT) (X(I),Y(I),I=1,N)
    b)    WRITE(IUNIT) X,Y

    The distinction is that (a) stores the data as X(1), Y(1),
    X(2), Y(2), ..., X(N), Y(N) while (b) stores all of X then
    all of Y.  There is no inherent advantage in either method in
    terms of performance or file size.  The SET WRITE FORMAT
    UNFORMATTED command only supports (a).

    Unformatted writing is supported only for variables or matrices
    (i.e., not for parameters or strings).

    Fortran unformatted files are NOT transportable across systems.
    This is due to the fact that the file contains header bytes (the
    Fortran standard leaves implementation of this up to vendor) that
    are not standard.  Also, the storage of real numbers varies
    between platforms.  This means that the SET WRITE FORMAT
    UNFORMATTED command can NOT be used to write raw binary files (as
    might be produced by a C program) and it cannot, in general, be
    used to write unformatted Fortran files that can be read on systems
    other than the one you are running Dataplot on.

Default:
    Data dependent
 
Synonyms:
    SET PRINT FORMAT
 
Related Commands:
    WRITE       = Write data to a file.
    READ FORMAT = Set an optional Fortran format for subsequent read
                  operations.
 
Applications:
    Input/Output
 
Implementation Date:
    88/03 (support for Fortran unformatted write added 02/96)
 
Program:
    XX
 
-----WRITE REWIND (SET)-------------------------------------------

WRITE REWIND (SET)

Name:
    WRITE REWIND (SET)
 
Type:
    Subcommand under SET
 
Purpose:
    Specify whether or not a file being written to is closed and
    rewound after the completion of the write operation.
 
Description:
    Normally Dataplot writes to the beginning of a file.  This means
    that if the file already exists, it is overwritten.  However,
    there are occassions where it is useful to do multiple WRITEs to
    the same file.  This command specifies that files being written
    are not rewound (more specifically, when a write is performed, the
    file is left open at its current position).
 
Syntax:
    SET WRITE REWIND   <ON/OFF>
    where ON specifies that the file is rewound after the completion
             of the write operation while OFF specifies that the file
             is left open at its current position.
 
Examples:
    SET WRITE REWIND ON
    SET WRITE REWIND OFF
 
Note:
    This command does NOT open the file in append mode.  This means
    that the first WRITE still overwrites a previously existing file
    even if the WRITE REWIND switch is set to OFF.
 
Default:
    Files are rewound before writing (i.e., ON).
 
Synonyms:
    None
 
Related Commands:
    READ            = Carries out a column-wise input of data.
    SERIAL READ     = Carries out a line-wise input of data.
    READ FUNCTION   = Read a function.
    READ PARAMETER  = Read a parameter.
    READ MATRIX     = Read a matrix.
    READ STRING     = Read a string.
    READ REWIND     = Specify file rewind when reading a file.
 
Applications:
    Input/Output
 
Implementation Date:
    88/3

Program:
    SET WRITE REWIND OFF
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    WRITE RANDOM.DAT "NORMAL RANDOM NUMBERS"
    WRITE RANDOM.DAT Y1
    LET Y2 = EXPONENTIAL RANDOM NUMBERS FOR I = 1 1 100
    WRITE RANDOM.DAT "EXPONENTIAL RANDOM NUMBERS"
    WRITE RANDOM.DAT Y2
 
-----WRITE ROW---------------------------------------------------
 
WRITE ROW
 
Name:
    WRITE ROW
 
Type:
    I/O Command
 
Purpose:
    Write variables in a row-wise fashion.
 
Description:
    Dataplot is a column oriented system.  That is, columns denote
    variables while rows denote observations.  The WRITE command will
    write variables in this column-wise fashion.

    Sometimes you may encounter data files that are row oriented, that
    is rows denote variables while columns denote observations.  This is
    often the case when the number of variables is significantly greater
    than the number of observations.  The READ ROW command was added to
    accomodate these types of files.

    Often these row-oriented files will contain a large number of rows
    and take a long time to read.  Typically, you cannot use the
    SET READ FORMAT command on these files to speed up the read.  The
    WRITE ROW command was added in order to allow you to create a version
    of the row oriented file that can be read using the SET READ FORMAT
    with the READ ROW command.  This speed-up can be on the order of a
    factor of 10 to 20.  The downside is that the new file is typically
    larger than the original file.

    The WRITE ROW command is only supported for numeric variables.

Syntax 1:
    WRITE ROW <var-list>
    where <var-list> is a list of variable names to write.
 
    This syntax is used to write to the terminal or from within a
    macro file.

    In practice, WRITE ROW is not typically used for terminal writes.
    However, it does work.
 
Syntax 2:
    WRITE ROW   <file>   <var-list>
    where <file> is the name of the file where the data resides;
    and   <var-list> is a list of variable names to write.

    This syntax is used to write to a file.

    The WRITE ROW is often used when there are a large number of
    variables.  The TO syntax is supported for this command which is
    useful when there are a large number of variables to write.

Examples:
    WRITE ROW FILE.DAT Y1 Y2 Y3 Y4 Y5
    WRITE ROW FILE.DAT Y1 TO Y100
 
Note:
    In order to determine whether the first argument is a file name or
    a variable name, Dataplot looks for a period in the name.  If it finds
    one, it assumes a file name.  If it does not, it assumes a variable
    name.
 
Note:
    Dataplot does not assume specific extensions for file names.  Although
    using conventions (e.g., ".DAT" or ".TXT" for data files, ".DP" for
    Dataplot macros) can be helpful for distinguishing between types of
    files, this is more for the analysts convenience.  Dataplot itself
    does not enforce any conventions.

    File names have the following restrictions:

        1. The file name should be a valid file name for the local
           operating system.

        2. The file name should contain a period "." in the file name
           itself or as a trailing character.  Dataplot strips off trailing
           periods on those systems where it is appropriate to do so.  On
           systems where trailing periods can be a valid file name (e.g.,
           Unix), Dataplot tries to open the file with the trailing period.
           If this fails, it then tries to open the file with the trailing
           period stripped off.

        3. If the file name contains spaces or hyphens, then it needs to be
           enclosed in quotes.

        4. File names are currently limited to 80 characters.  This can
           in particular be a problem if the file name is contained within
           a long path name.

           You can use the CD command to make the path where the file
           is stored the current directory.  This is most useful for
           data files.  For example,

                pwd
                cd  <path where data file resided>
                write row  file.dat ...
                cd ^CURDIR

           The pwd command is used to save the current directory.  The
           cd command is then used to set the current directory to the
           path where the data resides, the read is performed, and then
           the cd command is used to restore the original working
           directory (the cd command saves the current path in the
           string CURDIR).

Note:
    File names are case sensitive on Unix/Linux/Mac OS X systems.
 
    As a further caution for Unix/Linux hosts, certain expansion characters
    (specifically ~ to refer to your home directory) are interpreted
    by the shell and are not recognized by the Fortran compiler.  These
    expansion characters are interpreted as literal characters and do
    not yield the intended file name.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WRITE                  = Write variables to the screen or to a file.
    READ                   = Read data into variables.
    READ ROW               = Read row oriented data into variables.
    SERIAL READ            = Perform a serial read.
    CLIPBOARD              = Various commands for writing to the system
                             clipboard.
 
Applications:
    Data Output
 
Implementation Date:
    2018/10
 
Program 1:
    skip 25
    read berger1.dat y x batch
    .
    set write format 107F10.4
    write row berger1_row.dat y x batch

-----WRT-------------------------------------------------------

WRT

Name:
    WRT

Type:
    Keyword

Purpose:
    Defines the variable of interest for:
       1) roots
       2) differentiation
       3) integration
    in the LET command ("WRT" stands for "with respect to").

Syntax:
    None

Examples:
    LET R = ROOTS X-EXP(X) WRT X FOR X 0 3
    LET FUNCTION F2 = DERIVATIVE F1 WRT X
    LET A = INTEGRAL LOG(X) WRT X FOR X 1 2

Default:
    None

Synonyms:
    None

Related Commands:
    LET  = Perform various transformations and mathematical operations.

Applications:
    Mathematics

Implementation Date:
    Pre-1987

Program:
    XX

---------------------------------------------------------


























-------------------------  *X*  ZZZZZ--------------------
 
-----XBAR CHART--------------------------------------------------
 
XBAR CHART
 
Name:
    XBAR CHART
 
Type:
    Graphics Command
 
Purpose:
    Generates a mean control chart.
 
Description:
    A mean control chart is a data analysis analysis technique for
    determining if a measurement process has gone out of statistical
    control.  The x chart is sensitive to shifts in location in the
    measurement process.  It consist of:
       Vertical   axis = the mean for each sub-group.
       Horizontal axis = sub-group designation.
    In addition, horizontal lines are drawn at the overall mean and
    at the upper and lower control limits.
 
Syntax:
    XBAR CHART   <y>   <x>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response (= dependent) variable (containing the
              raw data values);
          <x> is an independent variable (containing the sub-group
              identifications);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    XBAR CHART Y X
 
Note:
    The distribution of the response variable is assumed to be normal.
    This assumption is the basis for calculating the upper and lower
    control limits.
 
Note:
    The attributes of the 4 traces can be controlled by the standard
    LINES, CHARACTERS, BARS, and SPIKES commands.  Trace 1 is the
    response variable, trace2 is the mean line, and traces 3 and 4 are
    the control limits.  Some analysts prefer to draw the response
    variable as a spike or character rather than a connected line.
 
Default:
    None
 
Synonyms:
    XBAR CONTROL CHART for X CHART
    MEAN CONTROL CHART for X CHART
    X CHART for XBAR CHART.
 
Related Commands:
    R CHART        = Generates a range control chart.
    S CHART        = Generates a standard deviation control chart.
    P CHART        = Generates a p control chart.
    NP CHART       = Generates a Np control chart.
    U CHART        = Generates a U control chart.
    C CHART        = Generates a C control chart.
    CHARACTERS     = Sets the types for plot characters.
    LINES          = Sets the types for plot lines.
    SPIKES         = Sets the on/off switches for plot spikes.
    BARS           = Sets the on/off switches for plot bars.
    PLOT           = Generates a data or function plot.
    LAG PLOT       = Generates a lag plot.
    4-PLOT         = Generates 4-plot univariate analysis.
    MEAN PLOT      = Generates a mean (vs subset) plot.
 
Applications:
    Quality Control
 
Implementation Date:
    88/2
 
Program:
    SKIP 25
    READ GEAR.DAT DIAMETER BATCH
    .
    LINE SOLID SOLID DOT DOT
    TITLE AUTOMATIC
    X1LABEL GROUP-ID
    Y1LABEL MEAN
    X CHART DIAMETER BATCH
 
-----XFRAME (LET)---------------------------------------------------
 
XFRAME
 
Name:
    XFRAME (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Determine the frame limits for the x-axis without generating a plot.
 
Description:
    In some cases, we may want to determine the frame limits that would
    be computed for a given data set without actually generating a plot.
    For example, if we are plotting subsets of a data set we may want
    the limits based on the full data set.

    One minor complication occurs if we have defined a tic mark offset
    (i.e., the distance from the first or last major tic mark to the
    end of the frame line.  You can use the following command to specify
    whether you want the tic mark offset included in the returned limits

        SET FRAME LIMIT OFFSET <OFF/ON>

    If you specify OFF, the tic mark offset will not be included.  If
    you specify ON, the tic mark offset will be included.

    Note that this command does not actually set the frame limits.  You
    can use the values returned by this command in a subsequent
    XLIMITS command to set the limits.

    This command returns the limits for the x-axis.  The YFRAME command
    can be used to return the limits for the y-axis.

Syntax:
    LET <xmin> <xmax> = XFRAME <x>   <SUBSET/EXCEPT/FOR qualification>
    where <x> is a response variable;
          <xmin> is a parameter that stores the minimum value for the
              x-axis frame;
          <xmax> is a parameter that stores the maximum value for the
              x-axis frame;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Examples:
    LET XMIN XMAX = XFRAME X
    LET XMIN XMAX = XFRAME X  SUBSET X > 0
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    YFRAME       = Return the frame limits for the y-axis.
    LIMITS       = Define limits for the x and y axes.
 
Applications:
    Plotting
 
Implementation Date:
    2016/02
 
Program 1:
    skip 25
    read berger1.dat y x
    .
    set frame limits offset off
    let ymin1 ymax1 = yframe y
    let xmin1 xmax1 = xframe x
    .
    set frame limits offset on
    tic mark offset units screen
    tic mark offset 3 3
    let ymin2 ymax2 = yframe y
    let xmin2 xmax2 = xframe x

-----XPLOT--------------------------------------------------

XPLOT

Name:
    XPLOT

Type:
    Keyword

Purpose:
    An internal variable into which the horizontal coordinates of the
    most recent plot are stored.

Description:
    Whenever Dataplot generates a plot, it saves the horizontal and
    vertical coordinates of each point plotted in the internal
    variables XPLOT and YPLOT.  For 3d plots, it stores the second
    horizontal axis coordinates in the variable X2PLOT. The
    coordinates are saved in the units of the data, not in the
    Dataplot 0 to 100 coordinates.  These variables can be used in
    any way that a user created variable can.

Syntax:
    None

Examples:
    BOOTSTRAP PLOT Y
    LET Y2 = YPLOT
    HISTOGRAM Y2

    . Generate a frequency table
    HISTOGRAM Y
    SET WRITE DECIMALS 3
    PRINT XPLOT YPLOT

    . Generate a table of medians
    MEDIAN PLOT Y GROUP
    SET WRITE DECIMALS 3
    PRINT XPLOT YPLOT

    . Generate a spectral density plot from a periodogram
    PERIODOGRAM Y
    LET A = VARIANCE Y
    LET Y2 = YPLOT/A
    LET X = XPLOT
    TITLE SPECTRAL DENSITY PLOT
    PLOT Y2 X

Default:
    None

Synonyms:
    None

Related Commands:
    TAGPLOT   = An internal variable that contains the trace 
                identifier of the points from the most recent plot.
    YPLOT     = An internal variable that contains the vertical
                coordinates from the most recent plot.
    X2PLOT    = An internal variable that contains the coordinates
                from the second horizontal axis from the most recent 
                3d plot.
    PLOT      = Generate a data of function plot.

Applications:
    XX

Implementation Date:
    XX

Program:
    . Generate a Tukey mean-difference plot
    SKIP 25
    READ AUTO83B.DAT Y1 Y2
    DELETE Y2 SUBSET Y2 < 0
    . 
    QUANTILE-QUANTILE PLOT Y1 Y2
    LET YMEAN = (YPLOT+XPLOT)/2
    LET YDIFF = YPLOT - XPLOT
    LET AMIN = MINIMUM YMEAN
    LET AMAX = MAXIMUM YDIFF
    LET XZERO = DATA AMIN AMAX
    LET YZERO = DATA 0 0
    LINE BLANK SOLID
    CHARACTER CIRCLE BLANK
    CHARACTER SIZE 1.0
    TITLE TUKEY M-D PLOT
    X1LABEL MEAN
    Y1LABEL DIFFERENCE
    PLOT YDIFF YMEAN AND
    PLOT YZERO XZERO

-----XTXINV (LET)----------------------------------------
 
XTXINV MATRIX
 
Name:
    XTXINV MATRIX (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the (X'X)**(-1) matrix.
 
Description:
    The X-transpose X matrix is defined as:

        XTXINV = (X'X)**(-1)

    The X matrix is typically a design matrix for a multiple
    linear regression.

    The (X'X)**(-1) matrix is useful for many regression diagnostic
    computations.  For example, the help for the FIT command
    describes the use of the (X'X)**(-1) matrix in generating
    partial regression plots, partial leverage plots, and
    variance inflation factors.  It is also used to compute
    various intervals for multiple linear regression problems.

    This command simplifies writing macros to compute these,
    as well as other, regression diagnostics.  Although this
    matrix can be read in after performing a linear fit,
    this command simplifies its computation.
 
Syntax:
    LET <mat2> = XTXINV MATRIX <mat1>
                 <SUBSET/EXCEPT/FOR qualification>
    where <mat1> is the design matrix for which the (X'X)**(-1) matrix
                is to be computed;
          <mat2> is a matrix where the resulting (X'X)**(-1) matrix
                is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional (and
                 rarely used in this context).
 
Examples:
    LET XTXINV = XTXINV MATRIX X
 
Note:
    Matrices are created with either the READ MATRIX, CREATE MATRIX,
    or the MATRIX DEFINITION command.  Enter HELP CREATE MATRIX and
    HELP MATRIX DEFINITION and HELP READ MATRIX for details.
 
Note:
    The columns of a matrix are accessible as variables by appending
    an index to the matrix name.  For example, the 4x4 matrix C has
    columns C1, C2, C3, and C4.  These columns can be operated on
    like any other Dataplot variable.
 
Note:
    The maximum size matrix that Dataplot can handle is set when
    Dataplot is built on a particular site.  Enter the command
    HELP MATRIX DIMENSION for details on the maximum size matrix
    that can be accomodated.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FIT                      = Perform a least squares fit.
    CATCHER MATRIX           = Compute the catcher matrix.
    PARTIAL REGRESSION PLOT  = Compute the catcher matrix.
    VARIANCE INFLATION FACT  = Compute variance inflation factors.
    CONDITION INDICES        = Compute condition indices.
    MATRIX INVERSE           = Compute a the inverse of a matrix.
 
Reference:
    "Applied Linear Statistical Models", 3rd ed., Neter, Wasserman,
    and Kunter, 1990, Irwin.
 
    "Applied Regression Analysis", 2nd ed., Draper and Smith, John
    Wiley, 1981.
 
    "Residuals and Influence in Regression", Cook and Weisberg,
    Chapman and Hall, 1982.
 
    "Regression Diagnostics", Belsley, Kuh, and Welsch, John Wiley,
    1980.
 
Applications:
    Regression Diagnostics
 
Implementation Date:
    2002/6
 
Program:
    .  Sample program to compute DFBETA's 
    ECHO ON
    DIMENSION 100 COLUMNS
    SKIP 25 
    READ HALD647.DAT Y X1 X2 X3 X4 
    FIT Y X1 X2 X3 X4 
    SKIP 1 
    SET READ FORMAT E15.7,65X,E15.7 
    READ DPST3F.DAT HII ESTUD 
    SKIP 0 
    SET READ FORMAT 
    . 
    LET N = SIZE X1 
    LET X0 = SEQUENCE 1 1 N 
    LET Z = CREATE MATRIX X0 X1 X2 X3 X4 
    . 
    LET XTXINV = XTXINV MATRIX Z
    LET C = CATCHER MATRIX Z 
    LOOP FOR K = 1 1 5 
        LET TEMP1 = C^K 
        LET TEMP2 = XTXINV^K(K) 
        LET DFBETA^K = TEMP1*ESTUD/SQRT(TEMP2*(1-HII)) 
    END OF LOOP 
    LET N = SIZE Y
    LET XTEMP = SEQUENCE 1 1 N
    .
    CHARACTER B0 B1 B2 B3 B4 B5 BLANK BLANK
    LINE BLANK BLANK BLANK BLANK BLANK DOTTED DOTTED
    X1LABEL SEQUENCE
    Y1LABEL DFBETA
    TIC OFFSET UNITS SCREEN
    TIC OFFSET 5 5
    .
    LET XGRID = DATA 1 N
    LET YGRID = DATA 1 1
    LET YGRID2 = DATA -1 -1
    PLOT DFBETA1 DFBETA2 DFBETA3 DFBETA4 DFBETA5 VERSUS XTEMP AND
    PLOT YGRID YGRID2 VERSUS XGRID
 
-----X11--------------------------------------------------------------
 
X11
 
Name:
    X11
 
Type:
    Output Device Command
 
Purpose:
    Direct graphical output to an X11 graphics device.
 
Description:
    The X Window System is a computer independent protocol developed at
    MIT for supporting windowing and graphics applications in a
    networked environment.  X is emerging as an industry standard and
    is now supported by most workstation vendors.  The X11 driver has
    been successfully implemented on Release 3, Release 4, Release 5
    and Release 6 of X11.
 
Syntax 1:
    X11
 
    This form designates device 1 as an X11 graphics device.
 
Syntax 2:
    DEVICE <1/2/3> X11
 
    This form designates one of Dataplot's 3 devices (typically device
    1) as an X11 device.
 
Examples:
    X11
    DEVICE 1 X11
 
Note:
    Dataplot must be linked with the proper X11 libraries in order for
    the X11 driver to work.  If this is not the case, contact your
    local Dataplot installer.
 
Note:
    A powerful feature of X is the ability to work in a networked
    environment.  Dataplot can use X11 in one of two ways:

      1) Dataplot is installed on a local workstation (e.g., a SUN).
         In this case, simply enter the DEVICE 1 X11 command to open a
         graphics window.  This assumes that X11 is installed on your
         local workstation.  Check with your system administrator if
         you are not sure.

      2) Dataplot is installed on a remote host and the graphics will
         be generated on a local workstation or X11 terminal.  Two
         typical configurations are a workstation running Dataplot
         from a mainframe or a group of workstations linked in a common
         network with Dataplot installed on one of these workstations.
         In this case, X11 must be installed on both the remote host
         and the local host and the following steps are required:
 
         a) Enter the following from your local workstation:
              xhost +   (entered from your local workstation)

         b) rlogin or telnet to the remote host

         c) Enter the following command before executing Dataplot:
              setenv DISPLAY  <local_X_machine>:0

         The xhost command gives the remote host permission to write
         to your display.  The setenv command identifies the specific
         workstation the remote host should generate the graphics on.
         Non-Unix hosts may have a different command than setenv.
 
Note:
    The dataplot command can be executed from any currently open X11
    window.  Dataplot's alphanumeric input and output, such as entering
    commands and the printing of FIT results, occurs in this window.
    Dataplot makes no effort to determine or manipulate the attributes
    of the alphanumeric window.  When the DEVICE 1 X11 command is
    entered, a separate graphics window is opened.  Both the
    alphanumeric and graphics windows can be controlled (i.e., moved,
    resized, exposed) with standard window manager menu options.  In
    addition, the Dataplot commands PICTURE POINTS and ORIENTATION can
    control the size and shape of the graphics window.  If the window
    is resized, the new dimensions do not take effect until the next
    screen erase is performed (this can be forced with a Dataplot
    erase command).  Until the screen erase is done, graphics may
    either be clipped or only use a part of the available window.
 
Note:
    In X11, the window manager is simply another application program.
    This means that different implementations of X11 can use different
    window managers.  There may be minor differences in how the
    Dataplot graphics window interacts with different window managers.
    However, Dataplot is written using the lowest layer of the X11
    libraries (xlib), so it should be compatible with any of the window
    managers.  The popular OpenLook (from Sun and AT&T) and Motif
    (most other vendors) window systems are X11 based and the X11
    driver works with them.
 
Note:
    X11 supports graphical user interfaces.  However, Dataplot simply
    supports X11 as a graphics device driver.
 
Note:
    Several SET commands were added to support X11 specific features.
 
    1) SET X11 NAME <display name>
 
       Normally, X11 sends the graphics to the default display (for
       Unix systems, this is the "setenv DISPLAY" variable).  This SET
       command is used to override the default display name.  On Unix
       systems, this command is the equivalent to doing the Unix
       command "setenv DISPLAY <name>".  The name is given in one of
       the following 2 formats:
 
         SET X11 NAME dogwood.cam.nist.gov:0
         SET X11 NAME 129.6.80.44:0
 
       The numeric address should always be recognized.  The name (and
       any abbreviations of the name) depend on the host tables on the
       specific machine.
 
    2) SET X11 PIXMAP <ON/OFF>
 
       If all or part of the Dataplot graphics window is covered and
       then re-exposed, the current graph is not automatically
       redrawn.  If the PIXMAP variable is turned on, graphs are
       written to a pixmap in the background as well as to the screen.
       If part of the current graph is lost, the pixmap is copied to
       the screen to restore the current graph (the updating does not
       occur until the next command is entered).  This option is
       recommended.
 
       This switch is ON by default.

    3) SET X11 FONT <font name>
 
       The X11 font name can be up to 80 characters long.  The
       following are terminal emulator fonts that should be available
       on most X11 systems.
 
           6x10
           6x12
           6x13
           8x13
           8x13bold
           9x15
           fixed
           variable
 
       In addition, most X11 implementations provide a large number of
       additional fonts.  The complete list available on a given
       implementation can be retrieved with the "xlsfonts" command.
       Since the list of fonts varies with the implementation,
       Dataplot provides no abbreviations of the font names (which
       tend to be long).
 
    4) SET X11 CAP <BUTT/ROUND/PROJECT/NOTLAST>
       SET X11 JOIN <MITER/ROUND/BEVEL>
 
       The cap style determines how the end of lines are drawn
       (referred to as end-caps).  For BUTT, the end-caps are squared
       off at end-points perpindicular to the slope of the line.  The
       NOTLAST option is equivalent to BUTT for wide lines.  For one
       pixel wide lines, the last point is not drawn.  The ROUND option
       draws the end-cap as a circle with diameter equal to the line
       width.  The PROJECT option draws a squared off end-cap, but it
       projects half the line-width beyond the endpoints.  The join
       style controls how intermediate points of a polyline are
       connected (only if the line is more than one pixel wide).  The
       MITER option extends the outer edges so that they meet at the
       same angle as would narrow lines.  The ROUND option rounds off
       corners using a circle with diameter equal to the line width
       centered at the join point.  The BEVEL option joins the lines
       as if they both had BUTT end-caps.  In most cases, the cap and
       join style can simply be defaulted (BUTT and MITER
       respectively).  The other choices are aesthetic preferences.
       Occasionally, curves that meet at sharp angles can produce
       spikes, in which case specifying a join style of ROUND or BEVEL
       should solve the problem.
 
    5) SET X11 PAUSE <ON/OFF>

       If this switch is ON, when a screen erase is performed on the
       X11 graphics window the user will be prompted to enter a carriage
       return.

       This switch is OFF by default.

       Note: This command is currently de-activated.

    6) SET X11 WINDOW ID <string>

       This command is used by the Tcl/Tk Graphical User Interface (GUI)
       when the GUI screen graphics are generated to an X11 window (rather
       than using the Tcl/Tk driver).  This command is typically not
       entered by the user.  If the user enters this command manually, it
       will probably result in the graphics not being displayed on the
       X11 window of the GUI.

Note:
    The 2023/11 version of Dataplot added support for scalable fonts.
    This is provided via the Xft library.

    To specify the use of scalable fonts, enter the commands

          set x11 font type scalable
          set x11 scalable font <font-name>

    Dataplot does no error checking as to whether or not a valid font name
    was entered.  Typically, the font can be entered with a family name
    plus a list of attributes.  For example

      set x11 scalable font LiberationSans-Regular:weight=bold:antialias=true

    Here, "LiberationSans-Regular" is the font family, weight specifies
    that the "bold" version of the font will be used and "antialias=true"
    specifies that the text will be drawn with anti-aliasing (this can
    sharpen the text).

    Some common options are

        weight=<light/medium/demibold/bold/black>
        slant=<roman/italic/oblique>
        spacing=<proportional/mono/charcell>
        antialias=<true/false>

    Dataplot will append a "size=<value>" to the end of the font string
    based on the requested character size.

    Note that if the requested font is not matched exactly, the Xtf
    library will try to match it to the "closest" avaiable font.

    To see a list of available font family names, enter

           fc-list : family | sort

    To see what a font family will be matched to, enter something like

           fc-match Arial

Note:
    Dataplot automatically determines if the X11 device is color.  The
    X11 driver supports the full range of colors available with
    Dataplot (about 88 colors and 100 levels of gray scale).  Enter
    HELP COLOR for a list of available colors.
 
Default:
    Off
 
Synonyms:
    None

Device Notes:
    1) HARDWARE TEXT - A large number of hardware fonts are available
       (use the SET X11 FONT command).  The 6x12 font is the default.
       A given font has a fixed size and rotation, so the only way to
       change the character size is to change the font.
    2) COLOR - X11 devices vary in their support of color (from
       monochrome to full 24-bit color).  For color workstations,
       Dataplot will try to assign all 88 colors.  Colors that are
       not available on the device are set to black (or white for black
       backgrounds).  Gray scale is supported if the device itself
       supports it.
    3) HARDWARE FILL - Solid area fills are done in hardware.
    4) DASH PATTERNS - The following dash patterns are available:
                          DASH  - 6 pixels on, 3 pixels off;
                          DOT   - 1 pixel on, 2 pixels off;
                          DASH2 - 9 pixels on, 3 pixels off, 3 pixels
                                  on, 3 pixels off;
                          DASH3 - 3 pixels on, 3 pixels off;
                          DASH4 - 2 pixels on, 4 pixels off.
    5) LINE WIDTH - Thick lines are generated in hardware.
    6) GRAPHICS INPUT - The CROSS-HAIR command is supported for this
       device.
 
Related Commands:
    POSTSCRIPT            = Direct graphical output to a Postscript
                            device.
    HPGL                  = Direct graphical output to an HPGL device.
    TEKTRONIX             = Direct graphical output to a Tektronix
                            device.
    DEVICE                = Specify certain actions for the graphics
                            output.

Applications:
    Graphics Output

Implementation Date:
    1990/04
    2023/11: Support for scalable fonts using the Xtf library
 
Program:
    DEVICE 1 X11
    PLOT X**2 FOR X = 1 1 9
 
-----X2PLOT--------------------------------------------------

X2PLOT

Name:
    X2PLOT

Type:
    Keyword

Purpose:
    An internal variable into which the second horizontal axis 
    coordinates of the most recent plot are stored.

Description:
    Whenever Dataplot generates a plot, it saves the horizontal and
    vertical coordinates of each point plotted in the internal
    variables XPLOT and YPLOT.  For 3d plots, it stores the second
    horizontal axis coordinates in the variable X2PLOT. The coordinates
    are saved in the units of the data, not in the Dataplot 0 to 100
    coordinates.  These variables can be used in any way that a user
    created variable can.

Syntax:
    None

Examples:
    3D-PLOT F FOR X = -2 0.1 2 FOR Y = -2 0.1 2
    LET X1 = XPLOT
    LET Y1 = YPLOT
    LET X2 = XPLOT
    LET TAG = TAGPLOT

Default:
    None

Synonyms:
    None

Related Commands:
    TAGPLOT   = An internal variable that contains the trace 
                identifier of the points from the most recent plot.
    YPLOT     = An internal variable that contains the vertical
                coordinates from the most recent plot.
    XPLOT     = An internal variable that contains the horizontal
                coordinates from the most recent plot.
    PLOT      = Generate a data of function plot.
    3D-PLOT   = Generate a 3d data of function plot.

Applications:
    XX

Implementation Date:
    XX

Program:
    XX
 
---------------------------------------------------------
 
 
 
 
 
 
 
 
 
 
 
 
 
 



































-------------------------  *Y*  ZZZZZ--------------------

-----Y0INT (LET)--------------------------------

Y0INT

Name:
   Y0INT (LET)
 
Type:
    Library Function

Purpose:
    This program computes the integral of the Bessel function Y0(x).

Description:
    The Y0INT function is defined as:

        Y0INT(x) = {integral 0 to x} Y0(t) dt

    with Y0 denoting the Bessel function of the second kind of
    order 0.

    Dataplot computes this function using ACM Algorithm 757 (see
    Reference: below).  The function is computed using Chebyshev
    expansions, the coefficients of which are given to 20 decimal
    places.

Syntax:
    LET <y> = Y0INT(<x>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative number, variable or parameter;
          <y> is a variable or a parameter (depending on what <x> 
               and <ord> are) where the computed Y0INT function
               values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = Y0INT(2.3)
    PLOT Y0INT(X) FOR  X = 0 .01 10
    LET X2 = Y0INT(X1) FOR X1 = 0.1 0.1 3.0
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BESSYN     = Compute the Bessel function of the second kind and
                 order N.
    BESSJN     = Compute the Bessel function of the first kind and
                 order N.
    BESSIN     = Compute the modified Bessel function of the first
                 kind and order N.
    BESSKN     = Compute the modified Bessel function of the third
                 kind and order N.
    I0INT      = Compute the integral of the modified Bessel
                 function of the first kind and order 0.
    K0INT      = Compute the integral of the modified Bessel
                 function of the third kind and order 0.
    J0INT      = Compute the integral of the Bessel function of
                 the first kind and order 0.

Reference:
    "ACM Transactions of Mathematical Software", Allan MacLead,
    Vol. 22, No. 3, September, 1996, pp. 288-301.
 
Applications:
    Special Functions
 
Implementation Date:
    2005/11
 
Program:
    TITLE Y0INT FUNCTION
    PLOT Y0INT(X) FOR X = 0 0.01 10
 
-----YATES ANALYSIS----------------------------------------------

YATES ANALYSIS

Name:
    YATES ANALYSIS

Type:
    Analysis Command

Purpose:
    Carry out a Yates analysis for estimating factor effects in 2-level
    full factorial and fractional factorial designs.

Description:
    The Yates analysis yields factor estimates for all of the
    coefficients (main effects and all relevant interactions) in
    2-level full and factorial experiments.  The name "Yates analysis"
    comes from the pioneering work which Yates carried out in the
    analysis of these designs.  Although the Yates algorithm (see Box,
    Hunter, and Hunter, page 342 in the REFERENCE section below), a
    manual iterative procedure for generating estimated factor effects,
    is a bit dated, we carry on the name in the form of the command.
 
    The data in the input variable is assumed to have been collected in
    Yates order (this is described in a NOTE section below).  The
    primary output from the Yates analysis is a list which consists of
    5 columns:
 
      1) A factor identifier (all from Yates order):
            1   = factor 1
            2   = factor 2
            3   = factor 3
            12  = factor 1 x factor 2 interaction
            13  = factor 1 x factor 3 interaction
            23  = factor 2 x factor 3 interaction
            123 = factor 1 x factor 2 x factor 3 interaction
            etc.
 
      2) Least squares estimated factor effects ordered from largest
         in magnitude (most significant) to smallest in magnitude
         (least significant).
 
      3) A t value (= e / sd(e)) where
            e is the estimated factor effect;
            sd(e) is the estimated standard deviation of e.
         Adjacent to this t value is an indication (* or **) as to
         whether the estimated effects are statistically significant
         at the 5% level (*) or 1% (**) level.
 
      4) The residual standard deviation that results from the model:
            response = constant + 1/2 (that single factor only)
         This is of interest but not that important.
 
      5) the (cumulative) residual standard deviation that results from
         the model:
            response = constant + 1/2 (all factors down to and
                       including the factor of interest).
 
         This column will consist of a monotonically decreasing set of
         residual standard deviations (indicating a better and better
         fit as the number of terms included in the model increases).
         The cumulative residual standard deviation at the top of the
         column is for the simplest model:
 
            response = constant + no factors
 
         The cumulative residual standard deviation  (identically 0) at
         the bottom of the column is for the most complicated model:
 
            response = constant + 1/2 (all factors and interactions)
 
    The 5 columns of this ordered list are written out (no header
    lines) to the ASCII files DPST1F.DAT and DPST2F.DAT (the name may
    vary on some operating systems).  The file DPST1F.DAT excludes the
    first line (the estimated mean) and so includes only those
    estimates of the factors and interactions.  The DPST1F.DAT is the
    one that is used for further analysis (e.g., a normal probability
    plot of the effects).  Such a further analysis is done as follows:
            SKIP 0
            READ DPST1F.DAT TAG COEF
            NORMAL PROBABILITY PLOT COEF
            LET COEF2 = ABS(COEF)
            HALFNORMAL PROBABILITY PLOT COEF2
 
    The DPST2F.DAT file has as its first line the mean information, 
    and so is a verbatim copy of the ordered list.  Although of
    interest, this second file is used less frequently.

Syntax 1:
    YATES <y1>  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a response variable in standard Yates form;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax is used for the no replication case.

Syntax 2:
    YATES   <y1>  <group>   <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a response variable in standard Yates form;
          <group> is a variable that identifies the replication;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax is used for the replication case.

Examples:
    YATES ANALYSIS Y
    YATES ANALYSIS Y GROUP
    YATES ANALYSIS Y GROUP  SUBSET GROUP > 1

Note:
    This code assumes the data is in the standard Yates/Hunter/Box
    order.  For example, for a 2**3 design:
           - - -
           + - -
           - + -
           + + -
           - - +
           + - +
           - + +
           + + +
    More specifically, the kth column consists of 2**(k-1) minus signs
    followed by 2**(k-1) plus signs.

Note:
    Since the Yates command has only one argument, the command itself
    does not know whether it is analyzing a full factorial design or
    some fractional factorial design with the same number of runs.  In
    such case, the analyst must make use of the confounding structure
    of 2-level factorial designs to translate the factor tag to its
    various aliases.  The simplest case of this is when the response
    variable has n = 4 observations.  In such case, the YATES command
    would output factor tags on the "assumption" that it is analyzing
    a 2**2 full factorial design.  Such tags would thus be 1, 2, and
    12.  If the design was in fact a 2**(3-1) design, then the analyst
    must augment the 1, 2, and 12 tags by their corresponding aliases--
    in particular for a 2**(3-1):
        1  == 23
        2  == 13
        12 == 3
    For on-line information about confounding structure, the analyst
    is referred (in this case) to the header lines of the ASCII file
    2TO3M1.DAT via:
        LIST 2TO3M1.DAT
    and similar such design files.  To get a list of all such design
    files, enter:
        LIST DESIGNS.

Note:
    If there is replication, then the replicates can either be
    immediately within or they can be in the blocks after.

Note:
    The predicted values and residual values are stored in the 
    internal variables PRED and RES respectively.  These can be used
    in subsequent plot commands to aid diagnostic checking.

Note:
    The YATES <COEF/T/RESSD> CUTOFF and the YATES OUTPUT commands are
    used to control what output is printed by the YATES ANALYSIS
    command.

Default:
    None

Synonyms:
    YATES, YATES FIT, DEX FIT, 2**K FIT are all synonyms for YATES
    ANALYSIS.

Related Commands:
    FIT                            = Carries out a least squares fit.
    PLOT                           = Generates a data or function plot.
    DEX SCATTER PLOT               = Generates a dex scatter plot.
    DEX SIGN PLOT                  = Generates a dex sign plot.
    DEX ... PLOT                   = Generates a dex plot for a
                                     statistic.
    DEX ... PARETO PLOT            = Generates a Pareto dex plot for a
                                     statistic.
    DEX ... YOUDEN PLOT            = Generates a Youden dex plot for a
                                     statistic.
    DEX ... EFFECTS PLOT           = Generates a dex effects plot for a
                                     statistic.
    DEX ... PARETO EFFECTS PLOT    = Generates a Pareto effects dex
                                     plot for a statistic.
    DEX ... ABSOLUTE EFFECTS PLOT  = Generates an absolute effects dex
                                     plot for a statistic.
    DEX ... PARE ABSO EFFECTS PLOT = Generates a Pareto absolute
                                     effects dex plot for a statistic.
    DEX PHD                        = Carry out a principal Hessian
                                     direction analysis of a Yates 
                                     design.

Reference:
    "Statistics for Experimenters", Box, Hunter, and Hunter.  John
    Wiley and Sons, 1978 (chapter 10, section 7).

Applications:
    Design of Experiments

Implementation Date:
    XX

Program:
    . THIS IS AN EXAMPLE OF A YATES ANALYSIS 
    . OF A 2**3 FULL FACTORIAL DESIGN.
    SKIP 25
    READ BOXSPRIN.DAT Y X1 X2 X3
    SKIP 0
    YATES Y
    .
    READ DPST1F.DAT TAG COEF
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LINE BLANK; CHARACTER CIRCLE
    CHARACTER HW 1.5 1.1; CHARACTER FILL ON
    DEX SCATTER PLOT Y X1 X2 X3
    NORMAL PROBABILITY PLOT COEF
    LET COEF2 = ABS(COEF)
    HALFNORMAL PROBABILITY PLOT COEF2
    END OF MULTIPLOT

Program 2:
    . THIS IS AN EXAMPLE OF A YATES ANALYSIS
    . OF A 2**(7-4) FRACTIONAL FACTORIAL DESIGN.
    DIMENSION 100 VARIABLES
    SKIP 25
    READ BOXBIKE2.DAT Y X1 X2 X3 X4 X5 X6 X7
    SKIP 0
    YATES Y
    .
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LINE BLANK; CHARACTER CIRCLE
    CHARACTER HW 1.5 1.1; CHARACTER FILL ON
    DEX SCATTER PLOT Y X1 TO X7
    READ DPST1F.DAT TAG COEF
    NORMAL PROBABILITY PLOT COEF
    LET COEF2 = ABS(COEF)
    HALFNORMAL PROBABILITY PLOT COEF2
    END OF MULTIPLOT
 
-----YATES CUBE PLOT-----------------------------------------------
 
YATES CUBE PLOT
 
Name:
    YATES CUBE PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a Yates cube plot.
 
Description:
    The Yates plot is used in the design of experiments for
    2-level full or fractional factorial designs.  It is used
    in the case where you have three independent factors, each
    with two levels.  The low level is coded as "-1" and the
    high level is coded as "+1".

    This command draws a cube with vertices corresponding
    to either -1 or +1 for each of the three factors.  At each
    vertex, the average of all the response values corresponding
    to that vertex is printed near that point.  For example,
    at the vertex point (-1,1,-1), the average value for the
    response variable for all points where X1=-1, X2=1, and X3=-1
    is printed.

Syntax:
    YATES CUBE PLOT <y> <x1> <x2> <x3>
                              <SUBSET/EXCEPT/FOR qualification>
    where <y>  is the response (= dependent) variable;
          <x1> is the first factor (= independent) variable;
          <x2> is the second factor (= independent) variable;
          <x3> is the third factor (= independent) variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    YATES CUBE PLOT Y X1 X2 X3
    YATES CUBE PLOT Y X1 X2 X3 SUBSET X4 = 4
 
Note:
    The appearance of the plot is controlled by the settings
    of the LINE and CHARACTER command.  In addition, you can
    use the attribute settings for LINE and CHARACTER (e.g.,
    color, thickness) to further control the appearance.

Note:
    The Yates cube plot can be extended to the 2**4 and
    2**5 cases by using it with the CONDITION PLOT
    command.  See the Program 2 and Program 3 examples below
    for details.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DEX MEAN PLOT      = Generate a dex mean plot.
    YATES              = Perform a Yates analysis.
    DEX CONTOUR PLOT   = Generates a dex contour plot.
    CONDITION PLOT     = Generates a condition plot.
 
Reference:
    "Statistics for Experimenters", Box, Hunter, and Hunter,
    John Wiley, 1978.
 
Applications:
    Design of Experiments
 
Implementation Date:
    2000/7
 
Program 1:
    SKIP 25
    READ SPLETT3.DAT Y X1 X2 X3
    TITLE YATES CUBE PLOT FOR SPLETT3.DAT
    TITLE DISPLACEMENT -8
    FRAME CORNER COORDINATES 0 0 100  100
    YATES CUBE PLOT Y X1 X2 X3

Program 2:
    skip 25
    read splett4.dat y x1 x2 x3 x4
    .
    frame corner coordinates 0 0 100 100
    multiplot corner coordinates 0 0 100 90
    multiplot scale factor 2
    set condition plot type yates cube
    condition plot y x1 x2 x3 x4
    .
    move 50 95
    just center
    text Yates Cube Plot for splett4.dat

Program 3:
    skip 25
    read boxreact.dat y x1 x2 x3 x4 x5
    .
    frame corner coordinates 0 0 100 100
    multiplot corner coordinates 0 0 100 100
    multiplot scale factor 2
    set condition plot type yates cube
    set condition plot conditioning variables 2
    condition plot y x1 x2 x3 x4 x5
    .
    move 50 3
    just center
    text Yates Cube Plot for boxreact.dat

-----YATES CUTOFF----------------------------------------------

YATES CUTOFF

Name:
    YATES CUTOFF

Type:
    Support Command

Purpose:
    Specify which factor estimates are printed by the YATES ANALYSIS
    command.

Description:
    The YATES ANALYSIS command  estimates the factor effects in 2-level
    full factorial and fractional factorial designs.  It yields factor
    estimates for all of the coefficients (main effects and all
    relevant interactions).  The primary output from the Yates analysis
    is a list which consists of 5 columns:
 
      1) A factor identifier (all from Yates order):
            1   = factor 1
            2   = factor 2
            3   = factor 3
            12  = factor 1 x factor 2 interaction
            13  = factor 1 x factor 3 interaction
            23  = factor 2 x factor 3 interaction
            123 = factor 1 x factor 2 x factor 3 interaction
            etc.
 
      2) Least squares estimated factor effects ordered from largest
         in magnitude (most significant) to smallest in magnitude
         (least significant).
 
      3) A t value (= e / sd(e)) where
            e is the estimated factor effect;
            sd(e) is the estimated standard deviation of e.
         Adjacent to this t value is an indication (* or **) as to
         whether the estimated effects are statistically significant
         at the 5% level (*) or 1% (**) level.
 
      4) The residual standard deviation that results from the model:
            response = constant + 1/2 (that single factor only)
         This is of interest but not that important.
 
      5) the (cumulative) residual standard deviation that results from
         the model:
            response = constant + 1/2 (all factors down to and
                       including the factor of interest).
 
         This column will consist of a monotonically decreasing set of
         residual standard deviations (indicating a better and better
         fit as the number of terms included in the model increases).
         The cumulative residual standard deviation at the top of the
         column is for the simplest model:
 
            response = constant + no factors
 
         The cumulative residual standard deviation  (identically 0) at
         the bottom of the column is for the most complicated model:
 
            response = constant + 1/2 (all factors and interactions)
 
    The YATES CUTOFF command is used to control which factor estimates
    are printed.  The criterion can be given in terms of the t-values
    (column 3 as described above), of the residual standard deviation 
    (column 4 as described above), or in terms of the absolute value of
    the coefficient (column 2 as described above).

Syntax 1:
    YATES COEF CUTOFF <value>
    where <value> is a number or parameter that specifies the cutoff
              value for the estimated factor coefficient.

    Only factor estimates that have a coefficient with an absolute 
    value less than or equal to <value> are printed.

Syntax 2:
    YATES T CUTOFF <value>
    where <value> is a number or parameter that specifies the cutoff
              value for the estimated factor t-value.

    Only factor estimates that have a t-value with an absolute value
    greater than or equal to <value> are printed.

Syntax 3:
    YATES RESSD CUTOFF <value>
    where <value> is a number or parameter that specifies the cutoff
              value for the estimated factor residual standard
              deviation.

    Only factor estimates that have a residual standard deviation less
    than or equal to <value> are printed.

Examples:
    YATES COEF CUTOFF 10
    YATES T CUTOFF 1.0
    YATES RESSD CUTOFF 0.5

Note:
    All 3 criterion (COEF/T/RESSD) can be specified for the same
    Yates analysis.  These criterion are tested independently of each
    other.

Default:
    All factor estimates are printed.

Synonyms:
    None

Related Commands:
    YATES ANALYSIS   = Carries out a Yates analysis.
    YATES OUTPUT     = Specify which sections of the Yates analysis to
                       print.

Applications:
    Design of Experiments

Implementation Date:
    89/12

Program:
    . THIS IS AN EXAMPLE OF A YATES ANALYSIS 
    . OF A 2**3 FULL FACTORIAL DESIGN.
    SKIP 25
    READ BOXSPRIN.DAT Y X1 X2 X3
    SKIP 0
    ECHO ON
    YATES Y
    YATES COEF CUTOFF 5
    YATES Y
    YATES COEF CUTOFF INFINITY
    YATES T CUTOFF 1.0
    YATES Y
    YATES T CUTOFF INFINITY
    YATES RESSD CUTOFF 0.5
    YATES Y
 
-----YATES OUTPUT----------------------------------------------

YATES OUTPUT

Name:
    YATES OUTPUT

Type:
    Support Command

Purpose:
    Specify which sections of the output from the YATES ANALYSIS
    command are printed.

Description:
    The YATES ANALYSIS command  estimates the factor effects in 2-level
    full factorial and fractional factorial designs.  It yields factor
    estimates for all of the coefficients (main effects and all
    relevant interactions).

    The output from the YATES ANALYSIS command is divided into 3
    sections:
      1) Various summary statistics are printed;
      2) The estimates of the factor effects are printed in standard
         order;
      3) The estimates of the factor effects are listed in order from
         most statistically significant to least statistically
         significant.
    As of the 92/7 version, the second section is no longer printed.
    This is true even if the analyst specifically specifies that it 
    should be printed with the YATES OUTPUT command.

Syntax:
    YATES OUTPUT <1/2/3/12/13/23/123>
    where any of the above choices containing "1" will print section
            1, any containing "2" will print section 2, and any 
            containing "3" will print section 3.

Examples:
    YATES OUTPUT 1
    YATES OUTPUT 3
    YATES OUTPUT 13

Note:
    Since section 2 output is no longer printed, specifying YATES
    OUTPUT 2 is equivalent to suppressing the output from the YATES
    ANALYSIS command (a few summary lines are still printed).

Default:
    All factor estimates are printed.

Synonyms:
    None

Related Commands:
    YATES ANALYSIS   = Carries out a Yates analysis.
    YATES CUTOFF     = Specify which factor effects are printed from
                       the YATES ANALYSIS command.

Applications:
    Design of Experiments

Implementation Date:
    89/12

Program:
    . THIS IS AN EXAMPLE OF A YATES ANALYSIS 
    . OF A 2**3 FULL FACTORIAL DESIGN.
    SKIP 25
    READ BOXSPRIN.DAT Y X1 X2 X3
    SKIP 0
    YATES Y
    YATES OUTPUT 1
    YATES Y
    YATES OUTPUT 3
    YATES Y
 
-----YFRAME (LET)---------------------------------------------------
 
YFRAME
 
Name:
    YFRAME (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Determine the frame limits for the y-axis without generating a plot.
 
Description:
    In some cases, we may want to determine the frame limits that would
    be computed for a given data set without actually generating a plot.
    For example, if we are plotting subsets of a data set we may want
    the limits based on the full data set.

    One minor complication occurs if we have defined a tic mark offset
    (i.e., the distance from the first or last major tic mark to the
    end of the frame line.  You can use the following command to specify
    whether you want the tic mark offset included in the returned limits

        SET FRAME LIMIT OFFSET <OFF/ON>

    If you specify OFF, the tic mark offset will not be included.  If
    you specify ON, the tic mark offset will be included.

    Note that this command does not actually set the frame limits.  You
    can use the values returned by this command in a subsequent
    YLIMITS command to set the limits.

    This command returns the limits for the y-axis.  The XFRAME command
    can be used to return the limits for the x-axis.

Syntax:
    LET <ymin> <ymax> = YFRAME <y>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <ymin> is a parameter that stores the minimum value for the
              y-axis frame;
          <ymax> is a parameter that stores the maximum value for the
              y-axis frame;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Examples:
    LET YMIN YMAX = YFRAME Y
    LET YMIN YMAX = YFRAME Y  SUBSET Y > 0
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    XFRAME       = Return the frame limits for the x-axis.
    LIMITS       = Define limits for the x and y axes.
 
Applications:
    Plotting
 
Implementation Date:
    2016/02
 
Program 1:
    skip 25
    read berger1.dat y x
    .
    set frame limits offset off
    let ymin1 ymax1 = yframe y
    let xmin1 xmax1 = xframe x
    .
    set frame limits offset on
    tic mark offset units screen
    tic mark offset 3 3
    let ymin2 ymax2 = yframe y
    let xmin2 xmax2 = xframe x
 
Program 2:
    . Purpose:  Demonstrate Interaction Effects Matrix plot using
    .           scatter plot matrix commnad.
    .
    . Step 1:   Read the data
    .
    skip 25
    read boxreact.dat y x1 to x5
    let n = size y
    let k = 5
    let string stat = Mean
    . variable label X1 X1 (Feed Rate)
    . variable label X2 X2 (Catalyst)
    . variable label X3 X3 (Agitation Rate)
    . variable label X4 X4 (Temperature)
    . variable label X5 X5 (Concentration)
    variable label X1 X1
    variable label X2 X2
    variable label X3 X3
    variable label X4 X4
    variable label X5 X5
    .
    . Step 2:   Define plot control settings
    .
    multiplot corner coordinates 5 5 95 95
    multiplot scale factor 3
    tic offset units screen
    tic offset 5 5
    .
    xlimits -2  2
    major x1tic mark number 5
    minor x1tic mark number 0
    x1tic mark label format alpha
    x1tic mark label content sp() -1 sp() 1 sp()
    x1tic marks off
    x1tic mark labels off
    x1tic mark offset 0.5 0.5
    x1label displacement 95
    x2label displacement 12
    x2label justification left
    x2label offset -20
    .
    probe cpumax
    let cpumax = probeval
    probe cpumin
    let cpumin = probeval
    let ymin = cpumax
    let ymax = cpumin
    loop for k = 1 1 k
        let ytemp = cross tabulate mean y x^k
        let ymint = minimum ytemp
        let ymaxt = maximum ytemp
        let ymin = min(ymint,ymin)
        let ymax = max(ymaxt,ymax)
    end of loop
    delete ytemp
    .
    set frame limits offset off
    let ytemp = data ymin ymax
    let ymin1 ymax1 = yframe ytemp
    set frame limits offset on
    let ymin2 ymax2 = yframe ytemp
    let xtemp = data -2 2
    let xmin2 xmax2 = xframe xtemp
    delete xtempl ytemp1
    ylimits ymin1 ymax1
    .
    char circle blank
    char hw 1 0.75
    char fill on
    line solid dashed
    .
    . Step 3:   Define options for scatter plot matrix
    .
    set scatter plot matrix type dex ^stat interaction
    set scatter plot matrix labels xon
    set scatter plot matrix y axis left
    set scatter plot matrix x axis bottom
    set scatter plot matrix lower diagonal off
    set scatter plot matrix x2label filliben
    set scatter plot matrix shaded diagonal on
    subregion on
    subregion xlimits xmin2 xmax2
    subregion ylimits ymin2 ymax2
    region fill on
    region color g80
    .
    . Step 4:   Generate the plot
    .
    dex mean interaction effects plot y x1 x2 x3 x4 x5
    .
    . Step 5:   Add overall title, vertical axis title
    .
    just center
    move 50 97
    text Chemical Reactor Efficiency (BHH) 2**5 (K=5, N=32)
    .
    direction vertical
    move 3 50
    text Average Y
    direction horizontal
 
-----YOUDEN PLOT--------------------------------------
 
YOUDEN PLOT
 
Name:
    YOUDEN PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a Youden plot.
 
Description:
    A Youden plot is a graphical data analysis technique for carrying
    out an interlab comparison where each lab has made 2 runs on the
    same product or 1 run on 2 different products.  The Youden plot
    answers the question "Are the labs in the study all behaving as if
    from the same population?".  It consists of:
       Vertical axis   = data from run 1;
       Horizontal axis = data from run 2.
    The various labs in the study are encoded by the plot character
    within the plot.  In the ideal case (all labs from same
    population), the Youden plot will have a structureless "random
    shotgun pattern".  Any structured deviation from this "shotgun
    pattern" suggests one or another lab is "different from the rest".
    The advantage of the Youden plot is 2-fold:
       1) Between-lab differences are easy to detect (shifts along the
          diagonal for a given lab);
       2) Within-lab differences are easy to detect (displacement
          drawn with a fixed size and with the base).
    Typically the Youden plot has no connecting lines between the data
    points and it has the lab identification imbedded in the plot
    characters.   For 8 labs (say), this is achievable via
       LINES BLANK ALL
       CHARACTERS 1 2 3 4 5 6 7 8
    or
       LINES BLANK ALL
       CHARACTERS B R S A T G B X
 
Syntax:
    YOUDEN PLOT <y1> <y2> <lab>    <SUBSET/EXCEPT/FOR qualification>
    where <y1>  is the first  response variable;
          <y2>  is the second response variable;
          <lab> is the coded laboratory variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    YOUDEN PLOT Y1 Y2 LAB
    YOUDEN PLOT Y1 Y2 LAB SUBSET MONTH 4
    YOUDEN PLOT Y1 Y2 LAB SUBSET MATERIAL 1 TO 5
 
Default:
    None
 
Synonyms:
    PLOT Y1 Y2 TAG is a synonym for YOUDEN PLOT Y1 Y2 TAG.
 
Related Commands:
    CHARACTERS     = Sets the type for plot characters.
    LINES          = Sets the type for plot lines.
    BIHISTOGRAM    = Generates a bihistogram.
    QUAN-QUAN PLOT = Generates a quantile-quantile plot
    PLOT           = Generates a data or function plot.
    MULTIPLOT      = Allows multiple plots per page.
    T-TEST         = Carries out a 2 sample t test.
    ANOVA          = Carries out an ANOVA.
 
Reference:
    "Graphical Methods for Data Analysis", Chambers, Cleveland,
    Kleiner, and Tukey.  Wadsworth, 1983.
 
Applications:
     Interlaboratory Analysis
 
Implementation Date:
    88/9
 
Program:
    LET Y1 = DATA 44 39 13 42 45 46 38
    LET Y2 = DATA 45 41 39 41 23 45 33
    LET LAB = DATA 1 2 3 4 5 6 7
    CHARACTERS 1 2 3 4 5 6 7
    LINES BLANK ALL
    TITLE AUTOMATIC
    YOUDEN PLOT Y1 Y2 LAB
 
-----YPLOT--------------------------------------------------

YPLOT

Name:
    YPLOT

Type:
    Keyword

Purpose:
    An internal variable into which the vertical coordinates of the
    most recent plot are stored.

Description:
    Whenever Dataplot generates a plot, it saves the horizontal and
    vertical coordinates of each point plotted in the internal
    variables XPLOT and YPLOT.  For 3d plots, it stores the second
    horizontal axis coordinates in the variable X2PLOT. The coordinates
    are saved in the units of the data, not in the Dataplot 0 to 100
    coordinates.  These variables can be used in any way that a user
    created variable can.

Syntax:
    None

Examples:
    BOOTSTRAP PLOT Y
    LET Y2 = YPLOT
    HISTOGRAM Y2

    . Generate a frequency table
    HISTOGRAM Y
    SET WRITE DECIMALS 3
    PRINT XPLOT YPLOT

    . Generate a table of medians
    MEDIAN PLOT Y GROUP
    SET WRITE DECIMALS 3
    PRINT XPLOT YPLOT

Default:
    None

Synonyms:
    None

Related Commands:
    TAGPLOT   = An internal variable that contains the trace 
                identifier of the points from the most recent plot.
    XPLOT     = An internal variable that contains the horizontal
                coordinates from the most recent plot.
    X2PLOT    = An internal variable that contains the coordinates
                from the second horizontal axis from the most recent 
                3d plot.
    PLOT      = Generate a data of function plot.

Applications:
    XX

Implementation Date:
    XX

Program:
    SKIP 25
    READ LEW.DAT DEFLECT
    .
    TITLE AUTOMATIC
    DEVICE 2 OFF
    PERIODOGRAM DEFLECT
    DEVICE 2 ON
    .
    LET A = VARIANCE DEFLECT
    LET TEMP = YPLOT/A
    LET X = XPLOT
    TITLE SPECTRAL DENSITY PLOT
    PLOT TEMP X
 
-----YULCDF (LET)--------------------------------
 
YULCDF
 
Name:
    YULCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Yule cumulative distribution function.
 
Description:
    The Yule distribution has the following probability mass
    function:

       p(x,p) = p*p!*x!/(x+p+1)!       p > 0, x = 0, 1, 2, ...
              = p*GAMMA(p+1)*GAMMA(x+1)/GAMMA(x+p+2)

    with p denoting the shape parameter and GAMMA denoting the
    gamma function (HELP GAMMA for details).

    The cumulative distribution function is the sum from
    0 to x.

    Dataplot computes the Yule probability density function
    using the log gamma function.  The Yule distribution has
    increasingly long tails as p goes to zero.  Currently,
    Dataplot limits the Yule cdf function to the case where
    p >= 0.1.
   
Syntax:
    LET <y> = YULCDF(<x>,<p>)     <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative integer number, parameter, or
               variable;
          <p> is a positive number, parameter, or variable that
               specifies the shape parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed Yule cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = YULCDF(3,1.5)
    LET A = YULCDF(X,P)
    PLOT YULCDF(X,2) FOR X = 0 1 50

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Note:
    The Yule is a special case of the Waring distribution.
    Specifically,

       YULCDF(X,P) = WARPDF(X,P-1,1)

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    YULPDF = Compute the Yule probability mass function.
    YULPPF = Compute the Yule percent point function.
    WARPDF = Compute the Waring probability density function.
    BBNPDF = Compute the beta-binomial probability density function.
    GEOPDF = Compute the geometric probability density function.
    NBPDF  = Compute the negative binomial probability density
             function.
    HYPPDF = Compute the hypergeometric probability density function.
 
Reference:
    "Discrete Univariate Distributions", Second Edition, Johnson,
    Kotz, and Kemp, John Wiley & Sons, 1994 (pp. 274-279).

Applications:
    Distributional Modeling
 
Implementation Date:
    2004/4
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    XTIC OFFSET 0.5 0.5
    LINE BLANK
    SPIKE ON
    TITLE AUTOMATIC
    X1LABEL X
    Y1LABEL PROBABILITY
    TITLE SIZE 3
    PLOT YULCDF(X,0.5) FOR X = 0 1 50
    PLOT YULCDF(X,1) FOR X = 0 1 50
    PLOT YULCDF(X,1.5) FOR X = 0 1 50
    PLOT YULCDF(X,2) FOR X = 0 1 50
    END OF MULTIPLOT

-----YULPDF (LET)--------------------------------
 
YULPDF
 
Name:
    YULPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Yule probability mass function.
 
Description:
    The Yule distribution has the following probability mass
    function:

       p(x,p) = p*p!*x!/(x+p+1)!       p > 0, x = 0, 1, 2, ...
              = p*GAMMA(p+1)*GAMMA(x+1)/GAMMA(x+p+2)

    with p denoting the shape parameter and GAMMA denoting the
    gamma function (HELP GAMMA for details).

    The probability mass function of the Yule disrtribution
    can also be given as

        p(x,p) = p*B(x+1,p+1)       p > 0, x = 0, 1, 2, ...

    with B denoting the beta function.

    Some sources shift the distribution to start at x = 1.
    In this case, the formulas for the probability mass
    function are:

       p(x,p) = p*p!*(x-1)!/(x+p)!       p > 0, x = 1, 2, ...
              = p*GAMMA(p+1)*GAMMA(x)/GAMMA(x+p+1)

    and

       p(x,p) = p*B(x,p+1)       p > 0, x = 1, 2, ...

    The Yule distribution can be derived as a continuous mixture
    of geometric distributions.
    Dataplot computes the Yule probability mass function
    using the log gamma function.  The Yule distribution has
    increasingly long tails as p goes to zero.  Currently,
    Dataplot limits the Yule pdf function to the case where
    p >= 0.1.
   
Syntax:
    LET <y> = YULPDF(<x>,<p>)     <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative integer number, parameter, or
               variable;
          <p> is a positive number, parameter, or variable that
               specifies the shape parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed Yule pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = YULPDF(3,1.5)
    LET A = YULPDF(X,P)
    PLOT YULPDF(X,2) FOR X = 0 1 50

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Note:
    The Yule is a special case of the Waring distribution.
    Specifically,

       YULPDF(X,P) = WARPDF(X,P-1,1)

Note:
    For a number of commands utilizing the Yule distribution,
    it is convenient to bin the data.  There are two basic ways
    of binning the data.

      1) For some commands (histograms, maximum likelihood
         estimation), bins with equal size widths are
         required.  This can be accomplished with the
         following commands:

            LET AMIN = MINIMUM Y
            LET AMAX = MAXIMUM Y
            LET AMIN2 = AMIN - 0.5
            LET AMAX2 = AMAX + 0.5
            CLASS MINIMUM AMIN2
            CLASS MAXIMUM AMAX2
            CLASS WIDTH 1
            LET Y2 X2 = BINNED

      2) For some commands, unequal width bins may be
         helpful.  In particular, for the chi-square goodness
         of fit, it is typically recommended that the minimum
         class frequency be at least 5.  In this case, it may
         be helpful to combine small frequencies in the tails.
         Unequal class width bins can be created with the
         commands

            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = INTEGER FREQUENCY TABLE Y

         If you already have equal width bins data, you can
         use the commands
         
            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = COMBINE FREQUENCY TABLE Y2 X2

         The MINSIZE parameter defines the minimum class
         frequency.  The default value is 5.

Note:
    You can generate Yule random numbers, probability plots,
    and chi-square goodness of fit tests with the following
    commands:

       LET P = <value>
       LET Y = YULE RANDOM NUMBERS FOR I = 1 1 N

       YULE PROBABILITY PLOT Y
       YULE PROBABILITY PLOT Y2 X2
       YULE PROBABILITY PLOT Y3 XLOW XHIGH

       YULE CHI-SQUARE GOODNESS OF FIT Y
       YULE CHI-SQUARE GOODNESS OF FIT Y2 X2
       YULE CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    To obtain the method of moment estimates, the mean and
    zero frequency estimates, and the maximum likelihood
    estimates of p, enter the command

        YULE MAXIMUM LIKELIHOOD Y

    These estimates are computed as follows.

        1) The method of moments:

              phat = (xbar + 1)/xbar

           with xbar denoting the sample mean.  Note that
           this method will never generate an estimate less
           than 1 (the mean is undefined for P < 1 for the
           Yule distribution).

        2) The method of zero frequency and sample mean:

              phat = (1/(1 - f1/N)/((1/(1-f1/N) - (1/xbar) - 1)

           with N and f1 denoting the sample size and the
           observed first frequency.

           This method is only useful for values of the shape
           parameter > 1.

        3) The method of maximum likelihood:

           The maximum likelihood estimate is the solution
           of the following equation:

              N/(C*(C-1)) - SUM[k=2 to lambda][V(k)/(C+k-1)] = 0

           with N denoting the sample size, V(k) the cumulative
           frequency from k upwards, and lamda the maximum
           frequency.
           
           Then the parameter P of the Yule distribution is
           P = C - 1.

    You can generate an estimate of p based on the maximum ppcc
    value or the minimum chi-square goodness of fit with the
    commands

        LET P1 = <value>
        LET P2 = <value>
        LET BETA1  = <value>
        LET BETA2  = <value>
        YULE KS PLOT Y
        YULE KS PLOT Y2 X2
        YULE KS PLOT Y3 XLOW XHIGH
        YULE PPCC PLOT Y
        YULE PPCC PLOT Y2 X2
        YULE PPCC PLOT Y3 XLOW XHIGH

    The default values of theta1 and theta2 are 0.05 and 0.95,
    respectively.  The default values for p1 and p2 are
    0.3 and 5, respectively.

    Due to the discrete nature of the percent point function
    for discrete distributions, the ppcc plot will not be smooth.
    For that reason, if there is sufficient sample size the
    KS PLOT (i.e., the minimum chi-square value) is typically
    preferred.  However, it may sometimes be useful to perform
    one iteration of the PPCC PLOT to obtain a rough idea of an
    appropriate neighborhood for the shape parameters since the
    minimum chi-square statistic can generate extremely large
    values for non-optimal values of the shape parameters.
    Also, since the data is integer values, one of the binned
    forms is preferred for these commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    YULCDF = Compute the Yule cumulative distribution function.
    YULPPF = Compute the Yule percent point function.
    WARPDF = Compute the Waring probability mass function.
    BGEPDF = Compute the beta-geometric probability mass function.
    BBNPDF = Compute the beta-binomial probability mass function.
    GEOPDF = Compute the geometric probability mass function.
    NBPDF  = Compute the negative binomial probability mass
             function.
    ZETPDF = Compute the zeta probability mass function.
    DLGPDF = Compute the logarithmic series probability mass
             function.
    GLSPDF = Compute the generalized logarithmic series
             probability mass function.
    HYPPDF = Compute the hypergeometric probability mass function.
 
Reference:
    "Discrete Univariate Distributions", Second Edition, Johnson,
    Kotz, and Kemp, John Wiley & Sons, 1994 (pp. 274-279).

    "Mathematcs in Medical and Biological Statistics", J. O. Irwin,
    Journal of the Royal Statistical Society, A, 1963, pp. 1-44.

Applications:
    Distributional Modeling
 
Implementation Date:
    2004/4
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    XTIC OFFSET 0.5 0.5
    LINE BLANK
    SPIKE ON
    TITLE AUTOMATIC
    X1LABEL X
    Y1LABEL PROBABILITY
    TITLE SIZE 3
    PLOT YULPDF(X,0.5) FOR X = 0 1 50
    PLOT YULPDF(X,1) FOR X = 0 1 50
    PLOT YULPDF(X,1.5) FOR X = 0 1 50
    PLOT YULPDF(X,2) FOR X = 0 1 50
    END OF MULTIPLOT

-----YULPPF (LET)--------------------------------
 
YULPPF
 
Name:
    YULPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Yule percent point function.
 
Description:
    The Yule distribution has the following probability mass
    function:

       p(x,p) = p*p!*x!/(x+p+1)!       p > 0, x = 0, 1, 2, ...
              = p*GAMMA(p+1)*GAMMA(x+1)/GAMMA(x+p+2)

    with p denoting the shape parameter and GAMMA denoting the
    gamma function (HELP GAMMA for details).

    The cumulative distribution function is the sum from
    0 to x.  The percent point function is the inverse of the
    cumulative distribution function.  That is, given the
    probability, the appropriate value of x is returned.

    Dataplot computes the Yule probability density function
    using the log gamma function.  The Yule distribution has
    increasingly long tails as p goes to zero.  Currently,
    Dataplot limits the Yule cdf function to the case where
    p >= 0.1.
   
Syntax:
    LET <y> = YULPPF(<x>,<p>)     <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative integer number, parameter, or
               variable in the range (0,1];
          <p> is a positive number, parameter, or variable that
               specifies the shape parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed Yule cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = YULPPF(0.95,1.5)
    LET A = YULPPF(X,P)
    PLOT YULPPF(X,2) FOR X = 0 0.01 0.95

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Note:
    The Yule is a special case of the Waring distribution.
    Specifically,

       YULPPF(X,P) = WARPDF(X,P-1,1)

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    YULCDF = Compute the Yule cumulative distribution function.
    YULPDF = Compute the Yule probability mass function.
    WARPDF = Compute the Waring probability density function.
    BBNPDF = Compute the beta-binomial probability density function.
    GEOPDF = Compute the geometric probability density function.
    NBPDF  = Compute the negative binomial probability density
             function.
    HYPPDF = Compute the hypergeometric probability density function.
 
Reference:
    "Discrete Univariate Distributions", Second Edition, Johnson,
    Kotz, and Kemp, John Wiley & Sons, 1994 (pp. 274-279).

Applications:
    Distributional Modeling
 
Implementation Date:
    2004/4
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    XTIC OFFSET 0.5 0.5
    LINE BLANK
    SPIKE ON
    TITLE AUTOMATIC
    X1LABEL X
    Y1LABEL PROBABILITY
    TITLE SIZE 3
    PLOT YULPPF(P,0.5) FOR P = 0  0.01  0.95
    PLOT YULPPF(P,1) FOR P = 0  0.01  0.99
    PLOT YULPPF(P,1.5) FOR P = 0  0.01 0.99
    PLOT YULPPF(P,2) FOR P = 0  0.01  0.99
    END OF MULTIPLOT

---------------------------------------------------------
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 











































































-------------------------  *Z*  ZZZZZ--------------------
 
-----ZETA (LET)--------------------------------
 
ZETA
 
Name:
    ZETA (LET)
 
Type:
    Library Function
 
Purpose:
    Compute a function of the Riemann Zeta function.
 
Description:
    The Riemann Zeta function is defined as:

        ZETA(z) = SUM(1/(K**z)    

    where the summation is for k = 1 to infinity and the
    real component of z is greater than 1.

    For better numerical stability, Dataplot actually
    computes ZETA(x) - 1 for real arguments (x > 1).

    Dataplot uses a Fortran translation of a C routine
    given in "Atlas For Computing Mathematical Functions"
    (see the Reference section below).
 
Syntax:
    LET <y> = ZETA(<x>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, variable, or parameter (> 1);
          <y> is a variable or a parameter (depending on what <x> 
               is) where the computed zeta - 1 values are
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ZETA(2)
    LET A = ZETA(X) 
    LET X2 = ZETA(X) FOR X = 0.1 0.1 3.0
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ETA        = Compute the eta function.
    CATLAN     = Compute the Catlan Beta function.
    LAMBDA     = Compute the lambda function.
 
Reference:
    "Atlas For Computing Mathematical Functions",
    William J. Thompson, John wiley & Sons, 1997.
 
    "AMS 55: Handbook of Mathematical Functions", Abramowitz and
    Stegun, Eds., Washington, DC, National Bureau of Standards,
    1964.

Applications:
    Special Functions
 
Implementation Date:
    1997/12
 
Program:
    TITLE AUTOMATIC
    PLOT ZETA(X) FOR X = 1.01 0.01 5
 
-----ZETA-------------------------------------------------------

ZETA PLOTTER

Name:
    ZETA
 
Type:
    Output Device Command
 
Purpose:
    Direct graphical output to a ZETA device.
 
Description:
    There are a large number of ZETA devices (although most are
    penplotters or film recorders) models.  ZETA typically supports
    their devices through a software library called the Calcomp
    library.  Dataplot supports the various ZETA devices through calls
    to this library.  This library contains a core set of modules that
    should be common to all ZETA devices.  In addition, it may contain
    a few routines that are specific to that device.  Dataplot is
    restricted to using the following routines in this library:
        PLOTS
        PLOT
        NEWPEN
        SYMBOL
        DASHDF

Syntax 1:
    ZETA
    This form designates device 1 as a ZETA device.  Although device
    1 is normally reserved for the terminal screen, in the ZETA case
    the graphics output is typically sent to a file.
 
Syntax 2:
    DEVICE <1/2/3> ZETA
    This form designates one of Dataplot's 3 devices (it will typically
    be device 2) to be a ZETA device.
 
Examples:
    ZETA
    DEVICE 2 ZETA
    DEVICE 3 ZETA
 
Note:
    ZETA devices support a modified version of the standard Calcomp
    library routines.  In order for this command to be operational,
    the local Dataplot installer must link the local copy of the ZETA
    library with Dataplot.  Contact your local site installer if this
    is not the case.
 
    The ZETA differs from the standard Calcomp library only in the
    routine for drawing dashed lines.  The Calcomp uses the DASHS
    routine while the ZETA uses the DASDF routine.  IF your device
    is emulating the Calcomp library, check to see what it used for
    its dashed lines and select the ZETA or CALCOMP device in 
    Dataplot accordingly.

Note:
    Local sites may have code to select different papers, pen types,
    colors, and other similar things.  Contact the local site
    installer if more information is needed about this.
 
Note:
    In order to accommodate different models, two SET commands are
    available.
      1) SET ZETA COLORS <number> identifies the number of
          colors available on the local ZETA device.
      2) SET ZETA WIDTH <width in Dataplot units> identifies the
         line width to be used when drawing thick lines and doing
         fills of solid regions.
 
Default:
    Off
 
Synonyms:
    None
 
DEVICE NOTES
    1) HARDWARE TEXT - ZETA hardware characters can be scaled to any
       size.  Vertical strings are rotated 90 degrees.  The appearance
       of hardware characters varies depending on the particular model.
    2) COLOR - The number of colors varies depending on the particular
       model you are using.  By default, Dataplot assumes 8 pen slots.
       If you have less (or more) than 8, use the command SET ZETA
       COLORS to specify the number you have.  For more than 8 slots,
       use the ZETA PEN MAP command for slot numbers greater than 8.
       This command can also be used to override the default color to
       slot number mapping.
    3) HARDWARE FILL - All area fills in software.
    4) DASH PATTERNS - Unique dash patterns are available for DASH,
       DASH2, DASH3, DASH4, DASH5, and DOT.
    5) LINE WIDTH - The ZETA device uses a default line width of
       0.1 (in Dataplot 0 to 100 coordinate units).  If this is not a
       good value, use the SET ZETA WIDTH command to specify a
       better value.  The best value may vary with the types of pens
       used as well.
    6) GRAPHICS INPUT - The CROSS-HAIR command is ignored for this
       device.
 
Related Commands:
    CALCOMP           = Direct graphical output to a Calcomp device.
    POSTSCRIPT        = Direct graphical output to a Postscript device.
    TEKTRONIX         = Direct graphical output to a Tektronix device.
    DEVICE            = Specify certain actions for the graphics
                            output.
    ZETA PEN MAP      = Specify the pen slot to color mapping for the
                        ZETA device.
    SHOW ZETA COLORS  = Show the available colors on the ZETA device.
    SET ZETA COLORS   = Specify the number of colors available on the
                        ZETA device.
    SET ZETA WIDTH    = Specify the width of a single line on the ZETA
                        device.
 
Applications:
    XX
 
Implementation Date:
    89/2
 
Program:
    XX
 
-----ZETCDF (LET)--------------------------------
 
ZETCDF
 
Name:
    ZETCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Zeta cumulative distribution function.
 
Description:
    The zeta distribution has the following probability mass
    function:

        p(x;alpha) = (1/x**alpha)/zeta(alpha)
                     x = 1, 2, ...; alpha > 1

    with alpha denoting the shape parameter and zeta denoting
    the Riemann zeta function

        zeta(alpha) = SUM[i=t to infinity][1/x**alpha]

    Some sources parameterize this distribution with
    s = alpha - 1 (so that the distribution is defined for
    s > 0).

    The cumulative distribution is computed by summing the
    probability mass function.

Syntax:
    LET <y> = ZETCDF(<x>,<alpha>)   <SUBSET/EXCEPT/FOR qualification>
    where <x> is a positive integer variable, number, or
               parameter;
          <alpha> is a number or parameter greater than 1 that
               specifies the shape parameter;
          <y> is a variable or a parameter where the computed
               Zeta cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ZETCDF(3,1.5)
    LET Y = ZETCDF(X1,2.3)
    PLOT ZETCDF(X,2.3) FOR X = 1  1  50
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ZETPDF                   = Compute the Zeta probability mass
                               distribution function.
    ZETPPF                   = Compute the Zeta
                               percent point function.
    YULPDF                   = Compute the Yule probability mass
                               function.
    BGEPDF                   = Compute the beta-geometric (Waring)
                               probability mass function.
    BTAPDF                   = Compute the Borel-Tanner probability
                               mass function.
    DLGPDF                   = Compute the logarithmic series
                               probability mass function.
    INTEGER FREQUENCY TABLE  = Generate a frequency table at
                               integer values with unequal bins.
    COMBINE FREQUENCY TABLE  = Convert an equal width frequency
                               table to an unequal width frequency
                               table.
    KS PLOT                  = Generate a minimum chi-square plot.
    MAXIMUM LIKELIHOOD       = Perform maximum likelihood
                               estimation for a distribution.

Reference:
    Johnson, Kotz, and Kemp (1992),  "Univariate Discrete
    Distributions", Second Edition, Wiley, pp. 465-471.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, New York.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/5
 
Program:
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    case asis
    label case asis
    title case asis
    tic offset units screen
    tic offset 3 3
    title displacement 2
    y1label displacement 17
    x1label displacement 12
    .
    y1label Probability
    ylimits 0 1
    major ytic mark number 6
    minor ytic mark number 3
    x1label X
    line blank
    spike on
    .
    multiplot 2 2
    .
    let alpha = 1.5
    title Alpha = ^alpha
    plot zetcdf(x,alpha) for x = 1 1 20
    .
    let alpha = 2.0
    title Alpha = ^alpha
    plot zetcdf(x,alpha) for x = 1 1 20
    .
    let alpha = 2.5
    title Alpha = ^alpha
    plot zetcdf(x,alpha) for x = 1 1 20
    .
    let alpha = 3.0
    title Alpha = ^alpha
    plot zetcdf(x,alpha) for x = 1 1 20
    .
    end of multiplot
    .
    justification center
    move 50 97
    text Zeta Cumulative Distribution Functions
 
-----ZETPDF (LET)--------------------------------
 
ZETPDF
 
Name:
    ZETPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Zeta probability mass function.
 
Description:
    The zeta distribution has the following probability mass
    function:

        p(x;alpha) = (1/x**alpha)/zeta(alpha)
                     x = 1, 2, ...; alpha > 1

    with alpha denoting the shape parameter and zeta denoting
    the Riemann zeta function

        zeta(alpha) = SUM[i=t to infinity][1/x**alpha]

    Some sources parameterize this distribution with
    s = alpha - 1 (so that the distribution is defined for
    s > 0).

    The zeta distribution becomes more long-tailed as the
    value of alpha gets closer to 1.

    The mean and variance of the Zeta distribution are

        mean     = zeta(alpha-1)/zeta(alpha)            alpha > 2
        variance = zeta(alpha-2)/zeta(alpha) -
                   (zeta(alpha-1))**2/(zeta(alpha))**2  alpha > 3
        
    The development of the zeta distribution was motivated by
    Zipf's law (from the linguistics community).  Zipf's law
    states that the frequency of occurence of any word is
    approximately inversely proportional to its rank in the
    frequency table.  When Zipf's law is applicable, plotting
    the frequency table on a log-log scale (i.e., log(frequency)
    versus log(rank order)) will typically show a linear pattern.
    Note that Zipf's law is an empirical (as oppossed to a
    theoretical) law.  However, Zipf's law has served as a
    useful model for many different kinds of phenomena.

Syntax:
    LET <y> = ZETPDF(<x>,<alpha>)   <SUBSET/EXCEPT/FOR qualification>
    where <x> is a positive integer variable, number, or
               parameter;
          <alpha> is a number or parameter greater than 1 that
               specifies the shape parameter;
          <y> is a variable or a parameter where the computed
               Zeta pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ZETPDF(3,1.5)
    LET Y = ZETPDF(X1,2.3)
    PLOT ZETPDF(X,2.3) FOR X = 1  1  50
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Note:
    The zeta distribution is the limiting case of the Zipf
    distribution.  Note that zeta distribution and Zipf
    distribution tend to be used interchangeably in the
    literature.  The primary distinction is that the Zipf
    distribution is bounded in the upper tail while the zeta
    distribution is unbounded in the upper tail.  When the
    upper bound for the Zipf distribution is large, the zeta
    distribution is typically used as an approximation. 

Note:
    For a number of commands utilizing the zeta distribution,
    it is convenient to bin the data.  There are two basic ways
    of binning the data.

      1) For some commands (histograms, maximum likelihood
         estimation), bins with equal size widths are
         required.  This can be accomplished with the
         following commands:

            LET AMIN = MINIMUM Y
            LET AMAX = MAXIMUM Y
            LET AMIN2 = AMIN - 0.5
            LET AMAX2 = AMAX + 0.5
            CLASS MINIMUM AMIN2
            CLASS MAXIMUM AMAX2
            CLASS WIDTH 1
            LET Y2 X2 = BINNED

      2) For some commands, unequal width bins may be
         helpful.  In particular, for the chi-square goodness
         of fit, it is typically recommended that the minimum
         class frequency be at least 5.  In this case, it may
         be helpful to combine small frequencies in the tails.
         Unequal class width bins can be created with the
         commands

            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = INTEGER FREQUENCY TABLE Y

         If you already have equal width bins data, you can
         use the commands
         
            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = COMBINE FREQUENCY TABLE Y2 X2

         The MINSIZE parameter defines the minimum class
         frequency.  The default value is 5.

Note:
    You can generate Zeta random numbers and probability
    plots with the following commands:

       LET N = VALUE
       LET ALPHA = <value>
       LET Y = ZETA RANDOM NUMBERS FOR I = 1 1 N

       ZETA PROBABILITY PLOT Y
       ZETA PROBABILITY PLOT Y2 X2
       ZETA PROBABILITY PLOT Y3 XLOW XHIGH

    To obtain the maximum likelihood estimate of alpha, enter
    the command

        ZETA MAXIMUM LIKELIHOOD Y
        ZETA MAXIMUM LIKELIHOOD Y2 X2

    The ZETA MAXIMUM LIKELIHOOD command will actually generate
    the following three numerical estimates of alpha.

        1) The first estimate is based on the ratio of the
           frequencies of the first group (F1) and the second
           group (F2).  The resulting estimate is

              ALPHAHAT = (LN(F1/F2)/LN(2))

           If either F1 or F2 is zero, this estimate is not
           computed.  This estimate is used as the starting
           value for the maximum likelihood method.

        2) The method of moment estimate is computed by solving
           the following equation

              XBAR - ZETA(ALPHAHAT-1)/ZETA(ALPHAHAT) = 0

           with XBAR denoting the sample mean.  Note that
           this method will not return an estimate <= 2
           (the mean of the zeta distribution is only defined
           for alpha > 2).  If an error message is returned
           stating that method of moment estimate is unable
           to find a bracketing interval, this is an indication
           that the value of alpha is <= 2.

        3) The maximum likelihood estimate is computed by solving
           the following equation

              SUM[i=1 to N][LN(X(i)] +
              ZETA'(ALPHAHAT)/ZETA(ALPHAHAT) = 0

    You can also generate an estimate of alpha based on the
    maximum ppcc value or the minimum chi-square goodness of fit
    with the commands

        LET ALPHA1 = <value>
        LET ALPHA2 = <value>
        ZETA KS PLOT Y
        ZETA KS PLOT Y2 X2
        ZETA KS PLOT Y3 XLOW XHIGH
        ZETA PPCC PLOT Y
        ZETA PPCC PLOT Y2 X2
        ZETA PPCC PLOT Y3 XLOW XHIGH

    The default values of alpha1 and alpha2 are 1.5 and 5,
    respectively.  Due to the discrete nature of the percent point
    function for discrete distributions, the ppcc plot will not be
    smooth.  For that reason, if there is sufficient sample size
    the KS PLOT (i.e., the minimum chi-square value) is typically
    preferred.  Also, since the data is integer values, one of the
    binned forms is preferred for these commands.

    To generate a chi-square goodness of fit test, enter the
    commands

       LET ALPHA = <value>
       ZETA CHI-SQUARE GOODNESS OF FIT Y2 X2
       ZETA CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ZETCDF                   = Compute the Zeta cumulative
                               distribution function.
    ZETPPF                   = Compute the Zeta
                               percent point function.
    YULPDF                   = Compute the Yule probability
                               mass function.
    BGEPDF                   = Compute the beta-geometric (Waring)
                               probability mass function.
    BTAPDF                   = Compute the Borel-Tanner probability
                               mass function.
    DLGPDF                   = Compute the logarithmic series
                               probability mass function.
                               mass function.
    INTEGER FREQUENCY TABLE  = Generate a frequency table at
                               integer values with unequal bins.
 
    COMBINE FREQUENCY TABLE  = Convert an equal width frequency
                               table to an unequal width frequency
                               table.
    KS PLOT                  = Generate a minimum chi-square plot.
    MAXIMUM LIKELIHOOD       = Perform maximum likelihood
                               estimation for a distribution.

Reference:
    Johnson, Kotz, and Kemp (1992),  "Univariate Discrete
    Distributions", Second Edition, Wiley, pp. 465-471.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/5
 
Program:
    let alpha = 1.7
    let y = zeta random numbers for i = 1 1 500
    .
    let y3 xlow xhigh = integer frequency table y
    class lower 1.5
    class width 1
    let amax = maximum y
    let amax2 = amax + 0.5
    class upper amax2
    let y2 x2 = binned y
    .
    let k = minimum y
    zeta mle y
    relative histogram y2 x2
    limits freeze
    pre-erase off
    line color blue
    plot zetpdf(x,alphaml) for x = 1 1 amax
    limits
    pre-erase on
    line color black
    let alpha = alphaml
    zeta chi-square goodness of fit y3 xlow xhigh
    .
    label case asis
    x1label Alpha
    y1label Minimum Chi-Square
    zeta ks plot y3 xlow xhigh
    let alpha = shape
    case asis
    justification center
    move 50 5
    text Alpha = ^alpha
    zeta chi-square goodness of fit y3 xlow xhigh
 
-----ZETPPF (LET)--------------------------------
 
ZETPPF
 
Name:
    ZETPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Zeta percent point function.
 
Description:
    The zeta distribution has the following probability mass
    function:

        p(x;alpha) = (1/x**alpha)/zeta(alpha)
                     x = 1, 2, ...; alpha > 1

    with alpha denoting the shape parameter and zeta denoting
    the Riemann zeta function

        zeta(alpha) = SUM[i=t to infinity][1/x**alpha]

    Some sources parameterize this distribution with
    s = alpha - 1 (so that the distribution is defined for
    s > 0).

    The cumulative distribution is computed by summing the
    probability mass function.  The percent point function is
    the inversre of the cumulative distribution function and is
    obtained by computing the cumulative distribution function
    until the desired probability is reached.

    The zeta distribution can have very long tails as the value
    of alpha gets close to 1.  Dataplot will return an error
    message if the percent point value exceeds the maximum
    machine integer value.

Syntax:
    LET <y> = ZETPPF(<p>,<alpha>)   <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, number, or parameter in the range (0,1);
          <alpha> is a number or parameter greater than 1 that
               specifies the shape parameter;
          <y> is a variable or a parameter where the computed
               Zeta ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ZETPPF(0.95,1.5)
    LET Y = ZETPPF(P1,2.3)
    PLOT ZETPPF(P,2.3) FOR X = 0  0.01  0.95
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ZETCDF                   = Compute the Zeta cumulative
                               distribution function.
    ZETPDF                   = Compute the Zeta probability mass
                               distribution function.
    YULPDF                   = Compute the Yule probability mass
                               function.
    BGEPDF                   = Compute the beta-geometric (Waring)
                               probability mass function.
    BTAPDF                   = Compute the Borel-Tanner probability
                               mass function.
    DLGPDF                   = Compute the logarithmic series
                               probability mass function.
    INTEGER FREQUENCY TABLE  = Generate a frequency table at
                               integer values with unequal bins.
    COMBINE FREQUENCY TABLE  = Convert an equal width frequency
                               table to an unequal width frequency
                               table.
    KS PLOT                  = Generate a minimum chi-square plot.
    MAXIMUM LIKELIHOOD       = Perform maximum likelihood
                               estimation for a distribution.

Reference:
    Johnson, Kotz, and Kemp (1992),  "Univariate Discrete
    Distributions", Second Edition, Wiley, pp. 465-471.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, New York.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/5
 
Program:
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    case asis
    label case asis
    title case asis
    tic offset units screen
    tic offset 3 3
    title displacement 2
    y1label displacement 17
    x1label displacement 12
    .
    y1label Probability
    ylimits 0 1
    major ytic mark number 6
    minor ytic mark number 3
    x1label X
    line blank
    spike on
    .
    multiplot 2 2
    .
    let alpha = 1.5
    title Alpha = ^alpha
    plot zetcdf(x,alpha) for x = 1 1 20
    .
    let alpha = 2.0
    title Alpha = ^alpha
    plot zetcdf(x,alpha) for x = 1 1 20
    .
    let alpha = 2.5
    title Alpha = ^alpha
    plot zetcdf(x,alpha) for x = 1 1 20
    .
    let alpha = 3.0
    title Alpha = ^alpha
    plot zetcdf(x,alpha) for x = 1 1 20
    .
    end of multiplot
    .
    justification center
    move 50 97
    text Zeta Cumulative Distribution Functions
 
-----ZIPCDF (LET)--------------------------------
 
ZIPCDF
 
Name:
    ZIPCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Zipf cumulative distribution function.
 
Description:
    The Zipf distribution has the following probability mass
    function:

       p(x;alpha,n) = (1/x^alpha)/Hn(n,alpha)
                      x = 1, 2, ..., n; alpha > 1

    with alpha and n denoting the shape parameters and
    Hn denoting the generalized harmonic number

        Hn(n,s) = SUM[i=t to n][1/x**alpha]

    Some sources parameterize this distribution with
    s = alpha - 1 (so that the distribution is defined for
    s > 0).

    The cumulative distribution is computed by summing the
    probability mass function.

Syntax:
    LET <y> = ZIPCDF(<x>,<alpha>,<n>)
                         <SUBSET/EXCEPT/FOR qualification>
    where <x> is a positive integer variable, number, or
               parameter;
          <alpha> is a number or parameter greater than 1 that
               specifies the first shape parameter;
          <n> is a number or parameter that is a positive integer
               that specifies the second shape parameter;
          <y> is a variable or a parameter where the computed
               Zipf cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ZIPCDF(3,1.5,100)
    LET Y = ZIPCDF(X1,2.3,1000)
    PLOT ZIPCDF(X,2.3,100) FOR X = 1  1  100
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ZIPPDF                   = Compute the Zipf probability mass
                               function.
    ZIPPPF                   = Compute the Zipf percent point
                               function.
    ZETPDF                   = Compute the Zeta probability mass
                               function.
    YULPDF                   = Compute the Yule probability
                               mass function.
    BGEPDF                   = Compute the beta-geometric (Waring)
                               probability mass function.
    BTAPDF                   = Compute the Borel-Tanner probability
                               mass function.
    DLGPDF                   = Compute the logarithmic series
                               probability mass function.
                               mass function.
    INTEGER FREQUENCY TABLE  = Generate a frequency table at
                               integer values with unequal bins.
 
    COMBINE FREQUENCY TABLE  = Convert an equal width frequency
                               table to an unequal width frequency
                               table.
    KS PLOT                  = Generate a minimum chi-square plot.
    MAXIMUM LIKELIHOOD       = Perform maximum likelihood
                               estimation for a distribution.

Reference:
    Johnson, Kotz, and Kemp (1992),  "Univariate Discrete
    Distributions", Second Edition, Wiley, pp. 465-471.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/5
 
Program:
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    case asis
    label case asis
    title case asis
    tic offset units screen
    tic offset 3 3
    title displacement 2
    y1label displacement 17
    x1label displacement 12
    .
    y1label Probability
    ylimits 0 1
    major ytic mark number 6
    minor ytic mark number 3
    x1label X
    line blank
    spike on
    .
    multiplot 2 2
    let n = 100
    .
    let alpha = 1.5
    title Alpha = ^alpha
    plot zipcdf(x,alpha,n) for x = 1 1 100
    .
    let alpha = 2.0
    title Alpha = ^alpha
    plot zipcdf(x,alpha,n) for x = 1 1 100
    .
    let alpha = 2.5
    title Alpha = ^alpha
    plot zipcdf(x,alpha,n) for x = 1 1 100
    .
    let alpha = 3.0
    title Alpha = ^alpha
    plot zipcdf(x,alpha,n) for x = 1 1 100
    .
    end of multiplot
    .
    justification center
    move 50 97
    text Zipf Cumulative Distribution Functions
 
-----ZIPPDF (LET)--------------------------------
 
ZIPPDF
 
Name:
    ZIPPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Zipf probability mass function.
 
Description:
    The Zipf distribution has the following probability mass
    function:

       p(x;alpha,n) = (1/x^alpha)/Hn(n,alpha)
                      x = 1, 2, ..., n; alpha > 1

    with alpha and n denoting the shape parameters and
    Hn denoting the generalized harmonic number

        Hn(n,s) = SUM[i=t to n][1/x**alpha]

    Some sources parameterize this distribution with
    s = alpha - 1 (so that the distribution is defined for
    s > 0).

    The mean of the Zipf distribution is

        mean     = Hn(n,alpha-2)/Hn(n,alpha-1)      alpha > 2
        
    The development of the Zipf distribution was motivated by
    Zipf's law (from the linguistics community).  Zipf's law
    states that the frequency of occurence of any word is
    approximately inversely proportional to its rank in the
    frequency table.  When Zipf's law is applicable, plotting
    the frequency table on a log-log scale (i.e., log(frequency)
    versus log(rank order)) will typically show a linear pattern.
    Note that Zipf's law is an empirical (as oppossed to a
    theoretical) law.  However, Zipf's law has served as a
    useful model for many different kinds of phenomena.

Syntax:
    LET <y> = ZIPPDF(<x>,<alpha>,<n>)
                         <SUBSET/EXCEPT/FOR qualification>
    where <x> is a positive integer variable, number, or
               parameter;
          <alpha> is a number or parameter greater than 1 that
               specifies the first shape parameter;
          <n> is a number or parameter that is a positive integer
               that specifies the second shape parameter;
          <y> is a variable or a parameter where the computed
               Zipf pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ZIPPDF(3,1.5,100)
    LET Y = ZIPPDF(X1,2.3,1000)
    PLOT ZIPPDF(X,2.3,100) FOR X = 1  1  100
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Note:
    The zeta distribution is the limiting case of the Zipf
    distribution as n goes to infinity.  Note that zeta
    distribution and Zipf distribution tend to be used
    interchangeably in the literature.  The primary distinction
    is that the Zipf distribution is bounded in the upper tail
    while the zeta distribution is unbounded in the upper tail.
    When the upper bound for the Zipf distribution is large, the
    zeta distribution is typically used as an approximation. 

Note:
    For a number of commands utilizing the Zipf distribution,
    it is convenient to bin the data.  There are two basic ways
    of binning the data.

      1) For some commands (histograms, maximum likelihood
         estimation), bins with equal size widths are
         required.  This can be accomplished with the
         following commands:

            LET AMIN = MINIMUM Y
            LET AMAX = MAXIMUM Y
            LET AMIN2 = AMIN - 0.5
            LET AMAX2 = AMAX + 0.5
            CLASS MINIMUM AMIN2
            CLASS MAXIMUM AMAX2
            CLASS WIDTH 1
            LET Y2 X2 = BINNED

      2) For some commands, unequal width bins may be
         helpful.  In particular, for the chi-square goodness
         of fit, it is typically recommended that the minimum
         class frequency be at least 5.  In this case, it may
         be helpful to combine small frequencies in the tails.
         Unequal class width bins can be created with the
         commands

            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = INTEGER FREQUENCY TABLE Y

         If you already have equal width bins data, you can
         use the commands
         
            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = COMBINE FREQUENCY TABLE Y2 X2

         The MINSIZE parameter defines the minimum class
         frequency.  The default value is 5.

Note:
    You can generate Zipf random numbers and probability
    plots with the following commands:

       LET NLAST = <value>
       LET N = <value>
       LET ALPHA = <value>
       LET Y = ZIPF RANDOM NUMBERS FOR I = 1 1 NLAST

       ZIPF PROBABILITY PLOT Y
       ZIPF PROBABILITY PLOT Y2 X2
       ZIPF PROBABILITY PLOT Y3 XLOW XHIGH

    You can generate an estimate of alpha, assuming the value
    of n is known, based on the maximum ppcc value or the minimum
    chi-square goodness of fit with the commands

        LET N = <value>
        LET ALPHA1 = <value>
        LET ALPHA2 = <value>
        ZIPF KS PLOT Y
        ZIPF KS PLOT Y2 X2
        ZIPF KS PLOT Y3 XLOW XHIGH
        ZIPF PPCC PLOT Y
        ZIPF PPCC PLOT Y2 X2
        ZIPF PPCC PLOT Y3 XLOW XHIGH

    If the value of n is unknown, you can use the maximum
    data value as the estimate of n.  The default values of
    alpha1 and alpha2 are 1.5 and 5, respectively.  Due to the
    discrete nature of the percent point function for discrete
    distributions, the ppcc plot will not be smooth.  For that
    reason, if there is sufficient sample size the KS PLOT (i.e.,
    the minimum chi-square value) is typically preferred.  Also,
    since the data is integer values, one of the binned forms is
    preferred for these commands.

    To generate a chi-square goodness of fit test, enter the
    commands

       LET N = <value>
       LET ALPHA = <value>
       ZIPF CHI-SQUARE GOODNESS OF FIT Y2 X2
       ZIPF CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ZIPCDF                   = Compute the Zipf cumulative
                               distribution function.
    ZIPPPF                   = Compute the Zipf percent point
                               function.
    ZETPDF                   = Compute the Zeta probability mass
                               function.
    YULPDF                   = Compute the Yule probability
                               mass function.
    BGEPDF                   = Compute the beta-geometric (Waring)
                               probability mass function.
    BTAPDF                   = Compute the Borel-Tanner probability
                               mass function.
    DLGPDF                   = Compute the logarithmic series
                               probability mass function.
                               mass function.
    INTEGER FREQUENCY TABLE  = Generate a frequency table at
                               integer values with unequal bins.
 
    COMBINE FREQUENCY TABLE  = Convert an equal width frequency
                               table to an unequal width frequency
                               table.
    KS PLOT                  = Generate a minimum chi-square plot.
    MAXIMUM LIKELIHOOD       = Perform maximum likelihood
                               estimation for a distribution.

Reference:
    Johnson, Kotz, and Kemp (1992),  "Univariate Discrete
    Distributions", Second Edition, Wiley, pp. 465-471.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/5
 
Program:
    let n = 100
    let alpha = 1.7
    let y = zipf random numbers for i = 1 1 500
    .
    let y3 xlow xhigh = integer frequency table y
    class lower 1.5
    class width 1
    let amax = maximum y
    let amax2 = amax + 0.5
    class upper amax2
    let y2 x2 = binned y
    .
    label case asis
    x1label Alpha
    y1label Minimum Chi-Square
    zipf ks plot y3 xlow xhigh
    let alpha = shape
    case asis
    justification center
    move 50 5
    text Alpha = ^alpha
    zipf chi-square goodness of fit y3 xlow xhigh
 
-----ZIPPPF (LET)--------------------------------
 
ZIPPPF
 
Name:
    ZIPPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Zipf percent point function.
 
Description:
    The Zipf distribution has the following percent point
    function:

       p(x;alpha,n) = (1/x^alpha)/Hn(n,alpha)
                      x = 1, 2, ..., n; alpha > 1

    with alpha and n denoting the shape parameters and
    Hn denoting the generalized harmonic number

        Hn(n,s) = SUM[i=t to n][1/x**alpha]

    Some sources parameterize this distribution with
    s = alpha - 1 (so that the distribution is defined for
    s > 0).

    The cumulative distribution is computed by summing the
    probability mass function.  The percent point function
    is the inverse of the cumulative distribution function
    and is obtained by computing the cumulative distribution
    until the specified probability is obtained.

Syntax:
    LET <y> = ZIPPPF(<p>,<alpha>,<n>)
                         <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, number, or parameter in the range
               (0,1);
          <alpha> is a number or parameter greater than 1 that
               specifies the first shape parameter;
          <n> is a number or parameter that is a positive integer
               that specifies the second shape parameter;
          <y> is a variable or a parameter where the computed
               Zipf ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ZIPPPF(0.95,1.5,100)
    LET Y = ZIPPPF(X1,2.3,1000)
    PLOT ZIPPPF(X,2.3,100) FOR X = 1  1  100
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ZIPCDF                   = Compute the Zipf cumulative
                               distribution function.
    ZIPPDF                   = Compute the Zipf probability mass
                               function.
    ZETPDF                   = Compute the Zeta probability mass
                               function.
    YULPDF                   = Compute the Yule probability
                               mass function.
    BGEPDF                   = Compute the beta-geometric (Waring)
                               probability mass function.
    BTAPDF                   = Compute the Borel-Tanner probability
                               mass function.
    DLGPDF                   = Compute the logarithmic series
                               probability mass function.
                               mass function.
    INTEGER FREQUENCY TABLE  = Generate a frequency table at
                               integer values with unequal bins.
 
    COMBINE FREQUENCY TABLE  = Convert an equal width frequency
                               table to an unequal width frequency
                               table.
    KS PLOT                  = Generate a minimum chi-square plot.
    MAXIMUM LIKELIHOOD       = Perform maximum likelihood
                               estimation for a distribution.

Reference:
    Johnson, Kotz, and Kemp (1992),  "Univariate Discrete
    Distributions", Second Edition, Wiley, pp. 465-471.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/5
 
Program:
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    case asis
    label case asis
    title case asis
    tic offset units screen
    tic offset 3 3
    title displacement 2
    y1label displacement 17
    x1label displacement 12
    .
    x1label Probability
    xlimits 0 1
    major xtic mark number 6
    minor xtic mark number 3
    y1label X
    line blank
    spike on
    .
    multiplot 2 2
    let n = 100
    .
    let alpha = 1.5
    title Alpha = ^alpha
    plot zipppf(p,alpha,n) for p = 0  0.01  1
    .
    let alpha = 2.0
    title Alpha = ^alpha
    plot zetppf(p,alpha,n) for p = 0  0.01  1
    .
    let alpha = 2.5
    title Alpha = ^alpha
    plot zetppf(p,alpha,n) for p = 0  0.01  1
    .
    let alpha = 3.0
    title Alpha = ^alpha
    plot zipppf(p,alpha,n) for p = 0  0.01  1
    .
    end of multiplot
    .
    justification center
    move 50 97
    text Zipf Cumulative Distribution Functions
 
---------------------------------------------------------
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
















 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
-------------------------  *MISCELLANEOUS*  ZZZZZ--------------------

-----2D GRID (LET)-------------------------------------
 
2D GRID
3D GRID
4D GRID
 
Name:
    2D GRID (LET)
    3D GRID (LET)
    4D GRID (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Given a sequence of values for two to four variables, create a
    gridded set of values.
 
Description:
    It is sometimes useful to create a set of gridded values.  For
    example, you may want to evaulate a function over this grid.

    For example, given X1 = 0, 0.5, 1.0 and
    X2 = 0, 0.2, 0.4 0.6, 0.8, 1.0, the gridded output (saved in
    Y1 and Y2) would be

        Y1       Y2
       ------------
       0.0      0.0
       0.0      0.2
       0.0      0.4
       0.0      0.6
       0.0      0.8
       0.0      1.0
       0.5      0.0
       0.5      0.2
       0.5      0.4
       0.5      0.6
       0.5      0.8
       0.5      1.0
       1.0      0.0
       1.0      0.2
       1.0      0.4
       1.0      0.6
       1.0      0.8
       1.0      1.0

    This basic logic can be extended to the case of three or four input
    variables.

    Although the gridded values can also be generated with a set of
    SEQUENCE commands, these commands are provided as a convenience.

Syntax 1:
    LET <y1> <y2> = 2D GRID <x1> <x2>  <SUBSET/EXCEPT/FOR qualification>
    where <x1> is a variable containing the values for the first
               variable to be gridded;
          <x2> is a variable containing the values for the second
               variable to be gridded;
          <y1> is a variable where the gridded values for the first
               variable are saved;
          <y2> is a variable where the gridded values for the second
               variable are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    LET <y1> <y2> <y3> = 3D GRID <x1> <x2> <x3>
                         <SUBSET/EXCEPT/FOR qualification>
    where <x1> is a variable containing the values for the first
               variable to be gridded;
          <x2> is a variable containing the values for the second
               variable to be gridded;
          <x3> is a variable containing the values for the third
               variable to be gridded;
          <y1> is a variable where the gridded values for the first
               variable are saved;
          <y2> is a variable where the gridded values for the second
               variable are saved;
          <y3> is a variable where the gridded values for the third
               variable are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 3:
    LET <y1> <y2> <y3> <y4> = 4D GRID <x1> <x2> <x3> <x4>
                              <SUBSET/EXCEPT/FOR qualification>
    where <x1> is a variable containing the values for the first
               variable to be gridded;
          <x2> is a variable containing the values for the second
               variable to be gridded;
          <x3> is a variable containing the values for the third
               variable to be gridded;
          <x4> is a variable containing the values for the third
               variable to be gridded;
          <y1> is a variable where the gridded values for the first
               variable are saved;
          <y2> is a variable where the gridded values for the second
               variable are saved;
          <y3> is a variable where the gridded values for the third
               variable are saved;
          <y4> is a variable where the gridded values for the third
               variable are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y1 Y2 = 2D GRID X1 X2
    LET Y1 Y2 Y3 = 3D GRID X1 X2 X3
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CONTOUR PLOT      = Generate a contour plot.
    3D PLOT           = Generate a 3D plot.
    LET FUNCTION      = Evaluate a function.

Applications:
    Data Transformations
 
Implementation Date:
    2019/08
 
Program 1:
    . Step 1:   Define input values
    .
    let x1 = sequence 0 0.1 1
    let x2 = sequence 0 0.1 1
    .
    . Step 2:   Generate the gridded sequence
    .
    let y1 y2 = 2d grid x1 x2
    set write decimals 1
    print y1 y2
 
Program 2:
    . Step 1:   Define input values
    .
    let x1 = sequence 0 0.1 1
    let x2 = sequence 0 0.1 1
    let x3 = sequence 0 0.1 1
    .
    . Step 2:   Test the command
    .
    let y1 y2 y3 = 3d grid x1 x2 x3
    set write decimals 1
    print y1 y2 y3 for i = 1 1 40

-----2D INTERPOLATION (LET)----------------------------------------
 
2D INTERPOLATION
 
Name:
    2D INTERPOLATION (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Perform a bivariate interpolation of a series of scattered data
    points.
 
Description:
    Two dimensional interpolation takes a series of (x,y,z) points and
    generates estimated values for z's at new (x,y) points.
    Interpolation is used when the function that generated the original
    (x,y,z) points is unknown.
 
    Interpolation is related to, but distinct from, fitting a function
    to a series of points.  In particular, an interpolated function
    goes through all the original points while a fitted function does
    not.
 
    There are two distinct types of 2d interpolation.  In the first,
    data is available for a rectangular grid of points and
    interpolation is performed for points off the grid.  In the second,
    data is available for a random set of points and the interpolation
    is generated on a rectangular grid.  This second form can be used
    to generate a contour or surface plot when the data do not form a
    grid.
 
    The 2D INTERPOLATION command is used for the second type of
    interpolation.  The method Dataplot uses is based on the
    construction of local thin plate splines, which are then blended
    together via univariate piecewise Hermite cubic polynomials.
 
    The BILINEAR INTERPOLATION and BIVARIATE INTERPOLATION commands
    are used for the first type.  Ses the documentation for these
    commands for more details.
 
Syntax:
    LET <z2> = 2D INTERPOLATION <z1> <y1> <x1> <y2> <x2>
                 <SUBSET/EXCEPT/FOR qualification>
    where <z1> is a variable containing the z-axis data points;
          <y1> is a variable containing the vertical axis data points;
          <x1> is a variable containing the horizontal axis data
               points;
          <x2> is a variable containing the horizontal points where the
               interpolation is to be performed;
          <y2> is a variable containing the vertical points where the
               interpolation is to be performed;
          <z2> is a variable (same length as <x2>) where the
               interpolated values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Z2 = 2D INTERPOLATION Z1 Y1 X1 Y2 X2
 
Note:
    The <z1>, <y1>, and <x1> arrays should be the same size.  The <x2>
    and <y2> define the grid points in the x and y axis and need not be
    the same size.  Only the distinct points in <x2> and <y2> are used.
 
Note:
    The original data do not have to be in sorted order.
 
Note:
    The desired average number of points per region can be specified
    with the following command:
        LET NPPR = <value>
    where <value> is a number greater than or equal to 3.  The default
    is 10, which should give good results in most cases.
 
Note:
    Bivariate interpolation of scattered data can be ill-behaved for
    some data sets.
 
Note:
    Dataplot uses the LOTPS library written by Richard Franke of the
    Naval Postgraduate School.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    INTERPOLATION            = Compute a cubic spline interpolation of
                               a series of points.
    LINEAR INTERPOLATION     = Compute a linear interpolation of a
                               series of points.
    BIVARIATE INTERPOLATION  = Compute a bilinear interpolation from a
                               grid to random points of a 2D series of
                               points.
    BILINEAR INTERPOLATION   = Compute a bilinear interpolation from a
                               grid to random points of a 2D series of
                               points.
    CONTOUR PLOT             = Generates a contour plot.
    3D-PLOT                  = Generates a 3d function or data plot.
    FIT                      = Perform a least squares fit.
 
References:
    "Smooth Interpolation of Scattered Data by Local Thin Plate
    Splines", Richard Franke, Naval Postgraduate School,
    TR#NPS-53-81-002, 1981 (also available from NTIS as AD-A098 232/2).
 
Applications:
    Mathematics
 
Implementation Date:
    94/6
 
Program:
    LET X = DATA 0 0.2 0.5 0.6 1.0
    LET Y = DATA 0.2 0.7 0 1.0 0.5
    LET Z = DATA 0.2 0.5 0.6 0.3 0
    LET X2 = DATA 0.2 0.9
    LET Y2 = DATA 0.1 0.8
    .
    SET WRITE DECIMALS 3
    LET Z2 = 2D INTERPOLATION Z Y X Y2 X2
    PRINT X2 Y2 Z2
 
-----3D PLOT-------------------------------------------------------
 
3D PLOT
 
Name:
    3D-PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a 3-dimensional plot.
 
Description:
    The 3D-PLOT command allows the analyst to generate single or
    multi-surface 3d-plots of data, functions, or both.
 
    There are 6 general 3D-PLOT syntaxes:
       1) 3-variable form
       2) 4-variable multi-trace form
       3) VERSUS form
       4) multi-VERSUS form
       5) function form
       6) AND form
 
 
Syntax 1:
    3D-PLOT   <y>   <x1>   <x2>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <x1> is a response variable;
          <x2> is a response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This is the 3-argument form for the 3D-PLOT command.  It is used
    for plotting <y> versus <x1> and <x2>.  The resulting plot will
    have <y> on the vertical axis, <x1> on one horizontal axis, and
    <x2> on the other horizontal axis.
 
Syntax 2:
    3D-PLOT <y> <x1> <x2> <tag>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <x1> is a response variable;
          <x2> is a response variable;
          <tag> is a coded variable for identifying traces;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This is the 4-argument form for the 3D-PLOT command.  It is used
    for multi-trace plotting of <y> versus <x1> and <x2>.  The
    resulting plot will have <y> on the vertical axis, <x1> on one
    horizontal axis, <x2> on the other horizontal axis, and will have
    multiple traces-- one trace for each distinct value in the <tag>
    variable.
 
Syntax 3:
    3D-PLOT   <y1>   <y2>   <y3>  ... <yk>   VERSUS   <x1>   <x2>
    where <y1>, <y2>, <y3>, ..., <yk> are response variables to be
              plotted on the vertical axis;
          <x1> and <x2> are response variables to be plotted on the
              horizontal axes;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This is the single-VERSUS argument form for the 3D-PLOT command.
    It is used for multi-trace 3-dimensional plotting.  The resulting
    3-d plot will have one trace for each <yi> variable:
       <y1> (vertically) versus <x1> and <x2> (horizontally)
       <y2> (vertically) versus <x1> and <x2> (horizontally)
       <y3> (vertically) versus <x1> and <x2> (horizontally)
       ...
       <yk> (vertically) versus <x1> and <x2> (horizontally)
 
Syntax 4:
    3D-PLOT   <syntax 3>   <syntax 3>   ...   <syntax 3>
 
    This is the multi-VERSUS argument form for the 3D-PLOT command.
    It is used for multi-trace 3-dimensional plotting.  The resulting
    3-d plot will have one trace for each <yi> variable:
       <y1> (vertically) versus <x1> and <x2> (horizontally)
       <y2> (vertically) versus <x3> and <x4> (horizontally)
       <y3> (vertically) versus <x5> and <x6> (horizontally)
       ...
       <yk> (vertically) versus <x(2k-1)> and <x(2k)> (horizontally)
 
Syntax: 5
    3D-PLOT  <f> FOR  <x1>  =  <start 1>  <increment 1>  <stop 1> ...
                 FOR  <x2>  =  <start 2>  <increment 2>  <stop 2>
    where <f> is a function (either pre-defined via the LET FUNCTION
              command, or explicitly defined herein);
          <x1> is one dummy variable in the function;
          <start 1> is the desired minimum value for <x1> at which the
              function is to be evaluated;
          <increment 1> is the desired increment value for <x1> at
              which the function is to be evaluated;
          <stop 1> is the desired maximum value for <x1> at which the
              function is to be evaluated;
          <x2> is the other dummy variable in the function;
          <start 2> is the desired minimum value for <x2> at which the
              function is to be evaluated;
          <increment 2> is the desired increment value for <x2> at
              which the function is to be evaluated;
    and   <stop 2> is the desired maximum value for <x2> at which the
              function is to be evaluated.
 
    This is the function form for the 3D-PLOT command.  It is used for
    plotting the surface of a function.
 
Syntax: 6
    <any valid syntax 1 to 5>  AND
    <any valid syntax 1 to 5>  AND
    <any valid syntax 1 to 5>  AND
    ...
    <any valid syntax 1 to 5>  AND
    <any valid syntax 1 to 5>
 
    This is the most general syntax for 3D-PLOT.  It is used for
    generating multi-trace plots of variables, of functions, or of
    mixtures of both.
 
Examples:
    3D-PLOT Y X1 X2
    3D-PLOT RES P1 P2
 
    3D-PLOT Y X1 X2 LAB
    3D-PLOT PRES TEMP1 TEMP2 DAY
 
    3D-PLOT Y1 Y2 Y3 VERSUS X1 X2
    3D-PLOT Y PRED VERSUS X1 X2
 
    3D-PLOT Y1 Y2 Y3 VERSUS X1 X2 Y4 Y5 VERSUS X3 X4
    3D-PLOT P1 VERSUS T1 T2 P2 VERSUS T3 T4 P3 VERSUS T5 T6
 
    3D-PLOT SIN(X)*EXP(-X-Y) FOR X = 0 .1 5 FOR Y = 1 .1 2
    LET FUNCTION F = EXP(-X*SIN(X**2+Y**2))
    3D-PLOT F FOR X = 0 .1 3 FOR Y = 1 .2 2
 
    3D-PLOT Y X1 X2 AND
    3D-PLOT A+B*X*Y FOR X = 1 1 10 FOR Y = 0 .2 1
 
    3D-PLOT Y X1 X2 AND
    3D-PLOT A*X+Y**2 FOR X = 1 .1 3 FOR Y = 2 .1 3 AND
    3D-PLOT Y3 X3 X4 LAB
 
Note:
    The view for the plot is determined by the eye coordinates.  The
    default eye coordinates for all 3 dimensions are:
       data maximum + 3 X (data maximum - data minimum)
    Enter HELP EYE COORDINATES for details.
 
Note:
    If the 3D plot is compressed in one or more directions, the most
    likely problem is that the X, Y, and Z scales have different ranges
    (e.g., X and Y go from 0 to 1000 while Z goes from 0 to 1).  One
    solution to this problem is to scale the data to the same range via
    the LET command (e.g., divide each of them by the appropriate power
    of 10 so that they all go from -1 to +1).
 
Note:
    Increasing the magnitude of the eye coordinates will shrink the
    size of the 3D plot.  That is, the further away the eye is from the
    plot, the smaller the plot appears.
 
Note:
    The eye coordinates can be negative.  This can be useful for
    looking at the plot from a different perspective.  The following
    algorithm can be a useful starting point:
       TITLE AUTOMATIC
       MULTIPLOT 2 2
       MULTIPLOT CORNER COORDINATES 0 0 100 100
       LET XMAX = MAXIMUM X; LET XMIN = MINIMUM X
       LET XEYE = XMAX + 3*(XMAX-XMIN)
       LET YMAX = MAXIMUM Y; LET YMIN = MINIMUM Y
       LET YEYE = YMAX + 3*(YMAX-YMIN)
       LET ZMAX = MAXIMUM Z; LET ZMIN = MINIMUM Z
       LET ZEYE = ZMAX + 3*(ZMAX-ZMIN)
       .  All positive
       EYE COORDINATES XEYE YEYE ZEYE
       3D-PLOT  ...
       .  X view negative
       LET XTEMP = -XEYE
       EYE COORDINATES XTEMP YEYE ZEYE
       3D-PLOT  ...
       .  Y view negative
       LET YTEMP = -YEYE
       EYE COORDINATES XEYE YTEMP ZEYE
       3D-PLOT  ...
       .  Both X and Y views negative
       EYE COORDINATES XTEMP YTEMP ZEYE
       3D-PLOT  ...
    Most reasonable views generate plots that are only marginally
    different from one of these 4 views.  Changing the magnitude of
    the eye coordinates can make the plot slightly larger or smaller,
    but will not change the basic appearance.  Making the Z eye
    coordinate negative is generally not helpful.
 
    The ROTATE EYE command can be used to automatically rotate the
    eye coordinates.  This command can be used with the LOOP and
    MULTIPLOT commands to automatically display various rotations of
    the 3d plot.
 
Note:
    The 3D-PLOT command has some limitations.
       1) No hidden line removal is performed.
       2) No axes or axes labels are drawn.  Text labels can be added
          with either the LEGEND or TEXT command (although the analyst
          will need to do the proper positioning).  The 3D FRAME
          command can be used draw a frame around the plot.  Although
          this essentially draws the axes, it has no capability for
          putting tic marks or tic mark labels on the frame lines.
    Some enhancements currently under development will address these
    limitations.
 
Note:
    The plot traces can be drawn as lines, characters, spikes, or bars.
    The LINES, CHARACTER, SPIKES, and BAR commands can be used to set
    these (along with their various attribute setting commands).
 
Default:
    None
 
Synonyms:
    VS and VS. can be used in place of VERSUS.
 
Related Commands:
    EYE COORDINATES     = Specify the eye coordinates for 3d plots.
    ROTATE EYE          = Rotate the current eye coordinates.
    3DFRAME             = Specify the type of frame (if any) to be
                          drawn on 3d plots.
    PLOT                = Generates a 2d data or function plot.
    CONTOUR PLOT        = Generates a contour plot.
    CHARACTERS          = Sets the types for plot characters.
    LINES               = Sets the types for plot lines.
    SPIKES              = Sets the on/off switches for plot spikes.
    BARS                = Sets the on/off switches for plot bars.
    TITLE               = Sets the plot title.
    LEGEND              = Sets the plot legends.
    SEQUENCE            = Sets the automatic sequence switch for plots.
    MULTIPLOT           = Generate multiple plots per page.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program 1:
    LET FUNCTION E = -0.5*((X**2)+(Y**2))
    LET FUNCTION F = (1/(2*PI))*EXP(E)
    3D-PLOT F FOR X = -2 .2 2 FOR Y = -2 .1 2
 
Program 2:
    LET FUNCTION F = SIN(X+COS(Y))
    3DFRAME 3PLANE
    FEEDBACK OFF
    .
    MULTIPLOT 4 4; MULTIPLOT CORNER COORDINATES 0 0 100 100
    LOOP FOR K = 1 1 16
    ROTATE
    3DPLOT F FOR X = -2 .2 2 FOR Y = -2 .2 2
    END OF LOOP
    END OF MULTIPLOT
 
Program 3:
    . THIS IS THE Dataplot PROGRAM FILE     BOXYIELD.DP
    . PURPOSE--GENERATE A 3D PLOT OF A NON-LINEAR FUNCTION
    .
    . -----START POINT-----
    .
    .
    LET M1 = 70
    LET M2 = 155
    LET SIG1 = 10
    LET SIG2 = 5
    LET RHO = 1.6
    .
    LET FUNCTION X1 = (TIME-M1)/SIG1
    LET FUNCTION X2 = (TEMP-M2)/SIG2
    LET FUNCTION F1 = EXP(-X1**2)
    LET FUNCTION F2 = EXP(RHO*X1*X2)
    LET FUNCTION F3 = EXP(-X2**2)
    LET FUNCTION F = 10*((1000*F1*F2*F3)**.25)
    .
    3DPLOT F FOR TIME = 50 2 90 FOR TEMP = 130 2 180
 
Program 4:
    . THIS IS Dataplot PROGRAM DEXSURF.DP
    . PURPOSE--GENERATE VARIOUS SURFACES
    .          UNDER LINEAR + INTERACTION MODEL
    . DATE--JULY 1989
    .
    . --------------------
    .
    EYE COORDINATES 10 20 30
    XLABEL SIZE 5
    X3LABEL SIZE 5
    LET X1 = SEQUENCE -1 .2 1 FOR I = 1 1 121
    LET X2 = SEQUENCE -1 11 .2 1
    .
    LOOP FOR B12 = -3 3 3
    MULTIPLOT 3 3; MULTIPLOT CORNER COORDINATES 0 0 100 100
    LOOP FOR B1 = -3 3 3
    LOOP FOR B2 = -3 3 3
    XLABEL B1 = ^B1   B2 = ^B2
    X3LABEL B12 = ^B12
    LET Y = B1*X1+B2*X2+B12*X1*X2
    3DPLOT Y X1 X2 X1 AND
    3DPLOT Y X1 X2 X2
    END OF LOOP
    END OF LOOP
    END OF MULTIPLOT
    END OF LOOP
 
-----3DFRAME------------------------------------------------------
 
3DFRAME
 
Name:
    3DFRAME
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the type of frame to draw for a 3d plot.
 
Description:
    Dataplot offers the following choices for drawing the frame on
    a 3d plot:
 
        OFF     - no 3d frame is drawn;
        3PRONG  - the 3 axes lines are drawn (from their minimums to
                  their maximums) from a common origin;
        3PLANE  - the xz and yz planes are drawn;
        BOX     - a cube is drawn (from the minimum to the maximum in
                  each direction);
        ZIGZAG  - similar to 3PRONG, but the axes are not drawn from a
                  common origin;
        ?       - print the current setting and the available settings.
 
Syntax:
    3DFRAME  <style>
    where <style> is OFF, 3PRONG, 3PLANE, BOX, ZIGZAG, or ? as
               described above.
 
Examples:
    3DFRAME OFF
    3DFRAME 3PLANE
    3DFRAME 3PRONG
    3DFRAME ZIGZAG
 
Note:
    At this time, the axes are not drawn with tic marks or tic mark
    labels.
 
Default:
    No 3d frame is drawn.
 
Synonyms:
    3DFRAME NONE is a synonym for 3DFRAME OFF and 3DFRAME CUBE is a
    synonym for 3DFRAME BOX.
 
Related Commands:
    EYE COORDINATES    = Specifies the eye coordinates for a 3d plot.
    3D-PLOT            = Generates a 3-d data or function plot.
    ROTATE EYE         = Automatically rotate the eye coordinates.
 
Applications:
    XX
 
Implementation Date:
    93/10
 
Program:
    LET FUNCTION E = -0.5*((X**2)+(Y**2))
    LET FUNCTION F = (1/(2*PI))*EXP(E)
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE 3D FRAME 3PRONG
    3DFRAME 3PRONG
    3D-PLOT F FOR X = -2 .2 2 FOR Y = -2 .1 2
    TITLE 3D FRAME 3PLANE
    3DFRAME 3PLANE
    3D-PLOT F FOR X = -2 .2 2 FOR Y = -2 .1 2
    TITLE 3D FRAME BOX
    3DFRAME BOX
    3D-PLOT F FOR X = -2 .2 2 FOR Y = -2 .1 2
    TITLE 3D FRAME ZIGZAG
    3DFRAME ZIGZAG
    3D-PLOT F FOR X = -2 .2 2 FOR Y = -2 .1 2
    END OF MULTIPLOT
 
-----4-PLOT--------------------------------------
 
4 PLOT
 
Name:
    4-PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a run sequence plot, a lag plot, a histogram, and a
    normal probability plot on the same page.
 
Description:
    Many measurement processes are based on the following assumptions
    that the data from the process behave like

       1. random drawings;
       2. from a fixed distribution;
       3. with the distribution having fixed location; and
       4. with the distribution having fixed variation.

    These assumptions are often stated as "indenpendent,
    identically distributed" (iid) random variables.

    These assumptions often apply when we have collected a univariate
    data set.  However, it also applies in a modeling context
    (e.g., linear regression) where the assumptions apply to the
    residuals of the model rather than to the response variable
    of the model.

    The 4-plot is a collection of four specific graphical techniques
    whose purpose is to test these assumptions.  A 4-plot consists of a

        1. run sequence plot;
        2. lag plot;
        3. histogram;
        4. normal probability plot. 

    If the four underlying assumptions of a typical measurement process
    hold, then the above four plots will have a characteristic
    appearance.  If any of the underlying assumptions fail to hold, then
    it will be revealed by an anomalous appearance in one or more of the
    plots.

    Specifically, the run sequence plot is a useful graph for
    assessing the fixed location and variation assumptions.  The
    lag plot should have a random appearance if the randomness
    assumption holds.  The histogram and normal probability plot
    are used to give some insight into the distribution of the
    data.  In many cases, the distributional assumption is
    tightened to specify that the data follow an approximately
    normal distribution.

Syntax 1:
    4-PLOT  <y>     <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    HIGHLIGHT 4-PLOT <y>  <x>  <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <x> is a group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax can be used to plot certain points with different
    attributes.  This is demonstrated in the Program 2 example
    below.
 
Examples:
    4-PLOT Y1
    4-PLOT RUN1
    4-PLOT Y1 SUBSET TAG = 1
 
Note:
    You can change the normal probability plot to an
    exponential probability plot with the command

         SET 4PLOT DISTRIBUTION EXPONENTIAL

    To restore the default of a normal probability plot, enter

         SET 4PLOT DISTRIBUTION NORMAL

Note:
    By default, the 4-PLOT command ignores the MULTIPLOT CORNER
    COORDINATE settings.  That is, the 4-plot will be generated
    as if the following command had been entered

         MULTIPLOT CORNER COORDINATES 15 20 85 90

    If you want the 4-PLOT command to utilize the settings from
    the MULTIPLOT CORNER COORDINATE command, enter

         SET 4PLOT MULTIPLOT ON

    To restore the default of ignoring the MULTIPLOT CORNER
    COORDINATE settings, enter

         SET 4PLOT MULTIPLOT OFF

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    RUN SEQUENCE PLOT = Generates a run sequence plot.
    LAG PLOT          = Generates a lag plot.
    HISTOGRAM         = Generates a histogram.
    NORMAL PROB PLOT  = Generates a normal probability plot.
    PLOT              = Generates a data or function plot.
    MULTIPLOT         = Allows multiple plots per page
    SUMMARY           = Computes various summary statistics.
 
Applications:
    Exploratory Data Analysis
 
Implementation Date:
    Pre-1987
    2002/04: Added SET 4PLOT MULTIPLOT
    2006/10: Added SET 4PLOT DISTRIBUTION
    2011/06: Added HIGHLIGHT option
 
Program 1:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    TIC MARK LABEL SIZE 4
    CHARACTER SIZE 4
    4-PLOT Y1
 
Program 2:
    SKIP 25
    READ LEW.DAT Y
    LET N = SIZE Y
    LET TAG = 0 FOR I = 1 1 N
    LET TAG(3) = 1
    LET TAG(5) = 1
    LET TAG(157) = 1
    LET TAG(158) = 1
    .
    TITLE AUTOMATIC
    TITLE CASE ASIS
    TITLE OFFSET 2
    TITLE SIZE 4
    LABEL CASE ASIS
    TIC MARK LABEL SIZE 4
    TIC MARK OFFSET UNITS SCREEN
    TIC MARK OFFSET 5 5
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    SET 4PLOT MULTIPLOT ON
    .
    CHARACTER COLOR BLACK RED
    CHARACTER X X
    LINE BLANK BLANK
    BAR FILL ON ON
    BAR FILL COLOR RED BLUE
    HIGHLIGHT 4-PLOT Y TAG
    .
    CASE ASIS
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT 4-Plot for LEW.DAT
 
Program 3:
    SKIP 25
    READ BERGER1.DAT Y X
    FIT Y X
    .
    TITLE AUTOMATIC
    TITLE CASE ASIS
    TITLE OFFSET 2
    TITLE SIZE 4
    LABEL CASE ASIS
    TIC MARK LABEL SIZE 4
    TIC MARK OFFSET UNITS SCREEN
    TIC MARK OFFSET 5 5
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    SET 4PLOT MULTIPLOT ON
    .
    CHARACTER X
    LINE BLANK
    4-PLOT RES
    .
    CASE ASIS
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT 4-Plot for Residuals from BERGER1.DAT

-----6-PLOT--------------------------------------
 
6 PLOT
 
Name:
    6-PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generate 6 plots on the same page that are useful after a fit.
 
Description:
    This plot is used after some type of fit to generate some of the
    most common diagnostic plots in a convenient way.  The plots are:
        1) observed and fitted dependent values against the independent
           variable (the observed values are automatically drawn using
           the plot symbol X while the predicted values are drawn as a
           solid line);
        2) the residuals versus the independent variable (uses whatever
           the current settings are for the LINE and CHARACTERS
           commands);
        3) the residuals versus the predicted  values (uses whatever the
           current settings are for the LINE and CHARACTERS commands);
        4) a lag plot of the residuals (uses an X as the plot symbol);
        5) a histogram of the residuals;
        6) and a normal probability plot of the residuals.
    The 6-PLOT command does not perform a fit.  It assumes that this has
    been done in a prior command and that the PRED and RES variables
    are the results from that fit.  The dependent variable and the
    independent variable used in the fit are given as the 2 arguments to
    the 6-PLOT command.  If a multi-variable fit was performed, specify
    the independent variable you want to use on the horizontal axis for
    the first 2 plots (plots against the remaining indepdendent
    will have to be generated with additional PLOT commands).
 
Syntax:
    6-PLOT <y> <x>    <SUBSET/EXCEPT/FOR qualification>
    where <y> is the dependent variable that was used in the most recent
              fit;
          <x> is an independent variable used in the most recent fit;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    6-PLOT Y X
    6-PLOT RUN1
    6-PLOT Y1 SUBSET TAG = 1
 
Note:
    If a fit has not yet been performed, Dataplot does not automatically
    generate one (and so the PRED and RES variables still contain all
    zero values).
 
Note:
    Various commands generate updated values for RES and PRED.
    Specifically, LOWESS, SMOOTH, SPLINE FIT, and several others
    automatically update these variables.  Be sure that the fit you want
    to plot was the most recent command to update the RES and PRED
    variables before entering the 6-PLOT command.
 
Note:
    By default, the 6-PLOT command ignores the MULTIPLOT CORNER
    COORDINATE settings.  That is, the 6-plot will be generated
    as if the following command had been entered

         MULTIPLOT CORNER COORDINATES 15 20 85 90

    If you want the 6-PLOT command to utilize the settings from
    the MULTIPLOT CORNER COORDINATE command, enter

         SET 6PLOT MULTIPLOT ON

    To restore the default of ignoring the MULTIPLOT CORNER
    COORDINATE settings, enter

         SET 6PLOT MULTIPLOT OFF

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FIT               = Performs a least squares linear or non-linear
                        fit.
    LOWESS            = Performs a locally weighted least square
                        regression.
    SMOOTH            = Smooth a time series.
    SPLINE FIT        = Performs a spline fit.
    ANOVA             = Performs an analysis of variance.
    MEDIAN POLISH     = Performs a median polish.
    RUN SEQUENCE PLOT = Generates a run sequence plot.
    LAG PLOT          = Generates a lag plot.
    HISTOGRAM         = Generates a histogram.
    NORMAL PROB PLOT  = Generates a normal probability plot.
    PLOT              = Generates a data or function plot.
    MULTIPLOT         = Allows multiple plots per page
 
Applications:
    Exploratory Data Analysis
 
Implementation Date:
    1993/12
    2002/03: Added SET 6PLOT MULTIPLOT command
 
Program:
    . ALASKA PIPELINE RADIOGRAPHIC DEFECT BIAS CURVE
    . PERFORM A LINEAR REGRESSION
    SKIP 25
    READ BERGER1.DAT TRUE MEAS
    FIT MEAS TRUE
    TITLE AUTOMATIC
    TITLE SIZE 4
    CHARACTER CIRCLE
    CHARACTER SIZE 2.5
    TIC MARK LABEL SIZE 4
    CHARACTER FILL ON
    LINE BLANK SOLID
    SET 6PLOT MULTIPLOT ON
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    6-PLOT MEAS TRUE
 
-----=-------------------------------------------------------

=

Name:
    =

Type:
    Keyword

Purpose:
    A mathematical symbol denoting equality which serves 4 separate
    functions:
       1) In conjunction with the LET command, it links output (on the
          left) with input or operation (on the right).
       2) In conjunction with the ROOTS sub-command under the LET
          command it allows functions to be written as the
          corresponding equations.
       3) In conjunction with SUBSET, EXCEPT and FOR, it is optionally
          included after the SUBSET, EXCEPT and FOR keywords.
       4) It is used as a logical operator for the IF command to test
          for equality.

Syntax:
    xx

Examples:
    LET Y = (X**LAMBDA-1)/LAMBDA
    LET A = MEAN Y
    LET Y2 = SORT Y1
    LET FUNCTION F1 = C*EXP(-0.5*X*X)
    LET FUNCTION G = DERIVATIVE F1/F2 WRT X
    LET R = ROOTS X=EXP(-X) WRT X FOR X=0 2
    LET Y = ROOTS F1=F2 WRT X FOR X = 0 100
    PLOT Y1 Y2 VERSUS X SUBSET LAB = 4
    FIT A+EXP(-B*X) EXCEPT X = 0 TO 32
    PLOT SIN(X) FOR X = 0 TO 6.28
    3D-PLOT X*Y FOR X=0 TO 5 FOR Y=0 TO 5
    LET A=INTEGRAL LOG(X) WRT X FOR X=1  2
    PLOT Y1 Y2 Y3 VERSUS X FOR I = 1 TO 30
    FIT (A+B*X)/(C+D*X) FOR I = 101 TO 200
    HISTOGRAM Y FOR I = 20 TO 50
    IF A = B

Default:
    None

Synonyms:
    None

Related Commands:
    <>       = A keyword denoting inequality.
    <        = A keyword denoting less than.
    <=       = A keyword denoting less than or equal to.
    >        = A keyword denoting greater than.
    >=       = A keyword denoting greater than or equal to.

Applications:
    XX

Implementation Date:
    XX

Program:
    XX
 
-----<>------------------------------------------------------

<>

Name:
    <>

Type:
    Keyword

Purpose:
    A mathematical symbol denoting "not equal to" which serves 2
    separate functions:
       1) In conjunction with the SUBSET, EXCEPT, and FOR, it  is
          optionally included after the SUBSET, EXCEPT, and FOR 
          keywords.
       2) It is used as a logical operator for the IF command to test
          for inequality.

Syntax:
    None

Examples:
    PLOT Y X SUBSET Y <> 1000
    BOX PLOT Y LAB SUBSET LAB <> 5
    FIT Y = A+B*LOG(C+X) EXCEPT X <> 0
    LET A  MEAN Y SUBSET Y <> 100
    IF A <> B

Default:
    None

Synonyms:
    None

Related Commands:
    =        = A keyword denoting equality.
    <        = A keyword denoting less than.
    <=       = A keyword denoting less than or equal to.
    >        = A keyword denoting greater than.
    >=       = A keyword denoting greater than or equal to.

Applications:
    XX

Implementation Date:
    XX

Program:
    XX
 
-----<-------------------------------------------------------

<

Name:
    <

Type:
    Keyword

Purpose:
    A mathematical symbol denoting "less than" which serves 2 separate
    functions:
       1) In conjunction with the SUBSET, EXCEPT, and FOR, it  is
          optionally included after the SUBSET, EXCEPT, and FOR 
          keywords.
       2) It is used as a logical operator for the IF command to test
          for less than.

Syntax:
    None

Examples:
    PLOT Y X SUBSET Y < 1000
    BOX PLOT Y LAB SUBSET LAB < 5
    FIT Y = A+B*LOG(C+X) EXCEPT X < 0
    LET A  MEAN Y SUBSET Y < 100
    IF A < B

Default:
    None

Synonyms:
    None

Related Commands:
    =        = A keyword denoting equality.
    <>       = A keyword denoting inequality.
    <=       = A keyword denoting less than or equal to.
    >        = A keyword denoting greater than.
    >=       = A keyword denoting greater than or equal to.

Applications:
    XX

Implementation Date:
    XX

Program:
    XX
 
-----<=------------------------------------------------------

<=

Name:
    <=

Type:
    Keyword

Purpose:
    A mathematical symbol denoting "less than or equal to" which serves
    2 separate functions:
       1) In conjunction with the SUBSET, EXCEPT, and FOR, it  is
          optionally included after the SUBSET, EXCEPT, and FOR 
          keywords.
       2) It is used as a logical operator for the IF command to test
          for less than or equal to.

Syntax:
    None

Examples:
    PLOT Y X SUBSET Y <= 1000
    BOX PLOT Y LAB SUBSET LAB <= 5
    FIT Y = A+B*LOG(C+X) EXCEPT X <= 0
    LET A  MEAN Y SUBSET Y <= 100
    IF A <= B

Default:
    None

Synonyms:
    None

Related Commands:
    =        = A keyword denoting equality.
    <>       = A keyword denoting inequality.
    <        = A keyword denoting less than.
    >        = A keyword denoting greater than.
    >=       = A keyword denoting greater than or equal to.

Applications:
    XX

Implementation Date:
    XX

Program:
    XX
 
----->-------------------------------------------------------

>

Name:
    >

Type:
    Keyword

Purpose:
    A mathematical symbol denoting "greater than" which serves two
    separate functions:
       1) In conjunction with the SUBSET, EXCEPT, and FOR, it  is
          optionally included after the SUBSET, EXCEPT, and FOR 
          keywords.
       2) It is used as a logical operator for the IF command to test
          for greater than.

Syntax:
    None

Examples:
    PLOT Y X SUBSET Y > 1000
    BOX PLOT Y LAB SUBSET LAB > 5
    FIT Y = A+B*LOG(C+X) EXCEPT X > 0
    LET A  MEAN Y SUBSET Y > 100
    IF A > B

Default:
    None

Synonyms:
    None

Related Commands:
    =        = A keyword denoting equality.
    <>       = A keyword denoting inequality.
    <        = A keyword denoting less than.
    <=       = A keyword denoting less than or equal to.
    >=       = A keyword denoting greater than or equal to.

Applications:
    XX

Implementation Date:
    XX

Program:
    XX
 
----->=------------------------------------------------------

>=

Name:
    >=

Type:
    Keyword

Purpose:
    A mathematical symbol denoting "greater than or equal to" which
    serves 2 separate functions:
       1) In conjunction with the SUBSET, EXCEPT, and FOR, it  is
          optionally included after the SUBSET, EXCEPT, and FOR 
          keywords.
       2) It is used as a logical operator for the IF command to test
          for greater than or equal to.

Syntax:
    None

Examples:
    PLOT Y X SUBSET Y >= 1000
    BOX PLOT Y LAB SUBSET LAB >= 5
    FIT Y = A+B*LOG(C+X) EXCEPT X >= 0
    LET A  MEAN Y SUBSET Y >= 100
    IF A >= B

Default:
    None

Synonyms:
    None

Related Commands:
    =        = A keyword denoting equality.
    <>       = A keyword denoting inequality.
    <        = A keyword denoting less than.
    <=       = A keyword denoting less than or equal to.
    >        = A keyword denoting greater than.

Applications:
    XX

Implementation Date:
    XX

Program:
    XX
 
-----.-------------------------------------------------------
 
.
 
Name:
    .
 
Type:
    Support Command
 
Purpose:
    Designates the current line to be a command that will not be
    executed.
 
Description:
    The "." command is used to put descriptive remarks into a Dataplot
    program (or simply to delineate sections of code).  It is
    equivalent to a C in FORTRAN and a REM in BASIC.  The "." comment
    is identical to the COMMENT command, with the "." being the
    preferred way to enter comment lines.  As with all Dataplot
    commands, the command must be separated from any other text on the
    line by at least one space.  The typical uses for the "." command
    are:
       1) to enter comments in a Dataplot program; e.g.,
             . ANALYZE THE CALIBRATION DATA
             PLOT Y X
             ANOVA Y X
       2) to "comment out" an existing command so that it will not be
          active but the analyst will still have a record of it in the
          program; e.g.,
             . FONT TRIPLEX
       3) to insert a visual separator that will partition a program
          into logical chunks that may be more easily perused; e.g.,
             READ CALIB. Y X
             .
             TITLE CALIBRATION ANALYSIS
             Y1LABEL CONCENTRATION
             X1LABEL TEMP
             PLOT Y X
             FIT Y=A+B*X
             .
             CHARACTERS X BLANK
             LINES BLANK SOLID
             PLOT Y PRED VERSUS X
             PLOT RES X
 
Syntax:
    .   <any text>
 
Examples:
    . STRESS ANALYSIS
    . 10/7/79
    . ANALYSIS OF SPECIMEN 4
 
Note:
    The COMMENT CHARACTER command can be used to define an additional
    character to be used as a comment.  Although this command is
    intended primarily for data files, it applies to commands as well.
 
Note:
    The semi-colon is the default separator character.  That is, it
    allows multiple commands to be placed on a single line.  A
    semi-colon in a comment line causes the remaining characters to
    be interpreted as a distinct command.  If you want to use the
    semi-colon in your comment lines, use the TERMINATOR CHARACTER
    command to define another character as the command separator.
 
Default:
    None
 
Synonyms:
    COMMENT
 
Related Commands:
    COMMENT CHARACTER   = Define a character that denotes a comment.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XX
 
-----...-------------------------------------------------------

...

Name:
    ...

Type:
    Support Command

Purpose:
    The occurrence of ... at the end of a line signifies that a command
    is continued onto the next line.

Description:
    The ... keyword allows a long command statement to be broken into
    two lines.  Command statements can be at most 2 lines long.  Any
    spaces immediately before the "..." and at the beginning of the
    next line are part of the command.  As long as there at least one
    space between command arguments, the number of spaces is only
    relevant for text strings (e.g., TITLE, LEGEND, LABEL commands).

    This keyword is most often used for entering long strings with 
    the TITLE, TEXT, LEGEND, and LABEL commands (particularly if it
    contains a large number of () sequences).  The CASE ASIS option
    (see the documentation for TITLE CASE, CASE, LABEL CASE, LEGEND
    CASE, etc.) allows upper and lower case shifts without entering
    UC() and LC() in the string.  This alleviates the most reason
    for long lines.

Syntax:
    None

Examples:
    CHARACTERS SOLID SOLID SOLID SOLID DOT...
              DOT DOT DOT DASH DASH DASH DASH
    3D-PLOT EXP(-0.5*(X**2+Y**2)) FOR X =...
            -2 .2 2 FOR Y = -2 .2 2

Note:
    Unfortunately, saved commands only save the first 80 characters.
    Specifically, this means commands inside a loop are limited to 80
    characters (any characters beyond that are simply truncated)
    even if the command is continued onto another line.  Also, commands
    saved by the SAVE or REPEAT command have the same restriction.

Default:
    None

Synonyms:
    None

Related Commands:
    CONTINUE CHARACTER   = Set the continuation character.
    ;                    = Keyword signifying the end of a command.

Applications:
    XX

Implementation Date:
    XX

Program:
    XX
 
-----;-------------------------------------------------------

;

Name:
    ;

Type:
    Keyword

Purpose:
    This is the default separator character.

Description:
    The ; is the character which automatically terminates the command
    statement.  Thus multiple command statements can be "packed" on a
    single line.  Hence
       READ ABC. X Y; PLOT Y X; FIT Y = A+B*X
       PLOT RES X; SMOOTH Y; PLOT RES X;
       HISTOGRAM RES
    is equivalent to
       READ ABC. X Y
       PLOT Y X
       FIT Y=A+B*X
       PLOT RES X
       SMOOTH Y
       PLOT RES X
       HISTOGRAM RES
    In another vein, the joint use of
       1) the ; "command" (to terminate commands), and
       2) the . command (to enter comments)
    allows the analyst to insert in-line comments, as in
       READ CALIB. Y X LAB       ;. READ IN THE DATA
       LINES SOLID SOLID DOT DOT ;. DEFINE LINES
       CHARACTERS 1 2 1 2        ;. DEFINE CHARACTERS
       PLOT Y X LAB              ;. GENERATE MULTI-TRACE PLOT
       ANOVA Y X LAB             ;. 2-WAY ANOVA
       PLOT RES X                ;. PLOT RESIDUALS
       PLOT RES LAB              ;. PLOT RESIDUALS
    This capability receives only light usage because Dataplot
    programs are self-documenting due to the English-syntax command
    structure.

    If the analyst wishes to change the terminator character from a
    semi-colon to some other choice, then use the TERMINATOR CHARACTER
    command, as in:
       TERMINATOR CHARACTER #

Syntax:
    None

Examples:
    READ CALIB. Y X;PLOT Y X;EXIT
    CHARACTERS X;LINES BLANK;LAG 1 PLOT Y
    FIT Y=A+B*X;PLOT Y PRED VS X;PLOT RES X

Note:
    Be careful that if a text line (e.g., TITLE, LEGEND, LABEL)
    contains a semi-colon character that you use the TERMINATOR
    CHARACTER command to change the default terminator character.

Default:
    In the absence of a semi-colon, the usual carriage return 
    terminates the command statement.

Synonyms:
    None

Related Commands:
    .                     = Denotes a comment line.
    ...                   = Specifies that a command continues onto
                            the next line.
    TERMINATOR CHARACTER  = Change the character that denotes the end
                            of the command.

Applications:
    XX

Implementation Date:
    XX

Program:
    XX
 
-----^-------------------------------------------------------

^

Name:
    ^

Type:
    Keyword

Purpose:
    This is the default substitution character.

Description:
    The ^ signifies that the following parameter name should be
    replaced with the value of that parameter.

Syntax:
    None

Examples:
    LET STRING FNAME = CALIB.DAT
    READ ^FNAME X1 X2 X3
 
    LOOP FOR K = 1 1 10
       PLOT Y^K
    END OF LOOP

Note:
    The substitute character can be used effectively with the LOOP
    command.  For example, assume that variables Y1 thru YN and
    strings S1 and SN have been previously defined:
        LOOP FOR K = 1 1 N
            TITLE Y^K VS X
            LEGEND 1 ^S^K
            PLOT Y^K VS X
        END OF LOOP
    Note the distinction between Y^K in the PLOT command and ^S^K in
    the LEGEND command.  For the plot command, we want PLOT Y1 VS X 
    while for the LEGEND command we want to insert the value of the
    string S1.  This is the reason that the Y^K has no preceding ^
    while the ^S^K does.

Note:
    The following characters are used to determine the end of the
    parameter name:
               - a space
       (       - a left parenthesis
       )       - a right parenthesis
       "       - a quote character
       &       - an ampersand character
       .       - a period
       ^       - another substitute character
       ,       - a comma
       :       - a colon
       ;       - a semi-colon
       ]       - a right bracket
       +       - a plus
       -       - a minus
       *       - an asterisk
       /       - a forward slash

Note:
    The substitution is performed before the command is interperted.

Note:
    If the parameter is undefined, it is replaced with a space
    character in the command line.

Note:
    The substitution is done on a parameter name.  To replace an
    element of a variable, do something like the following:
        LET TEMP=X(22)
        LEGEND 1 DATA VALUE = ^TEMP

Note:
    The substitution can be nested.  This is demonstrated in the 
    program segment in an above NOTE section (TITLE ^S^K).  Nesting
    more than 2 deep is rare.

Note:
    The VALU() sequence is equivalent to ^ in text strings (e.g, TEXT,
    LEGEND, TITLE, or LABEL commands). The EXECUTE STRING command can
    perform some string substitutions.  However, the ^ is more general
    since it can be used in any command (the substitution is performed
    before the command is passed to routines that process individual
    commands).  For this reason, the VALU() keyword and the EXECUTE
    STRING command are obsolete.

Default:
    None

Synonyms:
    None

Related Commands:
    SUBSTITUTE CHARACTER    = Define the substitute character.
    VALU()                  = Replace in a text string.
    LOOP                    = Execute a sequential loop.

Applications:
    XX

Implementation Date:
    XX

Program:
    LET Y1 = NORMAL RANDOM NUMBER FOR I = 1 1 100
    LET Y2 = EXPONENTIAL RANDOM NUMBERS FOR I = 1 1 100
    LET NU = 20
    LET Y3 = T RANDOM NUMBERS FOR I = 1 1 100
    LET Y4 = CAUCHY RANDOM NUMBERS FOR I = 1 1 100
    LET STRING T1 = NORMAL RANDOM NUMBERS
    LET STRING T2 = EXPONENTIAL RANDOM NUMBERS
    LET STRING T3 = T RANDOM NUMBERS
    LET STRING T4 = CAUCHY RANDOM NUMBERS
    LET X = SEQUENCE 1 1 100
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    LOOP FOR K = 1 1 4
       TITLE ^T^K
       HISTOGRAM Y^K
    END OF LOOP
    END OF MULTIPLOT
 
-----&-------------------------------------------------------

&

Name:
    &

Type:
    Keyword

Purpose:
    This keyword is used to concatenate two previously created strings.

Description:
    Strings are created with either the READ STRING command or the
    LET STRING command.  The READ STRING can read strings either
    from the terminal or from a file.  Another distinction is that
    READ STRING preserves the case of the string while LET STRING
    converts all characters to upper case.

    The & keyword is restricted to the LET STRING case.  If you want
    to both preserve the case and to concatenate strings, do
    something like the following:
       SET IO TERMINAL
       WRITE "Enter file to use (e.g., cube01):"
       READ STRING S
       SET IO
       READ STRING Z
       .dat
       READ STRING F
       ^s^z
       READ ^F  FIELD TEMP MZAVG MAVG

Syntax:
    None

Examples:
    LET STRING FNAME = CALIB.DAT
    LET STRING PATH = /usr/nist/heckert/datafiles/
    LET STRING NAME = ^PATH&^FNAME
    READ ^NAME X1 X2 X3

Note:
    When concatenating strings, uou need to use the substitution
    character (^) in front of the strings.  For example, given
        LET STRING A = CUBE01
        LET STRING B = .DAT
    then the following
        LET STRING C = ^A&^B
    generates the string CUBE01.DAT.  However,
        LET STRING D = A&B
    generates the string A&B.

Note:
    The following commands
        LET STRING A = CUBE01
        LET STRING C = ^A&.DAT
    generate the string CUBE01.DAT as expected.  However, the
    following command
        LET STRING A = CUBE01&.DAT
    generates the string CUBE01&.DAT instead of CUBE01.DAT. 

Note:
    More than one concatenation character can appear on a line.

Note:
    Dataplot does not at this time support commands for extracting
    a subset of a string or for returning the number of characters in
    an already existing string.

Default:
    None

Synonyms:
    None

Related Commands:
    LET STRING    = Define a string.
    READ STRING   = Read a string.
    ^             = Substitute the value of a string or a parameter
                    into a command.

Applications:
    XX

Implementation Date:
    XX

Program:
    XX
 
-----()--------------------------------------------------------

()

Name:
    ()

Type:
    Keyword

Purpose:
    The occurrence of () in a text string for the LEGEND, TITLE, LABEL,
    or TEXT commands indicates the use of Greek letters, special math
    symbols, case switching, font switching, or sub and superscripting.

Description:
    The list of available special symbols can be obtained by entering
    one of the following commands:
         HELP GREEK SYMBOLS
         HELP MATH SYMBOLS
         HELP MISC SYMBOLS
         HELP SUBSCRIPTS
         HELP CAPITALIZATION

Syntax:
    None

Examples:
    TITLE LC()USE A LOWER CASE TITLE
    Y1LABEL ESUP()ALPH()

Note:
    Most of the special symbols require the use of a software font.
    The default font, TEKTRONIX, specifies the use of hardware 
    characters.  Only the case shifts UC() and LC() and the space
    character SP() are recognized when hardware characters are used.
    If one of the other special symbols is encountered when a hardware
    character is in effect, it is converted to a space (earlier 
    versions simply print the characters as ASCII text).  Enter the
    command HELP FONT for a list of available fonts.

Note:
    Some versions may have a bug where the special symbols are not
    recognized if they are entered in lower case (e.g., alph() instead
    of ALPH()).  This bug should be fixed in current versions.

Default:
    None

Synonyms:
    None

Related Commands:
    FONT     = Specify the desired text font.
    TEXT     = Draws a text string immediately.
    LEGEND   = Draws a text string on subsequent plots.
    TITLE    = Specify the plot title.
    LABEL    = Specify the axes labels.

Applications:
    XX

Implementation Date:
    XX

Program:
    font duplex
    case upper
    move 5 90
    text ulc()pper case uc()glc()reek characters (duplex font):
    move 10 85 
    text alph() beta() gamm() delt() epsi() zeta() eta() thet() iota()
    move 10 80 
    text kapp() lamb() mu() nu() xi() omic() pi() rho() sigm() tau() upsi()
    move 10 75
    text phi() chi() psi() omeg()
    move 5 50
    text llc()ower case uc()glc()reek characters (duplex font):
    case lower
    move 10 45 
    text alph() beta() gamm() delt() epsi() zeta() eta() thet() iota()
    move 10 40 
    text kapp() lamb() mu() nu() xi() omic() pi() rho() sigm() tau() upsi()
    move 10 35
    text phi() chi() psi() omeg()
 
-----/-------------------------------------------------------

/

Name:
    /

Type:
    Support Command

Purpose:
    Re-execute saved commands.  Optionally, the alphanumeric output
    from the re-executed commands can be sent to a file or a printer.

Description:
    The SAVE (or S) command allows a single command or a list of
    commands to be saved.  Entering / allows these commands to be
    re-executed with a single keystroke.

Syntax 1:
    /

    This syntax re-executes the saved commands and sends the resulting
    alphanumeric output to the terminal screen.

Syntax 2:
    / LP
    / LPT1
    / PRINTER

    This syntax re-executes the saved commands and sends the resulting
    alphanumeric output to the printer rather than the terminal screen.
    Graphics output is still determined by the settings for the DEVICE
    1, DEVICE 2, and DEVICE 3 commands.

    This syntax is operating system dependent.  It has been implemented
    for the following systems:
       IBM PC/386
       Unix
       Cyber NOS/VE
       VAX/VMS (coded but not tested)
    Contact your local site installer if you would like this command
    implemented on your system.

    This command sends output to the default printer.  On the PC, this
    is printer port 1.  For Unix, enter the setenv PRINTER command
    before entering Dataplot.

Syntax 3:
    / <filename>
    where <filename> is the name of a file.

    This syntax re-executes the saved commands and sends the resulting
    alphanumeric output to <filename> rather than the terminal screen.
    Graphics output is still determined by the settings for the DEVICE
    1, DEVICE 2, and DEVICE 3 commands.

    This syntax is operating system dependent.  It has been implemented
    for the following systems:
       IBM PC/386
       Unix
       Cyber NOS/VE
       VAX/VMS (coded but not tested)
    Contact your local site installer if you would like this command
    implemented on your system.

Examples:
    / PLOTCALIB.
    / PROG.PLOTLAB

Default:
    None

Synonyms:
    None

Related Commands:
    SAVE          = Save a list of commands.
    LIST          = List the previous 20 commands.

Applications:
    XX

Implementation Date:
    Pre-1987

Program:
    XX
 
---------------------------------------------------------
 
 
 
 
 
 
 
 
 
 
 
 
 






























































-END -----*-----      ----------------ZZZZZ------
