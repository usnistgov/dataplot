 80600.    (VERSION 2023.10)   total number of lines in file (including this line)
 8.                          number of     sections below
  100.    D                  first line number of D section
18700.    E                  first line number of E section
27800.    F                  first line number of F section
37900.    G                  first line number of G section
55900.    H                  first line number of H section
63200.    I                  first line number of I section
72500.    J                  first line number of J section
74500.    K                  first line number of K section

----------------------------------------------------------
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
-------------------------  *D*  ZZZZZ--------------------
 
-----DATA (LET)---------------------------------------------------
 
DATA
 
Name:
    DATA (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Insert a list of numbers into a DATAPLOT variable.  This is a quick
    way to read a small group of numbers.
 
Syntax:
    LET <xvar> = DATA <list>
    where <xvar> is a variable;
    and   <list> is a list of numbers and parameters of arbitrary
                 length.
 
Examples:
    LET X1 = DATA 1 3 5 7 3 1 5 9 0 -1 4 5
    LET A = 2; LET X1 = DATA 3 4 5 A 4 3 A 2 1 A
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    READ           = Read data from file or terminal.
    SERIAL READ    = Read data serially from file or terminal.
    SEQUENCE       = Generate a sequence of numbers.
    PATTERN        = Generate numbers with a specific pattern.
 
Applications:
    Data Input
 
Implementation Date:
    Pre-1987
 
Program:
    LET Y = DATA 23  45  65  48  17
    LET X = DATA  1   2   3   4   5
    BAR ON
    LINE OFF
    PLOT Y X
 
-----DATA MISSING VALUE (SET)-------------------------------------------
 
DATA MISSING VALUE (SET)
 
Name:
    DATA MISSING VALUE (SET)
 
Type:
    Subcommand under SET
 
Purpose:
    Specifies a character sequence that will be interpreted
    as a missing value.
 
Description:
    Some software programs will have special characters to denote
    missing values.  Missing value flags are specific to individual
    programs.  You can specify a character string that denotes a
    missing value with the command

      SET DATA MISSING VALUE <value>

    where <value> is a string with 1 to 4 characters.  If Dataplot
    encounters <value> in a numeric field, it will convert it to the
    Dataplot "missing value".  The missing value string is not case
    sensitive.  You can specify what Dataplot will use for the missing
    value by entering the command

      SET READ MISSING VALUE  <value>

    where <value> is a numeric value.  The default is 0.

    The example program demonstrates how to convert "MV" to the
    machine minimum value.

Syntax:
    SET DATA MISSING VALUE  <string>
    where <string> is a character string that has from 1 to 4 characters.
 
Examples:
    SET DATA MISSING VALUE MV
    SET DATA MISSING VALUE ZZZZ

Note:
    Currently, only a single missing value flag is supported.  If
    the data file has multiple flags for missing values, the only
    current solution is to manually edit the file and replace the
    character values with numeric values.

    The string "NAN" (not case sensitive) is automatically searched.
    This is interpreted as an undefined number (this is the value
    used to print an undefined number on many systems).

Note:
    The SET DATA MISSING VALUE and the SET READ MISSING VALUE
    commands are related, but distinct.  The SET DATA MISSING VALUE
    command specifies a string that will be interpreted to denote
    a missing value when reading a data set while SET READ MISSING
    VALUE specifies the numeric value that will be used when a
    missing value is encountered.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    READ                = Carries out a column-wise input of data.
    READ MISSING VALUE  = Specifies the numeric value that will
                          be used when an empty,  missing, or undefined
                          value is encountered in a numeric field.
    ASCII FILES         = Guidance for reading ASCII files in
                          Dataplot.
 
Applications:
    Input/Output
 
Implementation Date:
    2009/4
 
Program:
    SET DATA MISSING VALUE MV
    PROBE CPUMIN
    LET AVAL = PROBEVAL
    SET READ MISSING VALUE AVAL
 
-----DATASETS-------------------------------------------------------
 
DATASETS
 
Name:
    DATASETS
 
Type:
    Keyword
 
Purpose:
    Symbolic name for DATAPLOT's data sets file.  It is used with the
    SEARCH and LIST commands.
 
Description:
    The DATAPLOT distribution files come with a large number of on-line
    data files.  These data files are stored in the DATAPLOT directory
    (the same directory where the on-line help files are stored).
    These files can be accessed by the READ and SERIAL READ commands
    without specifying the full path name.  The data sets file lists
    the sample on-line data files in alphabetical order.  It is a
    subset of the dictionary file.  The dictionary file also includes
    command names, macro files, and program files.
 
Syntax:
    None
 
Examples:
    SEARCH DATASETS ABC.DAT
    LIST DATASETS FOR I = 1 1 35
 
Note:
    The DATASETS file is stored in the DATAPLOT directory.  It has the
    name DATASETS (or datasets for Unix systems).  The exact file name
    and the directory where it is stored can vary depending on the
    installation (see your local DATAPLOT implementor to find the exact
    name on your system).
 
Note:
    If DATAPLOT is unable to open the command file, it is most likely
    because the DATAPLOT directory name is not specified correctly in
    the local DATAPLOT code.  See your local DATAPLOT implementor to
    have this corrected.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SEARCH        = Search a file for a string.
    LIST          = Lists the contents of a file.
    DIRECTORY     = Symbolic name for DATAPLOT's directory file.
    DICTIONAY     = Symbolic name for DATAPLOT's dictionary file.
    COMMANDS      = Symbolic name for DATAPLOT's commands file.
    DESIGNS       = Symbolic name for DATAPLOT's design of experiments
                    file.
    SYNTAX        = Symbolic name for DATAPLOT's syntax file.
    MACROS        = Symbolic name for DATAPLOT's macros file.
    PROGRAMS      = Symbolic name for DATAPLOT's programs file.
    DISTRIBU      = Symbolic name for DATAPLOT's distributions file.
    FUNCTION      = Symbolic name for DATAPLOT's function file.
 
Applications:
    XX
 
Implementation Date:
    93/12
 
Program:
    XX
 
-----DAVID TEST------------------------------------
 
DAVID TEST
 
Name:
    DAVID TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform the David, Hartley and Pearson test for univariate outliers
    from a normal distribution.
 
Description:
    The David, Hartley and Pearson statistic tests whether the minimum
    and maximum values from a univariate dataset are simultaneously
    outliers.  This test assumes that the data come from an approximately
    normal distribution.

    The test statistic is

        D = r/s

    with r and s denoting the sample range and sample standard deviation,
    respectively.

    Dataplot supports several methods for deterining the critical values
    for this test.

       1. The ASTM E178-16a standard provides tables for n = 3 to 50
          and alpha levels of 0.10, 0.05 and 0.01.  Linear interpolation
          is used for values of n not given in the table.  For values of
          n > 50, the simulation (see below) method is used.

       2. The original paper by David contains tables for n = 3 to
          1,000 and alpha levels of 0.10, 0.05, 0.025, 0.01 and 0.005.
          Linear interpolation is used for values of n not given in the
          table.

       3. The David paper suggests the following formula (equation 6
          on page 485)

             cv = SQRT[{2*(n-1)*t((1-alpha)/(n*(n-1)),n-2)}/
                       {(n-2) + t((1-alpha)/(n*n-1)),n-2)}]

          with t denoting the percent point function of the t
          distribution.

       4. Critical values can be obtained via simulation.  

    To specify the method used to compute the critical value, enter
    one of the following commands (the default is ASTM)

        SET DAVID TEST CRITICAL VALUES ASTM
        SET DAVID TEST CRITICAL VALUES DAVID
        SET DAVID TEST CRITICAL VALUES FORMULA
        SET DAVID TEST CRITICAL VALUES SIMULATION

    This test is included in the ASTM E178 standard for outliers.

Syntax 1:
    DAVID TEST  <y>  <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable being tested;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Syntax 2:
    MULTIPLE DAVID TEST <y1> ... <yk>   
                        <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of up to k response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax performs the David test on <y1>, then on <y2>, and so
    on.  Up to 30 response variables may be specified.

    Note that the syntax

         MULTIPLE DAVID TEST Y1 TO Y4

    is supported.  This is equivalent to

         MULTIPLE DAVID TEST Y1 Y2 Y3 Y4

Syntax 3:
    REPLICATED DAVID TEST <y> <x1> ... <xk>   
                          <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <x1> ... <xk> is a list of up to k group-id variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax performs a cross-tabulation of <x1> ... <xk> and performs
    a David test for each unique combination of cross-tabulated values.
    For example, if X1 has 3 levels and X2 has 2 levels, there will be a
    total of 6 David tests performed.

    Up to six group-id variables can be specified.

    Note that the syntax

         REPLICATED DAVID TEST Y X1 TO X4

    is supported.  This is equivalent to

         REPLICATED DAVID TEST Y X1 X2 X3 X4

Examples:
    DAVID TEST Y1
    MULTIPLE DAVID TEST Y1 Y2 Y3
    REPLICATED DAVID TEST Y X1 X2
    DAVID TEST Y1   SUBSET TAG > 2

Note:
    Tests for outliers are dependent on knowing the distribution of
    the data.  The David test assumes that the data come from an
    approximately normal distribution.  For this reason, it is
    strongly recommended that the David test be complemented with
    a normal probability test.  If the data are not approximately
    normally distributed, then the David test may be detecting
    the non-normality of the data rather than the presence of an
    outlier.

Note:
    You can specify the number of digits in the David output with
    the command

        SET WRITE DECIMALS <value>

Note:
    The DAVID TEST command automatically saves the following
    parameters:

       STATVAL    = the value of the test statistic
       STATDCF    = the CDF value of the test statistic
       PVALUE     = the p-value of the test statistic
       CUTOFF80   = the 80 percent point of the reference distribution
       CUTOFF90   = the 90 percent point of the reference distribution
       CUTOFF95   = the 95 percent point of the reference distribution
       CUTOF975   = the 97.5 percent point of the reference distribution
       CUTOFF99   = the 99 percent point of the reference distribution

    The STATCDF and PVALUE are only saved when the simulation method
    is used to obtain critical values.  If the ASTM method is used to
    obtain critical values, the CUTOFF80 and CUTOF975 values are not
    saved.  When the DAVID method is used to obtain critical values,
    the CUTOFF80 value is not saved.

    If the MULTIPLE or REPLICATED option is used, these values will
    be written to the file "dpst1f.dat" instead.

Note:
    In addition to the DAVID TEST command, the following commands
    can also be used:

        LET A = DAVID TEST Y
        LET A = DAVID TEST CDF Y
        LET A = DAVID TEST PVALUE Y
        LET A = DAVID TEST MINIMUM INDEX Y
        LET A = DAVID TEST MAXIMUM INDEX Y

        LET ALPHA = <value>
        LET A = DAVID TEST CRITICAL VALUE Y

    The DAVID TEST, DAVID TEST CDF, and DAVID TEST PVALUE return the
    values of the test statistic, the cdf of the test statistic and
    the pvalue of the test statistic, respectively.  For the
    DAVID TEST CDF and DAVID TEST PVALUE commands, the simulation method
    will be used.  Otherwise, the method specified by the
    SET DAVID TEST CRITICAL VALUE command will be used.

    The DAVID TEST MINIMUM INDEX and DAVID TEST MAXIMUM INDEX return the
    row index of the minimum and maximum values of the response
    variable, respectively.

    The DAVID TEST CRITICAL VALUE returns the critical value for
    the specified value of ALPHA.  If ALPHA is not specified,
    it will be set to 0.05.  Note that if the ASTM or DAVID
    methods are specified for the critical values, only a few select
    values for alpha are supported (0.01, 0.05 and 0.10 for ASTM and
    0.005, 0.01, 0.025, 0.05 and 0.10 for DAVID).

    In addition to the above LET command, built-in statistics are
    supported for about 25 different commands (enter HELP STATISTICS
    for details).

Default:
    The ASTM method is used to obtain critical values
 
Synonyms:
    None
 
Related Commands:
    GRUBBS TEST                 = Perform the Grubbs outlier test.
    TIETJEN-MOORE TEST          = Perform the Tietjen-Moore outlier
                                  test.
    EXTREME STUDENTIZED DEVIATE = Perform the generalized extreme
                                  studentized deviate outlier test.
    DIXON TEST                  = Perform the Dixon outlier test.
    SKEWNESS OUTLIER TEST       = Perform the skewness outlier test.
    KURTOSIS OUTLIER TEST       = Perform the kurtosis outlier test.
    ANDERSON DARLING TEST       = Perform the Anderson-Darling test for
                                  normality.
    WILK SHAPIRO TEST           = Perform the Wilk-Shapiro test for
                                  normality.
    PROBABILITY PLOT            = Generates a probability plot.
    HISTOGRAM                   = Generate a histogram.
    BOX PLOT                    = Generate a box plot.
 
Reference:
    David, Hartley, and Pearson (1954), "The Distribution of the Ratio,
    in a Single Normal Sample, of Range to Standard Deviation",
    Biometrika, Vol. 41, pp. 482-493.

    E178 - 16A (2016), "Standard Practice for Dealing with Outlying
    Observations", ASTM International, 100 Barr Harbor Drive,
    PO Box C700, West Conshohocken, PA 19428-2959, USA.

Applications:
    Outlier Detection
 
Implementation Date:
    2019/10
 
Program:
    . Step 1:   Read the data - example from ASTM E178 standard
    .
    read y
    -1.40
    -0.44
    -0.30
    -0.24
    -0.22
    -0.13
    -0.05
    0.06
    0.10
    0.18
    0.20
    0.39
    0.48
    0.63
    1.01
    end of data
    .
    . Step 2:   Perform the DAVID TEST
    .
    set write decimals 3
    set david test critical values astm
    david test y
    set david test critical values david
    david test y
    set david test critical values formula
    david test y
    set david test critical values simulation
    david test y

-----DAWSON (LET)--------------------------------
 
DAWSON
 
Name:
    DAWSON (LET)
 
Type:
    Library Function
 
Purpose:
    Compute Dawson's integral.
 
Description:
    Dawson's integral is defined as:
        F(x) = EXP(-x**2)*INTEGRAL(EXP(t**2))dt
    where the integral is taken from 0 to x.

Syntax:
    LET <y> = DAWSON(<x>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, variable, or parameter;
          <y> is a variable or a parameter (depending on what <x> is
               where the computed Dawson integral values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DAWSON(0.1)
    LET A = DAWSON(-0.1)
    LET X2 = DAWSON(X)
 
Note:
    DATAPLOT uses the routine DAWS from the SLATEC Common Mathematical
    Library to compute this function.  SLATEC is a large set of high
    quality, portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ERF        = Compute the error function.
    ERFC       = Compute the complementary error function.
    SININT     = Compute the sine integral.
    SININT     = Compute the cosine integral.
    EXPINTN    = Compute the exponential integral of order N.
    LOGINT     = Compute the logarithmic integral.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 7).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE AUTOMATIC
    PLOT DAWSON(X) FOR X = -10 0.1 10
 
-----DEBYE (LET)--------------------------------
 
DEBYE
 
Name:
    DEBYE (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Debye function.
 
Description:
    The Debye function is defined as:

        D(x,n) = (n/x**n)*INTEGRAL[t**n/(EXP(t2) - 1)dt],   x >= 0

    where the integral is defined from 0 to x and
    n, a non-negative integer, is the order of the Debye
    function.  Dataplot supports values of 0, 1, 2, 3, and 4
    for n.

    Dataplot computes this function using ACM Algorithm 757 (see
    Reference: below).
 
Syntax:
    LET <y> = DEBYE(<x>,<ord>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative number, variable or parameter;
          <ord> is a non-negative integer number, parameter, or
               variable in the range 0 to 4; 
          <y> is a variable or a parameter (depending on what <x> 
               and <ord> are) where the computed Debye function
               values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DEBYE(2.3,1)
    LET A = DEBYE(X,A1)
    LET X2 = DEBYE(X1,4) FOR X1 = 0.1 0.1 3.0
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ABRAM      = Compute the Abramowitz function.
    CLAUSN     = Compute the Clausen integral.
    EXP3       = Compute the cubic exponential integral.
    GOODST     = Compute the Goodwin and Stanton integral.
    LOBACH     = Compute the Lobachevski integral.
    SYNCH1     = Compute the synchrotron radiation function.
    SYNCH2     = Compute the synchrotron radiation function.
    STROM      = Compute the Stromgren integral.
    TRAN       = Compute the transport integral.
 
Reference:
    "ACM Transactions of Mathematical Software", Allan MacLead,
    Vol. 22, No. 3, September, 1996, pp. 288-301.
 
Applications:
    Special Functions
 
Implementation Date:
    1999/6
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    TITLE ORDER 0
    PLOT DEBYE(X,0) FOR X = 0 0.01 10
    TITLE ORDER 1
    PLOT DEBYE(X,1) FOR X = 0 0.01 10
    TITLE ORDER 2
    PLOT DEBYE(X,2) FOR X = 0 0.01 10
    TITLE ORDER 3
    PLOT DEBYE(X,3) FOR X = 0 0.01 10
    END OF MULTIPLOT
    MOVE 50 97
    CENTER JUSTIFICATION
    TEXT DEBYE FUNCTIONS
 
-----DECILE (LET)---------------------------------------------------
 
DECILE
 
Name:
    DECILE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute a decile for a variable.
 
Description:
    Deciles are the percentiles that are multiples of 10.  For example,
    the first decile is the point with 10 percent of the data below it
    and 90 percent above it while the ninth decile is the point with 90
    percent of the data below it and 10 percent above it.
 
Syntax:
    LET <par> = <id> DECILE <var>
    where <par> is a parameter where the computed decile is stored;
          <var> is a variable for which the deciles are computed;
    and <id> identifies the decile to compute.
 
    The <id> can be one of the following:
        FIRST     - first decile (or 10th percentile)
        SECOND    - second decile (or 20th percentile)
        THIRD     - third decile (or 30th percentile)
        FOURTH    - fourth decile (or 40th percentile)
        FIFTH     - fifth decile (or 50th percentile)
        SIXTH     - sixth decile (or 60th percentile)
        SEVENTH   - seventh decile (or 70th percentile)
        EIGHTH    - eighth decile (or 80th percentile)
        NINTH     - ninth decile (or 90th percentile)
 
Examples:
    LET A = FIRST DECILE Y1
    LET A = THIRD DECILE Y1
    LET A = FIFTH DECILE Y1
    LET A = SEVENTH DECILE Y1  SUBSET Y1 > 0
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CODE           = Generate a coded variable.
    READ           = Read data from a file or the terminal.
    SERIAL READ    = Read data serially from file the or terminal.
    SEQUENCE       = Generate a sequence of numbers.
    PATTERN        = Generate numbers with a specific pattern.
    MEAN           = Compute a sample mean.
    STANDARD DEVI  = Compute a sample standard deviation.
 
Applications:
    XX
 
Implementation Date:
    XX.X
 
Program:
    LET Y = NORMAL RANDOM NUMBERS FOR I = 1 1 1000
    LET A(1) = FIRST DECILE Y1
    LET A(2) = SECOND DECILE Y1
    LET A(3) = THIRD DECILE Y1
    LET A(4) = FOURTH DECILE Y1
    LET A(5) = FIFTH DECILE Y1
    LET A(6) = SIXTH DECILE Y1
    LET A(7) = SEVENTH DECILE Y1
    LET A(8) = EIGHTH DECILE Y1
    LET A(9) = NINTH DECILE Y1
    PRINT A
 
-----DECILE PLOT-------------------------------------------------
 
DECILE PLOT
 
Name:
    ... DECILE PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a decile plot.
 
Description:
    A decile plot is a plot consisting of a subsample decile versus
    subsample index.  A subsample decile is the estimated 10%, 20%,
    30%, ..., 80%, or 90% point of the subsample.  The decile plot is
    used to answer the question: "Does the subsample variation change
    over different subsamples?".  The decile plot consists of:
       Vertical   axis = subsample decile;
       Horizontal axis = subsample index.
    The DECILE PLOT yields 2 traces:
       1. a subsample decile trace; and
       2. a full-sample decile reference line.
    Like usual, the appearance of these 2 traces is controlled by
    the first 2 settings of the LINES, CHARACTERS, SPIKES, BARS,
    and similar attributes.
 
Syntax:
    <keyword> DECILE PLOT  <y>  <x>  <SUBSET/EXCEPT/FOR qualification>
    where <keyword> is FIRST, SECOND, THIRD, FOURTH, FIFTH, SIXTH,
              SEVENTH, EIGHTH, or NINTH;
          <y> is the response (= dependent) variable;
          <x> is the subsample identifier variable (this variable
              appears on the horizontal axis);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    FIRST DECILE PLOT Y X
    NINTH DECILE PLOT Y X1
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHARACTERS              = Sets the type for plot characters.
    LINES                   = Sets the type for plot lines.
    LOWER QUARTILE  PLOT    = Generates a lower quartile plot.
    UPPER QUARTILE  PLOT    = Generates a upper quartile plot.
    LOWER HINGE  PLOT       = Generates a lower hinge plot.
    UPPER HINGE  PLOT       = Generates a upper hinge plot.
    MINIMUM  PLOT           = Generates a minimum plot.
    MAXIMUM  PLOT           = Generates a maximum plot.
    RANGE  PLOT             = Generates a range plot.
    STANDARD DEVIATION PLOT = Generates a standard deviation plot.
    VARIANCE  PLOT          = Generates a variance plot.
    MEAN PLOT               = Generates a mean plot.
    MEDIAN PLOT             = Generates a median plot.
    BOX PLOT                = Generates a box plot.
    S CHART                 = Generates a standard deviation control
                              chart.
    PLOT                    = Generates a data or function plot.
 
Applications:
    Quality Control
 
Implementation Date:
    88/2
 
Program:
    TITLE AUTOMATIC
    LET Y = DATA 2 4 6 11 12 21 25 28 29
    LET X = DATA 1 1 1 2 2 3 3 3 3
    CHARACTER X BLANK
    LINE BLANK SOLID
    XTIC OFFSET 0.2 0.2
    FIRST DECILE PLOT Y X
 
-----DECOCT (LET)--------------------------------
 
DECOCT
 
Name:
    DECOCT (LET)
 
Type:
    Library Function
 
Purpose:
    Perform a decimal to octal conversion of a number.
 
Syntax:
    LET <y2> = DECOCT(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed octal values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DECOCT(14)
    LET A = DECOCT(A1)
    LET X2 = DECOCT(X1)
    LET X2 = DECOCT(X1-4)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    OCTDEC = Perform an octal to decimal conversion of a number.
 
Applications:
    XX
 
Implementation Date:
    XX.X
 
Program:
    LET Y1 = SEQUENCE 0 1 100
    LET Y2 = DECOCT(Y1)
    PRINT Y1 Y2
 
-----DECONVOLUTION (LET)--------------------------------
 
DECONVOLUTION
 
Name:
    DECONVOLUTION (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the numerical deconvolution of two variables.
 
Description:
    Mathematically, the convolution of 2 continuous distributions g and
    h is defined as:
       g*h = Indefinite integral of g(tau)h(t-tau)dtau
    In practice, h is typically a data stream while g is a response
    function.  The response function is typically peaked function that
    goes to zero in both directions from that peak.  The effect of
    convolution is to smear the data stream with the response function.
 
    DATAPLOT computes the convolution from the functions sampled at
    discrete points (see the sample program for an example of how to
    evaluate a function at a discrete set of points).  This is referred
    to as discrete convolution.  If Y1 and Y2 are the sampled
    functions, then DATAPLOT computes the convolution as:
        Y3(1) = Y1(1)*Y2(1)
        Y3(2) = Y1(1)*Y2(2) + Y1(2)*Y2(1)
        Y3(3) = Y1(1)*Y2(3) + Y1(2)*Y2(2) + Y1(3)*Y2(1)
        etc.
 
    Deconvolution is an attempt to "unsmear" a data set given a 
    known response function.  DATAPLOT computes the deconvolution 
    of variables Y1 and Y2 as where Y1 has the same or more elements
    than Y2:
        Y3(1) = Y2(1)/Y1(1)
        Y3(2) = (Y2(2) - Y1(2)*Y3(1))/Y1(1)
        Y3(3) = (Y2(3) -Y1(3)*Y3(1) -Y1(2)*Y33(2))/Y1(1)
        etc.

Syntax:
    LET <y3> = CONVOLUTION <y1> <y2>  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <y3> is a variable containing the computed deconvolution
               values;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y3 = DECONVOLUTION Y1 Y2
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CONVOLUTION  = Compute the discrete convolution of two variables.
    FFT          = Compute the Fast Fourier Transform of two variables.
 
Reference:
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", Press, Flannery, Teukolsky, and Vetterling, Cambridge
    University Press, 1989 (chapter 12).
 
Applications:
    Mathematics
 
Implementation Date:
    Pre-1987
 
Program:
    XX
 
-----DEFINE-------------------------------------------------------
 
DEFINE
 
Name:
    DEFINE
 
Type:
    Support Command
 
Purpose:
    Equate a name with a character sequence.
 
Description:
    This command is used to send "escape" codes to a device.  It is
    particularly useful for "emulator" devices which may require
    certain codes to put the device in and out of the right emulation
    mode.  It is also useful for activating terminal specific actions.
    For example, on many Tektronix emulators it is helpful to define an
    "ESCAPE FORMFEED" sequence to clear the screen (some emulators do
    not provide a keyboard key to serve this function).
 
Syntax 1:
    DEFINE <name> <sequence of characters>
    where <name> is an identifier which when entered as a command sends
             the specified characters to the device;
    and   <sequence of characters> are the desired characters.
 
Syntax 2:
    DEFINE PREPLOT <sequence of characters>
    where <sequence of characters> are the desired characters.
 
    This form of the command is used to send codes to a device
    automatically at the beginning of a plot or diagrammatics graphics
    command.  Its most common use is to switch an emulator into the
    proper mode.  Use the PREPOST command to define the device to which
    it applies.
 
Syntax 3:
    DEFINE POSTPLOT <sequence of characters>
    where <sequence of characters> are the desired characters.
 
    This form of the command is used to send codes to a device
    automatically at the end of a plot or diagrammatics graphics
    command.  Its most common use is to switch an emulator back into
    its normal terminal mode.  Use the PREPOST command to define the
    device to which it applies.
 
Syntax 4:
    DEFINE PREHELP <sequence of characters>
    where <sequence of characters> are the desired characters.
 
    This form of the command is used to send codes to a device
    automatically at the beginning of a HELP command.  It is
    most commonly used to automatically clear the terminal
    screen at the beginning of the HELP command.
 
Syntax: 5
    DEFINE POSTHELP <sequence of characters>
    where <sequence of characters> are the desired characters.
 
    This form of the command is used to send codes to a device
    automatically at the end of a help command.  It is most commonly
    used to clear the terminal screen at the end of the help command.
 
Examples:
    DEFINE ER ESC FF
    DEFINE BIG ESC 8
 
Note:
    Only the first character of a word is used (the exception is that
    certain non-printing codes are recognized).   Multi-character
    codes should send each character as a separate word (i.e., separate
    with a space).
 
Note:
    Enter the command LIST DEFINITIONS to see all current definitions.
 
Note:
    This is not the appropriate command for defining aliases for
    DATAPLOT commands.  Use the substitute character for that purpose.
    For example,
        LET STRING P = PLOT
        ^P Y VS X
 
Note:
    The following non-printing characters are recognized:
       NUL  = Null character (ASCII 0)
       SOH  = Start of heading (ASCII 1)
       STX  = Start of text (ASCII 2)
       ETX  = End of text (ASCII 3)
       EOT  = End of transmission (ASCII 4)
       ENQ  = Enquiry (ASCII 5)
       ACK  = Acknowledge (ASCII 6)
       BEL  = Ring Bell (ASCII 7)
       BS   = Backspace (ASCII 8)
       HTX  = Horizontal tab (ASCII 9)
       LF   = Line feed (ASCII 10)
       VT   = Vertical tab (ASCII 11)
       FF   = Form Feed (ASCII 12)
       CR   = Carriage return (ASCII 13)
       SO   = Shift out (ASCII 14)
       SI   = Shift in (ASCII 15)
       DLE  = Data link escape (ASCII 16)
       DC1  = Device control 1 (ASCII 17)
       DC2  = Device control 2 (ASCII 18)
       DC3  = Device control 3 (ASCII 19)
       DC4  = Device control 4 (ASCII 20)
       NAK  = Negative acknowledge (ASCII 21)
       SYN  = Synchronous idle (ASCII 22)
       ETB  = End of transmission block (ASCII 23)
       CAN  = Cancel (ASCII 24)
       EM   = End of medium (ASCII 25)
       SUB  = Substitute (ASCII 26)
       ESC  = Escape (ASCII 27)
       FS   = File separator (ASCII 28)
       GS   = Group separator (ASCII 29)
       RS   = Record separator (ASCIII 30)
       US   = Unit separator (ASCII 31)
       SP   = Space (ASCII 32)
       SPA  = Space (ASCII 32)
       BL   = Space (ASCII 32)
       BLA  = Space (ASCII 32)
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    PREPLOT          = Define the sequence before a page erase.
    POSTPLOT         = Define the sequence at the end of plot.
    LIST DEFINITIONS = List current definitions.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    .  THE FOLLOWING SEQUENCE DEFINES CODES TO PUT A VT-240 IN
    .  AND OUT OF TEKTRONIX 4014 MODE.  IT WILL ALSO DEFINE THE
    .  PREPLOT AND POSTPLOT STRINGS TO DO THIS AUTOMATICALLY FOR
    .  PLOT COMMANDS.
    DEFINE ER ESC [ ? 3 8 h
    DEFINE TEK ESC [ ? 3 8 h
    DEFINE VT  ESC [ ? 3 8 l
    DEFINE PREPLOT ESC [ ? 3 8 h
    DEFINE POSTPLOT  ESC [ ? 3 8 l
    PREPOST TEKTRONIX 4014
    .  Entering ER will switch to TEKTRONIX mode.
    ER
 
-----DEFAULT-------------------------------------------------------
 
 
Default:
 
Name:
    DEFAULT
 
Type:
    Keyword
 
Purpose:
    Sets the DATAPLOT switch in question to the "default" position.
 
Syntax:
    <Certain DATAPLOT commands>   DEFAULT
 
Examples:
    XLIMITS DEFAULT
    FILTER WIDTH DEFAULT
 
Note:
    Usage of this keyword is rare since, for most DATAPLOT commands, no
    argument after a command usually achieves the same effect.  For
    example, XLIMITS DEFAULT and XLIMITS are equivalent.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ON        = Allows a switch to be "on".
    OFF       = Allows a switch to be "off".
    AUTOMATIC = Allows a switch to be "automatic".
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XX
 
-----DEGREES-------------------------------------------------------
 
DEGREES
 
Name:
    DEGREES
 
Type:
    Support Command
 
Purpose:
    Specifies that all subsequent trigonometric calculations (e.g.,
    LET Y = SIN(X) and ANGLE 45) be carried out in degrees (as opposed
    to radians or grads).
 
Syntax:
    DEGREES   <ON or OFF>
    where ON specifies that degrees are used while OFF reverts to
    radians.
 
Examples:
    DEGREES ON
    DEGREES OFF
    DEGREES
 
Note:
    The DEGREES command with no arguments is equivalent to DEGREES ON.
 
Default:
    Radians are the default trigonometric units.
 
Synonyms:
    None
 
Related Commands:
    TEXT        = Writes a text string.
    RADIANS     = Sets the angle units to radians.
    GRADS       = Sets the angle units to grads.
    ANGLE UNITS = Sets the angle units (to degrees/radians/grads).
    ANGLE       = Sets the angle for TEXT string.
    FONT        = Sets the font for TEXT characters.
 
Applications:
    XX
 
Implementation Date:
    Pre-1987
 
Program:
    XX
 
-----DEHAAN MLE-----------------------------
 
DEHAAN
 
Name:
    DEHAAN MLE
 
Type:
    Analysis Command
 
Purpose:
    Estimate the parameters of a generalized Pareto distribution
    using the de Haan method.

Description:
    The generalized Pareto distribution (GPD) is an asymptotic
    distribution developed by using the fact that exceedances
    of a sufficiently high threshold are rare events to which the
    Poisson distribution applies.

    The cumulative distribution function of the generalized
    Pareto distribution is

       G(y) = 1 - {[1 + (c*y/a)]**(-1/k)}    a > 0,
                                             [1 + (c*y/a)] > 0

    Here, c is the shape parameter and a is the scale parameter.

    This equation can be used to represent the conditional 
    cumulative distribution of the excess Y = X - u of the
    variate X over the threshold u, given X > u for u
    sufficiently large.

    The cases c > 0, c = 0, and c < 0 correspond respectively
    to the extreme value type II (Frechet), extreme value 
    type I (Gumbel), and reverse Weibull domains of attraction.

    Given the mean E(Y) and standard deviation s(Y) of the
    variate Y, then

        a = 0.5*E(Y)*{1 + [E(Y)/s(Y)]**2}
        c = 0.5*{1 - [E(Y)/s(Y)]**2}

    Note that for the case where c < 0, then gamma = -1/c is
    the estimate of the shape parameter for the reverse Weibull
    (SET MINMAX 2 case in Dataplot) distribution.

    The de Haan estimates of a and c are determined as follows.

       1) Let k equal the number of data points above the threshold
          so that u represents the (k+1)-th highest data points.
          We have lambda = k/n where n is the length of the
          record (in whatever units are appropriate, e.g., years).
          The highest, second highest, ... kth highest, 
          (k+1)th highest variates are denoted by X(n,n),
          X(n-1,n), ... , X(n-(k+1),n) respectively.

       2) Compute the following quantities.

           (r)         k-1
          M    = (1/k)*SUM[log(X(n-i+1,n) - log(X(n-k,n))]**r, r = 1,2
            n          i=0

       3) The estimates for c and a are as follows.

               (1)                   (1)      (2)
          c = M    + 1 - 1/[2*{1 - [M  ]**2/[M   ]}]
               n                     n        n

                 (1)
          a = u*M   /p1
                 n

          where

          p1 =1          c >= 0
          p1 = 1(1-c)    c< 0

          Formulas for the standard deviation of c are given in
          the paper "Extreme Wind Distribution Tails: A 'Peaks
          Over Threshold' Approach" (see the Reference section
          below).

Syntax:
    DEHAAN MLE <y>       <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    DEHAAN MLE Y
    DEHAAN MLE Y SUBSET TAG > 0
 
Note:
    The user specified threshold is determined by entering the
    following command before the DEHAAN command:

        LET THRESHOL = <value>

    If no threshold is specified, then the minimum data value is
    used as the threshold.

Note:
    The following internal parameters will be saved.

        GAMMA   = shape parameter for generalized Pareto
                  distribution
        A       = scale parameter for generalized Pareto
                  distribution
        SDGAMMA = standard deviation of GAMMA

    If GAMMA is within a user-specified tolerance of zero, then the
    following are also saved.

        LOC     = location parameter for Gumbel distribution.
        SCALE   = scale parameter for Gumbel distribution.

    To specify the tolerance, enter the command

       SET PEAKS OVER THRESHOLD TOLERANCE <value>

    If GAMMA is less than zero with an absolute value greater than the
    above tolerance, then the following are also saved.

        GAMMA2  = shape parameter for reverse Weibull
                  distribution.
        LOC     = location parameter for reverse Weibull
                  distribution.
        SCALE   = scale parameter for reverse Weibull
                  distribution.

    These estimates for the reverse Weibull and Gumbel distributions
    are based on moment estimators.  Currently, no estimates for the
    Frechet case (GAMMA > 0) are saved.

Note:
    The May, 2005 version added support for generating the output in
    Latex or HTML.  Enter

       HELP CAPTURE HTML
       HELP CAPTURE LATEX

    for details.

    The ASCII output was also modified somewhat.  This was a
    cosemetic change to make the output clearer.

Note:
    The PEAKS OVER THRESHOLD PLOT was added in the 5/2005 version.
    This plot shows how the estimate of the shape parameter changes
    as the the threshold changes.

Default:
    None.
 
Synonyms:
    None
 
Related Commands:
    CME                        = Compute the CME estimates for the
                                 generalized Pareto distribution.
    CME PLOT                   = Generate a CME plot.
    GEPPDF                     = Compute the probability density
                                 function for the generalized Pareto
                                 distribution.
    PEAKS OVER THRESHOLD PLOT  = Generate a peaks over threshold
                                 plot.
 
Reference:
    "Continuous Univariate Distributions: Volume I", 2nd. ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley and Sons, 1994.

    "Estimates of Hurricane Wind Speeds by the "Peaks Over
    Threshold" Approach", Alan Heckert, Emil Simiu, and Tim Whalen,
    Journal of Structural Engineering, April, 1998.

    "Extreme Wind Distribution Tails: A "Peaks Over Threshold"
    Approach", Simiu and Heckert, Journal of Structural Engineering,
    May, 1996.

    "Assessment of 'peak over threshold' Methods for Estimating
    Extreme Value Distribution Tails", J. A. Lechner, E. Simiu,
    N. A. Heckert, Structural Safety, 1993.

    "Estimates of Hurricane Wind Speeds by the 'Peaks Over
    Threshold' Method", E. Simiu, N. A. Heckert, T. Whalen,
    NIST Technical Note 1416, February, 1996.

    "Extreme Wind Estimates by the Conditional Mean Exceedance
    Procedure", J. L. Gross, E. Simiu, N. A. Heckert, J. A. Lechner,
    NISTIR 5531, April, 1995.


    "Extreme Wind Distribution Tails: A 'Peaks Over Threshold'
    Approach", E. Simiu, N. A. Heckert, NIST Building Science
    Series 174, March, 1995

Applications:
    Extreme Value Analysis
 
Implementation Date:
    1998/5
    2005/5: Modified the output format.
    2005/5: Added support for HTML and Latex output.
 
Program:
    SKIP 25
    READ MPOST550.DAT
    LET Y2 = SORT Y
    LET THRESHOL = Y2(900)
    SET WRITE DECIMALS 5
    DEHAAN MLE Y

-----DELETE-------------------------------------------------------
 
DELETE
 
Name:
    DELETE
 
Type:
    Support Command
 
Purpose:
    Deletes one or more variables.  It also deletes the specified rows
    or a subset of a variable and packs the remaining elements into the
    "top" of the variable.
 
Syntax 1:
    DELETE   <list>
    where <list> is a list of one or more variables (separated by
             spaces) to delete.
 
    This syntax deletes the entire variable.
 
Syntax 2:
    DELETE   <list>   <SUBSET/EXCEPT/FOR qualification>
    where <list> is a list of one or more variables (separated by
             spaces) to delete;
    and where the <SUBSET/EXCEPT/FOR qualification> specifies which
             elements are to be deleted.
 
    This syntax deletes specific elements of a variable.
 
Syntax 3:
    DELETE   <list of elements of variables>
    where <list of elements of variables> is a list of one or more
             elements of variables (separated by spaces) to delete.
 
    This syntax deletes specific elements of a variable.
 
Examples:
    DELETE Y SUBSET X 2 TO 4
    DELETE Y1 Y2 X SUBSET X 8 TO INFINITY
    DELETE X Y Z FOR I = 11 1 20
    DELETE X(100)
    DELETE X(2) Y(7) Z(15)
    DELETE X(2) Y(2) PRED(2) RES(2)
 
Note:
    The DELETE command applies to variables.  You cannot delete either
    parameters or matrices.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    RETAIN = Retains rows or a subset of a variable.
    LET    = Transforms rows or a subset of a variable (plus other
             capabilities).
    SUBSET = Allows specification of a subset.
    EXCEPT = Allows exclusion-specification of a subset.
    FOR    = Allows row-specification of a subset.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XX
 
-----DEMODF-------------------------------------------------------
 
DEMODF
 
Name:
    DEMODF
 
Type:
    Keyword
 
Purpose:
    An internal DATAPLOT parameter into which the updated demodulation
    frequency is automatically placed whenever the COMPLEX DEMODULATION
    ... PLOT command is executed.  The value will be between 0 to 0.5.
 
Syntax:
    None
 
Examples:
    LET A = DEMODF
    WRITE DEMODF
    DEMODULATION FREQUENCY DEMODF
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COMPLEX DEMOD PLOT  = Generates a complex demodulation plot.
    DEMOD FREQUENCY     = Sets the demodulation frequency for the
                          complex demodulation plot.
    SPECTRUM            = Generates a spectral plot.
    CORRELATION PLOT    = Generates a correlation plot.
    LAG PLOT            = Generates a lag plot.
    PLOT                = Generates a data or function plot.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XX
 
-----DEMODULATION FREQUENCY--------------------------------------------
 
DEMODULATION FREQUENCY
 
Name:
    DEMODULATION FREQUENCY
 
Type:
    Support Command
 
Purpose:
    Specifies the demodulation frequency (a value between 0 and 0.5)
    for use in subsequent COMPLEX DEMODULATION ... PLOT commands.
 
Syntax:
    DEMODULATION FREQUENCY   <n>
    where <n> is a number or parameter in the range 0 to 0.5 that
              specifies the desired demodulation frequency.
 
Examples:
    DEMODULATION FREQUENCY .3
    DEMODULATION FREQUENCY DEMODF
    DEMODULATION FREQUENCY F
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COMPLEX DEMOD PLOT  = Generates a complex demodulation plot.
    DEMODF              = A parameter where the updated demodulation
                          frequency is stored.
    SPECTRUM            = Generates a spectral plot.
    CORRELATION PLOT    = Generates a correlation plot.
    LAG PLOT            = Generates a lag plot.
    PLOT                = Generates a data or function plot.
 
Applications:
    Frequency Analysis of Time Series
 
Implementation Date:
    XX
 
Program:
    XX
 
-----DERIVATIVE (LET)-------------------------------------------------
 
DERIVATIVE
 
Name:
    DERIVATIVE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the derivative for a function.
 
Description:
    DATAPLOT computes and prints the analytic form of the derivative
    function.  It can either return the derivative function as a new
    function or it can return the derivative evaluated at one or more
    points.
 
Syntax 1:
    LET <resp> = DERIVATIVE <function>  WRT <var>
    where <function> is the name of a previously defined function or a
              functional expression;
          <var> is the name of the variable with respect to which the
                derivative is taken;
          <resp> is a variable of the same length as <var> where the
              evaluated derivatives are stored.
 
    With this syntax, the derivative variable (<var>) must be defined
    for one or more points.  The derivative is calculated at each of
    these points and the resulting value is put in the corresponding
    element of <resp>.  The analytic derivative function is printed but
    not saved in a function that can be used later.
 
Syntax 2:
    LET <resp> = DERIVATIVE <function>  WRT <var>  FOR <var> = <value>
    where <function> is the name of a previously defined function or a
              functional expression;
          <var> is the name of the variable with respect to which the
                derivative is taken;
          <value> is a number or parameter at which the derivative is
                to be evaluated;
          <resp> is a parameter of length 1 where the evaluated
                derivative is stored.
 
    This syntax is similar to SYNTAX 1.  However, the FOR clause
    identifies a single point at which the derivative is to be
    evaluated.
 
Syntax 3:
    LET FUNCTION <d1> = DERIVATIVE <function>  WRT <var>
    where <function> is the name of a previously defined function or a
              functional expression;
          <var> is the name of the variable with respect to which the
                derivative is taken;
          <d1> is the name of a function where the computed derivative
              function is stored.
 
    With this syntax, the analytic derivative is saved in a new
    function (<d1>) which can be used later in the same way as any
    other function.  To evaluate the derivative at specific points,
    simply evaluate the function in the standard way.  For example,
       LET FUNCTION F1 = X**2 + 3*X -5
       LET X = SEQUENCE 0 0.1 10
       LET Y1 = F1
    The variable Y1 contains the values of F1 evaluated at the given
    points of X.
 
Examples:
    LET XDERV = DERIVATIVE 3*X**2 -8*X + 4 WRT X
    LET FUNCTION D1= DERIVATIVE 3*X**2 -8*X + 4 WRT X
    LET XDERV = DERIVATIVE F1 WRT X
    LET XDERV = DERIVATIVE 3*X**2 -8*X + 4 WRT X FOR X = 2.3
 
Note:
    DATAPLOT does not handle arbitrarily complex functions.
 
    DATAPLOT knows how to take the derivatives of the following
    functions:
      1) All the built-in trigonometric functions (including inverses).
      2) All the built-in hyperbolic trigonometric functions (including
         inverses).
      3) The LOG (LN is not recognized) and LOG10 functions for natural
         and base 10 logarithms respectively.  Logarithms in other bases
         should be expressed as a function of base 10 logarithms (e.g.,
         LOG (base 2) 30 = LOG (base 10) 30/ LOG (base 10) 2.
      4) The SQRT function.
      5) The EXP function.
      6) Arithmetic operations (i.e., +, -, *, /, and **).  This
         includes combinations of the above operations.
 
    The other built-in functions are not recognized directly.  However,
    some of them can be handled by defining a user function in terms of
    functions that DATAPLOT does recognize.
 
    The DATAPLOT derivative capability can also fail if the combined
    expression gets too complex.  It is difficult to give a simple rule
    on how complex a function DATAPLOT can handle.
 
Note:
    DATAPLOT only calculates first order derivatives.  To calculate
    higher order derivatives, use the second syntax to return the
    first derivative as a function.  Then take the derivative of this
    function to get the second order derivative.  This can be repeated
    as many times as needed (although going beyond second order
    derivatives is rare).
 
Note:
    DATAPLOT only takes derivatives with respect to a single variable.
    That is, it does not take partial derivatives.  The following syntax
    will NOT work:
        LET FUNCTION F = 4*x**2*Y**3 + 3*x + 4*Y
        LET FUNCTION D = DERIVATIVE F WRT X
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    INTEGRAL       = Compute the integral of a function.
    ROOTS          = Compute the roots of a function.
    RUNGE KUTTA    = Runge Kutta differential equation solver.
    INTERPOLATE    = Interpolate a function.
 
Reference:
    Consult any standard Calculus textbook.
 
Applications:
    Mathematics
 
Implementation Date:
    XX.X
 
Program:
    LET FUNCTION F1 = SIN(X)*COS(X)
    LET START = -PI/2
    LET STOP = PI/2
    LET X = SEQUENCE START 0.1 STOP
    LET D1 = DERIVATIVE F1 WRT X
    LINE SOLID DASH
    LET Y1 = F1
    TITLE PLOT OF FUNCTION AND ITS DERIVATIVE
    PLOT Y1 D1 VS X
 
-----DESIGNS-------------------------------------------------------
 
DESIGNS
 
Name:
    DESIGNS
 
Type:
    Keyword
 
Purpose:
    Symbolic name for DATAPLOT's experiment designs file.  It is used
    with the SEARCH and LIST commands.
 
Description:
    The DATAPLOT distribution files come with a large number of on-line
    experimental designs.  These files are stored in the DATAPLOT
    directory (the same directory where the on-line help files are
    stored).  These files can be accessed by the READ and SERIAL READ
    commands without specifying the full path name.  DATAPLOT's
    experiment designs file contains an alphabetic list of these files.
    It is a subset of the dictionary file.  The dictionary file also
    includes macro files, program files, and data files.
 
Syntax:
    None
 
Examples:
    SEARCH DESIGNS TAGUCHI
    LIST DESIGNS FOR I = 1 1 35
 
Note:
    The DESIGNS file is stored in the DATAPLOT directory.  It
    has the name DESIGNS (or designs for Unix systems).  The exact
    file name and the directory where it is stored can vary depending
    on the installation (see your local DATAPLOT implementor to find
    the exact name on your system).
 
Note:
    If DATAPLOT is unable to open the designs file, it is most likely
    because the directory name is not specified correctly in the local
    DATAPLOT code.  See your local DATAPLOT implementor to have this
    corrected.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SEARCH        = Search a file for a string.
    LIST          = Lists the contents of a file.
    DIRECTORY     = Symbolic name for DATAPLOT's directory file.
    DICTIONAY     = Symbolic name for DATAPLOT's dictionary file.
    DATASETS      = Symbolic name for DATAPLOT's data sets file.
    COMMANDS      = Symbolic name for DATAPLOT's commands file.
    SYNTAX        = Symbolic name for DATAPLOT's syntax file.
    MACROS        = Symbolic name for DATAPLOT's macros file.
    PROGRAMS      = Symbolic name for DATAPLOT's programs file.
    DISTRIBU      = Symbolic name for DATAPLOT's distributions file.
    FUNCTION      = Symbolic name for DATAPLOT's function file.
 
Applications:
    Experiment Design
 
Implementation Date:
    93/12
 
Program:
    XX
 
-----DEVICE-------------------------------------------------------
 
DEVICE
 
Name:
    DEVICE ...
 
Type:
    Output Device Command
 
Purpose:
    Specifies the manufacturer and model of a graphics output device.
 
Syntax:
    DEVICE <id> <manufacturer> <model> <model2> <model3>
    where <id> is a number or parameter with an integer value of 1 to 3
               that is the device identifier;
          <manufacturer> identifies the  manufacturer;
          <model> is the optional first model identifier;
          <model2> is the optional second model identifier;
    and   <model3> is the optional third model identifier.
 
    It is unusual for more than one model identifier to be specified.
 
Examples:
    DEVICE 1 TEKTRONIX 4105
    DEVICE 2 HP-GL
    DEVOCE 2 HP-GL 7475
    DEVICE 3 GENERAL
 
Note:
    The following manufacturers are supported on all installations:
 
       TEKTRONIX  - Tektronix devices
       HP         - Hewlett-Packard devices
       REGIS      - DEC terminals (REGIS protocol)
       POSTSCRIPT - Postscript devices
       QUIC       - QMS laser printers (QUIC protocol)
       GENERAL    - DATAPLOT specific metafile
       CGM        - ANSI standard metafile
 
    The following devices are available on some implementations.
 
       X11        - X11 workstation
       SUN        - SUN workstation (gfxtool or suntool window)
       CALCOMP    - Calcomp devices (using Calcomp library)
       ZETA       - Zeta devices (using Calcomp library)
 
    Enter HELP TEKTRONIX, HELP HP, HELP REGIS, HELP POSTSCRIPT, HELP
    QUIC, HELP GENERAL, HELP CGM, HELP X11, HELP SUN, HELP CALCOMP, or
    HELP ZETA for a list of supported models and for more detailed
    information for a given device.
 
Note:
    DATAPLOT supports 3 devices (defined by DEVICE 1, DEVICE 2, and
    DEVICE 3).  Device 1 output is sent to the terminal and device 2
    output is sent to a file (DPPL1F.DAT or dppl1f.dat on most
    systems).  Device 3 output is also sent to a file (DPPL2F.DAT or
    dppl2f.dat on most systems), but it only contains the most recent
    plot (the PP command can be used to print the device 3 output from
    within a DATAPLOT session).  DATAPLOT supports all 3 devices
    simultaneously.
 
Note:
    The device is immediately opened when a DEVICE command is entered.
 
Default:
    Device 1 is Tektronix 4014, device 2 is off, and device 3 is a
    Postscript printer.
 
Synonyms:
    DEVICE ... MANUFACTURER
 
Related Commands:
    DEVICE COLOR          = Sets the device color.
    DEVICE CONTINUITY     = Sets the device continuity.
    DEVICE PICTURE POINTS = Sets the device picture points.
    DEVICE POWER          = Sets the device power.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XX
 
-----DEVICE 2 SPLIT (SET)---------------------------------------
 
DEVICE 2 SPLIT
 
Name:
    DEVICE 2 SPLIT
 
Type:
    Set Subcommand
 
Purpose:
    Specify whether device 2 output will generate each plot into a
    separate file.
 
Description:
    You can use the DEVICE 2 command to generate all subsequent plots
    (until a DEVICE 2 CLOSE is given) to an external file.  By default,
    all plots are generated in the file "dppl1f.dat".

    In some cases, it may be desirable to put each plot in a
    separate file.  For example, this may be useful when you
    need to import the graphs into a web page or a word processor.

    The SET DEVICE 2 SPLIT command can be used to specify that each
    plot will be generated to a separate file.  A counter is added to
    the base file name before the extension (i.e., the period in the
    file name).  For the default name, the files will be called

        dppl1f_1.dat
        dppl1f_2.dat
           ....

    You can use the SET IPL1NA command to specify the base file name.
    This is demonstrated in the Program example below.

Syntax:
    SET DEVICE 2 SPLIT <ON/OFF>

    If you specify OFF (the default), all plots will be generated to a
    single file.  If you specify ON, a counter value will be added to the
    plot file name so that each plot will be saved in a different file.
 
Examples:
    SET DEVICE 2 SPLIT ON
    SET DEVICE 2 SPLIT OFF

Default:
    OFF
 
Synonyms:
    None
 
Related Commands:
    DEVICE                  = Open or close a graphics device.
    DEVICE 3 NAME COUNTER  = Add a counter to the device 3 output file
                             name.
 
Applications:
    Graphics Output
 
Implementation Date:
    2015/12
 
Program:
    . Step 0:   Define output devices
    .
    .           This program will create the plots
    .
    .              device2_1.ps
    .              device2_2.ps
    .              device2_3.ps
    .              device2_4.ps
    .
    set device 2 split on
    set ipl1na device2.ps
    device 2 postscript
    .
    . Step 1:   Plot control features
    .
    label case asis
    title case asis
    title automatic
    y1label Y Axis
    x1label X Axis
    character X
    line blank
    .
    . Step 2:   Generate several plots
    .
    plot x    for x = 1 1 9
    plot x**2 for x = 1 1 9
    plot x**3 for x = 1 1 9
    plot x**4 for x = 1 1 9
    .
    device 2 close

-----DEVICE 3 NAME COUNTER (SET)---------------------------------------
 
DEVICE 3 NAME COUNTER
 
Name:
    DEVICE 3 NAME COUNTER (SET)
 
Type:
    Set Subcommand
 
Purpose:
    Specify whether device 3 output will generate each plot into a
    separate file.
 
Description:
    Dataplot uses device 3 to maintain a copy of the most recent plot
    only (the default file name is "dppl2f.dat") in Postscript
    format.  Dataplot automatically handles the opening and closing of
    device 3.  The PP command uses the device 3 output to print the most
    recent plot from within a Dataplot session.

    The SET DEVICE 3 NAME COUNTER command can be used to add a counter
    to the base file name each time the plot file is opened.  That is,
    each plot will be saved in a different file name.

    The counter is added to the name before the extension (i.e., the
    period in the file name).  For the default name, the files will
    be called

        dppl2f_1.dat
        dppl2f_2.dat
           ....

    You can use the SET IPL2NA command to specify the base file name.
    This is demonstrated in the Program example below.

Syntax:
    SET DEVICE 3 NAME COUNTER <ON/OFF>

    If you specify OFF (the default), the plot file will be overwritten
    each time a new plot is generated.  If you specify ON, a counter
    value will be added to the plot file name so that each plot will
    be saved in a different file.
 
Examples:
    SET DEVICE 3 NAME COUNTER ON
    SET DEVICE 3 NAME COUNTER OFF

Default:
    OFF
 
Synonyms:
    None
 
Related Commands:
    DEVICE     = Open or close a graphics device.
    DEVICE 3   = Specifies whether device 3 output will be controlled
                 by Dataplot or by the user.
 
Applications:
    Graphics Output
 
Implementation Date:
    2015/12
 
Program:
    . Step 0:   Define output devices
    .
    .           The following commands will generate the
    .           plot files "plot_1.ps", "plot_2.ps", "plot_3.ps",
    .           "plot_4.ps".
    .
    set device 3 name counter on
    set ipl2na plot.ps
    device 3 close
    .
    . Step 1:   Plot control features
    .
    label case asis
    title case asis
    title automatic
    y1label Y Axis
    x1label X Axis
    character X
    line blank
    .
    . Step 2:   Generate several plots
    .
    plot x    for x = 1 1 9
    plot x**2 for x = 1 1 9
    plot x**3 for x = 1 1 9
    plot x**4 for x = 1 1 9
    .
    device 3 close

-----DEVICE 3 (SET)---------------------------------------
 
DEVICE 3
 
Name:
    DEVICE 3 (SET)
 
Type:
    Set Subcommand
 
Purpose:
    Specify whether device 3 output will be controlled automatically by
    Dataplot (the default) or by the user.
 
Description:
    Device 2 is typically used to generate plots (usually in Postscript
    format) to an external file (the default file name is "dppl1f.dat").
    The device 2 output is under the control of the user (device 2 output
    is off by default).

    In addition, Dataplot uses device 3 to maintain a copy of the most
    recent plot only (the default file name is "dppl2f.dat") in Postscript
    format.  Dataplot automatically handles the opening and closing of
    device 3.  The PP command uses the device 3 output to print the most
    recent plot from within a Dataplot session.

    If you would like to manually control the device 3 output yourself,
    then you can use the SET DEVICE 3 command.

Syntax:
    SET DEVICE 3 <AUTOMATIC/USER>
    where <AUTOMATIC> specifies that Dataplot will control the device 3
          output and <USER> specifies that the user will control the
          device 3 output.
 
Examples:
    SET DEVICE 3 AUTOMATIC
    SET DEVICE 3 USER

Default:
    AUTOMATIC
 
Synonyms:
    None
 
Related Commands:
    DEVICE                 = Open or close a graphics device.
    DEVICE 3 NAME COUNTER  = Add a counter to the device 3 output file
                             name.
 
Applications:
    Graphics Output
 
Implementation Date:
    2015/12
 
Program:
    . This code will use device 2 to generate Postscript
    . format plots and device 3 to generate SVG versions
    . of the graph.
    .
    set ipl1na plots.ps
    device 2 postscript
    .
    device 3 close
    set device 3 user
    .
    title automatic
    set ipl2na plot1.svg
    device 3 svg
    plot x for x = 1 1 9
    device 3 close
    .
    set ipl2na plot2.svg
    device 3 svg
    plot x**2 for x = 1 1 9
    device 3 close
    .
    set ipl2na plot3.svg
    device 3 svg
    plot x**3 for x = 1 1 9
    device 3 close

-----DEVICE COLOR-----------------------------------------------------
 
DEVICE COLOR
 
Name:
    DEVICE ... COLOR
 
Type:
    Outout Device Command
 
Purpose:
    Specifies whether a graphics output device is color (ON) or
    monochrome (OFF).
 
Description:
    Monochrome means that the device is not capable of producing more
    than 1 color upon the default background color of the device.
 
Syntax:
    DEVICE   <id>   COLOR   <ON/OFF>
    where <id> is a number or parameter with an integer value of 1 to 3
               that is the device identifier;
    and where <ON> indicates a color device while <OFF> indicates a
               monochrome device.
 
Examples:
    DEVICE 1 COLOR ON
    DEVICE 2 COLOR ON
    DEVICE 2 COLOR OFF
    DEVICE 3 COLOR ON
 
Note:
    The color capability is implicit in the specification of the device
    (DEVICE ... <manufacturer> command), so this command is rarely
    used.  For example, if one enters DEVICE 1 TEKTRONIX 4027, then the
    color for device 1 is automatically set to ON. However, if one
    enters DEVICE 1 TEKTRONIX 4014, then the color of device 1 is
    automatically set to OFF.  The DEVICE COLOR command would typically
    be used if you want to generate black and white graphics on a color
    device.  One exception is Postscript, which supports both color and
    monochrome devices.
 
Default:
    Device dependent
 
Synonyms:
    None
 
Related Commands:
    DEVICE                = Sets the device manufacturer/model.
    DEVICE CONTINUOUS     = Sets the device continuity.
    DEVICE PICTURE POINTS = Sets the device picture points.
    DEVICE POWER          = Sets the device power.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XX
 
-----DEVICE CONTINUOUS-------------------------------------------------
 
DEVICE CONTINUOUS
 
Name:
    DEVICE ... CONTINUOUS
 
Type:
    Output Device Command
 
Purpose:
    Specifies whether a graphics output device is continuous (ON) or
    discrete (OFF).
 
Description:
    Discrete means that the device is not capable of drawing a
    continuous line from one point to another point on the device.
 
Syntax:
    DEVICE   <id>   CONTINUOUS   <ON/OFF>
    where <id> is a number or parameter with an integer value of 1 to 3
               that is the device identifier;
    and   <ON> indicates a continuous device while <OFF> indicates a
               discrete device.
 
Examples:
    DEVICE 1 CONTINUOUS ON
    DEVICE 2 CONTINUOUS ON
    DEVICE 2 CONTINUOUS OFF
    DEVICE 3 CONTINUOUS ON
 
Default:
    Continuous
 
Synonyms:
    None
 
Note:
    The continuity/discreteness of a device is implicit in the
    specification of the DEVICE (manufacturer) command, so this
    command is rarely used.  For example, if one enters DEVICE 1
    TEKTRONIX 4025, then the continuity for the device is automatically
    set to ON.  However, if one enters DEVICE 1 TEXAS INSTRUMENT SILENT
    700, then the continuity is automatically set to OFF.  The DEVICE
    CONTINUOUS command would thus be used only when a non-supported
    manufacturer is used, and further (since the default is continuous)
    when such a device is discrete.
 
Related Commands:
    DEVICE                = Sets device man./model.
    DEVICE COLOR          = Sets device color.
    DEVICE PICTURE POINTS = Sets device picture points.
    DEVICE POWER          = Sets device power.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XX
 
-----DEVICE PICTURE POINTS--------------------------------------------
 
DEVICE PICTURE POINTS
 
Name:
    DEVICE ... PICTURE POINTS
 
Type:
    Output Device Command
 
Purpose:
    Specifies the number of picture points (horizontal, then vertical)
    of a graphics output device.
 
Syntax:
    DEVICE   <id>   PICTURE POINTS   <h>   <v>
    where <id> is a number or parameter with an integer value of 1 to 3
               that is the device identifier;
          <h> is a number or parameter that specifies the desired
               number of horizontal picture points;
          <v> is a number or parameter that specifies the desired
               number of vertical picture points.
 
Examples:
    DEVICE 1 PICTURE POINTS 640 480
    DEVICE 2 PICTURE POINTS 1024 781
    DEVICE 3 PICTURE POINTS 80 24
 
Note:
    The number of picture points of a device is implicit in the
    specification of the DEVICE (manufacturer) command, so this command
    is rarely used.  For example, if one enters DEVICE 1 TEKTRONIX
    4105, then the picture points for the device are automatically set
    to 640 by 480.  However, if one specifies that the device is an
    HP-GL, then the picture points of the device are automatically set
    to 16158 by 11040.  This command is typically only used for devices
    that support variable window sizes (currently X11) or if you want
    to use only a subset of the device (the WINDOW command gives a more
    device independent way to do this).
 
Default:
    Each device has a default number of picture points.  For the
    Tektronix 4014 (the default device), it is 4096 by 3124.
 
Synonyms:
    None
 
Related Commands:
    DEVICE                = Sets the device manufacturer and model.
    DEVICE COLOR          = Sets the device color.
    DEVICE CONTINUITY     = Sets the device continuity.
    DEVICE POWER          = Sets the device power.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XX
 
-----DEVICE POWER-----------------------------------------------------
 
DEVICE POWER
 
Name:
    DEVICE ... POWER
 
Type:
    Output Device Command
 
Purpose:
    Specifies whether a graphics output device is empowered (ON),
    depowered (OFF), opened (OPEN), or closed (CLOSE).
 
Description:
    DATAPLOT makes a distinction between empowering a device and
    opening a device.  Empowering a device means that subsequent plots
    are generated on that device.  However, the plot file is not
    opened and device initialization is not performed.  Opening a
    device empowers the device, but it also opens the plot file and
    performs device initialization.  Likewise, depowering a device
    means that subsequent plots are not generated on the device.
    However, the plot file is not closed and the device exit code is
    not performed.  Closing a device depowers the device, but it also
    performs device exit and closes the plot file.
 
    The <ON/OFF> switches are used to toggle output to a graphics file.
    For example, an analyst may want to make several iterations of a
    plot before sending the final plot to an off-line device.  A
    typical session may look like this:
         DEVICE 2 POSTSCRIPT
         PLOT Y X
         DEVICE 2 OFF
           <additional plots>
         DEVICE 2 ON
         PLOT Y X
    Entering DEVICE 2 POSTSCRIPT or DEVICE 2 OPEN for the DEVICE 2 ON
    command can cause problems on some devices (e.g., Postscript),
    since the device is reinitialized without being closed.
 
    The <OPEN/CLOSE> switches can be useful on systems that implement
    the SYSTEM command.  It allows the analyst to send plots to a
    plotter or printer without exiting DATAPLOT.  In order to do this,
    the plot file must be closed first (DEVICE 2 CLOSE).  After
    using the SYSTEM command to copy or print the output file, the
    device can be re-opened with a DEVICE ... OPEN (or a DEVICE ...
    <manufacturer>) command.
 
Syntax:
    DEVICE   <id>   POWER   <ON/OFF/OPEN/CLOSE>
    where <id> is a number or parameter with an integer value of 1 to 3
               that is the device identifier;
    and   ON empowers the device, OPEN opens the device, OFF depowers
               the device, and CLOSE closes the device.
 
Examples:
    DEVICE 1 POWER ON
    DEVICE 2 POWER OPEN
    DEVICE 2 POWER OFF
    DEVICE 3 POWER CLOSE
    DEVICE 2 ON
    DEVICE 2 CLOSE
    DEVICE 2 OPEN
    DEVICE 2 CLOSE
 
Default:
    Device 1 is on, device 2 is off, and device 3 is on.
 
Synonyms:
    None
 
Related Commands:
    DEVICE                = Sets the device manufacturer and model.
    DEVICE COLOR          = Sets the device color.
    DEVICE CONTINUITY     = Sets the device continuity.
    DEVICE PICTURE POINTS = Sets the device picture points.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XX
 
-----DEXCDF (LET)--------------------------------
 
DEXCDF
 
Name:
    DEXCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the double exponential (also known as
    the Laplace distribution) cumulative distribution function.
 
Description:
    The standard form of the double exponential distribution has the
    following probability density function:
       f(x) = 0.5*exp(-abs(x))
    The cumulative distribution is the area from negative infinity to
    x (i.e., the integral of the above function).  It has the formula:
       cdf(x) = 0.5*exp(x)           for x <= 0
       cdf(x) = 1.0 - 0.5*exp(-x)    for x >= 0
    The input value can be any real number.
 
Syntax:
    LET <y2> = DEXCDF(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, a number, or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
              where the computed double exponential cdf value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DEXCDF(3)
    LET A = DEXCDF(A1)
    LET X2 = DEXCDF(X1)
 
Note:
    The general form of the double exponential distribution is:
       f(x) = (0.5/beta)*exp(-abs(x-u)/beta)
    The formula for the cumulative distribution function is:
       cdf(x) = 0.5*exp(-(u-x)/beta)         for x <= 0
       cdf(x) = 1.0 - 0.5*exp(-(x-u)/beta)   for x >= 0
    The parameter u is a location parameter and the parameter beta is a
    scale parameter that must be greater than 0.  The cdf values for
    the general double exponential distributions can be computed by
    doing something like the following:
        LET U = <value>
        LET BETA = <value>
        PLOT (1/BETA)*DEXCDF((X-U)/BETA) FOR X = -4 .1 4
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DEXPDF = Compute the double exponential probability density
             function.
    DEXPPF = Compute the double exponential percent point function.
    EXPCDF = Compute the exponential cumulative distribution function.
    EXPPDF = Compute the exponential probability density function.
    EXPPPF = Compute the exponential percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    EV1CDF = Compute the extreme value type I cumulative distribution
             function.
    EV1PDF = Compute the extreme value type I probability density
             function.
    EV1PPF = Compute the extreme value type I percent point function.
    CHSPDF = Compute the chi-square probability density function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPPF = Compute the chi-square percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, Houghton
    Mifflin, 1970 (chapter 23).
 
Applications:
    XX
 
Implementation Date:
    94/4
 
Program:
    YLIMITS 0 1
    MAJOR YTIC NUMBER 6
    MINOR YTIC NUMBER 1
    YTIC DECIMAL 1
    XLIMITS -4 4
    XTIC OFFSET 0.6 0.6
    TITLE AUTOMATIC
    PLOT DEXCDF(X) FOR X = -4.5 0.01 4.5
 
-----DEX CHECK CENTER POINTS-----------------------------------------
 
DEX CHECK CENTER POINTS
 
Name:
    DEX CHECK CENTER POINTS (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Given a list of factor variables, create a tag variable that will
    identify center points.
 
Description:
    With the 10-step analysis of full and fractional factorial designs,
    it is helpful to identify which rows of the data are center points
    and which are not (most of the steps do not include the center points
    while others, specifically the contour plot, do use the center
    points).

    For 2-level full or fractional factorial design, the low level is
    typically coded as "-1" and the upper level is typically coded as
    "+1".  Center points are typically coded as "0".  In some cases, the
    data may be in the original units rather than the coded units.

    This command uses the following algorithm to determine whether a
    given row is a center point.

      1. For each column, compute the median of the distinct values in
         that column.  This median is used so that the data can be in
         either coded or original units.  Note that if there are an even
         number of distinct values, none of the rows will match the
         median.  This is reasonable as center points only make sense
         if there are an odd number of distinct values.

      2. For a given row, if the values for each column are equal to
         their respective medians, the point is identified as a center
         point.

Syntax:
    LET <tag> = DEX CHECK CENTER POINT  <name1> <name2> ... <namek>
    where <name1> <name2> ... <namek> is a list of 1 to k variable names;
    and   <tag> is a variable where the center point status is saved.
 
    All of the variables on the right hand side should be of the same
    length.  These should be the factor variables of the design matrix.
    Do not include the response variable.

    If a given row of the design matrix is identified as a center point,
    the corresponding row of <tag> will be set to 0.  Otherwise, it will
    be set to 1.

    This TAG variable can be used to subset out the center point when
    needed.

Examples:
    LET TAG = DEX CHECK CENTER POINT X1 X2 X3
    LET TAG = DEX CHECK CENTER POINT X1 X2 X3 X4 X5

Note:
    The TO syntax is not supported for this command.  That is,

          LET TAG = DEX CHECK CENTER POINT X1 TO X5

      should be coded as

          LET STALL = STRING COMBINE X1 TO X5
          LET IFLAG = DEX CHECK CENTER POINT ^STALL

Note:
    Not all design matrices will contain center points.  If you want to
    determine whether or not center points are present, do something like

        LET TAG = DEX CHECK CENTER POINTS X1 X2 X3 X4 X5
        LET NCENT = SIZE TAG  SUBSET TAG = 0

    If NCENT is equal to 0, then no center points are present.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DEX CHECK CLASSIC   = Determine whether a design matrix is in "coded"
                          form.
    CODE DEX            = Convert data to -1, 0, +1 codeing.
    CHECK TYPES         = Check the types for a list of names.
    CHECK EQUAL LENGTH  = Check whether a list of variables have the same
                          number of elements.
 
Applications:
    Analysis of full and fractional factorial designs
 
Implementation Date:
    2018/10
 
Program:
    let k = 8
    skip 25
    read scott_8_16.dat y x1 to x^k
    let stall = string combine x1 to x^k
    let tag = dex check center point ^stall
    set write decimals 0
    print x1 to x^8 tag

-----DEX CHECK CLASSIC-----------------------------------------
 
DEX CHECK CLASSIC
 
Name:
    DEX CHECK CLASSIC (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Given a list of factor variables, check to see if they are in
    classic form for a 2-level full or fractional factorial design.
 
Description:
    For 2-level full or fractional factorial design, the low level is
    typically coded as "-1" and the upper level is typically coded as
    "+1".  Center points are typically coded as "0".  This command
    checks whether each of the listed factor variables contains only
    "-1", "+1" and "0" values.

    If the factor variables are in the original units rather than coded
    as -1 and +1, you can use the CODE DEX command to convert them to
    -1 and +1 values.

Syntax:
    LET <iflag> = DEX CHECK CLASSIC  <name1> <name2> ... <namek>
    where <name1> <name2> ... <namek> is a list of 1 to k variable names;
    and   <iflag> is a parameter where the status is saved.
 
    If all variable names contain only -1, +1, or 0, <iflag> will be set
    to 1.  Otherwise <iflag> will be set to 0.

Examples:
    LET IFLAG = DEX CHECK CLASSIC X1 X2 X3
    LET IFLAG = DEX CHECK CLASSIC X1 X2 X3 X4 X5

Note:
    The TO syntax is not supported for this command.  That is,

          LET IFLAG = DEX CHECK CLASSIC X1 TO X5

      should be coded as

          LET STALL = STRING COMBINE X1 TO X5
          LET IFLAG = DEX CHECK CLASSIC ^STALL

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CODE DEX            = Convert data to -1, 0, +1 codeing.
    CHECK TYPES         = Check the types for a list of names.
    CHECK EQUAL LENGTH  = Check whether a list of variables have the same
                          number of elements.
 
Applications:
    Analysis of full and fractional factorial designs
 
Implementation Date:
    2018/02
 
Program:
    skip 25
    read scott_8_16.dat y x1 to x8
    let stall = string combine x1 to x^k
    let iflag = dex check classic ^stall

-----DEX CONFOUND-----------------------------------------
 
DEX CONFOUND
 
Name:
    DEX CONFOUND (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Determine the confounding structure for 2-level full and fractional
    factorial designs.
 
Description:
    The "dex10stepanalysis.dp" macro can be used to analyze 2-level full
    or fractional factorial designs.  A key step in the analysis of these
    designs is the estimation of the effects and the determination of the
    confounding structure.  The "dex10stepanalysis.dp" macro calls the
    "compute_effect_estimates_and_confounding.dp" macro to perform the
    effect estimation.  The DEX CONFOUND command is a utility command used
    in the "compute_effect_estimates_and_confounding.dp" macro and is not
    typically used outside of this context.

    Previous versions of the 10-step analysis macros contained a "conf.dp"
    macro.  The DEX CONFOUND command emulates the computations of this
    macro.  This command was added for performance reasons (i.e., using
    the DEX CONFOUND command is significantly faster than using the
    CONF.DP macro).

    The input to this command is the factor variables of the design
    matrix.  The response variable is not needed.

Syntax:
    LET <conftag1> <conftag2> = DEX CONFOUND  <x1> ... <xk>
                                <SUBSET/EXCEPT/FOR qualification>
    where <x1> ... <xk> is a list of 1 to k variable names;
          <conftag1> is a vector containing the merged first component of
              the tags for the k main effects and the first component tags
              of the 2-term interactions;
          <conftag2> is a vector containing the merged second component of
              the tags for the k main effects and the second component tags
              of the 2-term interactions;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    The <conftag1> and <conftag2> variables are typically called CONFTAG1
    and CONFTAG2.

    In addition to <conftag1> and <conftag2>, a number of strings starting
    with "STC" and "STT" are automatically created and saved.  It is these
    strings which are of primary interest.  The STC strings are the strings
    for the confounding and the STT strings are the strings for the primary
    tags.  These strings are used by subsequent macros in the 10-step
    analysis for labeling the plots with the confounding structure.

Examples:
    LET CONFTAG1 CONFTAG2 = DEX CONFOUND X1 X2 X3
    LET CONFTAG1 CONFTAG2 = DEX CONFOUND X1 X2 X3 X4 X5

    LET STALL = STRING COMBINE X1 TO X8
    LET CONFTAG1 CONFTAG2 = DEX CONFOUND ^STALL

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DEX CORE                 = Determine the core vectors spanning the
                               (n-1) space (or a large part of it) for
                               effect estimation in the analysis of 2-level
                               full and fractional factorial designs.
    CODE DEX                 = Convert data to -1, 0, +1 coding.
    CODE DEX 2-LEVEL         = Generate a coded variable for a factor
                               variable used in analyzing a 2-level full
                               or fractional factorial design.
    DEX CHECK CLASSIC        = Check if factor variables are in classic
                               ("-1", "+1") form.
    DEX CHECK CENTER POINTS  = Given a list of factor variables, create a
                               tag variable that will identify center
                               points.
 
Applications:
    Analysis of 2-level full and fractional factorial designs
 
Implementation Date:
    2018/02
 
Program:
    dimension 40 columns
    skip 25
    read scott_8_16.dat y x1 to x8
    let stall = string combine x1 to x8
    let conftag1 conftag2 = dex confound ^stall
    set write decimals 3
    print conftag1 conftag2
    status f

-----DEX CONTOUR PLOT-----------------------------------------------
 
DEX CONTOUR PLOT
 
Name:
    DEX CONTOUR PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a linear dex contour plot.
 
Description:
    A contour plot is a graphical technique for representing a
    3-dimensional z = f(x,y) surface by plotting constant-z "slices"
    (contours) on a 2-dimensional format.

    The dex contour plot is a specialized contour plot used in the
    design of experiments..  It is used in the case where you have
    two independent factors, each with two levels.  The
    low level is coded as "-1" and the high level is coded as
    "+1".  In addition, you can optionally have center points
    (center points are coded as "0" and represent the value
    of the independent variable halfway between the low level and
    high level of that variable).  These types of designs are
    common for full and fractional factorial designs.
    The dex contour plot is typically generated for the two
    most important factors in the full or fractional factorial
    design.  The determination of exactly which are the two
    most important factors is determined prior to generating
    the dex contour plot (e.g., through the use of dex mean
    plots).

    The typical application of the dex contour plot is in
    determining settings that will maximize (or minimize) the
    response variable.  It can also be helpful in determining
    settings that result in the response variable hitting a
    pre-determined target value.

    The following are the primary steps in the construction
    of the dex contour plot.

    1) The x and y axes of the plot represent the values
       of the first and second factor (independent) variable.

    2) The 4 vertex points are drawn.  The vertex points are
       (-1,-1), (-1,1), (1,1), (1,-1).  At each vertex point,
       the average of all the response values at that vertex
       point is printed.

    3) Similarly, if there are center points, a point is drawn
       at (0,0) and the average of the response values at the
       center points is printed.

    4) The linear dex contour plot assumes the model:

          Y = MU + 0.5*(B1*U1 + B2*U2 + B12*U1*U2)

       where MU is the overall mean of the response variables.
       The values of B0, B1, B12, and MU are estimated from
       the vertex points using a Yates analysis (the Yates
       analysis utilizes the special structure of the
       2-level full and fractional factorial designs to 
       simplify the computation of these parameters).  Note
       that Dataplot does not in fact generate a full Yates
       analysis at this point, it simply utilizes the Yates
       algorithm for determing the estimates for these 
       specific parameters.

       In order to generate a single contour line, we need a
       value for Y, say Y0.  Next, we solve for U2 in terms
       of U1 and, after doing the algebra, we have the equation:

          U2 = (2*(Y0 - MU) - B1*U1)/(B2 + B12*U1)

       We generate a sequence of points for U1 in the range
       -2 to 2 and compute the corresponding values of U2.
       These points constitute a single contour line corresponding
       to Y = Y0.

       The user specifies the target values for which contour
       lines will be generated.

    5) Dataplot generates a curvature test.  This is printed
       as part of the alpanumeric output, not on the graph
       itself.

       The curvature test is a t-test based on the response
       values at the vertex points and the center points.
       Note that this test is only applied if center points
       are in fact present.  Also, the center points are
       NOT utilized in the estimation of B1, B2, and B12.
       They are only used as part of the curvature test.

       The curvature test is used in determining if the linear
       model is an fact an adequate model for the data.  If
       the null hypothese is rejected, the linear model is
       not adequate.  In that case, we would probably consider
       the use of a quadratic, as oppossed to a linear, model.

       Dataplot does not generate a dex contour plot for the
       quadratic case directly.  However, the built-in macro,
       DEXCONTQ.DP, can be used.  Enter LIST DEXCONTQ.DP for
       details on how to run this macro.  This macro uses the
       Dataplot CONTOUR PLOT and FIT commands to generate
       the quadratic dex contour plot.

Syntax:
    DEX CONTOUR PLOT <y> <x1> <x2> <ycont>
                              <SUBSET/EXCEPT/FOR qualification>
    where <y>  is the response (= dependent) variable;
          <x1> is the first factor (= independent) variable;
          <x2> is the second factor (= independent) variable;
          <ycont> is the variable containing the desired
               contour levels;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET YCONT = SEQUENCE 30 5 90
    DEX CONTOUR PLOT Y X1 X2 YCONT
 
Note:
    The appearance of the plot is controlled by the settings
    of the LINE and CHARACTER command.  In addition, you can
    use the attribute settings for LINE and CHARACTER (e.g.,
    color, thickness) to further control the appearance.

    Specifically, if the design has center points, then
    the line and character settings are controlled by:

       trace 1 = labels for the points at (-1,-1) and (-1,1).  The
                 character setting is automatically set to a special type
                 called ZVAL and line is set to blank.  The character
                 justification is automatically set to RIGHT.  Although
                 the character type and justification are fixed, you can
                 still set the other CHARACTER attributes.  For example,
                 you can use CHARACTER OFFSET to position the text.
       trace 2 = labels for the points at (+1,-1), (-1,1) and (0,0).  The
                 character setting is automatically set to a special type
                 called ZVAL and line is set to blank.  The character
                 justification is automatically set to LEFT.  Although
                 the character type and justification are fixed, you can
                 still set the other CHARACTER attributes.  For example,
                 you can use CHARACTER OFFSET to position the text.
       trace 3 = the center point.  The line setting is typically
                 blank and the character type is commonly set to
                 CIRCLE.
       trace 4 = line connecting (-1,-1), (1,-1), (1,1), (-1,1).
                 The line type is typically set to SOLID and the
                 character type is typically set to CIRCLE.
       trace 5+= the contour lines start with trace 5.  There is
                 one trace for each value of YCONT.  This allows
                 you to set the attributes for each contour line
                 individually.  For example, you may want to
                 draw a thickened or colored line at the
                 maximum or minimum contour level.  By default,
                 the contour levels are drawn from the maximum
                 to the minimum value.

    If the design does not have center points, then
    the line and character settings are controlled by:

       trace 1 = labels for the points at (-1,-1) and (-1,1).  The
                 character setting is automatically set to a special type
                 called ZVAL and line is set to blank.  The character
                 justification is automatically set to RIGHT.  Although
                 the character type and justification are fixed, you can
                 still set the other CHARACTER attributes.  For example,
                 you can use CHARACTER OFFSET to position the text.
       trace 2 = labels for the points at (+1,-1) and (-1,1).  The
                 character setting is automatically set to a special type
                 called ZVAL and line is set to blank.  The character
                 justification is automatically set to LEFT.  Although
                 the character type and justification are fixed, you can
                 still set the other CHARACTER attributes.  For example,
                 you can use CHARACTER OFFSET to position the text.
       trace 3 = line connecting (-1,-1), (1,-1), (1,1), (-1,1).
                 The line type is typically set to SOLID and the
                 character type is typically set to CIRCLE.
       trace 4+= the contour lines start with trace 4.  There is
                 one trace for each value of YCONT.  This allows
                 you to set the attributes for each contour line
                 individually.  For example, you may want to
                 draw a thickened or colored line at the
                 maximum or minimum contour level.  By default,
                 the contour levels are drawn from the maximum
                 to the minimum value.

Note:
    By default, the contour levels are drawn from the maximum
    value to the minimum value.

    If you want to draw the contour levels from the minimum to
    the maximum, then enter the command:

        SET DEX CONTOUR PLOT MINIMUM

    To reset the default, enter

        SET DEX CONTOUR PLOT MAXIMUM

    Typically, it is common to highlight the maximum contour
    line when you are trying to maximize the response and to
    highlight the minimum contour line when you are trying to
    minimize the response.  The SET DEX CONTOUR PLOT command
    can help simplify this by ensuring that the first 
    contour line drawn is the one you highlight.

Note:
    In cases where there are more than two important factors,
    you may want to generate the dex contour plot for several
    different pairs.  All the pairwise combinations for 3 or
    more factors can be generated via a matrix plot.  Enter
    HELP SCATTER PLOT MATRIX for details.  See Program 2 below
    for an example of this.
    
Note:
    The DEX CONTOUR PLOT command assumes a linear model for
    the fit.  You can use the macro DEXCONTQ.DP to generate
    a dex contour plot assuming a quadratic model.  Enter
    LIST DEXCONTQ.DP for details.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DEX MEAN PLOT      = Generate a dex mean plot.
    YATES              = Perform a Yates analysis.
    CONTOUR PLOT       = Generates a contour plot.
 
Reference:
    "Statistics for Experimenters", Box, Hunter, and Hunter,
    John Wiley, 1978, pp. 296-300.
 
Applications:
    Design of Experiments
 
Implementation Date:
    2000/7
 
Program 1:
    SKIP 25
    READ BOXYIELD.DAT Y X1 X2
    LET YCONT = SEQUENCE 50 2 70
    CHARACTER ZVAL ZVAL CIRCLE CIRCLE
    CHARACTER FILL OFF OFF ON ON
    CHARACTR HW 2 1.5 2 1.5
    CHARACTER OFFSET -2 0 1 0
    LINE SOLID ON ALL
    LINE BLANK BLANK BLANK
    LINE THICKNESS 0.1 0.1 0.1 0.1 0.3
    Y1LABEL X1
    X1LABEL X2
    TITLE CASE ASIS
    TITLE DEX Contour Plot: BOXYIELD.DAT
    LIMITS -2 2
    TIC MARK OFFSET UNITS SCREEN
    TIC MARK OFFSET 5 5
    DEX CONTOUR PLOT Y X1 X2 YCONT
 
Program 2:
    skip 25
    read boxclean.dat y x1 x2 x3 x4
    let ycont = sequence 10 1 20
    .
    multiplot corner coordinates 10 10 90 90
    multiplot scale factor 2.5
    xtic offset 5 5
    ytic offset 5 5
    tic offset units screen
    x1label displacement 4
    .
    line bl so
    char zval circ 
    char fill off on
    line thickness 0.1 0.1 0.3
    set matrix plot type dex contour plot
    set matrix plot tag on
    matrix plot y x1 x2 x3 x4 ycont
    .
    move 50 97
    justification center
    text dex contour plot matrix for boxclean.dat
 
-----DEX CORE-----------------------------------------
 
DEX CORE
 
Name:
    DEX CORE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Determine the core vectors spanning the (n-1) space (or a large part
    of it) for effect estimation in the analysis of 2-level full and
    fractional factorial designs.
 
Description:
    The "dex10stepanalysis.dp" macro can be used to analyze 2-level full
    or fractional factorial designs.  A key step in the analysis of these
    designs is the estimation of the effects and the determination of the
    confounding structure.  The "dex10stepanalysis.dp" macro calls the
    "compute_effect_estimates_and_confounding.dp" macro to perform the
    effect estimation.  The DEX CORE command is a utility command used in
    the "compute_effect_estimates_and_confounding.dp" macro and is not
    typically used outside of this context.

    Previous versions of the 10-step analysis macros contained a "core.dp"
    macro.  The DEX CORE command emulates the computations of this macro.

    The input to this command is the factor variables of the design
    matrix.  The response variable is not needed.  The output is a
    matrix containing five core factors.

Syntax:
    LET <m> = DEX CORE  <x1> ... <xk>   <SUBSET/EXCEPT/FOR qualification>
    where <x1> ... <xk> is a list of 1 to k variable names;
          <m> is a matrix  where the core factors will be saved.
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Examples:
    LET CORE = DEX CORE X1 X2 X3
    LET CORE = DEX CORE X1 X2 X3 X4 X5

    LET STALL = STRING COMBINE X1 TO X8
    LET CORE = DEX CORE ^STALL

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DEX CONFOUND             = Determine the confounding structure of a
                               2-level full or fractional factorial design.
    CODE DEX                 = Convert data to -1, 0, +1 coding.
    CODE DEX 2-LEVEL         = Generate a coded variable for a factor
                               variable used in analyzing a 2-level full
                               or fractional factorial design.
    DEX CHECK CLASSIC        = Check if factor variables are in classic
                               ("-1", "+1") form.
    DEX CHECK CENTER POINTS  = Given a list of factor variables, create a
                               tag variable that will identify center
                               points.
 
Applications:
    Analysis of 2-level full and fractional factorial designs
 
Implementation Date:
    2018/02
 
Program:
    skip 25
    read scott_8_16.dat y x1 to x8
    let stall = string combine x1 to x8
    let core = dex core ^stall
    set write decimals 3
    print core

-----DEX DEPTH-------------------------------------------------------
 
DEX DEPTH
 
Name:
    DEX DEPTH
 
Note:
    This command is used for some DEX commands that are intended for
    future implementation.  It currently has no effect on any DEX
    plots.
 
Type:
    Plot Control
 
Purpose:
    Specifies the depth of interaction terms in subsequent DEX plots.
 
Syntax:
    DEX DEPTH <depth>
    where <depth> is an integer number or parameter (typically between
                  1 and 3) that specifies the desired depth.
 
Examples:
    DEX DEPTH 1
    DEX DEPTH 2
    DEX DEPTH 3
 
Default:
    The default depth is 1 (i.e., main effects only).
 
Synonyms:
    None
 
Related Commands:
    DEX HORIZONTAL  = Specifies the horizontal axis variable for some
                      DEX plots.
 
Applications:
    Design of Experiments
 
Implementation Date:
    89/12
 
Program:
    XX
 
-----DEX HORIZONTAL AXIS-----------------------------------------------
 
DEX HORIZONTAL AXIS
 
Name:
    DEX HORIZONTAL AXIS
 
Note:
    This command is used for some DEX commands that are intended for
    future implementation.  It currently has no effect on any DEX
    plots.
 
Type:
    Plot Control
 
Purpose:
    Specifies whether factors or terms or used as the horizontal axis
    variables on some subsequent DEX plots.
 
Syntax:
    DEX HORIZONTAL AXIS <FACTOR/TERM>
    where FACTOR specifies factors and TERM specifies terms as the
             horizontal axis variable on subsequent DEX plots.
 
Examples:
    DEX HORIZONTAL AXIS FACTOR
    DEX HORIZONTAL AXIS TERM
 
Default:
    FACTOR
 
Synonyms:
    None
 
Related Commands:
    DEX DEPTH    = Specifies the depth of interaction terms on some
                   subsequent DEX plots.
 
Applications:
    Design of Experiments
 
Implementation Date:
    89.12
 
Program:
    XX
 
-----DEXPDF (LET)--------------------------------
 
DEXPDF
 
Name:
    DEXPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the double exponential (also known as
    the Laplace distribution) probability density function.
 
Description:
    The standard form of the double exponential distribution has the
    following probability density function:
       f(x) = 0.5*exp(-abs(x))
    The input value can be any real number.
 
Syntax:
    LET <y2> = DEXPDF(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, a number, or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed double exponential pdf value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DEXPDF(3)
    LET A = DEXPDF(A1)
    LET X2 = DEXPDF(X1)
 
Note:
    The general form of the double exponential distribution is:
        f(x) = (0.5/beta)*exp(-abs(x-u)/beta)
    The parameter u is a location parameter and the parameter beta is a
    scale parameter that must be greater than 0.  The pdf values for the
    general double exponential distributions can be computed by doing
    something like the following:
        LET U = <value>
        LET BETA = <value>
        PLOT (1/BETA)*DEXPDF((X-U)/BETA) FOR X = -4 .1 4
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DEXCDF = Compute the double exponential cumulative distribution
             function.
    DEXPPF = Compute the double exponential percent point function.
    EXPCDF = Compute the exponential cumulative distribution function.
    EXPPDF = Compute the exponential probability density function.
    EXPPPF = Compute the exponential percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    EV1CDF = Compute the extreme value type I cumulative distribution
             function.
    EV1PDF = Compute the extreme value type I probability density
             function.
    EV1PPF = Compute the extreme value type I percent point function.
    CHSPDF = Compute the chi-square probability density function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPPF = Compute the chi-square percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, Houghton
    Mifflin, 1970 (chapter 23).
 
Applications:
    XX
 
Implementation Date:
    94/4
 
Program:
    YLIMITS 0 0.5
    MAJOR YTIC NUMBER 6
    MINOR YTIC NUMBER 1
    YTIC DECIMAL 1
    XLIMITS -4 4
    XTIC OFFSET 0.6 0.6
    TITLE AUTOMATIC
    PLOT DEXPDF(X) FOR X = -4.5 0.01 4.5
 
-----DEXPPF (LET)--------------------------------
 
DEXPPF
 
Name:
    DEXPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the double exponential (also known as
    the Laplace) percent point function.
 
Description:
    The standard form of the double exponential distribution has the
    following probability density function:
       f(x) = 0.5*exp(-abs(x))
    The percent point function is the inverse of the cumulative
    distribution function.  The cumulative distribution sums the
    probability from 0 to the given x value (i.e., the integral of the
    above function).  The percent point function takes a cumulative
    probability value and computes the corresponding x value.
 
    The input value is a real number between 0 and 1 (since it
    corresponds to a probability).  The output value can be any real
    number.
 
Syntax:
    LET <y2> = DEXPPF(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, a number, or a parameter in the range 0
               to 1;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed normal ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DEXPPF(0.9)
    LET A = DEXPPF(A1)
    LET X2 = DEXPPF(X1)
 
Note:
    The general form of the double exponential distribution is:
        f(x) = (0.5/beta)*exp(-abs(x-u)/beta)
    The parameter u is a location parameter and the parameter beta is a
    scale parameter that must be greater than 0.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DEXCDF = Compute the double exponential cumulative distribution
             function.
    DEXPDF = Compute the double exponential probability density
             function.
    EXPCDF = Compute the exponential cumulative distribution function.
    EXPPDF = Compute the exponential probability density function.
    EXPPPF = Compute the exponential percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    EV1CDF = Compute the extreme value type I cumulative distribution
             function.
    EV1PDF = Compute the extreme value type I probability density
             function.
    EV1PPF = Compute the extreme value type I percent point function.
    CHSPDF = Compute the chi-square probability density function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPPF = Compute the chi-square percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, Houghton
    Mifflin, 1970 (chapter 23).
 
Applications:
    XX
 
Implementation Date:
    94/4
 
Program:
    XLIMITS 0 1
    MAJOR XTIC NUMBER 6
    MINOR XTIC NUMBER 1
    XTIC DECIMAL 1
    TITLE AUTOMATIC
    PLOT DEXPPF(X) FOR X = 0.01 .01 0.99
 
-----DEX WIDTH-------------------------------------------------------
 
DEX WIDTH
 
Name:
    DEX WIDTH
 
Type:
    Plot Control
 
Purpose:
    Specifies the width of the subplot area on subsequent  DEX SCATTER
    PLOT commands.
 
Description:
    The DEX SCATTER PLOT command generates a subplot area for each
    factor variable along the horizontal axis.  The DEX WIDTH specifies
    the width of these subplots along the X axis (factors are plotted
    at integer values along the horizontal axis starting with 1).
 
Syntax:
    DEX WIDTH <width>
    where <width> is a number or parameter that specifies the desired
                  width.  It should have a value between 0 and 1
                  (greater than 1 causes the subplots to overlap).
 
Examples:
    DEX WIDTH 0.4
    DEX WIDTH 0.5
    DEX WIDTH AWIDTH
 
Default:
    The default width is 0.4.
 
Synonyms:
    None
 
Related Commands:
    LINES                          = Sets the type for plot lines.
    CHARACTER                      = Sets the type for plot characters
    PLOT                           = Generates a data or function plot.
    DEX SCATTER PLOT               = Generates a dex scatter plot.
    DEX SIGN PLOT                  = Generates a dex sign plot.
    DEX ... PLOT                   = Generates a dex plot for a
                                     statistic.
    DEX ... PARETO PLOT            = Generates a Pareto dex plot for a
                                     statistic.
    DEX ... YOUDEN PLOT            = Generates a Youden dex plot for a
                                     statistic.
    DEX ... EFFECTS PLOT           = Generates a dex effects plot for a
                                     statistic.
    DEX ... PARETO EFFECTS PLOT    = Generates a Pareto effects dex
                                     plot for a statistic.
    DEX ... ABSOLUTE EFFECTS PLOT  = Generates an absolute effects dex
                                     plot for a statistic.
    DEX ... PARE ABSO EFFECTS PLOT = Generates a Pareto absolute
                                     effects dex plot for a statistic.
 
Reference:
    "Statistics for Experimenters", Box, Hunter, and Hunter, John
    Wiley, 1978.
 
Applications:
    Design of Experiments
 
Implementation Date:
    89.12
 
Program:
    . FIT OF CHEMICAL YIELD AS A FUNCTION OF TIME AND TEMPERATURE
    . BOX, HUNTER & HUNTER (1978), STATISTIC FOR EXPERIMENTERS
    . WILEY, PAGE 519  (FILE BOXYIEL2.DAT IN REFERENCE DIRECTORY)
    READ Y X1 X2
    78.8    -1      -1
    84.5    +1      -1
    91.2    -1      +1
    77.4    +1      +1
    89.7     0       0
    86.8     0       0
    83.3    -1.414   0
    81.2    +1.414   0
    81.2     0      -1.414
    79.5     0      +1.414
    87.0     0       0
    86.0     0       0
    END OF DATA
    CHARACTERS X BLANK
    LINE BLANK SOLID
    YLIMITS 75 90
    Y1LABEL CHEMICAL YIELD
    YTIC OFFSET 0 2
    XLIMITS 1 2
    XTIC OFFSET 0.5 0.5
    MAJOR XTIC MARK NUMBER 2
    MINOR XTIC MARK NUMBER 0
    XTIC MARK LABEL FORMAT ALPHA
    XTIC MARK LABEL CONTENT TIME TEMPERATURE
    X1LABEL FACTORS
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE DEFAULT WIDTH
    DEX SCATTER PLOT Y X1 TO X2
    DEX WIDTH 0.8
    TITLE DEX WIDTH 0.8
    DEX SCATTER PLOT Y X1 TO X2
    DEX WIDTH 0.2
    TITLE DEX WIDTH 0.2
    DEX SCATTER PLOT Y X1 TO X2
    DEX WIDTH 1.0
    TITLE DEX WIDTH 1.0
    DEX SCATTER PLOT Y X1 TO X2
    END OF MULTIPLOT
 
-----DEX SCATTER PLOT-----------------------------------------------
 
DEX SCATTER PLOT
 
Name:
    DEX SCATTER PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a dex scatter plot.
 
Description:
    A dex scatter plot is a graphical method for representing a design
    of experiment problem.  The first variable is a response variable
    while the remaining variables (must be at least one) represent
    levels of factors.  Qualitative levels are coded as indices (e.g.,
    1 for process A, 2 for process B).  A separate subplot is drawn for
    each factor with the subplot for factor k centered horizontally at
    x=k.  Each subplot has a given horizontal width (defined by the DEX
    WIDTH command, defaults to 0.5).  For example, the subplot for
    factor 2 ranges from 1.75 to 2.25 on the horizontal axis.  The
    levels of the factor are assigned an x coordinate within this range
    (from lowest to highest).  Then within each subplot:
       Vertical   axis = value of the response variable;
       Horizontal axis = value of the level of a given factor.
    This plot graphically shows the following:
       1) How the response variable varies with the level of the
          factor.
       2) How the response variable varies between factors.
 
Syntax:
    DEX SCATTER PLOT <y1> <x1 ... xn> <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the response variable;
          <x1 ... xn> is a sequence of variables representing factors
               in a designed experiment;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    DEX SCATTER PLOT Y X1 X2
    DEX SCATTER PLOT Y X1 X2 X3
    DEX SCATTER PLOT Y X1 X2 X3 X4
    DEX SCATTER PLOT Y X1 TO X3
    DEX SCATTER PLOT Y X1 TO X4
 
Note:
    The TO syntax is allowed for the list of factor variables (see the
    EXAMPLES above).
 
Note:
    The CHARACTER and LINE settings can be used to control the
    appearance of the plot.  The first trace is typically drawn with a
    blank line and some type of character set (the choice of character
    is a matter of user preference).  The second trace draws a
    horizontal line at the overall mean.  It is typically drawn with a
    blank character and a solid line (some analysts may prefer a dashed
    or dotted line).  In any event, the user must explicitly set
    character and line settings (they default to all lines solid and
    all characters blank).
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LINES                          = Sets the type for plot lines.
    CHARACTER                      = Sets the type for plot characters
    PLOT                           = Generates a data or function plot.
    DEX SIGN PLOT                  = Generates a dex sign plot.
    DEX ... PLOT                   = Generates a dex plot for a
                                     statistic.
    DEX ... PARETO PLOT            = Generates a Pareto dex plot for a
                                     statistic.
    DEX ... YOUDEN PLOT            = Generates a Youden dex plot for a
                                     statistic.
    DEX ... EFFECTS PLOT           = Generates a dex effects plot for a
                                     statistic.
    DEX ... PARETO EFFECTS PLOT    = Generates a Pareto effects dex
                                     plot for a statistic.
    DEX ... ABSOLUTE EFFECTS PLOT  = Generates an absolute effects dex
                                     plot for a statistic.
    DEX ... PARE ABSO EFFECTS PLOT = Generates a Pareto absolute
                                     effects dex plot for a statistic.
    DEX WIDTH                      = Specifies the width of levels in a
                                     dex plot.
 
Reference:
    "Statistics for Experimenters", Box, Hunter, and Hunter, John
    Wiley, 1978.
 
Applications:
    Design of Experiments
 
Implementation Date:
    89.12
 
Program:
    . FIT OF CHEMICAL YIELD AS A FUNCTION OF TIME AND TEMPERATURE
    . BOX, HUNTER & HUNTER (1978), STATISTIC FOR EXPERIMENTERS
    . WILEY, PAGE 519  (FILE BOXYIEL2.DAT IN REFERENCE DIRECTORY)
    READ Y X1 X2
    78.8    -1      -1
    84.5    +1      -1
    91.2    -1      +1
    77.4    +1      +1
    89.7     0       0
    86.8     0       0
    83.3    -1.414   0
    81.2    +1.414   0
    81.2     0      -1.414
    79.5     0      +1.414
    87.0     0       0
    86.0     0       0
    END OF DATA
    CHARACTERS X BLANK
    LINE BLANK SOLID
    YLIMITS 75 90
    Y1LABEL CHEMICAL YIELD
    YTIC OFFSET 0 2
    XLIMITS 1 2
    XTIC OFFSET 0.5 0.5
    MAJOR XTIC MARK NUMBER 2
    MINOR XTIC MARK NUMBER 0
    XTIC MARK LABEL FORMAT ALPHA
    XTIC MARK LABEL CONTENT TIME TEMPERATURE
    X1LABEL FACTORS
    DEX SCATTER PLOT Y X1 TO X2
 
-----DEX SIGN PLOT-----------------------------------------------
 
DEX SIGN PLOT
 
Name:
    DEX SIGN PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a dex sign plot.
 
Description:
    A dex sign plot is a graphical method for representing a design of
    experiment problem.  The first variable is a response variable
    while the remaining variables (must be at least one) represent
    levels of factors.  Qualitative levels are coded as indices (e.g.,
    1 for process A, 2 for process B). A separate subplot is drawn for
    each factor with the subplot for factor k plotted horizontally at
    x=k.  Then within each subplot, the plot consists of:
       Vertical   axis = value of the response variable.  Each level
                         within a factor is plotted as a separate
                         trace.
       Horizontal axis = factor id (i.e., factor 1 at x=1, factor 2 at
                         x=2, etc.).
    This plot graphically shows the following:
       1) How the response variable varies with the level of the
          factor.
       2) How the response variable varies between factors.
 
Syntax:
    DEX SIGN PLOT <y1> <x1 ... xn> <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the response variable;
          <x1 ... xn> are a sequence of variables representing factors
               in a designed experiment;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    DEX SIGN PLOT Y X1 X2
    DEX SIGN PLOT Y X1 X2 X3
    DEX SIGN PLOT Y X1 X2 X3 X4
    DEX SIGN PLOT Y X1 TO X4
 
Note:
    This command is similar to the DEX SCATTER PLOT command.  There are
    two distinctions.  First, the levels of the factor variables are
    plotted with different traces.  This allows the levels to be
    clearly identified.  Second, the levels of a factor are plotted at
    the same horizontal axis value.
 
Note:
    The most common use of this plot is when all factor variables have
    exactly two levels.  The lower level is plotted with a minus sign
    and the upper level is plotted with a plus sign (this is where the
    term DEX SIGN PLOT comes from).
 
Note:
    The CHARACTER and LINE settings can be used to control the
    appearance of the plot.  If NLEVELS is the maximum number of levels
    in a factor, then the first NLEVELS traces are typically drawn with
    a blank line and with a unique character identifier.  Typically, if
    there are exactly 2 levels for each factor, the characters are set
    to a minus and plus sign respectively.  If there are more than 2
    levels, using 1, 2, 3, etc. works well. The NLEVELS+1 trace draws a
    horizontal line at the overall mean.  This is typically drawn with
    a blank character and a solid line (some analysts may prefer a
    dashed or dotted line).  In any event, the user must explicitly set
    character and line settings (they default to all lines solid and
    all characters blank).
 
Note:
    The program example below shows how to put the factor labels on the
    X axis.
 
Note:
    The TO syntax is allowed for the list of factor variables (see the
    EXAMPLES above).
 
Default:
    None
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LINES                          = Sets the type for plot lines.
    CHARACTER                      = Sets the type for plot characters
    PLOT                           = Generates a data or function plot.
    DEX SCATTER PLOT               = Generates a dex scatter plot.
    DEX ... PLOT                   = Generates a dex plot for a
                                     statistic.
    DEX ... PARETO PLOT            = Generates a Pareto dex plot for a
                                     statistic.
    DEX ... YOUDEN PLOT            = Generates a Youden dex plot for a
                                     statistic.
    DEX ... EFFECTS PLOT           = Generates a dex effects plot for a
                                     statistic.
    DEX ... PARETO EFFECTS PLOT    = Generates a Pareto effects dex
                                     plot for a statistic.
    DEX ... ABSOLUTE EFFECTS PLOT  = Generates an absolute effects dex
                                     plot for a statistic.
    DEX ... PARE ABSO EFFECTS PLOT = Generates a Pareto absolute
                                     effects dex plot for a statistic.
    DEX WIDTH                      = Specifies the width of levels in a
                                     dex plot.
 
Reference:
    "Statistics for Experimenters", Box, Hunter, and Hunter, John
    Wiley, 1978.
 
Applications:
    Design of Experiments
 
Implementation Date:
    89.12
 
Program:
    . CAT/TEMP/PRES/CONC EFFECT ON CHEMICAL PROCESS CONVERSION YIELD
    . BOX, HUNTER & HUNTER (1978), STATISTIC FOR EXPERIMENTERS, WILEY,
    . P 325.  2**4 FULL FACTORIAL DESIGN, NUMBER OF OBSERVATIONS = 16
    .    RESPONSE VARIABLE = % CONVERSION
    .    FACTOR 1 = CATALYST CHARGE (2 LEVELS--10 & 15 POUNDS)
    .    FACTOR 2 = TEMPERATURE     (2 LEVELS--220 & 240 DEG C)
    .    FACTOR 3 = PRESSURE        (2 LEVELS--50 & 80 PSI)
    .    FACTOR 4 = CONCENTRATION   (2 LEVELS--10 & 12 %)
    .    ORDER NUMBER = ORDER IN WHICH DATA WAS COLLECTED
    LET Y = DATA 71 61 90 82 68 61 87 80 61 50 89 83 59 51 85 78
    LET X1 = DATA -1 +1 -1 +1 -1 +1 -1 +1 -1 +1 -1 +1 -1 +1 -1 +1
    LET X2 = DATA -1 -1 +1 +1 -1 -1 +1 +1 -1 -1 +1 +1 -1 -1 +1 +1
    LET X3 = DATA -1 -1 -1 -1 +1 +1 +1 +1 -1 -1 -1 -1 +1 +1 +1 +1
    LET X4 = DATA -1 -1 -1 -1 -1 -1 -1 -1 +1 +1 +1 +1 +1 +1 +1 +1
    .
    CHARACTERS - + BLANK
    LINE BLANK BLANK SOLID
    YLIMITS 50 90
    Y1LABEL PERCENT CONVERSION
    YTIC OFFSET 5 5
    XLIMITS 1 4
    XTIC OFFSET 0.5 0.5
    MAJOR XTIC MARK NUMBER 4
    MINOR XTIC MARK NUMBER 0
    XTIC MARK LABEL FORMAT ALPHA
    XTIC MARK LABEL CONTENT CATALYST TEMPERATURE PRESSURE CONCENTRATION
    X1LABEL FACTORS
    DEX SIGN PLOT Y X1 TO X4
 
-----DEX ... PLOT-------------------------------------------
 
DEX PLOT
 
Name:
    DEX <statistic> PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a Design of Experiment (dex) plot for a given statistic.
 
Description:
    A dex statistic plot is a graphical method for representing a
    design of experiment problem.  The first variable is a response
    variable while the remaining variables (there must be at least one)
    represent levels of factors.  A separate subplot is drawn for each
    factor with the subplot for factor k centered horizontally at x=k.
    Each subplot has a given horizontal width (defined by the DEX WIDTH
    command, defaults to 0.5).  For example, the subplot for factor 2
    ranges from 1.75 to 2.25 on the horizontal axis.  The levels of the
    factor are assigned an x coordinate within this range (from lowest
    to highest).  Then within each subplot:

       Vertical   axis = value of the computed statistic from the
                         response variable (i.e., compute the statistic
                         for all values with the same level for a given
                         factor);
       Horizontal axis = value of the level of a given factor.

    This plot graphically shows the following:

       1) How the statistic for the response variable varies with the
          level of the factor.

       2) How the statistic for the response variable varies between
          factors.

    The DEX ... PLOT is most commonly used for the mean.  However, you
    can in fact generate this plot for any statistic supported in
    Dataplot. The primary application of this plot is in the analysis
    of 2-level full or fractional designs to identify the most important
    factors.

Syntax:
    DEX <stat> PLOT <y1> ... <y3> <x1> ... <xk>
                    <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <y3> is a list of one to three response variables
               (depending on the requested statistic);
          <x1> ... <xk> is a list of one to k factor variables;
          <stat> is the desired statistic;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    For a list of supported statistics, enter HELP STATISTICS.
 
Examples:
    DEX MEAN PLOT Y X1 X2
    DEX MEDIAN PLOT Y X1 X2
    DEX SD PLOT Y X1 X2 X3
    DEX RANGE PLOT Y X1 X2 X3 X4
    DEX SD PLOT Y X1 TO X3
    DEX MEAN PLOT Y X1 TO X8
 
Note:
    This plot is most typically generated for a location statistic
    (typically the mean or median) or a spread statistic (typically
    the standard deviation or range).  The other statistics are rarely
    used.
 
Note:
    The TO syntax is allowed for the list of factor variables (see the
    EXAMPLES above).
 
Note:
    The CHARACTER and LINE settings can be used to control the
    appearance of the plot.  The first trace is typically drawn with a
    blank line and some type of character set (the choice of character
    is a matter of user preference).  The second trace draws a
    horizontal line at the value for the specified statistic for the
    entire response variable.  This is typically drawn with a blank
    character and a solid line (some analysts may prefer a dashed or
    dotted line).  In any event, the user must explicitly set character
    and line settings (they default to all lines solid and all
    characters blank).
 
Note:
    By default, this plot is generated for the main effects only.  If
    you would like to include the 2-term interaction effects, enter

         SET DEX STATISTIC PLOT INTERACTION 2

    To include both 2-term and 3-term interaction effects, enter

         SET DEX STATISTIC PLOT INTERACTION 3

    To restore the default of main effects only, enter

         SET DEX STATISTIC PLOT INTERACTION NONE

    When interaction terms are requested, the terms are written to
    file "dpst5f.dat" in the order they are generated on the plot.
    For example, for three factor variables where both 2-term and
    3-term interactions are requested, the following will be written
    to dpst5f.dat

        X1  
        X2  
        X3  
        X1*X2
        X1*X3
        X2*X3
        X1*X2*X3

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LINES                          = Sets the type for plot lines.
    CHARACTER                      = Sets the type for plot characters
    PLOT                           = Generates a data or function plot.
    DEX SCATTER PLOT               = Generates a dex scatter plot.
    DEX SIGN PLOT                  = Generates a dex sign plot.
    DEX ... PARETO PLOT            = Generates a Pareto dex plot for a
                                     statistic.
    DEX ... YOUDEN PLOT            = Generates a Youden dex plot for a
                                     statistic.
    DEX ... EFFECTS PLOT           = Generates a dex effects plot for a
                                     statistic.
    DEX ... PARETO EFFECTS PLOT    = Generates a Pareto effects dex
                                     plot for a statistic.
    DEX ... ABSOLUTE EFFECTS PLOT  = Generates an absolute effects dex
                                     plot for a statistic.
    DEX ... PARE ABSO EFFECTS PLOT = Generates a Pareto absolute
                                     effects dex plot for a statistic.
    DEX WIDTH                      = Specifies the width of levels in a
                                     dex plot.
 
Reference:
    Box, Hunter, and Hunter (1978), "Statistics for Experimenters",
    John Wiley.
 
Applications:
    Design of Experiments
 
Implementation Date:
    1989/12: Original implementation for a limited number of statistics
    2002/08: List of supported statistics expanded.
    2019/03: Added support for SET DEX STATISTIC PLOT INTERACTION
 
Program 1:
    SKIP 25
    READ SHEESLE2.DAT Y X1 X2 X3 X4
    .
    TIC MARK LABEL CASE ASIS
    LABEL CASE ASIS
    TITLE CASE ASIS
    CASE ASIS
    X1LABEL DISPLACEMENT 12
    .
    CHARACTERS X BLANK
    LINES SOLID SOLID
    LET NFACT = 4
    XLIMITS 1 NFACT
    MAJOR XTIC MARK NUMBER NFACT
    MINOR XTIC MARK NUMBER 0
    X1TIC OFFSET 1 1
    X1TIC LABEL FORMAT ALPHA
    X1TIC LABEL CONTENT Weld Plant Speed Shift
    X1LABEL Factors
    YLIMITS 20 28
    .
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    MULTIPLOT SCALE FACTOR 2
    .
    MULTIPLOT 2 2
    Y1LABEL Mean Defects
    DEX MEAN PLOT Y X1 TO X4
    .
    Y1LABEL Median Defects
    DEX MEDIAN PLOT Y X1 TO X4
    .
    YLIMITS
    Y1LABEL Standard Deviation of Defects
    DEX SD PLOT Y X1 TO X4
    .
    Y1LABEL Range of Defects
    DEX RANGE PLOT Y X1 TO X4
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT DEX Statistic Plots for SHEESLE2.DAT
 
Program 2:
    SKIP 25
    READ SHEESLE2.DAT Y X1 TO X4
    .
    TITLE CASE ASIS
    LABEL CASE ASIS
    CHARACTERS X BLANK
    LINES SOLID SOLID
    .
    .  Generate plots with interaction terms
    .
    .  Since we want interaction terms, code to -1 and + 1
    .
    LET Z1 = CODE DEX 2-LEVEL X1
    LET Z2 = CODE DEX 2-LEVEL X2
    LET Z3 = CODE DEX 2-LEVEL X3
    .
    TIC MARK OFFSET UNITS DATA
    X1TIC MARK OFFSET 1 1
    XLIMITS 1 7
    MAJOR XTIC MARK NUMBER 7
    X1TIC MARK LABEL FORMAT ALPHA
    X1TIC MARK LABEL CONTENT X1 X2 X3 X1*X2 X1*X3 X2*X3 X1*X2*X3
    SET DEX STATISTIC PLOT INTERACTION 3
    .
    Y1LABEL Mean Defective Leads per Hour
    X1LABEL Factors
    TITLE DEX Mean Plot with 2- and 3-Term Interactions
    DEX MEAN PLOT Y Z1 Z2 Z3

-----DEX ... PARETO PLOT---------------------------------------------
 
DEX PARETO PLOT
 
Name:
    DEX <statistic> PARETO PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a dex Pareto plot for a given statistic.
 
Description:
    A dex statistic Pareto plot is a graphical method for representing
    a design of experiment problem.  The first variable is a response
    variable while the remaining variables (must be at least one)
    represent levels of factors.  These levels are often coded as
    indices (e.g., 1 for process A, 2 for process B).  The requested
    statistic is coded for each level of each factor.  These statistics
    are then ordered from high to low (this is where the Pareto term
    comes from).  The plot consists of:
       Vertical   axis = value of the computed statistic from each
                         level of each factor;
       Horizontal axis = an index value (1 for the highest value of
                         the statistic, N for the lowest value of the
                         statistic where N is the total number of
                         levels in all factors).
    This plot graphically shows the magnitude and spread of the given
    statistic for the various levels of factors.
 
Syntax:
    DEX <stat> PARETO PLOT <y1> <x1 ... xn>
                 <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the response variable;
          <x1 ... xn> are a sequence of variables representing factors
               in a designed experiment;
          <stat> is one of the following statistics:
              MEAN, MIDMEAN, MEDIAN, TRIMMED MEAN, WINSORIZED MEAN,
              GEOMETRIC MEAN, HARMONIC MEAN, HODGES LEHMAN,
              BIWEIGHT LOCATION,
              SUM, PRODUCT, SIZE (or NUMBER or SIZE),
              STANDARD DEVIATION, STANDARD DEVIATION OF MEAN,
              VARIANCE, VARIANCE OF THE MEAN,
              TRIMMED MEAN STANDARD ERROR,
              AVERAGE ABSOLUTE DEVIATION (or AAD),
              MEDIAN ABSOLUTE DEVIATION (or MAD),
              IQ RANGE, BIWEIGHT MIDVARIANCE, BIWEIGHT SCALE,
              PERCENTAGE BEND MIDVARIANCE,
              WINSORIZED VARIANCE, WINSORIZED STANDARD DEVIATION,
              RELATIVE STANDARD DEVIATION, RELATIVE VARIANCE (or
                 COEFFICIENT OF VARIATION),
              RANGE, MIDRANGE, MAXIMUM, MINIMUM, EXTREME,
              LOWER HINGE, UPPER HINGE, LOWER QUARTILE, UPPER QUARTILE,
              <FIRST/SECOND/THIRD/FOURTH/FIFTH/SIXTH/SEVENTH/EIGHTH/
                  NINTH/TENTH> DECILE,
              PERCENTILE, QUANTILE, QUANTILE STANDARD ERROR,
              SKEWNESS, KURTOSIS, NORMAL PPCC,
              AUTOCORRELATION, AUTOCOVARIANCE,
              SINE FREQUENCY, SINE AMPLITUDE,
              CP, CPK, CNPK, CPM, CC,
              EXPECTED LOSS, PERCENT DEFECTIVE,
              TAGUCHI SN0 (or SN), TAGUCHI SN+ (or SNL),
              TAGUCHI SN- (or SNS), TAGUCHI SN00 (or SN2);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    DEX MEAN PARETO PLOT Y X1 X2
    DEX SD PARETO PLOT Y X1 X2 X3
    DEX RANGE PARETO PLOT Y X1 X2 X3 X4
    DEX RANGE PARETO PLOT Y X1 TO X4
 
Note:
    This plot is similar to the DEX ... PLOT command.  The distinction
    is that the Pareto version sorts by the value of the statistic
    while the DEX .. PLOT command does not.  The Pareto version
    loses the connection between a given value and the factor to
    which it belongs, so it is typical to do a DEX ... PLOT command
    before a DEX ... PARETO PLOT command.  The Pareto version can
    sometimes show more distinctly the difference in magnitude and
    the amount of variation in the calculated statistic.
 
Note:
    This plot is normally done for a location parameter (typically the
    mean or median) or a spread parameter (typically the standard
    deviation or range).  The other statistics are rarely used.
 
Note:
    The TO syntax is allowed for the list of factor variables (see the
    EXAMPLES above).
 
Note:
    The CHARACTER, BAR, SPIKE,  and LINE settings can be used to
    control the appearance of the plot.  Trace 1 contains the
    calculated value of the statistic and trace 2 contains the value
    of the statistic for all values of the response variable.
    Pareto charts are typically drawn as bars.  However, you can draw
    them as spikes, individual points, or a connected line if you
    prefer.  The program example below demonstrates drawing them as
    bars.  The various plot control commands for characters, lines,
    spikes, and bars can be used as usual.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LINES                          = Sets the type for plot lines.
    CHARACTER                      = Sets the type for plot characters
    PLOT                           = Generates a data or function plot.
    DEX SCATTER PLOT               = Generates a dex scatter plot.
    DEX SIGN PLOT                  = Generates a dex sign plot.
    DEX ... PLOT                   = Generates a dex plot for a
                                     statistic.
    DEX ... YOUDEN PLOT            = Generates a Youden dex plot for a
                                     statistic.
    DEX ... EFFECTS PLOT           = Generates a dex effects plot for a
                                     statistic.
    DEX ... PARETO EFFECTS PLOT    = Generates a Pareto effects dex
                                     plot for a statistic.
    DEX ... ABSOLUTE EFFECTS PLOT  = Generates an absolute effects dex
                                     plot for a statistic.
    DEX ... PARE ABSO EFFECTS PLOT = Generates a Pareto absolute
                                     effects dex plot for a statistic.
    DEX WIDTH                      = Specifies the width of levels in a
                                     dex plot.
 
Reference:
    "Statistics for Experimenters", Box, Hunter, and Hunter, John
    Wiley, 1978.
 
Applications:
    Design of Experiments
 
Implementation Date:
    1989/12
    2002/8: List of supported statistics expanded.
 
Program:
    SERIAL READ Y
     28.4 21.9 36.8 19.2 28.2 26.6 30.4 25.1 25.5 21.5 26.0 21.9 20.2
     14.3 19.9 22.5 23.4 18.5 38.2 12.8 22.0 22.5 30.3 17.7
    END OF DATA
    LET N= SIZE Y
    LET PROC = PATTERN 1 2 FOR I = 1 1 N
    LET PLANT = SEQUENCE 1 12 1 2
    LET SPEED = PATTERN 1 1 1 1 1 1 2 2 2 2 2 2 FOR I = 1 1 N
    LET SHIFT = SEQUENCE 1 2 1 3 FOR I = 1 1 N
    .
    BAR ON
    BAR WIDTH 0.5
    LINES BLANK SOLID
    TITLE DEX PARETO PLOT
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    Y1LABEL MEAN
    LET A = MEAN Y
    BAR BASE A
    DEX MEAN PARETO PLOT Y PROC PLANT SPEED SHIFT
    Y1LABEL MEDIAN
    LET A = MEDIAN Y
    BAR BASE A
    DEX MEDIAN PARETO PLOT Y PROC PLANT SPEED SHIFT
    Y1LABEL STANDARD DEVIATION
    LET A = STANDARD DEVIATION Y
    BAR BASE A
    DEX SD PARETO PLOT Y PROC PLANT SPEED SHIFT
    Y1LABEL RANGE
    LET A = RANGE Y
    BAR BASE A
    DEX RANGE PARETO PLOT Y PROC PLANT SPEED SHIFT
    END OF MULTIPLOT
 
--------DEX PHD----------------------------------------------
 
DEX PHD
 
Purpose:
    Carry out a pHd (principal Hessian direction) analysis to
    generate the ordered pHd vectors (eigenvectors of the
    matrix of 2-term interactions) for 2-level full or
    fractional factorial (i.e., Yates) designs.
 
Description:
    This command starts by performing the standard Yates analysis (see
    the documentation for the YATES command for details).  The Yates
    analysis yields factor estimates for all of the coefficients (main
    effects and all relevant interactions) in 2-level full and
    factorial experiments.  The name "Yates analysis" comes from the
    pioneering work which Yates carried out in the analysis of these
    designs.  Although the Yates algorithm (see page 342 of the Box,
    Hunter, and Hunter listed in the Reference section below), a manual
    iterative procedure for generating estimated factor effects, is a
    bit dated, we carry on the name in the form of the command.
  
    The data in the input variable Y is assumed to have been collected
    in Yates order.  The primary output from the DEX pHd analysis is a
    list which consists of 5 columns:

      1) A factor identifier (all from Yates order):
            1   = factor 1
            2   = factor 2
            3   = factor 3
            12  = factor 1 x factor 2 interaction
            13  = factor 1 x factor 3 interaction
            23  = factor 2 x factor 3 interaction
            123 = factor 1 x factor 2 x factor 3 interaction
            etc.
 
      2) Least squares estimated factor effects ordered from largest
         in magnitude (most significant) to smallest in magnitude
         (least significant).
 
      3) A t value (= e / sd(e)) where
            e is the estimated factor effect;
            sd(e) is the estimated standard deviation of e.
         Adjacent to this t value is an indication (* or **) as to
         whether the estimated effects are statistically significant
         at the 5% level (*) or 1% (**) level.
 
      4) The residual standard deviation that results from the model:
            response = constant + 1/2 (that single factor only)
         This is of interest but not that important.
 
      5) the (cumulative) residual standard deviation that results from
         the model:
            response = constant + 1/2 (all factors down to and
                       including the factor of interest).
 
         This column will consist of a monotonically decreasing set of
         residual standard deviations (indicating a better and better
         fit as the number of terms included in the model increases).
  
    The DEX PHD analysis generates 3 outputs:
       1) the matrix of estimated 2-term interactions;
       2) the ordered (by magnitude) eigenvalues of the matrix;
       3) the corresponding eigenvectors of the matrix (these
          eigenvectors are the pHd's of the system).
 
    These 3 outputs are listed on the screen.  These 3 outputs are
    also written out to the following 3 ASCII files, respectively,
    which are automatically created by this command:
       1) DPST1F.DAT
       2) DPST2F.DAT
       3) DPST3F.DAT
  
    The contents of these files may be viewed via the LIST command:
       LIST DPST1F.DAT
       LIST DPST2F.DAT
       LIST DPST3F.DAT
    or may be read back in via the SKIP and READ commands:
       SKIP 5; READ DPST1F.DAT V1 V2 V3 etc.
       SKIP 5; READ DPST1F.DAT EIGVAL
       SKIP 5; READ DPST3F.DAT PHD1 PHD2 PHD3 etc.
    (usually only the first 2 pHd's are read back in)
  
    The DEX PHD technique is useful for Linear Domain Splitting (LDS).
    LDS is the partitioning of a 2-level design with a complicated
    2-term interaction structure into sub-regions which have simpler
    2-term interaction structures.  The pHd's indicate as to which of
    the variables (in full factorial designs) should be used as a
    splitting factor (see the Filliben and Li article listed in the
    Reference section below for details).
  
    A typical follow-up graphical analysis to determine the proper
    splitting factor is to use the pHd's in the ASCII file DPST3F.DAT
    is as follows:
          SKIP 5; READ DPST3F.DAT PHD1 PHD2
          CHARACTERS - + BLANK; LINES BLANK BLANK SOLID
          PLOT PHD1 PHD2 X1 AND
          PLOT PHD1 PHD2 X2 AND
          PLOT PHD1 PHD2 X3
  
    The first file (DPST1F.DAT) containing the 2-terms effects matrix
    and the second file (DPST2F.DAT) containing the eigenvalues are of
    interest but are less frequently used.

Syntax 1:
    DEX PHD <y1>  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a response variable in standard Yates form;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax is used for the no replication case.

Syntax 2:
    YATES   <y1>  <group>   <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a response variable in standard Yates form;
          <group> is a variable that identifies the replication;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax is used for the replication case.
 
Examples:
    DEX PHD Y
    DEX PHD Y GROUP

Note 1: 
    This code assumes the data is in the standard Yates/Hunter/Box
    order.  For example, for a 2**3 design:
           - - -
           + - -
           - + -
           + + -
           - - +
           + - +
           - + +
           + + +
    More specifically, the kth column consists of 2**(k-1) minus signs
    followed by 2**(k-1) plus signs.

Note 2:
    Since the DEX PHD command has only one argument, the command itself
    does not know whether it is analyzing a full factorial design or
    some fractional factorial design with the same number of runs.  In
    such case, the analyst must make use of the confounding structure
    of 2-level factorial designs to translate the factor tag to its
    various aliases.  The simplest case of this is when the response
    variable has n = 4 observations.  In such case, the DEX PHD command
    would output factor tags on the "assumption" that it is analyzing
    a 2**2 full factorial design.  Such tags would thus be 1, 2, and
    12.  If the design was in fact a 2**(3-1) design, then the analyst
    must augment the 1, 2, and 12 tags by their correspoding aliases--
    in particular for a 2**(3-1):
        1  == 23
        2  == 13
        12 == 3
    For on-line information about confounding structure, the analyst
    is referred (in this case) to the header lines of the ASCII file
    2TO3M1.DAT via:
        LIST 2TO3M1.DAT
    and similar such design files.  To get a list of all such design
    files, enter:
        LIST DESIGNS.

Note 3:
    If there is replication, then the replicates can either be
    immediately within or they can be in the blocks after.

Note 4:
    The predicted values and residual values are stored in the 
    internal variables PRED and RES respectively.  These can be used
    in subsequent plot commands to aid diagnostic checking.

Note 5:
    The YATES <COEF/T/RESSD> CUTOFF and the YATES OUTPUT commands are
    used to control what output is printed by the Yates analysis
    portion of the DEX PHD command.  See the documentation for the
    YATES CUTOFF and YATES OUTPUT commands for more details.

Note 6:
    The pHd method has broader application than Yates designs.
    However, the current DATAPLOT implementation is restricted to
    this Special case.

Synonyms:
    DEX PHD FIT, DEX PHD ANALYSIS, PHD DEX, PHD DEX FIT, and PHD DEX
    ANALYSIS are synonyms for DEX PHD.
 
Related commands:
    YATES                          = Carries out a Yates analysis.
    FIT                            = Carries out a least squares fit.
    PLOT                           = Generates a data or function plot.
    DEX SCATTER PLOT               = Generates a dex scatter plot.
    DEX SIGN PLOT                  = Generates a dex sign plot.
    DEX ... PLOT                   = Generates a dex plot for a
                                     statistic.
    DEX ... PARETO PLOT            = Generates a Pareto dex plot for a
                                     statistic.
    DEX ... YOUDEN PLOT            = Generates a Youden dex plot for a
                                     statistic.
    DEX ... EFFECTS PLOT           = Generates a dex effects plot for a
                                     statistic.
    DEX ... PARETO EFFECTS PLOT    = Generates a Pareto effects dex
                                     plot for a statistic.
    DEX ... ABSOLUTE EFFECTS PLOT  = Generates an absolute effects dex
                                     plot for a statistic.
    DEX ... PARE ABSO EFFECTS PLOT = Generates a Pareto absolute
                                     effects dex plot for a statistic.

Reference:
    "Statistics For Experimenters", Box, Hunter, and Hunter, Wiley
    and Sons, 1978.
 
    "pHd-Guided Linear Domain Splitting for 2-Level Factorial
    Designs", James J. Filliben and Ker-Chau Li, to appear in
    Technometrics 1995.

Implementation Date:
    93/10 (output to files DPST1F.DAT, DPST2F.DAT, and DPST3F.DAT
          activated 95/2)

Program 1:
    . THIS IS AN EXAMPLE OF A DEX PHD ANALYSIS
    . OF A 2**3 FULL FACTORIAL DESIGN.
    SKIP 25; READ NUT.DAT Y X1 X2 X3
    DEX PHD Y
    SKIP 5; READ DPST3F.DAT PHD1 PHD2
    FIT Y X1 X2 X3;. (to compute residuals)
    CHARACTERS - +; LINES BLANK BLANK
    MULTIPLOT 2 3; X3LABEL AUTOMATIC
    PLOT RES PHD1 X1
    PLOT RES PHD1 X2
    PLOT RES PHD1 X3
    PLOT PHD1 PHD2 X1
    PLOT PHD1 PHD2 X2
    PLOT PHD1 PHD2 X3
 
Program 2:
   . THIS IS AN EXAMPLE OF A DEX PHD ANALYSIS
   . OF A 2**5 FULL FACTORIAL DESIGN.
   SKIP 25; READ BOXREAC2.DAT Y X1 X2 X3 X4 X5
   DEX PHD Y
   SKIP 5; READ DPST3F.DAT PHD1 PHD2
   FIT Y X1 X2 X3 X4 X5; ;. (to compute residuals)
   CHARACTERS - +; LINES BLANK BLANK
   MULTIPLOT 2 5; X3LABEL AUTOMATIC
   PLOT RES PHD1 X1
   PLOT RES PHD1 X2
   PLOT RES PHD1 X3
   PLOT RES PHD1 X4
   PLOT RES PHD1 X5
   PLOT PHD1 PHD2 X1
   PLOT PHD1 PHD2 X2
   PLOT PHD1 PHD2 X3
   PLOT PHD1 PHD2 X4
   PLOT PHD1 PHD2 X5
 
-----DEX ... YOUDEN PLOT---------------------------------------------
 
DEX YOUDEN PLOT
 
Name:
    DEX <statistic> YOUDEN PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a dex Youden plot for a given statistic.
 
Description:
    A dex Youden plot is a graphical method for representing a design
    of experiment problem.  The first variable is a response variable
    while the remaining variables (must be at least one) represent
    levels of factors.  For the Youden plot, all factors must have
    exactly 2 levels.  The Youden plot calculates the given statistic
    for each level of each factor.  The plot then consists of:
       Vertical   axis = value of the computed statistic for the lower
                         level in the factor;
       Horizontal axis = value of the computed statistic for the higher
                         level in the factor.
    This plot graphically shows if the value of the computed statistic
    is dependent on the level of the factor and additionally if it is
    dependent on the factor.
 
Syntax:
    DEX <stat> YOUDEN PLOT <y1> <x1 ... xn>
              <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the response variable;
          <x1 ... xn> are a sequence of variables representing factors
               in a designed experiment;
          <stat> is one of the following statistics:
              MEAN, MIDMEAN, MEDIAN, TRIMMED MEAN, WINSORIZED MEAN,
              GEOMETRIC MEAN, HARMONIC MEAN, HODGES LEHMAN,
              BIWEIGHT LOCATION,
              SUM, PRODUCT, SIZE (or NUMBER or SIZE),
              STANDARD DEVIATION, STANDARD DEVIATION OF MEAN,
              VARIANCE, VARIANCE OF THE MEAN,
              TRIMMED MEAN STANDARD ERROR,
              AVERAGE ABSOLUTE DEVIATION (or AAD),
              MEDIAN ABSOLUTE DEVIATION (or MAD),
              IQ RANGE, BIWEIGHT MIDVARIANCE, BIWEIGHT SCALE,
              PERCENTAGE BEND MIDVARIANCE,
              WINSORIZED VARIANCE, WINSORIZED STANDARD DEVIATION,
              RELATIVE STANDARD DEVIATION, RELATIVE VARIANCE (or
                 COEFFICIENT OF VARIATION),
              RANGE, MIDRANGE, MAXIMUM, MINIMUM, EXTREME,
              LOWER HINGE, UPPER HINGE, LOWER QUARTILE, UPPER QUARTILE,
              <FIRST/SECOND/THIRD/FOURTH/FIFTH/SIXTH/SEVENTH/EIGHTH/
                  NINTH/TENTH> DECILE,
              PERCENTILE, QUANTILE, QUANTILE STANDARD ERROR,
              SKEWNESS, KURTOSIS, NORMAL PPCC,
              AUTOCORRELATION, AUTOCOVARIANCE,
              SINE FREQUENCY, SINE AMPLITUDE,
              CP, CPK, CNPK, CPM, CC,
              EXPECTED LOSS, PERCENT DEFECTIVE,
              TAGUCHI SN0 (or SN), TAGUCHI SN+ (or SNL),
              TAGUCHI SN- (or SNS), TAGUCHI SN00 (or SN2);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    DEX MEAN YOUDEN PLOT Y X1 X2
    DEX SD YOUDEN PLOT Y X1 X2 X3
    DEX RANGE YOUDEN PLOT Y X1 X2 X3 X4
    DEX RANGE YOUDEN PLOT Y X1 TO X4
 
Note:
    This plot is normally done for a location parameter (typically the
    mean or median) or a spread parameter (typically the standard
    deviation or range).  The other statistics are rarely used.
 
Note:
    The TO syntax is allowed for the list of factor variables (see the
    EXAMPLES above).
 
Note:
    The following program example shows how to put the factor
    labels on the X axis.
 
Note:
    The CHARACTER,BAR, SPIKE, and LINE settings can be used to control
    the appearance of the plot.  The first trace is typically drawn
    with a blank line and some type of character set (the choice of
    character is a matter of user preference).  The second trace draws
    a diagonal line on the plot.  This is typically drawn with a blank
    character and a solid line (some analysts may prefer a dashed or
    dotted line).  In any event, the user must explicitly set character
    and line settings (they default to all lines solid and all
    characters blank).
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LINES                          = Sets the type for plot lines.
    CHARACTER                      = Sets the type for plot characters
    PLOT                           = Generates a data or function plot.
    DEX SCATTER PLOT               = Generates a dex scatter plot.
    DEX SIGN PLOT                  = Generates a dex sign plot.
    DEX ... PLOT                   = Generates a dex plot for a
                                     statistic.
    DEX ... PARETO PLOT            = Generates a Pareto dex plot for a
                                     statistic.
    DEX ... EFFECTS PLOT           = Generates a dex effects plot for a
                                     statistic.
    DEX ... PARETO EFFECTS PLOT    = Generates a Pareto effects dex
                                     plot for a statistic.
    DEX ... ABSOLUTE EFFECTS PLOT  = Generates an absolute effects dex
                                     plot for a statistic.
    DEX ... PARE ABSO EFFECTS PLOT = Generates a Pareto absolute
                                     effects dex plot for a statistic.
    DEX WIDTH                      = Specifies the width of levels in a
                                     dex plot.
 
Reference:
    "Statistics for Experimenters", Box, Hunter, and Hunter, John
    Wiley, 1978.
 
Applications:
    Design of Experiments
 
Implementation Date:
    1989/12
    2002/8: List of supported statistics expanded.
 
Program:
    . CAT/TEMP/PRES/CONC EFFECT ON CHEMICAL PROCESS CONVERSION YIELD
    . BOX, HUNTER & HUNTER (1978), STATISTICS FOR EXPERIMENTERS,
    . WILEY, P 325
    . 2**4 FULL FACTORIAL DESIGN, NUMBER OF OBSERVATIONS = 16
    .    RESPONSE VARIABLE = % CONVERSION
    .    FACTOR 1 = CATALYST CHARGE (2 LEVELS--10 & 15 POUNDS)
    .    FACTOR 2 = TEMPERATURE     (2 LEVELS--220 & 240 DEG C)
    .    FACTOR 3 = PRESSURE        (2 LEVELS--50 & 80 PSI)
    .    FACTOR 4 = CONCENTRATION   (2 LEVELS--10 & 12 %)
    LET Y = DATA 71 61 90 82 68 61 87 80 61 50 89 83 59 51 85 78
    LET X1 = DATA -1 +1 -1 +1 -1 +1 -1 +1 -1 +1 -1 +1 -1 +1 -1 +1
    LET X2 = DATA -1 -1 +1 +1 -1 -1 +1 +1 -1 -1 +1 +1 -1 -1 +1 +1
    LET X3 = DATA -1 -1 -1 -1 +1 +1 +1 +1 -1 -1 -1 -1 +1 +1 +1 +1
    LET X4 = DATA -1 -1 -1 -1 -1 -1 -1 -1 +1 +1 +1 +1 +1 +1 +1 +1
    .
    CHARACTERS 1 2 3 4
    LINE BLANK BLANK BLANK BLANK DOTTED
    X1LABEL HIGH LEVEL
    Y1LABEL LOW LEVEL
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE MEAN
    YTIC OFFSET 5 0
    DEX MEAN YOUDEN PLOT Y X1 TO X4
    TITLE MEDIAN
    YTIC OFFSET 5 0
    DEX MEDIAN YOUDEN PLOT Y X1 TO X4
    TITLE STANDARD DEVIATION
    YTIC OFFSET 0 0
    DEX SD YOUDEN PLOT Y X1 TO X4
    TITLE RANGE
    YTIC OFFSET 0 5
    DEX RANGE YOUDEN PLOT Y X1 TO X4
    END OF MULTIPLOT
 
-----DEX ... EFFECTS PLOT---------------------------------------------
 
DEX EFFECTS PLOT
 
Name:
    DEX <statistic> EFFECTS PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a dex effects plot for a given statistic.
 
Description:
    A dex effects plot is a graphical method for representing a design
    of experiment problem.  The first variable is a response variable
    while the remaining variables (must be at least one) represent
    levels of factors.  The effects plot consists of:
       Vertical   axis = if there are exactly 2 levels, the effect is
                         the value of the statistic for the lower
                         level subtracted from the value of the
                         statistic for the higher level (this can be
                         positive or negative).  If there are more than
                         2 levels, the lowest value of the statistic
                         is subtracted from the highest value of the
                         statistic (this value is always positive);
       Horizontal axis = the factor id (i.e., 1 for factor 1, 2 for
                         factor 2 and so on).
    This plot graphically shows the following:
       1) The magnitude of the maximum differences for a given
          statistic between levels of a factor;
       2) How these maximum differences vary between factors.
 
Syntax:
    DEX <stat> EFFECT PLOT <y1> <x1 ... xn>
              <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the response variable;
          <x1 ... xn> are a sequence of variables representing factors
               in a designed experiment;
          <stat> is one of the following statistics:
              MEAN, MIDMEAN, MEDIAN, TRIMMED MEAN, WINSORIZED MEAN,
              GEOMETRIC MEAN, HARMONIC MEAN, HODGES LEHMAN,
              BIWEIGHT LOCATION,
              SUM, PRODUCT, SIZE (or NUMBER or SIZE),
              STANDARD DEVIATION, STANDARD DEVIATION OF MEAN,
              VARIANCE, VARIANCE OF THE MEAN,
              TRIMMED MEAN STANDARD ERROR,
              AVERAGE ABSOLUTE DEVIATION (or AAD),
              MEDIAN ABSOLUTE DEVIATION (or MAD),
              IQ RANGE, BIWEIGHT MIDVARIANCE, BIWEIGHT SCALE,
              PERCENTAGE BEND MIDVARIANCE,
              WINSORIZED VARIANCE, WINSORIZED STANDARD DEVIATION,
              RELATIVE STANDARD DEVIATION, RELATIVE VARIANCE (or
                 COEFFICIENT OF VARIATION),
              RANGE, MIDRANGE, MAXIMUM, MINIMUM, EXTREME,
              LOWER HINGE, UPPER HINGE, LOWER QUARTILE, UPPER QUARTILE,
              <FIRST/SECOND/THIRD/FOURTH/FIFTH/SIXTH/SEVENTH/EIGHTH/
                  NINTH/TENTH> DECILE,
              PERCENTILE, QUANTILE, QUANTILE STANDARD ERROR,
              SKEWNESS, KURTOSIS, NORMAL PPCC,
              AUTOCORRELATION, AUTOCOVARIANCE,
              SINE FREQUENCY, SINE AMPLITUDE,
              CP, CPK, CNPK, CPM, CC,
              EXPECTED LOSS, PERCENT DEFECTIVE,
              TAGUCHI SN0 (or SN), TAGUCHI SN+ (or SNL),
              TAGUCHI SN- (or SNS), TAGUCHI SN00 (or SN2);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    DEX MEAN EFFECTS PLOT Y X1 X2
    DEX SD EFFECTS PLOT Y X1 X2 X3
    DEX RANGE EFFECTS PLOT Y X1 X2 X3 X4
    DEX RANGE EFFECTS PLOT Y X1 TO X4
 
Note:
    This plot is normally done for a location parameter (typically the
    mean or median) or a spread parameter (typically the standard
    deviation or range).  The other statistics are rarely used.
 
Note:
    The TO syntax is allowed for the list of factor variables (see the
    EXAMPLES above).
 
Note:
    The CHARACTER,BAR, SPIKE, and LINE settings can be used to control
    the appearance of the plot.  The trace is typically drawn with a
    blank line and some type of character set (the choice of character
    is a matter of user preference).  However, you can draw the trace
    as a bar, a connected line, or a spike if you prefer. In any event,
    the user must explicitly set character and line settings (they
    default to all lines solid and all characters blank).
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LINES                          = Sets the type for plot lines.
    CHARACTER                      = Sets the type for plot characters
    PLOT                           = Generates a data or function plot.
    DEX SCATTER PLOT               = Generates a dex scatter plot.
    DEX SIGN PLOT                  = Generates a dex sign plot.
    DEX ... PLOT                   = Generates a dex plot for a
                                     statistic.
    DEX ... PARETO PLOT            = Generates a Pareto dex plot for a
                                     statistic.
    DEX ... YOUDEN PLOT            = Generates a Youden dex plot for a
                                     statistic.
    DEX ... PARETO EFFECTS PLOT    = Generates a Pareto effects dex
                                     plot for a statistic.
    DEX ... ABSOLUTE EFFECTS PLOT  = Generates an absolute effects dex
                                     plot for a statistic.
    DEX ... PARE ABSO EFFECTS PLOT = Generates a Pareto absolute
                                     effects dex plot for a statistic.
    DEX WIDTH                      = Specifies the width of levels in a
                                     dex plot.
 
Reference:
    "Statistics for Experimenters", Box, Hunter, and Hunter, John
    Wiley, 1978.
 
Applications:
    Design of Experiments
 
Implementation Date:
    1989/12
    2002/8: List of supported statistics expanded.
 
Program:
    SERIAL READ Y
     28.4 21.9 36.8 19.2 28.2 26.6 30.4 25.1 25.5 21.5 26.0 21.9 20.2
     14.3 19.9 22.5 23.4 18.5 38.2 12.8 22.0 22.5 30.3 17.7
    END OF DATA
    LET N= SIZE Y
    LET PROC = PATTERN 1 2 FOR I = 1 1 N
    LET PLANT = SEQUENCE 1 12 1 2
    LET SPEED = PATTERN 1 1 1 1 1 1 2 2 2 2 2 2 FOR I = 1 1 N
    LET SHIFT = SEQUENCE 1 2 1 3 FOR I = 1 1 N
    .
    CHARACTERS X ALL
    LINES BLANK ALL
    LET NFACT = 4
    XLIMITS 1 NFACT
    MAJOR XTIC MARK NUMBER NFACT
    MINOR XTIC MARK NUMBER 0
    XTIC OFFSET 1 1
    XTIC LABEL FORMAT ALPHA
    XTIC LABEL CONTENT PROCESS PLANT SPEED SHIFT
    X1LABEL FACTORS
    TITLE DEX EFFECTS PLOT
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    Y1LABEL MEAN
    DEX MEAN EFFECTS PLOT Y PROC PLANT SPEED SHIFT
    Y1LABEL MEDIAN
    DEX MEDIAN EFFECTS PLOT Y PROC PLANT SPEED SHIFT
    Y1LABEL STANDARD DEVIATION
    DEX SD EFFECTS PLOT Y PROC PLANT SPEED SHIFT
    TITLE RANGE
    DEX RANGE EFFECTS PLOT Y PROC PLANT SPEED SHIFT
    END OF MULTIPLOT
 
-----DEX ... PARETO EFFECTS PLOT----------------------------------
 
DEX PARETO EFFECTS PLOT
 
Name:
    DEX <statistic> PARETO EFFECTS PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a dex Pareto effects plot for a given statistic.
 
Description:
    A dex Pareto effects plot is a graphical method for representing
    a design of experiment problem.  The first variable is a response
    variable while the remaining variables (must be at least one)
    represent levels of factors.  This plot consists of:
       Vertical   axis = if there are exactly 2 levels, the effect is
                         the value of the statistic for the lower
                         level subtracted from the value of the
                         statistic for the higher level (this can be
                         positive or negative).  If there are more
                         than 2 levels, the lowest value of the
                         statistic is subtracted from the highest value
                         of the statistic (this value is always
                         positive).  The values are then sorted from
                         highest to lowest.
       Horizontal axis = the factor id (i.e., 1 for the factor with the
                         highest value, 2 for the factor with the
                         second highest value, and so on).
    This plot graphically shows the following:
       1) The magnitude of the maximum differences for a given
          statistic between levels of a factor;
       2) How these maximum differences vary between factors.
 
Syntax:
    DEX <stat> PARETO EFFECTS PLOT <y1> <x1 ... xn>
              <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the response variable;
          <x1 ... xn> are a sequence of variables representing factors
               in a designed experiment;
          <stat> is one of the following statistics:
              MEAN, MIDMEAN, MEDIAN, TRIMMED MEAN, WINSORIZED MEAN,
              GEOMETRIC MEAN, HARMONIC MEAN, HODGES LEHMAN,
              BIWEIGHT LOCATION,
              SUM, PRODUCT, SIZE (or NUMBER or SIZE),
              STANDARD DEVIATION, STANDARD DEVIATION OF MEAN,
              VARIANCE, VARIANCE OF THE MEAN,
              TRIMMED MEAN STANDARD ERROR,
              AVERAGE ABSOLUTE DEVIATION (or AAD),
              MEDIAN ABSOLUTE DEVIATION (or MAD),
              IQ RANGE, BIWEIGHT MIDVARIANCE, BIWEIGHT SCALE,
              PERCENTAGE BEND MIDVARIANCE,
              WINSORIZED VARIANCE, WINSORIZED STANDARD DEVIATION,
              RELATIVE STANDARD DEVIATION, RELATIVE VARIANCE (or
                 COEFFICIENT OF VARIATION),
              RANGE, MIDRANGE, MAXIMUM, MINIMUM, EXTREME,
              LOWER HINGE, UPPER HINGE, LOWER QUARTILE, UPPER QUARTILE,
              <FIRST/SECOND/THIRD/FOURTH/FIFTH/SIXTH/SEVENTH/EIGHTH/
                  NINTH/TENTH> DECILE,
              PERCENTILE, QUANTILE, QUANTILE STANDARD ERROR,
              SKEWNESS, KURTOSIS, NORMAL PPCC,
              AUTOCORRELATION, AUTOCOVARIANCE,
              SINE FREQUENCY, SINE AMPLITUDE,
              CP, CPK, CNPK, CPM, CC,
              EXPECTED LOSS, PERCENT DEFECTIVE,
              TAGUCHI SN0 (or SN), TAGUCHI SN+ (or SNL),
              TAGUCHI SN- (or SNS), TAGUCHI SN00 (or SN2);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    DEX MEAN PARETO EFFECTS PLOT Y X1 X2
    DEX SD PARETO EFFECTS PLOT Y X1 X2 X3
    DEX RANGE PARETO EFFECTS PLOT Y X1 X2 X3 X4
    DEX RANGE PARETO EFFECTS PLOT Y X1 TO X4
 
Note:
    This plot is similar to the DEX ... EFFECTS PLOT.  The distinction
    is that the Pareto effects plot orders the effects from high to
    low while the standard effects plot orders them in the order they
    are given in the plot.  The advantage to the standard plot is that
    you can trace a value to a specific factor while the Pareto plot
    loses this.  However, the ordering of the Pareto plot can make it
    easier to read.  It is common to generate a standard effects plot
    and then generate the Pareto version.  For presentation purposes,
    the TIC LABEL CONTENT can be used to label the factors on the
    Pareto version (the proper order is manually determined from the
    standard effects plot).  This was done for the example program
    below.
 
Note:
    This plot is normally done for a location parameter (typically the
    mean or median) or a spread parameter (typically the standard
    deviation or range).  The other statistics are rarely used.
 
Note:
    The TO syntax is allowed for the list of factor variables (see the
    EXAMPLES above).
 
Note:
    The CHARACTER, BAR, SPIKE, and LINE settings can be used to control
    the appearance of the plot.  The trace is typically drawn with a
    blank line and some type of character set (the choice of character
    is a matter of user preference) or with no character and a bar.  In
    any event, the user must explicitly set character and line settings
    (they default to all lines solid and all characters blank).
 
Default:
    None
 
Synonyms:
    DEX ... EFFECTS PARETO PLOT
 
Related Commands:
    LINES                          = Sets the type for plot lines.
    CHARACTER                      = Sets the type for plot characters
    PLOT                           = Generates a data or function plot.
    DEX SCATTER PLOT               = Generates a dex scatter plot.
    DEX SIGN PLOT                  = Generates a dex sign plot.
    DEX ... PLOT                   = Generates a dex plot for a
                                     statistic.
    DEX ... PARETO PLOT            = Generates a Pareto dex plot for a
                                     statistic.
    DEX ... YOUDEN PLOT            = Generates a Youden dex plot for a
                                     statistic.
    DEX ... EFFECTS PLOT           = Generates an effects dex plot for
                                     a statistic.
    DEX ... PARE ABSO EFFECTS PLOT = Generates a Pareto absolute
                                     effects dex plot for a statistic.
    DEX WIDTH                      = Specifies the width of levels in a
                                     dex plot.
 
Reference:
    "Statistics for Experimenters", Box, Hunter, and Hunter, John
    Wiley, 1978.
 
Applications:
    Design of Experiments
 
Implementation Date:
    1989/12
    2002/8: List of supported statistics expanded.
 
Program:
    SERIAL READ Y
     28.4 21.9 36.8 19.2 28.2 26.6 30.4 25.1 25.5 21.5 26.0 21.9 20.2
     14.3 19.9 22.5 23.4 18.5 38.2 12.8 22.0 22.5 30.3 17.7
    END OF DATA
    LET N= SIZE Y
    LET PROC = PATTERN 1 2 FOR I = 1 1 N
    LET PLANT = SEQUENCE 1 12 1 2
    LET SPEED = PATTERN 1 1 1 1 1 1 2 2 2 2 2 2 FOR I = 1 1 N
    LET SHIFT = SEQUENCE 1 2 1 3 FOR I = 1 1 N
    .
    BAR ON
    BAR WIDTH 0.5
    LINE BLANK
    TITLE DEX PARETO EFFECTS PLOT
    LET NUMFAC = 4
    XLIMITS 1 NUMFAC
    MAJOR XTIC MARK NUMBER NUMFAC
    MINOR XTIC MARK NUMBER 0
    XTIC OFFSET 1 1
    XTIC LABEL FORMAT ALPHA
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    Y1LABEL MEAN
    XTIC LABEL CONTENT SHIFT SPEED PLANT PROCESS
    DEX MEAN PARETO EFFECTS PLOT Y PROC PLANT SPEED SHIFT
    Y1LABEL MEDIAN
    XTIC LABEL CONTENT SHIFT SPEED PLANT PROCESS
    DEX MEDIAN PARETO EFFECTS PLOT Y PROC PLANT SPEED SHIFT
    Y1LABEL STANDARD DEVIATION
    XTIC LABEL CONTENT SHIFT PLANT SPEED PROCESS
    DEX SD PARETO EFFECTS PLOT Y PROC PLANT SPEED SHIFT
    Y1LABEL RANGE
    XTIC LABEL CONTENT SHIFT PLANT SPEED PROCESS
    DEX RANGE PARETO EFFECTS PLOT Y PROC PLANT SPEED SHIFT
    END OF MULTIPLOT
 
-----DEX ... ABSOLUTE EFFECTS PLOT----------------------------------
 
DEX ABSOLUTE EFFECTS PLOT
 
Name:
    DEX <statistic> ABSOLUTE EFFECTS PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a dex absolute effects plot for a given statistic.
 
Description:
    A dex absolute effects plot is a graphical method for representing
    a design of experiment problem.  The first variable is a response
    variable while the remaining variables (must be at least one)
    represent levels of factors.  This plot consists of:
       Vertical   axis = if there are exactly 2 levels, the effect is
                         the value of the statistic for the lower
                         level subtracted from the value of the
                         statistic for the higher level (and then the
                         absolute value is taken).  If there are more
                         than 2 levels, the lowest value of the
                         statistic is subtracted from the highest value
                         of the statistic (this value is always
                         positive);
       Horizontal axis = the factor id (i.e., 1 for factor 1, 2 for
                         factor 2 and so on).
    This plot graphically shows the following:
       1) The magnitude of the maximum differences for a given
          statistic between levels of a factor;
       2) How these maximum differences vary between factors.
 
Syntax:
    DEX <stat> ABSOLUTE EFFECTS PLOT <y1> <x1 ... xn>
              <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the response variable;
          <x1 ... xn> are a sequence of variables representing factors
               in a designed experiment;
          <stat> is one of the following statistics:
              MEAN, MIDMEAN, MEDIAN, TRIMMED MEAN, WINSORIZED MEAN,
              GEOMETRIC MEAN, HARMONIC MEAN, HODGES LEHMAN,
              BIWEIGHT LOCATION,
              SUM, PRODUCT, SIZE (or NUMBER or SIZE),
              STANDARD DEVIATION, STANDARD DEVIATION OF MEAN,
              VARIANCE, VARIANCE OF THE MEAN,
              TRIMMED MEAN STANDARD ERROR,
              AVERAGE ABSOLUTE DEVIATION (or AAD),
              MEDIAN ABSOLUTE DEVIATION (or MAD),
              IQ RANGE, BIWEIGHT MIDVARIANCE, BIWEIGHT SCALE,
              PERCENTAGE BEND MIDVARIANCE,
              WINSORIZED VARIANCE, WINSORIZED STANDARD DEVIATION,
              RELATIVE STANDARD DEVIATION, RELATIVE VARIANCE (or
                 COEFFICIENT OF VARIATION),
              RANGE, MIDRANGE, MAXIMUM, MINIMUM, EXTREME,
              LOWER HINGE, UPPER HINGE, LOWER QUARTILE, UPPER QUARTILE,
              <FIRST/SECOND/THIRD/FOURTH/FIFTH/SIXTH/SEVENTH/EIGHTH/
                  NINTH/TENTH> DECILE,
              PERCENTILE, QUANTILE, QUANTILE STANDARD ERROR,
              SKEWNESS, KURTOSIS, NORMAL PPCC,
              AUTOCORRELATION, AUTOCOVARIANCE,
              SINE FREQUENCY, SINE AMPLITUDE,
              CP, CPK, CNPK, CPM, CC,
              EXPECTED LOSS, PERCENT DEFECTIVE,
              TAGUCHI SN0 (or SN), TAGUCHI SN+ (or SNL),
              TAGUCHI SN- (or SNS), TAGUCHI SN00 (or SN2);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    DEX MEAN ABSOLUTE EFFECTS PLOT Y X1 X2
    DEX SD ABSOLUTE EFFECTS PLOT Y X1 X2 X3
    DEX RANGE ABSOLUTE EFFECTS PLOT Y X1 X2 X3 X4
    DEX RANGE ABSOLUTE EFFECTS PLOT Y X1 TO X4
 
Note:
    This plot is similar to the DEX ... EFFECTS PLOT.  The distinction
    is that the absolute effects plot takes the absolute value of the
    low level minus the high level while the standard effects plot does
    not.  For the case with more than 2 levels, the two plots are
    identical.
 
Note:
    This plot is normally done for a location parameter (typically the
    mean or median) or a spread parameter (typically the standard
    deviation or range).  The other statistics are rarely used.
 
Note:
    The TO syntax is allowed for the list of factor variables (see the
    EXAMPLES above).
 
Note:
    The CHARACTER,BAR, SPIKE, and LINE settings can be used to control
    the appearance of the plot.  The trace is typically drawn with a
    blank line and some type of character set (the choice of character
    is a matter of user preference).  However, you can draw the trace
    as a bar, a connected line, or a spike if you prefer. In any event,
    the user must explicitly set character and line settings (they
    default to all lines solid and all characters blank).
 
Default:
    None
 
Synonyms:
    DEX ... EFFECTS ABSOLUTE PLOT
 
Related Commands:
    LINES                          = Sets the type for plot lines.
    CHARACTER                      = Sets the type for plot characters
    PLOT                           = Generates a data or function plot.
    DEX SCATTER PLOT               = Generates a dex scatter plot.
    DEX SIGN PLOT                  = Generates a dex sign plot.
    DEX ... PLOT                   = Generates a dex plot for a
                                     statistic.
    DEX ... PARETO PLOT            = Generates a Pareto dex plot for a
                                     statistic.
    DEX ... YOUDEN PLOT            = Generates a Youden dex plot for a
                                     statistic.
    DEX ... EFFECTS PLOT           = Generates an effects dex plot for
                                     a statistic.
    DEX ... PARETO EFFECTS PLOT    = Generates a Pareto effects dex
                                     plot for a statistic.
    DEX ... PARE ABSO EFFECTS PLOT = Generates a Pareto absolute
                                     effects dex plot for a statistic.
    DEX WIDTH                      = Specifies the width of levels in a
                                     dex plot.
 
Reference:
    "Statistics for Experimenters", Box, Hunter, and Hunter, John
    Wiley, 1978.
 
Applications:
    Design of Experiments
 
Implementation Date:
    1989/12
    2002/8: List of supported statistics expanded.
 
Program:
    SERIAL READ Y
     28.4 21.9 36.8 19.2 28.2 26.6 30.4 25.1 25.5 21.5 26.0 21.9 20.2
     14.3 19.9 22.5 23.4 18.5 38.2 12.8 22.0 22.5 30.3 17.7
    END OF DATA
    LET N= SIZE Y
    LET PROC = PATTERN 1 2 FOR I = 1 1 N
    LET PLANT = SEQUENCE 1 12 1 2
    LET SPEED = PATTERN 1 1 1 1 1 1 2 2 2 2 2 2 FOR I = 1 1 N
    LET SHIFT = SEQUENCE 1 2 1 3 FOR I = 1 1 N
    .
    CHARACTERS X ALL
    LINES BLANK ALL
    LET NFACT = 4
    XLIMITS 1 NFACT
    MAJOR XTIC MARK NUMBER NFACT
    MINOR XTIC MARK NUMBER 0
    XTIC OFFSET 1 1
    XTIC LABEL FORMAT ALPHA
    XTIC LABEL CONTENT PROCESS PLANT SPEED SHIFT
    X1LABEL FACTORS
    TITLE DEX ABSOLUTE EFFECTS PLOT
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    Y1LABEL MEAN
    DEX MEAN ABSOLUTE EFFECTS PLOT Y PROC PLANT SPEED SHIFT
    Y1LABEL MEDIAN
    DEX MEDIAN ABSOLUTE EFFECTS PLOT Y PROC PLANT SPEED SHIFT
    Y1LABEL STANDARD DEVIATION
    DEX SD ABSOLUTE EFFECTS PLOT Y PROC PLANT SPEED SHIFT
    Y1LABEL RANGE
    DEX RANGE ABSOLUTE EFFECTS PLOT Y PROC PLANT SPEED SHIFT
    END OF MULTIPLOT
 
-----DEX ... PARETO ABSOLUTE EFFECTS PLOT----------------------------
 
DEX PARETO ABSOLUTE EFFECTS PLOT
 
Name:
    DEX <statistic> PARETO ABSOLUTE EFFECTS PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a dex Pareto absolute effects plot for a given statistic.
 
Description:
    A dex Pareto absolute effects plot is a graphical method for
    representing a design of experiment problem.  The first variable is
    a response variable while the remaining variables (must be at least
    one) represent levels of factors.  This plot consists of:
       Vertical   axis = if there are exactly 2 levels, the effect is
                         the value of the statistic for the lower
                         level subtracted from the value of the
                         statistic for the higher level (this can be
                         positive or negative).  The absolute value of
                         this number is taken.  If there are more than
                         2 levels, the lowest value of the
                         statistic is subtracted from the highest value
                         of the statistic (this value is always
                         positive).  The values are then sorted from
                         highest to lowest.
       Horizontal axis = the factor id (i.e., 1 for the factor with the
                         highest value, 2 for the factor with the
                         second highest value, and so on).
    This plot graphically shows the following:
       1) The magnitude of the maximum differences for a given
          statistic between levels of a factor;
       2) How these maximum differences vary between factors.
 
Syntax:
    DEX <stat> PARETO ABSOLUTE EFFECTS PLOT <y1> <x1 ... xn>
              <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the response variable;
          <x1 ... xn> are a sequence of variables representing factors
               in a designed experiment;
          <stat> is one of the following statistics:
              MEAN, MIDMEAN, MEDIAN, TRIMMED MEAN, WINSORIZED MEAN,
              GEOMETRIC MEAN, HARMONIC MEAN, HODGES LEHMAN,
              BIWEIGHT LOCATION,
              SUM, PRODUCT, SIZE (or NUMBER or SIZE),
              STANDARD DEVIATION, STANDARD DEVIATION OF MEAN,
              VARIANCE, VARIANCE OF THE MEAN,
              TRIMMED MEAN STANDARD ERROR,
              AVERAGE ABSOLUTE DEVIATION (or AAD),
              MEDIAN ABSOLUTE DEVIATION (or MAD),
              IQ RANGE, BIWEIGHT MIDVARIANCE, BIWEIGHT SCALE,
              PERCENTAGE BEND MIDVARIANCE,
              WINSORIZED VARIANCE, WINSORIZED STANDARD DEVIATION,
              RELATIVE STANDARD DEVIATION, RELATIVE VARIANCE (or
                 COEFFICIENT OF VARIATION),
              RANGE, MIDRANGE, MAXIMUM, MINIMUM, EXTREME,
              LOWER HINGE, UPPER HINGE, LOWER QUARTILE, UPPER QUARTILE,
              <FIRST/SECOND/THIRD/FOURTH/FIFTH/SIXTH/SEVENTH/EIGHTH/
                  NINTH/TENTH> DECILE,
              PERCENTILE, QUANTILE, QUANTILE STANDARD ERROR,
              SKEWNESS, KURTOSIS, NORMAL PPCC,
              AUTOCORRELATION, AUTOCOVARIANCE,
              SINE FREQUENCY, SINE AMPLITUDE,
              CP, CPK, CNPK, CPM, CC,
              EXPECTED LOSS, PERCENT DEFECTIVE,
              TAGUCHI SN0 (or SN), TAGUCHI SN+ (or SNL),
              TAGUCHI SN- (or SNS), TAGUCHI SN00 (or SN2);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    DEX MEAN PARETO ABSOLUTE EFFECTS PLOT Y X1 X2
    DEX SD PARETO ABSOLUTE EFFECTS PLOT Y X1 X2 X3
    DEX RANGE PARETO ABSOLUTE EFFECTS PLOT Y X1 X2 X3 X4
    DEX RANGE PARETO ABSOLUTE EFFECTS PLOT Y X1 TO X4
 
Note:
    This plot is similar to the DEX ... PARETO EFFECTS PLOT.  The
    distinction is that the Pareto absolute effects plot takes the
    absolute value of the effect while the Pareto effects plot does
    not.  This only applies if there are exactly two levels (for more
    than two levels, the two plots are identical).
 
Note:
    This plot is normally done for a location parameter (typically the
    mean or median) or a spread parameter (typically the standard
    deviation or range).  The other statistics are rarely used.
 
Note:
    The TO syntax is allowed for the list of factor variables (see the
    EXAMPLES above).
 
Note:
    The CHARACTER, BAR, SPIKE, and LINE settings can be used to control
    the appearance of the plot.  The trace is typically drawn with a
    blank line and some type of character set (the choice of character
    is a matter of user preference) or with no character and a bar.  In
    any event, the user must explicitly set character and line settings
    (they default to all lines solid and all characters blank).
 
Default:
    None
 
Synonyms:
    DEX ... EFFECTS PARETO ABSOLUTE PLOT
    DEX ... EFFECTS ABSOLUTE PARETO PLOT
    DEX ... PARETO EFFECTS ABSOLUTE PLOT
    DEX ... ABSOLUTE PARETO EFFECTS PLOT
    DEX ... ABSOLUTE EFFECTS PARETO PLOT
 
Related Commands:
    LINES                          = Sets the type for plot lines.
    CHARACTER                      = Sets the type for plot characters
    PLOT                           = Generates a data or function plot.
    DEX SCATTER PLOT               = Generates a dex scatter plot.
    DEX SIGN PLOT                  = Generates a dex sign plot.
    DEX ... PLOT                   = Generates a dex plot for a
                                     statistic.
    DEX ... PARETO PLOT            = Generates a Pareto dex plot for a
                                     statistic.
    DEX ... YOUDEN PLOT            = Generates a Youden dex plot for a
                                     statistic.
    DEX ... EFFECTS PLOT           = Generates an effects dex plot for
                                     a statistic.
    DEX ... PARE EFFECTS PLOT      = Generates a Pareto effects dex
                                     plot for a statistic.
    DEX WIDTH                      = Specifies the width of levels in a
                                     dex plot.
 
Reference:
    "Statistics for Experimenters", Box, Hunter, and Hunter, John
    Wiley, 1978.
 
Applications:
    Design of Experiments
 
Implementation Date:
    1989/12
    2002/8: List of supported statistics supported.
 
Program:
    SERIAL READ Y
     28.4 21.9 36.8 19.2 28.2 26.6 30.4 25.1 25.5 21.5 26.0 21.9 20.2
     14.3 19.9 22.5 23.4 18.5 38.2 12.8 22.0 22.5 30.3 17.7
    END OF DATA
    LET N= SIZE Y
    LET PROC = PATTERN 1 2 FOR I = 1 1 N
    LET PLANT = SEQUENCE 1 12 1 2
    LET SPEED = PATTERN 1 1 1 1 1 1 2 2 2 2 2 2 FOR I = 1 1 N
    LET SHIFT = SEQUENCE 1 2 1 3 FOR I = 1 1 N
    .
    BAR ON
    BAR WIDTH 0.5
    LINE BLANK
    TITLE DEX PARETO ABSOLUTE EFFECTS PLOT
    LET NUMFAC = 4
    XLIMITS 1 NUMFAC
    MAJOR XTIC MARK NUMBER NUMFAC
    MINOR XTIC MARK NUMBER 0
    XTIC OFFSET 1 1
    XTIC LABEL FORMAT ALPHA
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    Y1LABEL MEAN
    XTIC LABEL CONTENT SHIFT SPEED PLANT PROCESS
    DEX MEAN PARETO ABSOLUTE EFFECTS PLOT Y PROC PLANT SPEED SHIFT
    Y1LABEL MEDIAN
    XTIC LABEL CONTENT SHIFT SPEED PLANT PROCESS
    DEX MEDIAN PARETO ABSOLUTE EFFECTS PLOT Y PROC PLANT SPEED SHIFT
    Y1LABEL STANDARD DEVIATION
    XTIC LABEL CONTENT SHIFT PLANT SPEED PROCESS
    DEX SD PARETO ABSOLUTE EFFECTS PLOT Y PROC PLANT SPEED SHIFT
    Y1LABEL RANGE
    XTIC LABEL CONTENT SHIFT PLANT SPEED PROCESS
    DEX RANGE PARETO ABSOLUTE EFFECTS PLOT Y PROC PLANT SPEED SHIFT
    END OF MULTIPLOT
 
-----DGACDF (LET)--------------------------------
 
DGACDF
 
Name:
    DGACDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the double gamma cumulative
    distribution function.
 
Description:
    The standard form of the double gamma distribution has the
    following cumulative distribution function:

       F(x,gamma) = 0.5 + GAMCDF(x,gamma)/2       x >= 0
                  = 0.5 - GAMCDF(x,gamma)/2       x < 0

    where GAMCDF is the gamma cumulative distribution function.
 
    This is simply the gamma distribution reflected about x = 0
    when x is negative, or the distribution of ABS(x) when x has a
    gamma distribution.
 
Syntax:
    LET <y> = DGACDF(<x>,<gamma>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a positive number, a number, or a variable;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed double gamma cdf value is saved;
          <gamma> is a number or parameter that specifies the shape
               parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DGACDF(3,1.5)
    LET X2 = DGACDF(X1,GAMMA)
 
Note:
    This distribution is also referred to as the reflected gamma
    distribution in  the literature.  DATAPLOT refers to it as the
    double gamma to be consistent with the terminology used by
    the double exponential and double Weibull distributions.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DGAPDF = Compute the double gamma probability density function.
    DGAPPF = Compute the double gamma percent point function.
    GAMPDF = Compute the gamma probability density function.
    WEIPDF = Compute the Weibull probability density function.
    DWEPDF = Compute the double Weibull probability density function.
    EXPPDF = Compute the exponential probability density function.
    DEXPDF = Compute the double exponential probability density
             function.
    CHSPDF = Compute the chi-square probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994 (capter 17).
 
    "Statistical Distributions", 2nd. Edition, Evans, Hastings, and
    Peacock, Wiley and Sons, 1993 (chapter 18).

Applications:
    Reliability
 
Implementation Date:
    1996/1
 
Program:
    TITLE DGACDF FOR X = -3 0.01 3
    X1LABEL X
    Y1LABEL PROBABILITY
    LEGEND 1 COORDINATES 75 87
    .
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT 2 2
    LEGEND 1 GAMMA = 1
    PLOT DGACDF(X,1) FOR X = -3  0.01  3
    LEGEND 1 GAMMA = 2
    PLOT DGACDF(X,2) FOR X = -3  0.01  3
    LEGEND 1 GAMMA = 5
    PLOT DGACDF(X,5) FOR X = -3  0.01  3
    LEGEND 1 GAMMA = 0.5
    PLOT DGACDF(X,0.5) FOR X = -3  0.01  3
    END OF MULTIPLOT
 
-----DGAPDF (LET)--------------------------------
 
DGAPDF
 
Name:
    DGAPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the double gamma probability
    density function.
 
Description:
    The standard form of the double gamma distribution has the
    following probability density function:

       f(x,gamma) = (1/2)*|x|**(gamma-1)*exp(-|x|)/GAMMA(gamma)   

    where gamma is a positive number that is the shape parameter and
    GAMMA is the standard Gamma function (see the documentation for
    the GAMMA command for details of this function).
 
    This is simply the gamma distribution reflected about x = 0
    when x is negative, or the distribution of ABS(x) when x has a
    gamma distribution.
 
Syntax:
    LET <y> = DGAPDF(<x>,<gamma>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a positive number, a number, or a variable;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed double gamma pdf value is saved;
          <gamma> is a number or parameter that specifies the shape
               parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DGAPDF(3,1.5)
    LET X2 = DGAPDF(X1,GAMMA)
 
Note:
    This distribution is also referred to as the reflected gamma
    distribution in  the literature.  DATAPLOT refers to it as the
    double gamma to be consistent with the terminology used by
    the double exponential and double Weibull distributions.
 
Note:
    The general form of the double gamma distribution is:

       f(x) = (1/2)*(|x-u|/beta)**(gamma-1)*exp(-|x-u|/beta)
                  /(beta*(GAMMA(gamma))

    where mu and beta are the location and scale parameters
    respectively.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DGACDF = Compute the double gamma cumulative distribution
             function.
    DGAPPF = Compute the double gamma percent point function.
    GAMPDF = Compute the gamma probability density function.
    WEIPDF = Compute the Weibull probability density function.
    DWEPDF = Compute the double Weibull probability density function.
    EXPPDF = Compute the exponential probability density function.
    DEXPDF = Compute the double exponential probability density
             function.
    CHSPDF = Compute the chi-square probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994 (capter 17).
 
    "Statistical Distributions", 2nd. Edition, Evans, Hastings, and
    Peacock, Wiley and Sons, 1993 (chapter 18).

Applications:
    Reliability
 
Implementation Date:
    1996/1
 
Program:
    TITLE DGAPDF FOR X = -3 0.01 3
    X1LABEL X
    Y1LABEL PROBABILITY
    LEGEND 1 COORDINATES 75 87
    .
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT 2 2
    LEGEND 1 GAMMA = 1
    PLOT DGAPDF(X,1) FOR X = -3  0.01  3
    LEGEND 1 GAMMA = 2
    PLOT DGAPDF(X,2) FOR X = -3  0.01  3
    LEGEND 1 GAMMA = 5
    PLOT DGAPDF(X,5) FOR X = -3  0.01  3
    LEGEND 1 GAMMA = 0.5
    PLOT DGAPDF(X,0.5) FOR X = -3  0.01  3
    END OF MULTIPLOT
 
-----DGAPPF (LET)--------------------------------
 
DGAPPF
 
Name:
    DGAPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the double gamma percent point
    function.
 
Description:
    The standard form of the double gamma distribution has the
    following percent point function:

       G(p,gamma) = GAMPPF(2*(p - 0.5), gamma)    p >= 0.5
                  = -GAMPPF(2*(0.5 - p), gamma)   p < 0.5

    where GAMPPF is the percent point function of the gamma
    distribution.
 
    This is simply the gamma distribution reflected about x = 0
    when x is negative, or the distribution of ABS(x) when x has a
    gamma distribution.
 
Syntax:
    LET <y> = DGAPPF(<p>,<gamma>)    <SUBSET/EXCEPT/FOR qualification>
    where <p> is a positive number, a number, or a variable;
          <y> is a variable or a parameter (depending on what <p> is)
               where the computed double gamma pdf value is saved;
          <gamma> is a number or parameter that specifies the shape
               parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DGAPPF(0.95,1.5)
    LET X2 = DGAPPF(P,GAMMA)
 
Note:
    This distribution is also referred to as the reflected gamma
    distribution in  the literature.  DATAPLOT refers to it as the
    double gamma to be consistent with the terminology used by
    the double exponential and double Weibull distributions.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DGACDF = Compute the double gamma cumulative distribution
             function.
    DGAPDF = Compute the double gamma probability denstiy function.
    GAMPDF = Compute the gamma probability density function.
    WEIPDF = Compute the Weibull probability density function.
    DWEPDF = Compute the double Weibull probability density function.
    EXPPDF = Compute the exponential probability density function.
    DEXPDF = Compute the double exponential probability density
             function.
    CHSPDF = Compute the chi-square probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994 (capter 17).
 
    "Statistical Distributions", 2nd. Edition, Evans, Hastings, and
    Peacock, Wiley and Sons, 1993 (chapter 18).

Applications:
    Reliability
 
Implementation Date:
    1996/1
 
Program:
    TITLE DGAPPF FOR X = -3 0.01 3
    X1LABEL P
    Y1LABEL X
    LEGEND 1 COORDINATES 75 87
    .
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT 2 2
    LEGEND 1 GAMMA = 1
    PLOT DGAPPF(P,1) FOR P = 0.01  0.01 0.99
    LEGEND 1 GAMMA = 2
    PLOT DGAPPF(P,2) FOR P = 0.01  0.01 0.99
    LEGEND 1 GAMMA = 5
    PLOT DGAPPF(P,5) FOR P = 0,01  0.01  0.99
    LEGEND 1 GAMMA = 0.5
    PLOT DGAPPF(P,0.5) FOR P = 0.01  0.01  0.99
    END OF MULTIPLOT
 
-----DIAGONAL MATRIX (LET)------------------------------------------
 
DIAGONAL MATRIX
 
Name:
    DIAGONAL MATRIX (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Generate a diagonal matrix from the elements of a variable.
 
Description:
    A diagonal matrix is one in which all the elements off the
    main diagonal are zero.
 
Syntax:
    LET <mat3> = DIAGONAL MATRIX <v1> <SUBSET/EXCEPT/FOR qualification>
    where <v1> is a variable with N elements;
          <mat3> is a matrix of dimension NxN where the resulting
               diagonal matrix is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional (and
               rarely used in this context).
 
Examples:
    LET C = DIAGONAL MATRIX X
    LET IDENT = DIAGONAL MATRIX ONES
 
Note:
    Matrices are created with either the READ MATRIX command or the
    MATRIX DEFINITION command.  Enter HELP MATRIX DEFINITION and HELP
    READ MATRIX for details.
 
Note:
    The columns of a matrix are accessible as variables by appending an
    index to the matrix name.  For example, the 4x4 matrix C has
    columns C1, C2, C3, and C4.  These columns can be operated on like
    any other DATAPLOT variable.
 
Note:
    The maximum size matrix that DATAPLOT can handle is set when
    DATAPLOT is built on a particular site.  The default maximums are
    100 columns and 500 rows.  Earlier versions may be 20 rows and 20
    columns or 100 rows and 100 columns.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    MATRIX DIAGONAL      = Extract the diagonal elements of a variable.
    MATRIX ADJOINT       = Compute the adjoint matrix of a matrix.
    MATRIX COFACTOR      = Compute a matrix cofactor.
    MATRIX DEFINITION    = Set a matrix definition.
    MATRIX DETERMINANT   = Compute a matrix determinant.
    MATRIX EIGENVALUES   = Compute the matrix eigenvalues.
    MATRIX EIGENVECTORS  = Compute the matrix eigenvectors.
    MATRIX EUCLID NORM   = Compute the matrix Euclidean norm.
    MATRIX INVERSE       = Compute a matrix inverse.
    MATRIX MINOR         = Compute a matrix minor.
    MATRIX MULTIPLICAT   = Perform a matrix multiplication.
    MATRIX NUMB OF COLU  = Compute the number of columns in a matrix.
    MATRIX NUMB OF ROWS  = Compute the number of rows in a matrix.
    MATRIX RANK          = Compute the rank of a matrix.
    MATRIX SIMPLEX SOLU  = Compute a matrix simplex solution.
    MATRIX SOLUTION      = Solve a system of linear equations.
    MATRIX SPECTRAL NORM = Compute the matrix spectral norm.
    MATRIX SPECTRAL RADI = Compute the matrix spectral radius.
    MATRIX SUBMATRIX     = Define a matrix submatrix.
    MATRIX SUBTRACTION   = Perform a matrix subtraction.
    MATRIX TRACE         = Compute a matrix trace.
    MATRIX TRANSPOSE     = Compute a matrix transpose.
    CORRELATION MATRIX   = Compute the correlation matrix of a matrix.
    VARIANCE-COVA MATRIX = Compute the variance-covariance matrix of a
                           matrix.
    PRINCIPLE COMPONENTS = Compute the principle components of a
                           matrix.
    SINGULAR VALUES      = Compute the singular values of a matrix.
    SINGULAR VALUE DECOM = Compute the singular value decomposition of
                           a matrix.
    SINGULAR VALUE FACT  = Compute the singular value factorization of
                           a matrix.
 
Reference:
    Any standard text on linear algebra.
 
Applications:
    Linear Algebra
 
Implementation Date:
    93/10
 
Program:
    .  GENERATE A 20X20 IDENTITY MATRIX
    LET N = 20
    LET ONES = 1 FOR I = 1 1 N
    LET IDENT = DIAGONAL MATRIX ONES
 
-----DIAMOND-------------------------------------------------------
 
DIAMOND
 
Name:
    DIAMOND
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Draws a diamond.
 
Description:
    The 3 pairs of coordinates define the (x,y) values for one major
    diameter endpoint, one minor diameter endpoint, and the other major
    diameter endpoint (respectively) of the diamond.
 
Syntax:
    DIAMOND   <x1>   <y1>   <x2>   <y2>   <x3>   <y3>
    where <x1> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for one major diameter
               endpoint of the diamond;
          <y1> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for one major diameter
               endpoint of the diamond;
          <x2> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for one minor diameter
               endpoint of the diamond;
          <y2> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for one minor diameter
               endpoint of the diamond;
          <x3> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for the other major
               diameter endpoint of the diamond;
   and    <y3> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for the other major
               diameter endpoint of the diamond.
 
Examples:
    DIAMOND 30 50 50 40 70 50
    DIAMOND 30 30 50 40 70 70
    DIAMOND 20 70 30 50 40 70
    DIAMOND X1 Y1 X2 Y2 X3 Y3
    DIAMOND 50 50 X2 Y2 70 50
    DIAMOND 40 50 50 30 60 50
 
Note:
    The line style (i.e., solid, dash), color, and thickness are
    controlled by the LINE, LINE COLOR, and LINE THICKNESS commands.
    The REGION FILL command can be used to generate solid filled
    diamonds (they can not currently be filled with hatch patterns).
 
Note:
    If you use a software font, diamonds can be embedded in text (e.g.,
    the LEGEND or TEXT command) by entering the string DIAM().  To get
    filled diamonds, enter LEGEND FILL SOLID (for legends) or FILL ON
    (for TEXT).  Diamonds can also be used as plot characters (e.g.,
    CHARACTERS DIAMOND), in which case the attributes are set with the
    various CHARACTER commands.
 
Note:
    The keywords DATA and RELATIVE were added to the TRIANGLE
    command 7/1997.  These keywords are independent and can
    be used separately or together.  For example, 
    TRIANGLE DATA, TRIANGLE RELATIVE, or TRIANGLE DATA RELATIVE.
    The word DATA should come before the word RELATIVE if both
    appear.

    DATA means that the coordinates are specified in terms of
    the data units of the most recent plot rather than Dataplot
    0 to 100 screen units.

    RELATIVE means that the coordinates of the first point
    are drawn in absolute coordinates an all subsequent points
    in the figure are relative to that first point.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    POINT            = Draws a point.
    ARROW            = Draws an arrow.
    TRIANGLE         = Draws a triangle.
    BOX              = Draws a box.
    HEXAGON          = Draws a hexagon.
    CIRCLE           = Draws a circle.
    SEMI-CIRCLE      = Draws a semi-circle.
    ARC              = Draws an arc.
    ELLIPSE          = Draws an ellipse.
    OVAL             = Draws an oval.
    DRAW             = Draws a line.
    MOVE             = Moves to a point.
    LINES            = Sets the line type for figures and plot lines.
    LINE THICKNESSES = Sets the line thickness for figures and  plot
                       lines.
    LINE COLOR       = Sets the line colors for figures and plot lines.
    REGION FILL      = Specifies whether a figure is filled or not.
    CROSS-HAIR       = Activates and reads the cross-hair.
    TEXT             = Writes a text string.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    Pre-1987
 
Program:
    DIAMOND 10 20 15 10 20 20
    DIAMOND 60 30 70 10 80 30
    .
    THICKNESS 0.7
    DIAMOND 10 40  15 30 20 40
    THICKNESS 0.2
    .
    LINE DASH
    DIAMOND 10 60 15 55 20 60
    LINE SOLID
    .
    LINE COLOR G50
    DIAMOND 10 90 15 80 20 90
    LINE COLOR BLACK
    .
    REGION FILL ON
    DIAMOND 30 35  32.5 30 35 35
    REGION FILL COLOR G50
    DIAMOND 40 60 50 40 60 60
    .
    FILL ON
    FONT SIMPLEX
    THICKNESS 0.1
    MOVE 40 80
    TEXT DIAM() DRAW A DIAMOND WITH THE TEXT COMMAND
 
-----DICTIONARY-------------------------------------------------------
 
DICTIONARY
 
Name:
    DICTIONARY
 
Type:
    Keyword
 
Purpose:
    Symbolic name for DATAPLOT's dictionary file.  It is used with the
    SEARCH and LIST commands.
 
Description:
    DATAPLOT's dictionary file contains an alphabetic list of all
    DATAPLOT commands with a brief (one line) description.  It also
    contains names of data, macro, and program files.
 
Syntax:
    None
 
Examples:
    SEARCH DICTIONARY PLOT
    LIST DICTIONARY FOR I = 1 1 35
 
Note:
    The DICTIONARY file is stored in the DATAPLOT directory.  It
    has the name DPDICF.TEX (or dpdicf.tex for Unix systems).  The
    directory name varies depending on the installation (see your local
    DATAPLOT implementor to find the exact name on your system).
 
Note:
    If DATAPLOT is unable to open the dictionary file, it is most
    likely because the directory name is not specified correctly in the
    local DATAPLOT code.  See your local DATAPLOT implementor to have
    this corrected.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SEARCH        = Search a file for a string.
    LIST          = Lists the contents of a file.
    DIRECTORY     = Symbolic name for DATAPLOT's directory file.
 
Applications:
    On-line help
 
Implementation Date:
    Pre-1987
 
Program:
    SEARCH DICTIONARY BOOTSTRAP PLOT
 
-----DIFFERENCE OF AAD (LET)--------------------------------------
 
DIFFERENCE OF AAD
 
Name:
    DIFFERENCE OF AAD (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the average absolute deviations
    (AAD) for two response variables.
 
Description:
    The average absolute deviation is defined as

        AAD = SUM(ABS(X-XBAR))/N

    where ABS is the absolute value, XBAR is the mean of the variable,
    and N is the number of observations.  This statistic is sometimes
    used as an alternative to the standard deviation.

    For the difference of average absolute deviations, the average
    absolute deviation is computed for each of two samples then
    their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF AAD <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the average absolute deviations is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF AAD Y1 Y2
    LET A = DIFFERENCE OF AAD Y1 Y2 SUBSET X > 1

Note:
    Prior to the 2014/07 version, the AVERAGE ABSOLUTE DEVIATION  command
    computed the difference from the median rather than the mean.  The
    2014/07 version corrected this command to compute differences from the
    mean and added the command

          AVERAGE ABSOLUTE DEVIATION FROM THE MEDIAN

    to compute differences from the median.

    Since the DIFFERENCE OF AVERAGE ABSOLUTE DEVIATIONS was based on the
    average absolute deviation computation, these changes apply to it
    as well.

Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    DIFFERENCE OF AVERAGE ABSOLUTE DEVIATION is a synonym for DIFFERENCE OF AAD.
 
Related Commands:
    AVERAGE ABSOLUTE DEVIATION         = Compute the average absolute
    AVERAGE ABSO DEVI FROM THE MEDIAN  = Compute the average absolute
                                         deviation from the median of a
                                         variable.
    MEDIAN ABSOLUTE DEVIATION          = Compute the median absolute
                                         deviation of a variable.
    STANDARD DEVIATION                 = Compute the standard deviation of
                                         a variable.
    VARIANCE                           = Compute the variance of a
                                         variable.
    RANGE                              = Compute the range of a variable.
 
Applications:
    Data Analysis
 
Implementation Date:
    2003/03: Original implementation
    2014/07: Modified definition of underlying average absolute deviation
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF AAD Y1 Y2
    SET WRITE DECIMALS 4
    TABULATE DIFFERENCE OF AAD Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF AAD
    CHAR X
    LINE BLANK
    DIFFERENCE OF AAD PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF AAD PLOT Y1 Y2 X 
 
-----DIFFERENCE OF AVERAGE ABSOLUTE DEVIATION FROM MEDIAN (LET)-----------
 
DIFFERENCE OF AVERAGE ABSOLUTE DEVIATION FROM MEDIAN
 
Name:
    DIFFERENCE OF AVERAGE ABSOLUTE DEVIATION FROM MEDIAN (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the average absolute deviations
    from the median for two response variables.
 
Description:
    The average absolute deviation from the median is defined as

        AAD = SUM(ABS(X-XMED))/N

    where ABS is the absolute value, XMED is the median of the variable,
    and N is the number of observations.  This statistic is sometimes
    used as an alternative to the standard deviation.

    For the difference of average absolute deviations from the median, the
    average absolute deviation from the median is computed for each of two
    samples then their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF AVERAGE ABSOLUTE DEVIATION FROM MEDIAN <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the average absolute deviations from the median is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF AVERAGE ABSOLUTE DEVIATION FROM MEDIAN Y1 Y2

Note:
    Prior to the 2014/07 version, the AVERAGE ABSOLUTE DEVIATION  command
    computed the difference from the median rather than the mean.  The
    2014/07 version corrected this command to compute differences from the
    mean and added the commands

          AVERAGE ABSOLUTE DEVIATION FROM THE MEDIAN
          DIFFERENCE OF AVERAGE ABSOLUTE DEVIATION FROM MEDIAN

    to compute differences from the median.

Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    AVERAGE ABSO DEVI FROM THE MEDIAN  = Compute the average absolute
                                         deviation from the median of a
                                         variable.
    AVERAGE ABSOLUTE DEVIATION         = Compute the average absolute
    MEDIAN ABSOLUTE DEVIATION          = Compute the median absolute
                                         deviation of a variable.
    STANDARD DEVIATION                 = Compute the standard deviation of
                                         a variable.
    VARIANCE                           = Compute the variance of a
                                         variable.
    RANGE                              = Compute the range of a variable.
 
Applications:
    Data Analysis
 
Implementation Date:
    2014/07: Original implementation
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF AAD Y1 Y2
    SET WRITE DECIMALS 4
    TABULATE DIFFERENCE OF AAD Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF AAD
    CHAR X
    LINE BLANK
    DIFFERENCE OF AAD PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF AAD PLOT Y1 Y2 X 
 
-----DIFFERENCE OF BIWEIGHT LOCATION (LET)----------------------------
 
DIFFERENCE OF BIWEIGHT LOCATION
 
Name:
    DIFFERENCE OF BIWEIGHT LOCATION (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the biweight locations for two
    response variables.
 
Description:
     The biweight location estimate is defined as:
 
        y* = SUM[i=1 to n][w(i)*y(i)]/SUM[i=1 to n][w(i)]
 
     where 
 
       w(i) = (1 - ((y(i)-y*)/(c*S))**2)**2  for (Y(i)-y*)/(c*S)**2 < 1
            = 0                              otherwise
 
       S = median{|y(i) - y*|}
 
       c = 6  (using 6 means that residuals up to approximately
              4*sigma are included)
 
    Note that this is an iterative estimate since y* depends on
    w(i) and w(i) depends on y*.
 
    Dataplot will compute up to 10 iterations (computation is
    terminated if the biweight location estimate does not
    change in value by more than 0.000001).

    For the difference of biweight locations, the biweight
    location is computed for each of two samples then their
    difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF BIWEIGHT LOCATION <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the biweight locations is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF BIWEIGHT LOCATION Y1 Y2
    LET A = DIFFERENCE OF BIWEIGHT LOCATION Y1 Y2 SUBSET X > 1
 
Note:
    The difference of biweight locations statistic is also
    supported for the following commands:

        DIFFERENCE OF BIWEIGHT LOCATIONS PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF BIWEIGHT LOCATIONS PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF BIWEIGHT LOCATIONS PLOT Y1 Y2
        TABULATE DIFFERENCE OF BIWEIGHT LOCATIONS Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF BIWEIGHT LOCATIONS Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF BIWEIGHT LOCATIONS Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BIWEIGHT LOCATION               = Compute the biweight location.
    DIFFERENCE OF MEDIAN            = Compute the difference of
                                      medians.
    DIFFERENCE OF TRIMMED MEAN      = Compute the difference of
                                      trimmed means.
    DIFFERENCE OF MIDMEAN           = Computes the difference of
                                      midmeans.
    DIFFERENCE OF MEAN              = Compute the difference of means.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus
                                      two subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
 
Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF BIWEIGHT LOCATION Y1 Y2
    TABULATE DIFFERENCE OF BIWEIGHT LOCATION Y1 Y2 X
    .
    CHAR X
    LINE BLANK
    DIFFERENCE OF BIWEIGHT LOCATION PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF BIWEIGHT LOCATION PLOT Y1 Y2 X 
 
-----DIFFERENCE OF BIWEIGHT MIDVARIANCE (LET)-------------------------
 
DIFFERENCE OF BIWEIGHT MIDVARIANCE
 
Name:
    DIFFERENCE OF BIWEIGHT MIDVARIANCE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the biweight midvariances
    for two response variables.
 
Description:
    The biweight midvariance estimate is defined as:

       s(bi)**2 = {SUM'[(y-y')**2]*(1-u**2)**4}/
                   {[SUM'[1-u**2)*(1-5*u**2)]**2}

    where 

      y' = median y
      u(i) = (Y(i) - y')/[9*MAD]
      MAD = median absolute deviation
      SUM' means the summation is for u**2 <= 1

    For the difference of biweight midvariances, the biweight
    midvariance is computed for each of two samples then
    their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF BIWEIGHT MIDVARIANCE <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the biweight midvariances is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF BIWEIGHT MIDVARIANCE Y1 Y2
    LET A = DIFFERENCE OF BIWEIGHT MIDVARIANCE Y1 Y2 SUBSET X > 1
 
Note:
    The difference of biweight midvariances statistic is
    also supported for the following commands:

        DIFFERENCE OF BIWEIGHT MIDVARIANCE PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF BIWEIGHT MIDVARIANCE PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF BIWEIGHT MIDVARIANCE PLOT Y1 Y2
        TABULATE DIFFERENCE OF BIWEIGHT MIDVARIANCE Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF BIWEIGHT MIDVARIANCE Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF BIWEIGHT MIDVARIANCE Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BIWEIGHT MIDVARIANCE            = Compute the biweight midvariance.
    MAD                             = Compute the median absolute
                                      deviation.
    AAD                             = Compute the average absolute
                                      deviation.
    PERCENTAGE BEND MIDVARIANCE     = Compute the percentage bend
                                      midvariance.
    STANDARD DEVIATION              = Compute the standard deviation.
    DIFFERENCE OF AAD               = Compute the difference of
                                      average absolute deviations.
    DIFFERENCE OF SD                = Compute the difference of
                                      standard deviations.
    DIFFERENCE OF BIWEIGHT SCALE    = Compute the difference of
                                      biweight scales.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus
                                      two subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
    TABULATE                        = Perform a tabulation for a
                                      specified statistic.
    CROSS TABULATE                  = Perform a cross tabulation
                                      for a specified statistic.
 
Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF BIWEIGHT MIDVARIANCE Y1 Y2
    TABULATE DIFFERENCE OF BIWEIGHT MIDVARIANCE Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF BIWEIGHT MIDVARIANCE
    CHAR X
    LINE BLANK
    DIFFERENCE OF BIWEIGHT MIDVARIANCE PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF BIWEIGHT MIDVARIANCE PLOT Y1 Y2 X 
 
-----DIFFERENCE OF BIWEIGHT SCALE (LET)-------------------------
 
DIFFERENCE OF BIWEIGHT SCALE
 
Name:
    DIFFERENCE OF BIWEIGHT SCALE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the biweight scales
    for two response variables.
 
Description:
    The biweight scale estimate is defined as:

       ns(bi)**2 = {n*SUM'[(y-y')**2]*(1-u**2)**4}/
                   {[SUM'[1-u**2)*(1-5*u**2)]*
                   [-1 + SUM'[1-u**2)*(1-5*u**2)]}

    where 

      y' = median y
      u(i) = (Y(i) - y')/[9*MAD]

    For the difference of biweight scales, the biweight
    scale is computed for each of two samples then
    their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF BIWEIGHT SCALE <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the biweight scales is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF BIWEIGHT SCALE Y1 Y2
    LET A = DIFFERENCE OF BIWEIGHT SCALE Y1 Y2 SUBSET X > 1
 
Note:
    The difference of biweight scales statistic is
    also supported for the following commands:

        DIFFERENCE OF BIWEIGHT SCALE PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF BIWEIGHT SCALE PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF BIWEIGHT SCALE PLOT Y1 Y2
        TABULATE DIFFERENCE OF BIWEIGHT SCALE Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF BIWEIGHT SCALE Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF BIWEIGHT SCALE Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BIWEIGHT SCALE                  = Compute the biweight scale.
    MAD                             = Compute the median absolute
                                      deviation.
    AAD                             = Compute the average absolute
                                      deviation.
    PERCENTAGE BEND MIDVARIANCE     = Compute the percentage bend
                                      midvariance.
    STANDARD DEVIATION              = Compute the standard deviation.
    DIFFERENCE OF AAD               = Compute the difference of
                                      average absolute deviations.
    DIFFERENCE OF SD                = Compute the difference of
                                      standard deviations.
    DIFFERENCE OF BIWEIGHT MIDVAR   = Compute the difference of
                                      biweight midvariances.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus
                                      two subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
    TABULATE                        = Perform a tabulation for a
                                      specified statistic.
    CROSS TABULATE                  = Perform a cross tabulation
                                      for a specified statistic.
 
Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF BIWEIGHT SCALE Y1 Y2
    TABULATE DIFFERENCE OF BIWEIGHT SCALE Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF BIWEIGHT SCALE
    CHAR X
    LINE BLANK
    DIFFERENCE OF BIWEIGHT SCALE PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF BIWEIGHT SCALE PLOT Y1 Y2 X 
 
-----DIFFERENCE OF COEFFICENT OF VARIATION (LET)------------------
 
DIFFERENCE OF COEFFICENT OF VARIATION
 
Name:
    DIFFERENCE OF COEFFICENT OF VARIATION (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the coefficient of variation
    for two response variables.
 
Description:
    The coefficient of variation is the standard deviation divided
    by the mean.

    For the difference of the coefficient of variation, the
    coefficient of variation is computed for each of two samples
    then their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF COEFFICENT OF VARIATION <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the coefficient of variation is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF COEFFICENT OF VARIATION Y1 Y2
    LET A = DIFFERENCE OF COEFFICENT OF VARIATION Y1 Y2 SUBSET X > 1
 
Note:
    The difference of coefficient of variations statistic is
    also supported for the following commands:

        DIFFERENCE OF COEFFICENT OF VARIATION PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF COEFFICENT OF VARIATION PLOT
              Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF COEFFICENT OF VARIATION PLOT Y1 Y2
        TABULATE DIFFERENCE OF COEFFICENT OF VARIATION Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF COEFFICENT OF VARIATION Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF COEFFICENT OF VARIATION
              Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COEFFICENT OF VARIATION         = Compute the coefficient of
                                      variation.
    RELATIVE SD                     = Compute the relative sd.
    MEAN                            = Compute the mean.
    SD                              = Compute the sd.
    DIFFERENCE OF MEAN              = Compute the difference of
                                      the means.
    DIFFERENCE OF SD                = Compute the difference of
                                      standard deviations.
    DIFFERENCE OF RELATIVE SD       = Compute the difference of
                                      the relative sd.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus
                                      two subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
    TABULATE                        = Perform a tabulation for a
                                      specified statistic.
    CROSS TABULATE                  = Perform a cross tabulation
                                      for a specified statistic.
 
Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF COEFFICENT OF VARIATION Y1 Y2
    TABULATE DIFFERENCE OF COEFFICENT OF VARIATION Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF COEFFICENT OF VARIATION
    CHAR X
    LINE BLANK
    DIFFERENCE OF COEFFICENT OF VARIATION PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF COEFFICENT OF VARIATION PLOT Y1 Y2 X 
 
-----DIFFERENCE OF COUNT (LET)--------------------------------------
 
DIFFERENCE OF COUNT
 
Name:
    DIFFERENCE OF COUNT (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the count (sample size) for
    two response variables.
 
Description:
    The count is the number of obserations in a response variable.

    For the difference of counts, the count is computed for
    each of two samples then their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF COUNT <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the counts is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF COUNT Y1 Y2
    LET A = DIFFERENCE OF COUNT Y1 Y2 SUBSET X > 1

Default:
    None
 
Synonyms:
    DIFFERENCE OF SIZE and DIFFERENCE OF NUMBER are synonyms for
    DIFFERENCE OF COUNT.
 
Related Commands:
    COUNT                           = Compute the count.
    MINIMUM                         = Compute the minimum.
    MAXIMUM                         = Compute the maximum.
    SUM                             = Compute the sum.
    DIFFERENCE OF MINIMUM           = Compute the difference of
                                      the minimums.
    DIFFERENCE OF MAXIMUM           = Compute the difference of
                                      the maximums.
    DIFFERENCE OF SUM               = Compute the difference of sums.
 
Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ AUTO83B.DAT Y1 Y2
    .
    RETAIN Y2 SUBSET Y2 > -900
    LET A = DIFFERENCE OF COUNT Y1 Y2
 
-----DIFFERENCE OF EXTREME (LET)--------------------------------------
 
DIFFERENCE OF EXTREME
 
Name:
    DIFFERENCE OF EXTREME (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the extremes for two response
    variables.
 
Description:
    The extreme is the maximum of the absolute value of the
    smallest and largest value of a response variable.

    For the difference of extremes, the extreme is computed for
    each of two samples then their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF EXTREME <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the extreme is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF EXTREME Y1 Y2
    LET A = DIFFERENCE OF EXTREME Y1 Y2 SUBSET X > 1
 
Note:
    The difference of extremes statistic is
    also supported for the following commands:

        DIFFERENCE OF EXTREME PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF EXTREME PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF EXTREME PLOT Y1 Y2
        TABULATE DIFFERENCE OF EXTREME Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF EXTREME Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF EXTREME Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EXTREME                         = Compute the extreme.
    MEAN                            = Compute the mean.
    MINIMUM                         = Compute the minimum.
    MAXIMUM                         = Compute the maximum.
    QUANTILE                        = Compute a quantile.
    STANDARD DEVIATION              = Compute the standard deviation.
    DIFFERENCE OF MINIMUM           = Compute the difference of
                                      the minimums.
    DIFFERENCE OF MAXIMUM           = Compute the difference of
                                      the maximums.
    DIFFERENCE OF SD                = Compute the difference of
                                      standard deviations.
    DIFFERENCE OF QUANTILE          = Compute the difference of
                                      a quantile.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus
                                      two subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
    TABULATE                        = Perform a tabulation for a
                                      specified statistic.
    CROSS TABULATE                  = Perform a cross tabulation
                                      for a specified statistic.
 
Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF EXTREME Y1 Y2
    TABULATE DIFFERENCE OF EXTREME Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF EXTREME
    CHAR X
    LINE BLANK
    DIFFERENCE OF EXTREME PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF EXTREME PLOT Y1 Y2 X 
 
-----DIFFERENCE OF GEOMETRIC MEAN (LET)--------------------------------
 
DIFFERENCE OF GEOMETRIC MEAN
 
Name:
    DIFFERENCE OF GEOMETRIC MEAN (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the geometric means for two
    response variables.
 
Description:
    The geometric mean is defined as:
 
         XGM = (PRODUCT(Xi))**(1/N)

    For the difference of geometric means, the geometric mean is
    computed for each of two samples then their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF GEOMETRIC MEAN <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the geometric means is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF GEOMETRIC MEAN Y1 Y2
    LET A = DIFFERENCE OF GEOMETRIC MEAN Y1 Y2 SUBSET X > 1
 
Note:
    The difference of geometric means statistic is also supported for
    the following commands:

        DIFFERENCE OF GEOMETRIC MEANS PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF GEOMETRIC MEANS PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF GEOMETRIC MEANS PLOT Y1 Y2
        TABULATE DIFFERENCE OF GEOMETRIC MEANS Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF GEOMETRIC MEANS Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF GEOMETRIC MEANS Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GEOMETRIC MEAN                  = Compute the geometric mean.
    DIFFERENCE OF MEAN              = Compute the difference of means.
    DIFFERENCE OF HARMONIC MEAN     = Compute the difference of
                                      harmonic means.
    DIFFERENCE OF MEDIAN            = Compute the difference of
                                      medians.
    DIFFERENCE OF TRIMMED MEAN      = Compute the difference of
                                      trimmed means.
    DIFFERENCE OF MIDMEAN           = Compute the difference of
                                      midmeans.
    DIFFERENCE OF BIWEIGHT LOCATION = Compute the difference of
                                      biweight locations.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus
                                      two subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
 
Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF GEOMETRIC MEAN Y1 Y2
    TABULATE DIFFERENCE OF GEOMETRIC MEAN Y1 Y2 X
    .
    CHAR X
    LINE BLANK
    DIFFERENCE OF GEOMETRIC MEAN PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF GEOMETRIC MEAN PLOT Y1 Y2 X 
 
-----DIFFERENCE OF GEOMETRIC SD (LET)---------------------------------
 
DIFFERENCE OF GEOMETRIC SD
 
Name:
    DIFFERENCE OF GEOMETRIC SD (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the geometric standard deviations
    for two response variables.
 
Description:
    The geometric standard deviation is defined as:
 
         GSD = EXP(SD(LOG(Xi)))

    For the difference of geometric standard deviations, the
    geometric standard deviation is computed for each of two
    samples then their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF GEOMETRIC SD <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the geometric standard deviations is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF GEOMETRIC SD Y1 Y2
    LET A = DIFFERENCE OF GEOMETRIC SD Y1 Y2 SUBSET X > 1
 
Note:
    The difference of geometric sds statistic is
    also supported for the following commands:

        DIFFERENCE OF GEOMETRIC SD PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF GEOMETRIC SD PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF GEOMETRIC SD PLOT Y1 Y2
        TABULATE DIFFERENCE OF GEOMETRIC SD Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF GEOMETRIC SD Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF GEOMETRIC SD Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GEOMETRIC SD                    = Compute the geometric sd.
    GEOMETRIC MEAN                  = Compute the geometric mean.
    STANDARD DEVIATION              = Compute the standard deviation.
    DIFFERENCE OF MEAN              = Compute the difference of the
                                      means.
    DIFFERENCE OF GEOMETRIC MEAN    = Compute the difference of the
                                      geometric means.
    DIFFERENCE OF SD                = Compute the difference of
                                      standard deviations.
    DIFFERENCE OF QUANTILE          = Compute the difference of a
                                      quantile.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus two
                                      subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
    TABULATE                        = Perform a tabulation for a
                                      specified statistic.
    CROSS TABULATE                  = Perform a cross tabulation for
                                      a specified statistic.
 
Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25 
    READ IRIS.DAT Y1 TO Y4 X 
    . 
    LET A = DIFFERENCE OF GEOMETRIC SD Y1 Y2 
    TABULATE DIFFERENCE OF GEOMETRIC SD Y1 Y2 X 
    . 
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF GEOMETRIC SDS
    CHAR X 
    LINE BLANK 
    DIFFERENCE OF GEOMETRIC SD PLOT Y1 Y2 X 
    .
    CHAR X ALL 
    LINE BLANK ALL 
    BOOTSTRAP DIFFERENCE OF GEOMETRIC SD PLOT Y1 Y2 X  
 
-----DIFFERENCE OF HARMONIC MEAN (LET)--------------------------------
 
DIFFERENCE OF HARMONIC MEAN
 
Name:
    DIFFERENCE OF HARMONIC MEAN (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the harmonic means for two
    response variables.
 
Description:
    The harmonic mean is defined as:
 
         XHM = N/SUM(1/Xi)

    For the difference of harmonic means, the mean is computed
    for each of two samples then their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF HARMONIC MEAN <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the harmonic means is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF HARMONIC MEAN Y1 Y2
    LET A = DIFFERENCE OF HARMONIC MEAN Y1 Y2 SUBSET X > 1
 
Note:
    The difference of harmonic means statistic is also supported for
    the following commands:

        DIFFERENCE OF HARMONIC MEANS PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF HARMONIC MEANS PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF HARMONIC MEANS PLOT Y1 Y2
        TABULATE DIFFERENCE OF HARMONIC MEANS Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF HARMONIC MEANS Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF HARMONIC MEANS Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    HARMONIC MEAN                   = Compute the harmonic mean.
    DIFFERENCE OF GEOMETRIC MEAN    = Compute the difference of
                                      geometric means.
    DIFFERENCE OF MEAN              = Compute the difference of means.
    DIFFERENCE OF MEDIAN            = Compute the difference of
                                      medians.
    DIFFERENCE OF TRIMMED MEAN      = Compute the difference of
                                      trimmed means.
    DIFFERENCE OF MIDMEAN           = Compute the difference of
                                      midmeans.
    DIFFERENCE OF BIWEIGHT LOCATION = Compute the difference of
                                      biweight locations.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus
                                      two subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
 
Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF HARMONIC MEAN Y1 Y2
    TABULATE DIFFERENCE OF HARMONIC MEAN Y1 Y2 X
    .
    CHAR X
    LINE BLANK
    DIFFERENCE OF HARMONIC MEAN PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF HARMONIC MEAN PLOT Y1 Y2 X 
 
-----DIFFERENCE OF HODGES-LEHMANN (LET)------------------------------
 
DIFFERENCE OF HODGES-LEHMANN
 
Name:
    DIFFERENCE OF HODGES-LEHMANN (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the Hodges-Lehmanns location
    estimator for two response variables.
 
Description:
    The Hodge-Lehmann location estimate is based on ranks.  This
    makes it more resistant than the mean.  This estimator also
    has high efficiency for symmetric disributions.  It may be less
    successful with some skewed distributions.

    Specifically, the Hodges-Lehmann estimate for location is
    defined as

        muhat = median {(X(i) + X(j))/2,   1 <= i <= j <= n}

    Dataplot uses ACM algorithm 616 (HLQEST written by John
    Monohan) to compute the estimate.  This is a fast, exact
    algoirthm.  One modification is that for n <= 25 Dataplot
    computes the estimate directly from the definition.

    For the difference of the Hodges-Lehmann location estimats,
    the Hodges-Lehmann location estimate is computed for
    each of two samples then their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF HODGES-LEHMANN <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the Hodges-Lehmann location estimate is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF HODGES-LEHMANN Y1 Y2
    LET A = DIFFERENCE OF HODGES-LEHMANN Y1 Y2 SUBSET X > 1
 
Note:
    The difference of Hodges-Lehmanns statistic is
    also supported for the following commands:

        DIFFERENCE OF HODGES-LEHMANN PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF HODGES-LEHMANN PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF HODGES-LEHMANN PLOT Y1 Y2
        TABULATE DIFFERENCE OF HODGES-LEHMANN Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF HODGES-LEHMANN Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF HODGES-LEHMANN
              Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    HODGES-LEHMANN                  = Compute the Hodges-Lehmann
                                      location estimate.
    MEAN                            = Compute the mean.
    MEDIAN                          = Compute the median.
    TRIMMED MEAN                    = Compute the trimmed mean.
    BIWEIGHT LOCATION               = Compute the biweight location.
    DIFFERENCE OF MEAN              = Compute the difference of
                                      the means.
    DIFFERENCE OF MEDIAN            = Compute the difference of
                                      the median.
    DIFFERENCE OF TRIMMED MEAN      = Compute the difference of
                                      the trimmed mean.
    DIFFERENCE OF BIWEIGHT LOCATION = Compute the difference of
                                      the biweight location.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus
                                      two subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
    TABULATE                        = Perform a tabulation for a
                                      specified statistic.
    CROSS TABULATE                  = Perform a cross tabulation
                                      for a specified statistic.
 
Reference:
    "Algorithm 616: Fast Computation of the Hodges-Lehmann Location
    Estimator", John Monahan, ACM Transactions on Mathematical
    Software, Vol. 10, No. 3, September 1984, pp. 265-270.

    "Introduction to Robust Estimation and Hypothesis Testing",
    Rand Wilcox, Academic Press, 1997.

Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF HODGES-LEHMANN Y1 Y2
    TABULATE DIFFERENCE OF HODGES-LEHMANN Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF HODGES-LEHMANN
    CHAR X
    LINE BLANK
    DIFFERENCE OF HODGES-LEHMANN PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF HODGES-LEHMANN PLOT Y1 Y2 X 
 
-----DIFFERENCE OF INTERQUARTILE RANGE (LET)-----------------------

DIFFERENCE OF INTERQUARTILE RANGE
 
Name:
    DIFFERENCE OF INTERQUARTILE RANGE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the interquartile ranges for
    two response variables.
 
Description:
    The interquartile range is:

        IQ = UPPER QUARTILE - LOWER QUARTILE

    That is, it is the difference betweeen the 75th and 25th
    percentiles of a variable.

    The normalized interquartile range is

        NIQ = 0.7413*IQ

    This normalization is based on the fact that for a normal
    distribution, the interquartile range is approximately
    1.349 times the standard deviation.

    For the difference of interquartile ranges, the interquartile
    range is computed for each of two samples then their difference
    is taken.

Syntax 1:
    LET <par> = DIFFERENCE OF INTERQUARTILE RANGE <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the interquartile ranges is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    LET <par> = DIFFERENCE OF NORMALIZED INTERQUARTILE RANGE <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the normalized interquartile ranges is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF INTERQUARTILE RANGE Y1 Y2
    LET A = DIFFERENCE OF INTERQUARTILE RANGE Y1 Y2 SUBSET X > 1
    LET A = DIFFERENCE OF NORMALIZED INTERQUARTILE RANGE Y1 Y2
 
Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

        HELP STATISTICS

Default:
    None
 
Synonyms:
    IQ RANGE is a synonym for INTERQUARTILE RANGE
    IQR is a synonym for INTERQUARTILE RANGE
    SCALED is a synonym for NORMALIZED
    The word OF is optional
 
Related Commands:
    INTERQUARTILE RANGE             = Compute the interquartile range.
    RANGE                           = Compute the range.
    MIDRANGE                        = Compute the midrange.
    PERCENTILE                      = Compute a percentile.
    QUANTILE                        = Compute a quantile.
    STANDARD DEVIATION              = Compute the standard deviation.
    DIFFERENCE OF RANGE             = Compute the difference of
                                      the range.
    DIFFERENCE OF MIDRANGE          = Compute the difference of
                                      the midrange.
    DIFFERENCE OF SD                = Compute the difference of
                                      standard deviations.
    DIFFERENCE OF QUANTILE          = Compute the difference of
                                      a quantile.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus
                                      two subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
    TABULATE                        = Perform a tabulation for a
                                      specified statistic.
    CROSS TABULATE                  = Perform a cross tabulation
                                      for a specified statistic.
 
Applications:
    Data Analysis
 
Implementation Date:
    2003/03
    2016/02: Added NORMALIZED INTERQUARTILE RANGE
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF INTERQUARTILE RANGE Y1 Y2
    TABULATE DIFFERENCE OF INTERQUARTILE RANGE Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF INTERQUARTILE RANGE
    CHAR X
    LINE BLANK
    DIFFERENCE OF INTERQUARTILE RANGE PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF INTERQUARTILE RANGE PLOT Y1 Y2 X 
 
-----DIFFERENCE OF KURTOSIS (LET)------------------------------------
 
DIFFERENCE OF KURTOSIS
 
Name:
    DIFFERENCE OF KURTOSIS (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the kurtosiss for two response
    variables.
 
Description:
    The kurtosis is the standardized fourth central moment.  The
    formula is:

        (SUM[i=1 to n][(x-xbar)**4]/(N-1)/s**4

    with xbar denoting the mean, s denoting the standard deviation,
    and n denoting the number of observations.

    For the difference of kurtosiss, the kurtosis is computed for
    each of two samples then their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF KURTOSIS <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the kurtosiss is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF KURTOSIS Y1 Y2
    LET A = DIFFERENCE OF KURTOSIS Y1 Y2 SUBSET X > 1
 
Note:
    The difference of kurtosiss statistic is
    also supported for the following commands:

        DIFFERENCE OF KURTOSIS PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF KURTOSIS PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF KURTOSIS PLOT Y1 Y2
        TABULATE DIFFERENCE OF KURTOSIS Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF KURTOSIS Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF KURTOSIS Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    KURTOSIS                        = Compute the kurtosis.
    MEAN                            = Compute the mean.
    STANDARD DEVIATION              = Compute the standard deviation.
    SKEWNESS                        = Compute the skewness.
    DIFFERENCE OF MEAN              = Compute the difference of
                                      the means.
    DIFFERENCE OF SD                = Compute the difference of
                                      standard deviations.
    DIFFERENCE OF SKEWNESS          = Compute the difference of
                                      the skewness.
    DIFFERENCE OF QUANTILE          = Compute the difference of
                                      a quantile.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus
                                      two subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
    TABULATE                        = Perform a tabulation for a
                                      specified statistic.
    CROSS TABULATE                  = Perform a cross tabulation
                                      for a specified statistic.
 
Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF KURTOSIS Y1 Y2
    TABULATE DIFFERENCE OF KURTOSIS Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF KURTOSIS
    CHAR X
    LINE BLANK
    DIFFERENCE OF KURTOSIS PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF KURTOSIS PLOT Y1 Y2 X 
 
-----DIFFERENCE OF MAD (LET)--------------------------------------
 
DIFFERENCE OF MAD
 
Name:
    DIFFERENCE OF MAD (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the median absolute deviations
    (MAD) for two response variables.
 
Description:
    The median absolute deviation (MAD) is:

        MAD = MEDIAN(ABS(X-XMED))

    where ABS is the absolute value and XMED is the median of the
    variable.  This statistic is sometimes used as an alternative to
    the standard deviation.

    The scaled MAD is defined as

       MADN = MAD/0.6745

    For normally distributed data, the scaled MAD is approximately
    equal to the standard deviation.

    For the difference of median absolute deviations, the median
    absolute deviation is computed for each of two samples then
    their difference is taken.

Syntax 1:
    LET <par> = DIFFERENCE OF MAD <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the median absolute deviations is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    LET <par> = DIFFERENCE OF SCALED MAD <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the scaled median absolute deviations is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF MAD Y1 Y2
    LET A = DIFFERENCE OF SCALED MAD Y1 Y2
    LET A = DIFFERENCE OF MAD Y1 Y2 SUBSET X > 1
 
Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    MEDIAN ABSOLUTE DEVIATIONS is a synonym for MAD
    MADN is a synonym for SCALED MAD
    NORMALIZED is a synonym for SCALED
 
Related Commands:
    MAD                             = Compute the median absolute
                                      deviation.
    AAD                             = Compute the average absolute
                                      deviation.
    STANDARD DEVIATION              = Compute the standard deviation.
    DIFFERENCE OF AAD               = Compute the difference of
                                      average absolute deviations.
    DIFFERENCE OF SD                = Compute the difference of
                                      standard deviations.
    DIFFERENCE OF BIWEIGHT SCALE    = Compute the difference of
                                      biweight scales.
    DIFFERENCE OF BIWEIGHT MIDVARIA = Compute the difference of
                                      biweight midvariances.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus
                                      two subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
    TABULATE                        = Perform a tabulation for a
                                      specified statistic.
    CROSS TABULATE                  = Perform a cross tabulation
                                      for a specified statistic.
 
Applications:
    Robust Estimation of Scale
 
Implementation Date:
    2003/03
    2016/02: Added DIFFERENCE OF SCALED MAD
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF MAD Y1 Y2
    TABULATE DIFFERENCE OF MAD Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF MAD
    CHAR X
    LINE BLANK
    DIFFERENCE OF MAD PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF MAD PLOT Y1 Y2 X 
 
-----DIFFERENCE OF MAXIMUM (LET)--------------------------------------
 
DIFFERENCE OF MAXIMUM
 
Name:
    DIFFERENCE OF MAXIMUM (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the maximums for two response
    variables.
 
Description:
    The maximum is the largest value of a response variable.

    For the difference of maximums, the maximum is computed for
    each of two samples then their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF MAXIMUM <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the maximums is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF MAXIMUM Y1 Y2
    LET A = DIFFERENCE OF MAXIMUM Y1 Y2 SUBSET X > 1
 
Note:
    The difference of maximums statistic is
    also supported for the following commands:

        DIFFERENCE OF MAXIMUM PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF MAXIMUM PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF MAXIMUM PLOT Y1 Y2
        TABULATE DIFFERENCE OF MAXIMUM Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF MAXIMUM Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF MAXIMUM Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    MAXIMUM                         = Compute the maximum.
    MIDMEAN                         = Compute the midmean.
    MEAN                            = Compute the mean.
    MINIMUM                         = Compute the minimum.
    QUANTILE                        = Compute a quantile.
    STANDARD DEVIATION              = Compute the standard deviation.
    DIFFERENCE OF MINIMUM           = Compute the difference of
                                      the minimums.
    DIFFERENCE OF MEAN              = Compute the difference of
                                      the means.
    DIFFERENCE OF SD                = Compute the difference of
                                      standard deviations.
    DIFFERENCE OF QUANTILE          = Compute the difference of
                                      a quantile.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus
                                      two subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
    TABULATE                        = Perform a tabulation for a
                                      specified statistic.
    CROSS TABULATE                  = Perform a cross tabulation
                                      for a specified statistic.
 
Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF MAXIMUM Y1 Y2
    TABULATE DIFFERENCE OF MAXIMUM Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF MAXIMUM
    CHAR X
    LINE BLANK
    DIFFERENCE OF MAXIMUM PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF MAXIMUM PLOT Y1 Y2 X 
 
-----DIFFERENCE OF MEAN (LET)--------------------------------------
 
DIFFERENCE OF MEAN
 
Name:
    DIFFERENCE OF MEAN (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the means for two
    response variables.
 
Description:
    The mean is computed as

        A = SUM[i=1 to n][Y(i)]/n

    For the difference of means, the mean is computed for each of two
    samples then their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF MEAN <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the means is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF MEAN Y1 Y2
    LET A = DIFFERENCE OF MEAN Y1 Y2 SUBSET X > 1
 
Note:
    The difference of means statistic is also supported for
    the following commands:

        DIFFERENCE OF MEANS PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF MEANS PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF MEANS PLOT Y1 Y2
        TABULATE DIFFERENCE OF MEANS Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF MEANS Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF MEANS Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    MEAN                            = Compute the mean.
    DIFFERENCE OF MEDIAN            = Compute the difference of
                                      medians.
    DIFFERENCE OF TRIMMED MEAN      = Compute the difference of
                                      trimmed means.
    DIFFERENCE OF MIDMEAN           = Compute the difference of
                                      midmeans.
    DIFFERENCE OF BIWEIGHT LOCATION = Compute the difference of
                                      biweight locations.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus
                                      two subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
 
Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF MEAN Y1 Y2
    TABULATE DIFFERENCE OF MEAN Y1 Y2 X
    .
    CHAR X
    LINE BLANK
    DIFFERENCE OF MEAN PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF MEAN PLOT Y1 Y2 X 
 
-----DIFFERENCE OF MEANS CONFIDENCE INTERVAL--------------------------
 
DIFFERENCE OF MEANS CONFIDENCE INTERVAL
 
Name:
    DIFFERENCE OF MEANS CONFIDENCE INTERVAL
 
Type:
    Analysis Command
 
Purpose:
    Generates a confidence interval for the difference between two
    means.
 
Description:
    The confidence interval for the difference between tow means
    is defined by:

       (Ybar1 - Ybar2) +/- SQRT[s1**2/n1 + s2**2/n2]*t(1-alpha/2,df)
                       
    where
       Ybar1 = mean of first sample
       Ybar2 = mean of second sample
       s1    = standard deviation of sample 1
       s2    = standard deviation of sample 2
       alpha = the desired significance level
       df    = the degrees of freedom
             = (s1**2/n1 + s2**2/n2)**2/
               [(s1**2/n1)**2*(n1-1) + (s2**2/n2)**2*(n2-1)]
  
Syntax:
    DIFFERENCE OF MEANS CONFIDENCE INTERVAL  <y1>  <y2>
                        <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable,
          <y2> is the second response variable,
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    DIFFERENCE OF MEANS CONFIDENCE INTERVAL Y1 Y2
    DIFFERENCE OF MEANS CONFIDENCE INTERVAL Y1 Y2  SUBSET TAG > 2
    DIFFERENCE OF MEANS CONFIDENCE INTERVAL Y1 Y2  SUBSET Y1 > 0
 
Note:
    A table of confidence intervals is printed for alpha levels of
    50.0, 75.0, 90.0, 95.0, 99.0, 99.9, 99.99, and 99.999.  The sample
    sizes, sample means, sample standard deviations, and the standard
    error are also printed.  The t-value and t-value X standard
    error are printed in the table.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CONFIDENCE LIMITS                   = Generate a confidence
                                          interval for the mean.
    T-TEST                              = Perform a two sample t-test.
    BIHISTOGRAM                         = Generate a bihistogram.
    QUANTILE-QUANTILE PLOT              = Generate a quantile-quantile
                                          plot.
    KOLMOGOROV-SMIRNOV TWO SAMPLE TEST  = Generate a Kolmogorov-
                                          Smirnov two sample test.
 
Reference:
    Confidence intervals for the difference of two means are covered in
    most introductory statistics books.
 
Applications:
    Confirmatory Data Analysis
 
Implementation Date:
    3/1999
 
Program:
    SKIP 25
    READ AUTO83B.DAT Y1 Y2
    RETAIN Y2 SUBSET Y2 >= 0
    DIFFERENCE OF MEANS CONFIDENCE INTERVAL Y1
 
-----DIFFERENCE OF MEDIAN (LET)--------------------------------------
 
DIFFERENCE OF MEDIAN
 
Name:
    DIFFERENCE OF MEDIAN (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the medians for two
    response variables.
 
Description:
    The median is the value of the observation for which half the
    observations are larger and half are smaller.  If there are an
    even number of data points, the mean is taken of the two middle
    points.

    For the difference of medians, the median is computed for
    two samples and then their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF MEDIAN <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the medians is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF MEDIAN Y1 Y2
    LET A = DIFFERENCE OF MEDIAN Y1 Y2 SUBSET X > 1
 
Note:
    The difference of medians statistic is also supported for
    the following commands:

        DIFFERENCE OF MEDIANS PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF MEDIANS PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF MEDIANS PLOT Y1 Y2
        TABULATE DIFFERENCE OF MEDIANS Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF MEDIANS Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF MEDIANS Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    MEDIAN                          = Compute the median.
    DIFFERENCE OF MEAN              = Compute the difference of means.
    DIFFERENCE OF TRIMMED MEAN      = Compute the difference of
                                      trimmed means.
    DIFFERENCE OF MIDMEAN           = Compute the difference of
                                      midmeans.
    DIFFERENCE OF BIWEIGHT LOCATION = Compute the difference of
                                      biweight locations.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus
                                      two subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
 
Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF MEDIAN Y1 Y2
    TABULATE DIFFERENCE OF MEDIAN Y1 Y2 X
    .
    CHAR X
    LINE BLANK
    DIFFERENCE OF MEDIAN PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF MEDIAN PLOT Y1 Y2 X 
 
-----DIFFERENCE OF MIDMEAN (LET)--------------------------------------
 
DIFFERENCE OF MIDMEAN
 
Name:
    DIFFERENCE OF MIDMEAN (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the midmeans for two
    response variables.
 
Description:
    The midmean of a variable is the mean of the observations between
    the 25th and 75th percentiles.  It is sometimes used instead of
    the mean because it is more resistant to outliers.

    For the difference of midmeans, the midmean is computed for
    two samples and then their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF MIDMEAN <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the midmeans is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF MIDMEAN Y1 Y2
    LET A = DIFFERENCE OF MIDMEAN Y1 Y2 SUBSET X > 1
 
Note:
    The difference of midmeans statistic is also supported for
    the following commands:

        DIFFERENCE OF MIDMEANS PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF MIDMEANS PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF MIDMEANS PLOT Y1 Y2
        TABULATE DIFFERENCE OF MIDMEANS Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF MIDMEANS Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF MIDMEANS Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    MIDMEAN                         = Compute the midmean.
    DIFFERENCE OF MEAN              = Compute the difference of means.
    DIFFERENCE OF TRIMMED MEAN      = Compute the difference of
                                      trimmed means.
    DIFFERENCE OF MEDIAN            = Compute the difference of
                                      medians.
    DIFFERENCE OF BIWEIGHT LOCATION = Compute the difference of
                                      biweight locations.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus
                                      two subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
 
Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF MIDMEAN Y1 Y2
    TABULATE DIFFERENCE OF MIDMEAN Y1 Y2 X
    .
    CHAR X
    LINE BLANK
    DIFFERENCE OF MIDMEAN PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF MIDMEAN PLOT Y1 Y2 X 
 
-----DIFFERENCE OF MIDRANGE (LET)---------------------------------
 
DIFFERENCE OF MIDRANGE
 
Name:
    DIFFERENCE OF MIDRANGE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the midranges for two response
    variables.
 
Description:
    The midrange is the mean of the minimum and maximum points
    of a response variable.

    For the difference of midranges, the midrange is computed for
    each of two samples then their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF MIDRANGE <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the midranges is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF MIDRANGE Y1 Y2
    LET A = DIFFERENCE OF MIDRANGE Y1 Y2 SUBSET X > 1
 
Note:
    The difference of midranges statistic is
    also supported for the following commands:

        DIFFERENCE OF MIDRANGE PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF MIDRANGE PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF MIDRANGE PLOT Y1 Y2
        TABULATE DIFFERENCE OF MIDRANGE Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF MIDRANGE Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF MIDRANGE Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    MIDRANGE                        = Compute the midrange.
    RANGE                           = Compute the range.
    MINIMUM                         = Compute the minimum.
    MAXIMUM                         = Compute the maximum.
    QUANTILE                        = Compute a quantile.
    MEAN                            = Compute the mean.
    STANDARD DEVIATION              = Compute the standard deviation.
    DIFFERENCE OF RANGE             = Compute the difference of
                                      the ranges.
    DIFFERENCE OF MEAN              = Compute the difference of
                                      the means.
    DIFFERENCE OF SD                = Compute the difference of
                                      standard deviations.
    DIFFERENCE OF QUANTILE          = Compute the difference of
                                      a quantile.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus
                                      two subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
    TABULATE                        = Perform a tabulation for a
                                      specified statistic.
    CROSS TABULATE                  = Perform a cross tabulation
                                      for a specified statistic.
 
Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF MIDRANGE Y1 Y2
    TABULATE DIFFERENCE OF MIDRANGE Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF MIDRANGE
    CHAR X
    LINE BLANK
    DIFFERENCE OF MIDRANGE PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF MIDRANGE PLOT Y1 Y2 X 
 
-----DIFFERENCE OF MINIMUM (LET)--------------------------------------
 
DIFFERENCE OF MINIMUM
 
Name:
    DIFFERENCE OF MINIMUM (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the minimums for two response
    variables.
 
Description:
    The minimum is the smallest value of a response variable.

    For the difference of minimums, the minimum is computed for
    each of two samples then their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF MINIMUM <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the minimums is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF MINIMUM Y1 Y2
    LET A = DIFFERENCE OF MINIMUM Y1 Y2 SUBSET X > 1
 
Note:
    The difference of minimums statistic is
    also supported for the following commands:

        DIFFERENCE OF MINIMUM PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF MINIMUM PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF MINIMUM PLOT Y1 Y2
        TABULATE DIFFERENCE OF MINIMUM Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF MINIMUM Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF MINIMUM Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    MINIMUM                           = Compute the minimum.
    MIDMINIMUM                        = Compute the midminimum.
    MINIMUM                         = Compute the minimum.
    MAXIMUM                         = Compute the maximum.
    QUANTILE                        = Compute a quantile.
    STANDARD DEVIATION              = Compute the standard deviation.
    DIFFERENCE OF MINIMUM           = Compute the difference of
                                      the minimums.
    DIFFERENCE OF MAXIMUM           = Compute the difference of
                                      the maximums.
    DIFFERENCE OF SD                = Compute the difference of
                                      standard deviations.
    DIFFERENCE OF QUANTILE          = Compute the difference of
                                      a quantile.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus
                                      two subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
    TABULATE                        = Perform a tabulation for a
                                      specified statistic.
    CROSS TABULATE                  = Perform a cross tabulation
                                      for a specified statistic.
 
Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF MINIMUM Y1 Y2
    TABULATE DIFFERENCE OF MINIMUM Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF MINIMUM
    CHAR X
    LINE BLANK
    DIFFERENCE OF MINIMUM PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF MINIMUM PLOT Y1 Y2 X 
 
-----DIFFERENCE OF PERCENTAGE BEND MIDVARIANCE (LET)---------------
 
DIFFERENCE OF PERCENTAGE BEND MIDVARIANCE
 
Name:
    DIFFERENCE OF PERCENTAGE BEND MIDVARIANCE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the percentage bend midvariances
    for two response variables.
 
Description:
    The percentage bend midvariance estimator, discussed in
    Shoemaker and Hettmansperger and also by Wilcox, is both
    resistant and robust of efficiency.  The rationale and
    derivation for this estimate is given in these references.

    The percentage bend midvariance of a a variable X is computed
    as follows:

       1. Set m = [(1-beta)*n + 0.5].  This is the value of
          (1-beta)*m + 0.5 rounded down to the nearest integer.

       2. Let W(i) = |X(i) - M| for i = 1, ..., n where M is
          the median of X.

       3. Sort the W(i) in ascending order.

       4. what(beta) = W(m) (i. e., the mth order statistic).
           W(m) is the estimate of the (1-beta) quantile of W.


       5. Y(i) = (X(i) - M)/what(beta)

       6. a(i) = 1    if |Y(i)| < 1
               = 0    if |Y(i)| >= 1

       7. phi(x) = max[-1, min(1,x)]

       8. PBV = n*what(beta)**2*SUM[{phi(Y(i))}**2]/
                (SUM[a(i)])**2

    The value of beta is selected between 0 and 0.5.  Higher
    values of beta result in a higher breakdown point at the
    expense of lower efficiency.

    For the difference of percentage bend midvariances, the
    percentage bend midvariance is computed for each of two samples
   then their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF PERCENTAGE BEND MIDVARIANCE <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the percentage bend midvariances is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF PERCENTAGE BEND MIDVARIANCE Y1 Y2
    LET A = DIFFERENCE OF PERCENTAGE BEND MIDVARIANCE Y1 Y2 SUBSET X > 1
 
Note:
    To set the value of beta, enter the command

       LET BETA = <value>

    where <value> is greater than 0 and less than or equal to
    0.5.  The default value for beta is 0.1.

Note:
    The difference of percentage bend midvariances statistic is
    also supported for the following commands:

        DIFFERENCE OF PERCENTAGE BEND MIDVARIANCE PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF PERCENTAGE BEND MIDVARIANCE
              PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF PERCENTAGE BEND MIDVARIANCE PLOT Y1 Y2
        TABULATE DIFFERENCE OF PERCENTAGE BEND MIDVARIANCE Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF PERCENTAGE BEND MIDVARIANCE
              Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF PERCENTAGE BEND
              MIDVARIANCE Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    PERCENTAGE BEND MIDVARIANCE     = Compute the percentage bend
                                      midvariance.
    MAD                             = Compute the mad.
    AAD                             = Compute the aad.
    IQ RANGE                        = Compute the interquartile
                                      range.
    STANDARD DEVIATION              = Compute the standard deviation.
    DIFFERENCE OF MAD               = Compute the difference of
                                      the mad.
    DIFFERENCE OF AAD               = Compute the difference of
                                      the aad.
    DIFFERENCE OF SD                = Compute the difference of
                                      standard deviations.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus
                                      two subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
    TABULATE                        = Perform a tabulation for a
                                      specified statistic.
    CROSS TABULATE                  = Perform a cross tabulation
                                      for a specified statistic.
 
Reference:
    "Robust Estimates of and Tests for the One- and Two-Sample
    Scale Models", Shoemaker and Hettmansperger, Biometrika 69,
    1982, pp. 47-54.

    "Introduction to Robust Estimation and Hypothesis Testing",
    Rand Wilcox, Academic Press, 1997.

    "Data Analysis and Regression: A Second Course in Statistics",
    Mosteller and Tukey, Addison-Wesley, 1977, pp. 203-209.

Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF PERCENTAGE BEND MIDVARIANCE Y1 Y2
    TABULATE DIFFERENCE OF PERCENTAGE BEND MIDVARIANCE Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF PERCENTAGE BEND MIDVARIANCE
    CHAR X
    LINE BLANK
    DIFFERENCE OF PERCENTAGE BEND MIDVARIANCE PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF PERCENTAGE BEND MIDVARIANCE PLOT Y1 Y2 X 
 
-----DIFFERENCE OF PROPORTION CONFIDENCE LIMITS----------------------
 
DIFFERENCE OF PORPORTION CONFIDENCE LIMITS
 
Name:
    DIFFERENCE OF PROPORTION CONFIDENCE LIMITS
 
Type:
    Analysis Command
 
Purpose:
    Generates a confidence interval for the difference between
    two proportions.
 
Description:
    Given a set of N1 observations in a variable X1 and a set of
    N2 observations in a variable X2, we can compute the proportion
    of successes in each sample as p1 and p2.  We can then compute
    the difference of the proportions as P1 - P2.  In addition, the
    DIFFERENCE OF PROPORTION CONFIDENCE LIMITS command computes a
    confidence interval for the difference between the two
    proportions of successes.

    For most applications, you typically define success as a "1" and
    failure as a "0".  However, in Dataplot you can also specify the
    range of values that constitute success (all other values denote
    failure) by entering the command

        ANOP LIMITS <lower limit>  <upper limit>

    The default limits are 0.5 and 1.5 so that if your data contains
    0's and 1's this command can be omitted.

    Several methods have been proposed for the confidence limits for the
    difference between binomial proportions. The following methods are
    currently supported in Dataplot (other methods are available)

    WALD (or NORMAL APPROXIMATION)

    The Wald two-sided confidence interval is

        (phat1 - phat2) +/- z(alpha/2)*SQRT{phat1*(1-phat1)/n1 +
                            phat2*(1-phat2)/n2}

    where

        n1 is the number of observations in sample one
        n2 is the number of observations in sample two
        phat1 is the proportion of successess for sample one
        phat2 is the proportion of successess for sample two
        z(alpha) is the percent point function of the normal distribution

    This method is commonly used.  However, Agresti and Caffo
    pointed out that this method does not always perform well in
    the sense that the actual coverage probabilities can be less
    than (and often substantially less than) the nominal coverage
    probabilities.

    ADJUSTED WALD (or AGRESTI-CAFFO)

    Agresti and Caffo recommend the following confidence limit

        (ptilde1 - ptilde2) +/- z(alpha/2)*
                 SQRT{ptilde1*(1-ptilde1)/(n1+2) +
                      ptilde2*(1-ptilde2)/(n2+2)}

    where

        ptilde1 = (X1+1)/(n1+2)
        X1      =  the number of successess in sample one
        ptilde2 = (X2+1)/(n2+2)
        X2      =  the number of successess in sample two

    The justification and derivation of this interval is given in
    the Agresti Caffo paper.  This interval improves the coverage
    probabilities of the standard Wald interval.

    CARLIN AND LOUIS BAYESIAN

    Carlin and Louis propsed the following interval based on a
    Bayesian derivation

        (ptilde1 - ptilde2) +/- z(alpha/2)*
                 SQRT{ptilde1*(1-ptilde1)/(n1+3) +
                      ptilde2*(1-ptilde2)/(n2+3)}

    where ptilde1 and ptilde2 are defined as they are for the
    Agresti-Caffo interval.

    This interval also improves upon the Wald interval.  It is
    slightly less conservative with sometimes slightly narrower
    intervals than the Agresti-Caffo interval.  However, it
    can also at times have poorer coverage probabilities than
    the Agresti-Caffo interval.

    To specify the method to use, enter the command

        SET DIFFERENCE OF BINOMIAL METHOD <WALD/ADJUSTED WALD/BAYESIAN>

    The default is the adjusted Wald (Agresti-Caffo) interval.

    Dataplot computes this inverval for a number of different
    probability levels.
 
Syntax:
    DIFFERENCE OF PROPORTION CONFIDENCE LIMITS   <y1>  <y2>
                          <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    ANOP LIMITS 0.50 1.5
    DIFFERENCE OF PROPORTION CONFIDENCE LIMITS Y1 Y2
 
    SET DIFFERENCE OF BINOMIAL METHOD ADJUSTED WALD
    DIFFERENCE OF PROPORTION CONFIDENCE LIMITS Y1 Y2 SUBSET TAG > 2
 
Note:
    A table of confidence intervals is printed for alpha levels of
    50.0, 75.0, 90.0, 95.0, 99.0, 99.9, 99.99, and 99.999.  The sample
    size, sample number of successes, and sample proportion of
    successes are also printed.

Note:
    The following statistics are also supported

       LET ALPHA = <value>
       LET A = DIFF OF BINOMIAL PROPORTIONS LOWER CONFIDENCE LIMIT Y1 Y2
       LET A = DIFF OF BINOMIAL PROPORTIONS UPPER CONFIDENCE LIMIT Y1 Y2

    In addition to the above LET commands, built-in statistics are
    supported for about 20+ different commands (enter HELP STATISTICS
    for details).

Default:
    The adjusted Wald (Agresti-Caffo) interval is the default
 
Synonyms:
    None
 
Related Commands:
    ANOP LIMITS                  = Specify success region for proportions.
    PROPORTION CONFIDENCE LIMITS = Compute the proportions confidence
                                   interval.
    ANOP PLOT                    = Generate an analysis of proportions
                                   plot.
    CONFIDENCE LIMITS            = Generate the confidence limits for
                                   the mean.
 
References:
    Snedecor and Cochran (1989), "Statistical Methods", Eigth Edition,
    Iowa State University Press, pp. 125-128.
 
    Agresti and Caffo (2000), "Simple and Effective Confidence Intervals
    for Proportions and Differences of Proportions Result From Adding
    Two Successes and Two Failures", The American Statistician,
    Vol. 54, No. 4, pp. 280-288.

    Carlin and Louis (1996), "Bayes and Empirical Bayes Methods for
    Data Analysis", Chapman and Hall.

Applications:
    Categorical Data Analysis
 
Implementation Date:
    1999/05
    2017/11: Added the adjusted Wald (Agresti-Caffo) and Bayesian intervals
    2017/11: Made the adjusted Wald (Agresti-Caffo) interval the default
 
Program:
    let n1 = 40
    let nsuc1 = 8
    let y1 = 0 for i = 1 1 n1
    let y1 = 1 for i = 1 1 nsuc1
    .
    let n2 = 30
    let nsuc2 = 11
    let y2 = 0 for i = 1 1 n2
    let y2 = 1 for i = 1 1 nsuc2
    .
    .          Now do proportions confidence interval
    .
    set write decimals 5
    let alpha = 0.95
    .
    set difference of binomial method wald
    difference of proportion confidence interval y1 y2
    set difference of binomial method adjusted wald
    difference of proportion confidence interval y1 y2
    set difference of binomial method bayesian
    difference of proportion confidence interval y1 y2

-----DIFFERENCE OF PROPORTION HYPOTHESIS TEST (LET)-----------------
 
DIFFERENCE OF PROPORTION HYPOTHESIS TEST
 
Name:
    DIFFERENCE OF PROPORTION HYPOTHESIS TEST (LET)
 
Type:
    LET Subcommand
 
Purpose:
    Return the p-value for a large sample hypothesis test for the
    equality of two binomial proportions.
 
Description:
    Given a set of N1 observations in a variable X1 and a set of
    N2 observations in a variable X2, we can compute a normal
    approximation test that the two proportions are equal (or
    alternatively, that the difference of the two proportions is
    equal to 0).  In the following, let p1 and p2 be the population
    proportion of successes for samples one and two, respectively.

    The hypothesis test that the two binomial proportions are
    equal is

        H0: p1 = p2
        Ha: p1 <> p2
        Test Statistic: Z = (p1hat - p2hat)/
                        SQRT(phat*(1-phat)*((1/n1) + (1/n2)))

                        where phat is the proportion of successes
                        for the combined sample and

                        phat = (n1*p1hat + n2*phat2)/(n1 + n2) 
                             = (x1 + x2)/(n1 + n2)
        Significance Level: alpha
        Critical Region: For a two-tailed test

                            Z > NORPPF(1 - alpha/2)
                            Z < NORPPF(alpha/2)

                         For a lower tailed test

                            Z < NORPPF(alpha)

                         For an upper tailed test

                            Z > NORPPF(1 - alpha)
        Conclusion: Reject the null hypothesis if Z is in the
                    critical region

    For a lower tailed test, the p-value is equal to NORCDF(Z).  For
    an upper tailed test, the p-value is equal to 1 - NORCDF(Z).  For a
    two-tailed test, the p-value is equal to 2*(1 - NORCDF(Z)).

    Alternatively, you can request that the lower and upper
    confidence limits for p1 - p2 be returned instead of the
    p-value for the hypothesis test.

Syntax 1:
    LET PVAL = DIFFERENCE OF PROPORTION HYPOTHESIS TEST
               <p1>  <n1>  <p2>  <n2>  <alpha>
               <SUBSET/EXCEPT/FOR qualification>
    where <p1> is constant, parameter, or variable that contains the
              proportion of successes for the first sample;
          <n1> is constant, parameter, or variable that contains the
              number of trials for the first sample;
          <p2> is constant, parameter, or variable that contains the
              proportion of successes for the second sample;
          <n2> is constant, parameter, or variable that contains the
              number of trials for the second sample;
          <alpha> is constant or parameter that contains the significance
              level;
          <pval> is the returned p-value;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for the two-tailed case.

    The <p1>, <n1>, <p2>, and <n2> arguments can be either parameters
    or variables.  If they are variables, then the variables must have
    the same number of elements.  The <alpha> argument is always assumed
    to be either a constant or a parameter.

    If <p1>, <n1>, <p2> and <n2> are all parameters, then <pval>
    will be a parameter.  Otherwise, it will be a variable.

Syntax 2:
    LET PVAL = DIFFERENCE OF PROPORTION LOWER TAIL HYPOTHESIS TEST
               <p1>  <n1>  <p2>  <n2>  <alpha>
               <SUBSET/EXCEPT/FOR qualification>
    where <p1> is constant, parameter, or variable that contains the
              proportion of successes for the first sample;
          <n1> is constant, parameter, or variable that contains the
              number of trials for the first sample;
          <p2> is constant, parameter, or variable that contains the
              proportion of successes for the second sample;
          <n2> is constant, parameter, or variable that contains the
              number of trials for the second sample;
          <alpha> is constant or parameter that contains the significance
              level;
          <pval> is the returned p-value.
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for the lower tailed case.

    The <p1>, <n1>, <p2>, and <n2> arguments can be either parameters
    or variables.  If they are variables, then the variables must have
    the same number of elements.  The <alpha> argument is always assumed
    to be either a constant or a parameter.

    If <p1>, <n1>, <p2> and <n2> are all parameters, then <pval>
    will be a parameter.  Otherwise, it will be a variable.

Syntax 3:
    LET PVAL = DIFFERENCE OF PROPORTION UPPER TAIL HYPOTHESIS TEST
               <p1>  <n1>  <p2>  <n2>  <alpha>
               <SUBSET/EXCEPT/FOR qualification>
    where <p1> is constant, parameter, or variable that contains the
              proportion of successes for the first sample;
          <n1> is constant, parameter, or variable that contains the
              number of trials for the first sample;
          <p2> is constant, parameter, or variable that contains the
              proportion of successes for the second sample;
          <n2> is constant, parameter, or variable that contains the
              number of trials for the second sample;
          <alpha> is constant or parameter that contains the significance
              level;
          <pval> is the returned p-value.
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for the upper tailed case.

    The <p1>, <n1>, <p2>, and <n2> arguments can be either parameters
    or variables.  If they are variables, then the variables must have
    the same number of elements.  The <alpha> argument is always assumed
    to be either a constant or a parameter.

    If <p1>, <n1>, <p2> and <n2> are all parameters, then <pval>
    will be a parameter.  Otherwise, it will be a variable.

Syntax 4:
    LET <pdiff> <al> <au> = DIFFERENCE OF PROPORTION CONFIDENCE LIMITS
                            <p1>  <n1>  <p2>  <n2>  <alpha>
                            <SUBSET/EXCEPT/FOR qualification>
    where <p1> is a parameter that specifies the proportion of
               successes for sample 1;
          <n1> is a parameter that specifies the sample size for
               sample 1;
          <p2> is a parameter that specifies the proportion of
               successes for sample 2;
          <n2> is a parameter that specifies the sample size for
               sample 2;
          <alpha> is a parameter that specifies the desired
               significance level;
          <pdiff> is the returned difference of binomial proportions;
          <al> is the returned lower confidence limit;
          <au> is the returned upper confidence limit.
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    The <p1>, <n1>, <p2>, and <n2> arguments can be either parameters
    or variables.  If they are variables, then the variables must have
    the same number of elements.  The <alpha> argument is always assumed
    to be either a constant or a parameter.

    If <p1>, <n1>, <p2> and <n2> are all parameters, then <pdiff>,
    <al> and <au> will be parameters.  Otherwise, they will be
    variables.

Examples:
    LET PVAL = DIFFERENCE OF PROPORTION HYPOTHESIS TEST ...
               P1 N1 P2 N2 ALPHA
    LET PDIFF AL AU = DIFFERENCE OF PROPORTION CONF LIMITS ...
                      P1 N1 P2 N2 ALPHA
 
Note:
    The BINOMIAL PROPORTION TEST generates this test with full
    output.

Note:
    The following command is also available:

       LET DIFF = DIFFERENCE OF BINOMIAL PROPORTIONS Y1 Y2

    This command is a Statistics Let Subcommand rather than a Math
    LET Subcommand.  The distinctions are:

        1) The "Statistics" version of the command returns a single
           parameter value while the "Math" version of the command
           returns two variables.

        2) The "Statistics" version of the command can be used with
           a number of other commands (see the Note above) while the
           "Math" version of the command cannot.

           For example, the "Statistics" version of the command is
           most typically used with the FLUCTUATION PLOT, CROSS TABULATE,
           and STATISTIC PLOT commands.

        3) The "Statistics" version of the command expects a single
           variable (containing a sequence of 1's and 0's).  The
           "Math" version expects summary data (i.e., P and N).  The
           P and N can be either constants, parameters, or variables
           (or even a mix of these).

    Which form of the command to use is determined by the context of
    what you are trying to do.

    For details on the "Statistics" version of the command, enter

        HELP DIFFERENCE OF BINOMIAL PROPORTIONS

    In addition, the command

        BINOMIAL PROPORTION TEST

    performs a difference of binomial proportions test.  This
    command generates a more detailed output for the test.  The
    LET version of the test is most useful when computing many
    values of the test statistic.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BINOMIAL PROPORTION TEST        = Perform a difference of proportion
                                      hypothesis test.
    BINOMIAL PRODUCT CONF LIMITS    = Compute confidence limits for
                                      the product of two binomial
                                      proportions.
    AGRESTI-COULL CONF LIMITS       = Compute the Agresti-Coull confidence
                                      limits for binomial proportions.
    EXACT BINOMIAL CONF LIMITS      = Compute the exact binomial confidence
                                      limits for binomial proportions.
    BINOMIAL PROPORTION             = Compute the binomial proportion
                                      statistic.
    AGRESTI-COULL                   = Compute Agresti-Coull confidence
                                      limits statistic for binomial
                                      proportions.
    CROSS TABULATE (LET)            = Perform a cross tabulation for a
                                      specified statistic.
 
 
References:
    NIST/SEMATECH e-Handbook of Statistical Methods,
    http://www.itl.nist.gov/div898/handbook/prc/section3/prc33.htm.
 
    Ryan (2008), "Modern Engineering Statistics", Wiley, pp. 124-126.

Applications:
    Categorical Data Analysis
 
Implementation Date:
    2008/8
 
Program:
    LET X1 = 32
    LET N1 = 38
    LET P1 = X1/N1
    LET X2 = 39
    LET N2 = 44
    LET P2 = X2/N2
    LET ALPHA = 0.05
    LET PVAL = DIFFERENCE OF PROPORTION HYPOTHESIS TEST ...
               P1 N1 P2 N2 ALPHA
    LET PDIFF AL AU = DIFFERENCE OF PROPORTION CONF LIMIT ...
                      P1 N1 P2 N2 ALPHA

-----DIFFERENCE OF QUANTILE (LET)-----------------------------------
 
DIFFERENCE OF QUANTILE
 
Name:
    DIFFERENCE OF QUANTILE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the QUANTILEs for two response
    variables.
 
Description:
    The qth quantile of a data set is defined as that value
    where a q fraction of the data is below that value and (1-q)
    fraction of the data is above that value.  For example, the
    0.5 quantile is the median.
 
    Dataplot supports two methods for computing the quantile.

    The first method is based on the order statistic.  The
    formula is:

       X(q) = (1 - r)*X(NI1) + r*X(NI2)

   where

       X are the observations sorted in ascending order
       NI1 = INT(Q*(N+1))
       NI2 = NI1 + 1
       r = Q*(N+1) - INT(Q*(N+1))

   An alternative method is called the Herrell-Davis
   estimate.  This method attempts to provide a lower standard
   error for X(q) by utilizing all the order statistics rather
   than a single (or a weighted average of two) order statistic.
   Note that there are caes where the Herrell-Davis has a
   substantially smaller standard error than the order statistic
   method.  However, there are also cases where the reverse is
   true.

   To compute the Herrell-Davis estimate, do the following:

      1. Sort the X in ascending order.

      2. A = (N+1)*q

      3. B = (N+1)*(1-q)

      4. W(i) = BETCDF(i/n, A, B) - BETCDF((i-1)/n, A, B)

         where BETCDF is the beta cumulative distribution
         function with shape parameters A and B.

      5. X(q) = SUM[i=1 to n][W(i)*X(i)]

    For the difference of QUANTILEs, the QUANTILE is computed for
    each of two samples then their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF QUANTILE <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the QUANTILEs is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF QUANTILE Y1 Y2
    LET A = DIFFERENCE OF QUANTILE Y1 Y2 SUBSET X > 1
 
Note:
    The following command is used to determine which method
    is used to compute the quantile:

         SET QUANTILE METHOD <ORDER/HERRELL-DAVIS>

Note:
    The specific quantile to compute is specified by entering
    the following command:

       LET XQ = <value>

    where <value> is a number in the interval (0,1) that specifies
    the desired quantile.

Note:
    The difference of QUANTILEs statistic is
    also supported for the following commands:

        DIFFERENCE OF QUANTILE PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF QUANTILE PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF QUANTILE PLOT Y1 Y2
        TABULATE DIFFERENCE OF QUANTILE Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF QUANTILE Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF QUANTILE Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    QUANTILE                           = Compute the QUANTILE.
    MINIMUM                         = Compute the minimum.
    MAXIMUM                         = Compute the maximum.
    DIFFERENCE OF MINIMUM           = Compute the difference of
                                      the minimums.
    DIFFERENCE OF MAXIMUM           = Compute the difference of
                                      the maximums.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus
                                      two subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
    TABULATE                        = Perform a tabulation for a
                                      specified statistic.
    CROSS TABULATE                  = Perform a cross tabulation
                                      for a specified statistic.
 
Reference:
    "Introduction to Robust Estimation and Hypothesis Testing",
    Rand Wilcox, Academic Press, 1997.

    "A New Distribution-Free Quantile Estimator", Frank Herrell and
    C. E. Davis, Biometrika (1982), 69(3), 635-640.

Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET XQ = 0.9
    .
    LET A = DIFFERENCE OF QUANTILE Y1 Y2
    TABULATE DIFFERENCE OF QUANTILE Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF (0.9) QUANTILE
    CHAR X
    LINE BLANK
    DIFFERENCE OF QUANTILE PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF QUANTILE PLOT Y1 Y2 X 
 
-----DIFFERENCE OF QN (LET)-------------------------------
 
DIFFERENCE OF QN
 
Name:
    DIFFERENCE OF QN (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference of the Qn scale estimates for two
    response variables.
 
Description:
    The Qn scale estimate is motivated by the Hodges-Lehmann
    estimate of location:

        HL = MEDIAN{(x(i) + x(j))/2; i < j}

    An analogous scale estimate can be obtained by replacing
    pairwise averages with pairwised distances:
 
        MEDIAN{|x(i) - x(j)|; i < j}

    This estimate has high efficiency for normal data (86%),
    but a breakdown point of only 29%.  Rousseeuw and Croux
    proposed the following variation of this statistic:

        Qn = d{|x(i) - x(j)|; i < j}(k)

    where d is a constant factor and k = (h choose 2) which is
    approximately (n choose 2)/4.   The value of h is [n/2]+1
    (i.e., roughly half the number of obserations).  In other words,
    we take kth order statistic of the (n choose 2) interpoint
    distances.  The value of d is choosen to make Qn a
    consistent estimator of scale.  We use the value 2.2219
    since this is the value that makes Qn a consistent estimator
    for normal data.

    Enter HELP QN SCALE for a more detailed discussion of the
    Qn scale estimate.
 
    For the difference of Qn scale estimates, the Qn scale estimate
    is computed for each of the two samples then their difference
    is taken.
 
Syntax:
    LET <par> = DIFFERENCE OF QN <y>
                                 <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the computed difference of
              Qn scale estimates is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF QN Y1
    LET A = DIFFERENCE OF QN Y1 SUBSET TAG > 2
 
Note:
    Dataplot uses code provided by Rousseeuw and Croux to compute
    the Qn estimate.  This algorithm uses an efficient computational
    method for computing Qn.

Note:
    The Rousseeuw and Croux article also proposes the Sn scale
    estimate.  The article discusses the properties of both
    estimators in detail.

Note:
    In addition, the Qn statistic is supported for the following
    plots and commands

       DIFFERENCE OF QN PLOT Y X
       CROSS TABULATE DIFFERENCE OF QN PLOT Y X1 X2
       BOOTSTRAP DIFFERENCE OF QN PLOT Y
       JACKNIFE DIFFERENCE OF QN PLOT Y

       TABULATE DIFFERENCE OF QN Y X
       CROSS TABULATE SN Y X1 X2
       LET Z = CROSS TABULATE DIFFERENCE OF QN Y X1 X2

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    QN SCALE                   = Compute the Qn scale estimate of a
                                 variable.
    SN SCALE                   = Compute the Sn scale estimate of a
                                 variable.
    DIFFERENCE OF MAD          = Compute the difference of the median
                                 absolute deviations between two
                                 variables.
    DIFFERENCE OF IQ RANGE     = Compute the difference of iq ranges
                                 between two variables.
    DIFFERENCE OF SD           = Compute the difference of standard
                                 deviations between two variables.
    DIFFERENCE OF SN           = Compute the difference of the Sn
                                 scale estimates between two variables.
    STATISTIC PLOT             = Generate a statistic versus subset
                                 plot.
    CROSS TABULATE PLOT        = Generate a statistic versus subset
                                 plot (two subset variables).
    BOOTSTRAP PLOT             = Generate a bootstrap plot for a
                                 statistic.
 
Reference:
    "Alternatives to the Median Absolute Deviation",
    Peter J. Rousseuw and Christophe Croux, Journal of the American
    Statistical Association, December, 1993, Vol. 88, No. 424,
    pp. 1273-1283.

    "Data Analysis and Regression: A Second Course in Statistics",
    Mosteller and Tukey, Addison-Wesley, 1977, pp. 203-209.

Applications:
    Data Analysis
 
Implementation Date:
    2003/4
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF QN Y1 Y2
    TABULATE DIFFERENCE OF QN Y1 Y2 X
    .
    MAJOR XTIC MARK NUMBER 3
    MINOR XTIC MARK NUMBER 0
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF QN
    CHARACTER X
    LINE BLANK
    DIFFERENCE OF QN PLOT Y1 Y2 X
    CHARACTER X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF QN PLOT Y1 Y2 X
 
-----DIFFERENCE OF RANGE (LET)--------------------------------------
 
DIFFERENCE OF RANGE
 
Name:
    DIFFERENCE OF RANGE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the ranges for two response
    variables.
 
Description:
    The range is the difference between the minimum and
    maximum value of a response variable.

    For the difference of ranges, the range is computed for
    each of two samples then their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF RANGE <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the ranges is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF RANGE Y1 Y2
    LET A = DIFFERENCE OF RANGE Y1 Y2 SUBSET X > 1
 
Note:
    The difference of ranges statistic is
    also supported for the following commands:

        DIFFERENCE OF RANGE PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF RANGE PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF RANGE PLOT Y1 Y2
        TABULATE DIFFERENCE OF RANGE Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF RANGE Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF RANGE Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    RANGE                           = Compute the range.
    MIDRANGE                        = Compute the midrange.
    MINIMUM                         = Compute the minimum.
    MAXIMUM                         = Compute the maximum.
    QUANTILE                        = Compute a quantile.
    STANDARD DEVIATION              = Compute the standard deviation.
    DIFFERENCE OF MINIMUM           = Compute the difference of
                                      the minimums.
    DIFFERENCE OF MAXIMUM           = Compute the difference of
                                      the maximums.
    DIFFERENCE OF SD                = Compute the difference of
                                      standard deviations.
    DIFFERENCE OF QUANTILE          = Compute the difference of
                                      a quantile.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus
                                      two subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
    TABULATE                        = Perform a tabulation for a
                                      specified statistic.
    CROSS TABULATE                  = Perform a cross tabulation
                                      for a specified statistic.
 
Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF RANGE Y1 Y2
    TABULATE DIFFERENCE OF RANGE Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF RANGE
    CHAR X
    LINE BLANK
    DIFFERENCE OF RANGE PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF RANGE PLOT Y1 Y2 X 
 
-----DIFFERENCE OF RELATIVE SD (LET)---------------------------------
 
DIFFERENCE OF RELATIVE SD
 
Name:
    DIFFERENCE OF RELATIVE SD (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the relative standard deviations
    for two response variables.
 
Description:
    The relative standard deviation is:

         relsd = 100*(standard deviation/abs(mean))

    Some analysts prefer to call this the percent relative standard
    deviation and the value obtained without multiplying by 100 the
    relative standard deviation.  If this is your preference, simply
    divide the obtained value by 100 with the LET command.  This
    differs from the coefficient of variation in that the absolute
    value of the mean is taken and the value is expressed as a
    percentage.

    For the difference of relative standard deviations, the relative
    standard deviation is computed for each of two samples then
    their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF RELATIVE SD <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the relative standard deviations is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF RELATIVE SD Y1 Y2
    LET A = DIFFERENCE OF RELATIVE SD Y1 Y2 SUBSET X > 1
 
Note:
    The difference of relative sds statistic is
    also supported for the following commands:

        DIFFERENCE OF RELATIVE SD PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF RELATIVE SD PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF RELATIVE SD PLOT Y1 Y2
        TABULATE DIFFERENCE OF RELATIVE SD Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF RELATIVE SD Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF RELATIVE SD Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    DIFFERENCE OF RELATIVE STANDARD DEVIATION is a synonym for
    DIFFERENCE OF RELATIVE SD.
 
Related Commands:
    RELATIVE SD                     = Compute the relative sd.
    RELATIVE VARIANCE               = Compute the relative variance.
    COEFFICIENT OF VARIATION        = Compute the coefficient of
                                      variation.
    STANDARD DEVIATION              = Compute the standard deviation.
    DIFFERENCE OF RELATIVE VARIANCE = Compute the difference of
                                      the relative variances.
    DIFFERENCE OF COEF OF VARI      = Compute the difference of
                                      the coefficient of variation.
    DIFFERENCE OF SD                = Compute the difference of
                                      standard deviations.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus
                                      two subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
    TABULATE                        = Perform a tabulation for a
                                      specified statistic.
    CROSS TABULATE                  = Perform a cross tabulation
                                      for a specified statistic.
 
Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF RELATIVE SD Y1 Y2
    TABULATE DIFFERENCE OF RELATIVE SD Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF RELATIVE SD
    CHAR X
    LINE BLANK
    DIFFERENCE OF RELATIVE SD PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF RELATIVE SD PLOT Y1 Y2 X 

-----DIFFERENCE OF RELATIVE VARIANCE (LET)---------------------------
 
DIFFERENCE OF RELATIVE VARIANCE
 
Name:
    DIFFERENCE OF RELATIVE VARIANCE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the relative variances
    for two response variables.
 
Description:
    The relative variance is:

         relvar = 100*(s^2/abs(xbar))

    with s^2 and xbar denoting the variance and the mean,
    respectively.

    Some analysts prefer to call this the percent relative variance
    and the value obtained without multiplying by 100 the
    relative variance.  If this is your preference, simply
    divide the obtained value by 100 with the LET command.

    For the difference of relative variances, the relative
    variance is computed for each of two samples then
    their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF RELATIVE VARIANCE <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the relative variances is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF RELATIVE VARIANCE Y1 Y2
    LET A = DIFFERENCE OF RELATIVE VARIANCE Y1 Y2 SUBSET X > 1
 
Note:
    The difference of relative variances statistic is
    also supported for the following commands:

        DIFFERENCE OF RELATIVE VARIANCE PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF RELATIVE VARIANCE PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF RELATIVE VARIANCE PLOT Y1 Y2
        TABULATE DIFFERENCE OF RELATIVE VARIANCE Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF RELATIVE VARIANCE Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF RELATIVE VARIANCE
                Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    RELATIVE VARIANCE               = Compute the relative variance.
    RELATIVE SD                     = Compute the relative sd.
    COEFFICIENT OF VARIATION        = Compute the coefficient of
                                      variation.
    STANDARD DEVIATION              = Compute the variance.
    DIFFERENCE OF RELATIVE SD       = Compute the difference of the
                                      relative standard deviations.
    DIFFERENCE OF COEF OF VARI      = Compute the difference of the
                                      coefficient of variation.
    DIFFERENCE OF VARIANCE          = Compute the difference of
                                      variances.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus two
                                      subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
    TABULATE                        = Perform a tabulation for a
                                      specified statistic.
    CROSS TABULATE                  = Perform a cross tabulation for'
                                      a specified statistic.
 
Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF RELATIVE VARIANCE Y1 Y2
    TABULATE DIFFERENCE OF RELATIVE VARIANCE Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF RELATIVE VARIANCE
    CHAR X
    LINE BLANK
    DIFFERENCE OF RELATIVE VARIANCE PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF RELATIVE VARIANCE PLOT Y1 Y2 X 
 
-----DIFFERENCE OF SD (LET)--------------------------------------

DIFFERENCE OF SD
 
Name:
    DIFFERENCE OF SD (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the standard deviations for
    two response variables.
 
Description:
    The standard deviation is a common measure of the spread of a
    distribution or variable.  The formula is:

         SD = SQRT(SUM(Xi - Xmean)**2/(N-1))

    For the difference of standard deviations, the standard
    deviation is computed for each of two samples then their
    difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF SD <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the standard deviations is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF SD Y1 Y2
    LET A = DIFFERENCE OF SD Y1 Y2 SUBSET X > 1
 
Note:
    The difference of standard deviations statistic is
    also supported for the following commands:

        DIFFERENCE OF SD PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF SD PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF SD PLOT Y1 Y2
        TABULATE DIFFERENCE OF SD Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF SD Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF SD Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    STANDARD DEVIATION              = Compute the standard deviation.
    MEAN                            = Compute the meand.
    DIFFERENCE OF MEAN              = Compute the difference of
                                      the means.
    DIFFERENCE OF MAD               = Compute the difference of
                                      the mad.
    DIFFERENCE OF AAD               = Compute the difference of
                                      the aad.
    DIFFERENCE OF IQ RANGE          = Compute the difference of
                                      the interquartile range.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus
                                      two subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
    TABULATE                        = Perform a tabulation for a
                                      specified statistic.
    CROSS TABULATE                  = Perform a cross tabulation
                                      for a specified statistic.
 
Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF SD Y1 Y2
    TABULATE DIFFERENCE OF SD Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF SD
    CHAR X
    LINE BLANK
    DIFFERENCE OF SD PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF SD PLOT Y1 Y2 X 
 
-----DIFFERENCE OF SD OF THE MEAN (LET)------------------------------
 
DIFFERENCE OF SD OF THE MEAN
 
Name:
    DIFFERENCE OF SD OF THE MEAN (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the standard deviation of the
    means for two response variables.
 
Description:
    The standard deviation of the mean is:

        sd of mean = s/SQRT(N)

    with s and n denoting the standard deviation and the number of
    observations, respectively.

    For the difference of standard deviation of the means, the
    standard deviation of the mean is computed for each of two
    samples then their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF SD OF THE MEAN <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the sd of the means is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF SD OF THE MEAN Y1 Y2
    LET A = DIFFERENCE OF SD OF THE MEAN Y1 Y2 SUBSET X > 1
 
Note:
    The difference of standard deviation of the means statistic is
    also supported for the following commands:

        DIFFERENCE OF SD OF THE MEAN PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF SD OF THE MEAN PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF SD OF THE MEAN PLOT Y1 Y2
        TABULATE DIFFERENCE OF SD OF THE MEAN Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF SD OF THE MEAN Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF SD OF THE MEAN
                Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    DIFFERENCE OF STANDARD DEVIATION OF THE MEAN is a synonym for
    DIFFERENCE OF SD OF THE MEAN.
 
Related Commands:
    SD OF THE MEAN                  = Compute the sd of the mean.
    STANDARD DEVIATION              = Compute the standard deviation.
    MEAN                            = Compute the mean.
    DIFFERENCE OF MEAN              = Compute the difference of
                                      the means.
    DIFFERENCE OF SD                = Compute the difference of
                                      standard deviations.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus
                                      two subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
    TABULATE                        = Perform a tabulation for a
                                      specified statistic.
    CROSS TABULATE                  = Perform a cross tabulation
                                      for a specified statistic.
 
Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF SD OF THE MEAN Y1 Y2
    TABULATE DIFFERENCE OF SD OF THE MEAN Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF SD OF THE MEAN
    CHAR X
    LINE BLANK
    DIFFERENCE OF SD OF THE MEAN PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF SD OF THE MEAN PLOT Y1 Y2 X 
 
-----DIFFERENCE OF SKEWNESS (LET)---------------------------------
 
DIFFERENCE OF SKEWNESS
 
Name:
    DIFFERENCE OF SKEWNESS (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the skewnesss for two response
    variables.
 
Description:
    The skewness measures the lack of symmetry in a response
    variable.  The formula is:

       skew = (SUM(Xi-Xmean)**3/(N-1))/s**3

    where s is the standard deviation and N is the number of
    observations.

    For the differeence of skewnesss, the skewness is computed for
    each of two samples then their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF SKEWNESS <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the skewnesss is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF SKEWNESS Y1 Y2
    LET A = DIFFERENCE OF SKEWNESS Y1 Y2 SUBSET X > 1
 
Note:
    The difference of skewnesss statistic is
    also supported for the following commands:

        DIFFERENCE OF SKEWNESS PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF SKEWNESS PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF SKEWNESS PLOT Y1 Y2
        TABULATE DIFFERENCE OF SKEWNESS Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF SKEWNESS Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF SKEWNESS Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SKEWNESS                        = Compute the skewness.
    MEAN                            = Compute the mean.
    STANDARD DEVIATION              = Compute the standard deviation.
    KURTOSIS                        = Compute the kurtosis.
    DIFFERENCE OF MEAN              = Compute the difference of
                                      means.
    DIFFERENCE OF SD                = Compute the difference of
                                      standard deviations.
    DIFFERENCE OF KURTOSIS          = Compute the difference of
                                      kurtosis.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus
                                      two subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
    TABULATE                        = Perform a tabulation for a
                                      specified statistic.
    CROSS TABULATE                  = Perform a cross tabulation
                                      for a specified statistic.
 
Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF SKEWNESS Y1 Y2
    TABULATE DIFFERENCE OF SKEWNESS Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF SKEWNESS
    CHAR X
    LINE BLANK
    DIFFERENCE OF SKEWNESS PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF SKEWNESS PLOT Y1 Y2 X 
 
-----DIFFERENCE OF SN (LET)-------------------------------
 
DIFFERENCE OF SN
 
Name:
    DIFFERENCE OF SN (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference the Sn scale estimates for two
    response variables.
 
Description:
    The Sn scale estimate is a robust estimate of scale that is
    defined as:

        Sn = c*MEDIAN(i){MEDIAN(j)|x(i) - x(j)|}

    That is, for each i we compute the median of
    {|x(i) - x(j)|; j = 1, ..., n}.  The median of these n
    numbers is then the estimate of Sn.  The constant c is
    determined to make Sn a consistent estimator.  The value
    used is 1.1926 (this is the value needed to make Sn a
    consistent estimator for normal data).

    The Sn statistic measures typical distances between values
    (in contrast to the median absolute deviation and the standard
    deviation which measure the distance from a central location).

    Enter HELP SN SCALE for a more detailed discussion of the
    Sn scale estimate.
 
    For the difference of Sn scale estimates, the Sn scale estimate
    is computed for each of the two samples then their difference
    is taken.

Syntax:
    LET <par> = DIFFERENCE OF SN <y> 
                                 <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the computed difference of
               Sn scale statistics is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF SN Y1 Y2
    LET A = DIFFERENCE OF SN Y1 Y2 SUBSET TAG > 2
 
Note:
    Dataplot uses code provided by Rousseeuw and Croux to compute
    the Sn estimate.  This algorithm uses an efficient computational
    method for computing Sn.

Note:
    The Rousseeuw and Croux article (see the Reference section
    below) also proposes the Qn scale estimate.  The article
    discusses the properties of both estimators in detail.

Note:
    In addition, the Sn statistic is supported for the following
    plots and commands

       DIFFERENCE OF SN PLOT Y1 Y2 X
       CROSS TABULATE DIFFERENCE OF SN PLOT Y1 Y2 X1 X2
       BOOTSTRAP DIFFERENCE OF SN PLOT Y1 Y2
       JACKNIFE DIFFERENCE OF SN PLOT Y1 Y2

       TABULATE DIFFERENCE OF SN Y X
       CROSS TABULATE SN Y X1 X2
       LET Z = CROSS TABULATE DIFFERENCE OF SN Y X1 X2

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SN SCALE                   = Compute the Sn scale estimate of a
                                 variable.
    QN SCALE                   = Compute the Qn scale estimate of a
                                 variable.
    DIFFERENCE OF MAD          = Compute the difference of the median
                                 absolute deviations between two
                                 variables.
    DIFFERENCE OF IQ RANGE     = Compute the difference of iq ranges
                                 between two variables.
    DIFFERENCE OF SD           = Compute the difference of standard
                                 deviations between two variables.
    DIFFERENCE OF QN           = Compute the difference of the Qn
                                 scale estimates between two variables.
    STATISTIC PLOT             = Generate a statistic versus subset
                                 plot.
    CROSS TABULATE PLOT        = Generate a statistic versus subset
                                 plot (two subset variables).
    BOOTSTRAP PLOT             = Generate a bootstrap plot for a
                                 statistic.
 
Reference:
    "Alternatives to the Median Absolute Deviation",
    Peter J. Rousseuw and Christophe Croux, Journal of the American
    Statistical Association, December, 1993, Vol. 88, No. 424,
    pp. 1273-1283.

    "Data Analysis and Regression: A Second Course in Statistics",
    Mosteller and Tukey, Addison-Wesley, 1977, pp. 203-209.

Applications:
    Data Analysis
 
Implementation Date:
    2003/5
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF SN Y1 Y2
    TABULATE DIFFERENCE OF SN Y1 Y2 X
    .
    MAJOR XTIC MARK NUMBER 3
    MINOR XTIC MARK NUMBER 0
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF SN
    CHARACTER X
    LINE BLANK
    DIFFERENCE OF SN PLOT Y1 Y2 X
    CHARACTER X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF SN PLOT Y1 Y2 X
 
-----DIFFERENCE OF SUM (LET)--------------------------------------
 
DIFFERENCE OF SUM
 
Name:
    DIFFERENCE OF SUM (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the sums for two response
    variables.

Syntax:
    LET <par> = DIFFERENCE OF SUM <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the sums is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF SUM Y1 Y2
    LET A = DIFFERENCE OF SUM Y1 Y2 SUBSET X > 1
 
Note:
    The difference of sums statistic is
    also supported for the following commands:

        DIFFERENCE OF SUM PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF SUM PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF SUM PLOT Y1 Y2
        TABULATE DIFFERENCE OF SUM Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF SUM Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF SUM Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SUM                             = Compute the sum.
    PRODUCT                         = Compute the product.
    CUMULATIVE SUM                  = Compute the cumulative sum.
    MEAN                            = Compute the mean.
    STANDARD DEVIATION              = Compute the standard deviation.
    DIFFERENCE OF MEAN              = Compute the difference of
                                      the means.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus
                                      two subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
    TABULATE                        = Perform a tabulation for a
                                      specified statistic.
    CROSS TABULATE                  = Perform a cross tabulation
                                      for a specified statistic.
 
Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF SUM Y1 Y2
    TABULATE DIFFERENCE OF SUM Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF SUM
    CHAR X
    LINE BLANK
    DIFFERENCE OF SUM PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF SUM PLOT Y1 Y2 X 
 
-----DIFFERENCE OF TRIMMED MEAN (LET)-------------------------------
 
DIFFERENCE OF TRIMMED MEAN
 
Name:
    DIFFERENCE OF TRIMMED MEAN (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the trimmed means for two
    response variables.
 
Description:
    The mean is the sum of the observations divided by the number of
    observations.  The mean can be heavily influenced by extreme values
    in the tails of a variable.  The trimmed mean compensates for this
    by dropping a certain percentage of values on the tails.  For
    example, the 50% trimmed mean is the mean of the values between
    the upper and lower quartiles.  The 90% trimmed mean is the mean
    of the values after truncating the lowest and highest 5% of the
    values.

    For the difference of trimmed means, the trimmed mean is
    computed for each of two samples then their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF TRIMMED MEAN <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the trimmed means is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF TRIMMED MEAN Y1 Y2
    LET A = DIFFERENCE OF TRIMMED MEAN Y1 Y2 SUBSET X > 1
 
Note:
    The analyst must specify the percentages to trim in each tail.
    This is done by defining the internal variables P1 (the lower
    tail) and P2 (the upper tail).  For example, to trim 10% off each
    tail, do the following:

        LET P1 = 10
        LET P2 = 10
        LET A = DIFFERENCE OF TRIMMED MEAN Y1 Y2
 
Note:
    The difference of trimmed means statistic is also supported for
    the following commands:

        DIFFERENCE OF TRIMMED MEANS PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF TRIMMED MEANS PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF TRIMMED MEANS PLOT Y1 Y2
        TABULATE DIFFERENCE OF TRIMMED MEANS Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF TRIMMED MEANS Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF TRIMMED MEANS Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TRIMMED MEAN                    = Compute the trimmed mean.
    DIFFERENCE OF MEDIAN            = Compute the difference of
                                      medians.
    DIFFERENCE OF MEAN              = Compute the difference of means.
    DIFFERENCE OF MIDMEAN           = Compute the difference of
                                      midmeans.
    DIFFERENCE OF BIWEIGHT LOCATION = Compute the difference of
                                      biweight locations.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus
                                      two subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
 
Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET P1 = 10
    LET P2 = 10
    LET A = DIFFERENCE OF TRIMMED MEAN Y1 Y2
    TABULATE DIFFERENCE OF TRIMMED MEAN Y1 Y2 X
    .
    CHAR X
    LINE BLANK
    DIFFERENCE OF TRIMMED MEAN PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF TRIMMED MEAN PLOT Y1 Y2 X 
 
-----DIFFERENCE OF VARIANCE (LET)------------------------------------
 
DIFFERENCE OF VARIANCE
 
Name:
    DIFFERENCE OF VARIANCE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the variances for
    two response variables.
 
Description:
    The variance is a common measure of the spread of a
    distribution or variable.  The formula is:

         s**2 = SUM(Xi - Xmean)**2/(N-1)

    For the difference of variances, the variance is computed for
    each of two samples then their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF VARIANCE <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the variances is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF VARIANCE Y1 Y2
    LET A = DIFFERENCE OF VARIANCE Y1 Y2 SUBSET X > 1
 
Note:
    The difference of variances statistic is
    also supported for the following commands:

        DIFFERENCE OF VARIANCE PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF VARIANCE PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF VARIANCE PLOT Y1 Y2
        TABULATE DIFFERENCE OF VARIANCE Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF VARIANCE Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF VARIANCE Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    VARIANCE                        = Compute the variance.
    STANDARD DEVIATION              = Compute the standard deviaition.
    MEAN                            = Compute the mean.
    DIFFERENCE OF MEAN              = Compute the difference of the
                                      means.
    DIFFERENCE OF SD                = Compute the difference of the
                                      standard deviation.
    DIFFERENCE OF MAD               = Compute the difference of the
                                      mad.
    DIFFERENCE OF AAD               = Compute the difference of the
                                      aad.
    DIFFERENCE OF IQ RANGE          = Compute the difference of the
                                      interquartile range.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus
                                      two subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
    TABULATE                        = Perform a tabulation for a
                                      specified statistic.
    CROSS TABULATE                  = Perform a cross tabulation for
                                      a specified statistic.
 
Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF VARIANCE Y1 Y2
    TABULATE DIFFERENCE OF VARIANCE Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF VARIANCE
    CHAR X
    LINE BLANK
    DIFFERENCE OF VARIANCE PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF VARIANCE PLOT Y1 Y2 X 
 
-----DIFFERENCE OF VARIANCE OF THE MEAN (LET)----------------------
 
DIFFERENCE OF VARIANCE OF THE MEAN
 
Name:
    DIFFERENCE OF VARIANCE OF THE MEAN (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the variance of the
    means for two response variables.
 
Description:
    The variance of the mean is:

        variance(mean) = s^2/SQRT(n)

    with s^2 and n denoting the variance and the number of
    observations, respectively.

    For the difference of variance of the means, the
    variance of the mean is computed for each of two
    samples then their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF VARIANCE OF THE MEAN <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the variance of the means is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF VARIANCE OF THE MEAN Y1 Y2
    LET A = DIFFERENCE OF VARIANCE OF THE MEAN Y1 Y2 SUBSET X > 1
 
Note:
    The difference of variance of the means statistic is
    also supported for the following commands:

        DIFFERENCE OF VARIANCE OF THE MEAN PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF VARIANCE OF THE MEAN PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF VARIANCE OF THE MEAN PLOT Y1 Y2
        TABULATE DIFFERENCE OF VARIANCE OF THE MEAN Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF VARIANCE OF THE MEAN Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF VARIANCE OF THE MEAN
                Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SD OF THE MEAN                  = Compute the sd of the mean.
    VARIANCE                        = Compute the variance.
    STANDARD DEVIATION              = Compute the standard deviation.
    MEAN                            = Compute the mean.
    DIFFERENCE OF MEAN              = Compute the difference of the
                                      means.
    DIFFERENCE OF VARIANCE          = Compute the difference of
                                      variances.
    DIFFERENCE OF SD OF THE MEAN    = Compute the difference of sd of
                                      the mean.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus two
                                      subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
    TABULATE                        = Perform a tabulation for a
                                      specified statistic.
    CROSS TABULATE                  = Perform a cross tabulation for
                                      a specified statistic.
 
Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF VARIANCE OF THE MEAN Y1 Y2
    TABULATE DIFFERENCE OF VARIANCE OF THE MEAN Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF VARIANCE OF THE MEAN
    CHAR X
    LINE BLANK
    DIFFERENCE OF VARIANCE OF THE MEAN PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF VARIANCE OF THE MEAN PLOT Y1 Y2 X 
 
-----DIFFERENCE OF WINSORIZED MEAN (LET)-------------------------------
 
DIFFERENCE OF WINSORIZED MEAN
 
Name:
    DIFFERENCE OF WINSORIZED MEAN (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the Winsorized means for two
    response variables.
 
Description:
    The mean is the sum of the observations divided by the number of
    observations.  The mean can be heavily influenced by extreme values
    in the tails of a variable.  The Winsorized mean compensates for
    this by setting the tail values equal to a certain percentile
    value.  For example, for a 90% Winsorized mean, the bottom 5%
    of the values are set equal to the value corresponding to the
    5th percentile while the upper 5% of the values are set equal to
    the value corresponding to the 95th percentile.
 
    For the difference of Winsorized means, the Winsorized mean is
    computed for each of two samples then their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF WINSORIZED MEAN <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the Winsorized means is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF WINSORIZED MEAN Y1 Y2
    LET A = DIFFERENCE OF WINSORIZED MEAN Y1 Y2 SUBSET X > 1
 
Note:
    The analyst must specify the percentages to Winsorized in
    each tail.  This is done by defining the internal variables
    P1 (the lower tail) and P2 (the upper tail).  For example,
    to Winsorize 10% off each tail, do the following:

        LET P1 = 10
        LET P2 = 10
        LET A = DIFFERENCE OF WINSORIZED MEAN Y1 Y2
 
Note:
    The difference of Winsorized means statistic is also supported
    for the following commands:

        DIFFERENCE OF WINSORIZED MEANS PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF WINSORIZED MEANS PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF WINSORIZED MEANS PLOT Y1 Y2
        TABULATE DIFFERENCE OF WINSORIZED MEANS Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF WINSORIZED MEANS Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF WINSORIZED MEANS Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WINSORIZED MEAN                 = Compute the Winsorized mean.
    TRIMMED MEAN                    = Compute the trimmmed mean.
    DIFFERENCE OF MEDIAN            = Compute the difference of
                                      medians.
    DIFFERENCE OF MEAN              = Compute the difference of means.
    DIFFERENCE OF TRIMMED MEAN      = Compute the difference of
                                      trimmed means.
    DIFFERENCE OF MIDMEAN           = Compute the difference of
                                      midmeans.
    DIFFERENCE OF BIWEIGHT LOCATION = Compute the difference of
                                      biweight locations.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus
                                      two subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
 
Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET P1 = 10
    LET P2 = 10
    LET A = DIFFERENCE OF WINSORIZED MEAN Y1 Y2
    TABULATE DIFFERENCE OF WINSORIZED MEAN Y1 Y2 X
    .
    CHAR X
    LINE BLANK
    DIFFERENCE OF WINSORIZED MEAN PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF WINSORIZED MEAN PLOT Y1 Y2 X 
 
-----DIFFERENCE OF WINSORIZED SD (LET)-------------------------------
 
DIFFERENCE OF WINSORIZED SD
 
Name:
    DIFFERENCE OF WINSORIZED SD (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the Winsorized standard
    deviations for two response variables.
 
Description:
    The standard variance estimate can be heavily influenced by
    extreme values.  The Winsorized standard deviation compensates
    for this by setting the tail values equal to a certain percentile
    value.  For example, for a 90% Winsorized standard deviation, the
    bottom 5% of the values are set equal to the value corresponding
    to the 5th percentile while the upper 5% of the values are set
    equal to the value corresponding to the 95th percentile.  Then
    the regular standard deviation formula (HELP STANDARD
    DEVIATION for details) is applied.
 
    For the difference of Winsorized standard deviations, the
    Winsorized standard deviation is computed for each of two
    samples then their difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF WINSORIZED SD <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the Winsorized standard deviation is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF WINSORIZED SD Y1 Y2
    LET A = DIFFERENCE OF WINSORIZED SD Y1 Y2 SUBSET X > 1
 
Note:
    The analyst must specify the percentages to Winsorized in
    each tail.  This is done by defining the internal variables
    P1 (the lower tail) and P2 (the upper tail).  For example,
    to Winsorize 10% off each tail, do the following:

        LET P1 = 10
        LET P2 = 10
        LET A = DIFFERENCE OF WINSORIZED SD Y1 Y2
 
Note:
    The difference of Winsorized sds statistic is also supported
    for the following commands:

        DIFFERENCE OF WINSORIZED SDS PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF WINSORIZED SDS PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF WINSORIZED SDS PLOT Y1 Y2
        TABULATE DIFFERENCE OF WINSORIZED SDS Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF WINSORIZED SDS Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF WINSORIZED SDS Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    DIFFERENCE OF WINSORIZED STANDARD DEVIATION is a synonym for
    DIFFERENCE OF WINSORIZED VARIANCE.
 
Related Commands:
    WINSORIZED SD                 = Compute the Winsorized sd.
    WINSORIZED VARIANCE           = Compute the Winsorized variance.
    WINSORIZED MEAN               = Compute the Winsorized mean.
    BIWEIGHT MIDVARIANCE          = Compute the biweight midvariance.
    STANDARD DEVIATION            = Compute the standard deviation.
    MAD                           = Compute the mad.
    AAD                           = Compute the aad.
    IQ RANGE                      = Compute the interquartile range.
    DIFFERENCE OF WINSORZIED VARI = Compute the difference of
                                    Winsorized variance.
    DIFFERENCE OF WINSORZIED MEAN = Compute the difference of
                                    Winsorized mean.
    DIFFERENCE OF SD              = Compute the difference of sd.
    DIFFERENCE OF BIWEIGHT MIDVAR = Compute the difference of
                                    biweight midvariances.
    STATISTICS PLOT                 = Generate a statistic versus
                                      subset plot.
    CROSS TABULATE PLOT             = Generate a statistic versus
                                      two subsets plot.
    BOOTSTRAP PLOT                  = Generate a bootstrap plot.
 
Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET P1 = 10
    LET P2 = 10
    LET A = DIFFERENCE OF WINSORIZED SD Y1 Y2
    TABULATE DIFFERENCE OF WINSORIZED SD Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF WINSORIZED SD
    CHAR X
    LINE BLANK
    DIFFERENCE OF WINSORIZED SD PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF WINSORIZED SD PLOT Y1 Y2 X 
 
-----DIFFERENCE OF WINSORIZED VARIANCE (LET)------------------------
 
DIFFERENCE OF WINSORIZED VARIANCE
 
Name:
    DIFFERENCE OF WINSORIZED VARIANCE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the difference between the Winsorized variances
    for two response variables.
 
Description:
    The variance estimate can be heavily influenced by
    extreme values.  The Winsorized variance compensates
    for this by setting the tail values equal to a certain percentile
    value.  For example, for a 90% Winsorized variance, the
    bottom 5% of the values are set equal to the value corresponding
    to the 5th percentile while the upper 5% of the values are set
    equal to the value corresponding to the 95th percentile.  Then
    the regular variance formula (HELP VARIANCE for details) is
    applied.
 
    For the difference of Winsorized variances, the Winsorized
    variance is computed for each of two samples then their
     difference is taken.

Syntax:
    LET <par> = DIFFERENCE OF WINSORIZED VARIANCE <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the first response variable;
          <par> is a parameter where the computed difference of
               the Winsorized variance is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIFFERENCE OF WINSORIZED VARIANCE Y1 Y2
    LET A = DIFFERENCE OF WINSORIZED VARIANCE Y1 Y2 SUBSET X > 1
 
Note:
    The analyst must specify the percentages to Winsorized in
    each tail.  This is done by defining the internal variables
    P1 (the lower tail) and P2 (the upper tail).  For example,
    to Winsorize 10% off each tail, do the following:

        LET P1 = 10
        LET P2 = 10
        LET A = DIFFERENCE OF WINSORIZED VARIANCE Y1 Y2
 
Note:
    The difference of Winsorized variance statistic is also supported
    for the following commands:

        DIFFERENCE OF WINSORIZED VARIANCES PLOT Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF WINSORIZED VARIANCES PLOT Y1 Y2 X
        BOOTSTRAP DIFFERENCE OF WINSORIZED VARIANCES PLOT Y1 Y2
        TABULATE DIFFERENCE OF WINSORIZED VARIANCES Y1 Y2 X
        CROSS TABULATE DIFFERENCE OF WINSORIZED VARIANCES Y1 Y2 X
        LET Z = CROSS TABULATE DIFFERENCE OF WINSORIZED VARIANCES
                Y1 Y2 X1 X2

    Enter
  
        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP BOOTSTRAP PLOT
        HELP TABULATE
        HELP CROSS TABULATE
        HELP CROSS TABULATE (LET)

    for more information on these plots and commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WINSORIZED SD                 = Compute the Winsorized sd.
    WINSORIZED VARIANCE           = Compute the Winsorized variance.
    WINSORIZED MEAN               = Compute the Winsorized mean.
    BIWEIGHT MIDVARIANCE          = Compute the biweight midvariance.
    VARIANCE                      = Compute the variance.
    MAD                           = Compute the mad.
    AAD                           = Compute the aad.
    IQ RANGE                      = Compute the interquartile range.
    DIFFERENCE OF WINSORZIED SD   = Compute the difference of
                                    Winsorized standard deviations.
    DIFFERENCE OF WINSORZIED MEAN = Compute the difference of
                                    Winsorized mean.
    DIFFERENCE OF VARIANCE        = Compute the difference of
                                    variances.
    DIFFERENCE OF BIWEIGHT MIDVAR = Compute the difference of
                                    biweight midvariances.
    STATISTICS PLOT               = Generate a statistic versus
                                    subset plot.
    CROSS TABULATE PLOT           = Generate a statistic versus
                                    two subsets plot.
    BOOTSTRAP PLOT                = Generate a bootstrap plot.
 
Applications:
    Data Analysis
 
Implementation Date:
    3/2003
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET P1 = 10
    LET P2 = 10
    LET A = DIFFERENCE OF WINSORIZED VARIANCE Y1 Y2
    TABULATE DIFFERENCE OF WINSORIZED VARIANCE Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF WINSORIZED VARIANCE
    CHAR X
    LINE BLANK
    DIFFERENCE OF WINSORIZED VARIANCE PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF WINSORIZED VARIANCE PLOT Y1 Y2 X 
 
-----DIGAMMA (LET)--------------------------------
 
DIGAMMA
 
Name:
    DIGAMMA (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the digamma (or psi) function.
 
Description:
    The digamma function is defined as:
        digamma(x) = GAMMA'(x)/GAMMA(x)
    where GAMMA is the gamma function and GAMMA' is the derivative of
    the gamma function.  This function is undefined for zero and 
    negative integers.  Full precision may not be obtained if x is too
    near a negative integer.
 
Syntax:
    LET <y> = DIGAMMA(<x>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, variable or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed digamma values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIGAMMA(1)
    LET X2 = DIGAMMA(X1)
    LET X2 = DIGAMMA(X1-4)
 
Note:
    DATAPLOT uses the routine DPSI from the SLATEC Common Mathematical
    Library to compute this function.  SLATEC is a large set of high
    quality, portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GAMMA      = Compute the gamma function.
    LOGGAMMA   = Compute the log (to base e) gamma function.
    GAMMAI     = Compute the incomplete Gamma function.
    GAMMAIP    = Compute an alternate form of the incomplete gamma
                 function.
    GAMMAIC    = Compute the complementary incomplete Gamma function.
    GAMMAR     = Compute the reciprocal gamma function.
    TRICOMI    = Compute Tricomi's incomplete gamma function.
    BETA       = Compute the Beta function.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE DIGAMMA FUNCTION
    XLIMITS -2 10
    PLOT DIGAMMA(X) FOR X = 0.1 0.1 10 AND
    PLOT DIGAMMA(X) FOR X = -.9 0.1 -0.1 AND
    PLOT DIGAMMA(X) FOR X = -1.9 0.1 -1.1
 
-----DIGITS (LET)---------------------------------------------------
 
DIGITS
 
Name:
    DIGITS (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Strip out the individual digits for the integer portion of a number.
 
Description:
    Given the number 1423.36, DIGITS will return a vector containing the
    values 1, 4, 2, and 3.

    The negative sign is ignored for negative numbers.  That is, DIGITS
    will return the same values for 1423 and -1423.

    This command is a utility function that is used by the Dataplot
    10-step macros for analyzing 2-level factorial designs.

Syntax:
    LET <y> = DIGITS <a>
    where <a> is a parameter or number;
    and   <y> is a vector where the digits will be saved.
 
Examples:
    LET Y = DIGITS 58.6
    LET Y = DIGITS A
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DEXPLOT.DP     = Dataplot macro for performing a 10-step analysis of
                     2-level factorial designs.
    YATES          = Perform a Yates analysis.
 
Applications:
    Analysis of Factorial Designs
 
Implementation Date:
    2015/01
 
Program:
    SKIP 25
    READ BOXSPRIN.DAT Y
    SKIP 0
    YATES Y
    .
    SET WRITE DECIMALS 0
    LOOP FOR K = 1 1 8
        ROW LIMITS K K
        READ PARAMETER DPST1F.DAT IVAL
        LET D^K = DIGITS IVAL
        PRINT "K = ^K"
        PRINT D^K
    END OF LOOP
 
-----DIGITS TO STRING----------------------------------------------
 
DIGITS TO STRING

Name:
    DIGITS TO STRING
 
Type:
    Let Subcommand
 
Purpose:
    Convert a vector of positive integers to a string.
 
Description:
    Given a vector that contains the values 2, 3, and 5, the DIGITS TO
    STRING command creates the string

        X2*X3*X5

    This is a utility routine used by the macros that run the
    10-step analysis of 2-level factorial designs.

    Dataplot will add 0.5 to the numbers in the vector and then take
    the absolute value before truncating to the integer value.

Syntax:
    LET <sout> = DIGITS TO STRING  <y>
    where <sout> is the name of the resulting string;
    and   <y> is a variable containing integer values.

Examples:
    LET SOUT = DIGITS TO STRING Y
 
Note:
    The name on the right hand side of the equal sign must be a
    previously existing variable.  If it is a previously existing
    parameter, string, or matrix name, an error will be reported and
    the requested string will not be created.

    The name on the left hand side of the equal sign may be a
    previously existing string.  However, if it is a previously
    existing parameter, variable, or matrix name, an error will
    be reported and the requested string will not be created.

Note:
    The total number of characters that DATAPLOT can use for storing
    functions and strings is set when DATAPLOT is built.  The current
    default (11/2008) is 50,000 characters.  Previous versions may set
    this limit at 1,000 or 10,000 characters.  This limit applies to the
    combined number of characters for all functions and strings.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DIGITS                    = Strip out the individual digits for the
                                integer portion of a number.
    NUMBER OF WORDS           = Return the number of words in a string.
    UPPER CASE                = Convert a string to upper case.
    LOWER CASE                = Convert a string to lower case.
    LET FUNCTION              = Defines a function.
    LET STRING                = Defines a string.
    READ STRING               = Reads a string from a file.
    SUBSTITUTE CHARACTER (^)  = Substitute the value of a string or
                                parameter.
    CONCATENATE CHARACTER (&) = Concatenate two strings.
    SUBTRING                  = Extract a substring from an existing
                                string.
    STRING INDEX              = Extract the start/stop positions of a
                                substring within a string.
    STRING CONCATENATE        = Concatenate one or more previously
                                defined strings.
    STRING EDIT               = Edit a string.
    STRING MERGE              = Insert a string into another string
                                without overwrite.
    STRING LENGTH             = Return the length of a string.
    STRING WORD               = Extract a specified word from a string.
    CHARACTER                 = Convert numeric values to strings based
                                on the ASCII collating sequence.
    ICHAR                     = Convert a string to numeric values based
                                on the ASCII collating sequence.
    GROUP LABEL               = Define the text for group labels.
 
Applications:
    Data Management
 
Implementation Date:
    2015/03
 
Program:
    let y = data 2 3 5
    let stout = digits to string y
    print stout

-----DIM (LET)--------------------------------
 
DIM
 
Name:
    DIM (LET)
 
Type:
    Library Function
 
Purpose:
    Compute a positive difference of two numbers.
 
Description:
    The positive difference for two numbers x1 and x2 is:

        positive difference = x1 - minimum(x1,x2)
 
Syntax:
    LET <y2> = DIM(<x1>,<x2>)  <SUBSET/EXCEPT/FOR qualification>
    where <x1> is a variable or parameter;
          <x2> is a variable or parameter of the same length as <x1>;
          <y2> is a variable or a parameter (depending on what <x1> is)
               where the computed positive differences are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIM(14,23)
    LET A = DIM(23,14))
    LET X2 = DIM(X1,X2)
    LET X2 = DIM(X1-4,X2)
 
Note:
    If the smaller number comes first, the positive difference
    is returned as zero.  For example, DIM(14,23) returns a value
    of 0 while DIM(23,14) returns a value of 9.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ABS     = Compute the absolute value of a number.
    SQRT    = Compute the square root of a number.
    EXP     = Compute the exponential of a number.
    MOD     = Compute the modulo (i.e., the remainder of x/y) of two
              numbers.
    MIN     = Compute the minimum of two numbers.
    MAX     = Compute the maximum of two numbers.
    IND     = Compute the mathematical indicator function.
 
Applications:
    XX
 
Implementation Date:
    XX.X
 
Program:
    LET X = SEQUENCE 1 1 9
    LET Y1 = X**2
    LET Y2 = X**1.5
    LET Y3 = DIM(Y1,Y2)
    PRINT X Y1 Y2 Y3
 
-----DIMENSION-------------------------------------------------------
 
DIMENSION
 
Name:
    DIMENSION
 
Type:
    Support Command
 
Purpose:
    Specifies the maximum number of rows and columns (that is, the
    maximum number of observations per variable and the maximum number
    of variables) in the internal DATAPLOT data area.
 
Syntax 1:
    DIMENSION   <ncols>   VARIABLES
    where <ncols> is a number or parameter in the integer range 10 to
             200 that specifies the maximum number of variables that
             could be used in this run.
 
Syntax 2:
    DIMENSION   <nrows>   OBSERVATIONS
    where <nrows> is a number or parameter (the range is implementation
             dependent) that specifies the maximum number of rows that
             could be used in this run.
 
Syntax 3:
    DIMENSION   <nrows> <ncols>
    where <ncols> is a number or parameter in the integer range 10 to
             200 that specifies the maximum number of variables that
             could be used in this run;
    and   <nrows> is a number or parameter (the range is implementation
             dependent) that specifies the maximum number of rows that
             could be used in this run.
 
Examples:
    DIMENSION 100 VARIABLES
    DIMENSION 200 OBSERVATIONS
    DIMENSION DEFAULT
 
Note:
    The DIMENSION command erases the current contents of the data area!
    For this reason, the DIMENSION command should be entered before any
    data is read or generated.
 
Note:
    When DATAPLOT is installed, the local installer can set the three
    following parameters:
      1) Workspace size.  This is the total number of observations
         (i.e., rows X columns).  The default size is 100,000.  The
         user can redimension the rows and columns (with some
         constraints) to fit this number.
      2) The maximum number of observations per variable.  The default
         size is 10,000.  The user can redimension to a smaller number
         of rows, but this maximum number of rows can not be exceeded.
         The number of variables must be between 10 and 200 when
         redimensioning the work space.
      3) The maximum number of points on a plot.  This is normally set
         to twice the maximum number of observations per variable
         (i.e., 20,000).
    If larger data sets must be accommodated, the local installer can
    rebuild DATAPLOT after setting these parameters larger.
 
Default:
    Implementation dependent.  It is typically 10 variables and 10,000
    observations per variable.
 
Synonyms:
    DIMENSION <ncols> COLUMNS
    DIMENSION <nrows> ROWS
 
Related Commands:
    STATUS     = Displays dimension, variables, parameters, functions,
                 etc.
    PROBE      = Displays the value of an internal variable.
    SET        = Sets the value of an internal variable.
 
Applications:
    Data Manipulation
 
Implementation Date:
    Pre-1987
 
Program:
    XX
 
-----DIR---------------------------------------------------

DIR

Name:
    DIR
 
Type:
    Support Command
 
Purpose:
    This command lists the contents of a directory.
 
Description:
    This command uses an operating system command to list the
    contents a directory.

    For Unix/Linux/MacOS systems, the DIR command issues a

        ls ....

    command to the operating system.

    For Windows systems, the DIR command issues a

        DIR  ....

    command to the operating system.

    The string that follows the DIR on the command line
    is passed to the operating system as is.  Dataplot does no
    error checking of this string.

    This is a system dependent command.  It is currently supported
    for Unix/Linux/MacOS and Windows platforms.

Syntax:
    DIR <file-list>
    where <file-list> is an optional string specifying what files
          should be listed.

    If <file-list> is omitted, then the contents of the current
    directory are listed.

Examples:
    DIR
    DIR macros/*.dp
    DIR macros
 
Note:
    The DIR capability can be implemented by direct use of the
    SYSTEM command.  For example, under Linux do something like

         SYSTEM ls *.dp

    The motivation for adding this as a separate command is to
    allow the capability to be implemented in an operating
    system independent way.  This can be useful when writing
    general purpose macros that may be used on different
    operating systems.

Note:
    Both the Linux ls command and the Windows DIR commands
    support a number of different options for displaying
    the output.  A few of these are supported as follows.

    If you would like to display the results one screen at
    a time, enter the command

         SET DIR PAUSE ON

    This adds a "/P" option under Windows.  For Linux, the
    output will be piped to the Linux more command.  To reset
    the default (no pause), enter the command

         SET DIR PAUSE OFF

    If you would like the contents of any listed directories
    to be displayed, enter the command

         SET DIR RECURSIVE ON

    This adds a "/S" option under Windows and a "-R" option under
    Linux.  To reset the default (no recursive listing of directory
    contents), enter the command

         SET DIR RECURSIVE OFF

    To specify "long listing" (i.e., more detailed information
    about each file), enter the command

         SET DIR LONG LISTING ON

    This adds a "/N" option under Windows and a "-l" option under
    Linux.  To reset the default ("/W" option under Windows and
    no "-l" option under Linux), enter the command

         SET DIR LONG LISTING OFF

    By default, files are listed alphabetically.  To specify
    sorting by size, enter the command

         SET DIR SORT SIZE

    This adds a "/O:S" option under Windows and a "-s" option under
    Linux.

    To specify sorting by date, enter the command

         SET DIR SORT DATE

    This adds a "/O:D" option under Windows and a "-t" option under
    Linux.

    To reset alphabetic sorting, enter the command

         SET DIR SORT ALPHABETIC

    This adds a "/O:N" option under Windows.  No option is given
    for Linux.

    If you want to use options not supported by one of the above
    SET commands, you can enter them manually.  For example,
    under Linux you can do something like

         DIR -aFC *

Note:
    File names are case sensitive on Unix/Linux/MacOS file
    systems.  For this reason, case is preserved in passing the
    file name to the operating system.

Default:
    None
 
Synonyms:
    LS is a synonym for DIR

Related Commands:
    SYSTEM      = Enter an operating system command within a
                  Dataplot session.
    CD          = Change the current working directory.
    PWD         = Retrieve the current working directory.
    MKDIR       = Create a new di
    RM          = Delete one or more files.
    CAT         = List the contents of a file.
 
Applications:
    Interactive Usage
 
Implementation Date:
    2019/09
 
Program:
    SKIP 25
    READ BERGER1.DAT Y X
    .
    CAPTURE FIT.OUT
    FIT Y X
    END OF CAPTURE
    .
    DIR *.OUT  FIT.*
 
-----DIRECTORY-------------------------------------------------------
 
DIRECTORY
 
Name:
    DIRECTORY
 
Type:
    Keyword
 
Purpose:
    Symbolic name for DATAPLOT's DIRECTORY file.  It is used with the
    SEARCH and LIST commands.
 
Description:
    DATAPLOT's directory file contains a list by command category of
    all DATAPLOT commands with a brief (one line) description.  It also
    contains the names of DATAPLOT macro, program, and data files.
 
Syntax:
    None
 
Examples:
    SEARCH DIRECTORY PLOT
    LIST DIRECTORY FOR I = 1 1 35
 
Note:
    The DIRECTORY file is stored in the DATAPLOT directory.  It
    has the name DPDIRF.TEX (or dpdirf.tex for Unix systems).  The
    directory name varies depending on the installation (see your local
    DATAPLOT implementor to find the exact name on your system).
 
Note:
    If DATAPLOT is unable to open the directory file, it is most
    likely because the DATAPLOT directory name is not specified
    correctly in the local DATAPLOT code.  See your local DATAPLOT
    implementor to have this corrected.
 
Default:
    None
 
Synonyms:
    ADD
 
Related Commands:
    SEARCH        = Search a file for a string.
    LIST          = Lists the contents of a file.
    DICTIONARY    = Symbolic name for DATAPLOT's dictionary file.
 
Applications:
    XX
 
Implementation Date:
    Pre-1987
 
Program:
    SEARCH DICTIONARY BOOTSTRAP PLOT
 
-----DIRICHLET RANDOM NUMBER-------------------------------
 
DIRICHLET RANDOM NUMBER
 
Name:
    DIRICHLET RANDOM NUMBER
 
Type:
    Let Subcommand
 
Purpose:
    Generate random numbers from a Dirichlet distribution.
 
Description:
    The Dirichlet distribution is a generalization of the
    beta distribution.  To generate a matrix of Dirichlet
    random numbers with n rows and k columns, k independent
    vectors of length n containing independent gamma random
    numbers are generated.  The numbers in each column are
    divided by the sum of that column.

    If there are two shape parameters, the Dirichlet distribution
    reduces to a Beta distribution.  In addition, the marginal
    distribution of each column  is also a beta distribution.

Syntax:
    LET <mat> = DIRICHLET RANDOM NUMBERS <alpha> <n>
    where <alpha> is a variable containing the desired shape (> 0)
               parameters;
          <n> is a number or parameter specifying the desired number
               of observations;
    and where <mat> is a matrix where the resulting Dirichlet
               random numbers are stored.
 
Examples:
    LET ALPHA = DATA 1 2 3
    LET N = 1000
    LET M = DIRICHLET RANDOM NUMBERS ALPHA N
 
Note:
    Dataplot uses a Fortran translation of the
    "gsl_ran_dirichlet" code (written by Gavin Crooks) from
    the GNU GSL library.

Note:
    As with univariate random numbers, the multinomial random
    numbers are built on an underlying uniform random number
    generator.  Dataplot supports a number of different
    uniform random number generators.  For details, enter

       HELP SET RANDOM NUMBER GENERATOR

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    RANDOM NUMBERS                = Generate random numbers for 60+
                                    univariate distributions.
    SET RANDOM NUMBER GENERATOR   = Specify which univariate generator
                                    to use.
    MULTIVARIATE NORM RAND NUMB   = Generate multivariate normal
                                    random numbers.
    MULTIVARIATE T RANDOM NUMBERS = Generate multivariate t random
                                    numbers.
    INDEPENDENT UNIFORM RAND NUMB = Generate random numbers for
                                    independent uniform distributions.
    WISHART RANDOM NUMBERS        = Generate random numbers for a
                                    Wishart distribution.
    MULTINOMIAL RANDOM NUMBERS    = Generate random numbers for a
                                    multinomial distribution.
 
Reference:
    "Statistical Distributions: Third Edition", Evans, Hastings,
    and Peacock, Wiley, 2000.
 
Applications:
    Simulation, Bayesian Analysis
 
Implementation Date:
    2003/5
 
Program:
    dimension 100 columns
    .
    let alpha = data 0.5 1.0 1.5 2.0
    let n = 500
    .
    let d = dirichlet random numbers alpha n
    .
    title automatic
    xlimits 0 1
    xtic offset 0.2 0.2
    multiplot corner coordinates 0 0 100 100
    multiplot 2 2
    relative histogram d1
    relative histogram d2
    relative histogram d3
    relative histogram d4
    end of multiplot
 
-----DISCDF (LET)--------------------------------
 
DISCDF
 
Name:
    DISCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the discrete uniform cumulative distribution function.
 
Description:
    The discrete uniform distribution has the following probability
    density function:
       f(x) = 1/(n+1)      for x equal all integers between 0 and n
    The cumulative distribution is the area from negative infinity to x
    (i.e., the integral of the above function).  It has the formula:
       F(x) = (x+1)/(n+1)  for x equal all integers between 0 and n
 
Syntax:
    LET <y> = DISCDF(<x>,<n>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter containing
              values between 0 and <n>;
          <n> is a number or parameter that defines the upper limit
              of the discrete uniform distribution;
          <y> is a variable or a parameter (depending on what <y> is)
               where the computed cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DISCDF(3,20)
    LET Y = DISCDF(X1,100)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DISPDF = Compute the discrete uniform probability density function.
    DISPPF = Compute the discrete uniform percent point function.
    UNIPDF = Compute the uniform cumulative distribution function.
    UNIPDF = Compute the uniform probability density function.
    UNIPPF = Compute the uniform percent point function.
    UNISF  = Compute the uniform sparsity function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
 
Reference:
    "Statistical Distributions", 2nd. Edition, Evans, Hastings, and
    Peacock, John Wiley and Sons (chapter 36).
 
Applications:
    XX
 
Implementation Date:
    94/12 (earlier versions have a bug)
 
Program:
    TITLE AUTOMATIC
    LINE BLANK
    SPIKE ON
    PLOT DISCDF(X,20) FOR X = 0 1 20
 
-----DISCRETE CONTOUR PLOT-----------------------------------------
 
DISCRETE CONTOUR PLOT
 
Name:
    DISCRETE CONTOUR PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a discrete contour plot.
 
Description:
    A contour plot is a graphical technique for representing a
    3-dimensional z = f(x,y) surface by plotting constant-z "slices"
    (contours) on a 2-dimensional format.  These slices are also
    referred to as iso-lines.
 
    The discrete contour plot is a variation of the contour
    plot.  Instead of drawing an isolines, a box is drawn at
    each square on the grid.  The average response of the four
    points of this box is used to determine the level for that box.
    Levels are distinguished by the fill color of the box.

    There is currently no "smoothing" of the color within the
    boxes to match neighboring boxes.  If you want a smoother
    plot, then increase the number of points on the grid.

    Both the levels and the colors to be used to identify
    the levels are set by the user.

    The discrete contour plot is also referred to as an
    image map.

Syntax:
    DISCRETE CONTOUR PLOT  <z>  <x>  <y>  <z0>
                            <SUBSET/EXCEPT/FOR qualification>
    where <z>  is the response (= dependent) variable;
          <x>  is one horizontal axis variable;
          <y>  is the other horizontal axis variable;
          <z0> is the variable of desired contour values;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    DISCRETE CONTOUR PLOT Z X Y Z0
 
Note:
    The REGION FILL COLOR, REGION PATTERN, and REGION BORDER COLOR
    commands are used to control the appearance of the plot.
    This is demonstrated in the sample program below.

    Although you can use various types of region fill patterns,
    we typically just want solid-filled regions with the color
    denoting the level.

Note:
    Unlike the standard contour plot, the discrete contour
    plot does not require equally spaced grids.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CONTOUR PLOT         = Generates a contour plot.
    3D-PLOT              = Generates a 3-d data or function plot.
    PLOT                 = Generates a data or function plot.
    REGION FILL COLOR    = Set the fill color for regions.
 
Reference:
    Unwin, Theus, and Hofmann (2006), "Graphics of Large
    Datasets: Visualizing a Million", Springer, pp. 49-50.
 
Applications:
    Analysis of Trivariate Data
 
Implementation Date:
    2008/12
 
Program:
    LET NTOT = 41*41
    LET X = SEQUENCE -4 0.2 4 FOR I = 1 1 NTOT
    LET Y = SEQUENCE -4 41 0.2 4
    LET Z = X**2 + Y**2 - 2*X*Y
    LET Z0 = SEQUENCE 5 5 40
    . 
    LIMITS -4.0  4.0
    TIC MARK OFFSET 0 0
    MAJOR TIC MARK NUMBER 9
    MINOR TIC MARK NUMBER 1
    REGION FILL COLOR G90 G80 G70 G60 G50 G40 G30 G20 G10
    .
    TITLE OFFSET 2
    TITLE  X**2 + Y**2 - 2*X*Y
    DISCRETE CONTOUR PLOT Z X Y Z0

-----DISCRETE-------------------------------------------------------
 
DISCRETE
 
Name:
    DISCRETE
 
Type:
    Output Device Command
 
Purpose:
    Specifies that output device 1 (that is, the terminal) is:
       1) discrete (i.e., it cannot produce hardware-generated lines);
       2) narrow-width (i.e., it is at least 65 characters wide).
 
Description:
    The DISCRETE command is used when running DATAPLOT on a
    non-graphics terminal or a graphics terminal not supported by
    DATAPLOT.  In this case, DATAPLOT generates line printer type
    graphics.
 
Syntax:
    DISCRETE   <ON or OFF>
    where ON specifies that the terminal is discrete while OFF
    specifies that it is not.
 
Examples:
    DISCRETE ON
    DISCRETE
    DISCRETE OFF
 
Note:
    DISCRETE OFF is rare since a specific device is usually nominated
    (i.e., DEVICE 1 <device>).  Entering DISCRETE with no arguments is
    equivalent to DISCRETE ON.
 
Default:
    The terminal is assumed to be a Tektronix 4014 graphics device.
 
Synonyms:
    DISCRETE NARROW-WIDTH
    DEVICE 1 DISCRETE
    DEVICE 1 DISCRETE NARROW-WIDTH
 
Related Commands:
    BATCH      = Sets the terminal to batch.
    CONTINUOUS = Sets the terminal to continuous (Tektronix 4014).
    TEKTRONIX  = Sets the terminal to a Tektronix model.
    HP         = Sets the terminal to an HP model.
    GENERAL    = Sets the terminal to device-independent.
    DEVICE     = Sets the device manufacturer and model.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XX
 
-----DISCRETE NARROW-WIDTH------------------------------------------
 
DISCRETE NARROW-WIDTH
 
Name:
    DISCRETE NARROW-WIDTH
 
Type:
    Output Device Command
 
Purpose:
    Specifies that output device 1 (that is, the terminal) is:
       1) discrete (i.e., it cannot produce hardware-generated lines);
       2) narrow-width (i.e., it is at least 65 characters wide).
 
Description:
    The DISCRETE NARROW-WIDTH command is used when running DATAPLOT on
    a non-graphics terminal or a graphics terminal not supported by
    DATAPLOT.  In this case, DATAPLOT generates line printer type
    graphics.
 
Syntax:
    DISCRETE NARROW-WIDTH  <ON or OFF>
    where ON specifies that the terminal is discrete while OFF
    specifies that it is not.
 
Examples:
    DISCRETE NARROW-WIDTH ON
    DISCRETE NARROW-WIDTH
    DISCRETE NARROW-WIDTH OFF
 
Note:
    DISCRETE NARROW-WIDTH OFF is rare since a specific device is
    usually nominated (i.e., DEVICE 1 <device>).  Entering DISCRETE
    NARROW-WIDTH with no arguments is equivalent to DISCRETE
    NARROW-WIDTH ON.
 
Default:
    The terminal is assumed to be a Tektronix 4014 graphics device.
 
Synonyms:
    DISCRETE
    DEVICE 1 DISCRETE
    DEVICE 1 DISCRETE NARROW-WIDTH
 
Related Commands:
    BATCH      = Sets the terminal to batch.
    CONTINUOUS = Sets the terminal to continuous (Tektronix 4014).
    TEKTRONIX  = Sets the terminal to a Tektronix model.
    HP         = Sets the terminal to an HP model.
    GENERAL    = Sets the terminal to device-independent.
    DEVICE     = Sets the device manufacturer and model.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XX
 
-----DISCRETE WIDE-CARRIAGE------------------------------------------
 
DISCRETE WIDE-CARRIAGE
 
Name:
    DISCRETE WIDE-CARRIAGE
 
Type:
    Output Device Command
 
Purpose:
    Specifies that output device 1 (that is, the terminal) is:
       1) discrete (i.e., it cannot produce hardware-generated lines);
       2) wide-carriage (i.e., it is at least 120 characters wide).
 
Description:
    The DISCRETE WIDE-CARRIAGE command is used when running DATAPLOT on
    a non-graphics terminal or a graphics terminal not supported by
    DATAPLOT.  In this case, DATAPLOT generates line printer type
    graphics.
 
Syntax:
    DISCRETE WIDE-CARRIAGE  <ON or OFF>
    where ON specifies that the terminal is discrete while OFF
    specifies that it is not.
 
Examples:
    DISCRETE WIDE-CARRIAGE ON
    DISCRETE WIDE-CARRIAGE
    DISCRETE WIDE-CARRIAGE OFF
 
Note:
    DISCRETE WIDE-CARRIAGE OFF is rare since a specific device is
    usually nominated (i.e., DEVICE 1 <device>).  Entering DISCRETE
    WIDE-CARRIAGE with no arguments is equivalent to DISCRETE
    WIDE-CARRIAGE ON.
 
Default:
    The terminal is assumed to be a Tektronix 4014 graphics device.
 
Synonyms:
    BATCH
    DEVICE 1 BATCH
    DEVICE 1 DISCRETE WIDE-CARRIAGE
 
Related Commands:
    BATCH      = Sets the terminal to batch.
    CONTINUOUS = Sets the terminal to continuous (Tektronix 4014).
    TEKTRONIX  = Sets the terminal to a Tektronix model.
    HP         = Sets the terminal to an HP model.
    GENERAL    = Sets the terminal to device-independent.
    DEVICE     = Sets the device manufacturer and model.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XX
 
-----DISPDF (LET)--------------------------------
 
DISPDF
 
Name:
    DISPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the discrete uniform probability density function.
 
Description:
    The discrete uniform distribution has the following probability
    density function:
       f(x) = 1/(n+1)      for x equal all integers between 0 and n
 
Syntax:
    LET <y> = DISPDF(<y>,<n>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter containing
              values between 0 and <n>;
          <n> is a number or parameter that defines the upper limit
              of the discrete uniform distribution;
          <y> is a variable or a parameter (depending on what <y> is)
               where the computed pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DISPDF(3,20)
    LET X2 = DISPDF(X1,100)
 
Note:
    For a number of commands utilizing the discrete uniform
    distribution, it is convenient to bin the data.  There
    are two basic ways of binning the data.

      1) For some commands (histograms, maximum likelihood
         estimation), bins with equal size widths are
         required.  This can be accomplished with the
         following commands:

            LET AMIN = MINIMUM Y
            LET AMAX = MAXIMUM Y
            LET AMIN2 = AMIN - 0.5
            LET AMAX2 = AMAX + 0.5
            CLASS MINIMUM AMIN2
            CLASS MAXIMUM AMAX2
            CLASS WIDTH 1
            LET Y2 X2 = BINNED

      2) For some commands, unequal width bins may be
         helpful.  In particular, for the chi-square goodness
         of fit, it is typically recommended that the minimum
         class frequency be at least 5.  In this case, it may
         be helpful to combine small frequencies in the tails.
         Unequal class width bins can be created with the
         commands

            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = INTEGER FREQUENCY TABLE Y

         If you already have equal width bins data, you can
         use the commands
         
            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = COMBINE FREQUENCY TABLE Y2 X2

         The MINSIZE parameter defines the minimum class
         frequency.  The default value is 5.

Note:
    You can generate discrete uniform random numbers,
    probability plots, and chi-square goodness of fit
    tests with the following commands:

       LET N = VALUE
       LET Y = DISCRETE UNIFORM RANDOM NUMBERS FOR I = 1 1 N

       DISCRETE UNIFORM PROBABILITY PLOT Y
       DISCRETE UNIFORM PROBABILITY PLOT Y2 X2
       DISCRETE UNIFORM PROBABILITY PLOT Y3 XLOW XHIGH

       DISCRETE UNIFORM CHI-SQUARE GOODNESS OF FIT Y
       DISCRETE UNIFORM CHI-SQUARE GOODNESS OF FIT Y2 X2
       DISCRETE UNIFORM CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    There is no explicit fitting for the discrete uniform
    distribution.  Instead we pick a value for N and
    then apply goodness of fit tests (i.e., probability plots
    and chi-square goodness of fit) to see if the discrete
    uniform distribution is an adequate model.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DISCDF = Compute the discrete uniform cumulative distribution
             function.
    DISPPF = Compute the discrete uniform percent point function.
    UNIPDF = Compute the uniform cumulative distribution function.
    UNIPDF = Compute the uniform probability density function.
    UNIPPF = Compute the uniform percent point function.
    UNISF  = Compute the uniform sparsity function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
 
Reference:
    "Statistical Distributions", 2nd. Edition, Evans, Hastings, and
    Peacock, John Wiley and Sons (chapter 36).
 
Applications:
    Distributional Modeling
 
Implementation Date:
    1994/9
 
Program:
    TITLE AUTOMATIC
    LINE BLANK
    SPIKE ON
    PLOT DISPDF(X,20) FOR X = 0 1 20
 
-----DISPPF (LET)--------------------------------
 
DISPPF
 
Name:
    DISPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the discrete uniform percent point function.
 
Description:
    The discrete uniform distribution has the following probability
    density function:
       f(x) = 1/(n+1)      for x equal all integers between 0 and n
 
    The percent point function is the inverse of the cumulative
    distribution function.  The cumulative distribution sums the
    probability from 0 to the given x value (i.e., the integral of the
    above function).  The percent point function takes a cumulative
    probability value and computes the corresponding x value.  It has
    the formula:
       G(p) = p(n+1) - 1
    The input value is a real number between 0 and 1 (since it
    corresponds to a probability).  The output value can be any real
    number.
 
Syntax:
    LET <y> = DISPPF(<p>,<n>)  <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, variable or parameter in the range 0 to 1;
          <y> is a variable or a parameter (depending on what <y1> is)
              where the computed discrete uniform ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DISPPF(0.9)
    LET X2 = DISPPF(X1)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DISCDF = Compute the discrete uniform cumulative distribution
             function.
    DISPDF = Compute the discrete uniform probability density function.
    UNIPDF = Compute the uniform cumulative distribution function.
    UNIPDF = Compute the uniform probability density function.
    UNIPPF = Compute the uniform percent point function.
    UNISF  = Compute the uniform sparsity function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
 
Reference:
    "Statistical Distributions", 2nd. Edition, Evans, Hastings, and
    Peacock, John Wiley and Sons (chapter 36).
 
Applications:
    XX
 
Implementation Date:
    94/9
 
Program:
    XLIMITS 0 1
    MAJOR XTIC NUMBER 6
    MINOR XTIC NUMBER 1
    XTIC DECIMAL 1
    YLIMITS 0 20
    YTIC OFFSET 1 1
    TITLE AUTOMATIC
    PLOT DISPPF(X,20) FOR X = 0 0.01 1
 
-----DISTANCE FROM MEAN (LET)----------------------------------------
 
DISTANCE FROM MEAN
 
Name:
    DISTANCE FROM MEAN (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the distance from the mean for a matrix.
 
Description:
    The quadratic form of a matrix M and a vector X is defined as:

         A=X'MX

    where X' is the transpose of X.  If the vector X has n
    rows, then M must be an nxn matrix.

    The distance from the mean for a matrix X is a commonly used
    quadratic form:

       Di = (Xi - XMEAN)'*SINV*(Xi-XMEAN)

    where Xi is the ith row, XMEAN is the vector of column
    means, and SINV is the inverse of the variance-covariance
    matrix of X.  That is, Di is the distance of the ith row
    of the matrix from the mean.  D is a vector.

    In Dataplot, you specify the original matrix, not the
    variance-covariance matrix.
 
Syntax:
    LET <y> = DISTANCE FROM MEAN <mat1>
    where <mat1> is a matrix for which the distance from the
              mean is to be computed;
    and where <y> is a vector where the resulting distances 
             are saved.
 
Examples:
    LET Y = DISTANCE FROM MEAN M
 
Note:
    Matrices are created with either the READ MATRIX command or the
    MATRIX DEFINITION command.  Enter HELP MATRIX DEFINITION and HELP
    READ MATRIX for details.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    READ MATRIX               = Read a matrix.
    MATRIX COLUMN DIMENSION   = Dimension maximum number of columns
                                for Dataplot matrices.
    QUADRATIC FORM            = Compute the quadratic form of a matrix
                                and a vector.
    MATRIX DISTANCE           = Compute various row and column distances
                                for a matrix.
    MATRIX MEAN               = Compute the overall mean for a matrix.
    MATRIX COLUMN STATISTIC   = Compute column statistics for a matrix.
    MATRIX ROW STATISTIC      = Compute row statistics for a matrix.
    LINEAR COMBINATION        = Compute a linear combination of a matrix
                                and a vector.
 
Reference:
    "Applied Multivariate Statistical Analysis", Third Edition,
    Johnson and Wichern, Prentice-Hall, 1992.
 
Applications:
    Multivariate Analysis
 
Implementation Date:
    1998/8
 
Program:
    SKIP 25
    READ MATRIX IRIS.DAT M
    LET Y = DISTANCE FROM MEAN M
    PRINT Y

-----DISTINCT (LET)---------------------------------------------------
 
DISTINCT
 
Name:
    DISTINCT (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Extract the distinct elements of a variable and store them in
    another variable.
 
Syntax:
    LET <resp> = DISTINCT <x1>  <SUBSET/EXCEPT/FOR qualification>
    where <x1> is the variable for which the distinct elements are to
               be extracted;
          <resp> is a variable (generally of shorter length than <x1>)
               where the distinct values are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET XD = DISTINCT TAG
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COCODE         = Generate a cocoded variable.
    CODE           = Generate a coded variable.
    SEQUENCE       = Generate a sequence of numbers.
    PATTERN        = Generate numbers with a specific pattern.
 
Applications:
    XX
 
Implementation Date:
    XX.X
 
Program:
    LET X1 = PATTERN 1 2 3 4 5 FOR I = 1 1 100
    LET XD = DISTINCT X1
    The variable XD will contain the following values:
       1, 2, 3, 4, 5
 
-----DISTRIBU-------------------------------------------------------
 
DISTRIBU
 
Name:
    DISTRIBU
 
Type:
    Keyword
 
Purpose:
    Symbolic name for DATAPLOT's distributions file.  It is used with
    the SEARCH and LIST commands.
 
Description:
    DATAPLOT's distributions file contains an alphabetic list of
    probability distributions recognized by DATAPLOT.  It is possible
    to generate random numbers and probability plots for each of these
    distributions.  In addition, some of them support functions for
    cumulative, density, and percent point values.  Probability plot
    correlation coefficient plots can be generated for many of them.
 
Syntax:
    None
 
Examples:
    SEARCH DISTRIBU WEIBULL
    LIST DISTRIBU FOR I = 1 1 35
 
Note:
    The DISTRIBU file is stored in the DATAPLOT directory.  It has the
    name DISTRIBU (or distribu for Unix systems).  The exact file name
    and the directory where it is stored can vary depending on the
    installation (see your local DATAPLOT implementor to find the exact
    name on your system).
 
Note:
    If DATAPLOT is unable to open the distributions file, it is most
    likely because the directory name is not specified correctly in the
    local DATAPLOT code.  See your local DATAPLOT implementor to have
    this corrected.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SEARCH        = Search a file for a string.
    LIST          = Lists the contents of a file.
    DIRECTORY     = Symbolic name for DATAPLOT's directory file.
    DICTIONAY     = Symbolic name for DATAPLOT's dictionary file.
    DATASETS      = Symbolic name for DATAPLOT's data sets file.
    DESIGNS       = Symbolic name for DATAPLOT's design of experiments
                    file.
    SYNTAX        = Symbolic name for DATAPLOT's syntax file.
    MACROS        = Symbolic name for DATAPLOT's macros file.
    PROGRAMS      = Symbolic name for DATAPLOT's programs file.
    COMMANDS      = Symbolic name for DATAPLOT's commands file.
    FUNCTION      = Symbolic name for DATAPLOT's function file.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    93/12
 
Program:
    LIST DISTRIBU
 
-----DISTRIBUTIONAL BOOTSTRAP---------------------------------
 
DISTRIBUTIONAL BOOTSTRAP
 
Name:
    BOOTSTRAP PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a bootstrap plot for a given probability distribution.
 
Description:
    The PPCC PLOT and KS PLOT provide a graphical method for
    estimating the shape parameter for a proabability distribution.
    The PROBABILITY PLOT can then be used to estimate the location
    and scale parameters.

    One limitation of this method is that it does not provide a
    method for finding uncertainty intervals for these estimates.
    To address this, we have extended the BOOTSTRAP PLOT command
    to support a number of probability distributions.

    The bootstrap is a non-parametric method for calculating a
    sampling distribution for a statistic.  The bootstrap calculates
    the statistic with N different subsamples.  The subsampling is
    done with replacement.

    To apply the bootstrap to the univariate distributional
    modeling problem, we do the following:

       1) We have a univariate dataset containing n points.

       2) We draw a bootstrap sample from the original data.

       3) We perform the estimation for the bootstrap sample.

          a. For location/scale distributions, we estimate the
             parameters from a probability plot.

             The PPCC value is also computed for the bootstrap
             sample.

          b. For distributions with either one or two shape
             parameters, we generate a PPCC plot (alternatively,
             we can generate a KS plot) to estimate the shape
             parameters.   We then generate a probability plot
             to estimate the location and scale parameters.

             The PPCC value is also computed for the bootstrap
             sample.  If a KS plot is being used, the value of
             Kolmogorov-Smirnov statistic is computed instead.

          c. Bootstrapping is also supported for maximum likelihood
             estimation for a number of distributions.  In this
             case, we perform the maximum likelihood estimation
             on the bootstrap sample.

             In this case, no PPCC or Kolmogorov-Smirnov statistic
             is computed.

    For the bootstrap plot, there will be a separate curve drawn
    for each parameter estimated.  In addition, there will be a
    curve drawn for the PPCC value (or the Kolmogorov-Smirnov
    statistic).  The vertical axis contains the computed value of
    these estimated parameters and the horizontal axis contains the
    sample number (for k = 1, 2,  ..., N).

    The bootstrap plot is typically followed by some type of
    distributional plot, such as a histogram, for each estimated
    parameter.  This is demostrated in the Program sample below.
 
    Dataplot also supports bootstrap computations for the case
    when there is one group variable.  In this case, the horizontal
    axis is group id and the vertical axis contains the computed
    values of the estimated parameters for that group (the parameters
    are offset horizontally).  The number of bootstrap samples is
    applied to each group.  For example,if the requested number of
    bootstrap samples is 100, then each group will have 100 bootstrap
    samples applied.

Syntax 1:
    BOOTSTRAP <dist> PLOT <y>    <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <dist> is one of the following distributions:
                ANGLIT
                ARCSINE
                CAUCHY
                COSINE
                EXPONENTIAL
                GUMBEL (EXTREME VALUE TYPE 1)
                HALF CAUCHY
                HALF LOGISTIC
                HALF NORMAL
                HYPERBOLIC SECANT
                LAPLACE (DOUBLE EXPONENTIAL)
                LOGISTIC
                NORMAL
                RAYLEIGH
                SEMI-CIRCULAR
                SLASH
                UNIFORM
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax estimates the location and scale parameters for
    each bootstrap sample using a probability plot.

Syntax 2:
    BOOTSTRAP <dist> CENSORED PLOT <y> <x>
                     <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <x> is the censoring variable;
          <dist> is one of the distributions given for Synatx 1;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax estimates the location and scale parameters for
    each bootstrap sample using a censored probability plot.  The
    censoring variable should contain a value of 1 to indicate a
    failure time and a value of 0 to indicate a censoring time.

Syntax 3:
    BOOTSTRAP <dist> PLOT <y>    <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <dist> is one of the following distributions:
                ASYMMETRIC LAPLACE (ASYMMETRIC DOUBLE EXPONENTIAL)
                BURR TYPE 2
                BURR TYPE 7
                BURR TYPE 8
                BURR TYPE 10
                BURR TYPE 11
                BRADFORD
                CHI
                CHI-SQUARE
                DOUBLE GAMMA
                DOUBLE WEIBULL
                ERROR (SUBBOTIN)
                FATIGUE LIFE
                FOLDED T
                FRECHET
                GAMMA
                GENERALIZED EXTREME VALUE
                GENERALIZED HALF LOGISTIC
                GENERALIZED LOGISTIC
                GENERALIZED LOGISTIC TYPE 2
                GENERALIZED LOGISTIC TYPE 3
                GENERALIZED LOGISTIC TYPE 5
                GENERALIZED PARETO
                GEOMETRIC EXTREME EXPONENTIAL
                INVERTED GAMMA
                INVERTED WEIBULL
                LOG DOUBLE EXPONENTIAL (LOG LAPLACE)
                LOG GAMMA
                LOG LOGISTIC
                LOGNORMAL
                OGIVE
                PARETO
                PARETO SECOND KIND
                POWER
                POWER NORMAL
                RECIPROCAL
                REFLECTED POWER
                SKEW LAPLACE (SKEW DOUBLE EXPONENTIAL)
                SLOPE
                T
                TOPP AND LEONE
                TRIANGULAR
                TUKEY-LAMBDA
                VON MISES
                WALD
                WRAPPED CAUCHY
                WEIBULL
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax estimates the shape parameter using a PPCC plot and
    then estimates the location and scale parameters using a
    probability plot for each bootstrap sample .

Syntax 4:
    BOOTSTRAP <dist> CENSORED PLOT <y> <x>
                     <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <x> is the censoring variable;
          <dist> is one of the distributions given for syntax 3;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax estimates the shape parameter using a censored PPCC
    plot and then estimates the location and scale parameters using a
    censored probability plot for each bootstrap sample.  The
    censoring variable should contain a value of 1 to indicate a
    failure time and a value of 0 to indicate a censoring time.

Syntax 5:
    BOOTSTRAP <dist> KS PLOT <y>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <dist> is one of the distributions given for syntax 3;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax estimates the shape parameter using a KS plot and
    then estimates the location and scale parameters using a
    probability plot for each bootstrap sample.

Syntax 6:
    BOOTSTRAP <dist> PLOT <y>    <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <dist> is one of the following distributions:
                BETA
                BETA NORMAL
                BURR TYPE 3
                BURR TYPE 5
                BURR TYPE 6
                BURR TYPE 7
                BURR TYPE 9
                BURR TYPE 12
                DOUBLY PARETO UNIFORM
                EXPONENTIATED WEIBULL
                F
                FOLDED NORMAL
                G-AND-H
                GENERALIZED GAMMA
                GENERALIZED TOPP LEONE
                GENERALIZED TUKEY LAMBDA
                GOMPERTZ
                JOHNSON SB
                JOHNSON SU
                KUMARASWAMY
                INVERSE GAUSSIAN
                INVERTED BETA
                POWER LOGNORMAL
                RECIPROCAL INVERSE GAUSSIAN
                REFLECTED GENERALIZED TOPP LEONE
                TWO-SIDED OGIVE
                TWO-SIDED POWER
                TWO-SIDED SLOPE
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax estimates the two shape parameters using a PPCC plot
    and then estimates the location and scale parameters using a
    probability plot for each bootstrap sample.

    Note that for this plot can take a rather long time to
    generate for many of these distributions.

Syntax 7:
    BOOTSTRAP <dist> CENSORED PLOT <y> <x>
                     <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <x> is the censoring variable;
          <dist> is one of the distributions given in syntax 6;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax estimates the two shape parameters using a
    censored PPCC plot and then estimates the location and scale
    parameters using a censored probability plot for each bootstrap
    sample.  The censoring variable should contain a value of 1 to
    indicate a failure time and a value of 0 to indicate a censoring
    time.

Syntax 8:
    BOOTSTRAP <dist> MLE PLOT <y>  <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <dist> is one of the following distributions:
                CAUCHY
                EXPONENTIAL
                FOLDED NORMAL
                GUMBEL (EXTREME VALUE TYPE 1)
                LAPLACE (DOUBLE EXPONENTIAL)
                LOGISTIC
                MAXWELL
                NORMAL
                RAYLEIGH
                SLASH
                UNIFORM
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax estimates the location and scale parameters using
    maximum likelihood for each bootstrap sample.

Syntax 9:
    BOOTSTRAP <dist> CENSORED MLE PLOT <y> <x>
                     <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <x> is the censoring variable;
          <dist> is one of the following distributions:
                NORMAL
                EXPONENTIAL
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax estimates the location and scale parameters using
    maximum likelihood for each bootstrap sample.  The censoring
    variable should contain a value of 1 to indicate a failure
    time and a value of 0 to indicate a censoring time.

Syntax 10:
    BOOTSTRAP <dist> MLE PLOT <y>  <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <dist> is one of the following distributions:
                BETA
                BURR TYPE 10
                FATIGUE LIFE
                FRECHET
                GAMMA
                GENERALIZED PARETO
                GEOMETRIC EXTREME EXPONENTIAL
                INVERSE GAUSSIAN
                INVERTED WEIBULL
                LOGNORMAL
                PARETO
                WEIBULL
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax estimates the shape and scale parameters (the Beta,
    Pareto, and inverse Gaussian estimate the two shape parameters
    but no scale parameter) using maximum likelihood for each
    bootstrap sample.

Syntax 11:
    BOOTSTRAP <dist> CENSORED MLE PLOT <y> <x>
                     <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <x> is the censoring variable;
          <dist> is one of the following distributions:
                CENSORED GAMMA
                CENSORED LOGNORMAL
                CENSORED WEIBULL
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax estimates the location and scale parameters using
    maximum likelihood for each bootstrap sample.  The censoring
    variable should contain a value of 1 to indicate a failure
    time and a value of 0 to indicate a censoring time.

Syntax 12:
    BOOTSTRAP <dist> MLE PLOT <y>  <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <dist> is one of the following distributions:
                ASYMMETRIC LAPLACE
                TOPP AND LEONE
                GENERALIZED LOGISTIC TYPE 5
                TRIANGULAR
                POWER
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax estimates the shape, location, and scale parameters
    using maximum likelihood for each bootstrap sample.

    For the Topp and Leone distribution, the lower and upper
    limit parameters are estimated instead of location and scale.

Syntax 13:
    BOOTSTRAP <dist> MLE PLOT <y>  <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <dist> is one of the following distributions:
                BETA NORMAL
                REFLECTED GENERALIZED TOPP AND LEONE
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax estimates the two shape, location, and scale
    parameters using maximum likelihood for each bootstrap sample.

    For the reflected generalized Topp and Leone distribution, the
    lower and upper limit parameters can be specified by the user.
    Otherwise, the data minimum and maximum are used to estimate
    the lower and upper limit parameters.

Examples:
    BOOTSTRAP NORMAL PLOT Y
    BOOTSTRAP NORMAL MLE PLOT Y
    BOOTSTRAP WEIBULL PLOT Y
    BOOTSTRAP WEIBULL KS PLOT Y
    BOOTSTRAP WEIBULL CENSORED PLOT Y X

Note:
    The 2010/3 version of Dataplot updated the BOOTSTRAP PLOT command
    to include reports in addition to the plots.

    If the BOOTSTRAP PLOT is applied to a a distributional fit
    (e.g., BOOTSTRAP WEIBULL PPCC PLOT Y or BOOTSTRAP WEIBULL MLE
    PLOT Y), the following tables are generated:

       1) An initial summary table.

       2) A table containing percentile confidence limits for each of
          the parameters of the distribution for various levels of
          alpha.

       3) If the SET MAXIMUM LIKELIHOOD PERCENTILES command was
          given, a table containing confidence limits for the
          specified percentiles will be generated.

    The SET WRITE DECIMALS command can be used to specify the
    number of decimals to use in the tables and the CAPTURE HTML,
    CAPTURE LATEX, and CAPTURE RTF options are supported.

Note:
    The 2010/3 version of Dataplot updated the BOOTSTRAP PLOT command
    to support the ANDERSON DARLING goodness of fit statistic in
    addition to the KOLMOGOROV SMIRNOV goodness of fit statistic.
    For example,

        BOOTSTRAP WEIBULL ANDERSON DARLING PLOT Y

    The ANDERSON DARLING can be abbreviated as AD.  Like the
    KOLMOGOROV SMIRNOV case, it is only supported for continuous
    distributions and is not supported for censored data.

Note:
    The BOOTSTRAP PLOT command generates the estimates for the
    bootstrap samples.  Typically, these values are processed
    further for a complete bootstrap analysis.  To simplify this,
    Dataplot writes information to files.

    dpst1f.dat

    The estimates for each bootstrap sample are written to
    file dpst1f.dat.  You can read the variables written to
    dpst1f.dat to generate histograms and to compute selected
    percentiles.

    The order is:
        group id
        location parameter
        scale parameter
        first shape parameter
        second shape parameter
        ppcc (or ks) value

    If a particular syntax does not generate one or more of these
    values, then they are omitted (e.g., the normal distribution
    does not generate estimates for any shape parameters).

    The following example generates a Weibull bootstrap plot and
    then reads the bootstrap estimates from dpst1f.dat.

        WEIBULL BOOTSTRAP PLOT Y
        SKIP 0
        READ DPST1F.DAT ALOC ASCALE AGAMMA APPCC
        MULTIPLOT 2 2
        RELATIVE HISTOGRAM ALOC
        RELATIVE HISTOGRAM ASCALE
        RELATIVE HISTOGRAM AGAMMA
        RELATIVE HISTOGRAM APPCC
        END OF MULTIPLOT

    dpst2f.dat

    Selected percentiles are written to dpst2f.dat.  The order is:

       Group id          - omitted for ungrouped data
       Parameter number  - parameters are ordered as they are in
                           dpst1f.dat
       Mean
       Standard Deviation
       Median
        2.5 percentile
       97.5 percentile
        5.0 percentile
       95.0 percentile
        0.5 percentile
       99.5 percentile

Note:
    You can optionally specify that bootstrap estimates of
    selected percentiles be generated.  This option is off by
    default.

    If you enter the command

         SET MAXIMUM LIKELIHOOD PERCENTILES DEFAULT

    you will get bootstrap estimates for the following percentiles:

         0.5, 1.0, 2.5, 5.0, 10.0, 20.0, 30.0, 40.0, 50.0,
         60.0, 70.0, 80.0, 90.0, 95.0, 97.5, 99.0, 99.5

    If you would like to specify the specific percentiles to
    estimate, enter the command

         SET MAXIMUM LIKELIHOOD PERCENTILES YPERC

    with YPERC denoting a variable that contains the desired
    percentiles.

    This is demonstrated in the sample program below.

    By default, two sided confidence intervals are generated for
    the percentiles.  The following commands can be used to generate
    either lower one sided or upper one sided intervals

        SET BOOTSTRAP DISTRIBUTIONAL PERCENTILES LOWER
        SET BOOTSTRAP DISTRIBUTIONAL PERCENTILES UPPER

    To turn off the computation of the percentile confidence intervals,
    enter

        SET BOOTSTRAP DISTRIBUTIONAL PERCENTILES NONE

    To reset the default of two sided intervals, enter

        SET BOOTSTRAP DISTRIBUTIONAL PERCENTILES TWOSIDED

Note:
    As in the PPCC and KS plots, you can specify the range for
    shape parameter.  For example, to restrict the estimate of
    the shape parameter of a Weibull distribution to values between
    0.5 and 10, enter the commands

        LET GAMMA1 = 0.5
        LET GAMMA2 = 10
        BOOTSTRAP WEIBULL PLOT Y

    One recommendation is to generate the bootstrap plot for a
    relatively small number of samples (e.g., 50) and use that to
    determine a reasonable range for the shape parameter.

    Enter HELP PPCC PLOT to see the relevant parameter for the
    desired distribution.

    The SET PPCC PLOT AXIS POINTS command is also supported for
    the BOOTSTRAP PLOT command.

Note:
    The BOOTSTRAP PLOT supports ungrouped data, one group variable,
    or two group variables.  The distributional bootstrap plots
    do not currently support two group variables.

Note:
    Dataplot supports the BCA BOOTSTRAP PLOT option to generate
    more accurate confidence intervals.  BCa is an abbreviation
    for "acceleration" and "bias-correction". It provides
    second order accuracy (as oppossed to the first order
    accurary of the confidence intervals generated for the
    percentiles of the bootstrap samples).

    The BCA option is not currently supported for the bootstrap
    distributional plots.

Note:
    Some analysts prefer a different method for generating the
    bootstrap samples.

    The full sample is used to generate the parameter estimates
    of the distribution.  Then the bootstrap samples are generated
    by generating random numbers from the specified distribution
    using the parameters estimated from the full sample.

    The following command will specify this alternate method
    of bootstrapping be used:

        SET DISTRIBUTIONAL BOOTSTRAP PARAMETRIC

    To restore the default method of bootstrapping the data values,
    enter the command

        SET DISTRIBUTIONAL BOOTSTRAP NONPARAMETRIC

    The parameteric option is still being tested and may not work
    correctly for some of the distributions.

Note:
    The BOOTSTRAP SAMPLE command can be used to specify the
    desired number of bootstrap samples.  Recommended values
    are between 100 and 1,000.  The default is 100.

Default:
    None
 
Synonyms:
    KOLMOGOROV SMIRNOV is a synonym for KS
    MAXIMUM LIKELIHOOD is a synonym for MLE
 
Related Commands:
    BOOTSTRAP PLOT    = Generate a bootstrap plot.
    PPCC PLOT         = Generate a ppcc plot.
    KS PLOT           = Generate a ks plot.
    PROBABILITY PLOT  = Generate a probability plot.
    BOOTSTRAP PLOT    = Generate a bootstrap plot.
    JACKNIFE PLOT     = Generate a jacknife plot.
    BOOTSTRAP SAMP    = Set the sample size for the bootstrap
    BOOTSTRAP FIT     = Compute a bootstrap linear/multilinear fit.
    HISTOGRAM         = Generates a histogram.
    PLOT              = Generates a data/function plot.
 
Reference:
    "A Leisurely Look at the Bootstrap, the Jacknife, and
    Cross-Validation", Efron and Gong, The American Statistician,
    February, 1983.
 
    "An Introduction to the Bootstrap", Efron and Tibshirabi,
    Springer-Verlang, 1993.

Applications:
    Distributional Modeling
 
Implementation Date:
    2005/4:
 
Program 1:
    .
    .  Following Sample Macro demonstrates the use of the
    .  bootstrap with a Weibull distribution.
    .
    .  Step 0: Create some sample Weibull data
    .
    dimension 50 columns
    .
    let gamma = 2.3
    let y = weibull random numbers for i = 1 1 100
    .
    . Step 1: Perform PPCC/Probability Plot Analysis,
    .         Perform K-S goodness of fit test
    .
    multiplot 2 2
    multiplot corner coordinates 0 0 100 100
    multiplot scale factor 1.5
    y1label displacement 12
    .
    title Weibull PPCC Plot
    x1label Shape Parameter (gamma)
    y1label Correlation
    weibull ppcc plot y
    justification center
    move 50 28
    text Max PPCC Value: ^maxppcc
    move 50 23
    text Shape: ^shape
    let gamma1 = shape - 2
    if gamma1 <= 0
       let gamma1 = 0.1
    end of if
    let gamma2 = shape + 2
    title Weibull PPCC Plot
    weibull ppcc plot y
    move 50 28
    text Max PPCC Value: ^maxppcc
    move 50 23
    text Shape: ^shape
    let gamma = shape
    if n <= 200
       character x
       line blank
    else
       line solid
       character blank
    end of if
    .
    title Weibull Probability Plot
    x1label Theoretical
    y1label Data
    weibull probability plot y
    justification center
    move 50 6
    text Location:  ^ppa0, Scale:  ^ppa1
    move 50 1
    text Shape:  ^shape, PPCC:  ^ppcc
    let iplot = 3
    multiplot 2 2 iplot
    line solid
    character blank
    limits freeze
    pre-erase off
    let function f = ppa0 + ppa1*x
    let zmin = minimum xplot
    let zmax = maximum xplot
    let ainc2 = (zmax - zmin)/10
    plot f for x = zmin ainc2 zmax
    limits
    pre-erase on
    let iplot = iplot + 1
    multiplot 2 2 iplot
    title Histogram with Overlaid Weibull
    x1label Data Units
    y1label Density
    relative histogram y
    multiplot 2 2 iplot
    limits freeze
    pre-erase off
    let loc2=ppa0
    let scale2=ppa1
    line solid
    char blank
    line color blue
    let amin = minimum y
    let amax = maximum y
    let ainc = 0.1
    plot weipdf(x,shape,loc2,scale2) for x = amin ainc amax
    limits
    pre-erase on
    line color black
    end of multiplot
    delete gamma gamma1 gamma2
    .
    . Step 2: Now perform a bootstrap analysis
    .
    write " "
    write "BOOTSTRAP-BASED INTERVALS"
    write " "
    bootstrap samples 200
    set maximum likelihood percentiles default
    let gamma1 = 0.2
    let gamma2 = 6
    multiplot 2 3
    multiplot corner coordinates 0 0 100 100
    multiplot scale factor 1.7
    y1label Parameter Estimate
    x1label
    x2label Bootstrap Sample
    title Bootstrap Plot
    line color blue red green
    limits
    bootstrap weibull plot y
    line color black all
    .
    delete aloc ascale ashape appcc
    skip 0
    read dpst1f.dat aloc ascale ashape appcc
    y1label
    x2label
    x3label displacement 16
    title Location Parameter
    let amed = median aloc
    let amean = mean aloc
    let asd = sd aloc
    x2label Median = ^amed, Mean = ^amean
    x3label Standard Deviation = ^asd
    histogram aloc
    title Scale Parameter
    let amed = median ascale
    let amean = mean ascale
    let asd = sd ascale
    x2label Median = ^amed, Mean = ^amean
    x3label Standard Deviation = ^asd
    histogram ascale
    title Shape Parameter
    let amed = median ashape
    let amean = mean ashape
    let asd = sd ashape
    x2label Median = ^amed, Mean = ^amean
    x3label Standard Deviation = ^asd
    histogram ashape
    title PPCC Value
    let amed = median appcc
    let amean = mean appcc
    let asd = sd appcc
    x2label Median = ^amed, Mean = ^amean
    x3label Standard Deviation = ^asd
    histogram appcc
    x3label displacement
    .
    let alpha = 0.05
    let xqlow = alpha/2
    let xqupp = 1 - alpha/2
    .
    write "Bootstrap-based Confidence Intervals"
    write "alpha = ^alpha"
    write " "
    .
    let xq = xqlow
    let loc95low = xq quantile aloc
    let xq = xqupp
    let loc95upp = xq quantile aloc
    let xq = xqlow
    let sca95low = xq quantile ascale
    let xq = xqupp
    let sca95upp = xq quantile ascale
    let xq = xqlow
    let sha95low = xq quantile ashape
    let xq = xqupp
    let sha95upp = xq quantile ashape
    write "Confidence Interval for Location: (^loc95low,^loc95upp)"
    write "Confidence Interval for Scale:    (^sca95low,^sca95upp)"
    write "Confidence Interval for Gamma:    (^sha95low,^sha95upp)"
    .
    .  Now generate confidence intervals for percentiles
    .
    serial read p
    0.5 1 2.5 5 10 20 30 40 50 60 70 80 90 95 97.5 99 99.5
    end of data
    let nperc = size p
    skip 1
    read matrix dpst4f.dat  xqp
    write " "
    loop for k = 1 1 nperc
        let xqptemp = p(k)
        let amed = median xqp^k
        let xqpmed(k) = amed
        let xq = xqlow
        let atemp = xq quantile xqp^k
        let xq95low(k) = atemp
        let xq = xqupp
        let atemp = xq quantile xqp^k
        let xq95upp(k) = atemp
    end of loop
    set table title "Bootstrap Based Confidence Intervals for Percentiles"
    set table spacing 15
    set write decimals 7
    write " "
    write "Confidence Intervals for Percentiles"
    write p xqpmed xq95low xq95upp
    end of capture
    delete xqp xqpmed xq95low xq95upp
    delete gamma1 gamma2
    .

-----DISTRIBUTIONAL FIT PLOT (LET)--------------------------------
 
DISTRIBUTIONAL FIT PLOT
 
Name:
    DISTRIBUTIONAL FIT PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generate a tabulation plot based on the results of the
    BEST DISTRIBUTIONAL FIT command.

Description:
    The BEST DISTRIBUTIONAL FIT command generates a ranked list of best
    distributional fit for univariate data.  This is a screening tool to
    identify good candidate distributional models for the data.

    Often we have a number of related datasets.  The DISTRIBUTIONAL FIT
    PLOT provides a convenient way of graphically presenting the results
    of the BEST DISTRIBUTIONAL FIT command for these multiple datasets.
    Specifically, it creates a tabulation plot where the y-axis contains
    the distribution and the x-axis contains the distinct datasets.  That
    is, we can view a row of the plot to see how a particular
    distribution fits the various datasets and we can view a column to
    see which distributions fit a a particular dataset well.

    There are two steps in the distributional modeling:

        1) Fitting
        2) Computing a goodness of fit critierion

    You can specify the fit method with the command

         SET BEST FIT METHOD <value>

    where <value> is one of the following

         MAXIMUM LIKELIHOOD:        maximum likelihood
         PPCC:                      PPCC goodness of fit
         ANDERSON DARLING:          Anderson-Darling goodness of fit
         KOLMOGOROV SMIRNOV:        Kolmogorov-Smirnov goodness of fit

    The default method is maximum likelihood.

    You can specify the goodness of fit critierion with the command

         SET BEST FIT CRITERION <value>

    where <value> is one of the following

         ANDERSON DARLING:          Anderson-Darling
         KOLMOGOROV SMIRNOV:        Kolmogorov-Smirnov
         PPCC:                      PPCC
         AIC:                       Akaike Information Criterion
         AICc:                      Akaike Information Criterion with
                                    sample size adjustment
         BIC:                       Bayesian Information Critierion 

    The default goodness of fit criterion is Anderson-Darling.

    Once the matrix (rows represent distribtions, columns represent
    datasets) of goodness of fit statistics is computed, they are
    plotted in the form of a tabulation plot.  The tabulation plot is
    a mix between a fluctuation plot and a contour plot.

    For the fluctuation plot, at each grid position, two rectangles are
    drawn.  The first is drawn in a background color and is full size
    (i.e., the maximum value of the statistic).  A second rectangle is
    drawn in a foreground color with a height proportional to the value
    of the statistic for that particular combination of categories.

    For the tabulation plot, only one rectangle is drawn.  However, the
    color of the rectangle is based on the value of the statistic
    relative to a "levels" variable (hence the similarity to a
    contour plot).  The Program examples below demonstrate how to
    create and use the levels variable.  Note that defining good levels
    is somewhat problematic, so this plot is more useful for the PPCC,
    Anderson-Darling, and Kolmogorov-Smirnov goodness of fit statistics.

    The appearance of the tabulation plot is controlled by appropriate
    settings for the REGION, LINE, and CHARACTER settings.  This is
    demonstrated in the Program examples below.

    Note that not all of the options available for a standard
    TABULATION PLOT are supported for this command.

Syntax 1:
    DISTRIBUTIONAL FIT PLOT <y>  <x>  <ylevel>
                            <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <x> is a group-id variable;
          <ylevel> is a variable that defines the levels;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    For this syntax, the different datasets are identified by a
    group-id variable.

Syntax 2:
    MULTIPLE DISTRIBUTIONAL FIT PLOT <y1> ...  <yk>  <ylevel>
                            <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of 1 to 30 response variables;
          <ylevel> is a variable that defines the levels;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    For this syntax, the different datasets are identified with
    separate response variables.

Syntax 3:
    REPLICATED DISTRIBUTIONAL FIT PLOT <y>  <x1> ... <xk>  <ylevel>
                            <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <x1> ... <x6> is a list of 1 to 6 group-id variables;
          <ylevel> is a variable that defines the levels;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    The group-id variables are cross-tabulated and a dataset is defined
    for each distinct combination of values for the group-id variables.
 
    For the REPLICATED case, you can control the spacing between
    groups.  Internally, Dataplot uses the CODE CROSS TABULATE
    command to generate a single combined group-id variable.  Enter
    HELP CODE CROSS TABULATE for details on how to control the
    spacing (the SET commands used by CODE CROSS TABULATE are
    supported for the DISTRIBUTIONAL FIT PLOT command).

Examples:
    DISTRIBUTIONAL FIT PLOT Y X
    MULTIPLE DISTRIBUTIONAL FIT PLOT Y1 TO Y8
    REPLICATED DISTRIBUTIONAL FIT PLOT Y X1 X2
    DISTRIBUTIONAL FIT PLOT Y X  SUBSET X < 8

Note:
    The following command was added

       SET TABULATION PLOT CODED <ON/OFF>

    By default (= ON), each factor variable is coded from 1 to
    NDIST with NDIST denoting the number of levels (i.e., distinct
    values for that factor variable.

    When this switch is set to OFF, the x-axis variable is plotted
    in the units of group-id variable.  This can be useful if you
    want to add spacing between some groups of data or if you have
    missing groups that you want the plot to clearly show.

    This command does not apply for Syntax 2 (the MULTIPLTE option).

Note:
    The 2020/05 version of Dataplot added the ability to specify which
    distributions to include.  The following commands were added

       SET BEST FIT DISTRIBUTION NORMAL <ON/OFF>
       SET BEST FIT DISTRIBUTION LOGISTIC <ON/OFF>
       SET BEST FIT DISTRIBUTION LOG LOGISTIC <ON/OFF>
       SET BEST FIT DISTRIBUTION HYPERBOLIC SECANT <ON/OFF>
       SET BEST FIT DISTRIBUTION UNIFORM <ON/OFF>
       SET BEST FIT DISTRIBUTION POWER <ON/OFF>
       SET BEST FIT DISTRIBUTION ARCSINE <ON/OFF>
       SET BEST FIT DISTRIBUTION TRIANGULAR <ON/OFF>
       SET BEST FIT DISTRIBUTION ERROR <ON/OFF>
       SET BEST FIT DISTRIBUTION SLASH <ON/OFF>
       SET BEST FIT DISTRIBUTION CAUCHY <ON/OFF>
       SET BEST FIT DISTRIBUTION COSINE <ON/OFF>
       SET BEST FIT DISTRIBUTION BRADFORD <ON/OFF>
       SET BEST FIT DISTRIBUTION ANGLIT <ON/OFF>
       SET BEST FIT DISTRIBUTION RAYLEIGH <ON/OFF>
       SET BEST FIT DISTRIBUTION FOLDED NORMAL <ON/OFF>
       SET BEST FIT DISTRIBUTION TUKEY LAMBDA <ON/OFF>
       SET BEST FIT DISTRIBUTION GENERALIZED TUKEY LAMBDA <ON/OFF>
       SET BEST FIT DISTRIBUTION DOUBLE GAMMA <ON/OFF>
       SET BEST FIT DISTRIBUTION DOUBLE WEIBULL <ON/OFF>
       SET BEST FIT DISTRIBUTION REFLECTED POWER <ON/OFF>
       SET BEST FIT DISTRIBUTION TWO SIDED POWER <ON/OFF>
       SET BEST FIT DISTRIBUTION TOPP AND LEONE <ON/OFF>
       SET BEST FIT DISTRIBUTION REFLECTED GENERALIZED TOPP AND LEONE <ON/OFF>
       SET BEST FIT DISTRIBUTION GENERALIZED EXTREME VALUE MINIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION GENERALIZED EXTREME VALUE MAXIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION PARETO <ON/OFF>
       SET BEST FIT DISTRIBUTION GENERALIZED PARETO MINIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION GENERALIZED PARETO MAXIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION G AND H <ON/OFF>
       SET BEST FIT DISTRIBUTION G <ON/OFF>
       SET BEST FIT DISTRIBUTION INVERTED WEIBULL <ON/OFF>
       SET BEST FIT DISTRIBUTION GAMMA <ON/OFF>
       SET BEST FIT DISTRIBUTION LOG GAMMA <ON/OFF>
       SET BEST FIT DISTRIBUTION INVERTED GAMMA <ON/OFF>
       SET BEST FIT DISTRIBUTION FATIGUE LIFE <ON/OFF>
       SET BEST FIT DISTRIBUTION WALD <ON/OFF>
       SET BEST FIT DISTRIBUTION LOGISTIC EXPONENTIAL <ON/OFF>
       SET BEST FIT DISTRIBUTION GEOMETRIC EXTREME EXPONENTIAL <ON/OFF>
       SET BEST FIT DISTRIBUTION LOG DOUBLE EXPONENTIAL <ON/OFF>

       SET BEST FIT DISTRIBUTION TWO PARAMETER LOGNORMAL <ON/OFF>
       SET BEST FIT DISTRIBUTION 2 PARAMETER LOGNORMAL <ON/OFF>

       SET BEST FIT DISTRIBUTION THREE PARAMETER LOGNORMAL <ON/OFF>
       SET BEST FIT DISTRIBUTION 3 PARAMETER LOGNORMAL <ON/OFF>

       SET BEST FIT DISTRIBUTION TWO PARAMETER EXPONENTIAL <ON/OFF>
       SET BEST FIT DISTRIBUTION 2 PARAMETER EXPONENTIAL <ON/OFF>
       SET BEST FIT DISTRIBUTION EXPONENTIAL <ON/OFF>

       SET BEST FIT DISTRIBUTION TWO PARAMETER WEIBULL MINIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION 2 PARAMETER WEIBULL MINIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION TWO PARAMETER WEIBULL <ON/OFF>
       SET BEST FIT DISTRIBUTION 2 PARAMETER WEIBULL <ON/OFF>

       SET BEST FIT DISTRIBUTION TWO PARAMETER WEIBULL MAXIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION 2 PARAMETER WEIBULL MAXIMUM <ON/OFF>

       SET BEST FIT DISTRIBUTION THREE PARAMETER WEIBULL MINIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION 3 PARAMETER WEIBULL MINIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION THREE PARAMETER WEIBULL <ON/OFF>
       SET BEST FIT DISTRIBUTION 3 PARAMETER WEIBULL <ON/OFF>

       SET BEST FIT DISTRIBUTION THREE PARAMETER WEIBULL MAXIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION 3 PARAMETER WEIBULL MAXIMUM <ON/OFF>

       SET BEST FIT DISTRIBUTION ONE PARAMETER EXPONENTIAL <ON/OFF>
       SET BEST FIT DISTRIBUTION 1 PARAMETER EXPONENTIAL <ON/OFF>

       SET BEST FIT DISTRIBUTION ASYMMETRIC DOUBLE EXPONENTIAL <ON/OFF>
       SET BEST FIT DISTRIBUTION ASYMMETRIC LAPLACE <ON/OFF>

       SET BEST FIT DISTRIBUTION DOUBLE EXPONENTIAL <ON/OFF>
       SET BEST FIT DISTRIBUTION LAPLACE <ON/OFF>

       SET BEST FIT DISTRIBUTION BURR TYPE TEN <ON/OFF>
       SET BEST FIT DISTRIBUTION BURR TYPE 10 <ON/OFF>

       SET BEST FIT DISTRIBUTION TWO PARAMETER INVERSE GAUSSIAN <ON/OFF>
       SET BEST FIT DISTRIBUTION 2 PARAMETER INVERSE GAUSSIAN <ON/OFF>

       SET BEST FIT DISTRIBUTION THREE PARAMETER INVERSE GAUSSIAN <ON/OFF>
       SET BEST FIT DISTRIBUTION 3 PARAMETER INVERSE GAUSSIAN <ON/OFF>

       SET BEST FIT DISTRIBUTION THREE PARAMETER LOGNORMAL <ON/OFF>
       SET BEST FIT DISTRIBUTION 3 PARAMETER LOGNORMAL <ON/OFF>

       SET BEST FIT DISTRIBUTION TWO PARAMETER EXPONENTIAL <ON/OFF>
       SET BEST FIT DISTRIBUTION GUMBEL MINIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION GUMBEL MAXIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION EXTREME VALUE TYPE 1 MINIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION EXTREME VALUE TYPE 1 MAXIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION EXTREME VALUE TYPE I MINIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION EXTREME VALUE TYPE I MAXIMUM <ON/OFF>

       SET BEST FIT DISTRIBUTION FRECHET MINIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION FRECHET MAXIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION EXTREME VALUE TYPE TWO MINIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION EXTREME VALUE TYPE TWO MAXIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION EXTREME VALUE TYPE II MINIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION EXTREME VALUE TYPE II MAXIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION EXTREME VALUE TYPE 2 MINIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION EXTREME VALUE TYPE 2 MAXIMUM <ON/OFF>

       SET BEST FIT DISTRIBUTION TWO PARAMETER BETA <ON/OFF>
       SET BEST FIT DISTRIBUTION 2 PARAMETER BETA <ON/OFF>

       SET BEST FIT DISTRIBUTION FOUR PARAMETER BETA <ON/OFF>
       SET BEST FIT DISTRIBUTION 4 PARAMETER BETA <ON/OFF>

       SET BEST FIT DISTRIBUTION ONE PARAMETER HALF NORMAL <ON/OFF>
       SET BEST FIT DISTRIBUTION 1 PARAMETER HALF NORMAL <ON/OFF>

       SET BEST FIT DISTRIBUTION TWO PARAMETER HALF NORMAL <ON/OFF>
       SET BEST FIT DISTRIBUTION 2 PARAMETER HALF NORMAL <ON/OFF>
       SET BEST FIT DISTRIBUTION HALF NORMAL <ON/OFF>

       SET BEST FIT DISTRIBUTION ONE PARAMETER HALF LOGISTIC <ON/OFF>
       SET BEST FIT DISTRIBUTION 1 PARAMETER HALF LOGISTIC <ON/OFF>

       SET BEST FIT DISTRIBUTION TWO PARAMETER HALF LOGISTIC <ON/OFF>
       SET BEST FIT DISTRIBUTION 2 PARAMETER HALF LOGISTIC <ON/OFF>
       SET BEST FIT DISTRIBUTION HALF LOGISTIC <ON/OFF>

       SET BEST FIT DISTRIBUTION TWO COMPONENT NORMAL MIXTURE <ON/OFF>
       SET BEST FIT DISTRIBUTION 2 COMPONENT NORMAL MIXTURE <ON/OFF>

    The following resets the default list of distributions

       SET BEST FIT DISTRIBUTION ALL
       SET BEST FIT DISTRIBUTION DEFAULT

    The following turns off all the distributions.  If you have a small
    set of distributions, you can enter one of these commands first and
    then use the above commands to turn on the specific distributions
    you want to include

       SET BEST FIT DISTRIBUTION NONE
       SET BEST FIT DISTRIBUTION OFF

Default:
    None
 
Synonyms:
    None

Related Commands:
    BEST DISTRIBUTIONAL FIT       = Generate a ranked list of best
                                    distributional fit.
    GOODNESS OF FIT               = Perform a distributional goodness of
                                    fit.
    TABULATION PLOT               = Generate a tabulation plot.
    FLUCTUATION PLOT              = Generate a fluctuation plot.
    CONTOUR PLOT                  = Generate a contour plot.

Applications:
    Distributional Modeling
 
Implementation Date:
    2014/9
    2020/05: Added support for specifying which distributions to include
 
Program 1:
    .
    . Step 1:   Read the data
    .
    skip 25
    read exp.dat       y1
    read weibbury.dat  y2
    read lgn.dat       y3
    read gamma.dat     y4
    read gumbel.dat    y5
    skip 0
    .
    let string dist1 = EXP.DAT
    let string dist2 = WEIBBURY.DAT
    let string dist3 = LGN.DAT
    let string dist4 = GAMMA.DAT
    let string dist5 = GUMBEL.DAT
    .
    . Step 2:   Set basic plot control features
    .
    case asis
    title case asis
    label case asis
    tic mark label case asis
    title offset 1
    title size 1.8
    xlimits 1 5
    major xtic mark number 5
    minor xtic mark number 0
    x1tic mark offset 0.5 0.5
    x1tic mark label format alpha
    x1tic mark label content  ^dist1 ^dist2 ^dist3 ^dist4 ^dist5
    y1tic mark offset 1 1
    y1tic mark label size 1.3
    frame corner coordinates 15 15 80 93
    .
    . Step 3:   Define the plot levels
    .
    let p1 = 0.95
    let p2 = 0.96
    let p3 = 0.97
    let p4 = 0.98
    let p5 = 0.985
    let p6 = 0.990
    let p7 = 0.995
    let p8 = 1.0001
    let ylevel = data p1 p2 p3 p4 p5 p6 p7 p8
    .
    let ncolor = 8
    let string color1 = red
    let string color2 = orange
    let string color3 = tan
    let string color4 = yellow
    let string color5 = green
    let string color6 = dgreen
    let string color7 = lblue
    let string color8 = blue
    .
    . Step 4:   Define options and generate the plot
    .
    region fill on all
    region fill color   ^color1 ^color2 ^color3 ^color4 ^color5 ^color6 ...
                        ^color7 ^color8
    line color          white all
    .
    set write decimals 5
    set best fit method     ppcc
    set best fit criterion  ppcc
    .
    title Distributional Fit (PPCC Fit, PPCC Goodness of Fit)
    multiple distributional fit  plot y1 to y5 ylevel
    .
    . Step 5:   Draw the legend box
    .
    box fill pattern solid
    box shadow hw 0 0
    justification left
    height 1.7
    .
    let xcoor1 = 81
    let xcoor2 = 85
    let xcoor3 = xcoor2 + 1
    let ycoor1 = 93
    let yinc   = 4
    let ycoor2 = ycoor1 - yinc
    let kind = ncolor
    .
    loop for k = 1 1 ncolor
        box fill color ^color^kind
        box xcoor1 ycoor1 xcoor2 ycoor2
        let ycoor3 = ycoor2 + 1
        move xcoor3 ycoor3
        let km1 = kind - 1
        let aval1 = ^p^km1
        let aval2 = ^p^kind
        let aval2 = min(1,aval2)
        if k < ncolor
           if k = 1
              text ^aval1 - ^aval2
           else
              text ^aval1 - ^aval2
          end of if
        else
          text <= ^aval1
        end of if
        let ycoor1 = ycoor2
        let ycoor2 = ycoor1 - yinc
        let kind = kind - 1
    end of loop

Program 2:
    .
    . Step 1:   Read the data
    .
    skip 25
    read exp.dat       y1
    read weibbury.dat  y2
    read lgn.dat       y3
    read gamma.dat     y4
    read gumbel.dat    y5
    skip 0
    .
    let string dist1 = EXP.DAT
    let string dist2 = WEIBBURY.DAT
    let string dist3 = LGN.DAT
    let string dist4 = GAMMA.DAT
    let string dist5 = GUMBEL.DAT
    .
    . Step 2:   Set basic plot control features
    .
    case asis
    title case asis
    label case asis
    tic mark label case asis
    title offset 1
    title size 1.8
    xlimits 1 5
    major xtic mark number 5
    minor xtic mark number 0
    x1tic mark offset 0.5 0.5
    x1tic mark label format alpha
    x1tic mark label content  ^dist1 ^dist2 ^dist3 ^dist4 ^dist5
    y1tic mark offset 1 1
    y1tic mark label size 1.3
    frame corner coordinates 15 15 80 93
    y1tic mark offset 1 1
    y1tic mark label size 1.3
    .
    . Step 3:   Define the plot levels
    .
    let p1 = 0.25
    let p2 = 0.50
    let p3 = 0.75
    let p4 = 1.0
    let p5 = 1.5
    let p6 = 2.0
    let p7 = 5.0
    let p8 = 10000
    let ylevel = data p1 p2 p3 p4 p5 p6 p7 p8
    .
    let ncolor = 8
    let string color1 = blue
    let string color2 = lblue
    let string color3 = dgreen
    let string color4 = green
    let string color5 = yellow
    let string color6 = tan
    let string color7 = orange
    let string color8 = red
    .
    . Step 4:   Define plot options and generate the plot
    .
    set write decimals 5
    set best fit method     ml
    set best fit criterion  anderson darling
    .
    region fill on all
    region fill color   ^color1 ^color2 ^color3 ^color4 ^color5 ^color6 ...
                        ^color7 ^color8
    line color          white all
    .
    title Distributional Fit (ML Fit, Anderson-Darling Goodness of Fit)
    multiple distributional fit  plot y1 to y5  ylevel
    .
    . Step 5:   Add some labels and draw the legend box
    .
    box fill pattern solid
    box shadow hw 0 0
    justification left
    height 1.7
    .
    let xcoor1 = 81
    let xcoor2 = 85
    let xcoor3 = xcoor2 + 1
    let ycoor1 = 93
    let yinc   = 4
    let ycoor2 = ycoor1 - yinc
    .
    loop for k = 1 1 ncolor
        box fill color ^color^k
        box xcoor1 ycoor1 xcoor2 ycoor2
        let ycoor3 = ycoor2 + 1
        move xcoor3 ycoor3
        if k = 1
           text <= ^p1
        else if k = ncolor
           let km1 = k - 1
           text >= ^p^km1
        else
           let km1 = k - 1
           text ^p^km1 - ^p^k
        end of if
        let ycoor1 = ycoor2
        let ycoor2 = ycoor1 - yinc
    end of loop

-----DISTRIBUTIONAL LIKELIHOOD RATIO TEST---------------------------------
 
DISTRIBUTIONAL LIKELIHOOD RATIO TEST
 
Name:
    DISTRIBUTIONAL LIKELIHOOD RATIO TEST
 
Type:
    Analysis Command
 
Purpose:
    Distinguish which of two specified distributions better fit a data set
    based on the likelihood ratio test.
 
Description:
    In many cases, several distributions may provide adequate fit for a
    given data set.  This test provides a method for selecting between
    two specific distributions.  This test is somewhat different than
    the Kolmogorov-Smirnov (K-S) and Anderson-Darling (A-D) goodness of
    fit tests.  The K-S and A-D tests have a null hypothesis that the
    data come from a single specific distribution with the alternative
    hypothesis that the data do not come from that distribution (i.e.,
    there is no specific alternative distribution).  On the other hand,
    the likelihood ratio test has a null hypothesis that the data come
    from distribution A against the alternative that they come from
    distribution B.  With the likelihood ratio test, it may be that both
    distributions pass a K-S or A-D test or both fail a K-S or A-D test
    or one passes and one fails.

    The likelihood ratio test given here was proposed by Dumonceaux,
    Antle, and Haas.  The basic algorithm is as follows:

        1. Fit the data to both distributions using maximum likelihood.

        2. Compute the likelihood function for both distributions and
           then form the ratio of these likelihoods.  Note that the
           distribution given in the null hypothesis is used for the
           denominator and the distribution given in the alternative
           hypothesis is used for the numerator.  This ratio is the
           test statistic.

        3. Critical values are determined via simulation.  Specifically,
           10,000 runs are simulated from the distribution given in the
           null hypothesis.  The location and scale parametes will be
           set to 0 and 1, respectively.  If there are shape parameters,
           these will be set to estimates obtained from the maximum
           likelihood fit of the original data.

    Currently, Dataplot only supports this test for uncensored and
    ungrouped data from continuous distributions.  Also, Dataplot only
    supports this command for distributions for which it supports
    maximum likelihood estimation.

    Dumonceaux, Antle, and Haas proposed some simplified tests for a few
    specific cases.  Dataplot supports the following specific cases:

         1. H0: Normal,             Ha: Exponential
         2. H0: Exponential,        Ha: Normal
         3. H0: Normal,             Ha: Double Exponential
         4. H0: Double Exponential, Ha: Normal

    It is also important to note that it matters which distribution is
    specified for the null hypothesis and which is specified for the
    alternative hypothesis.  The power of the test is estimated by running
    5,000 simulations from the alternative hypothesis distribution
    (as with the critical values, location and scale parameters are set
    to 0 and 1, respectively, and the shape parameter is obtained from the
    maximum likelihood fit).  When the power is relatively low, the
    distribution specified in the null hypothesis may be favored.  For
    example, suppose you are testing a Weibull and a lognormal.  It is
    quite possible that if the Weibull is given as the null hypothesis 
    distribution that the null hypothesis will not be rejected and likewise
    if the lognormal is given as the null hypothesis it will not be
    rejected either.

Syntax 1:
    <dist1> AND <dist2> DISTRIBUTIONAL LIKELIHOOD  TEST  <y>
                        <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Syntax 2:
    <dist1> AND <dist2> MULTIPLE DISTRIBUTIONAL LIKELIHOOD TEST
                        <y1> ... <yk>   <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of up to 30 response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax will generate the test for each of the listed response
    variables.  Although the word MULTIPLE is optional, it can be
    useful to distinguish this from the REPLICATED case.

    Note that the syntax

         <dist1> AND <dist2> MULTIPLE DISTRIBUTIONAL LIKELIHOOD RATIO ...
                             TEST Y1 TO Y4

    is supported.  This is equivalent to

         <dist1> AND <dist2> MULTIPLE DISTRIBUTIONAL LIKELIHOOD RATIO MULTIPLE ...
                             TEST Y1 Y2 Y3 Y4

Syntax 3:
    <dist1> AND <dist2> REPLICATED DISTRIBUTIONAL LIKELIHOOD TEST
                        <y>  <x1> ... <xk>
                        <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <x1> ... <xk> is a list of one to six group-id variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax peforms a cross-tabulation of <x1> ... <xk> and performs
    the test for each unique combination of cross-tabulated values.  For
    example, if X1 has 3 levels and X2 has 2 levels, there will be a total
    of 6 likelihood ratio tests performed.

    The word REPLICATED is required to distinguish the replication case
    from the multiple case (if there are multiple variables and neither
    MULTIPLE or REPLICATED is specified, Dataplot assumes MULTIPLE).

    Note that the syntax

         <dist1> AND <dist2> REPLICATED DISTRIBUTIONAL LIKELIHOOD RATIO ...
                             TEST Y X1 TO X4

    is supported.  This is equivalent to

         <dist1> AND <dist2> REPLICATED DISTRIBUTIONAL LIKELIHOOD RATIO ...
                             TEST Y X1 X2 X3 X4

Examples:
    NORMAL AND EXPONENTIAL DISTRIBUTIONAL LIKELIHOOD RATIO TEST Y1
    NORMAL AND EXPONENTIAL MULTIPLE DISTRIBUTIONAL LIKELIHOOD RATIO TEST Y1 TO Y5
    NORMAL AND EXPONENTIAL REPLICATED  DISTRIBUTIONAL LIKELIHOOD RATIO TEST Y X
    NORMAL AND EXPONENTIAL DISTRIBUTIONAL LIKELIHOOD RATIO TEST Y1  SUBSET Y1 > 0

Note:
    For a list of supported distributions (i.e., for which Dataplot
    supports maximum likelihood) enter the command

         HELP MAXIMUM LIKELIHOOD

Note:
    If both distributions are single word names (e.g., NORMAL and
    EXPONENTIAL), then the word AND is optional.  However, if at least one
    of the distributions has multiple words (e.g., 3-PARAMETER WEIBULL),
    then the word AND is required.

    The word TEST is optional.

Note:
    Although the Dumonceaux, Antle, and Haas papers provide some tables
    for a few specific cases, Dataplot generates the critical values and
    power values by running the simulations dynamically.  Due to the use
    of different random number generators, there may be some small
    differences between the Dataplot results and the tables in the
    papers.  These differences should not have much practical importance.

Note:
    You can specify the number of digits in the output with the command

        SET WRITE DECIMALS <value>

Note:
    The DISTRIBUTIONAL LIKEHOOD RATIO TEST command automatically saves the following
    parameters:

       STATVAL    = the value of the test statistic
       STATCDF    = the CDF of the test statistic
       PVALUE     = the p-value of the test statistic
       CUTOFF90   = the 90 percent point of the reference distribution
       CUTOFF95   = the 95 percent point of the reference distribution
       CUTOFF99   = the 99 percent point of the reference distribution
       POWER90    = the power corresponding to the 90 percent point of
                    the reference distribution
       POWER95    = the power corresponding to the 95 percent point of
                    the reference distribution
       POWER99    = the power corresponding to the 99 percent point of
                    the reference distribution

    If the MULTIPLE or REPLICATED option is used, these values will
    be written to the file "dpst1f.dat" instead.

Default:
    None
 
Synonyms:
    DISTRIBUTIONAL LIKELIHOOD RATIO MULTIPLE is a synonym for
                   MULTIPLE DISTRIBUTIONAL LIKELIHOOD RATIO
    DISTRIBUTIONAL LIKELIHOOD RATIO REPLICATED is a synonym for
                   REPLICATED DISTRIBUTIONAL LIKELIHOOD RATIO
 
Related Commands:
    MAXIMUM LIKELIHOOD       = Computes maximum likelihood estimates for
                               distributional fits.
    GOODNESS OF FIT          = Performs Kolmogorov-Smirnov,
                               Anderson-Darling, chi-square, and PPCC
                               goodness of fit tests.
    BEST DISTRIBUTIONAL FIT  = Ranks distributional fits for many common
                               distributions.
    KAPPENMAN R              = Generate Kappenman's statistic for
                               distinguishing between a lognormal and a
                               Weibull distributional model.
    PROBABILITY PLOT         = Generates a probability plot.
 
Reference:
     Dumonceaux, Antle and Haas (1973), "Likelihood Ratio Test for
     Discrimination Between Two Models with Unknown Location and Scale
     Parameters", Technometrics, Vol. 15, No. 1, pp. 19-27.

     Dumonceaux and Antle (1973), "Discrimination Between the Log-Normal
     and Weibull Distributions", Technometrics, Vol. 15, No. 4,
     pp. 923-926.

Applications:
    Distributional Models
 
Implementation Date:
    2014/05
 
Program 1:
    . Step 1:   Create the data for the example on page 25 of the
    .           Dumonceaux, Antle, and Hass Technometrics paper
    .
    serial read y
    35.15  44.62  40.85  45.32  36.08
    38.97  32.48  34.36  38.05  26.84
    33.68  42.90  33.57  36.64  33.82
    42.26  37.88  38.57  32.05  41.50
    end of data
    .
    . Step 2:   Perform Test
    .
    set write decimals 4
    normal and exponential distributional likelihood ratio test y
    normal and double exponential distributional likelihood ratio test y

Program 2:
    . Step 1:   Create the data for the example on page 22 of the
    .           Dumonceaux, Antle, and Hass Technometrics paper
    .
    let y = data 47 38 29 92 41 44 47 62 59 44 47 41
    .
    . Step 2:   Perform Test
    .
    set write decimals 4
    normal and cauchy distributional likelihood ratio test y

Program 3:
    . Step 1:   Create the data for the example on page 926 of the
    .           Dumonceaux and Antle Technometrics paper
    .
    serial read y
    0.654  0.613  0.315  0.449  0.297  0.402  0.379  0.423  0.379  0.3235
    0.269  0.740  0.418  0.412  0.494  0.416  0.338  0.392  0.484  0.265
    end of data
    .
    . Step 2:   Perform Test
    .
    set write decimals 4
    normal and gumbel distributional likelihood ratio test y

Program 4:
    . Step 1:   Create the data for the example on page 925 of the
    .           Dumonceaux and Antle Technometrics paper
    .
    serial read y
     17.88  28.92  33.00  41.52  42.12  45.60
     48.48  51.84  51.96  54.12  55.56  67.80
     68.64  68.64  68.88  84.12  93.12  98.64
    105.12 105.84 127.92 128.04 173.40
    end of data
    .
    . Step 2:   Perform Test
    .
    set write decimals 4
    lognormal and weibull distributional likelihood ratio test y
    weibull and lognormal distributional likelihood ratio test y

-----DIWCDF (LET)--------------------------------
 
DIWCDF
 
Name:
    DIWCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the discrete Weibull cumulative distribution
    function.
 
Description:
    The discrete Weibull distribution has the following
    cumulative distribution function:

       F(x;q,beta) = 1 - (q)**((x+1)**beta)
                     x = 0, 1, 2, ...;
                     0 < q < 1;  beta > 0

    with q and beta denoting the shape parameters.
 
Syntax:
    LET <y> = DIWCDF(<x>,<q>,<beta>) 
               <SUBSET/EXCEPT/FOR qualification>
    where <x> is a positive integer variable, number, or parameter;
          <q> is a number, parameter, or variable in the range 
               (0,1) that specifies the first shape parameter;
          <beta> is a number, parameter, or variable that
               specifies the second shape parameter;
          <y> is a variable or a parameter (depending on what <x>
               is) where the computed discrete Weibull
               cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIWCDF(3,0.5,0.5)
    LET Y = DIWCDF(X,0.3,0.7)
    PLOT DIWCDF(X,0.6,0.4) FOR X = 1  1  20

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DIWPDF                   = Compute the discrete Weibull
                               probability mass function.
    DIWPPF                   = Compute the discrete Weibull
                               percent point function.
    GLSPDF                   = Compute the generalized logarithmic
                               series probability mass function.
    WEIPDF                   = Compute the Weibull probability
                               density function.
    LGNPDF                   = Compute the lognormal probability
                               density function.
    EXPPDF                   = Compute the exponential probability
                               density function.
    POIPDF                   = Compute the Poisson probability
                               mass function.
    BINPDF                   = Compute the binomial probability
                               mass function.
Reference:
    Johnson, Kemp, and Kotz (2005), "Univariate Discrete
    Distributions", Third Edition, Wiley, pp. 510-511.

    Nakagawa and Osaki (1975), "The Discrete Weibull
    Distribution", IEEE Transactions on Reliability,
    R-24, pp. 300-301.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/8
 
Program:
    title size 3
    tic label size 3
    label size 3
    legend size 3
    height 3
    x1label displacement 12
    y1label displacement 15
    .
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    label case asis
    title case asis
    case asis
    tic offset units screen
    tic offset 3 3
    title displacement 2
    y1label Probability
    x1label X
    .
    ylimits 0 1
    major ytic mark number 6
    minor ytic mark number 3
    xlimits 0 20
    line blank
    spike on
    .
    multiplot 2 2
    .
    title Q = 0.3, Beta = 0.3
    plot diwcdf(x,0.3,0.3) for x = 1 1 20
    .
    title Q = 0.5, Beta = 0.5
    plot diwcdf(x,0.5,0.5) for x = 1 1 20
    .
    title Q = 0.7, Beta = 0.7
    plot diwcdf(x,0.7,0.7) for x = 1 1 20
    .
    title Q = 0.9, Beta = 0.9
    plot diwcdf(x,0.9,0.9) for x = 1 1 20
    .
    end of multiplot
    .
    justification center
    move 50 97
    text Cumulative Distribution Functions for Discrete Weibull

-----DIWHAZ (LET)--------------------------------
 
DIWHAZ
 
Name:
    DIWHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the discrete Weibull hazard function.
 
Description:
    The discrete Weibull distribution has the following
    hazard function:

       h(x;q,beta) = 1 - (q)**(x+1)**beta/(q)**(x**beta)
                     x = 0, 1, 2, ...;
                     0 < q < 1;  beta > 0

    with q and beta denoting the shape parameters.
 
Syntax:
    LET <y> = DIWHAZ(<x>,<q>,<beta>) 
               <SUBSET/EXCEPT/FOR qualification>
    where <x> is a positive integer variable, number, or parameter;
          <q> is a number, parameter, or variable in the range 
               (0,1) that specifies the first shape parameter;
          <beta> is a number, parameter, or variable that
               specifies the second shape parameter;
          <y> is a variable or a parameter (depending on what <x>
               is) where the computed discrete Weibull
               hazard value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIWHAZ(3,0.5,0.5)
    LET Y = DIWHAZ(X,0.3,0.7)
    PLOT DIWHAZ(X,0.6,0.4) FOR X = 1  1  20

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DIWCDF                   = Compute the discrete Weibull
                               cumulative distribution function.
    DIWPDF                   = Compute the discrete Weibull
                               probability mass function.
    DIWPPF                   = Compute the discrete Weibull
                               percent point function.
    GLSPDF                   = Compute the generalized logarithmic
                               series probability mass function.
    WEIPDF                   = Compute the Weibull probability
                               density function.
    LGNPDF                   = Compute the lognormal probability
                               density function.
    EXPPDF                   = Compute the exponential probability
                               density function.
    POIPDF                   = Compute the Poisson probability
                               mass function.
    BINPDF                   = Compute the binomial probability
                               mass function.
Reference:
    Johnson, Kemp, and Kotz (2005), "Univariate Discrete
    Distributions", Third Edition, Wiley, pp. 510-511.

    Nakagawa and Osaki (1975), "The Discrete Weibull
    Distribution", IEEE Transactions on Reliability,
    R-24, pp. 300-301.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/8
 
Program:
    title size 3
    tic label size 3
    label size 3
    legend size 3
    height 3
    x1label displacement 12
    y1label displacement 15
    .
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    label case asis
    title case asis
    case asis
    tic offset units screen
    tic offset 3 3
    title displacement 2
    y1label Hazard
    x1label X
    .
    xlimits 0 20
    line blank
    spike on
    .
    multiplot 2 2
    .
    title Q = 0.3, Beta = 0.3
    plot DIWHAZ(x,0.3,0.3) for x = 1 1 20
    .
    title Q = 0.5, Beta = 0.5
    plot DIWHAZ(x,0.5,0.5) for x = 1 1 20
    .
    title Q = 0.7, Beta = 0.7
    plot DIWHAZ(x,0.7,0.7) for x = 1 1 20
    .
    title Q = 0.9, Beta = 0.9
    plot DIWHAZ(x,0.9,0.9) for x = 1 1 20
    .
    end of multiplot
    .
    justification center
    move 50 97
    text Hazard Functions for Discrete Weibull

-----DIWPDF (LET)--------------------------------
 
DIWPDF
 
Name:
    DIWPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the discrete Weibull probability mass function.
 
Description:
    The discrete Weibull distribution has the following
    probability mass function:

       p(x;q,beta) = (q)**(x**beta) - (q)**((x+1)**beta)
                     x = 0, 1, 2, ...;
                     0 < q < 1;  beta > 0

    with q and beta denoting the shape parameters.
 
    This distribution has application in reliability when
    the response of interest is a discrete variable.

Syntax:
    LET <y> = DIWPDF(<x>,<q>,<beta>) 
               <SUBSET/EXCEPT/FOR qualification>
    where <x> is a positive integer variable, number, or parameter;
          <q> is a number, parameter, or variable in the range 
               (0,1) that specifies the first shape parameter;
          <beta> is a number, parameter, or variable that
               specifies the second shape parameter;
          <y> is a variable or a parameter (depending on what <x>
               is) where the computed discrete Weibull
               pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIWPDF(3,0.5,0.5)
    LET Y = DIWPDF(X,0.3,0.7)
    PLOT DIWPDF(X,0.6,0.4) FOR X = 1  1  20

Note:
    For a number of commands utilizing the discrete Weibull
    distribution, it is convenient to bin the data.
    There are two basic ways of binning the data.

      1) For some commands (histograms, maximum likelihood
         estimation), bins with equal size widths are
         required.  This can be accomplished with the
         following commands:

            LET AMIN = MINIMUM Y
            LET AMAX = MAXIMUM Y
            LET AMIN2 = AMIN - 0.5
            LET AMAX2 = AMAX + 0.5
            CLASS MINIMUM AMIN2
            CLASS MAXIMUM AMAX2
            CLASS WIDTH 1
            LET Y2 X2 = BINNED

      2) For some commands, unequal width bins may be
         helpful.  In particular, for the chi-square goodness
         of fit, it is typically recommended that the minimum
         class frequency be at least 5.  In this case, it may
         be helpful to combine small frequencies in the tails.
         Unequal class width bins can be created with the
         commands

            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = INTEGER FREQUENCY TABLE Y

         If you already have equal width bins data, you can
         use the commands
         
            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = COMBINE FREQUENCY TABLE Y2 X2

         The MINSIZE parameter defines the minimum class
         frequency.  The default value is 5.

Note:
    You can generate discrete Weibull random numbers,
    probability plots, and chi-square goodness of fit
    tests with the following commands:

       LET N = VALUE
       LET Q = <value>
       LET BETA = <value>
       LET Y = DISCRETE WEIBULL ...
               RANDOM NUMBERS FOR I = 1 1 N

       DISCRETE WEIBULL PROBABILITY PLOT Y
       DISCRETE WEIBULL PROBABILITY PLOT Y2 X2
       DISCRETE WEIBULL PROBABILITY PLOT ...
                   Y3 XLOW XHIGH

       DISCRETE WEIBULL CHI-SQUARE ...
                   GOODNESS OF FIT Y
       DISCRETE WEIBULL CHI-SQUARE ...
                   GOODNESS OF FIT Y2 X2
       DISCRETE WEIBULL CHI-SQUARE ...
                   GOODNESS OF FIT Y3 XLOW XHIGH

    You can generate estimates of q and beta based on the
    maximum ppcc value or the minimum chi-square goodness of fit
    with the commands

        LET Q1 = <value>
        LET Q2 = <value>
        LET BETA1  = <value>
        LET BETA2  = <value>
        DISCRETE WEIBULL KS PLOT Y
        DISCRETE WEIBULL KS PLOT Y2 X2
        DISCRETE WEIBULL KS PLOT Y3 XLOW XHIGH
        DISCRETE WEIBULL PPCC PLOT Y
        DISCRETE WEIBULL PPCC PLOT Y2 X2
        DISCRETE WEIBULL PPCC PLOT Y3 XLOW XHIGH

    The default values of Q1 and Q2 are 0.05 and 0.95,
    respectively.  The default values for BETA1 and BETA2 are
    0.1 and 3, respectively.  Due to the discrete nature of the
    percent point function for discrete distributions, the ppcc
    plot will not be smooth.  For that reason, if there is
    sufficient sample size the KS PLOT (i.e., the minimum
    chi-square value) is typically preferred.  However, it may
    sometimes be useful to perform one iteration of the PPCC PLOT
    to obtain a rough idea of an appropriate neighborhood for the
    shape parameters since the minimum chi-square statistic can
    generate extremely large values for non-optimal values of the
    shape parameters.  Also, since the data is integer values,
    one of the binned forms is preferred for these commands.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DIWCDF                   = Compute the discrete Weibull
                               cumulative distribution function.
    DIWPPF                   = Compute the discrete Weibull
                               percent point function.
    GLSPDF                   = Compute the generalized logarithmic
                               series probability mass function.
    WEIPDF                   = Compute the Weibull probability
                               density function.
    LGNPDF                   = Compute the lognormal probability
                               density function.
    EXPPDF                   = Compute the exponential probability
                               density function.
    POIPDF                   = Compute the Poisson probability
                               mass function.
    BINPDF                   = Compute the binomial probability
                               mass function.
    INTEGER FREQUENCY TABLE  = Generate a frequency table at
                               integer values with unequal bins.
    COMBINE FREQUENCY TABLE  = Convert an equal width frequency
                               table to an unequal width frequency
                               table.
    KS PLOT                  = Generate a minimum chi-square plot.
    PPCC PLOT                = Generate a ppcc plot.
    PROBABILITY PLOT         = Generate a probability plot.
    MAXIMUM LIKELIHOOD       = Perform maximum likelihood
                               estimation for a distribution.
 
References:
    Johnson, Kemp, and Kotz (2005), "Univariate Discrete
    Distributions", Third Edition, Wiley, pp. 510-511.

    Nakagawa and Osaki (1975), "The Discrete Weibull
    Distribution", IEEE Transactions on Reliability,
    R-24, pp. 300-301.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/8
 
Program 1:
    title size 3
    tic label size 3
    label size 3
    legend size 3
    height 3
    x1label displacement 12
    y1label displacement 15
    .
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    label case asis
    title case asis
    case asis
    tic offset units screen
    tic offset 3 3
    title displacement 2
    y1label Probability Mass
    x1label X
    .
    major ytic mark number 6
    minor ytic mark number 3
    xlimits 0 20
    line blank
    spike on
    .
    multiplot 2 2
    .
    title Q = 0.3, Beta = 0.3
    plot diwpdf(x,0.3,0.3) for x = 1 1 20
    .
    title Q = 0.5, Beta = 0.5
    plot diwpdf(x,0.5,0.5) for x = 1 1 20
    .
    title Q = 0.7, Beta = 0.7
    plot diwpdf(x,0.7,0.7) for x = 1 1 20
    .
    title Q = 0.9, Beta = 0.9
    plot diwpdf(x,0.9,0.9) for x = 1 1 20
    .
    end of multiplot
    .
    justification center
    move 50 97
    text Probability Mass Functions for Discrete Weibull

Program 2:
    let q = 0.4
    let beta = 0.5
    .
    let y = discrete weibull rand numbers for i = 1 1 500
    .
    let xmax = maximum y
    let xmax2 = xmax + 0.5
    let xmin = minimum y
    class lower -0.5
    class upper xmax2
    class width 1
    .
    let y2 x2 = binned y
    let y3 xlow xhigh = combine frequency table y2 x2
    .
    char blank
    line solid
    y1label Minimum Chi-Square
    x1label Beta (curves represent values of Q)
    discrete weibull ks plot y3 xlow xhigh
    justification center
    move 50 6
    text Minimum Chi-Square = ^minks
    .
    let q = shape1
    let beta = shape2
    char x
    line blank
    y1label Data
    x1label Theoretical
    discrete weibull prob plot y2 x2
    justification center
    move 50 6
    text PPCC = ^ppcc
    .
    line solid
    characters blank
    relative hist y2 x2
    limits freeze
    pre-erase off
    line color blue
    plot diwpdf(x,q,beta) for x = 0 1 xmax
    pre-erase on
    limits
    .
    discrete weibull chi-square goodness of fit y3 xlow xhigh

-----DIWPPF (LET)--------------------------------
 
DIWPPF
 
Name:
    DIWPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the discrete Weibull percent point function.
 
Description:
    The discrete Weibull distribution has the following
    percent point function:

       G(p;q,beta) = {LOG(1-p)/LOG(q)]**(1/beta)
                     0 <= p < 1;
                     0 < q < 1;  beta > 0

    with q and beta denoting the shape parameters.
 
Syntax:
    LET <y> = DIWPPF(<p>,<q>,<beta>) 
               <SUBSET/EXCEPT/FOR qualification>
    where <p> is a positive integer variable, number, or parameter
               in the interval (0,1);
          <q> is a number, parameter, or variable in the range 
               (0,1) that specifies the first shape parameter;
          <beta> is a number, parameter, or variable that
               specifies the second shape parameter;
          <y> is a variable or a parameter (depending on what <x>
               is) where the computed discrete Weibull
               ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DIWPPF(0.95,0.5,0.5)
    LET Y = DIWPPF(P,0.3,0.7)
    PLOT DIWPPF(P,0.6,0.4) FOR P = 0  0.01  0.99

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DIWCDF                   = Compute the discrete Weibull
                               cumulative distribution function.
    DIWPDF                   = Compute the discrete Weibull
                               probability mass function.
    GLSPDF                   = Compute the generalized logarithmic
                               series probability mass function.
    WEIPDF                   = Compute the Weibull probability
                               density function.
    LGNPDF                   = Compute the lognormal probability
                               density function.
    EXPPDF                   = Compute the exponential probability
                               density function.
    POIPDF                   = Compute the Poisson probability
                               mass function.
    BINPDF                   = Compute the binomial probability
                               mass function.
Reference:
    Johnson, Kemp, and Kotz (2005), "Univariate Discrete
    Distributions", Third Edition, Wiley, pp. 510-511.

    Nakagawa and Osaki (1975), "The Discrete Weibull
    Distribution", IEEE Transactions on Reliability,
    R-24, pp. 300-301.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/8
 
Program 1:
    title size 3
    tic label size 3
    label size 3
    legend size 3
    height 3
    x1label displacement 12
    y1label displacement 15
    .
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    label case asis
    title case asis
    case asis
    tic offset units screen
    tic offset 3 3
    title displacement 2
    x1label Probability
    y1label X
    .
    ylimits 0 1
    major ytic mark number 6
    minor ytic mark number 3
    xlimits 0 20
    line blank
    spike on
    .
    multiplot 2 2
    .
    title Q = 0.3, Beta = 0.3
    plot diwppf(p,0.3,0.3) for p = 0  0.01  0.99
    .
    title Q = 0.5, Beta = 0.5
    plot diwppf(p,0.5,0.5) for p = 0  0.01  0.99
    .
    title Q = 0.7, Beta = 0.7
    plot diwppf(p,0.7,0.7) for p = 0  0.01  0.99
    .
    title Q = 0.9, Beta = 0.9
    plot diwppf(p,0.9,0.9) for p = 0  0.01  0.99
    .
    end of multiplot
    .
    justification center
    move 50 97
    text Percent Point Functions for Discrete Weibull

-----DIXON TEST------------------------------------
 
DIXON TEST
 
Name:
    DIXON TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform a Dixon test for a single outlier.
 
Description:
    The Dixon test can be used to test for a single outlier in a
    univariate data set.  This test is primarily used for small
    data sets (Dataplot limits the sample to be between 3 and 30). 
    It can be used to test whether the minimum value is an outlier,
    the maximum value is an outlier, or either the minimum or maximum
    value is an outlier.

    The Dixon text is based on comparing the distance of one end
    observation from its neighbors with the range of all the observations
    (or all but one or two observations).  This is in contrast to the
    Grubbs (and the generalizations of Grubbs: the Tietjen-Moore and
    extreme studentized deviate tests) which are based on the number
    of standard deviations from the mean of the extreme observations.

    Specifically, given a set of ordered observastions Y1, Y2, ..., YN,
    the Dixon test is computed as follows:

    Sample Size     Test for Minimum           Test for Maximum
    ====================================================================
     3 <= N <=  7   (Y(2)-Y(1))/(Y(N)-Y(1))    (Y(N)-Y(N-1))/(Y(N)-Y(1))
     8 <= N <= 10   (Y(2)-Y(1))/(Y(N-1)-Y(1))  (Y(N)-Y(N-1))/(Y(N)-Y(2))
    11 <= N <= 13   (Y(3)-Y(1))/(Y(N-1)-Y(1))  (Y(N)-Y(N-2))/(Y(N)-Y(2))
    14 <= N <= 30   (Y(3)-Y(1))/(Y(N-2)-Y(1))  (Y(N)-Y(N-2))/(Y(N)-Y(3))

    The critical values are obtained via simulation.  The simulation is
    performed by generating standard normal random sample and computing
    the Dixon test statistic.  The critical values are dynamically
    generated using 25,000 random samples.

    The null hypothesis of no outliers is rejected if the test statistic
    is greater than the critical value.

    There are a number of variants of the Dixon test (e.g., it can be
    adopted to handle more than one outlier).  Dataplot uses the
    formulation of the Dixon test as given in the ASTM-E178 standard
    (this is taken from Dixon's Biometrics paper).

    Dixon's test is generally limited to the case of small samples.  One
    reason for this is that it is quite sensitive to the number of
    outliers being tested for and this can be difficult to determine
    for larger samples.  It also assumes that the underlying data
    distribution (with the exception of the outlier) is normal.  For
    this reason, it is recommended that a Dixon test be preceeded by
    a normal probability plot.  The normal probability can be used to
    determine if the assumption of normality and the prescence of at
    most one outlier are in fact reasonable assumptions.

Syntax 1:
    <MINIMUM/MAXIMUM> DIXON TEST   <y>
                      <SUBSET/EXCEPT/FOR qualification>
    where <MINIMUM/MAXIMUM> is an optional keyword specifies whether the
              minimum or maximum value is tested as an outlier;
          <y> is the response variable being tested;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If neither MINIMUM or MAXIMUM is given, both the minimum and
    maximum points will be tested (the more extreme of the two values
    will be used).

Syntax 2:
    <MINIMUM/MAXIMUM> DIXON TEST   <y>   <labid>
                      <SUBSET/EXCEPT/FOR qualification>
    where <MINIMUM/MAXIMUM> is an optional keyword specifies whether the
              minimum or maximum value is tested as an outlier;
          <y> is the response variable being tested;
          <labid> is an id-variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The <labid> variable is only used to identify the point being
    tested as an outlier.  It does not affect the computations.

Syntax 3:
    <MINIMUM/MAXIMUM> DIXON MULTIPLE TEST <y1> ... <yk>   
                      <SUBSET/EXCEPT/FOR qualification>
    where <MINIMUM/MAXIMUM> is an optional keyword specifies whether the
              minimum or maximum value is tested as an outlier;
          <y1> ... <yk> is a list of 1 to 30 response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax performs a Dixon test on <y1>, then on <y2>, and so on.

    Note that the syntax

         DIXON MULTIPLE TEST Y1 TO Y4

    is supported.  This is equivalent to

         DIXON MULTIPLE TEST Y1 Y2 Y3 Y4

Syntax 4:
    <MINIMUM/MAXIMUM> DIXON REPLICATED TEST <y> <x1> ... <xk>   
                           <SUBSET/EXCEPT/FOR qualification>
    where <MINIMUM/MAXIMUM> is an optional keyword specifies whether the
              minimum or maximum value is tested as an outlier;
          <y> is the response variable;
          <x1> ... <xk> is a list of 1 to 6 group-id variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax peforms a cross-tabulation of <x1> ... <xk> and performs
    a Dixon test for each unique combination of cross-tabulated values.
    For example, if X1 has 3 levels and X2 has 2 levels, there will be a
    total of 6 Dixon tests performed.

    Note that the syntax

         DIXON REPLICATED TEST Y X1 TO X4

    is supported.  This is equivalent to

         DIXON REPLICATED TEST Y X1 X2 X3 X4

    If either the first or last replication variable has all unique
    elements, this variable will be interpreted as a lab-id variable
    rather than a replication variable.

Examples:
    DIXON TEST Y1
    DIXON TEST Y1 LABID
    DIXON MULTIPLE TEST Y1 Y2 Y3
    DIXON REPLICATED TEST Y X1 X2
    DIXON TEST Y1   SUBSET TAG > 2
    DIXON MINIMUM TEST Y1
    DIXON MAXIMUM TEST Y1

Note:
    Masking and swamping are two issues that can affect outlier tests.

    Masking can occur when we specify too few outliers in the test. For
    example, if we are testing for a single outlier when there are in
    fact two (or more) outliers, these additional outliers may influence
    the value of the test statistic enough so that no points are
    declared as outliers.

    On the other hand, swamping can occur when we specify too many
    outliers in the test. For example, if we are testing for two
    outliers when there is in fact only a single outlier, both points
    may be declared outliers.

    The possibility of masking and swamping are an important reason
    why it is useful to complement formal outlier tests with graphical
    methods. Graphics can often help identify cases where masking or
    swamping may be an issue.

    Also, masking is one reason that trying to apply a single outlier
    test sequentially can fail. If there are multiple outliers, masking
    may cause the outlier test for the first outlier to return a
    conclusion of no outliers (and so the testing for any additional
    outliers is not done).

    The Dixon and Grubbs tests are used to check for a single outlier.
    If there are in fact multiple outliers, the results of these tests
    can be distorted.

    If multiple outliers are suspected, then the Tietjen-Moore or the
    generalized extreme studentized deviate tests may be preferred.
    The Tietjen-Moore test is a generalization of the Dixon test
    for the case where multiple outliers may be present.  The
    Tietjen-Moore test requires that the number of suspected outliers
    be specified exactly while the generalized extreme studentized
    deviate test only requires that an upper bound on the suspected
    number of outliers be specified.

Note:
    Tests for outliers are dependent on knowing the distribution of
    the data.  The Dixon test assumes that the data come from an
    approximately normal distribution.  For this reason, it is
    strongly recommended that the Dixon test be complemented with
    a normal probability test.  If the data are not approximately
    normally distributed, then the Dixon test may be detecting
    the non-normality of the data rather than the presence of an
    outlier.

    If you perform a formal goodness of fit test for assessing
    normality, it is recommended you omit the potential outlier
    from the test (i.e., we want to distinguish between an outlier
    and non-normality and the potential outlier may distort the
    normality test).

Note:
    You can specify the number of digits in the Dixon output with
    the command

        SET WRITE DECIMALS <value>

Note:
    The DIXON TEST command automatically saves the following
    parameters:

       STATVAL    = the value of the test statistic
       STATCD     = the CDF of the test statistic
       PVALUE     = the p-value of the test statistic
       CUTOFF0    = the 0 percent point of the reference distribution
       CUTOFF50   = the 50 percent point of the reference distribution
       CUTOFF75   = the 75 percent point of the reference distribution
       CUTOFF90   = the 90 percent point of the reference distribution
       CUTOFF95   = the 95 percent point of the reference distribution
       CUTOFF975  = the 97.5 percent point of the reference distribution
       CUTOFF99   = the 99 percent point of the reference distribution

    If the MULTIPLE or REPLICATED option is used, these values will
    be written to the file "dpst1f.dat" instead.

Note:
    In addition to the DIXON TEST command, the following commands
    can also be used:

        LET A = DIXON TEST Y

    In addition to the above LET command, built-in statistics are
    supported for about 17 different commands (enter HELP STATISTICS
    for details).

Default:
    None
 
Synonyms:
    MULTIPLE DIXON TEST is a synonym for DIXON MULTIPLE TEST
    REPLICATED DIXON TEST is a synonym for DIXON REPLICATED TEST
 
Related Commands:
    GRUBBS TEST                 = Perform the Grubbs outlier test.
    TIETJEN-MOORE TEST          = Perform the Tietjen-Moore outlier
                                  test.
    EXTREME STUDENTIZED DEVIATE = Perform the generalized extreme
                                  studentized deviate outlier test.
    GOODNESS OF FIT             = Perform goodness of fit tests.
    PROBABILITY PLOT            = Generates a probability plot.
    HISTOGRAM                   = Generate a histogram.
    BOX PLOT                    = Generate a box plot.
 
Reference:
    Dixon (1953), "Processing Data for Outliers," Biometrics,
    Vol. 9, No. 1, pp. 74-89.

    Dixon and Massey (1957), "Introduction to Statistical Analysis,"
    Second Edition, McGraw-Hill, pp. 275-278.

    ASTM E 178 - 08, "Standard Practice for Dealing with Outlying
    Observations,"  ASTM International, 100 Barr Harbor Drive,
    PO BOX C700, West Conshohoceken, PA 19428-2959, USA.

    Iglewicz and Hoaglin (1993), "Volume 16: How To Detect and Handle
    Outliers," The ASQC Basic Reference in Quality Control: Statistical
    Techniques, Edward F. Mykytka, Ph.D., Editor.

Applications:
    Outlier Detection
 
Implementation Date:
    2011/09
 
Program:
    .  Following uses example 1 from ASTM E 178 - 08 standard.
    .
    .  Response variable is breaking strength (in pounds) of
    .  0.104-in hard-drawn copper wire.
    .  
    let y = data 568 570 570 570 572 578 584 596
    .
    let a = dixon maximum test y
    .
    set write decimals 5
    dixon maximum test y

-----DLGCDF (LET)--------------------------------
 
DLGCDF
 
Name:
    DLGCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the discrete logarithmic series cumulative distribution
    function.
 
Description:
    The discrete logarithmic distribution has the following
    probability density function:
       p(x,theta) = k*theta**x/x       x = 1, 2, ...
    where theta is a shape parameter in the interval (0,1) and
    k=-1/log(1-theta).  The cumulative distribution is the probability
    of obtaining x or fewer events.  It is the sum of the logarithmic
    series probabilities of 0 to x.
 
Syntax:
    LET <y2> = DLGCDF(<y1>,<theta>) <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a positive integer variable, number, or parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed logarithmic series cdf value is
               stored;
          <theta> is a number, parameter, or variable in the range 
               (0,1) that specifies the shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DLGCDF(3,0.5)
    LET X2 = DLGCDF(X1,0.3)

Note:
    The cumulative distribution function is computed from the
    following recurrence relation given in Johnson, Kotz, and Kemp
    (see the Reference section below):
        p(X=x+1) = theta*x*p(X=x)/(x+1)      x = 1, 2, ...

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DLGPDF = Compute the logarithmic series probability density
             function.
    DLGPPF = Compute the logarithmic series percent point function.
    WARCDF = Compute the Waring cumulative distribution function.
    WARPDF = Compute the Waring probability density function.
    WARPPF = Compute the Waring percent point function.
    POICDF = Compute the Poisson cumulative distribution function.
    POIPDF = Compute the Poisson probability density function.
    POIPPF = Compute the Poisson percent point function.
    BINCDF = Compute the binomial cumulative distribution function.
    BINPDF = Compute the binomial probability density function.
    BINPPF = Compute the binomial percent point function.
    NBCDF  = Compute the negative binomial cumulative distribution
             function.
    NBPDF  = Compute the negative binomial probability density
             function.
    NBPPF  = Compute the negative binomial percent point function.
    GEOCDF = Compute the geometric cumulative distribution function.
    GEOPDF = Compute the geometric probability density function.
    GEOPPF = Compute the geometric percent point function.
 
Reference:
    "Discrete Univariate Distributions", 2nd. ed., Johnson, Kotz, and
    Kemp, John Wiley & Sons, 1994 (chapter 7).

    "Statistical Distributions", 2nd. ed., Evans, Hastings, and
    Peacock, John Wiley and Sons, 1993 (chapter 23).
 
Applications:
    XX
 
Implementation Date:
    95/4
 
Program:
    LET Z = DATA ...
        0.1 0.3 0.5 0.7 0.8 0.85 0.90 0.95 0.99 0.995 0.999 0.9999
    TITLE AUTOMATIC
    XTIC OFFSET 0.5 0.5
    SPIKE ON
    LINE BLANK
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    MULTIPLOT 4 3
    LOOP FOR K = 1 1 12
       LET THETA = Z(K)
       X1LABEL THETA = ^THETA
       PLOT DLGCDF(X,THETA) FOR X = 1 1 50
    END OF LOOP
    END OF MULTIPLOT
 
-----DLGPDF (LET)--------------------------------
 
DLGPDF
 
Name:
    DLGPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the discrete logarithmic series probability density
    function.
 
Description:
    The discrete logarithmic distribution has the following
    probability density function:
       p(x,theta) = k*theta**x/x       x = 1, 2, ...
    where theta is a shape parameter in the interval (0,1) and
    k=-1/log(1-theta).
 
Syntax:
    LET <y2> = DLGPDF(<y1>,<theta>) <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a positive integer variable, number, or parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed logarithmic series pdf value is
               stored;
          <theta> is a number, parameter, or variable in the range 
               (0,1) that specifies the shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DLGPDF(3,0.5)
    LET X2 = DLGPDF(X1,0.3)

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DLGCDF = Compute the logarithmic series cumulative distribution
             function.
    DLGPPF = Compute the logarithmic series percent point function.
    WARCDF = Compute the Waring cumulative distribution function.
    WARPDF = Compute the Waring probability density function.
    WARPPF = Compute the Waring percent point function.
    POICDF = Compute the Poisson cumulative distribution function.
    POIPDF = Compute the Poisson probability density function.
    POIPPF = Compute the Poisson percent point function.
    BINCDF = Compute the binomial cumulative distribution function.
    BINPDF = Compute the binomial probability density function.
    BINPPF = Compute the binomial percent point function.
    NBCDF  = Compute the negative binomial cumulative distribution
             function.
    NBPDF  = Compute the negative binomial probability density
             function.
    NBPPF  = Compute the negative binomial percent point function.
    GEOCDF = Compute the geometric cumulative distribution function.
    GEOPDF = Compute the geometric probability density function.
    GEOPPF = Compute the geometric percent point function.
 
Reference:
    "Discrete Univariate Distributions", 2nd. ed., Johnson, Kotz, and
    Kemp, John Wiley & Sons, 1994 (chapter 7).

    "Statistical Distributions", 2nd. ed., Evans, Hastings, and
    Peacock, John Wiley and Sons, 1993 (chapter 23).
 
Applications:
    XX
 
Implementation Date:
    95/4
 
Program:
    LET Z = DATA ...
        0.1 0.3 0.5 0.7 0.8 0.85 0.90 0.95 0.99 0.995 0.999 0.9999
    TITLE AUTOMATIC
    XTIC OFFSET 0.5 0.5
    SPIKE ON
    LINE BLANK
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    MULTIPLOT 4 3
    LOOP FOR K = 1 1 12
       LET THETA = Z(K)
       X1LABEL THETA = ^THETA
       PLOT DLGPDF(X,THETA) FOR X = 1 1 50
    END OF LOOP
    END OF MULTIPLOT
 
-----DLGPPF (LET)--------------------------------
 
DLGPPF
 
Name:
    DLGPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the discrete logarithmic series percent point function.
 
Description:
    The discrete logarithmic distribution has the following
    probability density function:
       p(x,theta) = k*theta**x/x       x = 1, 2, ...
    where theta is a shape parameter in the interval (0,1) and
    k=-1/log(1-theta).
 
    The percent point function is the inverse of the cumulative
    distribution function.  The cumulative distribution sums the
    probability from 0 to the given x value.  The percent point
    function takes a cumulative probability value and computes the
    corresponding x value.  The discrete logarithmic percent point
    function is computed using a bisection method.
 
    The input value is a real number between 0 and 1 (since it
    corresponds to a probability).
 
Syntax:
    LET <y2> = DLGPPF(<y1>,<theta>) <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, a number, or a parameter in the range 0
              to 1;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed logarithmic series ppf value is
               stored;
          <lambda> is a number or parameter that specifies the shape
               parameter of the Poisson distribution;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DLGPPF(0.9,5)
    LET X2 = DLGPPF(X1,0.7)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DLGCDF = Compute the logarithmic series cumulative distribution
             function.
    DLGPDF = Compute the logarithmic series probability density
             function.
    WARCDF = Compute the Waring cumulative distribution function.
    WARPDF = Compute the Waring probability density function.
    WARPPF = Compute the Waring percent point function.
    POICDF = Compute the Poisson cumulative distribution function.
    POIPDF = Compute the Poisson probability density function.
    POIPPF = Compute the Poisson percent point function.
    BINCDF = Compute the binomial cumulative distribution function.
    BINPDF = Compute the binomial probability density function.
    BINPPF = Compute the binomial percent point function.
    NBCDF  = Compute the negative binomial cumulative distribution
             function.
    NBPDF  = Compute the negative binomial probability density
             function.
    NBPPF  = Compute the negative binomial percent point function.
    GEOCDF = Compute the geometric cumulative distribution function.
    GEOPDF = Compute the geometric probability density function.
    GEOPPF = Compute the geometric percent point function.
 
Reference:
    "Discrete Univariate Distributions", 2nd. ed., Johnson, Kotz, and
    Kemp, John Wiley & Sons, 1994 (chapter 7).

    "Statistical Distributions", 2nd. ed., Evans, Hastings, and
    Peacock, John Wiley and Sons, 1993 (chapter 23).
 
Applications:
    XX
 
Implementation Date:
    95/4
 
Program:
    LET Z = DATA ...
       0.1 0.3 0.5 0.7 0.8 0.85 0.90 0.95 0.99 0.995 0.999 0.9999
    TITLE AUTOMATIC
    Y1LABEL X; X1LABEL PROBABILITY
    MULTIPLOT 4 3; MULTIPLOT CORNER COORDINATES 0 0 100 100
    .
    LINE SOLID
    SPIKE OFF
    XLIMITS 0 1
    MAJOR XTIC NUMBER 6
    MINOR XTIC NUMBER 1
    XTIC DECIMAL 1
    MULTIPLOT 4 3
    LOOP FOR K = 1 1 12
       LET THETA = Z(K)
       X1LABEL THETA = ^THETA
       PLOT DLGPPF(P,THETA) FOR P = 0 0.01 0.99
    END OF LOOP
    END OF MULTIPLOT
 
-----DN (LET)----------------------------------------------
 
DN
 
Name:
    DN (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Jacobi elliptic function dn.
 
Description:
    The Jacobi elliptic function dn is defined as:
        dn(u,k)=SQRT(1-k*SIN(phi)*SIN(phi))
    where phi is the amplitude and is defined as:
        u = INTEGRAL(1./SQRT(1-k*sin(theta)*sin(theta)))dtheta
    where INTEGRAL is the integral from 0 to phi.

    The algorithm DATAPLOT uses takes MC=1-k**2 as its second
    argument rather than k.  Be aware that other routines take k**2
    as the second argument (e.g., IMSL, NAG, and mathematica).  If
    you want to use k**2, enter something like the following:
        LET K2 = <value>
        LET MC = 1 - K2

Syntax:
    LET <a> = DN(<u>,<mc>)  <SUBSET/EXCEPT/FOR qualification>
    where <u> is a number, parameter, or variable;
          <mc> is a number, parameter, or variable;
          <a> is a variable or a parameter (depending on what <u>
               and <mc> are) where the computed values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DN(2,1)
    LET A = DN(X,0.5)
    LET X2 = DN(9,0)
 
Note:
    The Jacobi elliptic functions are computed using a Fortran
    translation of the Algol-60 procedure given by Bulirsch (see the
    REFERENCE section below).

Note:
    DATAPLOT computes the Jacobi elliptic functions sn, cn, and dn.
    An additional 9 functions can be computed from these:
        cd(u,k) = cn(u,k)/dn(u,k)
        sd(u,k) = sn(u,k)/dn(u,k)
        nd(u,k) = 1/dn(u,k)
        dc(u,k) = dn(u,k)/cn(u,k)
        nc(u,k) = 1/cn(u,k)
        sc(u,k) = sn(u,k)/cn(u,k)
        ns(u,k) = 1/sn(u,k)
        ds(u,k) = dn(u,k)/sn(u,k)
        cs(u,k) = cn(u,k)/sn(u,k)

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CN      = Compute the Jacobi elliptic function cn.
    SN      = Compute the Jacobi elliptic function sn.
    PEQ     = Compute the real component of the Weirstrass elliptic
              function (equianharmonic case).
    PEQI    = Compute the complex component of the Weirstrass elliptic
              function (equianharmonic case).
    PLEM    = Compute the real component of the Weirstrass elliptic
              function (lemniscatic case).
    PLEMI   = Compute the complex component of the Weirstrass elliptic
              function (lemniscatic case).
    RC      = Compute the Carlson degenerate elliptic integral.
    RF      = Compute the Carlson elliptic integral of the first kind.
    RD      = Compute the Carlson elliptic integral of the second kind.
    RJ      = Compute the Carlson elliptic integral of the third kind.
    ELLIPC1 = Compute the Legendre complete elliptic integral of the
              first kind.
    ELLIPC2 = Compute the Legendre complete elliptic integral of the
              second kind.
    ELLIP1  = Compute the Legendre elliptic integral of the first
              kind.
    ELLIP2  = Compute the Legendre elliptic integral of the second
              kind.
    ELLIP3  = Compute the Legendre's elliptic integral of the third
              kind.
 
Reference:
    "Numerical Calculation of Elliptic Integrals and Elliptic
    Functions", Bulirsch, Numerische Mathematik, vol. 7, 1965 
    (pp. 78-90).

    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 16).

Applications:
    Special Functions
 
Implementation Date:
    94/11
 
Program:
    TITLE JACOBI ELLIPTIC FUNCTIONS
    LET MC = 0.5
    LINE SOLID DASH DOT
    PLOT SN(X,MC) FOR X = -10 0.1 10 AND
    PLOT CN(X,MC) FOR X = -10 0.1 10 AND
    PLOT DN(X,MC) FOR X = -10 0.1 10
 
-----DNFCDF (LET)------------------------------------------
 
DNFCDF
 
Name:
    DNFCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the doubly non-central F cumulative distribution function
    with degrees of freedom parameters v1 and v2 and with
    non-centrality parameters lambda1 and lambda2.
 
Description:
    The F distribution is the ratio of 2 central chi-square
    distributions:
          F = (U/v1)/(V/v2)
    where U and V are 2 independent chi-square distributions with v1
    and v2 degrees of freedom respectively.  The doubly non-central
    F distribution is the ratio of 2 non-central chi-square 
    distributions.  That is:
          f(x) = (X1/v1)/(X2/v2)
    where X1 and X2 are non-central chi-square distributions with
    degrees of freedom parameters v1 and v2 and non-centrality
    parameters lambda1 and lambda2 respectively.

    The cumulative distribution is the area from 0 to x.  Since this is
    a probability function, the returned value will be between 0 and 1.
 
    The input value should be greater than 0, the non-centrality
    parameters should be non-negative, and the degrees of freedom
    parameters should be positive.
 
Syntax:
    LET <y2> = DNFCDF(<y1>,<v1>,<v2>,<lambda1>,<lambda2>) 
                        <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a number, variable or a parameter containing 
               non-negative values;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed cdf value is stored;
          <v1> is a non-negative number, parameter or variable that
               specifies the first degrees of freedom parameter;
          <v2> is a non-negative number, parameter or variable that
               specifies the second degrees of freedom parameter;
          <lambda1> is a non-negative number, parameter or variable
               that specifies the first non-centrality parameter;
          <lambda2> is a non-negative number, parameter or variable
               that specifies the second non-centrality parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DNFCDF(2,3,3,5,5)
    LET A = DNFCDF(2,10,10,5,5)
    LET X2 = DNFCDF(1.1,14,15,10000,10000)
 
Note:
    This function uses code written by Charles Reeves while he was
    a member of the Statistical Engineering Division at NIST.  The
    algorithm is described in the paper listed in the REFERENCE section
    below.  This algorithm is based on a series representation given by
    Bulgren (see the REFERENCE below) of the exact form of the doubly 
    non-central F distribution.

Note:
    Both the degrees of freedom parameters and the non-centrality
    parameters can be non-negative real numbers.  The non-centrality
    parameters are restricted to values under 10,000.  The compute time
    increases as the value of the non-centrality parameters increases.
    The degrees of freedom parameters need not be integers.

Note:
    DATAPLOT also supports the central F and the singly non-central F
    distributions (see the documentation for FCDF and NCFCDF).  The
    DNFCDF function can be used for these cases as well by setting one
    or both non-centrality parameters to zero.  However, it uses a
    different algorithm.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DNFPPF = Compute the doubly non-central F percent point function.
    NCFCDF = Compute the singly non-central F cumulative distribution
             function.
    NCFPPF = Compute the singly non-central F percent point function.
    FCDF   = Compute the F cumulative distribution function.
    FPDF   = Compute the F probability density function.
    FPPF   = Compute the F percent point function.
    DNTCDF = Compute the doubly non-central t cumulative distribution
             function.
    DNTPPF = Compute the doubly non-central t percent point function.
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    TCDF   = Compute the T cumulative distribution function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
 
Reference:
    "An Algorithm for Computing the Doubly Non-Central F C.D.F. to a
    Specified Accuracy", Charles Reeve, SED Note 86-4, November, 1986.

    "On Representations of the Doubly Non-Central F Distribution", 
    W. G. Bulgren, Journal of the the American Statistical Association,
    Vol. 66, No. 333, 1971 (pp. 184-186).
 
Applications:
    Distributional Modeling
 
Implementation Date:
    1994/9
 
Program:
    TITLE A DOUBLY NON-CENTRAL F DISTRIBUTION
    PLOT DNFCDF(X,3,10,5,5) FOR X = 0 0.1 6
 
-----DNFPDF (LET)------------------------------------------
 
DNFPDF
 
Name:
    DNFPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the doubly non-central F probability density function with
    degrees of freedom parameters v1 and v2 and non-centrality
    parameters lambda1 and lambda2.
 
Description:
    If U and V are mutually independent chi-square random variables
    with degrees of freedom parameter v1 and v2, respectively,
    then

          F = (U/v1)/(V/v2)

    follows a F distribution.  If U and V are replaced with non-central
    chi-square distributions with non-centrality parameters lambda1
    and lambda2, respectively, then the above ratio follows a doubly
    non-central F distribution with non-centrality parameters lambda1
    and lambda2.

    The probability density function of the doubly non-central F
    distribution is computed by finding the numerical derivative
    of the doubly non-central F cumulative distribution function.
 
    The doubly non-central F probability density function can be
    generalized with location and scale parameters in the usual way.

Syntax:
    LET <y> = DNFPDF(<x>,<v1>,<v2>,<lambda1>,<lambda2>,<loc>,<scale>) 
                        <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, variable or a parameter containing 
               non-negative values;
          <v1> is a non-negative number, parameter or variable that
               specifies the first degrees of freedom parameter;
          <v2> is a non-negative number, parameter or variable that
               specifies the second degrees of freedom parameter;
          <lambda1> is a non-negative number, parameter or variable
               that specifies the first non-centrality parameter;
          <lambda2> is a non-negative number, parameter or variable
               that specifies the second non-centrality parameter;
          <loc> is a number or parameter that specifies the location
               parameter;
          <scale> is a number or parameter that specifies the scale
               parameter;
          <y> is a variable or a parameter (depending on what <y1> is)
               where the computed pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The location and scale parameters are optional.

Examples:
    LET A = DNFPDF(2,3,3,5)
    LET A = DNFPDF(2,10,10,5)
    LET X2 = DNFPDF(1.1,14,15,10000)
 
Note:
    Dataplot computes the doubly non-central F probability density
    function by finding the numerical derivative of the doubly
    non-central F cumulative distribution function.  It uses the
    DIFF routine from the SLATEC library to compute the numerical
    derivative.

    The doubly non-central F cumulative distribution function is
    computed using an algorithm written by Charles Reeves while he was
    a member of the Statistical Engineering Division at NIST.  The
    algorithm is described in the paper listed in the Reference section
    below and is based on a series representation given by Bulgren (see
    the Reference below) of the exact form of the doubly non-central F
    distribution.

Note:
    Both the degrees of freedom parameters and the non-centrality
    parameters can be non-negative real numbers.  The non-centrality
    parameters are restricted to values under 10,000.  The compute time
    increases as the value of the non-centrality parameters increases.
    The degrees of freedom parameters need not be integers.

Note:
    DATAPLOT also supports the central F and the non-central F
    distributions (see the documentation for FPDF and NCFPDF).  The
    DNFPDF routine can be used to compute the central F distribution
    and the non-central F distribution (set the appropriate
    non-centrality parameters to zero).  For example, this can be used
    for the non-integer degrees of freedom case for the standard
    F distribution.

Note:
    To generate doubly non-central F random numbers, enter the commands

        LET NU1 = <value>
        LET NU2 = <value>
        LET LAMBDA1 = <value>
        LET LAMBDA2 = <value>
        LET Y = DOUBLY NON-CENTRAL F RANDOM NUMBERS ...
                FOR I = 1 1 N

    To generate a non-central F probability plot or an non-central F
    Kolmogorov-Smirnov or chi-square goodness of fit test, enter the
    following commands

        LET NU1 = <value>
        LET NU2 = <value>
        LET LAMBDA1 = <value>
        LET LAMBDA2 = <value>
        DOUBLY NON-CENTRAL F PROBABILITY PLOT Y
        DOUBLY NON-CENTRAL F KOLMOGOROV SMIRNOV GOODNESS OF FIT Y
        DOUBLY NON-CENTRAL F CHI-SQUARE GOODNESS OF FIT Y

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DNFCDF = Compute the doubly non-central F cumulative distribution
             function.
    DNFPPF = Compute the doubly non-central F percent point function.
    NCFPDF = Compute the singly non-central F probability density
             function.
    FPDF   = Compute the F probability density function.
    NCBPDF = Compute the non-central beta probability density function.
    NCCPDF = Compute the non-central chi-square probability density
             function.
    DNTPDF = Compute the doubly non-central t probability density
             function.
    NCTPDF = Compute the non-central t probability density function.
    CHSPDF = Compute the chi-square probability density function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "An Algorithm for Computing the Doubly Non-Central F C.D.F. to a
    Specified Accuracy", Charles Reeve, SED Note 86-4, November, 1986.

    "On Representations of the Doubly Non-Central F Distribution", 
    W. G. Bulgren, Journal of the the American Statistical Association,
    Vol. 66, No. 333, 1971 (pp. 184-186).
 
    "Continuous Univariate Distributions: Volume 2", Johnson, Kotz, and
    Balakrishnan, Wiley and Sons, 1994, chapter 30.

    "Statistical Distributions", Third Edition, Evans, Hastings, and
    Peacock, 2000 pp. 95-97.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2004/5
 
Program:
    LABEL CASE ASIS
    Y1LABEL Probability
    X1LABEL X
    Y1LABEL DISPLACEMENT 12
    X1LABEL DISPLACEMENT 12
    TITLE DISPLACEMENT 2
    YLIMITS 0 0.9
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    MULTIPLOT 2 2
    TITLE LAMBDA1 = 0.5, LAMBDA2 = 0.5
    PLOT DNFPDF(X,10,5,0.5,0.5) FOR X = 0.01 0.01 5
    TITLE LAMBDA1 = 0.5, LAMBDA2 = 2
    PLOT DNFPDF(X,10,5,0.5,2) FOR X = 0.01 0.01 5
    TITLE LAMBDA1 = 2, LAMBDA2 = 0.5
    PLOT DNFPDF(X,10,5,2,0.5) FOR X = 0.01 0.01 5
    TITLE LAMBDA1 = 2, LAMBDA2 = 2
    PLOT DNFPDF(X,10,5,2,2) FOR X = 0.01 0.01 5
    END OF MULTIPLOT
    CASE ASIS
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Doubly Non-Central F Distribution PDF (NU1 = 10, NU2 = 5)
 
-----DNFPPF (LET)--------------------------------
 
DNFPPF
 
Name:
    DNFPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the doubly non-central F percent point function with
    degrees of freedom parameters v1 and v2 and non-centrality
    parameters lambda1 and lambda2.
 
Description:
    The F distribution is the ratio of 2 central chi-square
    distributions:
          F = (U/v1)/(V/v2)
    where U and V are 2 independent chi-square distributions with v1
    and v2 degrees of freedom respectively.  The doubly non-central
    F distribution is the ratio of 2 non-central chi-square 
    distributions.  That is:
          f(x) = (X1/v1)/(X2/v2)
    where X1 and X2 are non-central chi-square distributions with
    degrees of freedom parameters v1 and v2 and non-centrality
    parameters lambda1 and lambda2 respectively.
 
    The percent point function is the inverse of the cumulative
    distribution function.  The cumulative distribution sums the
    probability from 0 to the given x value.  The percent point
    function takes a cumulative probability value and computes the
    corresponding x value.
 
Syntax:
    LET <y> = DNFPPF(<p>,<v1>,<v2>,<lambda1>,<lambda2>) 
                        <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, variable or a parameter containing values in
               the interval (0,1);
          <y> is a variable or a parameter (depending on what <p> is)
               where the computed ppf value is stored;
          <v1> is a non-negative number, parameter or variable that
               specifies the first degrees of freedom parameter;
          <v2> is a non-negative number, parameter or variable that
               specifies the second degrees of freedom parameter;
          <lambda1> is a non-negative number, parameter or variable
               that specifies the first non-centrality parameter;
          <lambda2> is a non-negative number, parameter or variable
               that specifies the second non-centrality parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DNFPPF(0.75,3,3,5,5)
    LET A = DNFPPF(0.95,10,10,5,5)
    LET X2 = DNFPPF(0.82,14,15,10000,10000)
 
Note:
    This function uses a bisection method to calculate the percent
    point function.

Note:
    Both the degrees of freedom parameters and the non-centrality
    parameters can be non-negative real numbers.  The non-centrality
    parameters are restricted to values under 10,000.  The compute time
    increases as the value of the non-centrality parameters increases.
    The degrees of freedom parameters need not be integers.

Note:
    DATAPLOT also supports the central F and the singly non-central F
    distributions (see the documentation for FPPF and NCFPPF).  The
    DNFPPF function can be used for these cases as well by setting one
    or both non-centrality parameters to zero.  However, it uses a
    different algorithm.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DNFCDF = Compute the doubly non-central F cumulative distribution
             function.
    NCFCDF = Compute the singly non-central F cumulative distribution
             function.
    NCFPPF = Compute the singly non-central F percent point function.
    FCDF   = Compute the F cumulative distribution function.
    FPDF   = Compute the F probability density function.
    FPPF   = Compute the F percent point function.
    DNTCDF = Compute the doubly non-central t cumulative distribution
             function.
    DNTPPF = Compute the doubly non-central t percent point function.
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    TCDF   = Compute the T cumulative distribution function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
 
Reference:
    "An Algorithm for Computing the Doubly Non-Central F C.D.F. to a
    Specified Accuracy", Charles Reeve, SED Note 86-4, November, 1986.

    "On Representations of the Doubly Non-Central F Distribution", 
    W. G. Bulgren, Journal of the the American Statistical Association,
    Vol. 66, No. 333, 1971 (pp. 184-186).
 
Applications:
    XX
 
Implementation Date:
    94/9
 
Program:
    TITLE AUTOMATIC
    PLOT DNFPPF(P,10,10,5,5) FOR P = 0.01 0.01 0.99
 
-----DNTCDF (LET)------------------------------------------
 
DNTCDF
 
Name:
    DNTCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the doubly non-central t cumulative distribution function
    with degrees of freedom parameters v and with non-centrality
    parameters delta and lambda.
 
Description:
    Given the random variable:
          Y = Z/SQRT(X/v)
    where Z is a normal distribution with mean delta and a standard
    deviation of 1 and X is a non-central chi-square distribution with
    v degrees of freedom and a non-centrality parameter of lambda, 
    then Y has a doubly non-central t distribution.

    The cumulative distribution is the area from negative infinity to
    x.  Since this is a probability function, the returned value will
    be between 0 and 1.
 
Syntax:
    LET <y2> = DNTCDF(<y1>,<v>,<delta>,<lambda>) 
                        <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a number, variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed cdf value is stored;
          <v> is a non-negative number, parameter or variable that
               specifies the degrees of freedom parameter;
          <delta> is a non-negative number, parameter or variable that
               specifies the first non-centrality parameter;
          <lambda> is a non-negative number, parameter or variable that
               specifies the second non-centrality parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DNTCDF(0.7,1,1,1)
    LET A = DNTCDF(3,10,10,100)
    LET X2 = DNTCDF(95,10,100,1)
 
Note:
    This function uses code written by Charles Reeves while he was
    a member of the Statistical Engineering Division at NIST.  The
    algorithm is described in the paper listed in the REFERENCE section
    below.  This algorithm is based on a series representation given by
    Krishnan (see the REFERENCE below) of the exact form of the doubly
    non-central t distribution.

Note:
    The degrees of freedom parameter and the non-centrality parameters
    can be non-negative real numbers.  The delta non-centrality
    parameters is restricted to value under 100 and the lambda
    non-centrality parameter is restricted to values under 10,000.
    The compute time increases as the value of the non-centrality
    parameters increases.  The degrees of freedom parameter need not
    be an integer.

Note:
    DATAPLOT also supports the central t and the singly non-central t
    distributions (see the documentation for TCDF and NCTCDF).  The
    DNTCDF function can be used for these cases as well by setting one
    or both non-centrality parameters to zero.  However, it uses a
    different algorithm.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DNTPPF = Compute the doubly non-central t percent point function.
    NCTCDF = Compute the singly non-central t cumulative distribution
             function.
    NCTPPF = Compute the singly non-central t percent point function.
    TCDF   = Compute the t cumulative distribution function.
    TPDF   = Compute the t probability density function.
    TPPF   = Compute the t percent point function.
    DNFCDF = Compute the doubly non-central F cumulative distribution
             function.
    DNFPPF = Compute the doubly non-central F percent point function.
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    FCDF   = Compute the F cumulative distribution function.
    FPDF   = Compute the F probability density function.
    FPPF   = Compute the F percent point function.
 
Reference:
    "An Algorithm for Computing the Doubly Non-Central t C.D.F. to a
    Specified Accuracy", Charles Reeve, SED Note 86-5, December, 1986.

    "Series Representation of the Doubly Non-Central t-Distribution", 
    Marakatha Krishnan, Journal of the the American Statistical
    Association, Vol. 63, No. 323, 1968 (pp. 1004-1012).
 
Applications:
    Distributional Modeling
 
Implementation Date:
    1994/9
 
Program:
    TITLE A DOUBLY NON-CENTRAL T DISTRIBUTION
    PLOT DNTCDF(X,10,10,1) FOR X = -10 0.2 30
 
-----DNTPDF (LET)------------------------------------------
 
DNTPDF
 
Name:
    DNTPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the doubly non-central t probability density function
    with degrees of freedom parameter nu and with non-centrality
    parameters lambda1 and lambda2.
 
Description:
    If Z and X are mutually independent random variables with Z
    following a standard normal distribution and X following a 
    chi-square random variable with nu degrees of freedom, then

          Y = Z(0,1)/SQRT(X(nu)/nu)

    follows a t distribution with nu degrees of freedom.

    If Z is replaced with a normal distribution with location
    parameter lambda1 and X is replaced with a non-central
    chi-square distribution with non-centrality parameter
    lambda2, then

         Y = Z(lambda1,1)/SQRT(X(nu,lambda2)/nu)

    follows a doubly non-central t distribution with
    non-centrality parameters lambda1 lambda2.

    The doubly non-central t probability density function can be
    generalized with location and scale parameters in the usual
    way.
 
Syntax:
    LET <y> = DNTPDF(<x>,<nu>,<lambda1>,<lambda2>,<loc>,<scale>) 
                        <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, variable or a parameter;
          <nu> is a non-negative number, parameter or variable that
               specifies the degrees of freedom parameter;
          <lambda1> is a non-negative number, parameter or variable
               that specifies the first non-centrality parameter;
          <lambda2> is a non-negative number, parameter or variable
               that specifies the second non-centrality parameter;
          <loc> is a number or parameter that specifies the location
               parameter;
          <scale> is a number or parameter that specifies the scale
               parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The location and scale parameters are optional.

Examples:
    LET A = DNTPDF(0.7,1,1,1)
    LET A = DNTPDF(3,10,10,100)
    LET X2 = DNTPDF(95,10,100,1)
 
Note:
    Dataplot computes the doubly non-central t probability density
    function by finding the numerical derivative of the doubly
    non-central t cumulative distribution function.  It uses the
    DIFF routine from the SLATEC library to compute the numerical
    derivative.

    The doubly non-central t cumulative distribution function is
    computed using an algorithm written by Charles Reeves while he
    was a member of the Statistical Engineering Division at NIST.
    The algorithm is described in the paper listed in the Reference
    section below and is based on a series representation given by
    Krishnan (see the Reference below) of the exact form of the
    doubly non-central t distribution.

Note:
    The degrees of freedom parameter and the non-centrality parameters
    can be non-negative real numbers.  The lambda1 non-centrality
    parameters is restricted to value under 100 and the lambda2
    non-centrality parameter is restricted to values under 10,000.
    The compute time increases as the value of the non-centrality
    parameters increases.  The degrees of freedom parameter need not
    be an integer.

Note:
    DATAPLOT also supports the central t and the singly non-central t
    distributions (see the documentation for TPDF and NCTPDF).  The
    DNTPDF function can be used for these cases as well by setting one
    or both non-centrality parameters to zero.  However, it uses a
    different algorithm.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DNTCDF = Compute the doubly non-central t cumulative distribution
             function.
    DNTPPF = Compute the doubly non-central t percent point function.
    NCTPDF = Compute the singly non-central t probability density
             function.
    TPDF   = Compute the t probability density function.
    DNFPDF = Compute the doubly non-central F probability density
             function.
    CHSPDF = Compute the chi-square probability density function.
    NORPDF = Compute the normal probability density function.
    FPDF   = Compute the F probability density function.
 
Reference:
    "An Algorithm for Computing the Doubly Non-Central t C.D.F. to a
    Specified Accuracy", Charles Reeve, SED Note 86-5, December, 1986.

    "Series Representation of the Doubly Non-Central t-Distribution", 
    Marakatha Krishnan, Journal of the the American Statistical
    Association, Vol. 63, No. 323, 1968 (pp. 1004-1012).
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2004/5
 
Program:
    LABEL CASE ASIS
    Y1LABEL Probability
    X1LABEL X
    Y1LABEL DISPLACEMENT 12
    X1LABEL DISPLACEMENT 12
    TITLE DISPLACEMENT 2
    YLIMITS 0 0.5
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    MULTIPLOT 2 2
    TITLE LAMBDA1 = 0.5, LAMBDA2 = 0.5
    PLOT DNTPDF(X,5,0.5,0.5) FOR X = -5 0.1 5
    TITLE LAMBDA1 = 0.5, LAMBDA2 = 2
    PLOT DNTPDF(X,5,0.5,2) FOR X = -5 0.1 5
    TITLE LAMBDA1 = 2, LAMBDA2 = 0.5
    PLOT DNTPDF(X,5,2,0.5) FOR X = -5 0.1 5
    TITLE LAMBDA1 = 2, LAMBDA2 = 2
    PLOT DNTPDF(X,5,2,2) FOR X = -5 0.1 5
    END OF MULTIPLOT
    CASE ASIS
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Doubly Non-Central t Distribution PDF (NU = 5)
 
-----DNTPPF (LET)--------------------------------
 
DNTPPF
 
Name:
    DNTPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the doubly non-central t percent point function with
    degrees of freedom parameters v and non-centrality parameters
    delta and lambda.
 
Description:
    Given the random variable:
          Y = Z/SQRT(X/v)
    where Z is a normal distribution with mean delta and a standard
    deviation of 1 and X is a non-central chi-square distribution with
    v degrees of freedom and a non-centrality parameter of lambda, 
    then Y has a doubly non-central t distribution.
 
    The percent point function is the inverse of the cumulative
    distribution function.  The cumulative distribution sums the
    probability from 0 to the given x value.  The percent point
    function takes a cumulative probability value and computes the
    corresponding x value.
 
Syntax:
    LET <y> = DNTPPF(<p>,<v>,<delta>,<lambda>) 
                        <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, variable or a parameter containing values
               in the interval (0,1);
          <y> is a variable or a parameter (depending on what <p> is)
               where the computed ppf value is stored;
          <v> is a non-negative number, parameter or variable that
               specifies the degrees of freedom parameter;
          <delta> is a non-negative number, parameter or variable that
               specifies the first non-centrality parameter;
          <lambda> is a non-negative number, parameter or variable that
               specifies the second non-centrality parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DNTPPF(0.90,3,3,5)
    LET A = DNTPPF(0.95,10,10,5)
    LET X2 = DNTPPF(0.99,14,100,10000)
 
Note:
    This function uses a bisection method to calculate the percent
    point function.

Note:
    The degrees of freedom parameter and the non-centrality parameters
    can be non-negative real numbers.  The delta non-centrality
    parameters is restricted to value under 100 and the lambda
    non-centrality parameter is restricted to values under 10,000.
    The compute time increases as the value of the non-centrality
    parameters increases.  The degrees of freedom parameter need not
    be an integer.

Note:
    DATAPLOT also supports the central t and the singly non-central t
    distributions (see the documentation for TPPF and NCTPPF).  The
    DNTCDF function can be used for these cases as well by setting one
    or both non-centrality parameters to zero.  However, it uses a
    different algorithm.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DNTCDF = Compute the doubly non-central t cumulative distribution
             function.
    NCTCDF = Compute the singly non-central t cumulative distribution
             function.
    NCTPPF = Compute the singly non-central t percent point function.
    TCDF   = Compute the t cumulative distribution function.
    TPDF   = Compute the t probability density function.
    TPPF   = Compute the t percent point function.
    DNFCDF = Compute the doubly non-central F cumulative distribution
             function.
    DNFPPF = Compute the doubly non-central F percent point function.
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    FCDF   = Compute the F cumulative distribution function.
    FPDF   = Compute the F probability density function.
    FPPF   = Compute the F percent point function.
 
Reference:
    "An Algorithm for Computing the Doubly Non-Central F C.D.F. to a
    Specified Accuracy", Charles Reeve, SED Note 86-4, November, 1986.

    "Series Representation of the Doubly Non-Central t-Distribution", 
    Marakatha Krishnan, Journal of the the American Statistical
    Association, Vol. 63, No. 323, 1968 (pp. 1004-1012).
 
Applications:
    Distributional Analysis
 
Implementation Date:
    1994/09
 
Program:
    TITLE AUTOMATIC
    PLOT DNTPPF(P,10,10,5) FOR P = 0.01 0.01 0.99
 
-----DOT PRODUCT (LET)-------------------------------------
 
DOT PRODUCT
 
Name:
    DOT PRODUCT (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the dot product between two variables.
 
Description:
    The dot product between two variabes X and Y is the sum of the
    products.  The formula for the dot product is
 
        X.Y = SUM[i=1 to n][X(i)*Y(i)]

Syntax:
    LET <par> = DOT PRODUCT <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed dot product
              is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Examples:
    LET A = DOT PRODUCT Y1 Y2
    LET A = DOT PRODUCT Y1 Y2  SUBSET Y1 > 0 SUBSET Y2 > 0

Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

    This command performs the same function as the VECTOR DOT PRODUCT
    command.  The distinction is that DOT PRODUCT is implemented as a
    Statistics LET subcommand while VECTOR DOT PRODUCT is implemented as
    a Mathematics LET subcommand.  The Statistics LET subcommands work
    with the 25+ commands documented in HELP STATISTICS while the
    Mathematics LET subcommands do not.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EUCLIDEAN DISTANCE      = Compute the Euclidean distance.
    EUCLIDEAN LENGTH        = Compute the Euclidean length.
    COSINE DISTANCE         = Compute the cosine distance.
    MANHATTAN DISTANCE      = Compute the Manhattan distance.
    MATRIX DISTANCE         = Compute various distance metrics for
                              a matrix.

Applications:
    Mathematics
 
Implementation Date:
    2017/03
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET DDOT  = DOT PRODUCT Y1 Y2
    SET WRITE DECIMALS 4
    TABULATE DOT PRODUCT Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    LET NDIST = UNIQUE X
    XLIMITS 1 NDIST
    MAJOR X1TIC MARK NUMBER NDIST
    MINOR X1TIC MARK NUMBER 0
    CHAR X
    LINE BLANK
    LABEL CASE ASIS
    CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    SET STATISTIC PLOT REFERENCE LINE AVERAGE
    TITLE Dot Product (IRIS.DAT)
    Y1LABEL Dot Product
    DOT PRODUCT PLOT Y1 Y2 X

-----DPNTLINE (LET)--------------------------------
 
DPNTLINE
 
Name:
    DPNTLINE (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the perpindicular distance between a point and line defined
    by a point and a slope.
 
Description:
    Given a point (X1,Y1) and line defined by (X2,Y2) and the slope S,
    determine the perpindicular distance between (X1,Y1) and the line.

    The formula for this distance is

        D = |S*X1 - Y1 + B|/SQRT(S**2 + 1)

    where the line is defined as

        Y2 = S*X2 + B
        B = Y2 - S*X2

Syntax:
    LET <dist> = DPNTLINE(<x1>,<y1>,<x2>,<y2>,<slope>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x1> is a variable or a parameter containing the x coordinates
               of the first point;
          <y1> is a variable or a parameter containing the y coordinates
               of the first point;
          <x2> is a variable or a parameter containing the x coordinates
               of the second point;
          <y2> is a variable or a parameter containing the y coordinates
               of the second point;
          <slope> is the slope of the line containing (<x2>,<y2>);
          <dist> is a variable or a parameter (depending on what the input
               arguments are) where the computed perpindicular distances
               are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DPNTLINE(1,1,0,0,0.5)
    LET DIST = DPNTLINE(X1,Y1,X2,Y2,SLOPE)

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Reference:
    Bowyer and Woodwark (1983), "A Programmer's Geometry", Butterworths,
    pp. 12-13.

Related Commands:
    ANGRAD             = Determine the counter clockwise angle for the
                         angle defined by three points.
    POINTS IN POLYGON  = Determine whether points are in the interior
                         of a convex polygon.
    CONVEX HULL        = Determine the convex hull of a set of points.
    TRANSFORM POINTS   = Perform location, scale, and rotation
                         transformation for a set of points.
    EXTREME POINTS     = Determine the extreme points of a set of points.
    LINE INTERSECTIONS = Determine the intersection points for a set of
                         lines.
    PARALLEL LINE      = Determine the coordinates for a point that defines
                         a parallel line determined by a point and a line
                         defined by two points.
    PERPINDICULAR LINE = Determine the coordinates for a point that defines
                         a perpindicular line determined by a point and a line
                         defined by two points.
 
Applications:
    Computational Geometry
 
Implementation Date:
    2012/10
 
Program:
    skip 25
    read convhull.dat x y
    .
    let y2 x2 = 2d convex hull y x
    let xtemp = x2(1)
    let ytemp = y2(1)
    let y2 = combine y2 ytemp
    let x2 = combine x2 xtemp
    let x3 = x2
    let y3 = y2
    let n = size y2
    let nm1 = n - 1
    retain x2 y2 for i = 1 1 nm1
    retain x3 y3 for i = 2 1 n
    let slope = slope(x2,y2,x3,y3)
    let pdist = dpntline(xtemp,ytemp,x3,y3,slope)
    .
    set write decimals 4
    print "Anchor Point: (^xtemp,^ytemp)"
    print " "
    print " "
    print x3 y3 slope pdist

-----DPUCDF (LET)--------------------------------
 
DPUCDF
 
Name:
    DPUCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the doubly Pareto uniform cumulative distribution
    function with shape parameters m and n, location parameter
    alpha, and scale parameter (beta - alpha).
 
Description:
    The doubly Pareto uniform distribution has the following
    cumulative distribution function:


       F(x;alpha,beta,m,n) = K(m,n)*

           [n/(m+m*n+n)]*((beta-alpha/(beta-x))**m
           x < alpha 

           [(m*n*(x-alpha) + n*(beta-alpha)]/
                  [(m+m*n+n)*(beta-alpha)]
           alpha  <= x <= beta

           1 - [m/(m+m*n+n)]*((beta-alpha/(x-alpha))**n
           x > beta

           alpha < beta; m, n > 0

    where

           k(m,n) = m*n/(m+m*n+n)
 
    with m and n denoting the shape parameters, alpha denoting
    the location parameter, and (beta - alpha) denoting the
    scale parameter.

    This distribution is uniform between alpha and beta.  It
    has Paretian tails for both the lower and upper tails.
    The m parameter controls the shape of the lower tail and
    the n parameter controls the shape of the upper tail.

    The case where alpha = 0 and beta = 1 is referred to as
    the standard doubly Pareto uniform distribution.

Syntax:
    LET <y> = DPUCDF(<x>,<m>,<n>,<alpha>,<beta>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed double Pareto uniform
              cdf value is stored;
          <m> is a number, parameter, or variable that
              specifies the first shape parameter;
          <n> is a number, parameter, or variable that
              specifies the second shape paremeter;
          <alpha> is a number, parameter, or variable that
              specifies the location parameter;
          <beta> is a number, parameter, or variable
              (<beta> - <alpha> is the scale parameter);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <alpha> and <beta> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = DPUCDF(0.3,1.4,3.2,0,1)
    LET Y = DPUCDF(X,1.4,3.2,0,1)
    PLOT DPUCDF(X,1.4,3.2,-5,5) FOR X = -10  0.1  10
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DPUPDF = Compute the doubly Pareto uniform probability density
             function.
    DPUPPF = Compute the doubly Pareto uniform percent point
             function.
    RGTPDF = Compute the reflected generalized Topp and Leone
             probability density function.
    GTLPDF = Compute the generalized Topp and Leone probability
             density function.
    TOPPDF = Compute the Topp and Leone probability density
             function.
    TSPPDF = Compute the two-sided power probability density
             function.
    BETPDF = Compute the beta probability density function.
    TRIPDF = Compute the triangular probability density function.
    TRAPDF = Compute the trapezoid probability density function.
    UNIPDF = Compute the uniform probability density function.
    POWPDF = Compute the power probability density function.
    JSBPDF = Compute the Johnson SB probability density function.
 
Reference:
    Singh, Van Dorp, Mazzuchi "A Novel Asymmetric Distribution
    with Power Tails", Communications in Statistics--Theory and
    Methods, Vol. 36(2), to appear.

    Van Dorp, Singh, and Mazzuchi "The Doubly-Pareto Uniform
    Distribution with Applications in Uncertainty Analysis and
    Econometrics", Mediterranean Journal of Mathematics,
    Vol. 3(2), pp. 205-225.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    LET ALPHA = 0
    LET BETA  = 1
    .
    LET M = 0.5
    LET N = 0.5
    TITLE M = ^m, N = ^n
    PLOT DPUCDF(X,M,N,ALPHA,BETA) FOR X = -5  0.01  5
    .
    LET M = 2
    LET N = 0.5
    TITLE M = ^m, N = ^n
    PLOT DPUCDF(X,M,N,ALPHA,BETA) FOR X = -5  0.01  5
    .
    LET M = 0.5
    LET N = 2
    TITLE M = ^m, N = ^n
    PLOT DPUCDF(X,M,N,ALPHA,BETA) FOR X = -5  0.01  5
    .
    LET M = 2
    LET N = 2
    TITLE M = ^m, N = ^n
    PLOT DPUCDF(X,M,N,ALPHA,BETA) FOR X = -5  0.01  5
    .
    END OF MULTIPLOT
    .
    CASE ASIS
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Doubly Pareto Uniform Cumulative Distribution Functions

-----DPUPDF (LET)--------------------------------
 
DPUPDF
 
Name:
    DPUPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the doubly Pareto uniform probability density
    function with shape parameters m and n, location parameter
    alpha, and scale parameter (beta - alpha).
 
Description:
    The doubly Pareto uniform distribution has the following
    probability density function:

       f(x;m,n,alpha,beta) = k(m,n)*
                             (beta-alpha)**m/(beta-x)**(m+1))
                             x < alpha

                             1/(beta-alpha)
                             alpha <= x <= beta

                             (beta-alpha)**n/
                             (x-alpha)**(n+1))
                             x > beta

                             alpha < beta; m, n > 0

    where

           k(m,n) = m*n/(m+m*n+n)
 
    with m and n denoting the shape parameters, alpha denoting
    the location parameter, and (beta - alpha) denoting the
    scale parameter.

    This distribution is uniform between alpha and beta.  It
    has Paretian tails for both the lower and upper tails.
    The m parameter controls the shape of the lower tail and
    the n parameter controls the shape of the upper tail.
    
    The case where alpha = 0 and beta = 1 is referred to as
    the standard doubly Pareto uniform distribution.

Syntax:
    LET <y> = DPUPDF(<x>,<m>,<n>,<alpha>,<beta>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed double Pareto uniform
              pdf value is stored;
          <m> is a number, parameter, or variable that
              specifies the first shape parameter;
          <n> is a number, parameter, or variable that
              specifies the second shape paremeter;
          <alpha> is a number, parameter, or variable that
              specifies the location parameter;
          <beta> is a number, parameter, or variable
              (<beta> - <alpha> is the scale parameter);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <alpha> and <beta> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = DPUPDF(0.3,1.4,3.2,0,1)
    LET Y = DPUPDF(X,1.4,3.2,0,1)
    PLOT DPUPDF(X,1.4,3.2,-5,5) FOR X = -10  0.1  10
 
Note:
    Doubly Pareto uniform random numbers, probability plots, and
    goodness of fit tests can be generated with the commands:

       LET M = <value>
       LET N = <value>
       LET Y = DOUBLY PARETO UNIFORM RANDOM NUMBERS FOR I = 1 1 N
       DOUBLY PARETO UNIFORM PROBABILITY PLOT Y
       DOUBLY PARETO UNIFORM PROBABILITY PLOT Y2 X2
       DOUBLY PARETO UNIFORM PROBABILITY PLOT Y3 XLOW XHIGH
       DOUBLY PARETO UNIFORM KOLMOGOROV SMIRNOV GOODNESS OF FIT Y
       DOUBLY PARETO UNIFORM CHI-SQUARE GOODNESS OF FIT Y2 X2
       DOUBLY PARETO UNIFORM CHI-SQUARE ...
               GOODNESS OF FIT Y3 XLOW XHIGH

    For the random numbers, you can optionally specify the
    alpha and beta parameters with the commands

       LET ALPHA = <value>
       LET BETA = <value>

    The following commands can be used to estimate the m and n
    shape parameters for the doubly Pareto uniform distribution:

       LET M1 = <value>
       LET M2 = <value>
       LET N1 = <value>
       LET N2 = <value>
       DOUBLY PARETO UNIFORM PPCC PLOT Y
       DOUBLY PARETO UNIFORM PPCC PLOT Y2 X2
       DOUBLY PARETO UNIFORM PPCC PLOT Y3 XLOW XHIGH
       DOUBLY PARETO UNIFORM KS PLOT Y
       DOUBLY PARETO UNIFORM KS PLOT Y2 X2
       DOUBLY PARETO UNIFORM KS PLOT Y3 XLOW XHIGH

    The default values for M1 and M2 are 0.5 and 10.  The default
    values for N1 and N2 are 0.5 and 10.

    The probability plot can then be used to estimate the
    alpha and beta limits (alpha = PPA0, beta = PPA0 + PPA1).

    The following options may be useful for these commands.

       1) Instead of generating the ppcc plot or ks plot on
          the original data, we can generate them on
          selected percentiles of the data.  For example,
          if we have 1,000 points, we can choose to generate
          the plots on 100 evenly spaced percentiles with
          the command

             SET PPCC PLOT DATA POINTS 100

          This can be used to speed up the generation of 
          the plot for larger data sets.

          Since the percent point function exists in simple
          closed form, this option is typically not needed.

       2) For the ks plot, we can fix the location and scale.
          This is equivalent to assuming that the alpha and
          beta parameters are known.  If alpha and beta are
          known, enter the commands

             LET KSLOC   = ALPHA
             LET KSSCALE = BETA - ALPHA

          The ppcc plot is invariant to location and scale,
          so we cannot fix the lower and upper limits.

       3) Since the doubly Pareto uniform distribution can
          sometimes be heavy-tailed, the following command can
          be useful before using the DOUBLY PARETO UNIFORM KS PLOT:

             SET PPCC PLOT LOCATION SCALE BIWEIGHT

         This bases the location and scale estimates on the
         biweight estimates of the fitted line for the underlying
         probability plot.  In the final probability plot, use
         PPA0BW and PPA0BW + PPA1BW as the estimates of alpha and
         beta rather than PPA0 and PPA0 + PPA1.  Since the ppcc plot
         is invariant to location and scale, this option does not
         apply.

    The BOOTSTRAP DISTRIBUTION command can be used to find
    uncertainty intervals for the ppcc plot and ks plot.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DPUCDF = Compute the doubly Pareto uniform cumulative
             distribution function.
    DPUPPF = Compute the doubly Pareto uniform percent point
             function.
    RGTPDF = Compute the reflected generalized Topp and Leone
             probability density function.
    GTLPDF = Compute the generalized Topp and Leone probability
             density function.
    TOPPDF = Compute the Topp and Leone probability density
             function.
    TSPPDF = Compute the two-sided power probability density
             function.
    BETPDF = Compute the beta probability density function.
    TRIPDF = Compute the triangular probability density function.
    TRAPDF = Compute the trapezoid probability density function.
    UNIPDF = Compute the uniform probability density function.
    POWPDF = Compute the power probability density function.
    JSBPDF = Compute the Johnson SB probability density function.
 
Reference:
    Singh, Van Dorp, Mazzuchi "A Novel Asymmetric Distribution
    with Power Tails", Communications in Statistics--Theory and
    Methods, Vol. 36(2), to appear.

    Van Dorp, Singh, and Mazzuchi "The Doubly-Pareto Uniform
    Distribution with Applications in Uncertainty Analysis and
    Econometrics", Mediterranean Journal of Mathematics,
    Vol. 3(2), pp. 205-225.

Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program 1:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    LET ALPHA = 0
    LET BETA  = 1
    .
    LET M = 0.5
    LET N = 0.5
    TITLE M = ^m, N = ^n
    PLOT DPUPDF(X,M,N,ALPHA,BETA) FOR X = -5  0.01  5
    .
    LET M = 2
    LET N = 0.5
    TITLE M = ^m, N = ^n
    PLOT DPUPDF(X,M,N,ALPHA,BETA) FOR X = -5  0.01  5
    .
    LET M = 0.5
    LET N = 2
    TITLE M = ^m, N = ^n
    PLOT DPUPDF(X,M,N,ALPHA,BETA) FOR X = -5  0.01  5
    .
    LET M = 2
    LET N = 2
    TITLE M = ^m, N = ^n
    PLOT DPUPDF(X,M,N,ALPHA,BETA) FOR X = -5  0.01  5
    .
    END OF MULTIPLOT
    .
    CASE ASIS
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Doubly Pareto Uniform Probability Density Functions
 
Program 2:
    let alpha = 0
    let beta = 1
    let m = 2
    let n = 1
    let msav = m
    let nsav = n
    .
    let y = doubly pareto uniform rand numb for i = 1 1 200
    .
    set ppcc plot location scale biweight
    doubly uniform ks plot y1
    let m = shape1
    let n = shape2
    justification center
    move 50 6
    text Mhat =  ^m (M = ^msav)
    move 50 2
    text Nhat =  ^n (N = ^nsav)
    .
    char x
    line bl
    doubly pareto uniform prob plot y1
    let alphahat = ppa0bw
    let betahat = ppa0bw + ppa1bw
    move 50 6
    text Alphahat =  ^alphahat
    move 50 2
    text Betahat =  ^betahat
    char blank
    line solid
    .
    relative hist y
    limits freeze
    pre-erase off
    line color blue
    plot dpupdf(x,m,n,alphahat,betahat) for x = -5  0.01  5
    line color black
    limits
    pre-erase on
    .
    let ksloc = alphahat
    let ksscale = betahat - alphahat
    doubly pareto uniform kolm smir goodness of fit y1

-----DPUPPF (LET)--------------------------------
 
DPUPPF
 
Name:
    DPUPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the doubly Pareto uniform percent point function
    with shape parameters m and n, location parameter alpha,
    and scale parameter (beta - alpha).
 
Description:
    The doubly Pareto uniform distribution has the following
    percent point function:


       G(p;m,n,alpha,beta) = 

           lambda1*(beta-alpha) + alpha   0 < p < pi1
           lambda2*(beta-alpha) + alpha   pi1 <= p <= pi2
           lambda3*(beta-alpha) + alpha   pi2 < p < 1

    where

           k(m,n) = m*n/(m+m*n+n)
 
           pi1 = n/(m + m*n + n)
           pi2 = (m*n)/(m + m*n + n)
           pi3 = m/(m + m*n + n)

           lambda1 = 1 - (pi1/p)**(1/m)
           lambda2 = (p - pi1)/pi2
           lambda3 = (pi3/(1-p))**(1/n)

           alpha < beta; m, n > 0

    with m and n denoting the shape parameters, alpha denoting
    the location parameter, and (beta - alpha) denoting the
    scale parameter.

    This distribution is uniform between alpha and beta.  It
    has Paretian tails for both the lower and upper tails.
    The m parameter controls the shape of the lower tail and
    the n parameter controls the shape of the upper tail.

    The case where alpha = 0 and beta = 1 is referred to as
    the standard doubly Pareto uniform distribution.

Syntax:
    LET <y> = DPUPPF(<p>,<m>,<n>,<alpha>,<beta>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or variable in the interval
              (0,1);
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed double Pareto uniform
              ppf value is stored;
          <m> is a number, parameter, or variable that
              specifies the first shape parameter;
          <n> is a number, parameter, or variable that
              specifies the second shape paremeter;
          <alpha> is a number, parameter, or variable that
              specifies the location parameter;
          <beta> is a number, parameter, or variable
              (<beta> - <alpha> is the scale parameter);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <alpha> and <beta> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = DPUPPF(0.95,1.4,3.2,0,1)
    LET Y = DPUPPF(P,1.4,3.2,0,1)
    PLOT DPUPPF(P,1.4,3.2,-5,5) FOR X = 0.01  0.01  0.99
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DPUPDF = Compute the doubly Pareto uniform probability density
             function.
    DPUCDF = Compute the doubly Pareto uniform cumulative
             distribution function.
    RGTPDF = Compute the reflected generalized Topp and Leone
             probability density function.
    GTLPDF = Compute the generalized Topp and Leone probability
             density function.
    TOPPDF = Compute the Topp and Leone probability density
             function.
    TSPPDF = Compute the two-sided power probability density
             function.
    BETPDF = Compute the beta probability density function.
    TRIPDF = Compute the triangular probability density function.
    TRAPDF = Compute the trapezoid probability density function.
    UNIPDF = Compute the uniform probability density function.
    POWPDF = Compute the power probability density function.
    JSBPDF = Compute the Johnson SB probability density function.
 
Reference:
    Singh, Van Dorp, Mazzuchi "A Novel Asymmetric Distribution
    with Power Tails", Communications in Statistics--Theory and
    Methods, Vol. 36(2), to appear.

    Van Dorp, Singh, and Mazzuchi "The Doubly-Pareto Uniform
    Distribution with Applications in Uncertainty Analysis and
    Econometrics", Mediterranean Journal of Mathematics,
    Vol. 3(2), pp. 205-225.

Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    LET ALPHA = 0
    LET BETA  = 1
    .
    LET M = 0.5
    LET N = 0.5
    TITLE M = ^m, N = ^n
    PLOT DPUPPF(P,M,N,ALPHA,BETA) FOR P = 0.01  0.01  0.99
    .
    LET M = 2
    LET N = 0.5
    TITLE M = ^m, N = ^n
    PLOT DPUPPF(P,M,N,ALPHA,BETA) FOR P = 0.01  0.01  0.99
    .
    LET M = 0.5
    LET N = 2
    TITLE M = ^m, N = ^n
    PLOT DPUPPF(P,M,N,ALPHA,BETA) FOR P = 0.01  0.01  0.99
    .
    LET M = 2
    LET N = 2
    TITLE M = ^m, N = ^n
    PLOT DPUPPF(P,M,N,ALPHA,BETA) FOR P = 0.01  0.01  0.99
    .
    END OF MULTIPLOT
    .
    CASE ASIS
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Doubly Pareto Uniform Percent Point Functions

-----DRAW-------------------------------------------------------
 
DRAW
 
Name:
    DRAW
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Draws a line segment.
 
Description:
    The two pairs of coordinates, (x1,y1) and (x2,y2),  define the
    (x,y) values for the tail and the head (respectively) of the line
    segment.

    By default, the coordinates are in (0,100) screen units.  You can also
    specify that the coordinates are in units of the most recent plot
    (referred to as data units).  Screen or data units can be specified
    independently for the x and y coordinates.

    The arguments can be parameters (or numbers), variables, or a mix
    of parameters and variables.  Any arguments that are variables
    must be the same length.  If variable arguments are used, a line
    will be drawn for each row of the variables (arguments given as
    parameters will use the same value for all lines drawn).

    Coordinates can specify either absolute units or relative units.
    For example,

        DRAW 10 10 50 50

    will draw a line from (10,10) to (50,50) while

        DRAW RELATIVE 10 10 50 50

    will draw a line from (10,10) to (10+50,10+50), that is from
    (10,10) to (60,60).

    The DRAW command is most typically used to annotate a previously
    generated plot.  For example, it may be used to draw reference
    lines.

Syntax 1:
    DRAW  <RELATIVE> <x1>  <y1>  <x2>  <y2>
    where <x1> is a number, parameter or variable that specifies the x
               coordinate for one end of the line segment;
          <y1> is a number, parameter or variable that specifies the y
               coordinate for one end of the line segment;
          <x2> is a number, parameter or variable that specifies the x
               coordinate for the other end of the line segment;
    and   <y2> is a number, parameter or variable that specifies the y
               coordinate for the other end of the line segment.
 
    If all arguments are parameters, this syntax draws from (x1,y1) to
    (x2,y2) using screen coordinates.  If the arguments are variables,
    one line will be drawn for each row of the variables.  The arguments
    can be a mix of parameters and variables.  However, all variables
    must be of the same length and any parameter arguments will use the
    same value for all lines drawn.

    Since this syntax uses screen units, all values should be in the
    0 to 100 range.
 
    The keyword RELATIVE is optional.  If omitted, the coordinates are
    in absolute units.  If RELATIVE is included, the (<x2>,<y2>)
    coordinates are relative to (<x1>,<y1>).

Syntax 2:
    DRAWDATA  <RELATIVE> <x1>  <y1>  <x2>  <y2>
    where <x1> is a number, parameter or variable that specifies the x
               coordinate for one end of the line segment;
          <y1> is a number, parameter or variable that specifies the y
               coordinate for one end of the line segment;
          <x2> is a number, parameter or variable that specifies the x
               coordinate for the other end of the line segment;
    and   <y2> is a number, parameter or variable that specifies the y
               coordinate for the other end of the line segment.

    This syntax is similar to Syntax 1.  However, the coordinates are
    in data units rather than screen units.
 
    The keyword RELATIVE is optional.  If omitted, the coordinates are
    in absolute units.  If RELATIVE is included, the (<x2>,<y2>)
    coordinates are relative to (<x1>,<y1>).

Syntax 3:
    DRAWxxxx  <RELATIVE> <x1>  <y1>  <x2>  <y2>
    where <x1> is a number, parameter or variable that specifies the x
               coordinate for one end of the line segment;
          <y1> is a number, parameter or variable that specifies the y
               coordinate for one end of the line segment;
          <x2> is a number, parameter or variable that specifies the x
               coordinate for the other end of the line segment;
          <y2> is a number, parameter or variable that specifies the y
               coordinate for the other end of the line segment;
    and  xxxx specifies a mix of screen and data units.

    The "xxxx" string consists of exactly four characters where
    each character is either "S" to deonote screen units or "D" to
    denote data units.  The first character specifies the units for
    <x1>, the second character specifies the units for <y1>, the
    third character specifies the units for <x2>, and the fourth
    character specifies the units for <y2>.

    This syntax is similar to Syntax 1.  However, the coordinates can
    be drawn in a mix of screen and data units.
 
    The keyword RELATIVE is optional.  If omitted, the coordinates are
    in absolute units.  If RELATIVE is included, the (<x2>,<y2>)
    coordinates are relative to (<x1>,<y1>).

Syntax 4:
    DRAW  <RELATIVE> <x1>   <y1>
    where <x1> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for one end of the line
               segment;
    and   <y1> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for one end of the line
               segment.
 
    This syntax draws from the current position (typically specified by a
    MOVE command) to (x1,y1).
 
    The keyword RELATIVE is optional.  If omitted, the coordinates are
    in absolute units.  If RELATIVE is included, the (<x1>,<y1>)
    coordinates are relative to the current position.

Syntax 5:
    DRAW  <RELATIVE> <x1>  <y1>  <x2>  <y2>  ... <xn>  <yn>  etc.
    where <x1> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for the first point of
               the line segment;
          <y1> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for the first point of
               the line segment;
          <x2> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for the second point of
               the line segment;
          <y2> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for the second point of
               the line segment;
          <xn> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for the nth point of the
               line segment;
          <yn> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for the nth point of the
               line segment.
 
    This syntax draws from (x1,y1) to (x2,y2) to (x3,y3) and so on for
    each coordinate pair listed.  The coordinates are given in
    screen units.
 
    The keyword RELATIVE is optional.  If omitted, the coordinates are
    in absolute units.  If RELATIVE is included, the current point is
    relative to the previous point (the initial point (<x1> and <y1>)
    is interpreted as absolute units).

Syntax 6:
    DRAWDATA  <RELATIVE> <x1>  <y1>  <x2>  <y2>  ... <xn>  <yn>  etc.
    where <x1> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for the first point of
               the line segment;
          <y1> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for the first point of
               the line segment;
          <x2> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for the second point of
               the line segment;
          <y2> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for the second point of
               the line segment;
          <xn> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for the nth point of the
               line segment;
          <yn> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for the nth point of the
               line segment.
 
    This syntax draws from (x1,y1) to (x2,y2) to (x3,y3) and so on for
    each coordinate pair listed.  The coordinates are given in data
    units.
 
    The keyword RELATIVE is optional.  If omitted, the coordinates are
    in absolute units.  If RELATIVE is included, the current point is
    relative to the previous point (the initial point (<x1> and <y1>)
    is interpreted as absolute units).

Examples:
    DRAW 30 30 60 60
    DRAW 50 20 50 90
    DRAWDATA  1 100 1 200
    DRAWDSDS  1 20 1 90
    DRAWDSDS X1 20 X1 90
 
Note:
    The line style (i.e., solid, dash), color, and thickness are
    controlled by the first entry of the LINE, LINE COLOR, and LINE
    THICKNESS commands.  In particular, for SYNTAX 3 (where multiple
    lines are drawn) each of the line segments is drawn with the same
    attributes.
 
Note:
    Line segments defined by the SEGMENT COORDINATES command are drawn
    whenever a subsequent plot is generated.  Line segments defined by
    the DRAW command are generated immediately.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SEGMENT COORD    = Draws line segments on subsequent plots.
    MOVE             = Moves to a point.
    POINT            = Draws a point.
    ARROW            = Draws an arrow.
    TRIANGLE         = Draws a triangle.
    BOX              = Draws a box.
    HEXAGON          = Draws a hexagon.
    CIRCLE           = Draws a circle.
    SEMI-CIRCLE      = Draws a semi-circle.
    ARC              = Draws an arc.
    ELLIPSE          = Draws an ellipse.
    OVAL             = Draws an oval.
    DIAMOND          = Draws a diamond.
    LINE COLOR       = Sets the line colors for figures and plot lines.
    CROSS-HAIR       = Activates and reads the cross-hair.
    TEXT             = Writes a text string.
 
Applications:
    Plot Annotation
 
Implementation Date:
    Pre-1987
    1994/04: Support for data units
    2018/04: Support for variable arguments
 
Program 1:
    DRAW 10 10 20 20
    DRAW 60 20 80 30
    .
    THICKNESS 0.7
    DRAW 10 40 20 40
    THICKNESS 0.3
    .
    LINE DASH
    DRAW 10 60 20 60
    LINE SOLID
    .
    LINE COLOR G50
    DRAW 10 90 20 90
    LINE COLOR BLACK
    .
    THICKNESS 0.2
    DRAW 60 70 70 85 78 23 91 98
 
Program 2:
    SKIP 25
    READ SHEESLE2.DAT Y PROC PLANT SPEED SHIFT PROC
    .
    BAR ON
    BAR WIDTH 0.5
    LINES BLANK BLANK
    TITLE DEX PARETO PLOT
    TITLE OFFSET 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    MULTIPLOT SCALE FACTOR 2
    Y1LABEL MEAN
    LET A = MEAN Y
    BAR BASE A
    DEX MEAN PARETO PLOT Y PROC PLANT SPEED SHIFT
    LET NPTS = SIZE XPLOT
    LET XFIRST = 0.5
    LET XLAST = (NPTS-2) + 0.5
    LINE SOLID
    DRAWDATA  XFIRST A XLAST A
    LINE BLANK
    .
    Y1LABEL MEDIAN
    LET A = MEDIAN Y
    BAR BASE A
    DEX MEDIAN PARETO PLOT Y PROC PLANT SPEED SHIFT
    LINE SOLID
    DRAWDATA  XFIRST A XLAST A
    LINE BLANK
    .
    YLIMITS
    Y1LABEL STANDARD DEVIATION
    LET A = STANDARD DEVIATION Y
    BAR BASE A
    DEX SD PARETO PLOT Y PROC PLANT SPEED SHIFT
    LINE SOLID
    DRAWDATA  XFIRST A XLAST A
    LINE BLANK
    .
    Y1LABEL RANGE
    LET A = RANGE Y
    BAR BASE A
    DEX RANGE PARETO PLOT Y PROC PLANT SPEED SHIFT
    LINE SOLID
    DRAWDATA  XFIRST A XLAST A
    LINE BLANK
    END OF MULTIPLOT
 
-----DRAW SYMBOL------------------------------------------------
 
DRAW SYMBOL
 
Name:
    DRAW SYMBOL
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Draw characters at specified positions using the CHARACTER
    attributes.
 
Description:
    On occasion, you may have a plot that utilizes a large set of MOVE
    and TEXT commands to provide annotation for the plot.  The
    DRAW SYMBOL command provides an alternative method for doing this.
    Although this command provides the same functionality as the
    sequence of MOVE and TEXT commands, it may provide significantly
    better performance.

    The basic syntax for this command is

        DRAW SYMBOL XPOS YPOS TAG

    where XPOS and YPOS are variables that denote the x and y coordinates
    and TAG is a variable that denotes an index value (from 1 to 100)
    for the CHARACTER command and the associcated attribute setting
    commands for CHARACTER (e.g., CHARACTER JUSTIFICATION, CHARACTER
    SIZE).  For example,

        LET XPOS = DATA 35 55
        LET YPOS = DATA 40 55
        LET TAG  = DATA  1  2
        CHARACTER  - +
        CHARACTER COLOR RED BLUE
        DRAW SYMBOL XPOS YPOS TAG

    will draw a "-" symbol in red at position (35,55) and a "+" symbol
    at position (40,55) in blue.

    If one of the arguments is a parameter rather than a variable, the
    parameter value will be used for all rows.

    You can specify screen or data coordinates in the standard way (e.g.,
    DRAWDATA SYMBOL, DRAWSD SYMBOL).

    These commands were motivated to provide performance improvements to
    the 10-step macros for 2-level full and fractional factorial designs.
    However, they may have use outside of that context.  Specifically,
    if you have a number of symbols to add to a plot, using the
    DRAW SYMBOL command may be significantly faster than a series of
    MOVE and TEXT commands.

Syntax:
    DRAWxx <xpos> <ypos> <tag>
    where <xpos> is a number, parameter or variable that specifies the
               x coordinates;
          <ypos> is a number, parameter or variable that specifies the
               y coordinates;
          <tag> is a number, parameter or variable that specifies an
               index for the CHARACTER and its associated attribute
               setting commands;
    and  xx specifies a mix of screen and data units.
 
    These agruments can be a mix of parameters and variables.  However,
    all arguments specified as variables must be the same length.  If
    an argument is specified as a parameter or a number, that value
    will be used for all rows.

    The "xx" string is optional and consists of two characters where each
    character is either "S" to deonote screen units or "D" to denote data
    units.  The first character specifies the units for the x coordinates
    and the second character specifies the units for the y coordinates.
    The "xx" can also be set to DATA in which case both the x and y
    coordinates specify data units.

    For screen units, all values should be in the 0 to 100 range.  Data
    units are in the units of the most recent plot.

    The <tag> variable should contain integer values in the range
    1 to 100.

Examples:
    DRAW SYMBOL XPOS YPOS TAG
    DRAWSD SYMBOL XPOS YPOS TAG
    DRAWDATA SYMBOL XPOS YPOS TAG
 
Note:
    The actual character drawn is determined by the values of the
    CHARACTER command.  The attributes for the character are
    determined by the various CHARACTER attribute setting
    commands.

    Often when using the DRAW SYMBOL command, we need to set
    a specific CHARACTER or CHARACTER attribute setting without
    setting the entire list.  For example, we may want to set
    the attributes for character trace 20 without setting or
    changing the attributes for traces 1 to 19.  The
    LET PLOT command provides a convenient way to do this.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    MOVE                = Moves to a point.
    TEXT                = Writes a text string.
    DRAW                = Draw a line between two points.
    CHARACTER           = Sets the type for plot characters
    CHARACTER ANGLE     = Sets the angles for plot characters.
    CHARACTER AUTOMATIC = Specifies a variable to be used as the
                          arguments to the CHARACTER command.
    CHARACTER CASE      = Sets the cases for plot characters.
    CHARACTERS COLORS   = Sets the colors for plot characters.
    CHARACTER FILL      = Sets the fill switches for plot characters.
    CHARACTER FONT      = Sets the fonts for plot characters.
    CHARACTER HW        = Sets the heights and widths for plot
                          characters.
    CHARACTER JUST      = Sets the justifications for plot characters.
    CHARACTER OFFSET    = Sets the offsets for plot characters.
    CHARACTERS SIZES    = Sets the sizes for plot characters.
    CHARACTER THICKNESS = Sets the thicknesses for plot characters.
    CHARACTER WIDTH     = Sets the widths for plot characters.
    LET PLOT            = Set values for the CHARACTER, LINE, SPIKE,
                          BAR and REGION commands (and their associated
                          attribute setting commands).
 
Applications:
    Plot Annotation
 
Implementation Date:
    2018/03
 
Program:
    . Step 1:   Generate an initial plot
    .
    plot x**2 for x = 1 1 9
    .
    . Step 2:   Now use draw symbol command
    .
    let x1  = data 2 4 6 8
    let y1  = data 50 30 70 80
    let tag = data 1 2 3 4
    .
    character blank all
    let plot character 1 = A
    let plot character 2 = B
    let plot character 3 = C
    let plot character 4 = D
    character color blue red blue red
    character font simplex all
    character size 4 all
    .
    drawds symbol x1 y1 tag

-----DUANE PLOT--------------------------------------
 
DUANE PLOT
 
Name:
    DUANE PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a Duane plot.
 
Description:
    Given a set of failure times T, the Duane plot is  a plot of
    Ti/i (where i is the index from 1 to N) versus Ti on a
    log-log scale.  This is a plot of the cumulative mean time
    between failures against the failure time.

    The Duane plot is used to assess whether or not cumulative
    failure times can be adequately modeled with a
    Non-Homogeneous Poisson Process (NHPP) - Power Law model.
    
    If you have internet access, you can see a discussion of the
    NHPP Power Law model by entering the command:

      WEB HANDBOOK NHPP POWER LAW

    Duane plots are generally preceeded by one or more of the
    following plots to check for trends in the repair rates:

       1) Plot cumulative failures versus system age.  If the
          plot look linear, there is no obvious improvement or
          degradation trend.  A bending downward indicates 
          improvement while a bending upward indicates a 
          degradation.

       2) Plot the interarrival times between new failures.
          If these trend upward, there is improvement.
          If these trend downward, there is degradation.

       3) Plot the reciprocals of the interarrival times.
          If these trend upward, there is improvement.
          If these trend downward, there is degradation.

    If the trend plots do in fact indicate a trend, then the
    Duane plot should be generated.  If the Duane plot shows a
    linear pattern, then this indicates that the NHPP Power Law
    model is consistent with the data.

    You do not need to specify XLOGON or YLOG ON
    as Dataplot does this automatically.  Dataplot also resets
    the original values for these switches after the Duane plot
    is completed.

    A line is fit to the plotted data.  Various parameters from
    the fit are saved as internal parameters (enter
    STATUS PARAMETERS after the DUANE PLOT to see what they are).
    A typical use would be:

Syntax 1:
    DUANE PLOT   <y>     <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable containing failure times;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    DUANE PLOT Y1
    DUANE PLOT Y1 SUBSET TAG > 1
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LINES             = Sets the type for plot lines.
    CHARACTERS        = Sets the type for plot characters.
    TAIL AREA PLOT    = Generates a tail area plot.
    KAPLAN MEIER PLOT = Generates a Kaplan Meier plot.
    HAZARD PLOT       = Generates a hazard plot.
    PROBABILITY PLOT  = Generates a probability plot.
    PLOT              = Generates a data or function plot.
 
Applications:
    Reliability
 
Implementation Date:
    1998/5
 
Program:
    SKIP 25
    READ HAHN.DAT MILES  TAG
    Y1LABEL CUMULATIVE MEAN TIME BETWEEN FAILURE
    X1LABEL FAILURE TIME
    CHARACTER X BLANK
    LINE BLANK SOLID
    DUANE PLOT Y SUBSET TAG = 1
    JUSTIFCATION CENTER
    MOVE 50 7
    TEXT SLOPE OF FITTED LINE = ^BETA 
    MOVE 50 4
    TEXT INTERCEPT OF FITTED LINE = ^ALPHA 

-----DURBIN TEST-----------------------------------------
 
DURBIN TEST
 
Name:
    DURBIN TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform a Durbin test that k treatments in a two-way
    balanced incomplete block design have identical effects.
 
Description:
    In a randomized block design, k treatments are applied to
    b blocks.  In a complete block design, every treatment
    is run for every block and the data is arranged as follows:

                     Treatment
    Block  1    2      ...      k
      1   X11  X12     ...     X1k
      2   X21  X22     ...     X2k
      3   X31  X32     ...     X3k
     ...  ...  ...     ...     ...
      b   Xb1  Xb2     ...     Xbk

    For some experiments, it may not be realistic to run
    all treatments in all blocks.  In this case, you may
    need to run an incomplete block design.  If you need
    to run an incomplete block design, it is strongly
    recommended that you run a balanced incomplete design.
    A balanced incomplete block design has the following
    properties:

       1) Every block contains k experimental units.
       2) Every treatment appears in r blocks.
       3) Every treatment appears with every other treatment
          an equal number of times.

    The Friedman test is the most common nonparametric test
    for complete block designs.  The Durbin test is a
    nonparametric test for balanced incomplete designs that
    reduces to the Friedman test if k = r (i.e., you in fact
    have a complete block design).

    Let R(Xij) be the rank assigned to Xij within block i (i.e.,
    ranks within a given row).  Average ranks are used in the case
    of ties.  The ranks are summed to obtain

         R(j) = SUM[i=1 to b]R(X(ij))

    Then the Durbin test is 

        H0: The treatment effects have identical effects
        HA: At least one treatment is different from at least
            one other treatment
        Test Statistic:
               T2 = {T1/(t - 1)}/
                    {(b*(k - 1) - T1)/(b*k - b - t + 1)}
            where
               T1 = (t - 1)*SUM[i=1 to t][(R(i)**2 - r*C]/(A - C)
               t  = the number of treatments
               k  = the number of treatments per block
               b  = the number of blocks
               r  = the number of times each treatment appears
               A  = SUM[i=1 to b][j=1  to t][R(X(ij))**2]
               C  = b*k*(k+1)**2/4
        Significance Level: ALPHA
        Critical Region:
            T2 > FPPF(ALPHA,t-1,b*k-b-t+1) where FPPF is the F
            percent point function.
                   
            T1 > CHSPPF(ALPHA,t-1) where CHSPPF is the chi-square
            percent point function.

        Conclusion: Reject the null hypothesis if the test
                    statistic is in the critical region.

    Note that T1 was the original statistic proposed by Durbin.
    The critical region for T1 is approximated by a chi-square
    distribution with t - 1 degrees of freedom.  The T2 statistic
    has slightly more accurate critical regions, so it is now
    the preferred statistic.  The T2 statistic is the two-way
    analysis of variance statistic computed on the ranks R(X(ij)).
    Dataplot prints the value of both the T1 and T2 statistics,
    but it only prints the critical values for the T2 statistic
    (you can compute the appropriate critical value for T1 by
    using the CHSPPF function).

    If the hypothesis of identical treatment effects is rejected,
    it is often desirable to determine which treatments are
    different (i.e., multiple comparisons).  Treatments i and j
    are considered different if

       |R(j) - R(i)| > TPPF(1-alpha/2,b*k-b-t+1))*
             SQRT[{(A-C)*2*r/(b*k-b-t+1)}*{1 - T1/(b*(k-1))}]

Syntax:
    DURBIN TEST  <y>  <block> <treat>
                      <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <block> is a variable that identifies the block;
          <treat> is a variable that identifies the treatment;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    DURBIN TEST Y BLOCK TREATMENT
    DURBIN TEST Y X1 X2
    DURBIN TEST Y BLOCK TREATMENT  SUBSET BLOCK > 2
 
Note:
    In Dataplot, the variables should be given as:
 
        Y   BLOCK   TREAT
       X11    1      1
       X12    1      2
       ...    1     ...
       X1k    1      k 
       X21    2      1
       X22    2      2
       ...    2     ...
       X2k    2      k 
 
       ...   ...    ...
 
 
       Xb1    b      1
       Xb2    b      2
       ...    b     ...
       Xb3    b      k 
 
    Rows where no data are available are omitted.

    If your data are in a format similar to that given in the
    DESCRIPTION section (i.e., you have colums Y1 to Yk, each
    with b rows where missing values are identified with a
    specific numeric value), you can convert it to the format
    required by Dataplot with the commands (the value for MV
    should be modified to match what you use to identify missing
    rows):
   
       LET MV = 1
       LET NBLOCK = SIZE Y1
       LET BLOCKID = SEQUENCE 1 1 NBLOCK
       LET RESPONSE TREAT BLOCK = REPLICATED STACK Y1 Y2 ... YK BLOCKID
       RETAIN RESPONSE BLOCK TREAT SUBSET RESPONSE <> MV
       DURBIN TEST Y2 BLOCK TREAT

Note:
    The response, ranked response, block, and treatment are
    written to the file dpst1f.dat in the current directory.
 
    The treatment ranks and multiple comparisons are written to
    the file dpst2f.dat in the current directory.  Comparisons
    that are statistically significant at the 90% leverl are
    flagged with a single asterisk, comparisons that are
    statistically significant at the 95% level are flagged with
    two asterisks, and comparisons that are statistically
    significant at the 99% level are flagged with three asterisks.

Note:
    The Durbin test is based on the following assumptions:

       1) The b blocks are mutually independent.  That means that
          the results within one block do not affect the results
          within other blocks.

       2) The data can be meaningfully ranked (i.e., the data
          have at least an ordinal scale).

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ANOVA                 = Perform an analysis of variance.
    FRIEDMAN TEST         = Perform a Friedman test.
    COCHRAN TEST          = Perform a Cochran test.
    KRUSKAL WALLIS TEST   = Perform a Kruskal Wallis test.
    VAN DER WAERDEN TEST  = Perform a Van Der Waerden test.
    MEDIAN POLISH         = Carries out a robust ANOVA.
    BLOCK PLOT            = Generate a block plot.
    DEX SCATTER PLOT      = Generates a dex scatter plot.
    DEX ... PLOT          = Generates a dex plot for a statistic.
    DEX ... EFFECTS PLOT  = Generates a dex effects plot for a
 
Reference:
    "Practical Nonparametric Statistics", Third Edition, Wiley,
    1999, pp. 388-395.
    
 
Applications:
    Analysis of Two Way Tables
 
Implementation Date:
    2006/1
 
Program:
    .  Following data from page 391 of the Conover text
    READ Y BLOCK TREAT
    2 1 1
    3 1 2
    1 1 4
    3 2 2
    1 2 3
    2 2 5
    2 3 3
    1 3 4
    3 3 6
    1 4 4
    2 4 5
    3 4 7
    3 5 1
    1 5 5
    2 5 6
    3 6 2
    1 6 6
    2 6 7
    3 7 1
    1 7 3
    2 7 7
    END OF DATA
    READ CONOVER.DAT Y BLOCK TREAT
    DURBIN Y BLOCK TREAT
 
    The following output is generated.

                  DURBIN TEST FOR IDENTICAL TREATMENT EFFECTS:
                  TWO-WAY BALANCED, INCOMPLETE BLOCK DESIGNS
     
    1. STATISTICS
          NUMBER OF OBSERVATIONS                 =       21
          NUMBER OF BLOCKS                       =        7
          NUMBER OF TREATMENTS                   =        7
          NUMBER OF BLOCKS FOR EACH TREATMENT    =        3
          A (SUM OF SQUARES OF RANKS)            =    98.00000
          C (CORRECTION FACTOR)                  =    84.00000
          DURBIN TEST STATISTIC T1 (UNCORRECTED) =    12.00000
          DURBIN TEST STATISTIC T2 (CORRECTED)   =    8.000000
     
    2. PERCENT POINTS OF THE F REFERENCE DISTRIBUTION
       FOR DURBIN TEST STATISTIC
          0          % POINT    =    0.000000
          50         % POINT    =   0.9711078
          75         % POINT    =    1.650838
          90         % POINT    =    2.668334
          95         % POINT    =    3.580580
          99         % POINT    =    6.370685
          99.9       % POINT    =    12.85810
     
     
             99.50956       % Point:     8.000000
     
    3. CONCLUSION (AT THE 5% LEVEL):
          THE        7 TREATMENTS DO NOT HAVE IDENTICAL EFFECTS
  
-----DWECDF (LET)--------------------------------
 
DWECDF
 
Name:
    DWECDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the double Weibull cumulative
    distribution function with tail length parameter GAMMA.
 
Description:
    The standard form of the double Weibull cumulative distribution
    function is:

       F(x,gamma) = 0.5 + WEICDF(x,gamma)/2       x >= 0
                  = 0.5 - WEICDF(x,gamma)/2       x < 0

    where WEICDF is the Weibull cumulative distribution function.
 
    This is simply the double Weibull distribution reflected about
    x = 0 when x is negative.  For the Weibull distribution, Dataplot
    makes a distinction between the Weibull distribution based on the
    minimum order statistic and the Weibull distribution based on
    the maximum order statistic.  However, the double Weibull
    distribution has the same formula in either case.
 
Syntax:
    LET <y> = DWECDF(<x>,GAMMA)   <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed double Weibull cdf value is stored;
          <GAMMA> is a positive number or parameter that specifies the
               tail length parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DWECDF(3,2)
    LET A = DWECDF(A1,4)
    LET X2 = DWECDF(X1,8)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DWEPDF = Compute the double Weibull probability density
             function.
    DWEPPF = Compute the double Weibull percent point function.
    WEIPDF = Compute the Weibull probability density function.
    DGAPDF = Compute the double gamma probability density function.
    GAMPDF = Compute the gamma probability density function.
    DWECDF = Compute the double Weibull probability density function.
    EXPPDF = Compute the exponential probability density function.
    DEXPDF = Compute the double exponential probability density
             function.
    CHSPDF = Compute the chi-square probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994, page 688.
 
Applications:
    Reliability Analysis
 
Implementation Date:
    1995/9
 
Program:
    TITLE DWECDF FOR X = -3 0.01 3
    X1LABEL X
    Y1LABEL PROBABILITY
    LEGEND 1 COORDINATES 75 87
    .
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT 2 2
    LEGEND 1 GAMMA = 1
    PLOT DWECDF(X,1) FOR X = -3  0.01  3
    LEGEND 1 GAMMA = 2
    PLOT DWECDF(X,2) FOR X = -3  0.01  3
    LEGEND 1 GAMMA = 5
    PLOT DWECDF(X,5) FOR X = -3  0.01  3
    LEGEND 1 GAMMA = 0.5
    PLOT DWECDF(X,0.5) FOR X = -3  0.01  3
    END OF MULTIPLOT
 
-----DWEPDF (LET)--------------------------------
 
DWEPDF
 
Name:
    DWEPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the double Weibull probability
    density function with tail length parameter GAMMA.
 
Description:
    The standard form of the double Weibull probability density
    function is:
       f(x) = (gamma/2)*|x|**(gamma-1)*exp(-(|x|**gamma))    gamma > 0
 
    This is simply the double Weibull distribution reflected about
    x = 0 when x is negative.  For the Weibull distribution, Dataplot
    makes a distinction between the Weibull distribution based on the
    minimum order statistic and the Weibull distribution based on
    the maximum order statistic.  However, the double Weibull
    distribution has the same formula in either case.
 
Syntax:
    LET <y> = DWEPDF(<x>,GAMMA)   <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed double Weibull pdf value is stored;
          <GAMMA> is a positive number or parameter that specifies the
               tail length parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DWEPDF(3,2)
    LET A = DWEPDF(A1,4)
    LET X2 = DWEPDF(X1,8)
 
Note:
    The general form of the double Weibull probability density
    function is:
       f(x) = (gamma/(2*alpha))*(|x-u|/alpha)**(gamma-1)*
                 exp(-(|x-u|/alpha)**gamma))    gamma, alpha > 0
    where u is the location parameter and alpha is the scale
    parameter.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DWECDF = Compute the double Weibull cumulative distribution
             function.
    DWEPPF = Compute the double Weibull percent point function.
    WEIPDF = Compute the Weibull probability density function.
    DGAPDF = Compute the double gamma probability density function.
    GAMPDF = Compute the gamma probability density function.
    DWEPDF = Compute the double Weibull probability density function.
    EXPPDF = Compute the exponential probability density function.
    DEXPDF = Compute the double exponential probability density
             function.
    CHSPDF = Compute the chi-square probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994, page 688.
 
Applications:
    Reliability Analysis
 
Implementation Date:
    1995/9
 
Program:
    TITLE DWEPDF FOR X = -3 0.01 3
    X1LABEL X
    Y1LABEL PROBABILITY
    LEGEND 1 COORDINATES 75 87
    .
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT 2 2
    LEGEND 1 GAMMA = 1
    PLOT DWEPDF(X,1) FOR X = -3  0.01  3
    LEGEND 1 GAMMA = 2
    PLOT DWEPDF(X,2) FOR X = -3  0.01  3
    LEGEND 1 GAMMA = 5
    PLOT DWEPDF(X,5) FOR X = -3  0.01  3
    LEGEND 1 GAMMA = 0.5
    PLOT DWEPDF(X,0.5) FOR X = -3  0.01  3
    END OF MULTIPLOT
 
-----DWEPPF (LET)--------------------------------
 
DWEPPF
 
Name:
    DWEPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the double Weibull percent point
    function with tail length parameter GAMMA.
 
Description:
    The standard form of the double Weibull percent point
    function is:
 
       G(p,gamma) = WEIPPF(2*(p - 0.5), gamma)    p >= 0.5
                  = -WEIPPF(2*(0.5 - p), gamma)   p < 0.5

    where WEIPPF is the percent point function of the Weibull
    distribution.
 
    This is simply the double Weibull distribution reflected about
    x = 0 when x is negative.  For the Weibull distribution, Dataplot
    makes a distinction between the Weibull distribution based on the
    minimum order statistic and the Weibull distribution based on
    the maximum order statistic.  However, the double Weibull
    distribution has the same formula in either case.
 
Syntax:
    LET <y> = DWEPPF(<p>,GAMMA)   <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, number, or parameter in the range to
               (0,1);
          <y> is a variable or a parameter (depending on what <p> is)
               where the computed double Weibull pdf value is stored;
          <GAMMA> is a positive number or parameter that specifies the
               tail length parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = DWEPPF(0.95,2)
    LET A = DWEPPF(A1,4)
    LET X2 = DWEPPF(P,8)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DWECDF = Compute the double Weibull cumulative distribution
             function.
    DWEPDF = Compute the double Weibull probability density function.
    WEIPDF = Compute the Weibull probability density function.
    DGAPDF = Compute the double gamma probability density function.
    GAMPDF = Compute the gamma probability density function.
    DWEPPF = Compute the double Weibull probability density function.
    EXPPDF = Compute the exponential probability density function.
    DEXPDF = Compute the double exponential probability density
             function.
    CHSPDF = Compute the chi-square probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994, page 688.
 
Applications:
    Reliability Analysis
 
Implementation Date:
    1995/9
 
Program:
    TITLE DWEPPF FOR X = -3 0.01 3
    X1LABEL X
    Y1LABEL PROBABILITY
    LEGEND 1 COORDINATES 75 87
    .
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT 2 2
    LEGEND 1 GAMMA = 1
    PLOT DWEPPF(P,1) FOR P = 0.01  0.01  0.99
    LEGEND 1 GAMMA = 2
    PLOT DWEPPF(P,2) FOR P = 0.01  0.01  0.99
    LEGEND 1 GAMMA = 5
    PLOT DWEPPF(P,5) FOR P = 0.01  0.01  0.99
    LEGEND 1 GAMMA = 0.5
    PLOT DWEPPF(P,0.5) FOR P = 0.01  0.01  0.99
    END OF MULTIPLOT
 
-------------------------------------------------------------



















































-------------------------  *E*  ZZZZZ--------------------
 
-----E691 INTERLAB --------------------------------------------

E691 INTERLAB
 
Name:
    E691 INTERLAB
 
Type:
    Analysis Command
 
Purpose:
    Generate the tables for an interlab analysis as described
    by the ASTM E 691 - 99 standard.
 
Description:
    The following document

      "Standard Practice for Conducting an Interlaboratory Study
      to Determine the Precision of a Test Method", ASTM
      International, 100 Barr Harbor Drive, PO BOX C700,
      West Conshohoceken, PA 19428-2959, USA.

    describes a methodology for performing an interlab experiment.
    
    The data consists of:
    
        1. A response variable
        2. A lab-id variable
        3. A material-id variable
    
    It is assumed that this is a balanced design.  That is,
    each combination of lab-id and material-id (referred to as
    a cell in the standard) has an equal number of observations.

    The purpose of the E691 INTERLAB command is to estimate the
    precision of a test method.  Two important concepts in
    determining the precision are:

        1. Repeatability - repeatability concerns the variability
           between independent test results obtained within a
           single laboratory in the shortest practical period
           of time by a single operator with a specific set of
           test apparatus using test specimens taken at random
           from a single quantity of homogeneous material.

        2. Reproducibility - reproducibility is the variability
           between single test results obtained in different
           laboratories, each of which has applied the test
           method to test specimens taken at random from a
           single quantity of homogeneous material.
     
    The standard discusses issues regarding the design of the
    interlaboratory study.  We do not dicuss those issues here.

    If your data is stored in a format with each lab
    in a separate column, you can use the REPLICATED STACK
    command to save your data in the format needed by the
    E691 INTERLAB command.
    
    This command generates the five tables documented in the
    above document:
    
        1. The raw data
        2. For each material:
           a. Lab ID, Cell Average, Cell SD, 
           b. Deviation of Cell Average from Material Average,
           c. h-Consistency Statistic, k-Consistency Statistic,
        3. The h-consistency statistic by laboratory and material.
        4. The k-consistency statistic by laboratory and material.
        5. A summary table of precision statistics for each
           material.

    The following provides some of the quantities that are
    computed in this command (see the above document for a more
    detailed discussion of these quantities).

       n         = number of test results per cell
       p         = number of laboratories
       x         = individual test result
       xtilde    = cell average (SUM[i=1 to n][x]/n
       xbar      = average of cell averages for one material
                   (SUM[i=1 to p][xtilde]/p)
       s         = cell standard deviation
                   (SQRT(SUM[i=1 to n][(x - xtilde)**2]/(n-1)))
       d         = cell deviation (xtilde - xbar)
       s(xtilde) = standard deviations of cell averages
                   (SQRT(SUM[i=1 to p][d**2]/(p-1)))
       s(r)      = repeatability standard deviation
                   (SQRT(SUM[i=1 to p][s**2]/p))
       s(R)      = reproducibility standard deviation (larger of s(r)
                   and SQRT((s(xtilde)**2 + s(r)**2*(n-1)/n))
       h         = d/s(xtilde) (h is the between-laboratory
                   consistency statistic)
       k         = s/s(r) (k is the within-laboratory consistency
                   statistic)
       r         = 2.8*s(r)
       R         = 2.8*s(R)

Syntax:
    E691 INTERLAB <y> <matid> <labid>
                              <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <matid> is a material id variable;
          <labid> is a lab id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Examples:
    E691 INTERLAB Y1  MATID  LABID
    E691 INTERLAB Y1  MATID  LABID SUBSET LABID > 1
 
Note:
    The E691 INTERLAB command is typically supplementated with
    a number of graphs.

    The following graphs are recommended in the above documented:

         1. h-consistency statistic (materials within labs)
         2. h-consistency statistic (labs within materials)
         3. k-consistency statistic (materials within labs)
         4. k-consistency statistic (labs within materials)
         5. Reproducibility SD and Repeatability SD versus
            material average
    
    We also recommend the following graphs:
    
         1. A graph displaying the lab means and sd's for each
            material.
         2. A plot of means, sd's, repeatability sd's, and
            reproducibility sd's for each material.
         3. Dot plots of the h-consistency statistics.
         4. Box plots of the k-consistency statistics.

    We have added the following macros to Dataplot's built-in
    macro library:

         1. E691PLO1.DP  - plot of lab means and lab standard
                           deviations for each material
         2. E691PLO2.DP  - plot of means, standard deviations,
                           repeatability sd, and reproducibility
                           for each material.
         3. E691PLO3.DP  - plot of h-consistency statistic
                           (laboratories within materials)
         4. E691PLO4.DP  - plot of k-consistency statistic
                           (laboratories within materials)
         5. E691PLO5.DP  - plot of h-consistency statistic
                           (materials within laboratories)
         6. E691PLO6.DP  - plot of k-consistency statistic
                           (materials within laboratories)
         7. E691PLO7.DP  - plot of repeatability and
                           reproducibility sd versus average for
                           each material
         8. E691DOH1.DP  - dot plot of h-consistency statistic
                           (laboratories within materials)
         9. E691DOH2.DP  - dot plot of h-consistency statistic
                           (materials within laboratories)
        10. E691DOK1.DP  - dot plot of k-consistency statistic
                           (laboratories within materials)
        11. E691DOK2.DP  - dot plot of k-consistency statistic
                           (materials within laboratories)
        12. E691BPH1.DP  - box plot of h-consistency statistic
                           (laboratories within materials)
        13. E691BPH2.DP  - box plot of h-consistency statistic
                           (materials within laboratories)
        14. E691BPK1.DP  - box plot of k-consistency statistic
                           (laboratories within materials)
        15. E691BPK2.DP  - box plot of k-consistency statistic
                           (materials within laboratories)
   

    To call one of these macros, define the following values

         Y       = response variable
         MATID   = material-id variable
         LABID   = lab-id variable
         E691TIT = string containing a title for the analysis

    and then use the CALL command to invoke the macro.  This
    is demonstrated in the program example below.

    If you would like to view one of these macros, use the
    LIST command.  For example

        LIST E691PLO1.DP

    If you would like to modify one of these macros, use the
    COPY command to create a copy of the macro.  For example

        COPY E691PLO1.DP  C:\E691PLO1_NEW.DP

    You can then edit C:\E691PLO1_NEW.DP to suit your needs.

Note:
    You can use the CAPTURE HTML command to generate these tables
    in HTML format.  You can use the CAPTURE LATEX command to
    generated these tables in Latex format.  You can use the
    CAPTURE RTF command in Rich Text Format (RTF).

    The second program example demostrates this for Latex.

Note:
    In some cases, you may not want to generate all of the tables for
    the E691 analysis.  You can specify which tables to generate with
    the commands

          SET E692 DATA SUMMARY TABLE <ON/OFF>
          SET E692 TEST RESULTS TABLE <ON/OFF>
          SET E692 H CONSISTENCY TABLE <ON/OFF>
          SET E692 K CONSISTENCY TABLE <ON/OFF>
          SET E692 PRECISION STATISTICS TABLE <ON/OFF>

Note:
    By default, materials are identified with the numeric code given
    in the material id variable on the E691 INTERLAB command.

    If you have defined a group label variable (HELP GROUP LABEL for
    details) that defines alphabetic codes for the material names, you
    can use the command

          SET E691 MATERIAL ID GROUP LABEL <group-id variable>

    where <group-id variable> is the name of a group-id variable.

    To restore the use of numeric codes, enter

          SET E691 MATERIAL ID GROUP LABEL NONE

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CAPTURE HTML                       = Generate output in HTML
                                         format.
    CAPTURE LATEX                      = Generate output in Latek
                                         format.
    REPLICATED STACK                   = Convert data to the format
                                         required by the
                                         E691 INTERLAB command.
    REPEATABILITY STANDARD DEVIATION   = Compute the repeatability
                                         standard deviation.
    REPRODUCIBILITY STANDARD DEVIATION = Compute the repeatability
                                         standard deviation.
    H CONSISTENCY STATISTIC            = Compute the h consistency
                                         statistic.
    K CONSISTENCY STATISTIC            = Compute the k consistency
                                         statistic.
 
Reference:
    "Standard Practice for Conducting an Interlaboratory Study
    to Determine the Precision of a Test Method", ASTM
    International, 100 Barr Harbor Drive, PO BOX C700,
    West Conshohoceken, PA 19428-2959, USA.

Applications:
    Interlaboratory Studies
 
Implementation Date:
    2005/04
    2015/03: SET commands to allow user control over which tables will
             be printed
    2015/03: Added table to print raw data
 
Program 1:
    SKIP 25
    READ GLUCOSE.DAT Y LABID MATID
    LET STRING E691TIT = Glucose in Serum
    .
    E691 INTERLAB Y MATID LABID
    .
    CALL E691PLO1.DP
    CALL E691PLO2.DP
    CALL E691PLO3.DP
    CALL E691PLO4.DP
    CALL E691PLO5.DP
    CALL E691PLO6.DP
    CALL E691PLO7.DP

Program 2:
    SKIP 25
    READ MANDEL6.DAT Y LABID MATID
    LET STRING E691TIT = Pentosans in Wood Pulp
    .
    . DEMONSTRATE HOW TO SAVE OUTPUT IN A LATEX FILE
    . WITH GRAPHICS
    CAPTURE LATEX E691.TEX
    E691 INTERLAB Y MATID LABID
    .
    SET IPL1NA E691PLO1.PS
    DEVICE 2 POSTSCRIPT
    CALL E691PLO1.DP
    DEVICE 2 CLOSE
    SET IPL1NA E691PLO2.PS
    DEVICE 2 POSTSCRIPT
    CALL E691PLO2.DP
    DEVICE 2 CLOSE
    SET IPL1NA E691DOH1.PS
    DEVICE 2 POSTSCRIPT
    CALL E691DOH1.DP
    DEVICE 2 CLOSE
    SET IPL1NA E691DOH2.PS
    DEVICE 2 POSTSCRIPT
    CALL E691DOH2.DP
    DEVICE 2 CLOSE
    SET IPL1NA E691DOK1.PS
    DEVICE 2 POSTSCRIPT
    CALL E691DOK1.DP
    DEVICE 2 CLOSE
    SET IPL1NA E691DOK2.PS
    DEVICE 2 POSTSCRIPT
    CALL E691DOK2.DP
    DEVICE 2 CLOSE
    SET IPL1NA E691PLO7.PS
    DEVICE 2 POSTSCRIPT
    CALL E691PLO7.DP
    DEVICE 2 CLOSE
    END OF CAPTURE

-----ECHO-------------------------------------------------------
 
ECHO
 
Name:
    ECHO
 
Type:
    Support Command
 
Purpose:
    Specifies that all future commands will be "echoed" back to the
    terminal at the time of execution.
 
Description:
    This command is most commonly used for the following purposes:
    1) to help debug DATAPLOT macro files;
    2) to document alphanumeric output from DATAPLOT sessions when
       the output is diverted to a file with the CAPTURE command.
 
Syntax:
    ECHO   <ON or OFF>
    where ON specifies that subsequent commands are echoed while OFF
    specifies that they are not echoed.
 
Examples:
    ECHO ON
    ECHO OFF
    ECHO
 
Default:
    The default is no echo.
 
Synonyms:
    None
 
Note:
    The ECHO command with no arguments is equivalent to ECHO ON.
 
Related Commands:
    FEEDBACK     = Allows or suppresses the feedback messages.
    PRINTING     = Allows or suppresses the analysis output.
    PROMPT       = Allows or suppresses the prompt character.
    SET          = Sets the value of an internal variable (e.g., IPR).
    PROBE        = Displays the value of an internal variable (e.g.,
                   IPR).
    CAPTURE      = Redirect alphanumeric output to a file.
 
Applications:
    Debugging, Presentation Output
 
Implementation Date:
    Pre-1987
 
Program:
    ECHO ON
    CAPTURE FIT.OUT
    SKIP 25
    READ BERGER1.DAT Y X
    FIT Y X
    END OF CAPTURE
    ECHO OFF
    LIST FIT.OUT
 
-----EDGES TO VERTICES (LET)----------------------------------------
 
EDGES TO VERTICES
 
Name:
    EDGES TO VERTICES (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Convert a list of edges and coordinates for the vertices
    into a form suitable for plotting.
 
Description:
    This is a convenience function.  Graphs are often defined
    in terms of its edges.  If you have a list of edges and
    and variables that define the coordinates of the vertices,
    this command will return variables that contain the
    coordinates of the plot points (call them X2 and Y2) and a
    third variables that identifies which points are to be
    connected (call this variable TAG).  Then a plot of the
    edges of the graph can be generated with the command

        PLOT Y2 X2 TAG

    The primary limitation of this command is that it assumes
    that you already have coordinates for the vertices in the
    graph.

Syntax:
    LET <y2> <x2> <tag> = EDGES TO VERTICES <edge1> <edge2> <y> <x>
    where <edge1> is a variable that identifies the first vertex
              in the edge;
          <edge2> is a variable that identifies the second vertex
              in the edge;
          <y> is a variable that identifies the y-coordinates of
              the vertices;
          <x> is a variable that identifies the x-coordinates of
              the vertices;
    and   <tag> is a variable where the trace-id is saved.
 
Examples:
    LET Y2 X2 TAG = EDGES TO VERTICES E1 E2 Y X
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    2D CONVEX HULL           = Compute the 2D convex hull of a
                               set of points.
    MINIMUM SPANNING TREE    = Compute the minimum spanning tree.
    ADJACENCY MATRIX         = Create an adjacency matrix from a
                               list of edges.
    SPANNING FOREST          = Compute the spanning forest.
    NEXT PERMUTATION         = Generate the next permutation of a
                               positive integer.
    RANDOM PERMUTATION       = Generate a random permutation of a
                               positive integer.
 
References:
    Skiena (1998), "The Algorithm Design Manual", Telos.

Applications:
    Graph Theory
 
Implementation Date:
    2009/1
 
Program:
    read edge1 edge2
    2 3
    4 7
    1 9
    7 11
    5 8
    2 5
    6 10
    2 8
    3 8
    4 11
    end of data
    .
    read x1 y1
    80 80
    40 20
    40 80
    10 20
    60 80
    80 20
    18 60
    60 20
    90 80
    90 20
    25 20
    82 50
    90 50
    98 50
    end of data
    .
    let y2 x2 tag = edges to vertices edge1 edge2 y1 x1
    .
    limits 0 100
    let nvert = size y1
    let ivert = sequence 1 1 nvert
    character automatic ivert
    character offset 2 2 all
    line blank all
    plot y1 x1 ivert
    .
    pre-erase off
    character blank all
    line solid all
    plot y2 x2 tag
    .
    pre-erase on
    limits
 
-----EDITOR (SET)--------------------------------------------------
 
EDITOR
 
Name:
    EDITOR (SET)
 
Type:
    Set Subcommand
 
Purpose:
    This command sets the preferred editor to use for the EDIT (FED)
    command.
 
Description:
    Dataplot has a built-in line editor called FED (for Filliben
    Editor) that is modeled on the old Univac mainframe line editor.
    This editor is invoked with the EDIT (or FED) command.

    However, you can specify that another editor be invoked by the EDIT
    command by entering the command

       SET EDITOR <name>

    For example, on Windows platforms you can use

       SET EDITOR NOTEPAD
       SET EDITOR WORDPAD

    On Linux, you can use

       SET EDITOR vi
       SET EDITOR emacs

    If your desired editor is not in the default search path, then you
    need to include the complete path.  Be sure to enclose the path in
    double quotes if the path contains one or mor spaces.  For example,

        SET EDITOR "C:\Program Files (x86)\notepad++\notepad++.exe"

    For Linux/Unix and MacOS platforms, if you have defined the
    system enviornment variable EDITOR, then you can have Dataplot
    use that by entering the command

        SET EDITOR SYSTEM

    Dataplot does no error checking on the specified name.  If an
    invalid name is entered, the subsequent EDIT command will not work.

    The name is case sensitive on Linux/UNIX and MacOS platforms, so

        SET EDITOR VI
        SET EDITOR EMACS

    will not work.

    Specifying DEFAULT, ON, or AUTOMATIC will revert to using FED.

Syntax:
    SET EDITOR <name>
    where <name> is the desired editor.
 
Examples:
    SET EDITOR NOTEPAD
    SET EDITOR WORDPAD
    SET EDITOR vi
    SET EDITOR emacs
 
Default:
    FED
 
Synonyms:
    None
 
Related Commands:
    EDIT      = Edit a file from within a Dataplot session.
 
Applications:
    Editing Files
 
Implementation Date:
    2019/03
 
Program:
    SET EDITOR WORDPAD
    EDIT FIT.DP

-----EDIT-------------------------------------------------------
 
EDIT
 
Name:
    EDIT
 
Type:
    Support Command
 
Purpose:
    Edit a file.
 
Description:
    The EDIT command provides a full featured line editor.  The editor
    is typically used to correct a macro file or a data file without
    exiting DATAPLOT.  It is particularly useful on non-window systems
    where it is not possible to edit in a separate window.
 
Syntax:
    EDIT    <file name>
    where <file name> is the name of the file to be edited.
 
Examples:
    EDIT PLOTCALIB.DP
    EDIT PLOTCALIB.DAT
 
Note:
    This editor does not support screen mode editing at this time.
    Although a line editor is more primitive than a screen editor, it
    does provide maximum portability across terminals and operating
    systems.
 
Note:
    This editor is too extensive to document here.  There is a
    separate help which serves as the documentation.  Check with your
    local site installer to obtain a copy (you can also access this
    help file on-line by entering HELP after the EDIT command).  Enter
    QUIT to leave the editor and resume normal DATAPLOT use.
 
    The documention for the editor can be found at

    https://www.itl.nist.gov/div898/software/dataplot/refman1/ch5/edit.pdf

    Within a Dataplot session, you can enter WEB HELP EDIT to access
    this page.

Note:
    Most users already have a favorite editor.  If your implementation
    supports the SYSTEM command, you may be able to use it to invoke
    your own editor.  For example, on Unix implementations you can
    enter:

        SYSTEM vi <file>    (or emacs or whatever editor you prefer)

    Note that the SYSTEM command for the PC version will typically not
    work if this is tried.
 
    The 2019/03 version added the following command

        SET EDITOR <name>

    where <name> denotes the name for your desired editor.

    For example, on Windows platforms you can use

        SET EDITOR NOTEPAD
        SET EDITOR WORDPAD

    On Linux, you can use

        SET EDITOR vi
        SET EDITOR emacs

    If your desired editor is not in the default search path, then
    you need to include the complete path.  For example,

        SET EDITOR "C:\Program Files (x86)\notepad++\notepad++.exe"

Default:
    None
 
Synonyms:
    FED
 
Related Commands:
    CREATE        = Starts copying commands to macro file.
    LIST          = Lists the contents of a file.
    SEARCH        = Search a file for a string.
 
Applications:
    File Editing
 
Implementation Date:
    1992/06
    2019/03: Support for SET EDITOR command
 
Program:
    LIST MYFIT.DP
    EDIT MYFIT.DP
    LO FIT Y X1 X2 X3
    C /X1 X2 X3/X1 X2/
    EXIT
    CALL MYFIT.DP
 
-----ELLIP1 (LET)--------------------------------
 
ELLIP1
 
Name:
    ELLIP1 (LET)
 
Type:
    Library Function
 
Purpose:
    Compute Legendre's elliptic integral of the first kind.
 
Description:
    Legendre's elliptic integral of the first kind is defined as:
        F(phi,alpha)=INT(1/SQRT(1-SIN(alpha)**2*SIN(theta)**2))dtheta
    where INT is the integral from 0 to phi.

    This function is often expressed as:
        F(phi,k)=INT(1/SQRT(1-k**2*SIN(alpha)**2))dtheta
    where INT is the integral from 0 to phi.  That is, k is the
    sine of alpha.

    In DATAPLOT, the input values are the angles given in radian
    units.  The first angle must be in the interval (0,PI/2).

Syntax:
    LET <y> = ELLIP1(<phi>,<alpha>)  <SUBSET/EXCEPT/FOR qualification>
    where <phi> is a number, variable, or parameter containing values
               in the interval (0,PI/2) exclusive;
          <alpha> is a number, variable, or parameter;
          <y> is a variable or a parameter (depending on what <phi> 
               and <alpha> are where the computed values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ELLIP1(0.7,1.1)
    LET A = ELLIP1(0.1,1.4)
    LET X2 = ELLIP1(X,0.3)
 
Note:
    If your angles are in degrees, be sure to convert them to radians
    first.  For example, to convert a 45 degree angle to radians, do:
       LET PHI = 45*(180/PI)

    Also, if your second parameter is in the form of sin(alpha), be
    sure to convert back to the original angle (you can use the
    ARCSIN function for this).

Note:
    DATAPLOT computes Legendre elliptic integrals by computing the
    equivalent Carlson elliptic integrals.  The Carlson elliptic
    integrals are computed using the RC, RD, RF, and RJ routines
    from the SLATEC Common Mathematical Library to compute this
    function.  SLATEC is a large set of high quality, portable, public
    domain Fortran routines for various mathematical capabilities
    maintained by seven federal laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ELLIPC1 = Compute the Legendre complete elliptic integral of the
              first kind.
    ELLIPC2 = Compute the Legendre complete elliptic integral of the
              second kind.
    ELLIP2  = Compute the Legendre elliptic integral of the second
              kind.
    ELLIP3  = Compute the Legendre's elliptic integral of the third
              kind.
    RC      = Compute the degenerate Carlson elliptic integral.
    RD      = Compute the Carlson elliptic integral of the second kind.
    RF      = Compute the Carlson elliptic integral of the first kind.
    RJ      = Compute the Carlson elliptic integral of the third kind.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 17).
 
    "Numerical Recipes in FORTRAN", 2nd. Edition, Press, Teukolsky,
    Vetterling, and Flannery, Cambridge University Press, 1992 
    (chapter 6).

Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE AUTOMATIC
    LET ALPHA = PI/4
    PLOT ELLIP1(X,ALPHA) FOR X = 0.01 0.01 1.57
 
-----ELLIP2 (LET)--------------------------------
 
ELLIP2
 
Name:
    ELLIP2 (LET)
 
Type:
    Library Function
 
Purpose:
    Compute Legendre's elliptic integral of the second kind.
 
Description:
    Legendre's elliptic integral of the second kind is defined as:
        F(phi,alpha)=INT(SQRT(1-SIN(alpha)**2*SIN(theta)**2))dtheta
    where INT is the integral from 0 to phi.

    This function is often expressed as:
        F(phi,k)=INT(SQRT(1-k**2*SIN(alpha)**2))dtheta
    where INT is the integral from 0 to phi.  That is, k is the
    sine of alpha.

    In DATAPLOT, the input values are the angles given in radian
    units.  The first angle must be in the interval (0,PI/2).

Syntax:
    LET <y> = ELLIP2(<phi>,<alpha>)  <SUBSET/EXCEPT/FOR qualification>
    where <phi> is a number, variable, or parameter containing values
               in the interval (0,PI/2) exclusive;
          <alpha> is a number, variable, or parameter;
          <y> is a variable or a parameter (depending on what <phi> 
               and <alpha> are where the computed values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ELLIP2(0.7,1.1)
    LET A = ELLIP2(0.1,1.4)
    LET X2 = ELLIP2(X,0.3)
 
Note:
    If your angles are in degrees, be sure to convert them to radians
    first.  For example, to convert a 45 degree angle to radians, do:

       LET PHI = 45*(180/PI)

    Also, if your second parameter is in the form of sin(alpha), be
    sure to convert back to the original angle (you can use the
    ARCSIN function for this).

Note:
    DATAPLOT computes Legendre elliptic integrals by computing the
    equivalent Carlson elliptic integrals.  The Carlson elliptic
    integrals are computed using the RC, RD, RF, and RJ routines
    from the SLATEC Common Mathematical Library to compute this
    function.  SLATEC is a large set of high quality, portable, public
    domain Fortran routines for various mathematical capabilities
    maintained by seven federal laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ELLIPC1 = Compute the Legendre complete elliptic integral of the
              first kind.
    ELLIPC2 = Compute the Legendre complete elliptic integral of the
              second kind.
    ELLIP1  = Compute the Legendre elliptic integral of the first kind.
    ELLIP3  = Compute the Legendre's elliptic integral of the third
              kind.
    RC      = Compute the degenerate Carlson elliptic integral.
    RD      = Compute the Carlson elliptic integral of the second kind.
    RF      = Compute the Carlson elliptic integral of the first kind.
    RJ      = Compute the Carlson elliptic integral of the third kind.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 17).
 
    "Numerical Recipes in FORTRAN", 2nd. Edition, Press, Teukolsky,
    Vetterling, and Flannery, Cambridge University Press, 1992 
    (chapter 6).

Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE AUTOMATIC
    LET ALPHA = PI/4
    PLOT ELLIP2(X,ALPHA) FOR X = 0.01 0.01 1.57
 
-----ELLIP3 (LET)--------------------------------
 
ELLIP3
 
Name:
    ELLIP3 (LET)
 
Type:
    Library Function
 
Purpose:
    Compute Legendre's elliptic integral of the third kind.
 
Description:
    Legendre's elliptic integral of the third kind is defined as:
        F(phi,n,alpha)= INT([1/SQRT(1-SIN(alpha)**2*SIN(theta)**2)]*
             [1/(1-n*sin(theta)**2] )dtheta
    where INT is the integral from 0 to phi.

    This function is often expressed as:
        F(phi,n,k)= INT([1/SQRT(1-k**2*SIN(theta)**2)]*
             [1/(1+n*sin(theta)**2] )dtheta
    where INT is the integral from 0 to phi.  That is, k is the
    sine of alpha.

    In DATAPLOT, the input values for phi and alpha are the angles
    given in radian units.  The phi angle must be in the interval
    (0,PI/2).

Syntax:
    LET <y> = ELLIP3(<phi>,<n>,<alpha>)
                           <SUBSET/EXCEPT/FOR qualification>
    where <phi> is a number, variable, or parameter containing values
               in the interval (0,PI/2) exclusive;
          <n> is a number, variable, or parameter;
          <alpha> is a number, variable, or parameter;
          <y> is a variable or a parameter (depending on what <phi> 
               and <alpha> are where the computed values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ELLIP3(0.7,0.5,1.1)
    LET A = ELLIP3(0.1,0.2,1.4)
    LET X2 = ELLIP3(X,1.0,0.3)
 
Note:
    If your angles are in degrees, be sure to convert them to radians
    first.  For example, to convert a 45 degree angle to radians, do:

       LET PHI = 45*(180/PI)

    Also, if your third parameter is in the form of sin(alpha), be
    sure to convert back to the original angle (you can use the
    ARCSIN function for this).

Note:
    DATAPLOT computes Legendre elliptic integrals by computing the
    equivalent Carlson elliptic integrals.  The Carlson elliptic
    integrals are computed using the RC, RD, RF, and RJ routines
    from the SLATEC Common Mathematical Library to compute this
    function.  SLATEC is a large set of high quality, portable, public
    domain Fortran routines for various mathematical capabilities
    maintained by seven federal laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ELLIPC1 = Compute the Legendre complete elliptic integral of the
              first kind.
    ELLIPC2 = Compute the Legendre complete elliptic integral of the
              second kind.
    ELLIP1  = Compute the Legendre elliptic integral of the first kind.
    ELLIP2  = Compute the Legendre elliptic integral of the second
              kind.
    RC      = Compute the degenerate Carlson elliptic integral.
    RD      = Compute the Carlson elliptic integral of the second kind.
    RF      = Compute the Carlson elliptic integral of the first kind.
    RJ      = Compute the Carlson elliptic integral of the third kind.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 17).
 
    "Numerical Recipes in FORTRAN", 2nd. Edition, Press, Teukolsky,
    Vetterling, and Flannery, Cambridge University Press, 1992 
    (chapter 6).

Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE AUTOMATIC
    LET ALPHA = PI/4
    PLOT ELLIP3(X,0.5,ALPHA) FOR X = 0.01 0.01 1.57
 
-----ELLIPC1 (LET)--------------------------------
 
ELLIPC1
 
Name:
    ELLIPC1 (LET)
 
Type:
    Library Function
 
Purpose:
    Compute Legendre's complete elliptic integral of the first kind.
 
Description:
    Legendre's elliptic integral of the first kind is defined as:
        K(alpha)=ELLIP1(PI/2,alpha)
    where ELLIP1 is the Legendre elliptic integral of the first kind.
    See the documentation for ELLIP1 for details of this function.

    This function is often expressed as:
        F(m)=ELLIP1(PI/2,m)
    where m is the sin(alpha)**2.  The value k = sin(alpha) is
    also used.

    In DATAPLOT, the input value is m, the sin(alpha)**2.

Syntax:
    LET <y> = ELLIPC1(<m>)  <SUBSET/EXCEPT/FOR qualification>
    where <m> is a number, variable, or parameter in the range 0
              to 1;
          <y> is a variable or a parameter (depending on what <alpha> 
               is where the computed values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ELLIPC1(0.1)
    LET A = ELLIPC1(0.4)
    LET Y = ELLIPC1(X)
 
Note:
    DATAPLOT computes Legendre elliptic integrals by computing the
    equivalent Carlson elliptic integrals.  The Carlson elliptic
    integrals are computed using the RC, RD, RF, and RJ routines
    from the SLATEC Common Mathematical Library to compute this
    function.  SLATEC is a large set of high quality, portable,
    public domain Fortran routines for various mathematical
    capabilities maintained by seven federal laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ELLIPC2 = Compute the Legendre complete elliptic integral of the
              second kind.
    ELLIP1  = Compute the Legendre elliptic integral of the first kind.
    ELLIP2  = Compute the Legendre elliptic integral of the second
              kind.
    ELLIP3  = Compute the Legendre's elliptic integral of the third
              kind.
    RC      = Compute the degenerate Carlson elliptic integral.
    RD      = Compute the Carlson elliptic integral of the second kind.
    RF      = Compute the Carlson elliptic integral of the first kind.
    RJ      = Compute the Carlson elliptic integral of the third kind.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 17).
 
    "Numerical Recipes in FORTRAN", 2nd. Edition, Press, Teukolsky,
    Vetterling, and Flannery, Cambridge University Press, 1992 
    (chapter 6).

Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE AUTOMATIC
    PLOT ELLIPC1(ALPHA) FOR ALPHA = 0.01 0.01 0.99
 
-----ELLIPC2 (LET)--------------------------------
 
ELLIPC2
 
Name:
    ELLIPC2 (LET)
 
Type:
    Library Function
 
Purpose:
    Compute Legendre's complete elliptic integral of the second kind.
 
Description:
    Legendre's elliptic integral of the second kind is defined as:
        K(alpha)=ELLIP2(alpha)
    where ELLIP2 is the Legendre elliptic integral of the second kind.
    See the documentation for ELLIP2 for details of this function.

    This function is often expressed as:
        F(m)=ELLIP2(PI/2,m)
    where m is the sin(alpha)**2.  The value k = sin(alpha) is
    also used.

    In DATAPLOT, the input value is m, the sin(alpha)**2.

Syntax:
    LET <y> = ELLIPC2(<m>)  <SUBSET/EXCEPT/FOR qualification>
    where <m> is a number, variable, or parameter in the range 0 
               to 1;
          <y> is a variable or a parameter (depending on what <m> 
               is where the computed values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ELLIPC2(0.1)
    LET A = ELLIPC2(0.4)
    LET Y = ELLIPC2(X)
 
Note:
    DATAPLOT computes Legendre elliptic integrals by computing the
    equivalent Carlson elliptic integrals.  The Carlson elliptic
    integrals are computed using the RC, RD, RF, and RJ routines
    from the SLATEC Common Mathematical Library to compute this
    function.  SLATEC is a large set of high quality, portable,
    public domain Fortran routines for various mathematical
    capabilities maintained by seven federal laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ELLIPC1 = Compute the Legendre complete elliptic integral of the
              first kind.
    ELLIP1  = Compute the Legendre elliptic integral of the first kind.
    ELLIP2  = Compute the Legendre elliptic integral of the second
              kind.
    ELLIP3  = Compute the Legendre's elliptic integral of the third
              kind.
    RC      = Compute the degenerate Carlson elliptic integral.
    RD      = Compute the Carlson elliptic integral of the second kind.
    RF      = Compute the Carlson elliptic integral of the first kind.
    RJ      = Compute the Carlson elliptic integral of the third kind.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 17).
 
    "Numerical Recipes in FORTRAN", 2nd. Edition, Press, Teukolsky,
    Vetterling, and Flannery, Cambridge University Press, 1992 
    (chapter 6).

Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE AUTOMATIC
    PLOT ELLIPC2(ALPHA) FOR ALPHA = 0.01 0.01 0.99
 
-----ELLIPSE-------------------------------------------------------
 
ELLIPSE
 
Name:
    ELLIPSE
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Draws an ellipse.
 
Description:
    The 3 pairs of coordinates define the (x,y) values for one major
    diameter endpoint, one minor diameter endpoint, and the other major
    diameter endpoint (respectively) of the ellipse.
 
Syntax:
    ELLIPSE   <x1>   <y1>   <x2>   <y2>   <x3>   <y3>
    where <x1> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for one major diameter
               endpoint of the ellipse;
          <y1> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for one major diameter
               endpoint of the ellipse;
          <x2> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for one minor diameter
               endpoint of the ellipse;
          <y2> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for one minor diameter
               endpoint of the ellipse.
          <xn> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for the other major
               diameter endpoint of the ellipse;
          <yn> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for the other major
               diameter endpoint of the ellipse.
 
Examples:
    ELLIPSE 30 50 50 40 70 50
    ELLIPSE 30 30 50 40 70 70
    ELLIPSE 20 70 30 50 40 70
    ELLIPSE X1 Y1 X2 Y2 X3 Y3
    ELLIPSE 50 50 X2 Y2 70 50
    ELLIPSE 40 50 50 30 60 50
 
Note:
    The line style (i.e., SOLID, DASH), line color, and line thickness
    are dictated by the first entry of the LINE, LINE COLOR, and LINE
    THICKNESS commands respectively.  The REGION FILL command can be
    used to generate a solid filled ellipse (ellipses can not currently
    be filled with hatch patterns).
 
Note:
    The keywords DATA and RELATIVE were added to the TRIANGLE
    command 7/1997.  These keywords are independent and can
    be used separately or together.  For example, 
    TRIANGLE DATA, TRIANGLE RELATIVE, or TRIANGLE DATA RELATIVE.
    The word DATA should come before the word RELATIVE if both
    appear.

    DATA means that the coordinates are specified in terms of
    the data units of the most recent plot rather than Dataplot
    0 to 100 screen units.

    RELATIVE means that the coordinates of the first point
    are drawn in absolute coordinates an all subsequent points
    in the figure are relative to that first point.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    POINT            = Draws a point.
    ARROW            = Draws an arrow.
    TRIANGLE         = Draws a triangle.
    BOX              = Draws a box.
    HEXAGON          = Draws a hexagon.
    CIRCLE           = Draws a circle.
    SEMI-CIRCLE      = Draws a semi-circle.
    ARC              = Draws an arc.
    ELLIPSE          = Draws an ellipse.
    OVAL             = Draws an oval.
    DIAMOND          = Draws a diamond.
    DRAW             = Draws a line.
    MOVE             = Moves to a point.
    LINES            = Sets the line type for figures and plot lines.
    LINE THICKNESSES = Sets the line thickness for figures and  plot
                       lines.
    LINE COLOR       = Sets the line colors for figures and plot lines.
    CROSS-HAIR       = Activates and reads the cross-hair.
    TEXT             = Writes a text string.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    Pre-1987
 
Program:
    ELLIPSE 10 20 15 10 20 20
    ELLIPSE 60 30 70 10 80 30
    .
    THICKNESS 0.7
    ELLIPSE 10 40  15 30 20 40
    THICKNESS 0.2
    .
    LINE DASH
    ELLIPSE 10 60 15 55 20 60
    LINE SOLID
    .
    LINE COLOR G50
    ELLIPSE 10 90 15 80 20 90
    LINE COLOR BLACK
    .
    REGION FILL ON
    ELLIPSE 30 35  32.5 30 35 35
    REGION FILL COLOR G50
    ELLIPSE 40 60 50 40 60 60
 
-----EN (LET)--------------------------------
 
EN
 
Name:
    EN (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Euler number or the Euler polynomial.
 
Description:
    The Euler numbers can be defined by the recurrence relation:

        E(n) = -SUM[(2*n)!/((2*k)!(2*n-2*k)!)*E(2*k)    (n>=1)

    where n defines the order of the Euler number, the
    summation is from k = 0 to n-1, "!" is the factorial
    function, and E(0) = 1.  

    The Euler polynomials can be defined in terms of the
    Euler numbers:

        E(x,n) = SUM[n!E(k)/(2**k*k!*(n-k)!)*(x-0.5)**(n-k)]

    where the summation is from k = 0 to n, and E(k) is
    the Euler number of order k.

    Dataplot computes this function using the EULERB and EULERP
    routines from "Computation of Special Functions" (see the
    Reference section below).
 
Syntax 1:
    LET <y> = EN(<x>,<n>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, variable or parameter;
          <n> is a non-negagive integer number, variable or
              parameter;
          <y> is a variable or a parameter (depending on what <x> 
               and <n> are) where the computed Euler polynomial
               values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the Euler polynomial of order <n>.

Syntax 2:
    LET <y> = EN(<n>)    <SUBSET/EXCEPT/FOR qualification>
    where <n> is a non-negagive integer number, variable or
              parameter;
          <y> is a variable or a parameter (depending on what <n> 
               is) where the computed Euler numbers are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the Euler number of order <n>.

Examples:
    LET A = EN(12)
    LET A = EN(B)
    LET A = EN(2.5,4)
    LET Y = EN(X,N)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BN           = Compute Bernoulli number or polynomial.
 
Reference:
    "Computation of Special Functions", Shanjie Zhang and Jianming
    Jin, John Wiley and Sons, 1996, chapter 1.
 
Applications:
    Probability
 
Implementation Date:
    1997/12
 
Program:
    TITLE AUTOMATIC
    PLOT EN(X,2) FOR X = 0 0.01 5

-----END-----------------------------------------------------
 
END
 
Name:
    END
 
Type:
    Support Command
 
Purpose:
    Exit from DATAPLOT.
 
Syntax:
    END
 
Examples:
    END
 
Default:
    None
 
Synonyms:
    EXIT
    STOP
    QUIT
    BYE
    HALT
 
Applications:
    XX
 
Implementation Date:
    Pre-1987
 
Program:
    XX
 
-----END OF CAPTURE--------------------------------------------------
 
END OF CAPTURE
 
Name:
    END OF CAPTURE
 
Type:
    Support Command
 
Purpose:
    The CAPTURE command redirects DATAPLOT alphanumeric output to a
    file rather than to the screen.  The END OF CAPTURE command reverts
    alphanumeric output back to the screen.
 
Syntax:
    END OF CAPTURE
 
Examples:
    CAPTURE FITOUT.DAT
    END OF CAPTURE
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CAPTURE         = Re-directs alphanumeric output to a file.
    LIST            = Lists the contents of a file.
    CALL            = Execute commands stored in a file.
    CREATE          = Echo entered commands to a file.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    ECHO ON
    FEEDBACK ON
    CAPTURE FITOUT.DAT
    FIT Y X1 X2
    END OF CAPTURE
 
-----END OF CREATE----------------------------------------------------
 
END OF CREATE
 
Name:
    END OF CREATE
 
Type:
    Support Command
 
Purpose:
    Terminates the automatic copying of commands out to a "macro" file.
 
Syntax:
    END OF CREATE
 
Examples:
    END OF CREATE
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CREATE           = Echo entered commands to a file.
    CALL             = Executes the commands in a "macro" file.
    END OF DATA      = Defines the end of data for READ and SERIAL
                       READ.
    END OF LOOP      = Defines the end of a loop.
    END OF MULTIPLOT = Defines the end of multiplotting.
    END              = Terminates a DATAPLOT run.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XX
 
-----END OF DATA-------------------------------------------------------
 
END OF DATA
 
Name:
    END OF DATA
 
Type:
    Support Command
 
Purpose:
    Specifies the end of a data set being read from the terminal or
    from a file via the READ or the SERIAL READ command.
 
Description:
    This command is most commonly used when reading data from the
    terminal.  For example, to specify that the variable X should have
    the values 25, 75, 109.3, 145, and 160, one could enter from the
    terminal:
       READ X
       25
       75
       109.3
       145
       160
       END OF DATA
    or
       SERIAL READ X
       25 75 109.3 145 160
       END OF DATA
    If these above 5 data points reside in a file, then a READ or
    SERIAL READ of that file proceeds until the first occurrence of any
    one of the following:
       1) an end of file is encountered;
       2) an END OF DATA statement is encountered;
       3) a ROW LIMITS specification has been met.
    When an END OF DATA statment is used in a file, it should be
    inserted (via the editor) on a separate line.  In practice, the END
    OF DATA statement is rarely used when reading data from a file.  It
    is more typical to simply allow DATAPLOT to read the file until an
    end of file is encountered.
 
Syntax:
    END OF DATA
 
Examples:
    END OF DATA
 
Default:
    None
 
Synonyms:
    END OF READ
 
Related Commands:
    READ             = Reads data (column-wise) into variables.
    SERIAL READ      = Reads data (row-wise) into variables.
    ROW LIMITS       = Sets the file lines to be included in subsequent
                       reads.
    SKIP             = Sets the number of lines to skip over in read.
    WRITE            = Writes variable, parameter, or function to the
                       screen or to a file.
    LIST             = Lists the contents of a file (or the last 20
                       commands).
    STATUS           = Displays current variables, parameters, and
                       functions, etc.
    END OF CREATE    = Stops copying commands to a "macro" file.
    END OF LOOP      = Defines the end of a loop.
    END OF MULTIPLOT = Defines the end of multiplotting.
    EXIT             = Terminates a DATAPLOT run.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
       SERIAL READ X
       25 75 109.3 145 160
       END OF DATA
       PLOT X
 
-----END OF IF-------------------------------------------------------
 
END OF IF
 
Name:
    END OF IF
 
Type:
    Support Command
 
Purpose:
    Defines the end of an IF block.
 
Syntax:
    END OF IF
 
Examples:
    END OF IF
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    IF               = Defines the beginning of an IF block.
    LOOP             = Defines the beginning of a loop.
    END OF CREATE    = Stops copying commands to "macro" file.
    END OF DATA      = Defines end of data for READ/SERIAL READ.
    END OF MULTIPLOT = Defines the end of multiplotting.
    EXIT             = Terminates a DATAPLOT run.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET A = Y1(10)
    IF A < 0
      LET Y1(10)=ABS(A)
    END OF IF
 
-----END OF LOOP-------------------------------------------------------
 
END OF LOOP
 
Name:
    END OF LOOP
 
Type:
    Support Command
 
Purpose:
    Defines the end of a loop.
 
Syntax:
    END OF LOOP
 
Examples:
    END OF LOOP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LOOP             = Defines the beginning of a loop.
    IF               = Defines the beginning of an IF block.
    END OF IF        = Defines the end of an IF block.
    END OF CREATE    = Stops copying commands to "macro" file.
    END OF DATA      = Defines the end of data for the READ and SERIAL
                       READ commands.
    END OF MULTIPLOT = Defines the end of multiplotting.
    EXIT             = Terminates a DATAPLOT run.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    LET Y1 = NORMAL RANDOM NUMBER FOR I = 1 1 100
    LET Y2 = EXPONENTIAL RANDOM NUMBERS FOR I = 1 1 100
    LET Y3 = T RANDOM NUMBERS FOR I = 1 1 100
    LET Y4 = CAUCHY RANDOM NUMBERS FOR I = 1 1 100
    LET STRING T1 = NORMAL RANDOM NUMBERS
    LET STRING T2 = EXPONENTIAL RANDOM NUMBERS
    LET STRING T3 = T RANDOM NUMBERS
    LET STRING T4 = CAUCHY RANDOM NUMBERS
    LET X = SEQUENCE 1 1 100
    MULTIPLOT 2 2
    LOOP FOR K = 1 1 4
       TITLE ^T^K
       HISTOGRAM Y^K
    END OF LOOP
 
-----END OF MULTIPLOT--------------------------------------------------
 
END OF MULTIPLOT
 
Name:
    END OF MULTIPLOT
 
Type:
    Support Command
 
Purpose:
    Defines the end of a multiplotting (automatic multiple plots per
    page) sequence.
 
Syntax:
    END OF MULTIPLOT
 
Examples:
    END OF MULTIPLOT
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    MULTIPLOT        = Defines the beginning of multiplotting.
    END OF CREATE    = Stops copying commands to "macro" file.
    END OF LOOP      = Defines the end of a loop.
    EXIT             = Terminates a DATAPLOT run.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    LET THETA = SEQUENCE 0 1 380
    LET X = SIN(THETA)
    MULTIPLOT 3 4
    FEEDBACK OFF
    FRAME OFF
    PRE-SORT OFF
    LOOP FOR K = .1 .1 1.2
       LET Y=SIN(K*THETA)
       XLABEL \K
       PLOT Y X
    END OF LOOP
    END OF MULTIPLOT
 
-----EMBED-------------------------------------------------------
 
EMBED
 
Name:
    EMBED
 
Type:
    Plot Control Command
 
Purpose:
    Provides an alternative method for generating multiplot plots
    per page.
 
Description:
    The MULTIPLOT command is the standard command used to generate
    multiplot plots per page.  It works by defining a grid of equal
    sized sub-plot areas.  That is, MULTIPLOT 4 3 will define a grid
    of 4 rows and 3 columns (for a total of 12) of plots.  Each subsequent
    plot is generated in the next grid location.

    The EMBED command provides an alternative method for generating
    multiplot plots per page.  It works as follows:

       1. Enter the EMBED ON command.

       2. The first plot generated after the EMBED ON command defines
          a base coordinates system.  In some cases, this first plot
          will essentially be a dummy plot.  In other cases, it will
          generate a background plot.

       3. For subsequent plots, enter the command

             EMBED CORNER COORDINATES <xlow> <ylow> <xhigh> <yhigh>

          The parameters for this command are given in units of the
          base coordinate system (i.e., the coordinates defined by
          the first plot after the EMBED ON command).  The coordinates
          given on the EMBED CORNER COORDINATES command now define
          a sub-plot area where subsequent plots are drawn.

          Note that the EMBED CORNER COORDINATES defines where the
          subsequent plot will be drawn.  That subsequent plot will
          have it's own coordinate system that is independent of
          the base coordinate system.

          Typically, you will have a separate EMBED CORNER COORDINATES
          command for each subsequent plot.  However, you can in fact
          overlay multiple plots in a single sub-plot area if needed.

       4. Enter EMBED OFF to end the EMBED sequence.

    Although EMBED is similar to MULTIPLOT, there are several
    important distinctions.

       1. The EMBED command allows you to create a "background"
          plot that covers the full plot region.

       2. The EMBED command does not require equal sized sub-plot
          areas.  You can define an arbitrary sub-plot area.  The
          sub-plot area is still limited to rectangular regions
          and it must lie within the base coordinate system defined
          by the first plot.

    The EMBED command has several typical uses.

       1. It can be used to arbitrarily position sub-plots on the
          page.

       2. It can be used to create summary plots for a sub-plot
          region.

Syntax 1:
    EMBED  <ON/OFF>
    where ON starts an embed sequence and OFF ends an embed sequence.
 
Syntax 2:
    EMBED CORNER COORDINATES  <x1>  <y1>  <x2>  <y2>
    where <x1> is a decimal number or parameter that specifies the
               horizontal position of the lower left corner;
          <y1> is a decimal number or parameter that specifies the
               vertical position of the lower left corner;
          <x2> is a decimal number or parameter that specifies the
               horizontal position of the upper right corner;
          <y2> is a decimal number or parameter that specifies the
               vertical position of the upper right corner.
 
    The values of <x1>, <y1>, <x2>, and <y2> are given in units of
    the first plot generated after the EMBED ON command (the base
    coordinate system).  If a subsequent plot specifies embed
    corner coordinates that are outside the range of the base
    coordinate system, an error will be reported and the plot will
    not be generated.

    Note that the corner coordinates given here simply position the
    plot area.  This is independent of the coordinate system for
    the subsequent plot.

Examples:
    EMBED ON
    PLOT Y X
    EMBED CORNER COORDINATES 200 10 350 45
    HISTOGRAM Z
    EMBED OFF
 
Note:
    The MULTIPLOT SCALE command will be used to scale the size of
    hardware text characters when the EMBED sequence is active.  The
    scaling will not be applied to the first plot after the EMBED ON
    command since this is a full size plot.
 
Note:
    The MULTIPLOT and EMBED options cannot be used together.  When a
    plot is generated, if both MULTIPLOT and EMBED are active, an
    error will be reported and no plot will be generated.

Note:
    There is no restriction on the type of plot that can be used in
    conjunction with the EMBED command.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    MULTIPLOT               = Generate multiple plots per page.
    MULTIPLOT SCALE FACTOR  = Specify a scaling factor for text when
                              MULTIPLOT or EMBED are used.
 
Applications:
    Exploratory Data Analysis
 
Reference:
    Grolemund and Wickham (2015), "Visualizing Complex Data With
    Embedded Plots", Journal of Computational and Graphical Statistics,
    Vol. 24, No. 1, pp. 26-43.

Implementation Date:
    2015/8
 
Program 1:
    . Step 1:   Define the outer coordinate system
    .
    limits 0 10
    line blank
    multiplot scale factor 5
    embed on
    plot x for x = 1 1 9
    .
    . Step 2:   Now generate sub-plots
    .
    .           Note that in this case, the sub-plots
    .           are independent of the primary plot
    .
    frame corner coordinates 0 0 100 100
    tic marks off
    tic mark labels off
    title offset -10
    limits
    line solid
    .
    title x**2 for x = 1 1 9
    embed corner coordinates 2.5 4.5 3.5 5.5
    plot x**2 for x = 1 1 9
    .
    title -x for x = 1 1 9
    embed corner coordinates 7.5 6.5 8.5 7.5
    plot -x for x = 1 1 9
    .
    . Step 3:   Exit embed mode
    .
    embed off
 
Program 2:
    . Step 1:   Read the data
    .
    skip 25
    read morales2.dat y1 y2 y3 scan set standard
    let nset = unique set
    let nstan = unique standard
    .
    . Step 2:   Define the outer coordinate system
    .
    set let cross tabulate collapse
    let ymed = cross tabulate median y1 standard set
    let x1 = cross tabulate group one standard set
    let x2 = cross tabulate group two standard set
    let a1 = 0.25 quantile ymed
    let a2 = 0.50 quantile ymed
    let a3 = 0.75 quantile ymed
    let z0 = data a1 a2 a3
    region color red yellow cyan blue
    .
    xlimits 1 nstan
    major xtic mark number nstan
    minor xtic mark number 0
    x1tic mark offset 0.5 0.5
    x1label Experiment ID
    x1label displacement 5
    .
    ylimits 1 nset
    major ytic mark number nset
    minor ytic mark number 0
    y1tic mark offset 0.5 0.5
    y1label Set ID
    y1label displacement 5
    .
    frame corner coordinates 8 8 95 95
    title offset 2
    title Histograms of Y1 by Set and Experiment (MORALES2.DAT)
    .
    line blank
    embed on
    discrete contour plot y x1 x2 z0
    .
    title
    label
    limits
    major tic mark number
    minor tic mark number
    tic mark offset 0 0
    .
    . Step 3:   Now generate sub-plots
    .
    frame corner coordinates 0 0 100 100
    tic marks off
    tic mark labels off
    line solid
    xlimits 21.4 23.4
    ylimits 0 6
    .
    loop for k = 1 1 nstan
        let xc1 = k - 0.5
        let xc2 = k + 0.5
        loop for l = 1 1 nset
            let yc1 = l - 0.5
            let yc2 = l + 0.5
            embed corner coordinates xc1 yc1 xc2 yc2
            . kernel density plot y1 subset standard k  subset set l
            histogram y1 subset standard k  subset set l
        end of loop
    end of loop
    .
    . Step 4:   Exit embed mode and close the plot
    .
    embed off
 
-----EMPIRICAL CDF PLOT--------------------------------------
 
EMPIRICAL CDF PLOT
 
Name:
    EMPIRICAL CDF PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a empirical cumulative distribution function (cdf)
    plot.
 
Description:
    In reliability analysis, many data sets consists of a set of
    failure times, which may be truncated at some limit value. 
    The cumulative distribution function (CDF) is defined
    as:
       F(t) = prob(T < t)
    where T is the lifetime of a randomly selected unit.
 
    A empirical cdf plot is a plot of the empirical CDF versus
    failure time.  The failure time is plotted on the horizontal
    axis.  At each failure time, the following two points are
    calculated and plotted on the vertical axis:
       y1 = (I - 1)/N
       y2 = I/N
    where N is the number of data points and I is the rank of the
    failure time.  The last failure time only calculates one of these
    points.
 
    When all of the points are connected, a staircase type plot
    results.  The vertical step is constant for the failure times,
    while the lengths of the horizontal steps are determined by the
    distances between failure times.
 
    This plot is closely related to the TAIL AREA PLOT and the
    KAPLAN MEIER PLOT.

Syntax 1:
    EMPIRICAL CDF PLOT   <y>     <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable containing failure times;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    EMPIRICAL CDF PLOT <y> <x>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable containing counts;
          <x> is a response variable containing failure times;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This synatx is used for binned data.  That is, <x> contains
    the failure times and <y> contains the number of occurences
    corresponding to each failure time.

Examples:
    EMPIRICAL CDF PLOT Y1
    EMPIRICAL CDF PLOT Y1 SUBSET TAG > 1
    EMPIRICAL CDF PLOT Y X

Note:
    You can optionally generate approximate confidence intervals for the
    empirical cdf plot.  To generate the confidence interval, enter

       SET EMPIRICAL CDF PLOT CONFIDENCE LIMITS ON

    To turn off the confidence limits, enter
 
       SET EMPIRICAL CDF PLOT CONFIDENCE LIMITS OFF

    These confidence intervals are based on a binomial approximation to
    the normal distribution (Higgins, pp. 15-16)

       Fhat(x) +/- NORPPF(1-alpha/2)*SQRT(Fhat(x)*(1-Fhat(x)/n)

    with NORPPF  and alpha denoting the percent point function of the
    standard normal distribution and the confidence level, respectively.

    By default, 95% confidence levels are generated.  To specify a different
    confidence level, enter the command

       LET ALPHA = <value>

    where common values for <value> are 0.90 or 0.99.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LINES             = Sets the type for plot lines.
    CHARACTERS        = Sets the type for plot characters.
    TAIL AREA PLOT    = Generates a tail area plot.
    KAPLAN MEIER PLOT = Generates a Kaplan Meier plot.
    ... HAZARD PLOT   = Generates a hazard plot.
    PROBABILITY PLOT  = Generates a probability plot.
    PLOT              = Generates a data or function plot.
 
References:
    Higgins (2004), "Introduction to Modern Nonparametric Statistics,"
    Duxbury Press, pp. 15-16.

Applications:
    Reliability
 
Implementation Date:
    1998/08
    2023/05: Added support for confidence intervals
 
Program 1:
    SKIP 25
    READ HAHN.DAT MILES  TAG
    TITLE EMPIRICAL CDF PLOT OF HAHN.DAT
    Y1LABEL CDF
    X1LABEL FAILURE TIME
    XLIMITS 0 150000
    EMPIRICAL CDF PLOT MILES SUBSET TAG = 1
 
Program 2:
    . Step 1:   Read some data
    .
    skip 25
    read weibbury.dat y
    skip 0
    .
    . Step 2:   Set some plot control
    .
    case asis
    title case asis
    tic mark label case asis
    label case asis
    .
    line solid dotted dotted
    line color black blue blue
    .
    ylimits 0 1
    .
    . Step 3:   Generate plot
    .
    set empirical cdf plot confidence limits on
    empirical cdf plot y

-----EMPIRICAL QUANTILE FUNCTION (LET)-------------------------------------
 
EMPIRICAL QUANTILE FUNCTION
 
Name:
    EMPIRICAL QUANTILE FUNCTION (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the empirical quantile function.
 
Description:
    The quantile function is the inverse of the cumulative distribution
    function, F,

          Q(u) = F**(-1)(u)    0 < u < 1

    Given a set of ordered data, x(1) <= x(2) ... <= x(n), an empirical
    estimate of the quantile function can be obtained from the following
    piecewise linear function

          Qhat(u) = (N*u - j + (1/2))*X(j+1) +
                    (j + (1/2) - N*u)*X(j)

                    (2-j-1)/(2*N) <= u < (2*j+1)/(2*n)
                    j = 1, 2, ... n-1

    This will be computed for a specified number of equi-spaced points
    between the lower and upper limits.  Dataplot will use the number of
    points in the sample if this is greater than 1,000.  Otherwise 1,000
    points will be used.

Syntax:
    LET <y> <u> = EMPIRICAL QUANTILE FUNCTION <x>
                  <SUBSET/EXCEPT/FOR qualification>
    where <x> is the response variable;
          <y> is a variable containing the empirical quantile
              function values;
          <u> is a variable containing the values where the empirical
              quantile function is computed;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y U = EMPIRICAL QUANTILE FUNCTION X
    LET Y U = EMPIRICAL QUANTILE FUNCTION X  SUBSET X > 0
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EMPIRICAL QUANTILE PLOT        = Generate an empirical quantile plot.
    EMPIRICAL CDF PLOT             = Generate an empirical CDF plot.
    KAPLAN MEIER PLOT              = Generate a Kaplan Meier plot.
    PROBABILITY PLOT               = Generate a probability plot.
    INFORMATIVE QUANTILE FUNCTION  = Compute the informative quantile
                                     function.

References:
    "MIL-HDBK-17-1F Volume 1: Guidelines for Characterization of
    Structural Materials", Depeartment of Defense, pp. 8-36, 8-37, 2002.
 
    Parzen (1983), "Informative Quantile Functions and Identification of
    Probability Distribution Types", Technical Report No. A-26, Texas A&M
    University.

Applications:
    Distributional Analysis
 
Implementation Date:
    2017/02
 
Program:
    . Step 1:   Define some default plot control features
    .
    title offset 2
    title case asis
    case asis
    label case asis
    line color blue red
    multiplot scale factor 2
    multiplot corner coordinates 5 5 95 95
    .
    . Step 2:   Create 50, 100, 200, and 1000 normal random numbers and
    .           compute the empirical quantile funciton
    .
    let nv = data 50 100 200 1000
    let p = sequence 0.01 0.01 .99
    let y2 = norppf(p)
    .
    . Step 3:   Loop through the four cases and compute and plot the
    .           empirical quantile funciton with overlaid NORPPF
    .
    multiplot 2 2
    loop for k = 1 1 4
        let n = nv(k)
        let x = norm rand numb for i = 1 1 n
        let y u = empirical quantile function x
        title N: ^n
        plot y u and
        plot y2 p
    end of loop
    end of multiplot
    .
    justification center
    move 50 97
    text Empirical Quantile Functions (blue) Overlaid with ...
    NORPPF (red) for Normal Random Numbers
    move 50 5
    text u
    direction vertical
    move 5 50
    text Q(u)

-----EMPIRICAL QUANTILE PLOT--------------------------------------
 
EMPIRICAL QUANTILE PLOT
 
Name:
    EMPIRICAL QUANTILE PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates an empirical quantile plot, and optionally, overlays a
    quantile box plot.
 
Description:
    The empirical quantile function of a variable is defined as

                 Qhat(u) = (N*u - j + (1/2))*X(j+1) +
                           (j + (1/2) - N*u)*X(j)

                           (2-j-1)/(2*N) <= u < (2*j+1)/(2*n)
                           j = 1, 2, ... n-1

    This will be computed for a specified number of equi-spaced points
    between the lower and upper limits.  Dataplot will use the minimum
    of 1,000 points and the number of points in the sample.

    This plot is essentially the inverse of the empirical CDF plot.

    The empirical quantile plot can be enhanced with an overlaid
    quantile box plot (see Syntax 4).  The QUANTILE BOX PLOT command
    will first generate the empirical quantile plot and then it will
    overlay the quantile box plot.  The quantile box plot draws the
    following rectangles:

        1. The rectangle enclosing the 25% and 75% percentiles.
        2. The rectangle enclosing the 12.5% and 87.5% percentiles.
        3. The rectagle enclosing the 6.25% and 93.75% percentiles.
        4. A horizontal line is drawn through the median.

    The quantile box plot can help in assesing the symmetry, tail
    behavior, and the presence of outliers of the underlying distribution
    of the data.

    These plots are suggested as exploratory data analysis techniques
    in the MIL-HANDBK-17 (2002 edition).  They were originally suggested
    by Parzen (see References below).

Syntax 1:
    EMPIRICAL QUANTILE PLOT   <y>     <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    MULTIPLE EMPIRICAL QUANTILE PLOT  <y1> ... <yk>
                                      <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of 1 to 30 response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax generates an empirical quantile plot for each listed
    response variable.  These response variables can be matrices.

    The TO syntax is supported for this case.

Syntax 3:
    REPLICATED EMPIRICAL QUANTILE PLOT  <y> <x1> <x2>
                                        <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <x1> is the first (required) group-id variables;
          <x2> is the second (optional) group-id variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax peforms a cross-tabulation of <x1> and <x2> and generates
    the quantile function plot for each unique combination of
    cross-tabulated values.  For example, if X1 has 3 levels and X2 has
    2 levels, there will be a total of 6 plots generated.

Syntax 4:
    QUANTILE BOX PLOT <y>    <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable containing failure times;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    The MULTIPLE and REPLICATED options are not supported for this
    syntax.

Examples:
    EMPIRICAL QUANTILE PLOT Y1
    EMPIRICAL QUANTILE PLOT Y1 SUBSET TAG > 1
    MULTIPLE EMPIRICAL QUANTILE PLOT Y1 Y2 Y3 Y4 Y5
    MULTIPLE EMPIRICAL QUANTILE PLOT Y1 TO Y5
    REPLICATED EMPIRICAL QUANTILE PLOT Y X
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LINES                                = Sets the type for plot lines.
    CHARACTERS                           = Sets the type for plot characters.
    TRUNCATED INFORMATIVE QUANTILE PLOT  = Generate a truncated informative
                                           quantile plot.
    EMPIRICAL CDF PLOT                   = Generates a tail area plot.
    KAPLAN MEIER PLOT                    = Generates a Kaplan Meier plot.
    ... HAZARD PLOT                      = Generates a hazard plot.
    PROBABILITY PLOT                     = Generates a probability plot.
    PLOT                                 = Generates a data or function plot.

References:
    "MIL-HDBK-17-1F Volume 1: Guidelines for Characterization of
    Structural Materials", Depeartment of Defense, pp. 8-36, 8-37, 2002.
 
    Parzen (1983), "Informative Quantile Functions and Identification of
    Probability Distribution Types", Technical Report No. A-26, Texas A&M
    University.
 
Applications:
    Reliability
 
Implementation Date:
    2017/02
 
Program:
    . Step 1:   Read the data
    .
    skip 25
    read weibbury.dat y1
    read exp.dat y2
    read lgn.dat y3
    read gamma.dat y4
    .
    . Step 2:   Define some default plot control features
    .
    title offset 2
    title case asis
    case asis
    label case asis
    multiplot scale factor 2
    multiplot corner coordinates 5 5 95 95
    .
    . Step 3:   Generate the empirical quantile plot
    .
    multiplot 2 2
    .
    title WEIBBURY.DAT
    empirical quantile plot y1
    .
    title EXP.DAT
    empirical quantile plot y2
    .
    title LGN.DAT
    empirical quantile plot y3
    .
    title GAMMA.DAT
    empirical quantile plot y4
    .
    end of multiplot
    .
    justification center
    move 50 97
    text Empirical Quantile Plots
    move 50 5
    text u
    direction vertical
    move 5 50
    text Q(u)
    .
    . Step 4:   Demonstrate multiple option
    .
    y1label Q(u)
    x1label u
    title automatic
    line color black blue red green
    .
    multiple empirical quantile plot y1 to y4
    .
    . Step 5:   Demonstrate quantile box plot
    .
    line color black all
    line solid dotted dotted dotted dotted
    quantile box plot y1
    .
    line solid all
    .
    . Step 6:    Demonstrate replication option
    .
    skip 25
    read gear.dat y x
    line color black all
    line solid all
    character blank all
    .
    replicated empirical quantile plot y x

-----EQUAL SLOPES TEST-------------------------------------------
 
EQUAL SLOPES TEST
 
Name:
    EQUAL SLOPES TEST
 
Type:
    Analysis Command
 
Purpose:
    Test two or more linear regression lines to see if they have
    equal slopes.
 
Description:
    It is occasionally of interest whether or not two regression lines
    have the same slope.  That is, given

        y1 = a1 + b1*x1
        y2 = a2 + b2*x2

    we want to test whether b1 = b2.

    For example, this might be of interest when we are fitting a
    regression line based on two different measurement methods and we
    would like to know if the fits are equivalent.

    If the residul variances from the two regressions are statistically
    equivalent, the test statstic is

       that = |b1 - b2|/SQRT(TERM1*TERM2)

    where

       TERM1 = s**2(y1.x1)*(n1-2) + s*2(y2.x2)*(n2-2)/(n1+n2-4)
       TERM2 = 1/Q(x1) + 1/Q(x2)

       s**2(y.x) = SUM[(y(i) - ybar)**2]/(n-2)
       Q(x)      = SUM[(x(i) -xbar)**2]

    This test statistic is compared to a t distribution with
    n1 + n2 - 4 degrees of freedom.

    If the residual variances are not statistically equivalent and
    n1 and n2 are both greater than 20, the test statistic is

       zhat = |b1 - b2|/SQRT(s**2(y1.x1)/Q(x1) + s**2(y2.x2)/Q(x2))

    This is compared to a standard normal distribution.  If n1 or
    n2 is less than or equal to 20, the test statistic is compared
    to a t distribution with nu degrees of freedom where

        nu = 1/[c**2/(n1-2) + (1-c)**2/(n2-2)]

        c = NUM/DENOM

        NUM = s**2(y1.x1)/Q(x1)
        DENOM = (s*2(y1.x1)/Q(x1)) + (s*2(y2.x2)/Q(x2))

    Note that n1 should be set to the smaller sample size.

    To determine whether the residual variances are equal,
    the test statistic is

        s**2(y1.x1)/s**2(y2.x2)

    The hypothesis of equal residual variances is rejected if
    this statistic is greater than the F percent point function
    with n1 -2 and n2 - 2 degrees of freedom.

    Dataplot will perform the test for equal residual variances
    first and apply the appropriate test based on this.

    For the case where three or more regression lines are
    being compared, a series of three tests are performed.

        1) The first test is whether the k regressions are equal.
           The test statistic is

               F = (1/(2*k - 1))*[Q(y.x;T) - SUM[i=1 to k][Q(y.x;i)]/
                   [(1/(n-2*k))*SUM[i=1 to k][Q(y.x;i]

           The hypothesis of equal regressions is rejected if this
           test statistic is greater than the F percent point function
           with 2*k - 2 and n - 2*k degrees of freedom.

           where

               Q(y.x) = SUM[(y(i) - yhat)**2]

           That is, Q(y.x;T) is the sum of the squared differences
           between the data and the fitted function for the full data
           set while the Q(y.x;i) terms are the sum of the squared
           differences between the data and the fitted function for the
           k individual fits.

        2) If the hypothesis of equal regressions is not rejected,
           nothing further is done.  If the hypothesis is rejected,
           a test for equal slopes is performed.  The test statistic is

               F = (1/(k - 1))*[A - SUM[i=1 to k][Q(y.x;i)]/
                   [(1/(n-2*k))*SUM[i=1 to k][Q(y.x;i]

           where

               A = SUM[i=1 to k][Q(y;i] -
                   SUM[i=1 to k][Q(xy;i]/SUM[i=1 to k][Q(x;i]

               Q(xy) = SUM[(x - xbar)*(y - ybar)]

           The hypothesis of equal slopes is rejected if this
           test statistic is greater than the F percent point function
           with k - 1 and n - 2*k degrees of freedom.

        3) If the hypothesis of equal slopes is not rejected, nothing
           further is done.  If the hypothesis is rejected, a test for
           equal intercepts is performed.  The test statistic is

               F = (1/(k - 1))*[Q(y.x;T) - A]/
                   [(1/(n-2*k))*SUM[i=1 to k][Q(y.x;i]

           The hypothesis of equal intercepts is rejected if this test
           statistic is greater than the F percent point function with
           k - 1 and n - 2*k degrees of freedom.

Syntax:
    EQUAL SLOPES TEST <y> <x> <tag>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response (= dependent) variable;
          <x> is a factor (= independent) variable;
          <tag> is a group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    EQUAL SLOPE TEST Y X TAG
    EQUAL SLOPE TEST Y X TAG  SUBSET TAG 1 2 4 6
 
Note:
    The following statistics are also supported

        LET A = EQUAL SLOPES TEST                   Y X TAG
        LET A = EQUAL SLOPES TEST CDF               Y X TAG
        LET A = EQUAL SLOPES TEST PVALUE            Y X TAG
        LET A = EQUAL SLOPES TEST CRITICAL VALUE  Y X TAG

    The critical value is the 95% critical value.  For the more than two
    groups case, the values returned are the second of the three tests
    (i.e., the test for equal slopes).

    In addition to the above LET command, built-in statistics are
    supported for 20+ different commands (enter HELP STATISTICS
    for details).

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LINEAR CORRELATION PLOT = Generates a linear correlation plot.
    LINEAR INTERCEPT PLOT   = Generates a linear intercept plot.
    LINEAR RESSD PLOT       = Generates a linear residual standard
                              deviation plot.
    FIT                     = Carries out a least squares fit.
 
Reference:
    Lothar Sachs (1982), "Applied Statistics: A Handbook
    of Techniques", Springer-Verlag, pp. 413-442.

Applications:
    Exploratory Data Analysis
 
Implementation Date:
    2015/10
 
Program:
    . Step 1:   Read the data
    .
    dimension 40 columns
    read y x indx
    0.04101      297.16000        0.00000
    0.04104      297.17000        0.00000
    0.04105      297.18000        0.00000
    0.04103      297.20000        0.00000
    0.04109      297.20000        0.00000
    0.03707      280.12000        0.00000
    0.03929      290.12000        0.00000
    0.04171      300.18000        0.00000
    0.04428      310.18000        0.00000
    0.04700      320.17000        0.00000
    0.04052      297.15000        1.00000
    0.04055      297.15000        1.00000
    0.04056      297.15000        1.00000
    0.04056      297.15000        1.00000
    0.04056      297.15000        1.00000
    0.03656      280.15000        1.00000
    0.03883      290.15000        1.00000
    0.04125      300.15000        1.00000
    0.04381      310.15000        1.00000
    0.04654      320.15000        1.00000
    end of data
    let n = size y
    .
    . Step 2:   Generate the individual fits
    .
    set write decimals 6
    write "Fit for Lab One"
    write " "
    write " "
    fit y x  subset indx = 0
    let pred1 = pred
    write " "
    write " "
    write "Fit for NIST"
    write " "
    write " "
    fit y x  subset indx = 1
    let pred2 = pred
    .
    . Step 3:   Plot the fit
    .
    let x1 = x
    let x2 = x
    retain pred1 x1 subset indx = 0
    retain pred2 x2 subset indx = 1
    .
    case asis
    label case asis
    title case asis
    title offset 2
    line blank blank solid solid
    line color black black blue red
    character circle box
    character fill on on
    character color blue red
    char hw 1.0 0.75 all
    y1label Y
    x1label X
    x2label Red: Lab 1, Blue: Lab 2
    title Summary of Fits
    .
    ylimits 0.035 0.050
    xlimits 280 320
    xtic mark offset 5 5
    .
    plot y x subset indx = 1 and
    plot y x subset indx = 0 and
    plot pred2 x2 and
    plot pred1 x1
    .
    . Step 4:   Perform the equal slopes test
    .
    let statva = equal slopes test y x indx
    let statcd = equal slopes test cdf y x indx
    let pval   = equal slopes test pvalue y x indx
    let statcv = equal slopes test critical value y x indx
    .
    print statva statcd statcv pval
    .
    equal slopes test y x indx
 
-----ERASE-------------------------------------------------------
 
ERASE
 
Name:
    ERASE
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Erases the current screen for display terminals and goes to a new
    page for output devices written to a file.
 
Syntax:
    ERASE
 
Examples:
    ERASE
 
Note:
    If you use the ERASE command to simply clear the screen, be aware
    that a blank page will be generated for the output devices written
    to a file (DEVICE 2, DEVICE 3) as well.  For many terminals, the
    DEFINE command can be used to for this purpose.  For example, on a
    Tektronix 4014 you can enter DEFINE ER ESC FF and then enter ER
    when you wish to clear the screen without generating blank pages
    in the other output devices.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ERASE DELAY = Sets the delay after screen erasure.
    RING        = Rings the bell (immediately).
    COPY        = Copies the screen (immediately).
    BELL        = Sets the automatic bell switch for plots.
    PRE-ERASE   = Sets the automatic pre-erase switch for plots.
    HARDCOPY    = Sets the automatic copy switch for plots.
    SEQUENCE    = Sets the automatic sequence switch for plots.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XX
 
-----ERASE DELAY-------------------------------------------------------
 
ERASE DELAY
 
Name:
    ERASE DELAY
 
Type:
    Support Command
 
Purpose:
    Specifies the number of null lines to be transmitted immediately
    after subsequent screen erasures.
 
Description:
    This command is necessary only when the terminal being used has an
    inadequate buffer area.  The net effect of this is that the
    beginning portion of a plot may be destroyed in the erase because
    the erase takes a finite amount of time (typically about 1 second),
    and the terminal is receiving and plotting data even while the
    erase is taking place.
 
Syntax:
    ERASE DELAY   <n>
    where <n> is a number or parameter that specifies the desired
              number of null lines to be sent.
 
Examples:
    ERASE DELAY 5
    ERASE DELAY 10
    ERASE DELAY
 
Note:
    The ERASE DELAY command with no arguments is equivalent to
    ERASE DELAY 1   .
 
Note:
    This command currently only applies to Tektronix terminals.
 
Default:
    The default is 1 null line being sent.
 
Synonyms:
    None
 
Related Commands:
    ERASE      = Erases the screen (immediately).
    PRE-ERASE  = Sets the automatic pre-erase switch for plots.
    COPY DELAY = Sets the delay for screen hardcopying.
    COPY       = Copies the screen (immediately).
    HARDCOPY   = Sets the automatic copy switch for plots.
    BAUD       = Sets the baud rate.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XX
 
-----ERF (LET)--------------------------------
 
ERF
 
Name:
    ERF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the error function.
 
Description:
    The error function of x is defined as:
        2.0/SQRT(PI) X INTEGRAL(0 to X) of e**(-t**2)dt
    This function is defined for non-zero numbers.  The returned value
    will be between 0 and 1.  The complementary error function is
    defined as 1.0 minus the error function.
 
Syntax:
    LET <y2> = ERF(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter containing positive values;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed error function values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ERF(1.5)
    LET A = ERF(A1)
    LET X2 = ERF(X1)
    LET X2 = ERF(X1-4)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ERFC   = Compute the complementary error function.
    GAMMA  = Compute the Gamma function of a number.
 
Applications:
    XX
 
Implementation Date:
    XX.X
 
Program:
    TITLE AUTOMATIC
    XLIMITS 0 5
    MAJOR XTIC NUMBER 6
    YLIMITS 0 1
    MAJOR YTIC NUMBER 6
    PLOT ERF(X) FOR X = 0 0.01 5
 
-----ERFC (LET)--------------------------------
 
ERFC
 
Name:
    ERFC (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the complementary error function.
 
Description:
    The complementary error function of x is defined as:
        1.0 - 2.0/SQRT(PI) X INTEGRAL(0 to X) of e**(-t**2)dt
    This function is defined for non-negative numbers.  The returned
    value will be between 0 and 1.
 
Syntax:
    LET <y2> = ERFC(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter containing positive values;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed complementary error function values
               are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ERFC(1.5)
    LET A = ERFC(A1)
    LET X2 = ERFC(X1)
    LET X2 = ERFC(X1-4)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ERF    = Compute the error function of a number.
    GAMMA  = Compute the Gamma function of a number.
 
Applications:
    XX
 
Implementation Date:
    XX.X
 
Program:
    TITLE AUTOMATIC
    XLIMITS 0 5
    MAJOR XTIC MARK NUMBER 6
    YLIMITS 0 1
    MAJOR YTIC MARK NUMBER 6
    PLOT ERFC(X) FOR X = 0 0.01 5
 
-----ERRCDF (LET)--------------------------------
 
ERRCDF
 
Name:
    ERRCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard error cumulative distribution function.
    This is also referred to as the exponential power distribution,
    the Subbotin distribution, or the general error distribution.
 
    Dataplot supports another distribution that is also called the
    exponential power distribution.  This is a different distribution
    than the one described here (enter HELP PEXPDF for details).

Description:
    Note that there are several different parameterizations of
    the error distribution in the literature.  We will use the
    parameterization of Radikamalla (see the Reference section
    below).

    The standard error distribution has the following probability
    density function:

       f(x,alpha) = EXP(-|x|**alpha)/[2*GAMMA(1+1/alpha)]
                         -infinity < x < infinity,  alpha >= 1

    with GAMMA denoting the gamma function (HELP GAMMA for details)
    and alpha the shape parameter.

    For x > 0, Dataplot computes the error cdf function with the
    following formula:

        F(x,alpha) = 0.5 - [-(x*GAMMAI(1/alpha,x**alpha)]/
                     [2*alpha*(x**alpha)**(1/alpha)*GAMMA(1+1/alpha)]

    with GAMMA denoting the gamma function (HELP GAMMA for details),
    GAMMAI denoting the incomplete gamma function (HELP GAMMAI for
    details), and alpha the shape parameter.  Negative values of
    x are computed by using the above formula for positive x and
    taking advantage of the symmetry of the error distribution.

Syntax:
    LET <y> = ERRCDF(<x>,<alpha>)   <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <alpha> is a number or parameter specifying the first
               shape parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed error cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ERRCDF(3,2)
    LET X2 = ERRCDF(X1,A)
    PLOT ERRCDF(X,1.5)  FOR X = -3  0.01 3
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ERRPDF            = Compute the error probability density
                        function.
    ERRPPF            = Compute the error percent point function.
    NORPDF            = Compute the normal probability density
                        function.
    DEXPDF            = Compute the double exponential probability
                        density function.
    RANDOM NUMBERS    = Generate random numbers from 60+ univariate
                        distributions.
    PROBABILITY PLOT  = Generate a probability plot.
    PPCC PLOT         = Generate a ppcc plot.

Reference:
    "Random Sampling From the Exponential Power Distribution",
    Pandu R. Radikamalla, Journal of the American Statistical
    Association, September, 1980, pp. 683-686.

    "Statistical Distributions", Third Edition, Evans, Hastings, and
    Peacock, Wiley, 2000.
 
    "Continuous Univariate Distributions--Volume 2, Second Edition",
    Johnson, Kotz, and Balakrishnan, Wiley, 1994.

Applications:
    Distributional Modeling
 
Implementation Date:
    2003/5
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    MULTIPLOT SCALE FACTOR 2
    TITLE AUTOMATIC
    PLOT ERRCDF(X,1) FOR X = -5  0.01  5
    PLOT ERRCDF(X,1.5) FOR X = -5  0.01  5
    PLOT ERRCDF(X,2) FOR X = -5  0.01  5
    PLOT ERRCDF(X,4) FOR X = -5  0.01  5
    END OF MULTIPLOT

-----ERROR BAR PLOT--------------------------------------
 
ERROR BAR PLOT
 
Name:
    ERROR BAR PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates an error bar plot.
 
Description:
    An error bar plot is a graphical data analysis technique for
    showing the error in the dependent variable and, optionally, the
    independent variable in a standard x-y plot.  It consists of:
       Vertical   axis = dependent variable;
       Horizontal axis = independent variable.
    The error bars can be either symmetric or asymmetric about the
    point.
 
Syntax 1:
    ERROR BAR PLOT  <y1> <ypos> <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the dependent variable;
          <ypos> is the error for <y1> in both the positive (up) and
               the negative (down) direction;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    ERROR BAR PLOT  <y1> <ypos> <x1> <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the dependent variable;
          <ypos> is the error for <y1> in both the positive (up) and
               the negative (down) direction;
          <x1> is the independent variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 3:
    ERROR BAR PLOT  <y1> <ypos> <yneg> <x1>
             <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the dependent variable;
          <ypos> is the error for <y1> in both the positive (up) and
               the negative (down) direction;
          <yneg> is the error for <y1> in the negative (down)
               direction;
          <x1> is the independent variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 4:
    ERROR BAR PLOT  <y1> <ypos> <yneg> <x1> <xpos>
             <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the dependent variable;
          <ypos> is the error for <y1> in both the positive (up) and
               the negative (down) direction;
          <yneg> is the error for <y1> in the negative (down)
               direction;
          <x1> is the independent variable;
          <xpos> is the error for <x1> in both the positive (left) and
               the negative (right) direction;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax: 5
    ERROR BAR PLOT  <y1> <ypos> <yneg> <x1> <xpos> <xneg>
             <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the dependent variable;
          <ypos> is the error for <y1> in both the positive (up) and
               the negative (down) direction;
          <yneg> is the error for <y1> in the negative (down)
               direction;
          <x1> is the independent variable;
          <xpos> is the error for <x1> in both the positive (left) and
               the negative (right) direction;
          <xneg> is the error for <x1> in the negative (right)
               direction;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    ERROR BAR PLOT Y1 YDELTA
    ERROR BAR PLOT Y1 YDELTA X1
    ERROR BAR PLOT Y1 YDELPOS YDELNEG X1
    ERROR BAR PLOT Y1 YDELPOS YDELNEG X1 XDELTA
    ERROR BAR PLOT Y1 YDELPOS YDELNEG X1 XDELPOS XDELNEG
    ERROR BAR PLOT Y1 YDELTA X1 SUBSET X1 < 10
 
Note:
    The appearance of the error bars is controlled by the following
    character and line traces.
       Trace 1 = the point (x,y)
       Trace 2 = the point (x,y+error)
       Trace 3 = the point (x,y-error)
       Trace 4 = the point (x-error,y)
       Trace 5 = the point (x+error,y)
       Trace 6 = the line between (x,y+error) and (x,y-error)
       Trace 7 = the line between (x-error,y) and (x+error,y)
 
    The line setting for trace 1 is used if you want the plot points
    to be connected.  The line settings for traces 2 through 5 are
    almost always set to BLANK.  Most analysts prefer to use solid
    lines for traces 6 (connects the vertical errors) and and trace 7
    (connects the horizontal errors).  However, you can use a different
    line style or leave them blank if you prefer.  The character
    setting for trace 1 is the original data point.  Use character
    traces 2 through 5 if you want the 4 end points to have unique
    settings.  Use character traces 6 and 7 to use the same symbol for
    matching end points.  The program below demonstrates how to set the
    line and character traces.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LINES          = Sets type for plot lines.
    CHARACTER      = Sets symbol for plot characters.
    PLOT           = Generates a data/function plot.
 
Applications:
    Exploratory Data Analysis, Presentation Graphics
 
Implementation Date:
    XX.X
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    LET FUNCTION F = X1**2
    LET X1 = SEQUENCE -5 1 5
    LET Y1 = F
    LET N = SIZE Y1
    LET DELTA = NORMAL RANDOM NUMBERS FOR I = 1 1 N
    LET DELTA = 2*DELTA
    .
    TITLE AUTOMATIC
    XLIMITS -5 5
    XTIC OFFSET 1 1
    YLIMITS 0 30
    YTIC OFFSET 1 1
    CHARACTER FONT SIMPLEX ALL
    CHARACTER CIRCLE HBAR HBAR
    CHARACTER SIZE 1.0 ALL
    CHARACTER SIZE 0.5
    CHARACTER FILL ON
    .
    PLOT Y1 VS X1
    .
    ERROR BAR PLOT Y1 DELTA X1
    .
    LET YPOS = ABS(DELTA)
    LET YNEG = UNIFORM RANDOM NUMBERS FOR I = 1 1 N
    LET YNEG = 3*YNEG
    LET XPOS = PATTERN .2 .4 .6 FOR I = 1 1 N
    LET XNEG = PATTERN .4 .8 1.2 FOR I = 1 1 N
    .
    CHARACTER CIRCLE HBAR HBAR ( ) BLANK BLANK
    LINE BLANK BLANK BLANK BLANK BLANK BLANK BLANK
    ERROR BAR PLOT Y1 YPOS YNEG X1 XNEG XPOS
    .
    CHARACTER CIRCLE BLANK BLANK BLANK BLANK HBAR VBAR
    LINE BLANK BLANK BLANK BLANK BLANK SOLID SOLID
    ERROR BAR PLOT Y1 YPOS YNEG X1 XNEG XPOS
    END OF MULTIPLOT
 
-----ERRPDF (LET)--------------------------------
 
ERRPDF
 
Name:
    ERRPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard error probability density function.
    This is also referred to as the exponential power distribution,
    the Subbotin distribution, or the general error distribution.
 
    Dataplot supports another distribution that is also called the
    exponential power distribution.  This is a different distribution
    than the one described here (enter HELP PEXPDF for details).

Description:
    Note that there are several different parameterizations of
    the error distribution in the literature.  We will use the
    parameterization of Radikamalla (see the Reference section
    below).

    The standard error distribution has the following probability
    density function:

       f(x,alpha) = EXP(-|x|**alpha)/[2*GAMMA(1+1/alpha)]
                         -infinity < x < infinity,  alpha >= 1

    with GAMMA denoting the gamma function (HELP GAMMA for details)
    and alpha the shape parameter.

    For alpha = 1 and alpha = 2, the error distribution is
    equivalent to the double exponential distribution and the
    normal distribution, respectively.  As alpha goes to infinity,
    the error distribution approximates a uniform distribution.
    For applications, values of alpha between 1 and 6 are of
    most interest.  The error distribution is sometimes used
    in simulation studies because it provides a symmetric
    distribution with widely varying kurtosis.

Syntax:
    LET <y> = ERRPDF(<x>,<alpha>)   <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <alpha> is a number or parameter specifying the first
               shape parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed error pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ERRPDF(3,2)
    LET X2 = ERRPDF(X1,A)
    PLOT ERRPDF(X,1.5)  FOR X = -3  0.01 3
 
Note:
    You can generate random numbers from an error
    distribution with the following command:

        LET ALPHA = <value>
        LET Y = ERROR RANDOM NUMBERS FOR I = 1 1 N

    You can also generate probability plots, ppcc plots,
    Kolmogorov-Smirnov and chi-square goodness of fit tests.
    For example,

        LET ALPHA = 2.5
        LET Y = ERROR RANDOM NUMBERS FOR I = 1 1 200

        ERROR PPCC PLOT Y

        LET ALPHA = <value>
        ERROR PROBABILITY PLOT Y

        LET ALPHA = <value>
        ERROR KOLMOGOROV-SMIRNOV GOODNESS OF FIT TEST Y
        ERROR CHI-SQUARE GOODNESS OF FIT TEST Y

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ERRCDF            = Compute the error cumulative distribution
                        function.
    ERRPPF            = Compute the error percent point function.
    NORPDF            = Compute the normal probability density
                        function.
    DEXPDF            = Compute the double exponential probability
                        density function.
    RANDOM NUMBERS    = Generate random numbers from 60+ univariate
                        distributions.
    PROBABILITY PLOT  = Generate a probability plot.
    PPCC PLOT         = Generate a ppcc plot.

Reference:
    "Random Sampling From the Exponential Power Distribution",
    Pandu R. Radikamalla, Journal of the American Statistical
    Association, September, 1980, pp. 683-686.

    "Statistical Distributions", Third Edition, Evans, Hastings, and
    Peacock, Wiley, 2000.
 
    "Continuous Univariate Distributions--Volume 2, Second Edition",
    Johnson, Kotz, and Balakrishnan, Wiley, 1994.

Applications:
    Distributional Modeling
 
Implementation Date:
    2003/5
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    MULTIPLOT SCALE FACTOR 2
    TITLE AUTOMATIC
    PLOT ERRPDF(X,1) FOR X = -5  0.01  5
    PLOT ERRPDF(X,1.5) FOR X = -5  0.01  5
    PLOT ERRPDF(X,2) FOR X = -5  0.01  5
    PLOT ERRPDF(X,4) FOR X = -5  0.01  5
    END OF MULTIPLOT

-----ERRPPF (LET)--------------------------------
 
ERRPPF
 
Name:
    ERRPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard error probability density function.
    This is also referred to as the exponential power distribution,
    the Subbotin distribution, or the general error distribution.
 
    Dataplot supports another distribution that is also called the
    exponential power distribution.  This is a different distribution
    than the one described here (enter HELP PEXPDF for details).

Description:
    Note that there are several different parameterizations of
    the error distribution in the literature.  We will use the
    parameterization of Radikamalla (see the Reference section
    below).

    The standard error distribution has the following probability
    density function:

       f(x,alpha) = EXP(-|x|**alpha)/[2*GAMMA(1+1/alpha)]
                         -infinity < x < infinity,  alpha >= 1

    with GAMMA denoting the gamma function (HELP GAMMA for details)
    and alpha the shape parameter.

    The error percent point function is computed numerically
    using a bisection method.  For alpha = 1 and alpha = 2,
    the percent point functions for the double exponential
    and normal distributions, respectively, are used.

Syntax:
    LET <y> = ERRPPF(<p>,<alpha>)   <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, a number, or a parameter with values
               between 0 and 1;
          <alpha> is a number or parameter specifying the shape
               parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed error ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ERRPPF(0.95,2)
    LET X2 = ERRPPF(P1,A)
    PLOT ERRPPF(P,1.5)  FOR X = 0.01  0.01  0.99

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ERRCDF            = Compute the error cumulative distribution
                        function.
    ERRPDF            = Compute the error probability density
                        function.
    NORPDF            = Compute the normal probability density
                        function.
    DEXPDF            = Compute the double exponential probability
                        density function.
    RANDOM NUMBERS    = Generate random numbers from 60+ univariate
                        distributions.
    PROBABILITY PLOT  = Generate a probability plot.
    PPCC PLOT         = Generate a ppcc plot.

Reference:
    "Random Sampling From the Exponential Power Distribution",
    Pandu R. Radikamalla, Journal of the American Statistical
    Association, September, 1980, pp. 683-686.

    "Statistical Distributions", Third Edition, Evans, Hastings, and
    Peacock, Wiley, 2000.
 
    "Continuous Univariate Distributions--Volume 2, Second Edition",
    Johnson, Kotz, and Balakrishnan, Wiley, 1994.

Applications:
    Distributional Modeling
 
Implementation Date:
    2003/5
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    MULTIPLOT SCALE FACTOR 2
    TITLE AUTOMATIC
    PLOT ERRPPF(P,1) FOR P = 0.01  0.01  0.99
    PLOT ERRPPF(P,1.5) FOR P = 0.01  0.01  0.99
    PLOT ERRPPF(P,2) FOR P = 0.01  0.01  0.99
    PLOT ERRPPF(P,4) FOR P = 0.01  0.01  0.99
    END OF MULTIPLOT

-----ETA (LET)--------------------------------
 
ETA
 
Name:
    ETA (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the eta function.
 
Description:
    The eta function is defined as:

        ETA(s) = SUM((-1)**(k-1)/(k**s),      s >= 1

    where the summation is for k = 1 to infinity.

    For better numerical stability, Dataplot actually
    computes ETA(s) - 1.

    Dataplot uses a Fortran translation of a C routine
    given in "Atlas For Computing Mathematical Functions"
    (see the Reference section below).
 
Syntax:
    LET <y> = ETA(<x>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, variable, or parameter (> 1);
          <y> is a variable or a parameter (depending on what <x> 
               is) where the computed eta - 1 values are
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ETA(2)
    LET A = ETA(X) 
    LET X2 = ETA(X) FOR X = 0.1 0.1 3.0
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ZETA       = Compute the Riemann Zeta function.
    CATLAN     = Compute the Catlan beta function.
    LAMBDA     = Compute the lambda function.
 
Reference:
    "Atlas For Computing Mathematical Functions",
    William J. Thompson, John wiley & Sons, 1997, pp. 144-151.
 
Applications:
    Special Functions
 
Implementation Date:
    1997/12
 
Program:
    TITLE AUTOMATIC
    PLOT ETA(X) FOR X = 1.01 0.01 5
 
-----EUCLIDEAN DISTANCE (LET)-------------------------------------
 
EUCLIDEAN DISTANCE
 
Name:
    EUCLIDEAN DISTANCE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the Euclidean distance between two variables.
 
Description:
    The Euclidean distance between two variabes X and Y is
    defined as
 
        d = SQRT{SUM[i=1 to n][(X(i) - Y(i))*2]}

    The Euclidean distance is the straight line distance between
    two points in Euclidean space.

Syntax:
    LET <par> = EUCLIDEAN DISTANCE <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Euclidean distance
              is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Examples:
    LET A = EUCLIDEAN DISTANCE Y1 Y2
    LET A = EUCLIDEAN DISTANCE Y1 Y2  SUBSET Y1 > 0 SUBSET Y2 > 0

Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

    This command performs the same function as the VECTOR DISTANCE
    command.  The distinction is that EUCLIDEAN DISTANCE is implemented
    as a Statistics LET subcommand while VECTOR DISTANCE is implemented
    as a Mathematics LET subcommand.  The Statistics LET subcommands work
    with the commands documented in HELP STATISTICS while the Mathematics
    LET subcommands do not.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COSINE DISTANCE         = Compute the cosine distance.
    MANHATTAN DISTANCE      = Compute the Manhattan distance.
    MATRIX DISTANCE         = Compute various distance metrics for
                              a matrix.

Applications:
    Mathematics
 
Implementation Date:
    2017/03
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET DIST  = EUCLIDEAN DISTANCE Y1 Y2
    SET WRITE DECIMALS 4
    TABULATE EUCLIDEAN DISTANCE Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    LET NDIST = UNIQUE X
    XLIMITS 1 NDIST
    MAJOR X1TIC MARK NUMBER NDIST
    MINOR X1TIC MARK NUMBER 0
    CHAR X
    LINE BLANK
    LABEL CASE ASIS
    CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    SET STATISTIC PLOT REFERENCE LINE AVERAGE
    TITLE Euclidean Distance (IRIS.DAT)
    Y1LABEL Euclidean Distance
    EUCLIDEAN DISTANCE PLOT Y1 Y2 X

-----EUCLIDEAN LENGTH (LET)-------------------------------------
 
EUCLIDEAN LENGTH
 
Name:
    EUCLIDEAN LENGTH (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the Euclidean length of a variable.
 
Description:
    The Euclidean length of a variabe Y is defined as
 
        ||Y|| = SQRT{SUM[i=1 to n][Y(i)*2]}

Syntax:
    LET <par> = EUCLIDEAN LENGTH <y>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the computed Euclidean length
              is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Examples:
    LET A = EUCLIDEAN LENGTH Y
    LET A = EUCLIDEAN LENGTH Y SUBSET Y > 0

Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

    This command performs the same function as the VECTOR LENGTH
    command.  The distinction is that EUCLIDEAN LENGTH is implemented as
    a Statistics LET subcommand while VECTOR LENGTH is implemented as
    a Mathematics LET subcommand.  The Statistics LET subcommands work
    with the 25+ commands documented in HELP STATISTICS while the
    Mathematics LET subcommands do not.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EUCLIDEAN DISTANCE      = Compute the Euclidean distance.
    COSINE DISTANCE         = Compute the cosine distance.
    MANHATTAN DISTANCE      = Compute the Manhattan distance.

Applications:
    Mathematics
 
Implementation Date:
    2017/03
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET LENGTH  = EUCLIDEAN LENGTH Y1
    SET WRITE DECIMALS 4
    TABULATE EUCLIDEAN LENGTH Y1 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    LET NDIST = UNIQUE X
    XLIMITS 1 NDIST
    MAJOR X1TIC MARK NUMBER NDIST
    MINOR X1TIC MARK NUMBER 0
    CHAR X
    LINE BLANK
    LABEL CASE ASIS
    CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    SET STATISTIC PLOT REFERENCE LINE AVERAGE
    TITLE Euclidean Length (IRIS.DAT)
    Y1LABEL Euclidean Length
    EUCLIDEAN LENGTH PLOT Y1 X

-----EULER NUMBERS (LET)----------------------------------
 
EULER NUMBERS
 
Name:
    EULER NUMBERS (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Generate a sequence of Euler numbers.
 
Description:
    For a description of Euler numbers and polynomials,
    enter the command:

        HELP EN

    EN is a library function for computing Euler numbers
    and polynomials.  The EULER NUMBERS command can be
    used to generate a sequence of Euler numbers.

Syntax:
    LET <y> = EULER NUMBERS FOR I = <start> <inc>  <stop> 
    where <start> is the starting row for the Euler numbers;
          <inc> is the increment for the Euler numbers;
          <stop> is the stopping row for the Euler numbers;
          <y> is a variable where the Euler numbers are saved.
 
    Typically <start> and <inc> are 1 and <stop> is set to the
    number of Euler numbers to generate.  If <start> and <inc>
    are not 1, then <y> will still contain <stop> elements, but
    the empty rows will be set to 0.

Examples:
    LET Y = EULER NUMBERS FOR I = 1 1 30

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BINCDF       = Compute the binomial cumulative distribution
                   function.
    BINPDF       = Compute the binomial probability mass function.
    BINPPF       = Compute the binomial percent point function.
    BINOMIAL     = Compute the binomial coefficients.
    EN           = Compute Euler number or polynomial.
 
Reference:
    "Computation of Special Functions", Shanjie Zhang and Jianming
    Jin, John Wiley and Sons, 1996, chapter 1.
 
Applications:
    Probability
 
Implementation Date:
    1997/12
 
Program:
    LET Y = EULER NUMBERS FOR I = 1 1 30
    PRINT Y
 
-----EV1CDF (LET)--------------------------------
 
EV1CDF
 
Name:
    EV1CDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the extreme value type I (also known
    as the Gumbel distribution) cumulative distribution function.
 
Description:
    For the minimum order statistic, the standard form of the
    cumulative distribution function is:
       cdf(x) = 1.0 - exp(-exp(x))
    For the maximum order statistic, the standard form of the
    cumulative distribution function is:
       cdf(x) = exp(-exp(-x))
    The input value can be any real number.
 
Syntax:
    LET <y2> = EV1CDF(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, a number, or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed extreme value type I cdf value is
               saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = EV1CDF(3)
    LET X2 = EV1CDF(X1)
 
Note:
    The SET MINMAX command specifies whether the minimum or maximum
    order statistic form is used.  Entering SET MINMAX 2 specifies the
    maximum order statistic while SET MINMAX 1 specifies the
    minimum order statistic.  This command is required before using the
    EV1CDF function.
 
Note:
    For the minimum order statistic, the general form of the cumulative
    distribution is:
       cdf(x) = 1.0 - exp(-exp((x-u)/beta))
    For the maximum order statistic, the general form of the cumulative
    distribution is:
       cdf(x) = exp(-exp(-(x-u)/beta))
    The parameter u is a location parameter and the parameter beta is a
    scale parameter that must be greater than 0.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EV1PDF = Compute the extreme value type I probability density
             function.
    EV1PPF = Compute the extreme value type I percent point function.
    EV2CDF = Compute the extreme value type II cumulative distribution
             function.
    EV2PDF = Compute the extreme value type II probability density
             function.
    EV2PPF = Compute the extreme value type II percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    EXPCDF = Compute the exponential cumulative distribution function.
    EXPPDF = Compute the exponential probability density function.
    EXPPPF = Compute the exponential percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, Houghton
    Mifflin, 1970 (chapter 21).
 
Applications:
    XX
 
Implementation Date:
    94/4
 
Program:
    SET MINMAX 2
    YLIMITS 0 1
    MAJOR YTIC NUMBER 6
    MINOR YTIC NUMBER 1
    YTIC DECIMAL 1
    XLIMITS -3 5
    XTIC OFFSET 0.6 0.6
    TITLE AUTOMATIC
    PLOT EV1CDF(X) FOR X = -3.5 0.01 5.5
 
-----EV1CHAZ (LET)--------------------------------
 
EV1CHAZ
 
Name:
    EV1CHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the extreme value type I (also known
    as the Gumbel distribution) cumulative hazard function.
 
Description:
    For the minimum order statistic, the standard form of the extreme
    value type I distribution has the following cumulative hazard
    function:
       H(x) = exp(x)
    For the maximum order statistic, the standard form of the extreme
    value type I distribution has the following cumulative hazard
    function:
       H(x) = -DLOG[1 - exp(exp(-x))]
 
Syntax:
    LET <y> = EV1CHAZ(<x>)      <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed extreme value type I cumulative
               hazard value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = EV1CHAZ(3)
    LET X2 = EV1CHAZ(X1)
 
Note:
    The SET MINMAX command specifies whether the minimum or maximum
    order statistic form is used.  Entering SET MINMAX 2 specifies the
    maximum order statistic while SET MINMAX 1 specifies the
    minimum order statistic.  This command is required before using the
    EV1CHAZ function.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EV1CDF  = Compute the extreme value type I cumulative distribution
              function.
    EV1PDF  = Compute the extreme value type I probability density
              function.
    EV1PPF  = Compute the extreme value type I percent point function.
    EV1HAZ  = Compute the extreme value type I hazard function.
    EV2PDF  = Compute the extreme value type II probability density
              function.
    WEIPDF  = Compute the Weibull probability density function.
    EXPPDF  = Compute the exponential probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 2", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994.
 
Applications:
    Reliability, Extreme Values Analysis
 
Implementation Date:
    1999/6
 
Program:
    SET MINMAX 2
    TITLE AUTOMATIC
    PLOT EV1CHAZ(X) FOR X = -4  0.01  4
 
-----EV1HAZ (LET)--------------------------------
 
EV1HAZ
 
Name:
    EV1HAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the extreme value type I (also known
    as the Gumbel distribution) hazard function.
 
Description:
    For the minimum order statistic, the standard form of the extreme
    value type I distribution has the following hazard function:
       h(x) = exp(x)
    For the maximum order statistic, the standard form of the extreme
    value type I distribution has the following hazard
    function:
       h(x) = [exp(-x)]/[exp(exp(-x)) - 1]
 
Syntax:
    LET <y> = EV1HAZ(<x>)      <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed extreme value type I hazard value is
               saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = EV1HAZ(3)
    LET X2 = EV1HAZ(X1)
 
Note:
    The SET MINMAX command specifies whether the minimum or maximum
    order statistic form is used.  Entering SET MINMAX 2 specifies the
    maximum order statistic while SET MINMAX 1 specifies the
    minimum order statistic.  This command is required before using the
    EV1HAZ function.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EV1CDF  = Compute the extreme value type I cumulative distribution
              function.
    EV1PDF  = Compute the extreme value type I probability density
              function.
    EV1PPF  = Compute the extreme value type I percent point function.
    EV1CHAZ = Compute the extreme value type I cumulative hazard
              function.
    EV2PDF  = Compute the extreme value type II probability density
              function.
    WEIPDF  = Compute the Weibull probability density function.
    EXPPDF  = Compute the exponential probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 2", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994.
 
Applications:
    Reliability, Extreme Values Analysis
 
Implementation Date:
    1999/6
 
Program:
    SET MINMAX 2
    TITLE AUTOMATIC
    PLOT EV1HAZ(X) FOR X = -4  0.01  4
 
-----EV1PDF (LET)--------------------------------
 
EV1PDF
 
Name:
    EV1PDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the extreme value type I (also known
    as the Gumbel distribution) probability density function.
 
Description:
    For the minimum order statistic, the standard form of the extreme
    value type I distribution has the following probability density
    function:
       f(x) = exp(x)*exp(-exp(x))
    which simplifies to:
       f(x) = exp(x - exp(x))
    For the maximum order statistic, the standard form of the extreme
    value type I distribution has the following probability density
    function:
       f(x) = exp(-x)*exp(-exp(-x))
    which simplifies to:
       f(x) = exp(-x - exp(-x))
    This distribution has a mean of 0.5722... (Euler's number) and a
    standard deviation of PI/sqrt(6).  The input value can be any real
    number.
 
Syntax:
    LET <y2> = EV1PDF(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, a number, or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed extreme value type I pdf value is
               saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = EV1PDF(3)
    LET X2 = EV1PDF(X1)
 
Note:
    The SET MINMAX command specifies whether the minimum or maximum
    order statistic form is used.  Entering SET MINMAX 2 specifies the
    maximum order statistic while SET MINMAX 1 specifies the
    minimum order statistic.  This command is required before using the
    EV1CDF function.
 
Note:
    For the minimum order statistic, the general form of the extreme
    value type I distribution has the following probability density
    function:
       f(x) = (1/beta)*exp((x-u)/beta)*exp(-exp((x-u)/beta))
    For the maximum order statistic, the general form of the extreme
    value type I distribution has the following probability density
    function:
       f(x) = (1/beta)*exp(-(x-u)/beta)*exp(-exp(-(x-u)/beta))
    The parameter u is a location parameter and the parameter beta is a
    scale parameter that must be greater than 0.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EV1CDF = Compute the extreme value type I cumulative distribution
             function.
    EV1PPF = Compute the extreme value type I percent point function.
    EV2CDF = Compute the extreme value type II cumulative distribution
             function.
    EV2PDF = Compute the extreme value type II probability density
             function.
    EV2PPF = Compute the extreme value type II percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    EXPCDF = Compute the exponential cumulative distribution function.
    EXPPDF = Compute the exponential probability density function.
    EXPPPF = Compute the exponential percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, Houghton
    Mifflin, 1970 (chapter 21).
 
Applications:
    XX
 
Implementation Date:
    94/4
 
Program:
    SET MINMAX 2
    YLIMITS 0 0.5
    MAJOR YTIC NUMBER 6
    MINOR YTIC NUMBER 1
    YTIC DECIMAL 1
    XLIMITS -4 4
    XTIC OFFSET 0.6 0.6
    TITLE AUTOMATIC
    PLOT EV1PDF(X) FOR X = -4.5 0.01 4.5
 
-----EV1PPF (LET)--------------------------------
 
EV1PPF
 
Name:
    EV1PPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the extreme value type I (also known
    as the Gumbel) percent point function.
 
Description:
    For the minimum order statistic, the standard form of the extreme
    value type I distribution has the following probability density
    function:
       f(x) = exp(x - exp(x))
    For the maximum order statistic, the standard form of the extreme
    value type I distribution has the following probability density
    function:
       f(x) = exp(-x - exp(-x))
    The percent point function is the inverse of the cumulative
    distribution function.  The cumulative distribution sums the
    probability from 0 to the given x value (i.e., the integral of the
    above function).  The percent point function takes a cumulative
    probability value and computes the corresponding x value.
 
    The input value is a real number between 0 and 1 (since it
    corresponds to a probability).  The output value can be any real
    number.
 
Syntax:
    LET <y2> = EV1PPF(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, a number, or a parameter in the range 0
               to 1;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed extreme value type I ppf value is
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = EV1PPF(0.9)
    LET X2 = EV1PPF(X1)
 
Note:
    The SET MINMAX command specifies whether the minimum or maximum
    order statistic form is used.  Entering SET MINMAX 2 specifies the
    maximum order statistic while SET MINMAX 1 specifies the
    minimum order statistic.  This command is required before using the
    EV1CDF function.
 
Note:
    For the minimum order statistic, the general form of the extreme
    value type I distribution has the following probability density
    function:
       f(x) = (1/beta)*exp((x-u)/beta)*exp(-exp((x-u)/beta))
    For the maximum order statistic, the general form of the extreme
    value type I distribution has the following probability density
    function:
       f(x) = (1/beta)*exp(-(x-u)/beta)*exp(-exp(-(x-u)/beta))
    The parameter u is a location parameter and the parameter beta is a
    scale parameter that must be greater than 0.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EV1CDF = Compute the extreme value type I cumulative distribution
             function.
    EV1PPF = Compute the extreme value type I percent point function.
    EV2CDF = Compute the extreme value type II cumulative distribution
             function.
    EV2PDF = Compute the extreme value type II probability density
             function.
    EV2PPF = Compute the extreme value type II percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    EXPCDF = Compute the exponential cumulative distribution function.
    EXPPDF = Compute the exponential probability density function.
    EXPPPF = Compute the exponential percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, Houghton
    Mifflin, 1970 (chapter 21).
 
Applications:
    XX
 
Implementation Date:
    94/4
 
Program:
    SET MINMAX 2
    XLIMITS 0 1
    MAJOR XTIC NUMBER 6
    MINOR XTIC NUMBER 1
    XTIC DECIMAL 1
    TITLE AUTOMATIC
    PLOT EV1PPF(X) FOR X = 0.01 .01 0.99
 
-----EV2CDF (LET)--------------------------------
 
EV2CDF
 
Name:
    EV2CDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the extreme value type II (also known
    as the Frechet distribution) cumulative distribution function.
 
Description:
    For the minimum order statistic, the standard form of the
    cumulative distribution function is:
       F(x;gamma) = 1.0 - exp(-(-x)**(-gamma))      x <= 0
    For the maximum order statistic, the standard form of the
    cumulative distribution function is:
       F(x;gamma) = exp(-(x)**(-gamma))             x >= 0
    where gamma is a positive number that is the shape parameter.  The
    input value can be any non-negative real number.
 
Syntax:
    LET <y2> = EV2CDF(<y1>,<gamma>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, a number, or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed extreme value type II cdf value is
               saved;
          <gamma> is a number or parameter that specifies the shape
               parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = EV2CDF(3,1.5)
    LET X2 = EV2CDF(X1,GAMMA)
 
Note:
    The SET MINMAX command specifies whether the minimum or maximum
    order statistic form is used.  Entering SET MINMAX 2 specifies the
    maximum order statistic while SET MINMAX 1 specifies the
    minimum order statistic.  This command is required before using the
    EV1CDF function.
    The extreme value type II distribution can be based on either the
    maximum order statistic or the minimum order statistic.  This is
    specified by the SET MINMAX command.  Entering SET MINMAX 2
    specifies the maximum order statistic while SET MINMAX 1 specifies
    the minimum order statistic.  Currently, the EV2CDF function is
    only supported for the maximum order statistic.  However, the SET
    MINMAX command is still required before using the EV2CDF function.
 
Note:
    For the minimum order statistic, the general form of the cumulative
    distribution function is:
       F(x;u,beta,gamma) = 1.0 - exp(-((u-x)/beta)**(-gamma))   x <= u
    For the maximum order statistic, the standard form of the
    cumulative distribution function is:
       F(x;u,beta,gamma) = exp(-((x-u)/beta)**(-gamma))         x >= u
    The parameter u is a location parameter and the parameter beta is a
    shape parameter.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EV2PDF = Compute the extreme value type II probability density
             function.
    EV2PDF = Compute the extreme value type II probability density
             function.
    EV1PDF = Compute the extreme value type I probability density
             function.
    EV1PPF = Compute the extreme value type I percent point function.
    EV2PPF = Compute the extreme value type II percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    EXPCDF = Compute the exponential cumulative distribution function.
    EXPPDF = Compute the exponential probability density function.
    EXPPPF = Compute the exponential percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, Houghton
    Mifflin, 1970 (chapter 21).
 
Applications:
    Distributional Modeling
 
Implementation Date:
    94/4
 
Program:
    SET MINMAX 2
    MAJOR YTIC NUMBER 6; MINOR YTIC NUMBER 1
    YLIMITS 0 1; YTIC DECIMAL 1
    XLIMITS 0 5; XTIC OFFSET 0.6 0.6
    TITLE PLOT EV2CDF FOR VARIOUS VALUES OF GAMMA
    SEGMENT 1 COORDINATES 16 88 21 88; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 16 84 21 84; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 16 80 21 80; SEGMENT 3 PATTERN DOT
    SEGMENT 4 COORDINATES 16 76 21 76; SEGMENT 4 PATTERN DASH2
    LEGEND 1 GAMMA = 1; LEGEND 1 COORDINATES 22 87
    LEGEND 2 GAMMA = 0.5; LEGEND 2 COORDINATES 22 83
    LEGEND 3 GAMMA = 2; LEGEND 3 COORDINATES 22 79
    LEGEND 4 GAMMA = 5; LEGEND 4 COORDINATES 22 75
    LINES SOLID DASH DOT DASH2
    PLOT EV2CDF(X,1) FOR X = 0.01 0.01 5.5 AND
    PLOT EV2CDF(X,0.5) FOR X = 0.01 0.01 5.5 AND
    PLOT EV2CDF(X,2) FOR X = 0.01 0.01 5.5 AND
    PLOT EV2CDF(X,5) FOR X = 0.01 0.01 5.5
 
-----EV2CHAZ (LET)--------------------------------
 
EV2CHAZ
 
Name:
    EV2CHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the extreme value type II (also known
    as the Frechet distribution) cumulative hazard function.
 
Description:
    For the minimum order statistic, the standard form of the
    cumulative hazard function is:
       H(x) = (-x)**(-gamma)        x <= 0
    For the maximum order statistic, the standard form of the
    cumulative hazard function is:
       H(x) = -DLOG[1 - EV2CDF(x,gamma)]      x >= 0
    where gamma is a positive number that is the shape parameter
    and EV2CDF is the cumulative distribution of the EV2
    distribution.
 
Syntax:
    LET <y> = EV2CHAZ(<x>,<gamma>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed extreme value type II cumulative
               hazard value is saved;
          <gamma> is a number or parameter that specifies the shape
               parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = EV2CHAZ(3,1.5)
    LET X2 = EV2CHAZ(X1,GAMMA)
 
Note:
    The SET MINMAX command specifies whether the minimum or maximum
    order statistic form is used.  Entering SET MINMAX 2 specifies the
    maximum order statistic while SET MINMAX 1 specifies the
    minimum order statistic.  This command is required before using the
    EV1CDF function.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EV2CDF  = Compute the extreme value type II cumulative distribution
              function.
    EV2PDF  = Compute the extreme value type II probability density
              function.
    EV2CHAZ  = Compute the extreme value type II hazard function.
    EV2CHAZ  = Compute the extreme value type II hazard function.
    EV1PDF  = Compute the extreme value type I probability density
              function.
    WEIPDF  = Compute the Weibull probability density function.
    EXPPDF  = Compute the exponential probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994, (chapter 21).
 
Applications:
    Extreme Value Analysis
 
Implementation Date:
    1998/4
 
Program:
    SET MINMAX 2
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    TITLE CASE ASIS
    TITLE PLOT EV2 Cumulative Hazard Function (Gamma = 1)
    PLOT EV2CHAZ(X,1) FOR X = 0.01 0.01 5.5
    TITLE PLOT EV2 Cumulative Hazard Function (Gamma = 0.5)
    PLOT EV2CHAZ(X,0.5) FOR X = 0.01 0.01 5.5
    TITLE PLOT EV2 Cumulative Hazard Function (Gamma = 2)
    PLOT EV2CHAZ(X,2) FOR X = 0.01 0.01 5.5
    TITLE PLOT EV2 Cumulative Hazard Function (Gamma = 5)
    PLOT EV2CHAZ(X,5) FOR X = 0.01 0.01 5.5
    END OF PLOT
 
-----EV2HAZ (LET)--------------------------------
 
EV2HAZ
 
Name:
    EV2HAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the extreme value type II (also known
    as the Frechet distribution) hazard function.
 
Description:
    For the minimum order statistic, the standard form of the
    hazard function is:
       h(x) = gamma*(-x)**(-gamma-1)      x <= 0
    For the maximum order statistic, the standard form of the
    hazard function is:
       h(x) = EV2PDF(x,gamma)/(1 - Ev2CDF(x,gamma))    x >= 0
    where gamma is a positive number that is the shape parameter,
    EV2PDF is the probability density of the EV2 distribution, and
    EV2CDF is the cumulative distribution of the EV2 distribution.
 
Syntax:
    LET <y> = EV2HAZ(<x>,<gamma>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed extreme value type II hazard
               value is saved;
          <gamma> is a number or parameter that specifies the shape
               parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = EV2HAZ(3,1.5)
    LET X2 = EV2HAZ(X1,GAMMA)
 
Note:
    The SET MINMAX command specifies whether the minimum or maximum
    order statistic form is used.  Entering SET MINMAX 2 specifies the
    maximum order statistic while SET MINMAX 1 specifies the
    minimum order statistic.  This command is required before using the
    EV1CDF function.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EV2CDF  = Compute the extreme value type II cumulative distribution
              function.
    EV2PDF  = Compute the extreme value type II probability density
              function.
    EV2HAZ  = Compute the extreme value type II hazard function.
    EV2HAZ  = Compute the extreme value type II hazard function.
    EV1PDF  = Compute the extreme value type I probability density
              function.
    WEIPDF  = Compute the Weibull probability density function.
    EXPPDF  = Compute the exponential probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994, (chapter 21).
 
Applications:
    Extreme Value Analysis
 
Implementation Date:
    1998/4
 
Program:
    SET MINMAX 2
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    TITLE CASE ASIS
    TITLE PLOT EV2 Hazard Function (Gamma = 1)
    PLOT EV2HAZ(X,1) FOR X = 0.01 0.01 5.5
    TITLE PLOT EV2 Hazard Function (Gamma = 0.5)
    PLOT EV2HAZ(X,0.5) FOR X = 0.01 0.01 5.5
    TITLE PLOT EV2 Hazard Function (Gamma = 2)
    PLOT EV2HAZ(X,2) FOR X = 0.01 0.01 5.5
    TITLE PLOT EV2 Hazard Function (Gamma = 5)
    PLOT EV2HAZ(X,5) FOR X = 0.01 0.01 5.5
    END OF PLOT
 
-----EV2PDF (LET)--------------------------------
 
EV2PDF
 
Name:
    EV2PDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the extreme value type II (also known
    as the Frechet distribution) probability density function.
 
Description:
    For the minimum order statistic, the standard form of the
    probability density function is:
       f(x) = gamma*(-x)**(-gamma-1)*exp(-((-x)**exp(-gamma)))  x<=0
    For the maximum order statistic, the standard form of the
    probability density function is:
       f(x) = gamma*x**(-gamma-1)*exp(-(x**exp(-gamma)))        x>=0
    where gamma is a positive number that is the shape parameter.
 
Syntax:
    LET <y2> = EV2PDF(<y1>,<gamma>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, a number, or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed extreme value type II pdf value is
               saved;
          <gamma> is a number or parameter that specifies the shape
               parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = EV2PDF(3,1.5)
    LET X2 = EV2PDF(X1,GAMMA)
 
Note:
    The SET MINMAX command specifies whether the minimum or maximum
    order statistic form is used.  Entering SET MINMAX 2 specifies the
    maximum order statistic while SET MINMAX 1 specifies the
    minimum order statistic.  This command is required before using the
    EV1CDF function.
 
Note:
    For the minimum order statistic, the general form of the
    probability density function is:
       f(x) = gamma*(-(u-x)/beta)**(-gamma-1)*
              exp(-((u-x)/beta)**(-gamma)))          x<=u
    For the maximum order statistic, the general form of the
    probability density function is:
       f(x) = gamma*((x-u)/beta)**(-gamma-1)*
                 exp(-((x-u)/beta)**exp(-gamma)))    x>=0
    where u is a location parameter and beta is a shape parameter.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EV2CDF = Compute the extreme value type II cumulative distribution
             function.
    EV2PDF = Compute the extreme value type II probability density
             function.
    EV1PDF = Compute the extreme value type I probability density
             function.
    EV1PPF = Compute the extreme value type I percent point function.
    EV2PPF = Compute the extreme value type II percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    EXPCDF = Compute the exponential cumulative distribution function.
    EXPPDF = Compute the exponential probability density function.
    EXPPPF = Compute the exponential percent point function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994, (chapter 21).
 
Applications:
    Extreme Value Analysis
 
Implementation Date:
    94/4
 
Program:
    SET MINMAX 2
    MAJOR YTIC NUMBER 6; MINOR YTIC NUMBER 1
    YLIMITS 0 1; YTIC DECIMAL 1
    XLIMITS 0 5; XTIC OFFSET 0.6 0.6
    TITLE PLOT EV2PDF FOR VARIOUS VALUES OF GAMMA
    SEGMENT 1 COORDINATES 71 88 76 88; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 71 84 76 84; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 71 80 76 80; SEGMENT 3 PATTERN DOT
    LEGEND 1 GAMMA = 1; LEGEND 1 COORDINATES 77 87
    LEGEND 2 GAMMA = 0.5; LEGEND 2 COORDINATES 77 83
    LEGEND 3 GAMMA = 2; LEGEND 3 COORDINATES 77 79
    LINES SOLID DASH DOT DASH2
    PLOT EV2PDF(X,1) FOR X = 0.01 0.01 5.5 AND
    PLOT EV2PDF(X,0.5) FOR X = 0.01 0.01 5.5 AND
    PLOT EV2PDF(X,2) FOR X = 0.01 0.01 5.5
 
-----EV2PPF (LET)--------------------------------
 
EV2PPF
 
Name:
    EV2PPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the extreme value type II (also known
    as the Frechet) percent point function.
 
Description:
    For the minimum order statistic, the standard form of the
    probability density function is:
       f(x) = gamma*(-x)**(-gamma-1)*exp(-((-x)**exp(-gamma)))  x<=0
    For the maximum order statistic, the standard form of the
    probability density function is:
       f(x) = gamma*x**(-gamma-1)*exp(-(x**exp(-gamma)))        x>=0
    where gamma is a positive number that is the shape parameter.
 
    The percent point function is the inverse of the cumulative
    distribution function.  The cumulative distribution sums the
    probability from 0 to the given x value (i.e., the integral of the
    above function).  The percent point function takes a cumulative
    probability value and computes the corresponding x value.
 
    The input value is a real number between 0 and 1 (since it
    corresponds to a probability).
 
Syntax:
    LET <y2> = EV2PPF(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, a number, or a parameter in the range 0
               to 1;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed extreme value type II ppf value is
               stored;
          <gamma> is a number or parameter that specifies the shape
               parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = EV2PPF(0.9)
    LET X2 = EV2PPF(X1)
 
Note:
    The SET MINMAX command specifies whether the minimum or maximum
    order statistic form is used.  Entering SET MINMAX 2 specifies the
    maximum order statistic while SET MINMAX 1 specifies the
    minimum order statistic.  This command is required before using the
    EV1CDF function.
 
Note:
    For the minimum order statistic, the standard form of the
    probability density function is:
       f(x) = gamma*(-(x-u)/beta)**(-gamma-1)*
                 exp(-((-(x-u)/beta)**exp(-gamma)))  x<=u
    For the maximum order statistic, the standard form of the
    probability density function is:
       f(x) = gamma*((x-u)/beta)**(-gamma-1)*
                 exp(-((x-u)/beta)**exp(-gamma)))    x>=0
    where u is a location parameter and beta is a shape parameter.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EV2CDF = Compute the extreme value type II cumulative distribution
             function.
    EV2PDF = Compute the extreme value type II probability density
             function.
    EV1PDF = Compute the extreme value type I probability density
             function.
    EV1PPF = Compute the extreme value type I percent point function.
    EV2PPF = Compute the extreme value type II percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    EXPCDF = Compute the exponential cumulative distribution function.
    EXPPDF = Compute the exponential probability density function.
    EXPPPF = Compute the exponential percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, Houghton
    Mifflin, 1970 (chapter 21).
 
Applications:
    XX
 
Implementation Date:
    94/4
 
Program:
    SET MINMAX 2
    XLIMITS 0 1; MAJOR XTIC NUMBER 6
    MINOR XTIC NUMBER 1; XTIC DECIMAL 1
    SEGMENT 1 COORDINATES 16 88 21 88; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 16 84 21 84; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 16 80 21 80; SEGMENT 3 PATTERN DOT
    SEGMENT 4 COORDINATES 16 76 21 76; SEGMENT 4 PATTERN DASH2
    LEGEND 1 GAMMA = 1; LEGEND 1 COORDINATES 22 87
    LEGEND 2 GAMMA = 0.5; LEGEND 2 COORDINATES 22 83
    LEGEND 3 GAMMA = 2; LEGEND 3 COORDINATES 22 79
    LEGEND 4 GAMMA = 5; LEGEND 4 COORDINATES 22 75
    LINES SOLID DASH DOT DASH2
    TITLE PLOT EV2PPF FOR VARIOUS VALUES OF GAMMA
    PLOT EV2PPF(X,1) FOR X = 0.01 .01 0.95 AND
    PLOT EV2PPF(X,0.5) FOR X = 0.01 .01 0.75 AND
    PLOT EV2PPF(X,2) FOR X = 0.01 .01 0.99 AND
    PLOT EV2PPF(X,5) FOR X = 0.01 .01 0.99
 
-----EWECDF (LET)--------------------------------
 
EWECDF
 
Name:
    EWECDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the exponentiated Weibull
    cumulative distribution function with shape parameters gamma
    and theta.
 
Description:
    The standard form of the exponentiated Weibull cumulative
    distribution function is:
       F(x,gamma,theta) = [1 - EXP(-x**gamma]**theta
                          0 < x < infinity, gamma, theta > 0
    where gamma and theta are shape parameters.
 
Syntax:
    LET <y> = EWECDF(<x>,<GAMMA>,<THETA>)
                                 <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed exponentiated Weibull cdf value is
               stored;
          <GAMMA> is a positive number or parameter that specifies the
               first shape parameter;
          <THETA> is a positive number or parameter that specifies the
               second shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = EWECDF(3,2,3)
    LET A = EWECDF(A1,4,0.5)
    LET X2 = EWECDF(X1,2,1.5)
    LET X2 = EWECDF(X1,GAMMA,THETA)
 
Note:
    The general form of the exponentiated Weibull cumulative
    distribution function is:
       F(x,gamma,theta,mu,sigma) = 
                          [1 - EXP(-((x-mu)/sigma)**gamma]**theta
                          0 < x < infinity, gamma, theta, sigma > 0
    where gamma and theta are shape parameters and mu and sigma
    are the location and scale parameters, respectively.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
    EWEPPF = Compute the exponentiated Weibull percent point
             function.
    WEIPDF = Compute the Weibull probability density function.
    EXPPDF = Compute the exponential probability density function.
    GAMPDF = Compute the gamma probability density function.
    GGDPDF = Compute the generalized gamma probability density
             function.
    IGAPDF = Compute the inverted gamma probability density function.
    CHSPDF = Compute the chi-square probability density function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "The Exponentiated Weibull Family: A Reanalysis of the
    Bus-Motor-Failure Data", Mudholkar, Srivastava, and
    Friemer, Technometrics, November, 1995 (pp. 436-445).
 
Applications:
    Reliability Analysis
 
Implementation Date:
    1995/9
 
Program:
    LET G = DATA 1 1 1 0.5 0.5 0.5 2 2 2
    LET C = DATA 0.5 1 2 0.5 1 2 0.5 1 2
    LET START = DATA 0.01 0 0 0.01 0.01 0 0 0 0
    LET INC = DATA 0.001 0.01 0.01 0.001 0.01 0.01 0.01 0.01 0.01
    LET STOP = DATA 0.5 5 5 1 5 5 5 5 5
    .
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LOOP FOR K = 1 1 9
       LET G1 = G(K)
       LET C1 = C(K)
       LET FIRST = START(K)
       LET LAST = STOP(K)
       LET INCT = INC(K)
       X1LABEL GAMMA = ^G1
       X2LABEL C = ^C1
       PLOT EWECDF(X,G1,C1) FOR X = FIRST INCT LAST
    END OF LOOP
    END OF MULTIPLOT
 
-----EWECHAZ (LET)--------------------------------
 
EWECHAZ
 
Name:
    EWECHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the exponentiated Weibull cumulative
    hazard function with shape parameters gamma and theta.
 
Description:
    The standard form of the exponentiated Weibull cumulative hazard
    function is:
       H(x,gamma,theta) = -DLOG[1-(1-EXP[-(x)**gamma])**theta]
        0 < x < infinity, gamma, theta > 0
    where gamma and theta are shape parameters.
 
Syntax:
    LET <y> = EWECHAZ(<x>,<gamma>,<theta>)
                                 <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed exponentiated Weibull cumulative
               hazard value is stored;
          <gamma> is a positive number, parameter, or variable that
               specifies the first shape parameter;
          <theta> is a positive number, parameter, or variable that
               specifies the second shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = EWECHAZ(3,2,3)
    LET A = EWECHAZ(A1,4,0.5)
    LET X2 = EWECHAZ(X1,2,1.5)
    LET X2 = EWECHAZ(X1,GAMMA,THETA)
 
Note:
    The general form of the exponentiated Weibull cumulative hazard
    function includes the location parameter mu and the scale parameter
    sigma.  The general form of the cumulative hazard function can be
    computed from the standard form of the cumulative hazard function:
       H(x,gamma,theta,mu,sigma) = H((x-mu)/sigma,gamma,theta)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EWECDF  = Compute the exponentiated Weibull cumulative
              distribution function.
    EWEHAZ  = Compute the exponentiated Weibull hazard function.
    EWECPF  = Compute the exponentiated Weibull probability density
              function.
    EWEPPF  = Compute the exponentiated Weibull percent point
              function.
    WEIPDF  = Compute the Weibull probability density function.
    EXPPDF  = Compute the exponential probability density function.
    GAMPDF  = Compute the gamma probability density function.
    GGDPDF  = Compute the generalized gamma probability density
              function.
    IGAPDF  = Compute the inverted gamma probability density function.
    CHSPDF  = Compute the chi-square probability density function.
    NORPDF  = Compute the normal probability density function.
 
Reference:
    "The Exponentiated Weibull Family: A Reanalysis of the
    Bus-Motor-Failure Data", Mudholkar, Srivastava, and
    Friemer, Technometrics, November, 1995 (pp. 436-445).
 
Applications:
    Reliability Analysis
 
Implementation Date:
    1998/5
 
Program:
    LET G = DATA 1 1 1 0.5 0.5 0.5 2 2 2
    LET C = DATA 0.5 1 2 0.5 1 2 0.5 1 2
    LET START = DATA 0.01 0 0 0.01 0.01 0 0 0 0
    LET INC = DATA 0.001 0.01 0.01 0.001 0.01 0.01 0.01 0.01 0.01
    LET STOP = DATA 0.5 5 5 1 5 5 5 5 2
    .
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LOOP FOR K = 1 1 9
       LET G1 = G(K)
       LET C1 = C(K)
       LET FIRST = START(K)
       LET LAST = STOP(K)
       LET INCT = INC(K)
       X1LABEL GAMMA = ^G1
       X2LABEL C = ^C1
       PLOT EWECHAZ(X,G1,C1) FOR X = FIRST INCT LAST
    END OF LOOP
    END OF MULTIPLOT
 
-----EWEHAZ (LET)--------------------------------
 
EWEHAZ
 
Name:
    EWEHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the exponentiated Weibull
    hazard function with shape parameters gamma and theta.
 
Description:
    The standard form of the exponentiated Weibull hazard function is:
       h(x,gamma,theta) =
        (gamma*theta)*[1-EXP(-(x)**gamma)]**(theta-1)*EXP[-(x)**gamma]*
        x**(gamma-1)/[1-(1-EXP[-(x)**gamma])**theta]
        0 < x < infinity, gamma, theta > 0
    where gamma and theta are shape parameters.
 
Syntax:
    LET <y> = EWEHAZ(<x>,<gamma>,<theta>)
                                 <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed exponentiated Weibull hazard value is
               stored;
          <gamma> is a positive number, parameter, or variable that
               specifies the first shape parameter;
          <theta> is a positive number, parameter, or variable that
               specifies the second shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = EWEHAZ(3,2,3)
    LET A = EWEHAZ(A1,4,0.5)
    LET X2 = EWEHAZ(X1,2,1.5)
    LET X2 = EWEHAZ(X1,GAMMA,THETA)
 
Note:
    The general form of the exponentiated Weibull hazard function
    includes the location parameter mu and the scale parameter sigma.
    The general form of the hazard function can be computed from the
    standard form of the hazard function:
       h(x,gamma,theta,mu,sigma) = h((x-mu)/sigma,gamma,theta)/sigma
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EWECDF  = Compute the exponentiated Weibull cumulative
              distribution function.
    EWECHAZ = Compute the exponentiated Weibull cumulative
              hazard function.
    EWECPF  = Compute the exponentiated Weibull probability density
              function.
    EWEPPF  = Compute the exponentiated Weibull percent point
              function.
    WEIPDF  = Compute the Weibull probability density function.
    EXPPDF  = Compute the exponential probability density function.
    GAMPDF  = Compute the gamma probability density function.
    GGDPDF  = Compute the generalized gamma probability density
              function.
    IGAPDF  = Compute the inverted gamma probability density function.
    CHSPDF  = Compute the chi-square probability density function.
    NORPDF  = Compute the normal probability density function.
 
Reference:
    "The Exponentiated Weibull Family: A Reanalysis of the
    Bus-Motor-Failure Data", Mudholkar, Srivastava, and
    Friemer, Technometrics, November, 1995 (pp. 436-445).
 
Applications:
    Reliability Analysis
 
Implementation Date:
    1998/5
 
Program:
    LET G = DATA 1 1 1 0.5 0.5 0.5 2 2 2
    LET C = DATA 0.5 1 2 0.5 1 2 0.5 1 2
    LET START = DATA 0.01 0 0 0.01 0.01 0 0 0 0
    LET INC = DATA 0.001 0.01 0.01 0.001 0.01 0.01 0.01 0.01 0.01
    LET STOP = DATA 0.5 5 5 1 5 5 5 5 2
    .
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LOOP FOR K = 1 1 9
       LET G1 = G(K)
       LET C1 = C(K)
       LET FIRST = START(K)
       LET LAST = STOP(K)
       LET INCT = INC(K)
       X1LABEL GAMMA = ^G1
       X2LABEL C = ^C1
       PLOT EWEHAZ(X,G1,C1) FOR X = FIRST INCT LAST
    END OF LOOP
    END OF MULTIPLOT
 
-----EWEPDF (LET)--------------------------------
 
EWEPDF
 
Name:
    EWEPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the exponentiated Weibull
    probability density function with shape parameters gamma
    and theta.
 
Description:
    The standard form of the exponentiated Weibull probability
    density function is:
       f(x,gamma,theta) = (gamma*theta)*[1-EXP(-x**gamma)]**(theta-1)
                          *EXP[-x**gamma]*x**(gamma-1) 
                          0 < x < infinity, gamma, theta > 0
    where gamma and theta are shape parameters.
 
Syntax:
    LET <y> = EWEPDF(<x>,<GAMMA>,<THETA>)
                                 <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed exponentiated Weibull pdf value is
               stored;
          <GAMMA> is a positive number or parameter that specifies the
               first shape parameter;
          <THETA> is a positive number or parameter that specifies the
               second shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = EWEPDF(3,2,3)
    LET A = EWEPDF(A1,4,0.5)
    LET X2 = EWEPDF(X1,2,1.5)
    LET X2 = EWEPDF(X1,GAMMA,THETA)
 
Note:
    The general form of the exponentiated Weibull probability
    density function is:
       f(x,gamma,theta,mu,sigma) = (gamma*theta/sigma)*
           [1-EXP(-((x-mu)/sigma)**gamma)]**(theta-1)*
           EXP[-((x-mu)/sigma)**gamma]*((x-mu)/sigma)x**(gamma-1) 
                mu < x < infinity, gamma, theta, sigma > 0
    where gamma and theta are shape parameters and mu and sigma
    are the location and scale parameters, respectively.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EWECDF = Compute the exponentiated Weibull cumulative
             distribution function.
    EWEPPF = Compute the exponentiated Weibull percent point
             function.
    WEIPDF = Compute the Weibull probability density function.
    EXPPDF = Compute the exponential probability density function.
    GAMPDF = Compute the gamma probability density function.
    GGDPDF = Compute the generalized gamma probability density
             function.
    IGAPDF = Compute the inverted gamma probability density function.
    CHSPDF = Compute the chi-square probability density function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "The Exponentiated Weibull Family: A Reanalysis of the
    Bus-Motor-Failure Data", Mudholkar, Srivastava, and
    Friemer, Technometrics, November, 1995 (pp. 436-445).
 
Applications:
    Reliability Analysis
 
Implementation Date:
    1995/9
 
Program:
    LET G = DATA 1 1 1 0.5 0.5 0.5 2 2 2
    LET C = DATA 0.5 1 2 0.5 1 2 0.5 1 2
    LET START = DATA 0.01 0 0 0.01 0.01 0 0 0 0
    LET INC = DATA 0.001 0.01 0.01 0.001 0.01 0.01 0.01 0.01 0.01
    LET STOP = DATA 0.5 5 5 1 5 5 5 5 5
    .
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LOOP FOR K = 1 1 9
       LET G1 = G(K)
       LET C1 = C(K)
       LET FIRST = START(K)
       LET LAST = STOP(K)
       LET INCT = INC(K)
       X1LABEL GAMMA = ^G1
       X2LABEL C = ^C1
       PLOT EWEPDF(X,G1,C1) FOR X = FIRST INCT LAST
    END OF LOOP
    END OF MULTIPLOT
 
-----EWEPPF (LET)--------------------------------
 
EWEPPF
 
Name:
    EWEPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the exponentiated Weibull
    percent point function with shape parameters gamma
    and theta.
 
Description:
    The standard form of the exponentiated Weibull percent
    point function is:
       G(p,gamma,theta) = [-LOG(1 - p**(1/theta))]**(1/gamma)
                          0 < p < 1, gamma, theta > 0
    where gamma and theta are shape parameters.
 
Syntax:
    LET <y> = EWEPPF(<p>,<GAMMA>,<THETA>)
                                 <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, number, or parameter in the interval
               (0,1);
          <y> is a variable or a parameter (depending on what <p> is)
               where the computed exponentiated Weibull ppf value is
               stored;
          <GAMMA> is a positive number or parameter that specifies the
               first shape parameter;
          <THETA> is a positive number or parameter that specifies the
               second shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = EWEPPF(0.95,2,3)
    LET A = EWEPPF(P1,4,0.5)
    LET X2 = EWEPPF(P,2,1.5)
    LET X2 = EWEPPF(P,GAMMA,THETA)
 
Note:
    The general form of the exponentiated Weibull percent point
    function is:
       G(p,gamma,theta,mu,sigma) =
           mu + sigma*[-LOG(1 - p**(1/theta))]**(1/gamma)
                0 < p < 1, gamma, theta, sigma > 0
    where gamma and theta are shape parameters and mu and sigma
    are the location and scale parameters, respectively.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EWECDF = Compute the exponentiated Weibull cumulative
             distribution function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
    WEIPDF = Compute the Weibull probability density function.
    EXPPDF = Compute the exponential probability density function.
    GAMPDF = Compute the gamma probability density function.
    GGDPDF = Compute the generalized gamma probability density
             function.
    IGAPDF = Compute the inverted gamma probability density function.
    CHSPDF = Compute the chi-square probability density function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "The Exponentiated Weibull Family: A Reanalysis of the
    Bus-Motor-Failure Data", Mudholkar, Srivastava, and
    Friemer, Technometrics, November, 1995 (pp. 436-445).
 
Applications:
    Reliability Analysis
 
Implementation Date:
    1995/9
 
Program:
    LET G = DATA 1 1 1 0.5 0.5 0.5 2 2 2
    LET C = DATA 0.5 1 2 0.5 1 2 0.5 1 2
    .
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LOOP FOR K = 1 1 9
       LET G1 = G(K)
       LET C1 = C(K)
       LET FIRST = START(K)
       LET LAST = STOP(K)
       LET INCT = INC(K)
       X1LABEL GAMMA = ^G1
       X2LABEL C = ^C1
       PLOT EWEPPF(P,G1,C1) FOR P = 0.01 0.01 0.99
    END OF LOOP
    END OF MULTIPLOT
 
-----EWMA CONTROL CHART----------------------------------------
 
EWMA CONTROL CHART
 
Name:
    EWMA CONTROL CHART
 
Type:
    Graphics Command
 
Purpose:
    Generates a an exponentially weighted moving average (EWMA) control
    chart.  These are also referred to as geometric moving average
    control charts.
 
Description:
    An EWMA control chart is a data analysis analysis technique for
    determining if a measurement process has gone out of statistical
    control.  Similar to the cusum control chart, it is better than
    the standard xbar control chart for detecting small shifts in
    the process mean.

    For the EWMA control chart, we plot

        y(t) = p*xbar(t) + (1 - p)*y(t-1)

    where p is a fraction between 0 and 1 and xbar(t) is the subgroup
    average at time t.  That is, we plot a weighted average of the
    current subgroup mean with the previous weighted average.
    The starting value of y is set to the overall mean.  The closer
    the value of p is to 1, the less prior data affects the current
    estimate.

    The control limits are computed as

        xbar +/-  3.092*s*SQRT(p/(n*(2-p))

    where xbar is the overall mean and s is an estimate of the process
    standard deviation.

    In some cases, there may be historical data or engineering
    considerations that determine the control limits.  You can set
    your own control limits by entering the commands:

        LET TARGET = <value>
        LET USL = <value>
        LET LSL = <value>

    where TARGET is the desired target value and USL and LSL are the
    desired upper and lower control limits.

    You can control the appearance of this chart by setting the
    switches for the LINE, CHARACTER, SPIKE, and BAR commands
    appropriately.  Specifically,

       Trace 1 = the EWMA statistic
       Trace 2 = Target reference line (the overall mean)
       Trace 3 = Dataplot calculated upper control limit
       Trace 4 = Dataplot calculated lower control limit
       Trace 5 = User specified target value
       Trace 6 = User specified upper control limit
       Trace 7 = User specified lower control limit

    For example, to draw the EWMA values as a solid line and
    an X,  the reference line and the Dataplot calculated control
    limits as dotted lines, and no user specified control limit, 
    enter the commands:

        LINE SOLID DOTTED DOTTED DOTTED BLANK BLANK BLANK
        CHARACTER X BLANK BLANK BLANK BLANK BLANK BLANK
 
Syntax 1:
    EWMA CONTROL CHART <y> <group>    <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <group> is a sub-group identifier variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for the most common case where the data is
    divided into subgroups.

Syntax 2:
    EWMA CONTROL CHART <y>     <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for the case of ungrouped data.

Examples:
    EWMA CONTROL CHART Y1 X
    EWMA CONTROL CHART Y
    EWMA CONTROL CHART Y1 X SUBSET X > 1
 
Default:
    None
 
Synonyms:
    EWMA CHART is a synonym for EWMA CONTROL CHART.

    WEIGHT is a synonym for the parameter P.  That is,
    you can enter
  
        LET WEIGHT = <value>

    to specify the weighting parameter.
 
Related Commands:
    XBAR CONTROL CHART      = Generates a mean control chart.
    RANGE CONTROL CHART     = Generates a mean control chart.
    S CONTROL CHART         = Generates a sd control chart.
    CUSUM CONTROL CHART     = Generates a mean cusum control chart.
    HOTELLING CONTROL CHART = Generates a Hotelling control chart.
    MOVING AVERAGE CHART    = Generates a moving average control
                              chart.
    MOVING RANGE CHART      = Generates a moving range control chart.
    MOVING SD CHART         = Generates a moving sd control chart.
    C CHART                 = Generates a C control chart.
    U CHART                 = Generates a U control chart.
    P CHART                 = Generates a P control chart.
    NP CHART                = Generates an Np control chart.
 
Reference
    "Statistical Methods For Quality Improvement", Thomas Ryan,
    John Wiley and Sons, 1989, pp. 122-124.

Applications:
    Quality Control
 
Implementation Date:
    1997/9
 
Program:
    TITLE Silicon Wafer Thickness Analysis
    LABEL CASE ASIS
    TITLE CASE ASIS
    Y1LABEL Wafer Thickness
    X1LABEL Day
    LEGEND 1 Statistical Process Control
    LEGEND 2 EWMA Control Chart
    .
    SKIP 25
    READ CCXBAR.DAT Y X
    .
    CHARACTERS CONTROL CHART
    CHARACTER FILL ON
    LINES CONTROL CHART
    .
    LET P = 0.5
    EWMA CONTROL CHART Y X
 
-----EXACT BINOMIAL CONFIDENCE LIMITS (LET)--------------------------
 
EXACT BINOMIAL CONFIDENCE LIMITS
 
Name:
    EXACT BINOMIAL CONFIDENCE LIMITS (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the exact binomial confidence limits for a binomial
    proportion.
 
Description:
    The binomial proportion is defined as the number of successes
    divided by the number of trials.

    Confidence intervals for the binomial proportion can be computed
    using one of the following methods:

       1) the most common method is based on the normal approximation

              phat +/- z(alpha/2)*SQRT[(phat*(1-phat))/n]

       2) the Agresti-Coull method (HELP AGRESTI COULL for details)
          In most cases, this is the recommended method to use.

       3) an exact method based on the binomial distribution.  This
          is the method discussed here.

    If either the number of failures or the sample size is small,
    the commonly used symmetrical confidence limits based on the
    normal approximation may not be accurate enough.  In that case,
    the following exact method can be used.

       1) Solve the equation

             BINCDF(x;p(u),N) = alpha/2

          for p(u) to obtain the upper 100(1 - alpha)% limit for p
          where BINCDF is the cumulative distribution function of the
          binomial distribution, x is the number of successes, and
          n is the number of trials.

       2) Next solve the equation

             BINCDF(x;p(l),n) = 1 - alpha/2

          for p(l) to obtain the lower 100(1 - alpha)% limit for p.

    Note that these intervals are not symetric about p.

    One-sided intervals can be computed by replacing alpha/2 by alpha
    in the above equations.

Syntax 1:
    LET <lowlim> <upplim> = EXACT BINOMIAL CONFIDENCE LIMITS
                            <p> <n> <alpha>
                            <SUBSET/EXCEPT/FOR qualification>
    where <p> is constant, parameter, or variable that contains the
              proportion of successes;
          <n> is constant, parameter, or variable that contains the
              number of trials;
          <alpha> is constant or parameter that contains the significance
              level;
          <lowlim> is a variable that contains the computed lower
              exact binomial confidence limit;
          <upplim> is a variable that contains the computed upper
              exact binomial confidence limit;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The <p> and <n> arguments can be either parameters or variables.
    If they are both variables, then the variables must have the same
    number of elements.  The <alpha> argument is always assumed to
    be either a constant or a parameter.

    If <p> and <n> are both parameters, then <lowlim> and <upplim> will
    be parameters.  Otherwise, they will be variables.

Syntax 2:
    LET <lowlim> = EXACT BINOMIAL LOWER LIMITS <p> <n> <alpha>
                   <SUBSET/EXCEPT/FOR qualification>
    where <p> is constant, parameter, or variable that contains the
              proportion of successes;
          <n> is constant, parameter, or variable that contains the
              number of trials;
          <alpha> is constant or parameter that contains the significance
              level;
          <lowlim> is a variable that contains the computed lower
              exact binomail confidence limit;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The <p> and <n> arguments can be either parameters or variables.
    If they are both variables, then the variables must have the same
    number of elements.  The <alpha> argument is always assumed to
    be either a constant or a parameter.

    If <p> and <n> are both parameters, then <lowlim> will be a parameter.
    Otherwise, it will be a variable.

Syntax 3:
    LET <upplim> = EXACT BINOMIAL LOWER LIMITS <p> <n> <alpha>
                   <SUBSET/EXCEPT/FOR qualification>
    where <p> is constant, parameter, or variable that contains the
              proportion of successes;
          <n> is constant, parameter, or variable that contains the
              number of trials;
          <alpha> is constant or parameter that contains the significance
              level;
          <upplim> is a variable that contains the computed upper
              exact binomail confidence limit;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The <p> and <n> arguments can be either parameters or variables.
    If they are both variables, then the variables must have the same
    number of elements.  The <alpha> argument is always assumed to
    be either a constant or a parameter.

    If <p> and <n> are both parameters, then <upplim> will be a parameter.
    Otherwise, it will be a variable.

Examples:
    LET AL AU = EXACT BINOMIAL CONFIDENCE LIMITS P N ALPHA
    LET AL = EXACT BINOMIAL LOWER LIMITS P N ALPHA
    LET AU = EXACT BINOMIAL UPPER LIMITS P N ALPHA
    LET AL AU = EXACT BINOMIAL CONFIDENCE LIMITS P N ALPHA  SUBSET TAG > 2
 
Note:
    If you would like to use this command on raw data (i.e., you have
    a variable containing a sequence of 0's and 1's), do something like
    the following

        LET YSUM = SUM Y
        LET NTRIAL = SIZE Y
        LET P = YSUM/NTRIAL
        LET AL AU = EXACT BINOMIAL CONFIDENCE LIMITS P NTRIAL ALPHA

    If you have a group-id variable (X), you would do something like

        SET LET CROSS TABULATE COLLAPSE
        LET YSUM = CROSS TABULATE SUM Y X
        LET NTRIAL = CROSS TABULATE SIZE Y X
        LET P = YSUM/NTRIAL
        LET AL AU = EXACT BINOMIAL CONFIDENCE LIMITS P NTRIAL ALPHA

    In this case, P and NTRIAL are now variables rather than parameters.

Note:
    The following commands are also available:

       LET A = TWO SIDED LOWER EXACT BINOMIAL Y
       LET A = TWO SIDED UPPER EXACT BINOMIAL Y
       LET A = ONE SIDED LOWER EXACT BINOMIAL Y
       LET A = ONE SIDED UPPER EXACT BINOMIAL Y

    These commands are Statistics Let Subcommands rather than Math
    LET Subcommands.  The distinctions are:

        1) The "Statistics" version of the command returns a single
           parameter value while the "Math" version of the command
           returns either one or two variables.

        2) The "Statistics" version of the command can be used with
           a number of other commands (see the Note above) while the
           "Math" version of the command cannot.

           For example, the "Statistics" version of the command is
           most typically used with the FLUCTUATION PLOT, CROSS TABULATE,
           and STATISTIC PLOT commands.

        3) The "Statistics" version of the command expects a single
           variable (containing a sequence of 1's and 0's).  The
           "Math" version expects summary data (i.e., P and N).  The
           P and N can be either constants, parameters, or variables
           (or even a mix of these).

    Which form of the command to use is determined by the context of
    what you are trying to do.

    For details on the "Statistics" version of the command, enter

        HELP EXACT BINOMIAL

Default:
    None
 
Synonyms:
    EXACT BINOMIAL CONFIDENCE is a synonym for EXACT BINOMAIL CONFIDENCE
    LIMITS
 
Related Commands:
    EXACT BINOMIAL                  = Compute exact binomial confidence
                                      limits statistic for binomial
                                      proportions.
    EXACT BINOMIAL AGRESTI-COULL    = Compute the Agresti-Coull confidence
                                      limits for binomial proportions.
    AGRESTI-COULL                   = Compute Agresti-Coull confidence
                                      limits statistic for binomial
                                      proportions.
    BINOMIAL PROPORTION             = Compute the binomial proportion
                                      statistic.
    BINOMIAL PROPORTION TEST        = Perform a binomial proportions test.
    CROSS TABULATE (LET)            = Perform a cross tabulation for a
                                      specified statistic.
 
Reference:
    NIST/SEMATECH e-Handbook of Statistical Methods,
    http://www.itl.nist.gov/div898/handbook/prc/section2/prc241.htm.

Applications:
    Statistics
 
Implementation Date:
    2008/3: One-sided limits implemented
    2010/10: Two-sided limits implemented
 
Program:
    LET N = 25
    LET P = 0.8
    LET ALPHA = 0.95
    LET AL AU = EXACT BINOMIAL CONFIDENCE LIMITS P N ALPHA
 
-----EXACT BINOMIAL (LET)-----------------------------------------
 
EXACT BINOMIAL
 
Name:
    EXACT BINOMIAL (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute either the lower or upper exact binomial confidence limit
    for either a one-sided or a two-sided binomial proportion of a
    variable.
 
Description:
    The binomial proportion is defined as the number of successes
    divided by the number of trials.

    In this context, we define success as "1" and failure as "0".
    Dataplot actually allows any two distinct values to be used.
    However, the larger value will always be considered "success" and
    the smaller value will always be considered "failure".  If the
    variable contains more than two distinct values, an error is
    reported.

    The BINOMIAL PROPORTION command is used to compute a point
    estimate of the probability of success.  Confidence intervals
    for the binomial proportion can be computed using one of the
    following methods:

       1) the most common method is based on the normal approximation

              phat +/- z(alpha/2)*SQRT[(phat*(1-phat))/n]

       2) the Agresti-Coull method (HELP AGRESTI COULL for details)
          In most cases, this is the recommended method to use.

       3) an exact method based on the binomial distribution.  This
          is the method discussed here.

    If either the number of failures or the sample size is small,
    the commonly used symmetrical confidence limits based on the
    normal approximation may not be accurate enough.  In that case,
    the following exact method can be used.

       1) Solve the equation

             BINCDF(x;p(u),N) = alpha/2

          for p(u) to obtain the upper 100(1 - alpha)% limit for p
          where BINCDF is the cumulative distribution function of the
          binomial distribution, x is the number of successes, and
          n is the number of trials.

       2) Next solve the equation

             BINCDF(x;p(l),n) = 1 - alpha/2

          for p(l) to obtain the lower 100(1 - alpha)% limit for p.

    Note that these intervals are not symetric about p.

    One-sided intervals can be computed by replacing alpha/2 by alpha
    in the above equations.

Syntax 1:
    LET <par> = TWO-SIDED LOWER EXACT BINOMIAL <y>
                <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the computed value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This is for raw data case and <y> should contain a sequence of
    0's and 1's.  This returns the lower confidence limit for the
    two-sided exact binomial interval.

Syntax 2:
    LET <par> = TWO-SIDED UPPER EXACT BINOMIAL <y>
                <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the computed value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This is for raw data case and <y> should contain a sequence of
    0's and 1's.  This returns the upper confidence limit for the
    two-sided exact binomial interval.

Syntax 3:
    LET <par> = ONE-SIDED LOWER EXACT BINOMIAL <y>
                <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the computed value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This is for raw data case and <y> should contain a sequence of
    0's and 1's.  This returns the lower confidence limit for the
    one-sided lower tailed exact binomial interval.

Syntax 4:
    LET <par> = ONE-SIDED UPPER EXACT BINOMIAL <y>
                <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the computed value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This is for raw data case and <y> should contain a sequence of
    0's and 1's.  This returns the upper confidence limit for the
    one-sided upper tailed exact binomial interval.

Examples:
    LET A = TWO-SIDED LOWER EXACT BINOMIAL Y1
    LET A = TWO-SIDED UPPER EXACT BINOMIAL Y1
    LET A = ONE-SIDED LOWER EXACT BINOMIAL Y1
    LET A = ONE-SIDED UPPER EXACT BINOMIAL Y1
    LET A = TWO-SIDED LOWER EXACT BINOMIAL Y1  SUBSET TAG > 2
 
Note:
    To specify the signficance level to use for the exact binomial
    limits, enter the command

        LET ALPHA = <value>

    The default value of alpha is 0.95.
 
Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

    These various commands are actually where the EXACT BINOMIAL
    statistics are most commonly used.

Note:
    In addition to the commands given here, the following commands
    are also available:

       LET AL = EXACT BINOMIAL LOWER LIMITS P N ALPHA
       LET AU = EXACT BINOMIAL UPPER LIMITS P N ALPHA

    This command is a Math Let Subcommand rather than a Statistics
    LET Subcommand.  The distinctions are:

        1) The "Statistics" version of the command returns a single
           parameter value while the "Math" version of the command
           returns two variables.

        2) The "Statistics" version of the command can be used with
           a number of other commands (see the Note above) while the
           "Math" version of the command cannot.

           For example, the "Statistics" version of the command is
           most typically used with the FLUCTUATION PLOT, CROSS TABULATE,
           and STATISTIC PLOT commands.

        3) The "Statistics" version of the command expects a single
           variable (containing a sequence of 1's and 0's).  The
           "Math" version expects summary data (i.e., P and N).  The
           P and N can be either constants, parameters, or variables
           (or even a mix of these).

    Which form of the command to use is determined by the context of
    what you are trying to do.

    For details on the "Math" version of the command, enter

        HELP EXACT BINOMIAL CONFIDENCE LIMITS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EXACT BINOMIAL CONFIDENCE LIMITS = Compute exact binomial confidence
                                       limits for binomial proportions.
    AGRESTI COULL                    = Compute the Agresti Coull
                                       confidence limits statistic for
                                       binomial proportions.
    BINOMIAL PROPORTION              = Compute the binomial proportion
                                       statistic.
    BINOMIAL PROPORTION TEST         = Perform a binomial proportions test.
    CROSS TABULATE                   = Perform a cross-tabulation for a
                                       specified statistic.
    FLUCTUATION PLOT                 = Generate a fluctuation plot.
    STATISTIC PLOT                   = Generate a statistic versus subset
                                       plot.
 
References:
    NIST/SEMATECH e-Handbook of Statistical Methods,
    http://www.itl.nist.gov/div898/handbook/prc/section2/prc241.htm.
 

Applications:
    Statistics
 
Implementation Date:
    2008/3
 
Program:
    LET N = 1
    LET P = 0.8
    LET ALPHA = 0.95
    LET Y = BINOMIAL RANDOM NUMBERS FOR I = 1 1 50
    LET EL = ONE SIDED LOWER EXACT BINOMIAL Y
    LET EU = ONE SIDED LOWER EXACT BINOMIAL Y
    LET EL = TWO SIDED LOWER EXACT BINOMIAL Y
    LET EU = TWO SIDED LOWER EXACT BINOMIAL Y
 
-----EXACT RATIONAL FIT-------------------------------------------
 
EXACT RATIONAL FIT
 
Name:
    EXACT ... RATIONAL FIT
 
Type:
    Analysis Command
 
Purpose:
    Carries out an exact rational function fit.
 
Description:
    An exact rational fit is a data analysis technique for determining
    good starting values for the parameters in rational function
    models (a type of non-linear model).  This command is usually
    followed by the FIT command.  This command can be used only under
    certain specialized conditions.  If
          n  = number of observations to be fitted;
          n1 = desired degree of numerator;
          n2 = desired degree of denominator.
    then
          n1 + n2 must = n -1
    n1 and n2 are integers from 0 to 10.  Typical values of n1 and n2
    are from 0 to 3.  In practice, this technique is rarely used on
    the original data (because n is usually much larger than 10 or 20).
    This technique is usually applied to a selected subset of the
    original data, with the selection done so that the subset mimics
    quite closely the original data.  An exact rational fit to the
    subset will thus provide starting values which may be used for a
    least squares fit to the full data set.
 
Syntax 1:
    EXACT  <n1>/<n2>  RATIONAL FIT  <y1>  <x1>
                    <SUBSET/EXCEPT/FOR qualification>
    where <n1> is an integer number or parameter from 0 to 10 that is
               the desired degree of the numerator;
          <n2> is an integer number or parameter from 0 to 10 that is
               the desired degree of the denominator;
          <y1> is the response (= vertical axis) variable;
          <x1> is the independent (= horizontal axis) variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional and
               rarely used in this context.
 
    As discussed above, y1 and x1 usually only have a relatively
    small number of observations.
 
Syntax 2:
    EXACT  <n1>/<n2>  RATIONAL FIT  <y1>  <x1>  <y2>  <x2>
                    <SUBSET/EXCEPT/FOR qualification>
    where <n1> is an integer number or parameter from 0 to 10 that is
               the desired degree of the numerator;
          <n2> is an integer number or parameter from 0 to 10 that is
               the desired degree of the denominator;
          <y1> is the response (= vertical axis) variable;
          <x1> is the independent (= horizontal axis) variable;
          <y2> is the response (= vertical axis) variable;
          <x2> is the independent (= horizontal axis) variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional and
               rarely used in this context.
 
    In this syntax, y1 and x1 usually have only a few observations,
    while y2 and x2 are usually the original data with many
    observations.  The exact rational fit is carried out on y1 and x1,
    and then predicted values (in PRED) and residuals (in RES) are
    computed by applying the exact-fit coefficients to the full data
    set.
 
Examples:
    EXACT 1/1 RATIONAL FIT Y2 X2
    EXACT 2/3 RATIONAL FIT Y2 X2 Y X
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FIT                = Carries out a least squares fit.
    PRE-FIT            = Carries out a least squares pre-fit.
    SPLINE FIT         = Carries out a spline fit.
    SMOOTH             = Carries out a smoothing.
    ANOVA              = Carries out an ANOVA.
    MEDIAN POLISH      = Carries out a median polish.
    PLOT               = Generates a data or function plot.
    PRED               = A variable where predicted values are stored.
    RES                = A variable where residuals are stored.
    RESSD              = A parameter where the residual standard
                         deviation is stored.
    RESDF              = A parameter where the residual degrees of
                         freedom is stored.
    REPSD              = A parameter where the replication standard
                         deviation is stored.
    REPDF              = A parameter where the replication degrees of
                         freedom is stored.
    LOFCDF             = A parameter where the lack of fit cdf is
                         stored.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    . EXAMPLE -- TOM HAHN COPPER THERMAL EXPANSION STUDY
    . MODEL   -- QUADRATIC/QUADRATIC AND CUBIC/CUBIC TECHNIQUE FOR
    .            UPDATING AND IMPROVING RATIONAL FIT MODEL.  A SECOND
    .            FIT IS RESTRAINED TO GO THROUGH THE ORGIN.
    READ HAHN1.DAT X Y
    .
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    MULTIPLOT 2 2
    CHARACTER O
    CHARACTER SIZE 1.0
    LINE BLANK
    TITLE RAW DATA
    Y1LABEL COEFFICIENT OF THERMAL EXPANSION (COPPER)
    X1LABEL TEMPERATURE (DEGREES KELVIN)
    PLOT Y X
    .
    CAPTURE EXACT_FIT.DAT
    LET X2 = DATA 10 50 120 200 800
    LET Y2 = DATA 0 5 12 15 20
    EXACT 2/2 FIT Y2 X2 Y X
    .
    TITLE EXACT QUADRATIC/QUADRATIC FIT
    PLOT Y PRED VS X
    .
    LET X2 = DATA 40 30 FOR I = 6 1 7
    LET Y2 = DATA 3 2 FOR I = 6 1 7
    EXACT 3/3 RATIONAL FIT Y2 X2 Y X
    .
    TITLE EXACT CUBIC/CUBIC RATIONAL FIT
    PLOT Y Y PRED VS X
    END OF MULTIPLOT
    .
    MULTIPLOT 2 2
    FIT Y = (A0+A1*X+A2*X**2+A3*X**3)/(1+B1*X+B2*X**2+B3*X**3)
    TITLE (A0+A1*X+A2*X**2+A3*X**3)/(1+B1*X+B2*X**2+B3*X**3)
    X2LABEL RESIDUAL STANDARD DEVIATION = ^RESSD
    PLOT Y PRED VS X
    TITLE
    Y1LABEL RESIDUALS
    PLOT RES X
    X1LABEL
    NORMAL PROBABILITY PLOT RES
    END OF MULTIPLOT
    .
    MULTIPLOT 2 2
    FIT Y = (A0+A1*X+A2*X**2+A3*X**3)/(1+B1*X+B2*X**2+B3*X**3)
    TITLE (A0+A1*X+A2*X**2+A3*X**3)/(1+B1*X+B2*X**2+B3*X**3)
    X2LABEL RESIDUAL STANDARD DEVIATION = ^RESSD
    Y1LABEL COEFFICIENT OF THERMAL EXPANSION (COPPER)
    X1LABEL TEMPERATURE (DEGREES KELVIN)
    PLOT Y PRED VS X
    TITLE
    Y1LABEL RESIDUALS
    PLOT RES X
    X1LABEL
    NORMAL PROBABILITY PLOT RES
    END OF MULTIPLOT
 
-----EXCEPT-------------------------------------------------------
 
EXCEPT
 
Name:
    EXCEPT
 
Type:
    Keyword
 
Purpose:
    Specifies a subset to be excluded for any plot and analysis
    commands and for certain support commands.
 
Syntax 1:
    <command> EXCEPT <var> <qual> <list of values>
    where <command> is a DATAPLOT command that allows subsets;
          <var> is a variable for which the subset is defined;
          <qual> is an optional qualifier (=, <, >, <>, <=, >=);
    and   <list of values> are the values of <var> to be excluded.
 
    If <qual> is omitted, equality (i.e., =) is assumed.
 
Syntax 2:
    <command> EXCEPT <var> <min> TO <max>
    <command> EXCEPT <var> = <min> TO <max>
    where <command> is a DATAPLOT command that allows subsets;
          <var> is a variable for which the subset is defined;
          <min> is the minimum value of <var> to exclude;
    and   <max> is the maximum value of <var> to exclude.
 
    The "=" qualifier is optional in this syntax.  This syntax excludes
    all values between (inclusive) <min> and <max>.
 
Examples:
    FIT Y=A*EXP(B*X) EXCEPT X 101 TO 1000
    PLOT Y PRED VERSUS X EXCEPT LAB 4
    PLOT Y X SUBSET LAB 2 TO 8 EXCEPT LAB 4
    PLOT Y X EXCEPT LAB < 4
    PLOT Y X EXCEPT LAB > 4
 
Note:
    EXCEPT X 2 10 excludes only values equal to 2 and 10 while
    EXCEPT X 2 TO 10 excludes values equal to 2 and 10 and all values
    in between as well.
 
Note:
    As shown in the above examples, EXCEPT can be combined with a
    SUBSET qualification.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SUBSET = Allows specification of a subset.
    FOR    = Allows row-specification of a subset.
    <      = Allows a "less than" subset.
    <=     = Allows a "less than or equal to" subset.
    =      = Allows a "equal to" subset.
    >=     = Allows a "greater than or equal to" subset.
    >      = Allows a "greater than" subset.
 
Applications:
    Data Subsetting
 
Implementation Date:
    Pre-1987
 
Program:
    SKIP 25
    READ BERGER1.DAT Y X BATCH
    RETAIN Y X BATCH EXCEPT BATCH = 4
 
-----EXECUTE (LET)---------------------------------------------------
 
EXECUTE
 
Name:
    EXECUTE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Execute an external program.
 
Description:
    The external program is executed with the command

        LET Y = EXECUTE <file>  X

    The above command will write the data in the variable X to
    the file "dpst1f.dat" and then execute the command

        <file>  < dpst1f.dat > dpst2f.dat

    The output in file "dpst2f.dat" will be read into the variable Y.

    Note that the first line written to dpst1f.dat will be an integer
    that specifies the number of lines in X.

    Note that the first line written to dpst1f.dat will be an integer
    that specifies the number of lines in X.

    Although this command was motivated primarily to be used within a
    FUNCTION BLOCK or a STATISTIC BLOCK, it can be used independently of
    function blocks and statistic blocks.

    The LET FUNCTION command can be used to define functions in Dataplot.
    The FUNCTION BLOCK command can be used to define functions that cannot
    be defined using the LET FUNCTION command.  For functions that cannot
    be defined using Dataplot commands within a function block, then
    the EXECUTE command provides an alternative that allows you to
    create your own functions in whatever language is most convenient.

Syntax:
    LET <y> = EXECUTE <file> <x>
    where <file> is the name of the external file to be executed;
          <x> is a variable containing data that will be read from
                standard input of the external program;
    and   <y> is a variable containing data that will be written to
                standard output by the external program.

Examples:
    LET Y = EXECUTE  ./SUM.EXE .DAT X
    LET Y = EXECUTE "MY FILES\OPT.EXE" X
 
Note:
    The specified file name should be given as a literal string.  If the file
    name is stored in a string, you can use the "^" character as in

        LET Y = EXECUTE ^FNAME  X
 
Note:
    If the external file name contans hyphens or spaces, you need to
    enclose the file name in double quotes (").  For Linux/Unix and
    Mac OS X systems, if the external file is in the current directory,
    you may need to add a "./" in front of the file name (alternatively
    you can specifiy the absolute path name).

    The file name is currently limited to 80 characters.

Note:
    Although the program examples below execute Fortran programs, you are
    not limited to this.  You can create the external program in any
    language that is convenient for you as long as that language can
    generate executable files that can be executed from the command line
    and can read from standard input and write to standard output.

Note:
    Dataplot will write the specified variable to "dpst1f.dat" using a
    Fortran E15.7 format.  One value per line will be written.  It is up
    to you to create the data needed by your external program.  The
    COMBINE command can be used to create a combination of parameters
    and variables into a single variable.

    It may be that you need to read additional information into the
    external program.  You can have your external program read any
    additional needed files.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LET FUNCTION    = Define a function.
    FUNCTION BLOCK  = Define a function block.
    STATISTIC BLOCK = Define a statistic block.
    COMBINE         = Combine parameters and variables into a single
                      variable.
 
Applications:
    Functions
 
Implementation Date:
    2016/02
 
Program 1:
    . Step 1:   Create the external program (for Linux)
    .
    capture script test.f
          program test
    c
    c     Test Dataplot LET ... EXECUTE .... command.
    c
    c     For this simple example, read in a data set and
    c     compute the mean and standard deviation.
    c
          real x(10000)
    c
          xmean=0.0
          xsd=0.0
          nval=0
          read(*,*,end=9020,err=9020)nval
    c
          sum1=0.0
          do 10 i=1,min(nval,10000)
             read(*,*,end=19,err=9020)x(i)
             sum1=sum1 + x(i)
       10 continue
       19 continue
          if(nval.ge.1)then
            xmean=sum1/real(nval)
          endif
    c
          if(nval.gt.1)then
            sum1=0.0
            do 20 i=1,nval
               sum1=sum1 + (x(i)-xmean)**2
      20    continue
            xsd=sum1/real(nval-1)
          endif
    c
     9020 continue
          write(*,*)xmean
          write(*,*)xsd
    c
          stop
          end
    end of capture
    .
    system gfortran -o test.exe  test.f
    .
    . Step 2:   Read the Data
    .
    skip 25
    read zarr13.dat x
    .
    . Step 3:   Test the command
    .
    let y = execute /home/heckert/test.exe  x
    let ymean = y(1)
    let ysd   = y(2)
 
Program 2:
    . Step 1:   Create and compile the Fortran code
    .
    capture script exec2.for
          program exec
    c
    c     Test Dataplot LET ... EXECUTE .... command.
    c
    c     For this simple example, read in a data set and
    c     compute the 2-parameter Weibull log-likelihood
    c     equations (specifically, solve for the shape parameter).
    c
          real x(10000)
    c
          nval=0
          read(*,*,end=9020,err=9020)nval
          read(*,*,end=9020,err=9020)g
    c
          sum1=0.0
          sum2=0.0
          sum3=0.0
          do 10 i=1,10000
             read(*,*,end=19,err=9020)aval
             z=log(aval)
             y2=aval**g
             w=y2*z
             sum1=sum1 + w
             sum2=sum2 + y2
             sum3=sum3 + z
       10 continue
       19 continue
    c
          n=nval-1
          c1=sum3/real(n)
          c2=1.0/g
          a=c2-(sum1/sum2) + c1
    c
     9020 continue
          write(*,*)a
    c
          stop
          end
    end of capture
    .
    system gfortran -o exec2.exe  exec2.for
    .
    . Step 1:   Read the data
    .
    skip 25
    read weibbury.dat x
    skip 0
    .
    . Step 2:   Define the function block
    .
    capture function block one f a g
    let z = execute ./exec2.exe x
    let a  = z(1)
    end of capture
    .
    list function block one
    .
    . Step 3:   Plot the function
    .
    title offset 2
    title case asis
    label case ais
    y1label Function Response A
    x1label G Parameter 
    title Function Block with Plot Command
    plot f for g = 2 0.05 20
    .
    . Step 3:   Now use it to solve an equation
    .
    let yroot = roots f wrt g for g = 2  20
    let ztemp = yroot(1)
    .
    line dash
    drawsdsd 15 0 85 0
    drawdsds ztemp 20 ztemp 90

-----EXECUTE STRING--------------------------------------------------
 
EXECUTE STRING
 
Name:
    EXECUTE STRING
 
Type:
    Support Command
 
Purpose:
    This command substitutes the value for any functions or strings
    on the command line and then executes it as a command (minus the
    words EXECUTE STRING).
 
Description:
    The following 2 commands:L
       LET FUNCTION F = CALIBRATION ANALYSIS
       EXECUTE STRING TITLE F
    results in the following command being executed:
       TITLE CALIBRATION ANALYSIS
    This command is now essentially obsolete.  The string substitution
    character (^) provides the same capability in a simpler and more
    general way.
 
Syntax:
    EXECUTE STRING <text>
    where <text> is all characters from the first non-blank character
             after EXECUTE STRING to the last non-blank character on
             the command line.  All function and string names are
             replaced with their values.
 
Examples:
    LET STRING FNAME = CALIB.DAT
    EXECUTE STRING READ ^FNAME X1 X2 X3
 
Default:
    None
 
Synonyms:
    X is a synonym for EXECUTE STRING.
 
Related Commands:
    ^         = Substitute a parameter or string name in a command line
                with its value.
    VALU()    = Replace a variable with its value in a text string.
 
Applications:
    XX
 
Implementation Date:
    Pre-1987
 
Program:
    XX
 
-----EXIT-----------------------------------------------------
 
EXIT
 
Name:
    EXIT
 
Type:
    Support Command
 
Purpose:
    Exit from DATAPLOT.
 
Syntax:
    EXIT
 
Examples:
    EXIT
 
Default:
    None
 
Synonyms:
    END
    STOP
    QUIT
    BYE
    HALT
 
Applications:
    Program Control
 
Implementation Date:
    Pre-1987
 
Program:
    XX
 
-----EXP (LET)--------------------------------
 
EXP
 
Name:
    EXP (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the exponent function of x, that is e**x.
 
Syntax:
    LET <y2> = EXP(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter containing decimal numbers;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed exponential values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = EXP(14)
    LET A = EXP(A1)
    LET X2 = EXP(X1)
    LET X2 = EXP(X1-4)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ABS    = Compute the absolute value of a number.
    SQRT   = Compute the square root of a number.
    MOD    = Compute the modulo of two numbers.
    MIN    = Compute the minimum of two numbers.
    MAX    = Compute the maximum of two numbers.
    DIM    = Compute the positive difference of two numbers.
    IND    = Compute the mathematical indicator function.
    LN     = Compute the natural logarithm of a number.
    LOG    = Compute the base 10 logarithm of a number.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    TITLE AUTOMATIC
    PLOT EXP(X) FOR X = -3 .01 2.9
 
-----EXPAND (LET)---------------------------------------------------
 
EXPAND
 
Name:
    EXPAND (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Given a variable of lab-id's, create a coded variable where the code
    values are taken from another variable.
 
Description:
    Suppose we have a variable, LAB, containing 100 lab-id's where there
    are 10 distinct lab-id's.  Suppose we have a variable, XVAL, that
    contains the means corresponding to each of these 10 lab-id's.  This
    command will create a coded variable where the first value in XVAL
    will be inserted into the rows with the smallest lab-id, the second
    value in XVAL will be inserted into the rows with the second smallest
    lab-id, and so on.  If the number of unique values for the lab-id's
    is greater than the number of rows in XVAL an error message will
    be generated (if it less, then the extra rows in XVAL will simply
    be ignored).

Syntax:
    LET <y> = EXPAND <lab> <xval>    <SUBSET/EXCEPT/FOR qualification>
    where <lab> is a variable containing lab or group id's;
          <xval> is a variable (with length equal to the number of
               distinct values in <lab>);
          <y> is a variable of the same length as <lab> where the
               coded values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y = EXPAND LAB XMEAN
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CODE           = Generate a coded variable.
    COCODE         = Generate a cocoded variable.
    COCOPY         = Generate a cocoded variable.
    CODE2          = Generate a binary coded variable.
    CODE4          = Generate a quartile coded variable.
    CODE8          = Generate an octal coded variable.
    CODEH          = Generate a hinge coded variable.
 
Applications:
    Data Manipulation
 
Implementation Date:
    2012/1
 
Program:
    skip 25
    read gear.dat y x
    .
    set let cross tabulate collapse
    let ymean = cross tabulate mean y x
    .
    let y2 = expand x ymean
    set write decimals 3
    print x y y2
 
-----EXPCDF (LET)--------------------------------
 
EXPCDF
 
Name:
    EXPCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the exponential cumulative
    distribution function.
 
Description:
    The standard form of the exponential distribution has the following
    probability density function:
       f(x) = exp(-x)      for x > 0
    The cumulative distribution is the area from negative infinity to x
    (i.e., the integral of the above function).  It has the formula:
       cdf(x) = 1.0 - exp(-x)      for x > 0
 
Syntax:
    LET <y2> = EXPCDF(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, a number, or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed exponential cdf value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = EXPCDF(3)
    LET X2 = EXPCDF(X1)
 
Note:
    The general form of the exponential distribution is:
        f(x) = (1/beta)*exp(-(x-u)/beta)      for x >= u
    The parameter u is a location parameter and the parameter beta is a
    scale parameter that must be greater than 0.  The cdf values for
    the general exponential distributions can be computed by doing
    something like the following:
        LET U = <value>
        LET BETA = <value>
        PLOT (1/BETA)*EXPCDF((X-U)/BETA) FOR X = U 0.1 10
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EXPPDF = Compute the exponential probability density function.
    EXPPPF = Compute the exponential percent point function.
    DEXCDF = Compute the double exponential cumulative distribution
             function.
    DEXPDF = Compute the double exponential probability density
             function.
    DEXPPF = Compute the double exponential percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    EV1CDF = Compute the extreme value type I cumulative distribution
             function.
    EV1PDF = Compute the extreme value type I probability density
             function.
    EV1PPF = Compute the extreme value type I percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, Houghton
    Mifflin, 1970 (chapter 18).
 
Applications:
    XX
 
Implementation Date:
    94/4
 
Program:
    YLIMITS 0 1
    MAJOR YTIC NUMBER 6
    MINOR YTIC NUMBER 1
    YTIC DECIMAL 1
    XLIMITS 0 5
    XTIC OFFSET 0 0.6
    TITLE AUTOMATIC
    PLOT EXPCDF(X) FOR X = 0.01 0.01 5.5
 
-----EXPCHAZ (LET)--------------------------------
 
EXPCHAZ
 
Name:
    EXPCHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the exponential cumulative hazard function.
 
Description:
    The standard form of the exponential distribution has the
    following cumulative hazard function:

       H(x) = x            for x > 0

Syntax:
    LET <y> = EXPCHAZ(<x>,<loc>,<scale>)
                               <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed exponential cumulative hazard value
               is saved;
          <loc> is a variable, a number, or a parameter that defines
               the location parameter;
          <scale> is a variable, a number, or a parameter that defines
               the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The location and scale parameters are optional.

Examples:
    LET A = EXPCHAZ(3)
    LET Y = EXPCHAZ(X1)
    LET Y = EXPCHAZ(X1,2,5)
 
Note:
    The general form of the exponential distribution has the
    following cumulative hazard function:

        H(x) = (x - u)/beta        for x > u,  beta > 0

    where u is a location parameter and beta is a scale parameter.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EXPHAZ  = Compute the exponential hazard function.
    EXPCDF  = Compute the exponential cumulative distribution function.
    EXPPDF  = Compute the exponential probability density function.
    EXPPPF  = Compute the exponential percent point function.
    WEIHAZ  = Compute the Weibull hazard function.
    EV1HAZ  = Compute the extreme value type I hazard function.
    EV2HAZ  = Compute the extreme value type II hazard function.
    LGNHAZ  = Compute the lognormal hazard function.
 
Reference:
    "Continuous Univariate Distributions--Vol. I", 2nd. Ed., Johnson,
    Kotz, and Balakrishnan, John Wiley and Sons, 1994.
 
    "Statistical Distributions", 2nd. Edition, Evans, Hastings, and
    Peacock, Wiley and Sons, 1993 (chapter 18).

Applications:
    Reliability
 
Implementation Date:
    1998/5
 
Program:
    TITLE AUTOMATIC
    PLOT EXPCHAZ(X) FOR X = 0.01 0.01 10
 
-----EXPECTED LOSS (LET)-------------------------------------------
 
EXPECTED LOSS
 
Name:
    EXPECTED LOSS (LET)
 
Type:
    LET Subcommand
 
Purpose:
    Compute the expected loss for a variable.
 
Description:
    The expected loss computes the number of defectives for a variable
    (i.e., the number of values that fall outside of some user
    specified tolerance limits) and multiplies that by some user
    specified cost.
 
Syntax:
    LET <par> = EXPECTED LOSS <y1>  <SUBSET/EXCEPT/FOR qualification>
          where <y1> is a response variable;
                <par> is a parameter where the computed expected loss
                     is stored;
          and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = EXPECTED LOSS Y1
    LET A = EXPECTED LOSS Y1 SUBSET TAG > 2
 
Note:
    The upper and lower specification limits must be specified by the
    user as follows:
        LET USL = <value>
        LET LSL = <value>
    The cost value must be specified as follows:
        LET USLCOST = <value>
 
Default:
    None
 
Synonyms:
    None
RELATED COMMAND
    CONTROL CHART     = Generate a control chart.
    CP (LET)          = Compute the CP index.
    CPK (LET)         = Compute the CPK index.
    PERDEF (LET)      = Compute the percentage of defectives.
 
Reference:
    "Guide to Quality Control", Karou Ishikawa, Asian Productivity
    Organization, 1982 (chapter 13).
 
Applications:
    Quality Control
 
Implementation Date:
    XX.X
 
Program:
    LET Y = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET LSL = -2
    LET USL = 2
    LET USLCOST = 10
    LET A = EXPECTED LOSS Y
 
-----EXPECTED LOSS PLOT-----------------------------------------
 
EXPECTED LOSS PLOT
 
Name:
    EXPECTED LOSS PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates an expected loss plot.
 
Description:
    An expected loss plot consists of subsample expected loss versus
    subsample index.  The subsample expected loss index is the expected
    loss of the data in the subsample.  The expected loss plot is used
    to answer the question--"Does the subsample expected loss index
    change over different subsamples?"  The plot consists of:
       Vertical   axis = subsample expected loss index;
       Horizontal axis = subsample index.
    The expected loss plot yields 2 traces:
       1. a subsample expected loss trace; and
       2. a full-sample expected loss reference line.
    Like usual, the appearance of these 2 traces is controlled by
    the first 2 settings of the LINES, CHARACTERS, SPIKES, BARS,
    and similar attributes.
 
Syntax:
    EXPECTED LOSS PLOT   <y>   <x>    <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response (= dependent) variable;
          <x> is the subsample identifier variable (this variable
              appears on the horizontal axis);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    EXPECTED LOSS PLOT Y X
    EXPECTED LOSS PLOT Y X1
 
Note:
    The expected loss computes the number of defectives for a variable
    (i.e., the number of values that fall outside of some user
    specified tolerance limits) and multiplies that by some user
    specified cost.
 
Note:
    The upper and lower specification limits must be specified by the
    user as follows:
        LET USL = <value>
        LET LSL = <value>
    The cost value must be specified as follows:
        LET USLCOST = <value>
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHARACTERS              = Sets the type for plot characters.
    LINES                   = Sets the type for plot lines.
    CP PLOT                 = Generates a Cp plot.
    CPK PLOT                = Generates a Cpk plot.
    PERCENT DEFECTIVE PLOT  = Generates a percent defective plot.
    BOX PLOT                = Generates a box plot.
    XBAR CHART              = Generates an xbar control chart.
    PLOT                    = Generates a data or function plot.
 
Applications:
    Quality Control
 
Implementation Date:
    93/10
 
Program:
    SKIP 25
    READ GEAR.DAT DIAMETER BATCH
    .
    TITLE CASE ASIS; LABEL CASE ASIS
    TITLE  Gear Diameter Analysis
    Y1LABEL EXPECTED LOSS
    X1LABEL Batch
    LEGEND 1 Process Capability
    LEGEND 2 EXPECTED LOSS Plot
    XTIC OFFSET 0.5 0.5
    CHARACTER X BLANK
    LINE BLANK SOLID
    .
    LET LSL = 0.98
    LET USL = 1.02
    LET USLCOST = 15
    .
    EXPECTED LOSS PLOT Diameter Batch
 
-----EXPERT-------------------------------------------------------
 
EXPERT
 
Note:
    The EXPERT command is only partially implemented at this time and
    is not ready for general use.
 
Name:
    EXPERT
 
Type:
    Support Command
 
Purpose:
    Prints a sequence of expert menus and explanations to provide
    guidance to the user in stepping through an analysis.
 
Description:
    4 general topic areas are available:
       1) data analysis
       2) mathematics
       3) graphics
       4) DATAPLOT
 
Syntax 1:
    EXPERT   <topic area>
    where <topic area> is one of the topic areas listed above.
 
Syntax 2:
    EXPERT   <menu identification number>
    where <menu identification number> is an integer number or
              parameter or a string that specifies the desired option.
 
Examples:
    EXPERT DATA ANALYSIS
    EXPERT MATHEMATICS
    EXPERT GRAPHICS
    EXPERT DATAPLOT
    EXPERT
    EXPERT 5.1
    EXPERT 5.2.1.4
    EXPERT 1
    EXPERT 1.3
 
Default:
    None
 
Synonyms:
    None
 
Note:
    The Expert Subsystem is integrated.  Any other DATAPLOT command
    can be entered at any time while in the subsystem.  You can reenter
    the expert system and resume where you left off (at the last menu)
    at any time (by entering 0 to print the last menu).
 
Note:
    To enter into the Expert Subsystem, enter EXPERT or EXPERT ON.
    The EXPERT command with no arguments prints out a master menu
    consisting of the 4 general topic areas.
 
Note:
    Each menu has an unique id number.  To do an absolute move to a
    particular menu, enter EXPERT followed by the id number, as in
    EXPERT 5.2.1
 
Note:
    To exit out of the Expert Subsystem, enter EXPERT OFF.  To select
    a menu item, enter the number, as in 3.  To regenerate the current
    menu, enter 0.  To regenerate the previous (i.e.,  higher-level)
    menu, enter -1.  To regenerate 2nd, 3rd, etc. previous
    (higher-order) menus, enter -2, -3, etc.
 
Related Commands:
    LIST          = Lists the contents of a file.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XX
 
-----EXPHAZ (LET)--------------------------------
 
EXPHAZ
 
Name:
    EXPHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the exponential hazard function.
 
Description:
    The standard form of the exponential distribution has the
    following hazard function:

       h(x) = 1            for x > 0
 
    That is, the hazard function for the exponential distribution
    is simply a constant.

Syntax:
    LET <y> = EXPHAZ(<x>,<loc>,<scale>)
                               <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed exponential hazard value is saved;
          <loc> is a variable, a number, or a parameter that defines
               the location parameter;
          <scale> is a variable, a number, or a parameter that defines
               the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The location and scale parameters are optional.

Examples:
    LET A = EXPHAZ(3)
    LET Y = EXPHAZ(X1)
    LET Y = EXPHAZ(X1,2,5)
 
Note:
    The general form of the exponential distribution has the
    following hazard function:

        h(x) = (1/beta)      for x > u,  beta > 0

    where u is a location parameter and beta is a scale parameter.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EXPCHAZ = Compute the exponential cumulative hazard function.
    EXPCDF  = Compute the exponential cumulative distribution function.
    EXPPDF  = Compute the exponential probability density function.
    EXPPPF  = Compute the exponential percent point function.
    WEIHAZ  = Compute the Weibull hazard function.
    EV1HAZ  = Compute the extreme value type I hazard function.
    EV2HAZ  = Compute the extreme value type II hazard function.
    LGNHAZ  = Compute the lognormal hazard function.
 
Reference:
    "Continuous Univariate Distributions--Vol. I", 2nd. Ed., Johnson,
    Kotz, and Balakrishnan, John Wiley and Sons, 1994.
 
    "Statistical Distributions", 2nd. Edition, Evans, Hastings, and
    Peacock, Wiley and Sons, 1993 (chapter 18).

Applications:
    Reliability
 
Implementation Date:
    1998/5
 
Program:
    YLIMITS 0 2
    TITLE AUTOMATIC
    PLOT EXPHAZ(X) FOR X = 0.01 0.01 10
 
-----EXPINT1 (LET)--------------------------------
 
EXPINT1
 
Name:
    EXPINT1 (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the exponential integral of order 1.
 
Description:
    For positive x, the exponential integral of order 1 is defined as:
        E1(x) = INT(EXP(-t)/t)dt            x > 0
    where INT is the integral from x to infinity.

    For negative x, the exponential integral of order 1 is defined to
    be the Cauchy principal value:
        E1(x) = -Ei(-x)                     x < 0
    where Ei is defined as:
        Ei(x) = INT(EXP(t)/t)dt             x > 0
    where INT is the integral from -x to infinity.
    
    The E1 function is undefined for zero.

Syntax:
    LET <y> = EXPINT1(<x>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-zero number, variable, or parameter;
          <y> is a variable or a parameter (depending on what <x> is
               where the computed EXPINT1 integral values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = EXPINT1(0.1)
    LET A = EXPINT1(-0.1)
    LET X2 = EXPINT1(X)
 
Note:
    DATAPLOT uses the routine E1 from the SLATEC Common Mathematical
    Library to compute this function.  SLATEC is a large set of high
    quality, portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EXPINTN    = Compute the exponential integral of order N.
    EXPINTE    = Compute the principla value of the exponential
                 integral.
    ERF        = Compute the error function.
    SININT     = Compute the sine integral.
    COSINT     = Compute the cosine integral.
    LOGINT     = Compute the logarithmic integral.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 5).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE E1 EXPONENTIAL INTEGRAL
    PLOT EXPINT1(X) FOR X = 0.01 0.01 3 AND
    PLOT EXPINT1(X) FOR X = -0.01 -0.01 -2
 
-----EXPINTE (LET)--------------------------------
 
EXPINTE
 
Name:
    EXPINTE (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Ei type exponential integral.
 
Description:
    For positive x, the exponential integral is defined as:
        Ei(x) = INT(EXP(t)/t)dt             x > 0
    where INT is the integral from -x to infinity.

    For negative x, the exponential integral is defined to be the
    Cauchy principal value:
        Ei(x) = -E1(-x)                     x < 0
    where E1 is defined as:
        E1(x) = INT(EXP(-t)/t)dt            x > 0
    where INT is the integral from x to infinity.
    
    The Ei function is undefined for zero.

Syntax:
    LET <y> = EXPINTE(<x>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-zero number, variable, or parameter;
          <y> is a variable or a parameter (depending on what <x> is
               where the computed EXPINTE integral values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = EXPINTE(0.1)
    LET A = EXPINTE(-0.1)
    LET X2 = EXPINTE(X)
 
Note:
    DATAPLOT uses the routine EI from the SLATEC Common Mathematical
    Library to compute this function.  SLATEC is a large set of high
    quality, portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EXPINTN    = Compute the exponential integral of order N.
    EXPINT1    = Compute the exponential integral or order 1.
    ERF        = Compute the error function.
    SININT     = Compute the sine integral.
    COSINT     = Compute the cosine integral.
    LOGINT     = Compute the logarithmic integral.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 5).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE EI EXPONENTIAL INTEGRAL
    PLOT EXPINTI(X) FOR X = 0.01 0.01 3 AND
    PLOT EXPINTI(X) FOR X = -0.01 -0.01 -2
 
-----EXPINTN (LET)--------------------------------
 
EXPINTN
 
Name:
    EXPINTN (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the exponential integral of order n.
 
Description:
    For positive x, the exponential integral of order 1 is defined as:
        En(x,n) = INT(EXP(-xt)/t**n)dt       x >= 0, n = 0, 1, 2, ...
    where INT is the integral from 1 to infinity.

Syntax:
    LET <y> = EXPINTN(<x>,<n>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative number, variable, or parameter;
          <n> is a positive integer number, parameter, or variable;
          <y> is a variable or a parameter (depending on what <x> and
               <n> are where the computed integral values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = EXPINTN(0.1,2)
    LET A = EXPINTN(2,4)
    LET X2 = EXPINTN(X,N)
 
Note:
    If n is 1, then x cannot be zero.

Note:
    DATAPLOT uses the routine EXINT from the SLATEC Common Mathematical
    Library to compute this function.  SLATEC is a large set of high
    quality, portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EXPINT1    = Compute the exponential integral of order 1.
    EXPINTE    = Compute the principal value of the exponential
                 integral.
    ERF        = Compute the error function.
    SININT     = Compute the sine integral.
    COSINT     = Compute the cosine integral.
    LOGINT     = Compute the logarithmic integral.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 5).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE EN EXPONENTIAL INTEGRALS
    PLOT EXPINTN(X,0) FOR X = 0.2 0.1 2 AND
    PLOT EXPINTN(X,1) FOR X = 0.7 0.1 2 AND
    PLOT EXPINTN(X,2) FOR X = 1 0.1 3 AND
    PLOT EXPINTN(X,3) FOR X = 1.2 0.1 3 AND
    PLOT EXPINTN(X,4) FOR X = 1.5 0.1 3 AND
    PLOT EXPINTN(X,5) FOR X = 1.7 0.1 3
 
-----EXPONENTIAL SMOOTHING (LET)--------------------------------
 
EXPONENTIAL SMOOTHING
 
Name:
    EXPONENTIAL SMOOTHING (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Apply exponential smoothing to a time series.
 
Description:
    Exponential smoothing is defined as:

        Y2(1) = Y(1)
        Y2(I) = ALPHA*Y(I) + (1-ALPHA)*Y2(I-1),  I > 1

    That is, the current smoothed value is a weighted average
    of the current point and the previous smoothed point.  ALPHA
    is the smoothing parameter that defines the weighting and should
    be greater than 0 and less than 1.  ALPHA equal 0 sets the
    current smoothed point to the previous smoothed value and
    ALPHA equal 1 sets the current smoothed point to the current
    point (i.e., the smoothed series is the original series).  The
    closer ALPHA is to 1, the less the prior data points enter
    into the smooth.  In practice, ALPHA is usually set to a
    value between 0.1 and 0.3.
 
Syntax:
    LET <y2> = EXPONENTIAL SMOOTHING <y1>
                           <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a  response variable;
          <alpha> is a number or parameter that specifies the
               value of the smoothing parameter ALPHA;
          <y2> is a variable where the computed exponential
               smoothing is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y2 = EXPONENTIAL SMOOTHING Y1 0.3
    LET Y2 = EXPONENTIAL SMOOTHING Y1 0.8
 
Note:
    If the value of ALPHA is omitted, Dataplot will attempt to
    find an optimal value (up to 3 decimal places).  Note that
    a brute force method is employed, so this is not a
    mathematically optimized value.  However, the computed value
    should be adequate for most applications.

Note:
    Exponential smoothing should not be applied to series that
    contain significant trend or seasonal components.  

    Holt-Winters smoothing is an extension of exponential
    smoothing that has trend and seasonal components.  Dataplot
    does not support Holt-Winters smoothing at this time.
    Dataplot does support seasonal lowess, which is a locally
    weighted least squares approach to performing a trend,
    seasonal, residual decomposition of a time series.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SMOOTH                = Perform least squares smoothing.
    ARMA                  = Fit an autoregressive-moving
                            average model.
    LOWESS                = Perform locally weighted least squares 
                            smoothing.
    SEASONAL LOESS        = Compute a locally weighted least squares
                            based trend-seasonal-residual
                            decomposition.
    SPECTRAL PLOT         = Generate a spectral plot.
    AUTOCORRELATION PLOT  = Generate a spectral plot.
 
Applications:
    Time Series
 
Implementation Date:
    2000/8
 
Program:
    SKIP 25
    READ LEW.DAT Y
    LET Y2 = EXPONENTIAL SMOOTHING Y1 0.3
 
-----EXPPDF (LET)--------------------------------
 
EXPPDF
 
Name:
    EXPPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the exponential probability density
    function.
 
Description:
    The standard form of the exponential distribution has the following
    probability density function:
       f(x) = exp(-x)      for x > 0
 
Syntax:
    LET <y2> = EXPPDF(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, a number, or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed exponential pdf value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = EXPPDF(3)
    LET X2 = EXPPDF(X1)
 
Note:
    The general form of the exponential distribution is:
        f(x) = (1/beta)*exp(-(x-u)/beta)      for x >= u
    The parameter u is a location parameter and the parameter beta is a
    scale parameter that must be greater than 0.  The pdf values for the
    general exponential distributions can be computed by doing something
    like the following:
        LET U = <value>
        LET BETA = <value>
        PLOT (1/BETA)*EXPPDF((X-U)/BETA) FOR X = U 0.1 10
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EXPCDF = Compute the exponential cumulative distribution function.
    EXPPPF = Compute the exponential percent point function.
    DEXCDF = Compute the double exponential cumulative distribution
             function.
    DEXPDF = Compute the double exponential probability density
             function.
    DEXPPF = Compute the double exponential percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    EV1CDF = Compute the extreme value type I cumulative distribution
             function.
    EV1PDF = Compute the extreme value type I probability density
             function.
    EV1PPF = Compute the extreme value type I percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, Houghton
    Mifflin, 1970 (chapter 18).
 
Applications:
    XX
 
Implementation Date:
    94/4
 
Program:
    MAJOR YTIC NUMBER 6
    MINOR YTIC NUMBER 1
    YTIC DECIMAL 1
    XLIMITS -4 4
    XTIC OFFSET 0.6 0.6
    TITLE AUTOMATIC
    PLOT EXPPDF(X) FOR X = -4.5 0.01 4.5
 
-----EXPPPF (LET)--------------------------------
 
EXPPPF
 
Name:
    EXPPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the exponential percent point
    function.
 
Description:
    The standard form of the exponential distribution has the following
    probability density function:
       f(x) = exp(-x)
    The percent point function is the inverse of the cumulative
    distribution function.  The cumulative distribution sums the
    probability from 0 to the given x value (i.e., the integral of the
    above function).  The percent point function takes a cumulative
    probability value and computes the corresponding x value.
 
    The input value is a real number between 0 and 1 (since it
    corresponds to a probability).  The output value can be any real
    number.
 
Syntax:
    LET <y2> = EXPPPF(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, a number, or a parameter in the range 0
               to 1;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed exponential ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = EXPPPF(0.9)
    LET X2 = EXPPPF(X1)
 
Note:
    The general form of the exponential distribution is:
        f(x) = (1/beta)*exp(-(x-u)/beta)
    The parameter u is a location parameter and the parameter beta is a
    scale parameter that must be greater than 0.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EXPCDF = Compute the exponential cumulative distribution function.
    EXPPDF = Compute the exponential probability density function.
    EXPSF  = Compute the exponential sparsity function.
    DEXCDF = Compute the double exponential cumulative distribution
             function.
    DEXPDF = Compute the double exponential probability density
             function.
    DEXPPF = Compute the double exponential percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    EV1CDF = Compute the extreme value type I cumulative distribution
             function.
    EV1PDF = Compute the extreme value type I probability density
             function.
    EV1PPF = Compute the extreme value type I percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, Houghton
    Mifflin, 1970 (chapter 18).
 
Applications:
    XX
 
Implementation Date:
    94/4
 
Program:
    XLIMITS 0 1
    MAJOR XTIC NUMBER 6
    MINOR XTIC NUMBER 1
    XTIC DECIMAL 1
    TITLE AUTOMATIC
    PLOT EXPPPF(X) FOR X = 0.01 .01 0.99
 
-----EXPSF (LET)--------------------------------
 
EXPSF
 
Name:
    EXPSF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the exponential sparsity function.
 
Description:
    The standard form of the exponential distribution has the following
    probability density function:
       f(x) = exp(-x)
    The sparsity function function is the derivative of the percent
    point function, which is the inverse of the cumulative distribution
    function.  The cumulative distribution sums the probability from 0
    to the given x value (i.e., the integral of the above function).
    The percent point function takes a cumulative probability value and
    computes the corresponding x value.
 
    The input value is a real number between 0 and 1 (since it
    corresponds to a probability).
 
Syntax:
    LET <y2> = EXPSF(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, a number, or a parameter in the range 0
               to 1;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed exponential sf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = EXPSF(0.9)
    LET X2 = EXPSF(X1)
 
Note:
    The general form of the exponential distribution is:
        f(x) = (1/beta)*exp(-(x-u)/beta)
    The parameter u is a location parameter and the parameter beta is a
    scale parameter that must be greater than 0.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EXPCDF = Compute the exponential cumulative distribution function.
    EXPPDF = Compute the exponential probability density function.
    EXPPPF = Compute the exponential percent point function.
    DEXCDF = Compute the double exponential cumulative distribution
             function.
    DEXPDF = Compute the double exponential probability density
             function.
    DEXPPF = Compute the double exponential percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    EV1CDF = Compute the extreme value type I cumulative distribution
             function.
    EV1PDF = Compute the extreme value type I probability density
             function.
    EV1PPF = Compute the extreme value type I percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, Houghton
    Mifflin, 1970 (chapter 18).
 
Applications:
    XX
 
Implementation Date:
    94/4
 
Program:
    XLIMITS 0 1
    MAJOR XTIC NUMBER 6
    MINOR XTIC NUMBER 1
    XTIC DECIMAL 1
    TITLE AUTOMATIC
    PLOT EXPSF(X) FOR X = 0.01 .01 0.99
 
-----EXP3 (LET)--------------------------------
 
EXP3
 
Name:
    EXP3 (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the cubic exponential integral.
 
Description:
    The cubic exponential integral is defined as:

        f(x) = INTEGRAL[EXP(-t**3)dt],       x >= 0

    where the integral is defined from 0 to x.

    Dataplot computes this function using ACM Algorithm 757 (see
    Reference: below).
 
Syntax:
    LET <y> = EXP3(<x>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative number, variable or parameter;
          <y> is a variable or a parameter (depending on what <x> 
               is) where the computed cubic exponential integral
               values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = EXP3(2)
    LET A = EXP3(X) 
    LET X2 = EXP3(X) FOR X1 = 0.1 0.1 3.0
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EXPINT1    = Compute the exponential integral of order 1.
    EXPINTN    = Compute the exponential integral of order N.
    EXPINTE    = Compute the principal value of the exponential
                 integral.
    ABRAM      = Compute the Abramowitz integral.
    DEBYE      = Compute the Debye function.
    EXP3       = Compute the cubic exponential integral.
    GOODST     = Compute the Goodwin and Stanton integral.
    LOBACH     = Compute the Lobachevski integral.
    SYNCH1     = Compute the synchrotron radiation function.
    SYNCH2     = Compute the synchrotron radiation function.
    STROM      = Compute the Stromgren integral.
    TRAN       = Compute the transport integral.
 
Reference:
    "ACM Transactions of Mathematical Software", Allan MacLead,
    Vol. 22, No. 3, September, 1996, pp. 288-301.
 
Applications:
    Special Functions
 
Implementation Date:
    1999/6
 
Program:
    TITLE AUTOMATIC
    PLOT EXP3(X) FOR X = 0 0.01 10
 
-----EXTEND-------------------------------------------------------
 
EXTEND
 
Name:
    EXTEND
 
Type:
    Support Command
 
Purpose:
    Extend a variable by another variable.  The first variable will
    have the second variable appended onto it.
 
Syntax:
    EXTEND   <var1>  <var2>
    where <var1> is the variable that will be extended;
    and   <var2> is the variable that is added onto <var1>.
 
Examples:
    EXTEND Y1 Y2
    EXTEND Y DEL
    EXTEND X X
 
Default:
    None
 
Synonyms:
    APPEND is a synonym to EXTEND, but with the arguments reversed.
    Thus if you have 2 variables X1 and X2 and wish to append the
    contents of X2 onto the end of X1, then the following 2 commands
    are equivalent:
       EXTEND X1 X2
       APPEND X2 X1
 
Related Commands:
    APPEND    = Appends a variable to another variable.
    DELETE    = Deletes all or part of a variable.
    LET       = Creates or transforms a variable.
 
Applications:
    Data Management
 
Implementation Date:
    Pre-1987
 
Program:
    LET Y1 = DATA 1 2 3 4 5
    LET Y2 = DATA 6 7 8 9 10
    EXTEND Y1 Y2
 
-----EXTREME POINTS--------------------------------------------------
 
EXTREME POINTS
 
Name:
    EXTREME POINTS
 
Type:
    LET Subcommand
 
Purpose:
    Given a set of points, return a list of extreme points.
 
Description:
    Given a set of (X,Y) points, return the four points

        (X1,YMIN)
        (XMAX,Y2)
        (X3,YMAX)
        (XMIN,Y4)

    with XMIN, XMAX, YMIN, and YMAX denoting the minimum X value, the
    maximum X value, the minimum Y value, and the maximum Y value,
    respectively.  The Xi and Yi mean the x or y coordinate corresponding
    to the minimum or maximum value.

Syntax:
    LET <yout> <xout>= EXTREME POINTS <y> <x> 
                       <SUBSET/EXPCEPT/FOR qualification>
    where <y> is a variable containing the x-coordinates of the data points;
          <x> is a variable containing the y-coordinates of the data points;
          <yout> is a variable containing the y-coordinates of the extreme
               points;
          <xout> is a variable containing the x-coordinates of the extreme
               points;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y2 X2 = EXTREME POINTS Y X

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    POINTS IN POLYGON  = Determine whether points are in the interior
                         of a convex polygon.
    CONVEX HULL        = Determine the convex hull of a set of points.
    TRANSFORM POINTS   = Perform location, scale, and rotation
                         transformation on a set of points.
    LINE INTERSECTIONS = Determine the intersection points for a set of
                         lines.
    PARALLEL LINE      = Determine the coordinates for a point that defines
                         a parallel line determined by a point and a line
                         defined by two points.
    PERPINDICULAR LINE = Determine the coordinates for a point that defines
                         a perpindicular line determined by a point and a line
                         defined by two points.

Applications:
    Computational Geometry
 
Implementation Date:
    2012/10
 
Program:
    .  Following data from Eddy's ACM article
    read x y
    2.0       0.0
    1.73      -1.0
    1.0       1.73
    0.0       2.0
    0.1       0.1
    -1.0      -1.73
    0.2       -0.2
    -1.73     1.0
    -0.3      0.3
    0.0       -2.0
    -0.4      -0.4
    -2.0      0.0
    0.5       0.5
    1.73      1.0
    0.6       -0.6
    -1.0      1.73
    -0.7      0.7
    -1.73     -1.0
    -0.8      -0.8
    1.0       -1.73
    end of data
    .
    let y2 x2 = 2d convex hull y x
    let y3 x3 = extreme points y2 x2
    let xtemp = x2(1)
    let ytemp = y2(1)
    let x2 = combine x2 xtemp
    let y2 = combine y2 ytemp
    .
    title case asis
    title offset 2
    title Extreme Points of the Convex Hull
    y1label Y
    x1label X
    tic offset units screen
    tic offset 3 3
    x3label
    .
    character hw 1 0.75 all
    character fill on all
    character color black black red
    character circle blank  circle
    line blank solid blank
    .
    pre-sort off
    plot y x and
    plot y2 x2 and
    plot y3 x3
    pre-sort on

-----EXTREME STUDENTIZED DEVIATE TEST------------------------------------
 
EXTREME STUDENTIZED DEVIATE TEST
 
Name:
    EXTREME STUDENTIZED DEVIATE TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform a generalized extreme studentized deviate (ESD) test for
    outliers.
 
Description:
    The generalized extreme Studentized deviate (ESD) test is used to
    detect one or more outliers in a univariate data set that follows an
    approximately normal distribution.

    The primary limitation of the Grubbs test and the Tietjen-Moore test
    is that the suspected number of outliers, k, must be specified
    exactly.  If k is not specified correctly, this can distort the
    conclusions of these tests.  On the other hand, the generalized ESD
    test only requires that an upper bound for the suspected number of
    outliers be specified.

    Given the upper bound, r, the generalized ESD test essentially
    performs r separate tests: a test for one outlier, a test for two
    outliers, and so on up to r outliers.

    The generalized ESD test is defined for the hypothesis:

    H0:          There are no outliers in the data set.
    Ha:          There are up to r outliers in the data set.

    Test         Compute
    Statistic:
                    R(1) = (max(i)|x(i) - xbar"/s

                  with xbar and s denoting the sample mean and sample
                  standard deviation, respectively.

                  Remove the observation that maximizes |x(i)-xbar|
                  and then recompute the above statistic with n - 1
                  observations.  Repeat this process until r
                  observations have been removed.  This results in the
                  r test statistics R(1), R(2), ..., R(r).

    Significance  alpha
    Level:

    Critical     Corresponding to the r test statistics, compute
    Region:      the following r critical values

                 lambda(i) = [t(n-i-1,p(n-i)]/
                             [SQRT((n-i-1+t(n-i-1,p)**2)*(n-i+1))]

                 where i = 1, 2, ..., r and t(nu,p) is the 100p
                 percentage point from the t distribution with nu
                 degrees of freedom, and p = 1 - alpha/(2*(n-i+1)).

                 The number of outliers is determined by finding the
                 largest i such that R(i) > lambda(i).

                 Simulation studies by Rosner indicate that this critical
                 value approximation is very accurate for n >= 25 and
                 reasonably accurate for n >= 15.
    Note that although the generalized ESD is essentially Grubbs test
    applied sequentially, there are a few important distinctions:

       1) The generalized ESD test makes approriate adjustments for the
          critical values based on the number of outliers being tested
          for that the sequential application of Grubbs test does not.

       2) If there is significant masking, applying Grubbs test
          sequentially may stop too soon.  The example below
          identifies 3 outliers at the 5% level when using the
          generalized ESD test.  However, trying to use Grubbs test
          sequentially would stop at the first iteration and
          declare no outliers.

       3) Grubbs test allows one-sided tests (i.e., you can specify
          a minimum test or the maximum test) in addition to two-sided
          tests (both the minimum and the maximum value are tested).
          The generalized ESD test is restricted to two-sided tests.

Syntax 1:
    EXTREME STUDENTIZED DEVIATE TEST  <y>
                                      <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable being tested;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Syntax 2:
    EXTREME STUDENTIZED DEVIATE MULTIPLE TEST <y1> ... <yk>   
                         <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of up to k response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax performs an extreme studentized deviate test on <y1>,
    then on <y2>, and so on.  Up to 30 response variables can be
    specified.

    Note that the syntax

         EXTREME STUDENTIZED DEVIATE MULTIPLE TEST Y1 TO Y4

    is supported.  This is equivalent to

         EXTREME STUDENTIZED DEVIATE MULTIPLE TEST Y1 Y2 Y3 Y4

Syntax 3:
    EXTREME STUDENTIZED DEVIATE REPLICATED TEST  <y>  <x1> ... <xk>
                           <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <x1> ... <xk> is a list of up to k group-id variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax peforms a cross-tabulation of <x1> ... <xk> and performs
    an extreme studentized deviate test for each unique combination of
    cross-tabulated values.  For example, if X1 has 3 levels and X2 has 2
    levels, there will be a total of 6 extreme studentized deviate tests
    performed.

    Up to six group-id variables can be specified.

    Note that the syntax

         EXTREME STUDENTIZED DEVIATE REPLICATED TEST Y X1 TO X4

    is supported.  This is equivalent to

         EXTREME STUDENTIZED DEVIATE REPLICATED TEST Y X1 X2 X3 X4

Examples:
    EXTREME STUDENTIZED DEVIATE TEST Y1
    EXTREME STUDENTIZED DEVIATE TEST Y1 LABID
    EXTREME STUDENTIZED DEVIATE MULTIPLE TEST Y1 Y2 Y3
    EXTREME STUDENTIZED DEVIATE REPLICATED TEST Y X1 X2
    EXTREME STUDENTIZED DEVIATE TEST Y1   SUBSET TAG > 2
    EXTREME STUDENTIZED DEVIATE MINIMUM TEST Y1
    EXTREME STUDENTIZED DEVIATE MAXIMUM TEST Y1

Note:
    The upper bound on the number of outliers to test for is specified
    with the command

        LET NOUTLIER = <value>

Note:
    Masking and swamping are two issues that can affect outlier tests.

    Masking can occur when we specify too few outliers in the test. For
    example, if we are testing for a single outlier when there are in
    fact two (or more) outliers, these additional outliers may influence
    the value of the test statistic enough so that no points are
    declared as outliers.

    On the other hand, swamping can occur when we specify too many
    outliers in the test. For example, if we are testing for two
    outliers when there is in fact only a single outlier, both points
    may be declared outliers.

    The possibility of masking and swamping are an important reason
    why it is useful to complement formal outlier tests with graphical
    methods. Graphics can often help identify cases where masking or
    swamping may be an issue.

    Also, masking is one reason that trying to apply a single outlier
    test sequentially can fail. If there are multiple outliers, masking
    may cause the outlier test for the first outlier to return a
    conclusion of no outliers (and so the testing for any additional
    outliers is not done).  Also, applying a single outlier test
    sequentially does not properly adjust the critical value for the
    overall test.

    The masking/swamping issue explains the primary advantage of the
    generalized ESD test.  When there is masking or swamping, it is
    not uncommon to see the conclusion for the prescence of outliers
    change as the value for the number of outliers changes.  By
    weaking the assumption that the exact number of potential outliers
    is known to the assumption that an upper bound is known (and we can
    always pick this upper bound a little high if we do not have a good
    handle on it), we are more likely to avoid distortions caused by
    masking or swamping.

Note:
    Tests for outliers are dependent on knowing the distribution of the
    data.  The generalized ESD test assumes that the data come from an
    approximately normal distribution.  For this reason, it is
    strongly recommended that the extreme studentized deviate test be
    complemented with a normal probability plot.  If the data are not
    approximately normally distributed, then the generalized ESD test
    may be detecting the non-normality of the data rather than the
    presence of outliers.

Note:
    You can specify the number of digits in the generalized ESD output
    with the command

        SET WRITE DECIMALS <value>

Note:
    The EXTREME STUDENTIZED DEVIATE TEST command automatically saves the
    following parameters:

       STATVAL    = the value of the test statistic
       PVAL       = the p-value of the test statistic
       CUTOFF0    = the 0 percent point of the reference distribution
       CUTOFF01   = the 1 percent point of the reference distribution
       CUTOFF025  = the 2.5 percent point of the reference distribution
       CUTOFF05   = the 5 percent point of the reference distribution
       CUTOFF10   = the 10 percent point of the reference distribution
       CUTOFF25   = the 25 percent point of the reference distribution
       CUTOFF50   = the 50 percent point of the reference distribution
       CUTOF100   = the 100 percent point of the reference distribution

    If the MULTIPLE or REPLICATED option is used, these values will
    be written to the file "dpst1f.dat" instead.

Note:
    In addition to the EXTREME STUDENTIZED DEVIATE TEST command, the
    following command can also be used:

        LET A = EXTREME STUDENTIZED DEVIATE Y

    In addition to the above LET command, built-in statistics are
    supported for about 17 different commands (enter HELP STATISTICS
    for details).

Default:
    None
 
Synonyms:
    ESD is a synonym for EXTREME STUDENTIZED DEVIATE
    MULTIPLE ESD is a synonym for ESD MULTIPLE
    REPLICATION ESD is a synonym for ESD REPLICATION
 
Related Commands:
    GRUBB TEST               = Perform the Grubbs outlier test.
    TIETJEN-MOORE            = Perform the Tietjen-Moore outlier test.
    DIXON TEST               = Perform the Dixon outlier test.
    ANDERSON DARLING TEST    = Perform the Anderson-Darling test for
                               normality.
    WILK SHAPIRO TEST        = Perform the Wilk-Shapiro test for
                                  normality.
    PROBABILITY PLOT         = Generates a probability plot.
    HISTOGRAM                = Generate a histogram.
    BOX PLOT                 = Generate a box plot.
 
Reference:
    Rosner, Bernard (May 1983), Percentage Points for a Generalized ESD
    Many-Outlier Procedure, Technometrics, Vol. 25, No. 2, pp. 165-172.

    Iglewicz and Hoaglin (1993), "Volume 16: How to Detect and Handle
    Outliers", The ASQC Basic Reference in Quality Control: Statistical
    Techniques, Edward F. Mykytka, Ph.D., Editor.
 
Applications:
    Outlier Detection
 
Implementation Date:
    2009/11
 
Program:
    .  Step 1: Data from Rosner paper
    .
    serial read y
    -0.25 0.68 0.94 1.15 1.20 1.26 1.26 1.34 1.38 1.43 1.49 1.49 1.55 1.56
     1.58 1.65 1.69 1.70 1.76 1.77 1.81 1.91 1.94 1.96 1.99 2.06 2.09 2.10
     2.14 2.15 2.23 2.24 2.26 2.35 2.37 2.40 2.47 2.54 2.62 2.64 2.90 2.92
     2.92 2.93 3.21 3.26 3.30 3.59 3.68 4.30 4.64 5.34 5.42 6.01
    end of data
    .
    .  Step 2: Generate a normal probability plot
    .
    title case asis
    title offset 2
    label case asis
    title Normal Probability Plot
    y1label Sorted Data
    x1label Theoretical Percent Points
    char circle
    char fill on
    char hw 1.2 0.8
    line blank
    normal prob plot y
    .
    .  Step 3: Perform the generalized ESD outlier test
    .
    set write decimals 5
    let noutlier = 10
    extreme studentized deviate test y

-----EXTREME-------------------------------------------------------
 
EXTREME
 
Name:
    EXTREME (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the most extreme value in a variable.
 
Description:
    The most extreme value is the one with the largest absolute value.
    However, the sign is preserved.
 
Syntax:
    LET <param> = EXTREME <resp>   <SUBSET/EXCEPT/FOR qualification>
    where <resp> is the variable for which the extreme is to be
                 computed;
          <param> is a parameter where the extreme value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A1 = EXTREME Y1
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    MINIMUM   = Compute the minimum of a variable.
    MAXIMUM   = Compute the maximum of a variable.
    MEAN      = Compute the mean of a variable.
 
Applications:
    XX
 
Implementation Date:
    90/4
 
Program:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET A = EXTREME Y1
 
-----EXTREME PLOT------------------------------------------------
 
EXTREME PLOT
 
Name:
    EXTREME PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates an extreme plot.
 
Description:
    An extreme plot consists of subsample extreme point versus
    subsample index.  The subsample extreme is the data value with the
    largest absolute value in the subsample.  The extreme plot is used
    to answer the question--"Does the subsample variation change over
    different subsamples?"  The plot consists of:
       Vertical   axis = subsample extreme;
       Horizontal axis = subsample index.
    The extreme plot yields 2 traces:
       1. a subsample extreme trace; and
       2. a full-sample extreme reference line.
    Like usual, the appearance of these 2 traces is controlled
    by the first 2 settings of the LINES, CHARACTERS, SPIKES,
    BARS, and similar attributes.
 
Syntax:
    EXTREME PLOT   <y>   <x>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response (= dependent) variable;
          <x> is the subsample identifier variable (this variable
              appears on the horizontal axis);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    EXTREME PLOT Y X
    EXTREME PLOT Y X1  SUBSET X1 > 3
 
Default:
    None
 
Synonyms:
    MAX PLOT
 
Related Commands:
    CHARACTERS              = Sets the type for plot characters.
    LINES                   = Sets the type for plot lines.
    MINIMUM PLOT            = Generates a minimum plot.
    MAXIMUM PLOT            = Generates a minimum plot.
    RANGE  PLOT             = Generates a range plot.
    DECILE  PLOT            = Generates a decile plot.
    STANDARD DEVIATION PLOT = Generates a stand deviation plot.
    MEAN PLOT               = Generates a mean plot.
    BOX PLOT                = Generates a box plot.
    RANGE CHART             = Generates a range control chart.
    S CHART                 = Generates a standard deviation control
                              chart.
    PLOT                    = Generates a data or function plot.
 
Applications:
    Quality Control
 
Implementation Date:
    88/2
 
Program:
    LET Y = DATA 2 4 6 11 12 21 25 28 29
    LET X = DATA 1 1 1 2 2 3 3 3 3
    LINE BLANK DASH
    CHARACTER X BLANK
    XTIC OFFSET 0.2 0.2
    Y1LABEL EXTREME
    X1LABEL SAMPLE ID
    TITLE AUTOMATIC
    EXTREME PLOT Y X
 
-----EYE COORDINATES--------------------------------------------------
 
EYE COORDINATES
 
Name:
    EYE COORDINATES
 
Type:
    Support Command
 
Purpose:
    Specifies the eye coordinates (i.e., the viewing position) for
    subsequent 3-dimensional plotting (via the 3D-PLOT command).
 
Description:
    Changing the viewing position allows you to view a 3-d plot from
    a different perspective.  This can sometimes allow you to see more
    clearly certain structures that are hidden in the default viewing
    position.
 
Syntax:
    EYE COORDINATES   <x>   <y>   <z>
    where <x> is a decimal number or parameter that specifies the
              eye coordinate for the X axis;
          <y> is a decimal number or parameter that specifies the
              eye coordinate for the Y axis;
    and   <z> is a decimal number or parameter that specifies the
              eye coordinate for the Z axis.
 
Examples:
    EYE COORDINATES 20 20 3.5
    EYE COORDINATES 0.5 200 4.5
 
Note:
    If the 3D plot is compressed in one or more directions, the most
    likely problem is that the X, Y, and Z scales have different ranges
    (e.g., X and Y go from 0 to 1000 while Z goes from 0 to 1).  One
    solution to this problem is to scale the data to the same range via
    the LET command (e.g., divide each of them by the appropriate power
    of 10 so that they all go from -1 to +1).  Changing the eye
    coordinates is an ineffective way to compensate for unequal scales.
 
Note:
    Increasing the magnitude of the eye coordinates shrinks the size of
    the 3D plot.  That is, the further away the eye is from the plot,
    the smaller the plot appears.  However, if the magnitude is too
    small, the plot may be clipped.
 
Note:
    The eye coordinates can be negative.  This can be useful for
    looking at the plot from a different perspective.  The sample
    program demonstrates the approach of showing the positive view, the
    negative X view, the negative Y view, and the X and Y both negative
    view on a single page.  Most reasonable views generate plots that
    are only marginally different from one of these 4 views.  Changing
    the magnitude of the eye coordinates can make the plot slightly
    larger or smaller, but will not change the basic appearance.
    Making the Z eye coordinate negative is generally not helpful.
 
Default:
    default x = data xmax + 3 x (data xmax - data xmin)
    default y = data ymax + 3 x (data ymax - data ymin)
    default z = data zmax + 3 x (data zmax - data zmin)
 
Synonyms:
    None
 
Related Commands:
    3D-PLOT            = Generates a 3-d data or function plot.
    ORIGIN COORDINATES = Sets the location of the origin for 3-d plots.
    PEDESTAL           = Allows or suppresses the pedestal for 3-d
                         plots.
    PEDESTAL COLOR     = Sets the pedestal color for 3-d plots.
    PEDESTAL SIZE      = Sets the pedestal height for 3-d plots.
    VISIBLE            = Allows or suppresses hidden lines in 3-d
                         plots.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    LET FUNCTION F1 = X**2 + Y**2 - X*Y
    LET X = SEQUENCE -2 .2 2
    LET Y = SEQUENCE -2 .2 2
    LET Z = F1
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    LET XMAX = MAXIMUM X
    LET XMIN = MINIMUM X
    LET XEYE = XMAX + 3*(XMAX-XMIN)
    LET YMAX = MAXIMUM Y
    LET YMIN = MINIMUM Y
    LET YEYE = YMAX + 3*(YMAX-YMIN)
    LET ZMAX = MAXIMUM Z
    LET ZMIN = MINIMUM Z
    LET ZEYE = ZMAX + 3*(ZMAX-ZMIN)
    .  All positive
    EYE COORDINATES XEYE YEYE ZEYE
    TITLE ALL EYE COORDINATES POSITIVE
    3D-PLOT F1 FOR X = -2 .2 2 FOR Y = -2 .2 2
    .  X view negative
    LET XTEMP = -XEYE
    EYE COORDINATES XTEMP YEYE ZEYE
    TITLE X VIEW NEGATIVE
    3D-PLOT F1 FOR X = -2 .2 2 FOR Y = -2 .2 2
    .  Y view negative
    LET YTEMP = -YEYE
    EYE COORDINATES XEYE YTEMP ZEYE
    TITLE Y VIEW NEGATIVE
    3D-PLOT F1 FOR X = -2 .2 2 FOR Y = -2 .2 2
    .  Both X and Y views negative
    EYE COORDINATES XTEMP YTEMP ZEYE
    TITLE X AND Y VIEWS NEGATIVE
    3D-PLOT F1 FOR X = -2 .2 2 FOR Y = -2 .2 2
    END OF MULTIPLOT
 
-------------------------------------------------------------



















































































-------------------------  *F*  ZZZZZ--------------------
 
-----FACTOR PLOT--------------------------------------
 
FACTOR PLOT
 
Name:
    FACTOR PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a factor plot.  A factor plot is simply the same
    plot generated for different response and factor variables and
    arranged on a single page.
 
    The underlying plot generated can be any univariate or bivariate
    plot.  The scatter plot is the most common application.

    Although factor plots can be generated using the MULTIPLOT
    command (and typically LOOPING), the FACTOR PLOT command allows
    some fairly involved multiplots to be generated with a minimum
    number of commands (and without looping).

Description:
    A factor plot of Y X1, ... , Xk is a plot Y X1, Y X2, .... ,
    Y Xk arranged on a single page.  The parituclar plot can
    be any plot requiring 2 variables.
    
    There are a couple of variations on this.  If a univariate
    plot (e.g., a histogram) is being generated, then
    FACTOR PLOT Y1 Y2 ... Yk would generate HISTOGRAM Y1, 
    HISTOGRAM Y2, ... HISTOGRAM Yk.  The most general case
    would have multiple response and multiple factor variables.
    For example,

        FACTOR PLOT Y1 Y2 Y3 X1 X2 X3 X4

    would generate

              col 1       col 2       col 3       col 4
       row 1: PLOT Y1 X1, PLOT Y1 X2, PLOT Y1 X3, PLOT Y1 X4
       row 2: PLOT Y2 X1, PLOT Y2 X2, PLOT Y2 X3, PLOT Y2 X4
       row 3: PLOT Y3 X1, PLOT Y3 X2, PLOT Y3 X3, PLOT Y3 X4
       row 4: PLOT Y4 X1, PLOT Y4 X2, PLOT Y4 X3, PLOT Y4 X4

    There are a number of alternatives for the appearance of this
    plot.  Dataplot tries to balance simplicity with flexibility
    by using default settings, but providing numerous SET commands
    to control the appearance of the plot.  These are described in
    detail in the NOTES section below.

Syntax 1:
    FACTOR PLOT  <y1> <y2> ... <yk>  <SUBSET/EXCEPT/FOR qualification>
    where <y1> through <yk> are the response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    Up to 25 response variables can be specified.  This syntax is
    used when generating a univariate plot.

Syntax 2:
    FACTOR PLOT  <y1> <x1> ... <xk>  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the response variables;
          <x1> through <xk> are the factor variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax generates PLOT Y1 X1, PLOT Y1 X2, etc.  Up to 25
    factor variables can be specified.  This syntax is used when
    generating a bivariate plot.

Syntax 3:
    FACTOR PLOT  <y1> ... <yl> <x1> ... <xk>  <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yl> are the response variables;
          <x1> through <xk> are the factor variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax generates a matrix of plots where the number of
    response variables determines the number of rows and the  number
    of factor variables determines the number of columns.
    This syntax is used when generating a bivariate plot and there
    is more than one response variable.

Examples:
    SET FACTOR PLOT TYPE HISTOGRAM
    FACTOR PLOT Y1 Y2 Y3 Y4 Y5

    SET FACTOR PLOT TYPE PLOT
    FACTOR PLOT Y X1 X2 X3 X4 X5 SUBSET TAG > 2
 
    SET FACTOR PLOT TYPE PLOT
    SET FACTOR PLOT RESPONSE VARIABLES 3
    FACTOR PLOT Y1 Y2 Y3  X1 X2 X3 X4
 
Note:
    The concept of the factor plot generalizes quite nicely to any
    plot type for either one or two variables.  Dataplot supports the
    factor plot for a number of different plot types.  The type of
    plot generated is controlled by the following command:

        SET FACTOR PLOT TYPE <value>

    where <value> is one of the following.

    The folllowing plot two variables (e.g., BIHISTOGRAM Y1 Y2).
    Use either syntax 2 or syntax 3 above, depending on whether
    you have one or multiple response variables, for the FACTOR PLOT
    command.

        PLOT    - generate scatter plots (this is the default).
                  The x and y axis labels are automatically set
                  to the appropriate variable name.
 
        QUANTILE-QUANTILE - generate quantile-quantile plots.
                  The x and y axis labels are automatically set
                  to the appropriate variable name.
                  
        BIHISTOGRAM - generate relative bihistograms.  We recommend
                  that you enter SET RELATIVE HISTOGRAM PERCENT to
                  generate more consistent y-axis scales.  The
                  X1LABEL is set to the first variable name and the
                  X2LABEL is set to the second variable name.  If no
                  YLABEL is already defined, the YLABEL is set to
                  "Frequency".

        BOX-COX LINEARITY - generate Box-Cox linearity plots.
                  If not previously defined, the X1LABEL is set
                  to "Alpha" and the Y1LABEL is set to "Correlation".
                  X2LABEL is set to the appropriate variable names.
                  
 
        STATISTIC PLOT - generate a statistic plot (e.g., MEAN PLOT,
                  STANDARD DEVIATION PLOT).  To define which 
                  statistic is plotted, enter the command
                      SET FACTOR PLOT STATISTIC <name>
                  where <name> can be either one or two words.
                  The list of supported statistics is the same as
                  for the STATISTIC PLOT command.  The x and y axis
                  labels are automatically set to the appropriate
                  variable name.
 
    The folllowing plot one variables (e.g., HISTOGRAM Y1).
    Use syntax 1 above.

        HISTOGRAM - generate relative histograms.  We recommend that
                  you enter SET RELATIVE HISTOGRAM PERCENT to
                  generate more consistent y-axis scales.  The
                  X1LABEL is set to the variable name.  If no Y1LABEL
                  is already defined, the Y1LABEL is set to
                  "Frequency".

        PERCENT POINT PLOT - generate a percent point plot. The
                  X1LABEL is set to "Percentile" and the X2LABEL is
                  set to the variable name.  No Y1LABEL is
                  automatically set.

        AUTOCORRELATION - generate an autocorrelation plot. If not
                  already defined, X1LABEL is set to "Lag", Y1LABEL
                  is set to "Correlation" and the X2LABEL is
                  set to the variable name.

        SPECTRAL - generate a spectral plot. If not already defined,
                  X1LABEL is set to "Frequency", Y1LABEL
                  is set to "Power" and the X2LABEL is
                  set to the variable name.

        LAG     - generate a lag plot. If not already defined,
                  X1LABEL is set to "Frequency", Y1LABEL
                  is set to "Power" and the X2LABEL is
                  set to the variable name.

        RUN SEQUENCE PLOT - generate a run sequence plot. If not
                  already defined, X1LABEL is set to "Sequence",
                  Y1LABEL is not set, and the X2LABEL is
                  set to the variable name.

        <dist> PROBABILITY PLOT - generate a probability plot for the
                  <dist> distribution.  <dist> can be up to 5 words
                  and corresponds to the same names as supported
                  by the PROBABILITY PLOT command (70+ distributions
                  supported).  If not already defined,
                  X1LABEL is set to "Theoretical", Y1LABEL
                  is set to "Data" and the X2LABEL is
                  set to the variable name.

        <dist> PPCC PLOT - generate a ppcc plot for the
                  <dist> distribution.  <dist> can be up to 5 words
                  and corresponds to the same names as supported
                  by the PPCC PLOT command (30+ distributions
                  supported).  If not already defined,
                  X1LABEL is set to "Parameter", Y1LABEL
                  is set to "Correlation" and the X2LABEL is
                  set to the variable name.

    Dataplot automatically defines X1LABEL, X2LABEL, and YLABEL
    commands for these plots.  You can control the attributes
    of these labels with the standard label setting commands.
    If you have defined variable labels (with the VARIABLE LABEL
    command), these will automatically be substituted for variable
    names in the labels.

    If you have defined variable labels with the VARIABLE LABEL
    command and you want to suppress the automatic expansion
    of the variable name to the variable label, enter

        SET VARIABLE LABEL EXPAND OFF

    To restore the default that variable names will be expanded to
    the corresponding variable label, enter

        SET VARIABLE LABEL EXPAND ON

Note:
    The following option controls which axis tic marks, tic mark
    labels, and axis labels are plotted.
 
        SET FACTOR PLOT LABELS <ON/OFF/XON/YON/BOX>

    OFF means that all axis labels are suppressed (this can be
    useful if a large number of variables are being plotted).  ON
    means that both X and Y axis labels are printed.  XON only
    plots the x axis labels and YON only plots the y axis labels.

    BOX is a special option that creates an extra column on the
    left and an extra row on the bottom.  The axis label is
    printed in this box.  BOX is typically reserved for the plot
    types that plot the variable names in the axes labels.

    The default is ON (both x and y axis labels are printed).

Note:
    The following option controls where the x axis tic marks,
    tic mark labels, and axis label are printed.
 
        SET FACTOR PLOT X AXIS <BOTTOM/TOP/ALTERNATE>

    BOTTOM specifies that the x axis labels are printed on the
    bottom axis (on the last row only).  TOP specifies that
    the x axis labels are printed on the top axis (first row
    only).  ALTERNATE specifies that the x axis labels alternate
    between the top (first row) and bottom axis (last row).
    We recommend using the TIC OFFSET command to avoid overlap
    of axis labels and tic marks.

    The default is ALTERNATE.

Note:
    The following option controls where the y axis tic marks,
    tic mark labels, and axis label are printed.
 
        SET FACTOR PLOT Y AXIS <LEFT/RIGHT/ALTERNATE>

    LEFT specifies that the y axis labels are printed on the
    left axis (on the first column only).  RIGHT specifies that
    the y axis labels are printed on the right axis (last column
    only).  ALTERNATE specifies that the y axis labels alternate
    between the left (first column) and right axis (last column).
    We recommend using the TIC OFFSET command to avoid overlap
    of axis labels and tic marks.

    The default is ALTERNATE.

Note:
    Users have different preferences in terms of whether the
    plot frames for neighboring plots are connected or not.
    This is controlled with the following option.
 
        SET FACTOR PLOT FRAME <DEFAULT/CONNECTED/USER>

    DEFAULT connects neighboring frames (i.e., the FRAME CORNER
    COORDINATES are set to 0 0 100 100).  USER uses whatever
    frame coordinates are currently set (15 20 85 90 by default)
    and makes no special provisions for axis labels and tic marks
    (i.e., you set them as you normally would, each plot uses 
    whatever you have set).  CONNECTED uses whatever frame
    coordinates have been set by the user, but it draws the axis
    labels and tic marks as if DEFAULT were being used (that is, as
    determined by the SET FACTOR PLOT <LABELS/X AXIS/Y AXIS>
    commands described above).  Typically, CONNECTED is used to
    put a small bit of space between plots.  For example, you
    might use FRAME CORNER COORDINATES  3 3 97 97 before the
    FACTOR PLOT command.
 
    Since the plots can often have different limits for the axes,
    the default is USER.

Note:
    When the tic marks and tic mark labels are all plotted on the
    same side (i.e., SET FACTOR PLOT Y AXIS is
    set to LEFT or RIGHT or SET FACTOR PLOT X AXIS is
    set to BOTTOM or TOP), then overlap between plots is possible.
    The TIC OFFSET command can be used to avoid this.  In addition,
    you can stagger the tic labels with the following command:
 
        SET FACTOR PLOT LABEL DISPLACEMENT
                <NORMAL/STAGGERED/VALUE>
 
    NORMAL means that all tic labels are plotted at a distance
    determined by the TIC LABEL DISPLACEMENT command.  STAGGERED
    means that alternating plots will be staggered.  That is, one
    will use the standard displacement while the next uses a
    staggered value.  Entering this command with a numeric value
    specifies the amount of the displacement for the staggered
    tic labels.  For example,

        TIC MARK LABEL DISPLACEMENT 10
        SET FACTOR PLOT LABEL DISPLACEMENT STAGGERED
        SET FACTOR PLOT LABEL DISPLACEMENT 25

    These commands specify that the default tic label displacement
    is 10 and the staggered tic mark label displacement is 25.

Note:
    It is often helpful on scatter plot matrices to overlay a
    fitted line on the plots.  The following command is used
    to specify the type of fit.

        SET FACTOR PLOT FIT <NONE/LOWESS/LINE/QUAD/SMOOTH>

    NONE means that no fitted line is plotted.  LOWESS means
    that a locally weighted least squares line will be overlaid.
    LINE means that a linear fit (Y = A0 + A1*X) will be overlaid.
    QUAD means that a quadratic fit (Y = A0 + A1*X + A2*X**2) will
    be overlaid.  SMOOTH means that a least squares smoothing will
    be overlaid.

    For LOWESS, it is recommended that the lowess fraction be set
    fairly high (e.g., LOWESS FRACTION 0.6).

    The fitted line is currently only generated if the factor plot
    type is PLOT.

    The default is for no fitted line to be overlaid on the plot.
    If a overlaid fit is desired, the most common choice is to use
    LOWESS.

Note:
    In distinguishing syntax 2 and syntax 3 above, Dataplot needs
    to know how many response variables there are.  This is specified
    with the command

        SET FACTOR PLOT RESPONSE VARIABLES <value>

    where <value> identifies the number of response variables.
    On the FACTOR PLOT command, Dataplot assummes that the 
    response variables (y axis) come first, then the factor
    variables (x axis).

    For the two variable plot types, the default is one.  For the
    univariate plot types, all variables are assummed to be response
    variables.

Note:
    Dataplot supports a special plot type

        PLOT Y X TAG

    In this form of the plot command, TAG is a group identifier
    variable.  Points belonging to the same group are plotted with
    the same attributes (controlled by the CHARACTER and LINE commands
    and their various attribute setting commands).

    Using a tag variable has two common purposes:

    1) If your data has natural groups (e.g., batch 1 and batch 2).
    2) To identify certain points.  The most common application
       would be to flag outliers.
 
    You can specify that the factor plot use the form
    of the PLOT command by using the command

        SET FACTOR PLOT TAG <ON/OFF>

    OFF specifies that the standard plot command (PLOT Y1 Y2) will
    be used.  ON specifies that the last variable on the
    FACTOR PLOT command is a tag variable.  That is, it is
    not plotted directly, but is instead the third variable on
    all the plot commands generated by the factor plot.

    Currently, this command only applies if the factor plot
    plot type is set to PLOT.

    In some cases, you may want to use a tag variable for both
    purposes.  That is, you may have natural groups in your data,
    but you also want to flag certain outlying points.  You can
    do this by using a SUBSET clauuse.  For example,

        LIMITS 0 120
        SET FACTOR PLOT TAG ON
        CHARACTER CIRCLE SQUARE TRIANGLE
        CHARACTER FILL OFF OFF OFF
        FACTOR PLOT Y X1 X2 X3 TAG  SUBSET Y2 <= 100
        PRE-ERASE OFF
        CHARACTER FILL ON ON ON
        FACTOR PLOT Y X1 X2 X3 TAG  SUBSET Y2 > 100

    The SET FACTOR PLOT LIMITS command, discussed below,
    can be used to control the axis limits for the individual plots.

    The default is OFF.

Note:
    Dataplot allows you to set axis limits with the LIMITS command.
    For the factor plot, it is often desirable to set
    the axis limits for each plot.  This can be done with the
    command
 
        SET FACTOR PLOT YLIMITS <LOW1> <UPP1> <LOW2> <UPP2> ...
        SET FACTOR PLOT XLIMITS <LOW1> <UPP1> <LOW2> <UPP2> ...

    Note that the pairs of limits correspond to the variable list
    in the FACTOR PLOT command.  For univariate plot types, the 
    plot order corresponds to the variable list.  For bivariate plot
    types, the YLIMITS refer to the response variables and XLIMITS
    refer to the factor variables.  That is, Dataplot determines
    which variable is being plotted on each axis, and gets the
    corresponding limits.

    The default is to allow the axis limits to float with the data.

Note:
    Dataplot supports a subregion capability.  This is used to
    draw "engineering limits" on a plot.  For a factor plot,
    if you specify engineering limits, you typically want these
    limits to vary with each plot.  They can be specified with the
    command
 
        SET FACTOR PLOT SUBREGION XLIMITS <LOW1> <UPP1>
            <LOW2> <UPP2> ...
        SET FACTOR PLOT SUBREGION YLIMITS <LOW1> <UPP1>
            <LOW2> <UPP2> ...

    This command is similar to the SET FACTOR PLOT XLIMITS and
    SET FACTOR PLOT YLIMITS commands in that the list corresponds to
    the variables entered on the FACTOR PLOT command.

    Only one set of subregion limits can be set for each variable.

    The default is that no subregion limits are set.

Note:
    You can specify a special X2LABEL for the plots with the
    following command 
 
        SET FACTOR PLOT X2LABEL <OFF/
              CORRELATION/PERCENT CORRELATION/EFFECT/
              PERCENT ACCEPT/NUMBER ACCEPT/ACCEPT TOTAL>

    where
        OFF      - no special X2LABEL is drawn.
        CORRELATION - the correlation of the points on the plot
                   is printed with the X2LABEL.  This option
                   is typically used with the plot type PLOT.
        PERCENT CORRELATION - this is the same as CORRELATION, except
                   that the correlation is printed as a percent.
        EFFECT   - the difference between the low and high value
                   is printed.  This option is typically used with
                   the plot type DEX <stat> INTERACTION (and doesn't
                   really make any sense with the other plot types).
                   This plot type is supported for the SCATTER PLOT
                   MATRIX, but not for the FACTOR PLOT.
        PERCENT ACCEPT - this option prints the percentage of points
                   inside the first subregion.  If no subregions are
                   defined, this option makes no sense.  It is
                   typically used to specify the percentage of points
                   within engineering limits.
        NUMBER ACCEPT - this option is similar to PERCENT ACCEPT.
                   However, the number of points rather than the
                   percentage is printed.
        ACCEPT TOTAL - this option is similar to NUMBER ACCEPT.
                   However, it prints the number accepted first,
                   then the total number of points.
        ACCEPT TOTAL PERCENT - this option is similar to ACCEPT TOTAL.
                   However, after printing the number accepted and
                   the total number, it prints the percentage
                   accepted.

    The following commands can be used to add a prefix and suffix
    to the X2LABEL.  For example, you might want the PERCENT
    CORRELATION to append a "%" after the percent correlation
    and to start with "CORR = ".

        SET X2LABEL PREFIX <prefix>
        SET X2LABEL SUFFIX <suffix>
 
    The appearance and location of the X2LABEL are controlled
    with the standard X2LABEL attribute setting commands.

    There are occassions where you may want to use the values
    computed in the X2LABEL for additional numeric computations.
    These values are automatically written to the file
    "dpst5f.dat".  The values are printed in the order the plots
    are generated.

Note:
    You can use standard plot control commands to control the
    appearance of the factor plot.

    For example,

       MULTIPLOT CORNER COORDINATES 5 5 95 95
       MULTIPLOT SCALE FACTOR 3
       TIC OFFSET UNITS SCREEN
       TIC OFFSET 5 5

    is a fairly typical set of commands commonly used with
    scatter plot matrices.

Default:
    None
 
Synonyms:
    SCATTER PLOT is a synonym for FACTOR PLOT.
    SET SCATTER PLOT is a synonym for SET FACTOR PLOT.
 
Related Commands:
    PLOT                = Generates a data or function plot.
    SCATTER PLOT MATIRX = Generate a factor plot.
    CONDITIONAL PLOT    = Generate a conditional (subset) plot.
 
Reference:
    Cleveland (1993), "Visualizing Data," Hobart Press.
 
    du Toit, Steyn, and Stumpf (1986), "Graphical Exploratory Data
    Analysis," Springer-Verlang, 1986.
 
Applications:
    Exploratory Data Analysis, Multivariate Data Analysis
 
Implementation Date:
    2000/01
 
Program:
    dimension 25 variables
    skip 25
    read simon1.dat y1 y2 x1 to x5 block runseq
    .
    multiplot corner coordinates 10 5 90 90
    tic offset units screen
    xtic offset 5 10
    ytic offset 5 5
    y1label displacement 15
    x1label displacement 3
    x2label displacement 7
    char x
    line blank
    .
    set factor plot response variables 2
    factor plot y1 Y2 x1 x2 x3 x4 x5
 
-----FALSE NEGATIVE (LET)--------------------------------
 
FALSE NEGATIVE
 
Name:
    FALSE NEGATIVE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the proportion of false negatives between two
    binary variables.
 
Description:
    Given two variables with n parired observations where each
    variable has exactly two possible outcomes, we can generate
    the following 2x2 table:

                      |       Variable 2        |
        Variable 1    |   Success      Failure  |  Row Total
        ====================================================
        Success       |   N11            N12    |  N11 + N12
        Failure       |   N21            N22    |  N21 + N22
        ====================================================
        Column Total  |   N11+N21      N12+N22  |  Total

    The parameters N11, N12, N21, and N22 denote the counts
    for each category.
 
    Success and failure can denote any binary response.
    Dataplot expects "success" to be coded as "1" and "failure"
    to be coded as "0".  Some typical examples would be:

       1) Variable 1 denotes whether or not a patient has a
          disease (1 denotes disease is present, 0 denotes
          disease not present).  Variable 2 denotes the result
          of a test to detect the disease (1 denotes a positive
          result and 0 denotes a negative result).

       2) Variable 1 denotes whether an object is present or
          not (1 denotes present, 0 denotes absent). Variable 2
          denotes a detection device (1 denotes object detected
          and 0 denotes object not detected).

    In these examples, the "ground truth" is typically given
    as variable 1 while some estimator of the ground truth is
    given as variable 2.
   
    The proportion of false negatives is then N12/N (i.e., the
    number of cases where variable 1 is a "success" and
    variable 2 is a "failure").  In the context of the first
    example above, the test does not detect the disease when it
    was in fact present.

Syntax:
    LET <par> = FALSE NEGATIVE <y1> <y2>
                              <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed false negative
               proportion is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = FALSE NEGATIVE Y1 Y2
    LET A = FALSE NEGATIVE Y1 Y2 SUBSET TAG > 2
 
Note:
    The two variables must have the same number of elements.
 
Note:
    There are two ways you can define the response variables:

       1) Raw data - in this case, the variables contain
          0's and 1's.

          If the data is not coded as 0's and 1's, Dataplot
          will check for the number of distinct values.  If
          there are two distinct values, the minimum value
          is converted to 0's and the maximum value is
          converted to 1's.  If there is a single distinct
          value, it is converted to 0's if it is less than
          0.5 and to 1's if it is greater than or equal to
          0.5.  If there are more than two distinct values,
          an error is returned.

       2) Summary data - if there are two observations, the
          data is assummed to be the 2x2 summary table.
          That is,

              Y1(1) = N11
              Y1(2) = N21
              Y2(1) = N12
              Y2(2) = N22
 
Note:
    This commands returns the proportion of false negatives.
    If you need raw counts or percentages, you can enter
    the commands

        LET N = SIZE Y1
        LET TRUEPOS = FALSE NEGATIVE Y1 Y2
        LET TPCOUNT = N*TRUEPOS
        LET TPPERC = 100*TRUEPOS

Note:
    This command has been extended to support the case
    for RxC tables where R denotes the number of categories
    for variable one and C denotes the number of categories
    for variable two.  Note that Dataplot assumes that the
    categories can be meaningfully ordered (Dataplot assumes
    a "small" to "large" ordering).

    In this case, if variable one denotes "ground truth" and
    variable two denotes the estimate of ground truth, then
    we define:

       1) A correct value is the case where the estimated
          category is the same as the ground truth category.

          For this case, we do not distinguish between
          "true positives" and "true negatives" as we do
          for the 2x2 case.

       2) A false positive is the case where the estimated
          category is too large.

       3) A false negative is the case where the estimated
          category is too small.

    So the number of false negatives is simply the number of
    times where the value for variable two is smaller than
    the corresponding value for variable one.  As another
    way of thinking of this, if you generate a cross-tabulation
    of the two variables, the number of false negatives is the
    sum of the elements below the diagonal in this table.

    The RxC case is currently only supported for raw data.

Note:
    The following additional commands are supported

        TABULATE FALSE NEGATIVE  Y1 Y2 X
        CROSS TABULATE FALSE NEGATIVE Y1 Y2 X1 X2

        FALSE NEGATIVES PLOT Y1 Y2 X
        CROSS TABULATE FALSE NEGATIVE PLOT Y1 Y2 X1 X2

        BOOTSTRAP FALSE NEGATIVES PLOT Y1 Y2
        JACKNIFE  FALSE NEGATIVES PLOT Y1 Y2

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FALSE POSITIVES            = Compute the proportion of
                                 false positives.
    TRUE NEGATIVES             = Compute the proportion of
                                 true negatives.
    TRUE POSITIVES             = Compute the proportion of
                                 true positives.
    TEST SENSITIVITY           = Compute the test sensitivity.
    TEST SPECIFICITY           = Compute the test specificity.
    ODDS RATIO                 = Compute the bias corrected
                                 log(odds ratio).
    ODDS RATIO STANDARD ERROR  = Compute the standard error of the
                                 bias corrected log(odds ratio).
    RELATIVE RISK              = Compute the relative risk.
    TABULATE                   = Compute a statistic for data with
                                 a single grouping variable.
    CROSS TABULATE             = Compute a statistic for data with
                                 two grouping variables.
    STATISTIC PLOT             = Generate a plot of a statistic for
                                 data with a single grouping
                                 variable.
    CROSS TABULATE PLOT        = Generate a plot of a statistic for
                                 data with two grouping variables.
    BOOTSTRAP PLOT             = Generate a bootstrap plot for a
                                 given statistic.
 
Reference:
    Fleiss, Levin, and Paik (2003), "Statistical Methods for
    Rates and Proportions", Third Edition, Wiley, chapter 1.
 
Applications:
    Categorical Data Analysis
 
Implementation Date:
    2007/4
 
Program:
    let n = 1
    .
    let p = 0.2
    let y1 = binomial rand numb for i = 1 1 100
    let p = 0.1
    let y2 = binomial rand numb for i = 1 1 100
    .
    let p = 0.4
    let y1 = binomial rand numb for i = 101 1 200
    let p = 0.08
    let y2 = binomial rand numb for i = 101 1 200
    .
    let p = 0.15
    let y1 = binomial rand numb for i = 201 1 300
    let p = 0.18
    let y2 = binomial rand numb for i = 201 1 300
    .
    let p = 0.6
    let y1 = binomial rand numb for i = 301 1 400
    let p = 0.45
    let y2 = binomial rand numb for i = 301 1 400
    .
    let p = 0.3
    let y1 = binomial rand numb for i = 401 1 500
    let p = 0.1
    let y2 = binomial rand numb for i = 401 1 500
    .
    let x = sequence 1 100 1 5
    .
    let a = false negatives y1 y2 subset x = 1
    tabulate false negativess y1 y2 x
    .
    label case asis
    xlimits 1 5
    major xtic mark number 5
    minor xtic mark number 0
    xtic mark offset 0.5 0.5
    ytic mark offset 0.05 0.05
    y1label Proportion of False Negatives
    x1label Group ID
    character x blank
    line blank solid
    .
    false negatives plot y1 y2 x
 
-----FALSE POSITIVE (LET)--------------------------------
 
FALSE POSITIVE
 
Name:
    FALSE POSITIVE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the proportion of false positives between two
    binary variables.
 
Description:
    Given two variables with n parired observations where each
    variable has exactly two possible outcomes, we can generate
    the following 2x2 table:

                      |       Variable 2        |
        Variable 1    |   Success      Failure  |  Row Total
        ====================================================
        Success       |   N11            N12    |  N11 + N12
        Failure       |   N21            N22    |  N21 + N22
        ====================================================
        Column Total  |   N11+N21      N12+N22  |  Total

    The parameters N11, N12, N21, and N22 denote the counts
    for each category.
 
    Success and failure can denote any binary response.
    Dataplot expects "success" to be coded as "1" and "failure"
    to be coded as "0".  Some typical examples would be:

       1) Variable 1 denotes whether or not a patient has a
          disease (1 denotes disease is present, 0 denotes
          disease not present).  Variable 2 denotes the result
          of a test to detect the disease (1 denotes a positive
          result and 0 denotes a negative result).

       2) Variable 1 denotes whether an object is present or
          not (1 denotes present, 0 denotes absent). Variable 2
          denotes a detection device (1 denotes object detected
          and 0 denotes object not detected).

    In these examples, the "ground truth" is typically given
    as variable 1 while some estimator of the ground truth is
    given as variable 2.

    The proportion of false positives is then N21/N (i.e., the
    number of cases where variable 1 is a failure and variable 2
    is a "successes").  In the context of the first examples above,
    the test detected the disease when it was in fact not present.

Syntax:
    LET <par> = FALSE POSITIVE <y1> <y2>
                              <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed false positive
               proportion is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = FALSE POSITIVE Y1 Y2
    LET A = FALSE POSITIVE Y1 Y2 SUBSET TAG > 2
 
Note:
    The two variables must have the same number of elements.
 
Note:
    There are two ways you can define the response variables:

       1) Raw data - in this case, the variables contain
          0's and 1's.

          If the data is not coded as 0's and 1's, Dataplot
          will check for the number of distinct values.  If
          there are two distinct values, the minimum value
          is converted to 0's and the maximum value is
          converted to 1's.  If there is a single distinct
          value, it is converted to 0's if it is less than
          0.5 and to 1's if it is greater than or equal to
          0.5.  If there are more than two distinct values,
          an error is returned.

       2) Summary data - if there are two observations, the
          data is assummed to be the 2x2 summary table.
          That is,

              Y1(1) = N11
              Y1(2) = N21
              Y2(1) = N12
              Y2(2) = N22
 
Note:
    This commands returns the proportion of false positives.
    If you need raw counts or percentages, you can enter
    the commands

        LET N = SIZE Y1
        LET FALSEPOS = FALSE POSITIVE Y1 Y2
        LET FPCOUNT = N*FALSEPOS
        LET FPPERC = 100*FALSEPOS
 
Note:
    This command has been extended to support the case
    for RxC tables where R denotes the number of categories
    for variable one and C denotes the number of categories
    for variable two.  Note that Dataplot assumes that the
    categories can be meaningfully ordered (Dataplot assumes
    a "small" to "large" ordering).

    In this case, if variable one denotes "ground truth" and
    variable two denotes the estimate of ground truth, then
    we define:

       1) A correct value is the case where the estimated
          category is the same as the ground truth category.

          For this case, we do not distinguish between
          "true positives" and "true negatives" as we do
          for the 2x2 case.

       2) A false positive is the case where the estimated
          category is too large.

       3) A false negative is the case where the estimated
          category is too small.

    So the number of false positives is simply the number of
    times where the value for variable two is larger than
    the corresponding value for variable one.  As another
    way of thinking of this, if you generate a cross-tabulation
    of the two variables, the number of false positives is the
    sum of the elements above the diagonal in this table.

    The RxC case is currently only supported for raw data.

Note:
    The following additional commands are supported

        TABULATE FALSE POSITIVE  Y1 Y2 X
        CROSS TABULATE FALSE POSITIVE Y1 Y2 X1 X2

        FALSE POSITIVES PLOT Y1 Y2 X
        CROSS TABULATE FALSE POSITIVES PLOT Y1 Y2 X1 X2

        BOOTSTRAP FALSE POSITIVES PLOT Y1 Y2
        JACKNIFE  FALSE POSITIVES PLOT Y1 Y2

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FALSE NEGATIVES            = Compute the proportion of
                                 false negatives.
    TRUE NEGATIVES             = Compute the proportion of
                                 true negatives.
    TRUE POSITIVES             = Compute the proportion of
                                 true positives.
    TEST SENSITIVITY           = Compute the test sensitivity.
    TEST SPECIFICITY           = Compute the test specificity.
    ODDS RATIO                 = Compute the bias corrected
                                 log(odds ratio).
    ODDS RATIO STANDARD ERROR  = Compute the standard error of the
                                 bias corrected log(odds ratio).
    RELATIVE RISK              = Compute the relative risk.
    TABULATE                   = Compute a statistic for data with
                                 a single grouping variable.
    CROSS TABULATE             = Compute a statistic for data with
                                 two grouping variables.
    STATISTIC PLOT             = Generate a plot of a statistic for
                                 data with a single grouping
                                 variable.
    CROSS TABULATE PLOT        = Generate a plot of a statistic for
                                 data with two grouping variables.
    BOOTSTRAP PLOT             = Generate a bootstrap plot for a
                                 given statistic.
 
Reference:
    Fleiss, Levin, and Paik (2003), "Statistical Methods for
    Rates and Proportions", Third Edition, Wiley, chapter 1.
 
Applications:
    Categorical Data Analysis
 
Implementation Date:
    2007/4
 
Program:
    let n = 1
    .
    let p = 0.2
    let y1 = binomial rand numb for i = 1 1 100
    let p = 0.1
    let y2 = binomial rand numb for i = 1 1 100
    .
    let p = 0.4
    let y1 = binomial rand numb for i = 101 1 200
    let p = 0.08
    let y2 = binomial rand numb for i = 101 1 200
    .
    let p = 0.15
    let y1 = binomial rand numb for i = 201 1 300
    let p = 0.18
    let y2 = binomial rand numb for i = 201 1 300
    .
    let p = 0.6
    let y1 = binomial rand numb for i = 301 1 400
    let p = 0.45
    let y2 = binomial rand numb for i = 301 1 400
    .
    let p = 0.3
    let y1 = binomial rand numb for i = 401 1 500
    let p = 0.1
    let y2 = binomial rand numb for i = 401 1 500
    .
    let x = sequence 1 100 1 5
    .
    let a = false positives y1 y2 subset x = 1
    tabulate false positives y1 y2 x
    .
    label case asis
    xlimits 1 5
    major xtic mark number 5
    minor xtic mark number 0
    xtic mark offset 0.5 0.5
    ytic mark offset 0.05 0.05
    y1label Proportion of False Positives
    x1label Group ID
    character x blank
    line blank solid
    .
    false positives plot y1 y2 x
 
-----FATAL ERROR (SET)--------------------------------------------
 
FATAL ERROR
 
Name:
    FATAL ERROR (SET)
    WARNING ERROR (SET)
 
Type:
    Set Subcommand
 
Purpose:
    Specify the action to take when an error is encountered.
 
Description:
    By default, Dataplot simply continues to the next command when an
    error is returned from a Dataplot command.

    You can change the default behaviour with the SET FATAL ERROR command.
    Specifically, you can tell Dataplot to exit when an error is returned
    or you can have Dataplot prompt you for what action to take.

    This command can be helpful when debugging Dataplot macros by allowing
    you to determine where errors are occuring.  This is typically not an
    issue when running Dataplot interactively or running short macros.
    However, it can be helpful with longer more complicated macros.
 
Syntax 1:
    SET FATAL ERROR <IGNORE/PROMPT/TERMINATE>

    Specifying TERMINATE means that Dataplot will exit if an error is
    encountered on a subsequent Dataplot command.  Specifying PROMPT
    means that Dataplot will prompt whether you want to continue or
    exit Dataplot if an error is encountered on a subsequent Dataplot
    command.  Specifying IGNORE resets the default Dataplot behaviour of
    simply continuing to the next command.

    Any argument other than PROMPT or TERMINATE will be treated as
    equivalent to IGNORE (for example, SET FATAL ERROR DEFAULT).
 
Syntax 2:
    SET WARNING ERROR <IGNORE/PROMPT/TERMINATE>

    This has the same actions as for the SET FATAL ERROR in Syntax 1.

    Currently, this option has no effect as there is currently no
    distinction between fatal and warning errors.  However, this option
    is being reserved for future use in that this distinction may
    be implemented in subsequent implementations of Dataplot.

Examples:
    SET FATAL ERROR PROMPT
    SET FATAL ERROR TERMINATE
    SET FATAL ERROR IGNORE
 
Note:
    Using the following commands can also be helpful when debugging macros.

       ECHO ON
       CAPTURE SCREEN ON
       CAPTURE JUNK.OUT

    The ECHO command encloses entered commands in a box of asterisks.
    The CAPTURE command directs the output from Dataplot commands to an
    external file.  The CAPTURE SCREEN ON specifies that the output will
    be written to both the screen and the external file when the CAPTURE
    command is in effect.
 
Note:
    If an error is encountered while running a macro and this setting is
    PROMPT, then Dataplot will print a traceback of the macros that have
    been called.  This can be useful for nested macros (i.e., macros
    called from within other macros).

Default:
    IGNORE is the default.
 
Synonyms:
    EXIT, STOP, HALT, and QUIT are synonyms for TERMINATE
 
Related Commands:
    ECHO      = Enclose entered Dataplot commands in a box of asterisks.
    CAPTURE   = Direct Dataplot output to an external file.
 
Applications:
    Debugging Macros
 
Implementation Date:
    2007/04
    2014/03: Added support for traceback of macros in PROMPT mode
 
Program 1:
    echo on
    set fatal error prompt
    capture screen on
    capture error.out
    .
    plot y
    lowess y
    .
    call error2.dp
    .
    frequency plot y
    .
    end of capture
 
Program 2:
    . This is the "error2.dp" macros called in Program 1 above.
    .
    histogram y

-----F TEST----------------------------------------------------------
 
F TEST
 
Name:
    F TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform a two sample F test that the ratio of two standard deviations
    is equal to 1 (i.e., the standard deviations are equal).
 
Description:
    This F test can be either an upper tailed test or a two-sided test.

    The two-sided hypothesis test is:
       H0: sigma1/sigma2 = 1
       Ha: sigma1/sigma2 <> 1
       Test Statistic: F = s1**2/s2**2
                       with s1 and s2 denoting the sample standard
                       deviations
       Alpha: Typically set to .05
       Critical Region: F < f(alpha/2)(v1,v2) or
                        F > f(1-alpha/2)(v1,v2)
                        and where the critical region is determined from
                        the F distribution function with (N1-1) and (N2-1)
                        degrees of freedom
       Conclusion: Reject the null hypothesis if F in critical region
 
    Note that for the upper tailed test, the larger of s1 and s2 is
    in the numerator and the smaller is in the denominator of the test
    statistic.

    The upper tailed hypothesis test is:
       H0: max(sigma1,sigma2)/min(sigma1,sigma2) = 1
       Ha: max(sigma1,sigma2)/min(sigma1,sigma2) > 1
       Test Statistic: F = max(s1,s2)**2/min(s1,s2)**2
                       with s1 and s2 denoting the sample standard
                       deviations
       Alpha: Typically set to .05
       Critical Region: F > f(1-alpha,v1,v2)
                        where the critical region is determined from the
                        F distribution function with (N1-1) and (N2-1)
                        degrees of freedom
       Conclusion: Reject null hypothesis if F in critical region
 
    To specify the upper tailed test (the default), enter

        SET F TEST TYPE UPPER TAILED

    To specify the two-tailed test, enter
 
        SET F TEST TYPE TWO SIDED

    The test conclusions are given for several values of alpha.

    Note that the F test is known to be quite senstive to departures
    from normality.  There have been several proposals in the literature
    to make this test more robust.  This is discussed further in the
    "Note:" section below.

Syntax 1:
    F TEST  <y1>  <y2>   <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    F TEST  <y1>  ... <yk>   <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of two or more response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax performs all the two-way F tests for the listed
    variables.  This syntax supports the TO syntax.

Examples:
    F TEST Y1  Y2
    F TEST Y1  Y2 Y3
    F TEST Y1  TO Y10
    F TEST Y1  Y2  SUBSET Y2 > 0
 
    SET F TEST TYPE TWO SIDED
    F TEST Y1  Y2
 
    SET F TEST TYPE UPPER TAILED
    F TEST Y1  Y2

Note:
    The F test is known to be quite sensitive to departures from
    normality.

    Shoemaker (2003) proposed the following adjustment to the degrees
    of freedom to make the F test more robust against non-normality.
 
    The degrees of freedom are

        r(i) = 2*n(i)/[(mu4/sigma**4) - (n(i)-3)/(n(i)-1)]

    where

        mu4 = SUM[i=1 to 2][SUM[j=1 to n(i)]
                 [[(Y(ij) - YBAR(i))**4]]/(n1+n2)

        sigma**2 = {(n1-1)*s1**2 + (n2-1)**s2**2}/(n1+n2)

    with Y(.j), n(i), s(i) and YBAR(i) denoting the data, the sample size,
    the standard deviation and the mean, respectively, of the i-th
    variable.

    This typically results in fractional degrees of freedom.  The
    Dataplot FCDF, FPDF and FPPF routines were updated to support
    fractional degrees of freedom (fractional degrees of freedom less
    than 1 are set to 1).

    The justification and derivation of this modification is given in
    Shoemaker's paper.  Simulations by Shoemaker indicated that the
    standard F test tends to be too conservative for light tailed
    distributions and too liberal for heavy tailed and skewed
    distributions.  Using the Shoemaker modifications for degrees of
    freedom generally had good coverage properties with the exception
    of heavily skewed distributions with small samples where it was
    still too liberal.

    Bonett (2006) suggested that rounding the numerator degrees of
    freedom up to the nearest integer degrees of freedom and rounding
    the denominator degrees of freedom down to the nearest integer
    degrees of freedom (but not less than 1) prevented some anomalous
    behavior while reducing coverage performance only slightly.

    Bonett proposed the following statistic:

        EXP[LN(c*s1**2/s2**2)/se]

    where

        ak4     = (n1+n2)*SUM[i=1,2]SUM[j=1,n(i)][(Y(ij) - m(i)]/
                  {SUM[i=1,2]SUM[j=1,n(i)][(Y(ij) - ybar(i)**2)]}**2

        m(i)    = sample trimmed mean of the i-th variable with trimming
                  proportion 1/SQRT(2*(n(i) - 4))
        ybar(i) = sample mean of the i-th variable

        se      = SQRT{(ak4-k1)/(n1-1) + (ak4-k2)/(n2-1)}
        k1      = (n1-3)/n1
        k2      = (n2-3)/n2

        c       = {n1*(1-NORPPF(alpha/2)}/{n2*(n2-NORPPF(alpha/2))}
        NORPPF  = the percent point function of the normal distribution

    The parameter c is a small sample adjustment to help equalize the
    tail probabilities.  It equals 1 when n1 and n2 equal and
    approaches 1 as n1 and n2 get large.  For unequal sample sizes,
    the value of the test statistic will vary slightly depending on
    the value of alpha.

    The above formula is for the variance.  For the standard
    deviation, take the square root.

    This test statistic is compared to a standard normal distribution.

    The justification and derivation of this test is given in the
    Bonett paper.  Based on his simulations, he claims this method
    improves somewhat on the Shoemaker modification for heavy-tailed
    (particularly skewed) distributions.

    To specify Shoemaker's modification with fractional degrees
    of freedom, enter

         SET F TEST DEGREES OF FREEDOM SHOEMAKER

    To specify Shoemaker's modification with integral degrees
    of freedom as suggested by Bonett, enter

         SET F TEST DEGREES OF FREEDOM SHOEMAKER ROUNDED

    To specify Bonett's method, enter

         SET F TEST DEGREES OF FREEDOM BONETT

Note:
    Shoemaker suggests that when more than two groups of data are
    available, it can improve accuracy to use all of the groups
    in the estimates of the pooled location (mu4) and pooled variance
    (sigma**2) instead of just the two groups being tested.  That is,

        mu4 = SUM[i=1 to k][SUM[j=1 to n(i)]
                 [[(Y(ij) - YBAR(i))**4]]/(n1+n2+ ... + nk)

        sigma**2 = {(n1-1)*s1**2 + (n2-1)**s2**2 + ... + (nk-1)*sk**2}/
                   (n1+n2+ ... +nk)

    To use these values, enter the commands

         SET SHOEMAKER F TEST POOLED MU       <value>
         SET SHOEMAKER F TEST POOLED VARIANCE <value>

    To reset the default of Dataplot computing these from the two groups
    being tested, enter

         SET SHOEMAKER F TEST POOLED MU
         SET SHOEMAKER F TEST POOLED VARIANCE 0

Note:
    The following parameters are saved after the F test is
    performed.

         STATVAL   - value of the test statistic
         STATCDF   - CDF of the test statistic
         PVALUE    - p-value of the test statistic
         STATNU1   - degrees of the freedom of the numerator variable
         STATNU2   - degrees of the freedom of the denominator variable
         POOLSD    - pooled standard deviation

    For an upper tailed test, the following parameters are saved

         CUTUPP50  - upper critical value for 50% test
         CUTUPP75  - upper critical value for 50% test
         CUTUPP90  - upper critical value for 90% test
         CUTUPP95  - upper critical value for 95% test
         CUTUPP99  - upper critical value for 99% test
         CUTUP999  - upper critical value for 99.9% test

    For a two sided test, the following parameters are saved

         CUTLOW80  - lower critical value for 80% test
         CUTUPP80  - upper critical value for 80% test
         CUTLOW90  - lower critical value for 90% test
         CUTUPP90  - upper critical value for 90% test
         CUTUPP90  - upper critical value for 90% test
         CUTLOW95  - lower critical value for 95% test
         CUTUPP95  - upper critical value for 95% test
         CUTLOW99  - lower critical value for 99% test
         CUTUPP99  - upper critical value for 99% test
         CUTLW999  - lower critical value for 99.9% test
         CUTUP999  - upper critical value for 99.9% test

    If the Bonett method is specified, a two sided interval will
    always be used.  Also, STATNU1, STATNU2 and POOLSD will not be
    saved.

Note:
    In addition to the F TEST command, the following commands can
    also be used:

        LET STATVAL = F TEST        Y1 Y2
        LET STATCDF = F TEST CDF    Y1 Y2
        LET PVALUE  = F TEST PVALUE Y1 Y2

    In addition to the above LET commands, built-in statistics are
    supported for 20+ different commands (enter HELP STATISTICS for
    details).

Note:
    The RATIO OR STANDARD DEVIATIONS CONFIDENCE LIMITS can be used to
    generate the corresponding confidence limits.
 
Default:
    An upper tailed test without the Shoemaker or Bonett modifications
    is performed.
 
Synonyms:
    None
 
Related Commands:
    SIEGEL TUKEY TEST              = Perform a ranks based test that two
                                     standard deviations are equal.
    BARTLETTS TEST                 = Perform a k-sample Bartlett test for
                                     homogeneous variances.
    LEVENE TEST                    = Perform a k-sample Levene test for
                                     homogeneous variances.
    SQUARED RANKS TEST             = Perform a k-sample squared ranks test
                                     for homogeneous variances.
    KLOTZ TEST                     = Perform a k-sample Klotz test
                                     for homogeneous variances.
    RATIO OF SD CONFIDENCE LIMITS  = Compute the confidence limtis for the
                                     ratio of two standard deviations.
    SD CONFIDENCE LIMITS           = Compute the confidence limits for the
                                     standard deviation.
    CHI-SQUARE TEST                = Performs a one sample chi-square test
                                     that the standard deviation is equal
                                     to a given value.
    T TEST                         = Performs a two-sample t test for
                                     equal means.
    CONFIDENCE LIMITS              = Compute the confidence limits for the
                                     mean of a sample.
    STANDARD DEVIATION             = Computes the standard deviation of a
                                     variable.
 
Reference:
    F tests are discussed in most introductory statistics books.

    Shoemaker (2003), "Fixing the F-Test for Equal Variances," The American
    Statistician, Vol. 57, pp. 105-114.

    Bonett (2006), "Robust Confidence Intervals for a Ratio of Standard
    Deviations," Applied Pyschological Measurement, Vol. 30, No. 5,
    pp. 432-439.

Applications:
    Confirmatory Data Analysis
 
Implementation Date:
    1994/02
    2023/06: Added support for Shoemaker and Bonett modifications
    2023/06: Added support for two sided tests
 
Program 1:
    SKIP 25
    READ AUTO83B.DAT Y1 Y2
    DELETE Y2 SUBSET Y2 < 0
    .
    F TEST Y1 Y2
     
Program 2:
    . Step 1:   Read the data
    .
    skip 25
    read shoemake.dat bottom mid surface
    let y x = stack bottom mid surface
    let temp1 = cross tabulate mean y x
    let temp2 = (y - temp1)**4
    let num = sum temp2
    let den = size y
    let mu4 = num/den
    let y1var = variance bottom
    let y2var = variance mid
    let y3var = variance surface
    let n1 = size bottom
    let n2 = size mid
    let n3 = size surface
    let num   = (n1 - 1)*y1var + (n2 -1)*y2var + (n3 - 1)*y3var
    let poolvar = num/den
    .
    . Step 2:   Generate a box plot
    .
    character box plot
    line box plot
    xlimits 1 3
    major xtic mark number 3
    minor xtic mark number 0
    xtic mark offset 0.5 0.5
    x1tic mark label format alpha
    x1tic mark label content Bottom Middepth Surface
    tic mark label case asis
    set box plot fences on
    box plot y x
    .
    . Step 3:   Default F-test
    .
    set f test degrees of freedom default
    print "Standard F Test"
    f test bottom mid
    let statval = f test        bottom mid
    let statcdf = f test cdf    bottom mid
    let pvalue  = f test pvalue bottom mid
    print statval statcdf pvalue
    .
    . Step 4:   Shoemaker F-test
    .
    set f test degrees of freedom shoemaker
    print "Shoemaker degrees of freedom F Test"
    f test bottom mid
    print "Use pooled location and variance for Shoemaker"
    set shoemaker f test pooled variance poolvar
    set shoemaker f test pooled mu       mu4
    f test bottom mid
    print "Shoemaker rounded degrees of freedom F Test"
    set f test degrees of freedom shoemaker rounded
    f test bottom mid
    set shoemaker f test pooled variance 0
    set shoemaker f test pooled mu
    .
    . Step 5:   Bonett
    .
    set f test degrees of freedom bonett
    print "Bonett method"
    f test bottom mid

-----FCACDF (LET)--------------------------------
 
FCACDF
 
Name:
    FCACDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard folded Cauchy cumulative distribution
    function.
 
Description:
    If X is Cauchy distributed, then ABS(X) has a folded Cauchy
    distribution.

    The folded Cauchy cumulative distribution can be expressed
    in terms of the standard cumulative Cauchy distribution as:
       F(x,mu,sigma) = CAUCDF((x-mu)/sigma) - CAUCDF((-x-mu)/sigma)
                       x >= 0
    where CAUCDF is the cumulative distribution function of a
    standard Cauchy distribution and mu and sigma are the location
    and scale parameters of the parent Cauhy distribution.  They are
    shape parameters for the folded Cauchy distribution.  If mu
    is zero, the folded Cauchy distribution reduces to a
    half-Cauchy distribution.
 
Syntax:
    LET <y> = FCACDF(<x>,<u>,<s>)   <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed folded Cauchy cdf value is stored;
          <u> is a number, parameter, or variable that defines the
               location parameter of the parent Cauchy distribution;
          <s> is a number, parameter, or variable that defines the
               scale parameter of the parent Cauchy distribution;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = FCACDF(3,2,0.7)
    LET X2 = FCACDF(X1,U,SD)
 
Note:
    The folded Cauchy distribution is typically used when
    measurements are taken without regard to sign and the
    underlying distribution is assumed to be Cauchy.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FCAPDF = Compute the folded Cauchy probability density
             function.
    FCAPPF = Compute the folded Cauchy percent point function.
    HCAPDF = Compute the half Cauchy probability density function.
    CAUCDF = Compute the Cauchy cumulative distribution function.
    CAUPDF = Compute the Cauchy probability density function.
    CAUPPF = Compute the Cauchy percent point function.
    FNRPDF = Compute the folded normal probability density function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    1996/1
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LET U = 0.5
    LET SD = 6
    X1LABEL U = ^U, SD = ^SD
    PLOT FCACDF(X,U,SD) FOR X = 0  0.01 20
    LET U = 6
    LET SD = 0.5
    X1LABEL U = ^U, SD = ^SD
    PLOT FCACDF(X,U,SD) FOR X = 0  0.01 8
    LET U = 2
    LET SD = 10
    X1LABEL U = ^U, SD = ^SD
    PLOT FCACDF(X,U,SD) FOR X = 0  0.01 50
    LET U = 3
    LET SD = 2
    X1LABEL U = ^U, SD = ^SD
    PLOT FCACDF(X,U,SD) FOR X = 0  0.01 10
    END OF MULTIPLOT

-----FCAPDF (LET)--------------------------------
 
FCAPDF
 
Name:
    FCAPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard folded Cauchy probability density
    function.
 
Description:
    If X is Cauchy distributed, then ABS(X) has a folded Cauchy
    distribution.  The folded Cauchy distribution can be expressed
    in terms of the standard Cauchy distribution as:
       f(x,mu,sigma) = (1/sigma)*(CAUPDF((x-mu)/sigma) +
                       CAUPDF((x+mu)/sigma))       x >= 0
    where CAUPDF is the probability density function of a standard
    Cauchy distribution and mu and sigma are the location and
    scale parameters of the parent Cauhy distribution.  They are
    shape parameters for the folded Cauchy distribution.  If mu
    is zero, the folded Cauchy distribution reduces to a
    half-Cauchy distribution.
 
Syntax:
    LET <y> = FCAPDF(<x>,<u>,<s>)   <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed folded Cauchy pdf value is stored;
          <u> is a number, parameter, or variable that defines the
               location parameter of the parent Cauchy distribution;
          <s> is a number, parameter, or variable that defines the
               scale parameter of the parent Cauchy distribution;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = FCAPDF(3,2,0.7)
    LET X2 = FCAPDF(X1,U,SD)
 
Note:
    The folded Cauchy distribution is typically used when
    measurements are taken without regard to sign and the
    underlying distribution is assumed to be Cauchy.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FCACDF = Compute the folded Cauchy cumulative distribution
             function.
    FCAPPF = Compute the folded Cauchy percent point function.
    HCAPDF = Compute the half Cauchy probability density function.
    CAUCDF = Compute the Cauchy cumulative distribution function.
    CAUPDF = Compute the Cauchy probability density function.
    CAUPPF = Compute the Cauchy percent point function.
    FNRPDF = Compute the folded normal probability density function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    1996/1
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LET U = 0.5
    LET SD = 6
    X1LABEL U = ^U, SD = ^SD
    PLOT FCAPDF(X,U,SD) FOR X = 0  0.01 20
    LET U = 6
    LET SD = 0.5
    X1LABEL U = ^U, SD = ^SD
    PLOT FCAPDF(X,U,SD) FOR X = 0  0.01 8
    LET U = 2
    LET SD = 10
    X1LABEL U = ^U, SD = ^SD
    PLOT FCAPDF(X,U,SD) FOR X = 0  0.01 50
    LET U = 3
    LET SD = 2
    X1LABEL U = ^U, SD = ^SD
    PLOT FCAPDF(X,U,SD) FOR X = 0  0.01 10
    END OF MULTIPLOT

-----FCAPPF (LET)--------------------------------
 
FCAPPF
 
Name:
    FCAPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard folded Cauchy percent point function.
 
Description:
    If X is Cauchy distributed, then ABS(X) has a folded Cauchy
    distribution.

    The folded Cauchy percent point function is computed
    numerically using a bisection method.
 
Syntax:
    LET <y> = FCAPPF(<p>,<u>,<s>)   <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <p> is)
               where the computed folded Cauchy pdf value is stored;
          <u> is a number, parameter, or variable that defines the
               location parameter of the parent Cauchy distribution;
          <s> is a number, parameter, or variable that defines the
               scale parameter of the parent Cauchy distribution;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = FCAPPF(0.95,2,0.7)
    LET X2 = FCAPPF(P,U,SD)
 
Note:
    The folded Cauchy distribution is typically used when
    measurements are taken without regard to sign and the
    underlying distribution is assumed to be Cauchy.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FCACDF = Compute the folded Cauchy cumulative distribution
             function.
    FCAPDF = Compute the folded Cauchy probability density function.
    HCAPDF = Compute the half Cauchy probability density function.
    CAUCDF = Compute the Cauchy cumulative distribution function.
    CAUPDF = Compute the Cauchy probability density function.
    CAUPPF = Compute the Cauchy percent point function.
    FNRPDF = Compute the folded normal probability density function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    1996/1
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LET U = 0.5
    LET SD = 6
    X1LABEL U = ^U, SD = ^SD
    PLOT FCAPPF(P,U,SD) FOR P = 0  0.01 0.99
    LET U = 6
    LET SD = 0.5
    X1LABEL U = ^U, SD = ^SD
    PLOT FCAPPF(P,U,SD) FOR P = 0  0.01 0.99
    LET U = 2
    LET SD = 10
    X1LABEL U = ^U, SD = ^SD
    PLOT FCAPPF(P,U,SD) FOR P = 0  0.01 0.99
    LET U = 3
    LET SD = 2
    X1LABEL U = ^U, SD = ^SD
    PLOT FCAPPF(P,U,SD) FOR P = 0  0.01 0.99
    END OF MULTIPLOT

-----FCDF (LET)--------------------------------
 
FCDF
 
Name:
    FCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the F cumulative distribution function with degrees of
    freedom parameters NU1 and NU2.
 
Description:
    The F distribution is the ratio of 2 chi-square distributions:
          F = (U/NU1)/(V/NU2)
    where U and V are 2 independent chi-square distributions with NU1
    and NU2 degrees of freedom respectively.  The cumulative
    distribution is the area from 0 to x.  Since this is a probability
    function, the returned value will be between 0 and 1.
 
    The input value should be greater than 0 and the degrees of freedom
    should be positive integers.
 
Syntax:
    LET <y2> = FPDF(<y1>,NU1,NU2)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter containing positive values;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed F cdf value is stored;
          <NU1> and <NU2> are positive integer numbers or parameters
               that define the degrees of freedom;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = FCDF(3,10,8)
    LET A = FCDF(A1,10,8)
    LET X2 = FCDF(X1,10,8)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHSPDF = Compute chi-square probability density function.
    CHSPPF = Compute chi-square percent point function.
    CHSCDF = Compute chi-square cumulative distribution function.
    FCDF   = Compute F cumulative distribution function.
    FPDF   = Compute F probability density function.
    FPPF   = Compute F percent point function.
    NORCDF = Compute normal cumulative distribution function.
    NORPDF = Compute normal probability density function.
    NORPPF = Compute normal percent point function.
    TCDF   = Compute T cumulative distribution function.
    TPDF   = Compute T probability density function.
    TPPF   = Compute T percent point function.
    WEICDF = Compute Weibull cumulative distribution function.
    WEIPDF = Compute Weibull probability density function.
    WEIPPF = Compute Weibull percent point function.
    WALPDF = Compute the Wald probability density function.
    WALPPF = Compute the Wald percent point function.
    WALCDF = Compute the Wald cumulative distribution function.
    FLPDF  = Compute the Fatigue Life probability density function.
    FLPPF  = Compute the Fatigue Life percent point function.
    FLCDF  = Compute the Fatigue Life cumulative distribution function.
    IGPDF  = Compute the Inverse Gaussian probability density function.
    IGPPF  = Compute the Inverse Gaussian percent point function.
    IGCDF  = Compute the Inverse Gaussian cumulative distribution
             function.
    RIGPDF = Compute the Reciprocal Inverse Gaussian probability
             density function.
    RIGPPF = Compute the Reciprocal Inverse Gaussian percent point
             function.
    RIGCDF = Compute the Reciprocal Inverse Gaussian cumulative
             distribution function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, 1970.
 
Applications:
    XX
 
Implementation Date:
    XX.X
 
Program:
    TITLE PLOT FCDF FOR VARIOUS VALUES OF NU
    SEGMENT 1 COORDINATES 64 38 69 38; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 64 34 69 34; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 64 30 69 30; SEGMENT 3 PATTERN DOT
    SEGMENT 4 COORDINATES 64 26 69 26; SEGMENT 4 PATTERN DASH2
    LEGEND 1 NU1 = 5, NU2 = 5
    LEGEND 1 COORDINATES 70 37
    LEGEND 2 NU1 = 5, NU2 = 10
    LEGEND 2 COORDINATES 70 33
    LEGEND 3 NU1 = 10, NU2 = 5
    LEGEND 3 COORDINATES 70 29
    LEGEND 4 NU1 = 10, NU2 = 10
    LEGEND 4 COORDINATES 70 25
    YLIMITS 0 1; MAJOR YTIC NUMBER 6
    MINOR YTIC NUMBER 1; YTIC DECIMAL 1
    XLIMITS 0 5; XTIC OFFSET 0.5 1
    MAJOR XTIC NUMBER 6; MINOR XTIC NUMBER 1
    LINES SOLID DASH DOT DASH2
    PLOT FCDF(X,5,5) FOR X = 0 .1 6 AND
    PLOT FCDF(X,5,10) FOR X = 0 .1 6 AND
    PLOT FCDF(X,10,5) FOR X = 0 .1 6 AND
    PLOT FCDF(X,10,10) FOR X = 0 .1 6
 
-----FEEDBACK-------------------------------------------------------
 
FEEDBACK
 
Name:
    FEEDBACK
 
Type:
    Support Command
 
Purpose:
    Specifies whether or not the usual feedback messages that are
    generated by most DATAPLOT commands and by SUBSET/EXCEPT/FOR
    qualifications should be printed or suppressed.
 
Syntax:
    FEEDBACK   <ON or OFF>
    where ON specifies that feedback messages are printed while OFF
    specifies that they are suppressed.
 
Examples:
    FEEDBACK ON
    FEEDBACK OFF
    FEEDBACK
 
Note:
    The FEEDBACK command with no arguments is equivalent to
    FEEDBACK ON.
 
Note:
    A SAVE/RESTORE option was added.  FEEDBACK SAVE will save
    the current setting of the FEEDBACK switch.  A subsequent
    FEEDBACK RESTORE will then restore the saved value.

    This option is intended primarily for general purpose macros.
    This option allows the macro to toggle the FEEDBACK switch as
    desired within the macro and then restoring the value in effect
    when the user called the macro.

Default:
    The default is for feedback messages to be printed.
 
Synonyms:
    None
 
Related Commands:
    ECHO         = Allows or suppresses command echoing.
    PRINTING     = Allows or suppresses analysis output.
    PROMPT       = Allows or suppresses the prompt character.
    SET          = Sets the value of an internal variable (e.g., IPR).
    PROBE        = Displays the value of an internal variable (e.g.,
                   IPR).
 
Applications:
    XX
 
Implementation Date:
    Pre-1987
    2009/1: Added the SAVE/RESTORE option
 
Program:
    XX
 
-----FENCE-------------------------------------------------------
 
FENCE
 
Name:
    FENCE
 
Type:
    Support Command
 
Purpose:
    Specify the fences switch for box plots.
 
Description:
    If this switch is ON, outliers are drawn as circles (small circles
    for near outliers, large circles for far outliers).  If IQ is the
    interquartile range, near outliers are defined as points between
    median +/- 1.5*IQ and M +/- 3.0*IQ.  Far outliers are defined as
    points greater 3.0*IQ from the median.   If this switch is OFF,
    individual points are not identified (a line is drawn from the
    quartile to the minimum and maximum points).
 
Syntax:
    FENCE    <ON/OFF>
    where ON specifies that outliers are drawn as circles while OFF
    specifies that a lines are drawn from the quartiles to the minimum
    and maximum points.
 
Examples:
    FENCE ON
    FENCE OFF
 
Note:
    The outliers are defined by CHARACTER and LINE traces 21 through
    24.  This is relevant if you wish to define the attributes of these
    points (e.g., drawing filled circles, changing the size of the
    circles, using a different character).
 
Default:
    OFF
 
Synonyms:
    None
 
Related Commands:
    BOX PLOT      = Generates a box plot.
 
Applications:
    Data Analysis
 
Implementation Date:
    Pre-1987
 
Program:
    XX
 
-----FERMDIRA (LET)--------------------------------
 
FERMDIRA
 
Name:
    FERMDIRA (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Fermi-Dirac function for orders -0.5, 0.5, 1.5,
    and 2.5.
 
Description:
    The Fermi-Dirac function of order -0.5 is defined as:

                      Int{0 to inf} t**(-1/2) / (1+exp(t-x)) dt
          FDM0P5(x) = -----------------------------------------
                                  Gamma(1/2)

    The Fermi-Dirac function of order 0.5 is defined as:

                      Int{0 to inf} t**(1/2) / (1+exp(t-x)) dt
          FDP0P5(x) = -----------------------------------------
                                  Gamma(3/2)

    The Fermi-Dirac function of order 1.5 is defined as:

                      Int{0 to inf} t**(3/2) / (1+exp(t-x)) dt
          FDP1P5(x) = -----------------------------------------
                                  Gamma(5/2)

    The Fermi-Dirac function of order 2.5 is defined as:

                      Int{0 to inf} t**(5/2) / (1+exp(t-x)) dt
          FDP2P5(x) = -----------------------------------------
                                  Gamma(7/2)

    where Gamma is the gamma function.

    If the specified order is within 0.1 of one of the supported
    orders, Dataplot will use the supported order.  Otherwise,
    it returns an error message.

    Dataplot computes this function using ACM Algorithm 779 (see
    Reference: below).  Specifically, it uses the routines FDM0P5,
    FDP0P5, FDP1P5, and FDP2P5.
 
Syntax:
    LET <y> = FERMDIRA(<x>,<ord>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative number, variable or parameter;
          <ord> is a non-negative integer number, parameter, or
               variable containing one of -0.5, 0.5, 1.5, or 2.5;
          <y> is a variable or a parameter (depending on what <x> 
               and <ord> are) where the computed Fermi-Dirac function
               values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = FERMDIRA(2.3,1.5)
    LET A = FERMDIRA(X,A1)
    LET X2 = FERMDIRA(X1,0.5) FOR X1 = -20 0.01 20
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ABRAM      = Compute the Abramowitz integral.
    CLAUSN     = Compute the Clausen integral.
    DEBYE      = Compute the Debye function.
    EXP3       = Compute the cubic exponential integral.
    GOODST     = Compute the Goodwin and Stanton integral.
    LOBACH     = Compute the Lobachevski integral.
    SYNCH1     = Compute the synchrotron radiation function.
    SYNCH2     = Compute the synchrotron radiation function.
    STROM      = Compute the Stromgren integral.
    TRAN       = Compute the transport integral.
 
Reference:
    "ACM Transactions of Mathematical Software", Allan MacLead,
    Vol. 24, No. 1, March, 1998.
 
Applications:
    Special Functions
 
Implementation Date:
    2002/5
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT SCALE FACTOR 2
    LET ORDER = -0.5
    TITLE ORDER = ^ORDER
    PLOT FERMDIRA(X,ORDER) FOR X = -50 0.1 50
    LET ORDER = 0.5
    TITLE ORDER = ^ORDER
    PLOT FERMDIRA(X,ORDER) FOR X = -50 0.1 50
    LET ORDER = 1.5
    TITLE ORDER = ^ORDER
    PLOT FERMDIRA(X,ORDER) FOR X = -50 0.1 50
    LET ORDER = 2.5
    TITLE ORDER = ^ORDER
    PLOT FERMDIRA(X,ORDER) FOR X = -50 0.1 50
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT FERMI-DIRAC FUNCTIONS
 
-----FFT (LET)---------------------------------------------------
 
FFT
 
Name:
    FFT (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the fast Fourier transform of a variable.
 
Description:
    The Fourier transform converts a time domain function into a
    frequency domain function while the inverse Fourier transform
    converts a frequency domain function into a time domain function.
 
    If h(t) represents the function in the time domain while H(f)
    represents the function in the frequency domain, then the
    definitions of the Fourier transform and the inverse Fourier
    transformation respectively are:
        H(f) = integral[h(t)exp(2*PI*i*f*t)]dt
        h(t) = integral[H(f)exp(-2*PI*i*f*t)]df
    where the integral goes from minus infinity to plus infinity.  An
    alternate (mathematically equivalent) formulation specifies these
    transformations in terms of the angular frequency(radians per
    second) w, where w = 2*PI*f.  The equations then become:
        H(w) = integral[h(t)exp(i*w*t)]dt
        h(t) = (1/(2*PI))*integral[H(w)exp(-i*w*t)]dw
 
    In practice, functions are sampled at equally spaced discrete
    points.  The discrete Fourier transform and the discrete inverse
    Fourier transforms respectively are:
        H(n) = SUM(k=0 to N-1) [h(k)exp(2*PI*i*k*n/N)]
        h(k) = (1/N)*SUM(n=0 to N-1) [H(n)*exp(-2*PI*i*k*n/N]
    where k represents the sampled points in the time domain, lower
    case n represents the sampled points in the frequency domain, and
    N is the number of sampled points.
 
    DATAPLOT calculates the discrete Fourier and inverse Fourier
    transforms.  If you wish to calculate these transforms for a
    function, then evaluate this function at a series of points.  This
    can be accomplished with something like the following:
       LET FUNCTION F = <define the function in terms of X1>
       LET X1 = SEQUENCE 0 0.5 40
       LET Y1 = F
       LET R2 C2 = FOURIER TRANSFORM Y1
 
    See the REFERENCE section below for references which give a more
    detailed explanation of Fourier transforms.
 
    The fast Fourier and the inverse fast Fourier transforms are more
    computationally efficient ways to calculate the Fourier and inverse
    Fourier transforms.
 
Syntax:
    LET <r1> <c1> = FFT <y1>  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a response variable for which the FFT is to be
               computed;
          <r1> is a variable containing the real component of the
               calculated FFT;
          <c1> is a variable containing the complex component of the
               calculated FFT;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET RFFT CFFT = FFT Y1
 
Note:
    DATAPLOT uses the FOUR1 routine from the Numerical Recipes book
    to calculate the FFT.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    INVERSE FOUR TRANS = Compute the inverse Fourier transform.
    FOURIER TRANSFORM  = Compute the Fourier transform.
    INVERSE FFT        = Compute the inverse FFT.
    COSINE TRANS       = Compute the cosine transformation.
    SINE TRANS         = Compute the sine transformation.
    SPECTRAL PLOT      = Generate a spectral plot.
 
Reference:
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", Press, Flannery, Teukolsky, and Vetterling.  Cambridge
    University Press, 1989 (chapter 12).
 
    "Fourier Analysis of Time Series: An Introduction", Peter
    Bloomfield, John Wiley and Sons, 1976.
 
Applications:
    Frequency analysis of time series, signal processing
 
Implementation Date:
    87/5
 
Program:
    LEGEND 1 TIME SERIES SMOOTHING
    LEGEND 2 FFT PLOT (REAL & IMAG.)
    .
    LET X = SEQUENCE 0 .1 25.55
    LET YS = SIN(X)
    LET YN = NORMAL RANDOM NUMBERS FOR I = 1 1 256
    LET YN = YN/10
    LET Y = YS+YN
    .
    LET U V = FFT Y
    LET NU = NUMBER U
    LET XU = SEQUENCE 1 1 NU
    LET XU = XU+50
    LET XV = XU+350
    .
    LET U = 2.5*U
    PLOT U VS XU AND
    PLOT V VS XV
 
-----FIBONNACCI NUMBERS (LET)-----------------------------------------
 
FIBONNACCI NUMBERS
 
Name:
    FIBONNACCI NUMBERS (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Generate a sequence of Fibonnacci numbers.
 
Description:
    The Fibonacci sequence is defined by:
        Fib(i) = Fib(i-1) + Fib(i-2)     for i > 1
               = 1                       for i = 1
               = 0                       for i = 0
 
Syntax:
    LET <resp> = FIBONNACCI NUMBERS FOR I = <start> <inc> <stop>
    where <resp> is a variable where the Fibonnacci numbers are stored;
          <start>, <inc>, and <stop> identify the start, increment, and
              stop points of the Fibonnacci sequence.  The <start> and
              <inc> values are almost always 1.  If they are not, <resp>
              still contains <stop> elements, but the skipped elements
              contain zeros.
 
Examples:
    LET YFIB = FIBONNACCI NUMBERS FOR I = 1 1 100
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SEQUENCE       = Generate a sequence of numbers.
    PATTERN        = Generate numbers with a specific pattern.
    PRIME NUMBERS  = Generate prime numbers.
    DATA           = Place numbers in a variable.
 
Applications:
    Mathematics
 
Implementation Date:
    Pre-1987
 
Program:
    LET YFIB = FIBONNACCI NUMBERS FOR I = 1 1 20
    PRINT YFIB
 
-----FILE NAME QUOTE (SET)--------------------------------------------
 
FILE NAME QUOTE
 
Name:
    FILE NAME QUOTE (SET)
 
Type:
    Set Subcommand
 
Purpose:
    Specify whether or not file names may be enclosed in
    double quotes (").
 
Description:
    The READ, WRITE, CAPTURE, CALL/CREATE and LIST commands can
    accept file names as arguments.  Many current operating systems
    allow path and file names to contain embedded spaces.  In particular,
    Windows on the PC uses spaces in many common path names.  Typically,
    when Dataplot parses a file name, it treats the next space character
    as the end of the file name.  Enclosing the file name in quotes
    allows the file name to contain spaces.

    For the WRITE command, we can have something like

       WRITE   "   string to printed  "

    In this case, we do not want the quotes to be interpreted as
    enclosing a file name.  The SET FILE NAME QUOTE is used to address
    this ambiguity.  If the command

        SET FILE NAME QUOTE ON

    is given, then if the first character in the file name is a double
    quote, Dataplot treats all characters until the next double quote as
    the file name (the quotes are not part of the file name).

        SET FILE NAME QUOTE OFF

    is given, Dataplot treats any quotes as signifying the start of a
    literal string to be printed.

    The READ, CAPTURE, CALL/CREATE and LIST commands do not have this
    ambiguity.  For these commands, the value for SET FILE NAME QUOTE
    is automatically set to ON.

    For the WRITE command, the default is OFF.  This is so that WRITE
    commands that contain quotes for literal strings will still work if
    the embedded string contains a "." (a period is the signifier that
    a string denotes a file name).

Syntax:
    SET FILE NAME QUOTE <ON/OFF>
    where <ON> specifies that file names may be embedded with
    quotes and <OFF> specifies that quotes do not delineate
    file names.
 
Examples:
    SET FILE NAME QUOTE ON
    SET FILE NAME QUOTE OFF

Note:
    Dataplot treats hyphens as delimiters as well.  So if the file name
    contains hyphens, you need to enclose it in quotes.

Default:
    This switch is OFF by default for the WRITE command.  The switch is
    automatically set to ON for READ, LIST, CALL/CREATE and CAPTURE
    commands.
 
Synonyms:
    None
 
Related Commands:
    READ          = Read data from a file.
    WRITE         = Write data to a file.
    CAPTURE       = Re-direct alphanumeric output to a file.
    LIST          = List the contents of a file.
    CALL          = Execute commands stored in a file.
 
Applications:
    Data Input/Output
 
Implementation Date:
    2002/07
    2003/08: The READ, CAPTURE, and LIST commands automatically set
             this switch to ON.
 
Program:
    SET FILE NAME QUOTE ON
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET Y2 = CAUCHY RANDOM NUMBERS FOR I = 1 1 100
    WRITE "C:\My Data\TEST.DAT"  Y1 Y2
    LIST "C:\My Data\TEST.DAT"
    READ "C:\My Data\TEST.DAT"  Z1 Z2
 
-----FILE SWITCHES (SET)--------------------------------------------
 
FILE SWITCHES
 
Name:
    FILE SWITCHES (SET)
 
Type:
    Set Subcommand
 
Purpose:
    Probe for values pertaining to Dataplot file names, unit numbers, and
    file status values.
 
Description:
    Dataplot utilizes a number of files.  In some cases, these files are
    previously created file names (e.g., the Dataplot help files, the file
    containing the sign-on message).  In other cases, these files are
    dynamically named during a Dataplot session (e.g., the files
    associated with READ, WRITE, or CALL commands).

    In addition to the file name, there is also a Fortran unit number
    associated with that file.  Fortran unit numbers are typically between
    1 and 99 (for Dataplot files, they typically are greater than or equal
    to 10).  Files also have a status value.  A status value of OLD is
    used for files that are expected to already exist (and are not
    modified by the user during a Dataplot session).  This would include
    the help files, the file containing the sign-on message, and several
    others.  A status value of UNKNOWN is used for files that can be
    modifed during a Dataplot session and that may not currently exist.
    An example would be the file associated with the READ command.

    Unit numbers are typically not changed and the file status is
    determined dynamically.  So these would typically only be used by the
    PROBE command (i.e., not by SET).  The SET command can be used to
    change the name of the plot files (IPL1NA, IPL2NA).  The SET command
    would not typically be used to change the name of the other files
    listed below.

    These setting are typically of interest to the Dataplot developers for
    debugging purposes.  However, they can be used by any Dataplot user.

    The list of available file name and unit number switches is

        IMESNU         - the Fortran unit number for the message file
        IMESST         - the current status of the message file
        IMESNA         - the name of the message file

        INEWNU         - the Fortran unit number for the news file
        INEWST         - the current status of the news file
        INEWNA         - the name of the news file

        IMAINU         - the Fortran unit number for the mail file
        IMAIST         - the current status of the mail file
        IMAINA         - the name of the mail file

                         Note: the mail file is obsolete and these
                               values are no longer set.

        IHELNU         - the Fortran unit number for the help file
        IHELST         - the current status of the help file
        IHELNA         - the name of the help file

        IBUGNU         - the Fortran unit number for the bugs file
        IBUGST         - the current status of the bugs file
        IBUGNA         - the name of the bugs file

        IQUENU         - the Fortran unit number for the query file
        IQUEST         - the current status of the query file
        IQUENA         - the name of the query file

                         Note: the query file is obsolete and these
                               values are no longer set.

        ILOGNU         - the Fortran unit number for the log file
        ILOGST         - the current status of the log file
        ILOGNA         - the name of the log file

        IREANU         - the Fortran unit number for the user read file
        IREAST         - the current status of the user read file
        IREANA         - the name of the user read file

        IWRINU         - the Fortran unit number for the user write file
        IWRIST         - the current status of the user write file
        IWRINA         - the name of the user write file

        ICRENU         - the Fortran unit number for the create macro file
        ICREST         - the current status of the create macro file
        ICRENA         - the name of the create macro file

        ISAVNU         - the Fortran unit number for the save memory file
        ISAVST         - the current status of the save memory file
        ISAVNA         - the name of the save memory file

        ISCRNU         - the Fortran unit number for the scratch file
        ISCRST         - the current status of the scratch file
        ISCRNA         - the name of the scratch file

        IDATNU         - the Fortran unit number for the data file
        IDATST         - the current status of the data file
        IDATNA         - the name of the data file

                         Note: the data file is reserved for future use.

        IPL1NU         - the Fortran unit number for the DEVICE 2 graphics
                         output file
        IPL1ST         - the current status of the DEVICE 2 graphics output
                         file
        IPL1NA         - the name of the DEVICE 2 graphics output file

        IPL2NU         - the Fortran unit number for the DEVICE 3 graphics
                         output file
        IPL2ST         - the current status of the DEVICE 3 graphics output
                         file
        IPL2NA         - the name of the DEVICE 3 graphics output file

Syntax 1:
    PROBE <FILE SWITCH>
    where <FILE SWITCH> is one of the names listed above.
 
Syntax 2:
    SET <FILE SWITCH>
    where <FILE SWITCH> is one of the names listed above.

Examples:
    PROBE IBUGNA
    PROBE IPL1NA
    SET IPL1NA PLOT1.PS

Default:
    The default unit numbers and names are defined by the INITFO routine
    when Dataplot is compiled.
 
Synonyms:
    None
 
Related Commands:
    NAME TABLE        = Probe the current settings for the Dataplot name
                        table.
    BUG SWITCHES      = Set debug switches.
    SYSTEM LIMITS     = Parameters defining certain Dataplot limits.
    MACHINE CONSTANTS = Return the values for certain machine constants.

Applications:
    Debugging
 
Implementation Date:
    Pre-1987
 
Program:
    SKIP 25
    READ BERGER1.DAT Y X BAT
    .
    SET IPL1NA BERGER1.PS
    DEVICE 2 POSTSCRIPT
    .
    CHARACTER X
    LINE BLANK
    TITLE BERGER1.DAT
    PLOT Y X
    .
    DEVICE 2 CLOSE
 
-----FILL---------------------------------------------------
 
FILL
 
Name:
    FILL
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Specifies whether certain figures in subsequent TEXT commands are
    filled or not filled.
 
Description:
    This applies only to those special symbols that have a fill
    capability and if a software font (e.g., SIMPLEX) is used:
       CIRC()   = circle
       SQUA()   = square
       TRIA()   = triangle
       REVT()   = reverse triangle
       PYRA()   = pyramid
       DIAM()   = diamond
    The most common use is to put bullets (i.e., a filled circle) in
    word charts.
 
Syntax:
    FILL <ON/OFF>
    where ON specifies that the relevant symbols are filled and OFF
    specifies they are not filled.
 
Examples:
    FILL ON
    FILL OFF
 
Default:
    No characters are filled.
 
Synonyms:
    None
 
Related Commands:
    FONT                = Specify font to use for text.
    TEXT                = Generate a text string.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    VERTICAL SPACING 6
    CRLF ON
    MARGIN 10
    FONT DUPLEX
    .
    HW 4 2
    MOVE 5 95
    TEXT JAPAN's 6-POINT PROGRAM FOR
    MOVE 5 89
    TEXT QUALITY MANUFACTURING
    MOVE 10 80
    HW 2.2 1.1
    FILL ON
    TEXT CIRC() QUALITY AUDITS
    TEXT CIRC() COMPANY-WIDE QUALITY CONTROL (CWQC)
    TEXT CIRC() QUALITY TRAINING AND EDUCATION
    TEXT CIRC() APPLICATION OF STATISTICAL METHODS
    TEXT CIRC() QUALITY CIRCLE ACTIVITIES
    TEXT CIRC() NATION-WIDE QUALITY CONTROL PROMOTIONAL ACTIVITIES
    FILL OFF
    HW 2 1
    MOVE 5 10
    TEXT SOURCE: Q.C. TRENDS WINTER 1985, PAGES 22-23.
 
-----FILTER WIDTH-----------------------------------------------------
 
FILTER WIDTH
 
Name:
    FILTER WIDTH
 
Type:
    Support Command
 
Purpose:
    Specifies the number (this number must be odd) of equally-spaced
    points to be considered as a moving set in subsequent ... SMOOTH
    commands.
 
Syntax:
    FILTER WIDTH   <n>
    where <n> is a number or parameter specifies the desired filter
              width (an odd integer from 1 to xx).
 
Examples:
    FILTER WIDTH 7
    FILTER WIDTH 3
    FILTER WIDTH 11
    FILTER WIDTH W
 
Default:
    The default filter width is 3.
 
Synonyms:
    None
 
Related Commands:
    SMOOTH            = Carries out a smoothing.
    FIT               = Carries out a least squares fit.
    POLYNOMIAL DEGREE = Sets the polynomial degree for smoothing and
                        fitting.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XX
 
-----FISHER EXACT TEST (LET)--------------------------------
 
FISHER EXACT TEST
 
Name:
    FISHER EXACT TEST (LET)
 
Type:
    Analysis Command
 
Purpose:
    Perform a Fisher exact test of independence for a two-way
    contingency table.

Description:
    If we have N observations with two variables where each
    observation can be classified into one of R mutually exclusive
    categories for variable one and one of C mutually exclusive
    categories for variable two, then a cross-tabulation of the
    data results in a two-way contingency table (also referred to
    as an RxC contingency table).  The resulting contingency table
    has R rows and C columns.

    Conover idenifies three distinct scenarios for contingency
    tables:

       1) Row totals are fixed, column totals are random
          (or alternatively, column totals are fixed and
          row totals are random).

          An example of this would be where the row totals
          are sample sizes (which may or may not be equal).
          Conover uses the example where we sample a population
          before and after a treatment and we are counting
          the presence or absence of some condition in each
          of the samples.

          In this case, the hypothesis being tested is
          homegeneity.  In the 2x2 case, this means we are
          testing whether the probability of success is
          equal in two Bernoulli populations.

          The normal theory test of equality of proportions
          is the large sample approximation to the Fisher
          exact test.

       2) Both row totals and column totals are random.

          This model would apply when we have a single sample
          that is classified according to two properties
          where property one has R possible outcomes and
          property two has C possible outcomes.
 
          In this case, the hypothesis being tested is
          bivariate independence.

          The chi-square test of independence is the large
          sample approximation to the Fisher exact test
          (see case 3).

       3) Both row totals and column totals are fixed.

          In this case, the null hypothesis being tested
          is independence.  By independence, we mean that the
          row and column variables are unassociated (i.e., knowing
          the value of the row variable will not help us predict
          the value of column variable and likewise knowing the
          value of the column variable will not help us predict
          the value of the row variable).

          A more technical definition for independence is that

             P(row i, column j) = P(row i)*P(column j)   for all i,j

    Note that the Fisher exact test returns the same
    p-value for each of these models.  What does change
    is the power of the test.   The power of the test is
    highest when the row and column totals are both fixed.
    That is, when the row and column totals are fixed, the
    Fisher exact test really is exact.  However, when either
    the row or column totals is random, the test is still
    valid.  However, it may become too conservative.
   
    The Fisher exact test is based on the probability of
    obtaining a table more extreme than the observed table.
    For example, for the 2x2 case when both row and column
    totals are fixed, the test statistic is the frequency
    of the row 1, column 1 cell.  This is compared to the
    hypergeometric distribution.
    
    The Fisher exact test is typically used when the row and
    column totals are small.  When they are large, the
    chi-square independence test is sufficiently accurate.
    In addition, the computational burden of the Fisher exact
    test can become prohibitively high as the marginal totals
    get higher (and the values of R and C increase).

    Dataplot computes the Fisher exact test using
    ACM algorithm 643, the FEXACT routine, written by
    Mehta and Patel.  This algorithm supports the RxC case
    (not just the 2x2 case) and is based on a network
    algorithm.  See the Mehta and Patel articles given in the
    References section for details of the algorithm.

Syntax 1:
    FISHER EXACT TEST <y1> <y2>    <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax is used for the case where you have raw data (i.e.,
    the data has not yet been cross tabulated into a two-way table).

Syntax 2:
    FISHER EXACT TEST <m>          <SUBSET/EXCEPT/FOR qualification>
    where <m> is a matrix containing the two-way table;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax is used for the case where we the data have already
    been cross-tabulated into a two-way contingency table.

Syntax 3:
    FISHER EXACT TEST <n11> <n12> <n21> <n22>
    where <n11> is a parameter containing the value for row 1,
                column 1 of a 2x2 table;
          <n12> is a parameter containing the value for row 1,
                column 2 of a 2x2 table;
          <n21> is a parameter containing the value for row 2,
                column 1 of a 2x2 table;
          <n22> is a parameter containing the value for row 2,
                column 2 of a 2x2 table.

    This syntax is used for the special case where you have a
    2x2 table.  In this case, you can enter the 4 values directly,
    although you do need to be careful that the parameters are
    entered in the order expected above.

Examples:
    FISHER EXACT TEST Y1 Y2
    FISHER EXACT TEST M
    FISHER EXACT TEST N11 N12 N21 N22

Note:
    The FEXACT routine allows you to set the value of the
    following parameters:

        EXPECT    - if EXPECT <= 0, then the exact test will
                    be performed.

                    If EXPECT > 0, then the PERCNT and EMIN
                    parameters are examined.

        PERCNT    - if EXPECT > 0, the value of PERCNT specifies
                    the number of cells that must have estimated
                    expected values > EXPECT before the asymptotic
                    chi-sqare test will be used.

        EMIN      - if EXPECT > 0, the value of EMIN identifies
                    the minimum estimated expected value for a
                    cell for the asymptotic chi-square test to
                    be used.

    The default values are referred to as the Cochran conditions:

        EXPECT  = 5.0
        PERCNT  = 80.0
        EMIN    = 1.0

    The following commands can be entered to change the default
    settings:

        SET FISHER EXACT TEST EXPECT <value>
        SET FISHER EXACT TEST PERCNT <value>
        SET FISHER EXACT TEST EMIN   <value>

Default:
    None
 
Synonyms:
    None

Related Commands:
    CHI-SQUARE INDEPENDENCE TEST  = Perform the chi-square independence
                                    test.
    ODDS RATIO INDEPENDENCE TEST  = Perform a log(odds ratio) test for
                                    independence.
    ASSOCIATION PLOT              = Generate an association plot.
    SIEVE PLOT                    = Generate a sieve plot.
    ROSE PLOT                     = Generate a Rose plot.
    BINARY TABULATION PLOT        = Generate a binary tabulation plot.
    ROC CURVE                     = Generate a ROC curve.
    ODDS RATIO                    = Compute the bias corrected odds ratio.
    LOG ODDS RATIO                = Compute the bias corrected
                                    log(odds ratio).

Reference:
    Mehta and Patel (1986), "ALGORITHM 643: FEXACT: a FORTRAN
    Subroutine for Fisher's Exact Test on Unordered RxC
    Contingency Tables", Volume 12, No. 2, pp. 154-161.

    Mehta and Patel (1983), "A Network Algorithm for Performing Fisher's
    Exact Test in <i>rxc</i> Contingency Tables", Journal of the
    American Statistical Association, Vol.78. No, 382, pp. 427-434.

    Conover (1999), "Practical Nonparametric Statistics", Third Edition,
    Wiley, pp. 204-216.

Applications:
    Categorical Data Analysis
 
Implementation Date:
    2007/3
 
Program 1:
    . Example from page 190 of Conover
    read matrix m
    1  9
    3  1
    end of data
    .
    fisher exact test m

Program 2:
    . Example from page 160 of Mehta and Patel ACM paper
    read matrix m
    1  2  2  1  1  0
    2  0  0  2  3  0
    0  1  1  1  2  7
    1  1  2  0  0  0
    0  1  1  1  1  0
    end of data
    .
    fisher exact test m

-----FISHER TWO SAMPLE RANDOMIZATION TEST----------------------------
 
FISHER TWO SAMPLE RANDOMIZATION TEST
 
Name:
    FISHER TWO SAMPLE RANDOMIZATION TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform a Fisher two sample randomization test for the equality
    of the means of two independent samples.
 
Description:
    The two sample t-test is the standard test for the equality of the
    means from two samples.  This test is based on the following
    aassumptions

       1. the samples are randomly selected from infinite populations
          (equivalently the observations are independent)

       2. the samples come from normal populations

       3. the two populations have equal variances

    Randomization tests can be used when these assumptions are
    questionable.  Fisher introduced randomization tests (also referred
    to as permutation tests) in 1935.

    The randomization test for the equality of the means for two
    samples is computed as follows:

       1. Given that sample one has n1 observations and sample two has
          n2 observations, randomly assign the n1 + n2 observations
          so that n1 observations are assigned to sample one and n2
          observations and compute the difference of the means.
          This is a single permuation for the test.

       2. Generate all possible permutations of the n1 + n2
          observations and compute the difference of the means
          for each permutation.  The number of permutations is
          (n1+n2)!/(n1!n2!).  Call this value NTOTAL for subsequent
          steps.

       3. Let DFULL denote the difference of the means for the
          original samples.  Let D(i) denote the difference of the
          means for the i-th sample.  Then the following p-values
          can be computed

             p(upper tail) = (number of D(i) >= DFULL)/NTOTAL

             p(lower tail) = (number of D(i) <=DFULL)/NTOTAL

             p(two tailed) = (number of |D(i)| >= DFULL)/NTOTAL

    The primary drawback to this test is that NTOTAL grows rapidly
    as n1 and n2 increase.  A test based on the full set of permutations
    may be computationaly prohibitive except for relatively small
    samples.  For larger n1 and n2, one approach is to generate a
    random subset of the complete set of permutations (typically
    on the order of 4,000 to 10,000 random subsets will be generated).

    For this command, Dataplot is using the algorithm of Richards and
    Byrd.  This algorithm generates the complete set of permutations.
    The advantage of this algorithm is that exact p-values are obtained
    for one-tailed tests and also for two-tailed tests when n1 = n2.  If
    n1 is not equal n2, an approximate p-value is obtained for the
    two-tailed test.  The primary drawback is that this test is limited
    to small sample sizes.  Dataplot currently limits the maximum value of
    n1 and n2 to be 22.  See the Note section below for some guidance to
    generating this test for larger samples based on randomly sampling the
    permutations.

    If the two samples are not randomly drawn from larger populations,
    the inference will be valid for the observations under study but
    not necesarily for the populations from which the observations are
    drawn.

Syntax 1:
    FISHER TWO SAMPLE RANDOMIZATION TEST <y1>  <y2>
                      <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    The <y1> and <y2> need not be the same length.

    Either <y1> or <y2> (or both) may be matrix arguments.  If a matrix
    argument is given, the response variable will consist of all
    observations in that matrix.  Although matrix arguments are allowed,
    they are rarely used for this command due to limitation on the
    size of the response variable.

Syntax 2:
    FISHER TWO SAMPLE RANDOMIZATION TEST  <y1>  ... <yk>
                      <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of 1 to 30 response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax will implement all the pairwise Fisher two sample
    randomization tests for the listed response variables.  For example,

         FISHER TWO SAMPLE RANDOMIZATION TEST Y1 TO Y4

    is equivalent to

         FISHER TWO SAMPLE RANDOMIZATION TEST Y1 Y2
         FISHER TWO SAMPLE RANDOMIZATION TEST Y1 Y3
         FISHER TWO SAMPLE RANDOMIZATION TEST Y1 Y4
         FISHER TWO SAMPLE RANDOMIZATION TEST Y2 Y3
         FISHER TWO SAMPLE RANDOMIZATION TEST Y2 Y4
         FISHER TWO SAMPLE RANDOMIZATION TEST Y3 Y4

    The <y1>, ..., <yk> need not be the same length.

    Any of the listed response variables may be matrix arguments.  If a
    matrix argument is given, the response variable will consist of all
    observations in that matrix.  Although matrix arguments are allowed,
    they are rarely used for this command due to limitation on the
    size of the response variable.

Examples:
    FISHER TWO SAMPLE RANDOMIZATION TEST Y1 Y2
    FISHER TWO SAMPLE RANDOMIZATION TEST Y1 TO Y4
 
Note:
    According to Franks and Byrd, this test can also be used to obtained
    p-values for the Wilcoxon signed rank test and the Mann-Whitney rank
    sum test for small samples.  These tests are essentially Fisher's
    test applied to the ranks of the original observations.  So you can
    generate the ranks of the data (the ranks are based on the combined
    data) and apply the FISHER TWO SAMPLE RANDOMIZATION TEST to the
    ranked data.
 
Note:
    Dataplot saves the following internal parameters after this test:

        STATVALU  = the value of the test statistic
        PVALUE    = the p-value for the two-sided test
        PVALUELT  = the p-value for the lower tailed test

Note:
    The following statistics are also supported:

        LET A = FISHER TWO SAMPLE RANDOMIZATION TEST        Y1 Y2
        LET A = FISHET TWO SAMPLE RANDOMIZATION TEST PVALUE Y1 Y2

    In addition to the above LET command, built-in statistics are
    supported for about 20+ different commands (enter HELP STATISTICS
    for details).

Note:
    This test is specific to the two sample location test and
    generates all possible permutations of the data.  For that
    reason, it is restricted to small sample sizes (currently a
    maximum sample size of 22 is allowed).

    The SAMPLE RANDOM PERMUTATION command can be used to implement
    other randomization tests (and to accomodate sample sizes
    greater than allowed here).  The Program 2 and Program 3 examples
    demonstrate this.  Although these examples demonstrate the
    difference of means statistic, other statistics can be easily
    substituted into these examples.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    T-TEST                     = Perform a two sample t-test.
    SIGN TEST                  = Perform a sign test.
    SIGNED RANK TEST           = Perform a signed rank test.
    CHI-SQUARED 2 SAMPLE TEST  = Compute a two sample chi-square
                                 test.
    BIHISTOGRAM                = Generates a bihistogram.
    QUANTILE-QUANTILE PLOT     = Generate a quantile-quantile plot.
    BOX PLOT                   = Generates a box plot.
 
Reference:
    Richards and Byrd (1996), "Fisher's Randomization Test for Two Small
    Independent Samples", Applied Statistics, Vol. 45, No. 3,
    pp. 394-398.

    Fisher (1935), "Design of Experiments", Edinburgh: Oliver and Boyd.

    Conover (1999), "Practical Non-Parametric Statistics", Third Edition,
    Wiley, pp. 410-410.

    Higgins (2004), "Introduction to Modern Nonparametric Statistics",
    Thomson/Brooks/Cole, Duxbury Advanced Series, Chapter 2.

Applications:
    Nonparameteric statistics, two sample problem
 
Implementation Date:
    2011/06
 
Program:
    .  Example from p. 410 of Convover (1999), "Practical Nonparametric
    .  Statistics", Third Edition, Wiley.
    .
    let y1 = data 0 1 1 0 -2
    let y2 = data 6 7 7 4 -3 9 14
    let y3 = data 9 2 3 5 7
    let y4 = data 6 8 9 12 15
    set write decimals 5
    .
    let t    = fisher two sample rand test        y1 y2
    let pval = fisher two sample rand test pvalue y1 y2
    .
    print t pval
    .
    fisher two sample rand test y1 y2
    fisher two sample rand test y1 y2 y3 y4

-----FIT-------------------------------------------------------
 
FIT
 
Name:
    ... FIT
 
Type:
    Analysis Command
 
Purpose:
    Estimate the parameters for a linear, polynomial, or non-linear
    least squares fit.  This is one of Dataplot's most powerful and
    heavily used commands.
 
Description:
    The FIT command can be used for both linear or non-linear fits.
    Both weighted and unweighted fits are supported.

    Non-linear fits are performed using an iterative modified
    Levenberg-Marquardt algorithm (Dataplot implements the algorithm
    given in the Osborne paper listed in the References section below).
    This algorithm can fit linear and multi-linear models as well as
    non-linear models.

    In addition, the FIT command can perform linear and polynomoal fits
    using a non-iterative algorithm.  Since the non-iterative algorithm
    supports a much broader range of output, this will be documented
    separately,  Enter

        HELP LINEAR FIT

    for the documentation for exact linear fits.

    Non-linear fits are specified by entering a function.  For example,

        FIT Y = A0 + A1*X1
        FIT Y = A0 + A1*EXP(A2*(YEAR-1950)
        FIT Y = (A0 + A1*X)/(1 + B1*X)

    The function can either be given on the FIT command or be defined
    with a LET FUNCTION command.

    For non-linear fits, the FIT command generates the following output.

    1) The parameter estimates and associated standard deviations are
       printed for each iteration.

    2) After convergence, a table containing the parameter estimates, the
       parameter standard deviations, and the parameter t-values is
       printed.  The t-value is used to determine if a given paramater is
       statistically significant.

       These values are also written to the file dpst1f.dat.  To read
       these values into Dataplot variables, enter the command

            SKIP 1
            READ DPST1F.DAT COEF COEFSD TVAL

    3) The correlation matrix for the parameter estimates is written to
       the file dpst2f.dat.  To read this correlation matrix, enter the
       command

            SKIP 1
            READ MATRIX DPST2F.DAT CORR

    4) The variance-covariance matrix for the parameter estimates is
       written to the file dpst3f.dat.  To read this covariance matrix,
       enter the command

            SKIP 0
            READ MATRIX DPST3F.DAT COV

    5) The residual standard deviation and its corresponding degrees of
       freedom are are stored in the parameters RESSD and RESDF,
       respectively.  RESDF is the number of observations minus the
       number of independent variables in the fit (including the
       constant term).  The formula for RESSD is:

            RESSD = SQRT(SUM(Y - PREDICTED VALUE)**2)/RESDF)

    6) If there is replication in the independent variables, the
       replication standard deviation and corresponding degrees of
       freedom are printed.  In addition, a lack of fit F test is
       performed.  These are stored in the parameters REPDF, REPSD, and
       LOFCDF respectively.  The formulas are:

             REPDF = SUM(number of observations in replication - 1)
             REPSD = SQRT(SUM((Y - replication mean)**2)/REPDF)
 
    7) Dataplot saves the predicted values from a fit in the variable
       PRED and the residual values in the variable RES.  These variables
       can be used in subsequent LET and PLOT commands to generate
       diagnostic plots of residuals and predicted values.
 
    It is recommended that a FIT be followed by a residual analysis to
    assess the model adequacy.  Specifically, the typical assumptions for
    the residuals are that they are independent with a common
    distribution having fixed location and variation.  It is usually
    assumed that the common distribution is a normal distribution.
    The 4-PLOT command generates 4 plots that are useful in testing
    these assumptions.  The NIST/SEMATECH e-Handbook contains a
    more detailed discussion of this issue at

        https://www.itl.nist.gov/div898/handbook/eda/section2/eda2.htm

    In addition, if there is a single independent variable in the model,
    it can be useful to plot the data with the fitted values overlaid.

    For non-linear fits, up to 15 indepedent variables can be
    included in the model.

Syntax:
    FIT  <y1>  =  <f>  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the response (= dependent) variable;
          <f> is:
               1) a general Fortran-like expression; or
               2) any function name that the user has already created
                  via the LET FUNCTION command;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is appropriate for all models--linear, polynomial,
    multi-linear (up to 15 independent variables), and non-linear (up to
    15 independent variables).  It uses an iterative modified
    Levenberg-Marquardt algorithm.  Linear fits are handled as a special
    case (the fits are still done iteratively).
 
Examples:
    FIT Y = A+B*EXP(-C*X)
    FIT Y = A*(EXP(-B*TIME/10) - EXP(-TIME/10))
    FIT Y = B0 + B1*X**B2
    FIT Y = K/(1+K*A*X**B)
    FIT Y = A - B*X - ATAN(C/(X-D))/3.1459
    FIT Y = A0*BESS0(A1*X)*BESS1(A1*X)
    FIT Y = (A0 + A1*X)/(1 + B1*X + B2*X**2)
    FIT Y = (A+B*X+C*X**D)/(SIN(EXP(-ALPHA*X2+BETA*X3)))

    FIT Y = F1

Note:
    The following document contains a number of examples of the
    Dataplot FIT command

    https://www.itl.nist.gov/div898/software/dataplot/NonLinearFitting.pdf

Note:
    The non-linear algorithm is iterative with two commands for
    controlling the iterations.

    By default, a maximum of 50 iterations are allowed before Dataplot
    assumes the fit is not converging.  You can change this maximum with
    the FIT ITERATIONS command.

    Dataplot checks for convergence by computing the ratio of sccuessive
    values of the residual standard deviation.  You can specify the
    critierion for convergence with the FIT STANDARD DEVIATION command.

Note:
    Starting values are not required.  The Levenberg-Marquardt algorithm
    can provide good fits for a wide variety of applications without
    decent starting values.

    However, decent starting values can often speed up non-linear fits.
    In addition, some fits may require good starting values in order
    to converge to accurate values.

    To specify starting values, simply assign values to the coefficients
    before doing the fit.  For example:

       LET ALPHA = 0.15
       LET A = 0.004
       LET B = 0.01
       FIT Y = EXP(-ALPHA*X)/(A+B*X)

    In some cases, good starting values might be known from previous
    work or from theoretical considerations.  However, if better
    starting values are needed and reasonable guesses are not available,
    the PRE-FIT command can be helpful.  Enter HELP PRE-FIT for details.

    Sinusoidal models are one case where good starting values are
    needed.  See the following example from the NIST/SEMATECH e-Handbook
    for an example of fitting this kind of model

        https://www.itl.nist.gov/div898/handbook/eda/section4/eda425.htm

    If you have a parameter in the model that you want to set to a fixed
    value, then enter the literal value or use the substitution
    character "^".  For example

        FIT Y = A0 + A1*X**1.5

        LET C = 1.5
        FIT Y = A0 + A1*X**C   - Dataplot will try to fit C
        FIT Y = A0 + A1*X**^C  - Dataplot will leave C fixed at 1.5

Note:
    Weighted fits are typically used in the following two situations.

       1. Weighting is one approach for dealing with non-constant
          variation in the residuals.  It is not uncommon for the
          variance of the residuals to increase for the largest (or
          smallest) values of the independent variable.  In this case,
          weights can be used to give less weight to the less precise
          measurements.  The NIST/SEMATECH e-Handbook contains a
          disucssion of weighted fits and an example of using weights
          to address non-constant variation in the following pages

          https://www.itl.nist.gov/div898/handbook/pmd/section4/pmd432.htm
          https://www.itl.nist.gov/div898/handbook/pmd/section6/pmd625.htm

       2. Weights can also used to implement certain types of robust
          fitting.  In this case, weights are used to down weight
          observations based on the size of the associated residual.
          Outlier observations can sometimes distort a fit (i.e., in
          trying to fit the outlier point(s), the bulk of the data
          is poorly fit).  Weighting based on the residuals can often
          provide a good fit to the bulk of the data without eliminating
          the outlier observations from the analysis.

          Enter HELP WEIGHTS and HELP BIWEIGHT for examples of this
          use of weighted fits in Dataplot.

    To specify weights for a least squares fit, enter the command

         WEIGHTS <var>

    where <var> is a variable containing the weights.

    Note that the RES variable contains the absolute value of the
    residuals after the fit.  For residual plots and analysis, it
    may be preferrable to work with the weighted residuals.  You can
    create this with the command

         LET RESW = W*RES

    where W contains the weight variable.

Note:
    Data transformations are often used to improve the quality of the
    fit.  For example, some types of non-linear fits can be restated as
    linear fits with an appropriate transformation.  Also,
    transformations are often applied to address non-homogeneous
    variation in the fit.  The NIST/SEMATECH e-Handbook contains a
    disucssion of this issue at

        https://www.itl.nist.gov/div898/handbook/pmd/section4/pmd452.htm

    Data transformations can be generated easily if needed via the
    LET command.  The BOX-COX LINEARITY PLOT can be a useful command for
    determining an approriate transformation.

    Some analysts prefer to standardize the indpendent variables
    and the dependent variable by subtracting the mean and dividing
    by the standard deviation.  This is done to provide numerical
    stability (note that Dataplot scales the data internally before
    performing the regression calculations) and also so that the
    data and regression coefficients are on a common scale.  The
    original regression and standardized model are related as follows

         x'(i) = (x(i) - xbar)/s(x)
         y'(i) = (y(i) - ybar)/s(y)

    with xbar and s(x) denoting the mean and standard deviation of the
    independent variable and ybar and s(y) denoting the mean and
    standard deviation of the dependent variable.

    The parameters are related by

         Beta(k) = (s(y)/s(k))*Beta'(k)
         Beta'(0) = ybar - Beta(1)*xbar(1) - ... - Beta(p)*xbar(p)

    A variation on this is the correlation transformation (also called
    the standardized regression model).  Specifically

         y'(i) = (1/SQRT(n-1))*(y(i) - ybar)/s(y)
         x'(ik) = (1/SQRT(n-1))*(x(ik) - xbar(k))/s(x(k))

    With this transformation, the X'X matrix reduces to a correlation
    matrix of the independent variables.  If there are p independent
    variables, these transformations can be generated with the commands

         LET N = SIZE Y
         LET FACT = 1/SQRT(N-1)
         LOOP FOR K = 1 1 P
             LET Z^K = STANDARDIZE X^K
             LET Z^K = AFACT*Z^K
         END OF LOOP
         LET YT = STANDARDIZE Y
         LET YT = AFACT*YT

Note:
    Although the FIT command is the Dataplot workhorse command
    for fitting, Dataplot supports the additional fit capabilities:

       1. ORTHOGONAL DISTANCE FIT - This command is used to fit
          errors-in-variables models for for both linear and non-linear
          models.  It can also fit implicit models.
       2. BOOTSTRAP FIT - This command is used to fit linear or
          multilinear models using the bootstrap.
       3. EXACT RATIONAL FIT - This command is used to determine good
          starting values for fitting rational function models (the
          full model is still fit using the FIT command).

          Rational function models are the ratio of two polynomial
          functions.  The NIST/SEMATECH e-Handbook contains a detailed
          discussion of these models at

          https://www.itl.nist.gov/div898/handbook/pmd/section8/pmd812.htm

       4. CALIBRATION - This command is used to fit linear or quadratic
          calibration models.
       5. YATES ANALYSIS - This command is used to fit full and fractional
          2-level designs.
       6. SPLINE FIT - This command is used for spline fits.
       7. LOWESS SMOOTH - This command is used to fit locally-weighted
          least squares models.
       8. ARMA - This command is used for fitting autoregressive/moving
          average time series models.
       9. PRINCIPAL COMPONENTS - This LET subcommand can be used to
          reduce the number of indpendent variables in a multi-linear fit.
      10. SMOOTH - This command is used for various types of smoothing.
      11. INTERPOLATION - This LET subcommand performs cubic spline
          interpolation.
      12. HERMITE INTERPOLATION - This LET subcommand performs Hermite
          interpolation.

    These commands are documented separately.

Note:
    If you want to suppress the output to files dpst1f.dat, dpst2f.dat,
    and dpst3f.dat, enter the command

        SET FIT AUXILLARY FILES OFF

Note:
    By default, the values written to dpst1f.dat, dpst2f.dat and
    dpst3f.dat are written using a Fortran E15.7 format (that is,
    exponential format with 7 significant digits).  You can specify
    the number of signficant digits with the command

        SET AUXILLARY FILES DECIMAL POINTS <value>

    where the default is 7.

Default:
    None

Synonyms:
    None
 
Related Commands:
    FIT ITERATIONS     = Sets the maximum number of iterations for the
                         FIT command.
    FIT STANDARD DEVI  = Sets the minimum standard deviation for the
                         convergence criterion in the FIT command.
    PRED               = A variable where predicted values are stored.
    RES                = A variable where residuals are stored.
    RESSD              = A parameter where the residual standard
                         deviation is stored.
    RESDF              = A parameter where the residual degrees of
                         freedom is stored.
    REPSD              = A parameter where the replication standard
                         deviation is stored.
    REPDF              = A parameter where the replication degrees of
                         freedom is stored.
    LOFCDF             = A parameter where the lack of fit cdf is
                         stored.
    WEIGHTS            = Sets the weights for the fit command.
    BIWEIGHT           = Perform a biweight transformation.
    EXACT RATIONAL FIT = Perform an exact rational fit.
    CALIBRATION        = Perform a linear or quadratic calibration fit.
    LOWESS SMOOTH      = Perform a locally weighted least squares
                         smoothing.
    BOOTSTRAP FIT      = Perform a linear or multi-linear fit based on
                         the bootstrap.
    ORTHOGON DIST FIT  = Perform an orthogonal distance fit (useful for
                         errors-in-variables models).
    PRE-FIT            = Perform a least squares pre-fit.
    SPLINE FIT         = Perform a spline fit.
    SMOOTH             = Perform a smoothing.
    ANOVA              = Perform a fixed effects analysis of variance.
    MEDIAN POLISH      = Perform a median polish.
    PLOT               = Generate a data/function plot.
    4-PLOT             = Generate a 4-plot.
 
References:
    Osborne (1972), "Some Aspects of Nonlinear Least Squares
    Calculation", in Numerical Methods for Nonlinear Optimization,
    Ed. Lootsma, Academic Press.

    Osborne (1976), "Nonlinear Least Squares -- the Levenberg Algorithm
    Revisited", ANZIAM Journal, Vol. 19, No. 3, pp. 343-357.

Applications:
    Least Squares Fitting
 
Implementation Date:
    Pre-1987
    1987/09: Support for weighted fits
    1988/03: Save LOFCDF parameter
    1991/09: Expand number of allowed independent variables from 15 to 5
    1992/03: Write coefficient, coefficient sd, and t-value to dpst1f.dat
    1992/03: Write coefficient, coefficient sd, and t-value to dpst1f.dat
    1997/07: Print summary information if maximum iterations reached
    2001/04: Print parameter covariance matrix to dpst3f.dat
    2014/06: Option to suppress output to auxillary files
    2019/04: Option to suppress output to auxillary files

Program 1:
    . Step 1:   Read the data
    .
    SKIP 25
    READ CHWIRUT1.DAT Y X
    SKIP 0
    .
    . Step 2:   Perform the fit
    .
    SET WRITE DECIMALS 5
    LET ALPHA = 0.15
    LET A = 0.004
    LET B = 0.01
    CAPTURE SCREEN ON
    CAPTURE FIT1.OUT
    FIT Y = EXP(-ALPHA*X)/(A+B*X)
    END OF CAPTURE
    .
    . Step 3:   Generate diagonistic graphs
    .
    TITLE OFFSET 2
    TITLE CASE ASIS
    LABEL CASE ASIS
    TITLE Predicted Values Overlaid on Raw Data (CHWIRUT1.DAT)
    X1LABEL Metal Distance
    Y1LABEL Ultrasonic Response
    .
    LINE BLANK SOLID
    CHARACTER X BLANK
    .
    PLOT Y PRED VS X
    .
    LABEL
    TITLE
    SET 4-PLOT MULTIPLOT ON
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TIC MARK LABEL SIZE 4
    CHARACTER SIZE 4
    .
    4-PLOT RES
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT 4-Plot of Residuals (CHWIRUT1.DAT)

Program 2:
    . Step 1:   Read the data
    .
    READ ROSZMAN1.DAT X T
    LET Q = X - SQRT(-109737.3/T)
    .
    . Step 2:   Perform the fit
    .
    SET WRITE DECIMALS 5
    LET A = 0.2
    LET B = -0.00005
    LET C = 200
    LET D = -123
    .
    CAPTURE SCREEN ON
    CAPTURE FIT2.OUT
    FIT Q = A - B*T - ATAN(C/(T-D))/3.14159
    END OF CAPTURE
    .
    . Step 3:   Generate diagonistic graphs
    .
    TITLE OFFSET 2
    TITLE CASE ASIS
    LABEL CASE ASIS
    TITLE Predicted Values Overlaid on Raw Data (ROSZMAN1.DAT)
    X1LABEL Excited State Energy
    Y1LABEL Quantum Effects for Sulfur I Atom
    .
    LINE BLANK SOLID
    CHARACTER X BLANK
    .
    PLOT Q PRED VS T
    .
    LABEL
    TITLE
    SET 4-PLOT MULTIPLOT ON
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TIC MARK LABEL SIZE 4
    CHARACTER SIZE 4
    .
    4-PLOT RES
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT 4-Plot of Residuals (ROSZMAN1.DAT)
 
-----FIT AUXILLARY FILES (SET)--------------------------------------------
 
FIT AUXILLARY FILES
 
Name:
    FIT AUXILLARY FILES (SET)
 
Type:
    Set Subcommand
 
Purpose:
    Specify whether the FIT command will generate auxillary files.
 
Description:
    When a FIT command is entered, Dataplot will generate several files
    (for a linear fit: dpst1f.dat, dpst2f.dat, dpst3f.dat, dpst4f.dat,
    dpst5f.dat, for a nonlinear fit: dpst1f.dat, dpst2f.dat, dpst3f.dat).

    If this switch is set to OFF, then writing to these files is
    suppressed.  Note that this command was primarily created for internal
    Dataplot use (i.e., several commands call the fit routines behind the
    scenes).   However, it can be explicitly specified by the user.
 
Syntax:
    SET FIT AUXILLARY FILES <ON/OFF>

    If ON is specified, the auxillary files will be written.  If OFF
    is specified, the auxillary files will not be written.
 
Examples:
    SET FIT AUXILLARY FILES ON
    SET FIT AUXILLARY FILES OFF

Default:
    The default is ON
 
Synonyms:
    NO and FALSE are synonyms for OFF.  Note that any other arguments will
    be interpreted as ON.
 
Related Commands:
    FIT       = Perform a linear or nonlinear fit.
 
Applications:
    Fitting
 
Implementation Date:
    2014/06
 
Program:
    skip 25
    read berger1.dat
    set fit auxillary files on
    fit y x
 
-----FIT CONSTRAINT---------------------------------------------------
 
FIT CONSTRAINT
 
Note:
    ***** This command is not yet operational *****
 
Name:
    FIT CONSTRAINT
 
Type:
    Support Command
 
Purpose:
    Specifies a constraint for subsequent FIT commands.
 
Description:
    The constraint can be an equality constraint such as ALPHA = 2.5
    or an inequality constraint such as BETA > 0.
 
Syntax:
    FIT CONSTRAINT   <parameter>   <operation>   <number>
    where <parameter> is the name of a parameter to appear in
             subsequent FIT commands;
          <operation> is   =, >, >=, <, <=, or <>;
    and   <number> is any number or parameter.
 
Examples:
    FIT CONSTRAINT ALPHA = 2.3
    FIT CONSTRAINT A > 0
    FIT CONSTRAINT A < 100
    FIT CONSTRAINT A
 
Note:
    If <operation> and <number> are omitted in the FIT CONSTRAINT
    command, then all prior constraints for that parameter will be
    deleted.
 
Default:
    There are no constraints.
 
Synonyms:
    None
 
Related Commands:
    FIT                = Carries out a least squares fit.
    FIT ITERATIONS     = Set the maximum iterations for a fit command.
    FIT STANDARD DEVI  = Set the minimum standard deviation for a fit
                         command.
    WEIGHTS            = Set the weights for a fit command.
    PRED               = A variable where predicted values are stored.
    RES                = A variable where residuals are stored.
    RESSD              = A parameter where the residual standard
                         deviation is stored.
    RESDF              = A parameter where the residual degrees of
                         freedom is stored.
    REPSD              = A parameter where the replication standard
                         deviation is stored.
    REPDF              = A parameter where the replication degrees of
                         freedom is stored.
    LOFCDF             = A parameter where the lack of fit cdf is
                         stored.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XX
 
-----FIT ITERATIONS---------------------------------------------------
 
FIT ITERATIONS
 
Name:
    FIT ITERATIONS
 
Type:
    Support Command
 
Purpose:
    Specifies the maximum number of iterations allowable for
    subsequent FIT commands.
 
Description:
    The FIT command automatically terminates itself when it has
    converged to the least squares solution.  The number of iterations
    for such convergence varies with the model and the data.  The FIT
    ITERATIONS command will not affect the number of iterations to
    least squares convergence.  It simply terminates the iterations if
    convergence to the least squares solution has not occurred before
    the specified maximum number of iterations.  Note also that if the
    maximum number of iterations has occurred, the analyst may resume
    the iterations (picking up where it had left off) by simply
    re-entering the FIT command.
 
Syntax:
    FIT ITERATIONS   <n>
    where <n> is a positive integer number or parameter that specifies
              the desired maximum number of iterations.
 
Examples:
    FIT ITERATIONS 30
    FIT ITERATIONS 100
 
Default:
    The default maximum number of iterations is 50.
 
Synonyms:
    None
 
Related Commands:
    FIT                = Carries out a least squares fit.
    FIT ITERATIONS     = Set the maximum iterations for a fit command.
    FIT STANDARD DEVI  = Set the minimum standard deviation for a fit
                         command.
    WEIGHTS            = Set the weights for a fit command.
    PRED               = A variable where predicted values are stored.
    RES                = A variable where residuals are stored.
    RESSD              = A parameter where the residual standard
                         deviation is stored.
    RESDF              = A parameter where the residual degrees of
                         freedom is stored.
    REPSD              = A parameter where the replication standard
                         deviation is stored.
    REPDF              = A parameter where the replication degrees of
                         freedom is stored.
    LOFCDF             = A parameter where the lack of fit cdf is
                         stored.
 
Applications:
    Fitting
 
Implementation Date:
    XX
 
Program:
    XX
 
-----FIT POWER---------------------------------------------------
 
FIT POWER
 
Name:
    FIT POWER
 
Type:
    Support Command
 
Purpose:
    The FIT POWER command can be used in conjunction with the PRE-FIT
    command to asses the sensitivity of the parameter estimates to
    the fitting criterion (for example, least squares and L1 fits).
 
Description:
    Least squares estimates are optimal if the error distribution is
    normally distributed.  However, if the errors are non-normal or
    if there are outliers, then the least squares estimates may be
    unduly affected.  In this case, criterion other than least squares
    may be desirable.
 
    One approach to this problem is called Lp norm estimation.  This
    method is based on minimizing:
        SUM[ABS(Y - YPRED)**power]**(1/power)
    where Y is the raw data, YPRED is the predicted data, and power
    determines the fitting criterion (this is the p in Lp).  When
    power is 2, this reduces to standard least squares.  When power
    is 1, it reduces to least absolute deviations (LAD) fitting.  LAD
    fitting provides good protection against outliers, but it is not as
    efficient as least square estimation when the errors are well
    behaved.  The value of power is generally chosen to be between 1
    and 2 inclusive.
 
    The PRE-FIT command evaluates:
        SUM[(ABS(Y - YPRED)**power)/(n-p)]**(1/power)
    (where n is the number of points and p is the number of parameters
    in the fit) over a lattice of user-specified parameter values.
    That point in the lattice for which the summation is smallest will
    be the "least power" fit over the lattice.
 
    A practical method for determining the sensitivity of the estimated
    parameters to the goodness of fit criterion is:
       1) Use the PRE-FIT command with power 2 (this is the default or
          it can be explicitly specified via FIT POWER 2) to determine
          the least squares estimates over the lattice.  Several
          iterations can be used to determine a finer grid.
       2) Use the parameter values from the PRE-FIT to generate the
          least squares fit via the FIT command.  Perform the usual
          residual analysis to determine the adequacy of the model,
          validity of assumptions, and the existence of outliers.
       3) Check to see how much of a difference there is between the
          obtained least squares solution and the solution that would
          result from using a different power.  Enter FIT POWER <value>
          and rerun the PRE-FIT command in the region surrounding the
          least squares solution.  Even though the PRE-FIT is
          restricted to the lattice, it nevertheless is strongly
          suggestive of the true magnitude of such differences.  If the
          analyst wishes a more exact value for the minimum of the
          specified power criterion, the PRE-FIT command can be run
          again with a finer grid in the vicinity of the solution from
          the previous PRE-FIT command.  If such differences are
          significantly large, then the analyst will be aware of the
          sensitivity of the solution to the fitting criterion.
 
Syntax:
    FIT POWER   <value>
    where <value> is a number or parameter (typically between 1 and 2)
              that specifies the desired fit power.
 
Examples:
    FIT POWER 1
    FIT POWER 2
    FIT POWER 1.5
 
Note:
    The FIT command is currently limited to a power of 2 (i.e., least
    squares estimates only).  The PRE-FIT command can be used in an
    iterative fashion to obtain a "rough" estimate of the Lp solution.
    More efficient methods for L1 (i.e., least absolute deviations)
    regression are typically based on linear programming methods.  This
    is not supported by DATAPLOT at this time.  DATAPLOT does have a
    SIMPLEX SOLUTION command for solving linear programming problems.
    However, this can be used for L1 estimation in DATAPLOT only for
    small N (less than about 30 or so data points).
 
Note:
    The FIT POWER and PRE-FIT commands can be applied to both linear
    and non-linear fits (many programs that support LAD regression and
    Lp regression are restricted to linear fits).
 
Note:
    Iteratively re-weighted least squares is another approach to
    handling outliers.  It is based on down-weighting large residuals.
    See the documentation for the BIWEIGHT command for details on how
    to do this in DATAPLOT.
 
Note:
    The PRE-FIT command is primarily used to obtain good starting
    values for non-linear fits.
 
Default:
    The fit power is 2 (i.e., least squares).
 
Synonyms:
    None
 
Related Commands:
    PRE-FIT            = Determine a fit solution over a lattice of
                         parameter values.
    FIT                = Carries out a least squares fit.
    FIT ITERATIONS     = Set the maximum iterations for a fit command.
    FIT STANDARD DEVI  = Set the minimum standard deviation for a fit
                         command.
    BIWEIGHT           = Compute a biweight estimate for robust
                         fitting.
    WEIGHTS            = Set the weights for a fit command.
    PRED               = A variable where predicted values are stored.
    RES                = A variable where residuals are stored.
    RESSD              = A parameter where the residual standard
                         deviation is stored.
    RESDF              = A parameter where the residual degrees of
                         freedom is stored.
    REPSD              = A parameter where the replication standard
                         deviation is stored.
    REPDF              = A parameter where the replication degrees of
                         freedom is stored.
    LOFCDF             = A parameter where the lack of fit cdf is
                         stored.
 
References:
    "Statistical Computing", Kennedy and Gentle, Marcel Dekker, 1980
    (chapter 11).
 
    "Elements of Statistical Computing", Thisted, Chapman and Hall,
     1988 (section 3.12).
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    . DAN CHWIRUT ULTRASONIC REFERENCE BLOCK ANALYSIS
    SKIP 25
    READ CHWIRUT1.DAT Y X
    LET FUNCTION F = A + B*EXP(-C*X)
    FIT POWER 2
    PRE-FIT Y=F FOR A = 0 10 50 FOR B = 100 20 200 FOR C = 0.5 0.5 2
    PRE-FIT Y=F FOR A = 9.8 .1 10.2 FOR B = 95 5 125 FOR C = 0.8 .1 1.2
    FIT POWER 1.5
    PRE-FIT Y=F FOR A = 9.8 .1 10.2 FOR B = 95 5 125 FOR C = 0.8 .1 1.2
    FIT POWER 1
    PRE-FIT Y=F FOR A = 9.8 .1 10.2 FOR B = 95 5 125 FOR C = 0.8 .1 1.2
 
-----FIT STANDARD DEVIATION--------------------------------------------
 
FIT STANDARD DEVIATION
 
Name:
    FIT STANDARD DEVIATION
 
Type:
    Support Command
 
Purpose:
    Specifies the target value for the residual standard deviation
    which (upon attainment) will cause the iterations in the FIT
    command to terminate.
 
Description:
    Under usual default circumstances, The FIT command automatically
    terminates itself when it has converged to the least squares
    solution.  The number of iterations for such convergence varies
    with the model and the data.  The convergence criterion involves
    residual standard deviations for 3 successive iterations.  The 2
    successive differences are computed, a ratio is formed, and this
    ratio is compared to a cutoff value.  This criterion is excellent
    and has served well for a wide variety of models and data sets.  If
    the starting values were at all decent (within an order of
    magnitude), convergence (via the underlying Marquardt/Levenberg/
    Osborne algorithm is usually rapid (within 15 iterations).  If
    convergence is too slow, however, and if the analyst has a
    pre-specified value in mind that he or she wants the fitted model
    to be accurate to, then the usual mode of convergence may be
    circumvented via the FIT STANDARD DEVIATION command.
 
Syntax:
    FIT STANDARD DEVIATION   <n>
    where <n> is a positive number or parameter that specifies the
              target value for the residual standard deviation.
 
Examples:
    FIT STANDARD DEVIATION 0.01
    FIT STANDARD DEVIATION 0.0001
    FIT STANDARD DEVIATION A
 
Default:
    The default value is 0.000005.
 
Synonyms:
    None
 
Related Commands:
    FIT                = Carries out a least squares fit.
    FIT ITERATIONS     = Set the maximum iterations for a fit command.
    WEIGHTS            = Set the weights for a fit command.
    PRED               = A variable where predicted values are stored.
    RES                = A variable where residuals are stored.
    RESSD              = A parameter where the residual standard
                         deviation is stored.
    RESDF              = A parameter where the residual degrees of
                         freedom is stored.
    REPSD              = A parameter where the replication standard
                         deviation is stored.
    REPDF              = A parameter where the replication degrees of
                         freedom is stored.
    LOFCDF             = A parameter where the lack of fit cdf is
                         stored.
 
Applications:
    Fitting
 
Implementation Date:
    XX
 
Program:
    XX
 
-----FLCDF (LET)--------------------------------
 
FLCDF
 
Name:
    FLCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Fatigue Life cumulative distribution function with shape
    parameter gamma.  The location parameter (mu) is assumed to be 1
    (see the NOTE below for information on other location parameters).
 
Description:
    The  Fatigue Life distribution has the following probability
    density function:
        pdf(x) = (IGPDF(X,GAMMA) + RIGPDF(X,GAMMA))/2
               = ((1+X)/2)*IGPDF(X,GAMMA)
    where IGPDF is Inverse Gausian distribution function, RICPDF is the
    Reciprocal Inverse Gaussian distribution function, and GAMMA is the
    shape parameter.  It is defined for any non-negative real number.
    It has mean MU (see NOTE below) and standard deviation
    MU*GAMMA*SQRT(1+(5/4)*GAMMA**2).
 
    The cumulative distribution is the area from 0 to x (i.e., the
    integral of the above function).  It has the form:
        cdf(x) = (IGCDF(X,GAMMA) + RIGCDF(X,GAMMA))/2
               = NORCDF((1/GAMMA)*(SQRT(X) - SQRT(1/X)))
    where NORCDF is the standard Normal cumulative distribution
    function.  The cdf function is defined for any non-negative real
    number.  Since it is a probability function, the returned value
    will be between 0 and 1.
 
Syntax:
    LET <y2> = FLCDF(<y1>,GAMMA)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed fatigue life cdf value is stored;
          <GAMMA> is a positive integer (the shape parameter);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = FLCDF(3,10)
    LET A = FLCDF(A1,10)
    LET X2 = FLCDF(X1,10)
 
Note:
    The Fatigue Life distribution is symmetric and moderate tailed
    for small gammas.  It is highly skewed and long tailed for large
    gamma.  It approaches normality as gamma approaches zero.
 
Note:
    DATAPLOT computes this distribution for the case where MU = 1.
    For other values of MU, scale up by the MU parameter.  That is,
         LET Y = FLCDF(MU*X,GAMMA)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    FCDF   = Compute the F cumulative distribution function.
    FPDF   = Compute the F probability density function.
    FPPF   = Compute the F percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    TCDF   = Compute the T cumulative distribution function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    WALPDF = Compute the Wald probability density function.
    WALPPF = Compute the Wald percent point function.
    WALCDF = Compute the Wald cumulative distribution function.
    FLPDF  = Compute the Fatigue Life probability density function.
    FLPPF  = Compute the Fatigue Life percent point function.
    IGPDF  = Compute the Inverse Gaussian probability density function.
    IGPPF  = Compute the Inverse Gaussian percent point function.
    IGCDF  = Compute the Inverse Gaussian cumulative distribution
             function.
    RIGPDF = Compute the Reciprocal Inverse Gaussian probability
             density function.
    RIGPPF = Compute the Reciprocal Inverse Gaussian percent point
             function.
    RIGCDF = Compute the Reciprocal Inverse Gaussian cumulative
             distribution function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, 1970.
 
Applications:
    XX
 
Implementation Date:
    90/5
 
Program:
TITLE PLOT FLCDF FOR VARIOUS VALUES OF GAMMA
    SEGMENT 1 COORDINATES 70 38 75 38; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 70 34 75 34; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 70 30 75 30; SEGMENT 3 PATTERN DOT
    SEGMENT 4 COORDINATES 70 26 75 26; SEGMENT 4 PATTERN DASH2
    LEGEND 1 GAMMA = 1; LEGEND 1 COORDINATES 76 37
    LEGEND 2 GAMMA = 2; LEGEND 2 COORDINATES 76 33
    LEGEND 3 GAMMA = 5; LEGEND 3 COORDINATES 76 29
    LEGEND 4 GAMMA = .5; LEGEND 4 COORDINATES 76 25
    YLIMITS 0 1; MAJOR YTIC NUMBER 6
    MINOR YTIC NUMBER 1; YTIC DECIMAL 1
    XLIMITS 0 3
    LINES SOLID DASH DOT DASH2
    PLOT FLCDF(X,1) FOR X = 0.01 0.01 3 AND
    PLOT FLCDF(X,2) FOR X = 0.01 0.01 3 AND
    PLOT FLCDF(X,5) FOR X = 0.01 0.01 3 AND
    PLOT FLCDF(X,0.5) FOR X = 0.1 0.01 2.5
 
-----FLCHAZ (LET)--------------------------------
 
FLCHAZ
 
Name:
    FLCHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Fatigue Life cumulative hazard function with shape
    parameter gamma.
 
Description:
    The  Fatigue Life distribution has the following cumulative
    hazard function:
        H(x,gamma) = -LOG(1 - FLCDF(x,gamma))    x >= 0, gamma > 0
    where FLCDF is the Fatigue Life cumulative distribution function
    and gamma is the shape parameter.
 
Syntax:
    LET <y> = FLCHAZ(<x>,<gamma>)   <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative variable, parameter, or number;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed Fatigue Life cumulative hazard value
               is stored;
          <gamma> is a positive number, parameter, or variable that
               defines the shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = FLCHAZ(3,10)
    LET A = FLCHAZ(A1,3)
    LET X2 = FLCHAZ(X1,GAMMA)

Note:
    The Fatigue Life distribution is symmetric and moderate tailed
    for small gammas.  It is highly skewed and long tailed for large
    gamma.  It approaches normality as gamma approaches zero.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FLCDF  = Compute the Fatigue Life cumulative distribution function.
    FLHAZ  = Compute the Fatigue Life hazard function.
    FLPDF  = Compute the Fatigue Life probability density function.
    FLPPF  = Compute the Fatigue Life percent point function.
    IGPDF  = Compute the Inverse Gaussian probability density function.
    RIGPDF = Compute the Reciprocal Inverse Gaussian probability
             density function.
    WALPDF = Compute the Wald probability density function.
    CHSPDF = Compute the chi-square probability density function.
    NORPDF = Compute the normal probability density function.
    WEIPDF = Compute the Weibull probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 2", Johnson, Kotz,
    and Balakrishnan, John Wiley, 1994.
 
Applications:
    Reliability
 
Implementation Date:
    1998/4
 
Program:
    MULTIPLOT CORNER COORDINATES 5 5 95 95 
    MULTIPLOT 2 2 
    TITLE CASE ASIS 
    TITLE Fatigue Life Cumulative Hazard (Gamma = 1) 
    PLOT FLCHAZ(X,1) FOR X = 0.01 0.01 3
    TITLE Fatigue Life Cumulative Hazard (Gamma = 2) 
    PLOT FLCHAZ(X,2) FOR X = 0.01 0.01 3
    TITLE Fatigue Life Cumulative Hazard (Gamma = 3) 
    PLOT FLCHAZ(X,3) FOR X = 0.1 0.01 3
    TITLE Fatigue Life Cumulative Hazard (Gamma = 0.5) 
    PLOT FLCHAZ(X,0.5) FOR X = 0.2 0.01 3 
    END OF MULTIPLOT 
 
-----FLHAZ (LET)--------------------------------
 
FLHAZ
 
Name:
    FLHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Fatigue Life hazard function with shape parameter
    gamma.  The location parameter (mu) is assumed to be 1 (see
    the NOTE below for information on other location parameters).
 
Description:
    The  Fatigue Life distribution has the following hazard function:
        h(x,gamma) = FLPDF(x,gamma)/(1 - FLCDF(x,gamma)
                     x >= 0, gamma > 0
    where FLPDF is Fatigue Life probability density function, FLCDF is
    the Fatigue Life cumulative distribution function, and gamma is the
    shape parameter.
 
Syntax:
    LET <y> = FLHAZ(<x>,<gamma>)   <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative variable, parameter, or number;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed Fatigue Life hazard value is stored;
          <gamma> is a positive number, parameter, or variable that
               defines the shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = FLHAZ(3,10)
    LET A = FLHAZ(A1,3)
    LET X2 = FLHAZ(X1,GAMMA)

Note:
    The Fatigue Life distribution is symmetric and moderate tailed
    for small gammas.  It is highly skewed and long tailed for large
    gamma.  It approaches normality as gamma approaches zero.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FLCDF  = Compute the Fatigue Life cumulative distribution function.
    FLCHAZ = Compute the Fatigue Life cumulative hazard function.
    FLPDF  = Compute the Fatigue Life probability density function.
    FLPPF  = Compute the Fatigue Life percent point function.
    IGPDF  = Compute the Inverse Gaussian probability density function.
    RIGPDF = Compute the Reciprocal Inverse Gaussian probability
             density function.
    WALPDF = Compute the Wald probability density function.
    CHSPDF = Compute the chi-square probability density function.
    NORPDF = Compute the normal probability density function.
    WEIPDF = Compute the Weibull probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 2", Johnson, Kotz,
    and Balakrishnan, John Wiley, 1994.
 
Applications:
    Reliability
 
Implementation Date:
    1998/4
 
Program:
    MULTIPLOT CORNER COORDINATES 5 5 95 95 
    MULTIPLOT 2 2 
    TITLE CASE ASIS 
    TITLE Fatigue Life Hazard (Gamma = 1) 
    PLOT FLHAZ(X,1) FOR X = 0.01 0.01 3
    TITLE Fatigue Life Hazard (Gamma = 2) 
    PLOT FLHAZ(X,2) FOR X = 0.01 0.01 3
    TITLE Fatigue Life Hazard (Gamma = 3) 
    PLOT FLHAZ(X,3) FOR X = 0.1 0.01 3
    TITLE Fatigue Life Hazard (Gamma = 0.5) 
    PLOT FLHAZ(X,0.5) FOR X = 0.2 0.01 3 
    END OF MULTIPLOT 
 
-----FLIGNER POLICELLO TEST--------------------------------------------
 
FLIGNER POLICELLO TEST
 
Name:
    FLIGNER POLICELLO TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform a two sample Fligner-Policello test for equal medians.
 
Description:
    The Fligner-Policello test for equal medians is a nonparametric
    test based on placement scores.  Given two respoonse variables, say
    Y1 and Y2, the placement score for Y1(i) is defined as the number of
    observations in Y2 that are less than Y1(i).  Likewise, the placement
    score for Y2(i) is the number of observations in Y1 that are less
    than Y2(i).  Values in Y2 that are equal to Y1(i) (or values in Y1
    that are equal to Y2(i)) add 0.5 rather than 1.

    If the placement scores are in P1 and P2, the Fligner-Policello
    test statistic is

        Z = (SUM[j=1 to Ny1][P(Y1(j))] - SUM[i=1 to Ny2][P(Y2(i))])/
            (2*SQRT(Vy1 + Vy2 + Pbar(Y1)*Pbar(Y2)))

    where Pbar(Y1) and Pbar(Y2) are the means of the placement scores

        Pbar(Y1) = (SUM[i=1 to Ny1][P(Y1(i))])/Ny1
        Pbar(Y2) = (SUM[j=1 to Ny2][P(Y2(i))])/Ny2

    and where

        Vy1 = SUM[i=1 to Ny1][(P(Y1(i)) - Pbar(Y1))**2
        Vy2 = SUM[i=1 to Ny2][(P(Y2(i)) - Pbar(Y2))**2
 
    The standard deviations of the placements are
 
        SD(P1) = SQRT(Vy1/(Ny1-1))
        SD(P2) = SQRT(Vy2/(Ny2-1))

    The above test statistic is compared to a standard normal
    distribution.

Syntax 1:
    <LOWER TAILED/UPPER TAILED> FLIGNER POLICELLO TEST <y1> <y2>
                                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If LOWER TAILED is specified, a lower tailed test is performed.  If
    UPPER TAILED is specified, an upper tailed test is performed.  If
    neither LOWER TAILED or UPPER TAILED is specified, a two-tailed test
    is performed.

Syntax 2:
    <LOWER TAILED/UPPER TAILED> FLIGNER POLICELLO TEST
                                <y1>  ... <yk>
                                <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of two or more response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax performs all the two-way Fligner-Policello tests
    for the listed variables.  This syntax supports the TO syntax.

    If LOWER TAILED is specified, a lower tailed test is performed.  If
    UPPER TAILED is specified, an upper tailed test is performed.  If
    neither LOWER TAILED or UPPER TAILED is specified, a two-tailed test
    is performed.

Examples:
    FLIGNER POLICELLO TEST Y1  Y2
    FLIGNER POLICELLO TEST Y1  Y2 Y3
    FLIGNER POLICELLO TEST Y1  TO Y6
    FLIGNER POLICELLO TEST Y1  Y2  SUBSET Y2 > 0
    LOWER TAILED FLIGNER POLICELLO TEST Y1  Y2
    UPPER TAILED FLIGNER POLICELLO TEST Y1  Y2

Note:
    The following parameters are saved after the Fligner-Policello
    test is performed.

         STATVAL   - value of the test statistic
         STATCDF   - CDF of the test statistic
         PVALUE    - p-value of the two tailed test statistic
         PVALUELT  - p-value of the lower tailed test statistic
         PVALUEUT  - p-value of the upper tailed test statistic

         CUTUPP90  - 90%   upper critical value
         CUTUPP95  - 95%   upper critical value
         CUTUP975  - 97.5% upper critical value
         CUTUPP99  - 99%   upper critical value
         CUTUP995  - 99.5% upper critical value
         CUTUP999  - 99.9% upper critical value

         CUTLOW10  - 10%   lower critical value
         CUTLOW05  - 5%    lower critical value
         CUTLO025  - 2.5%  lower critical value
         CUTLOW01  - 1%    lower critical value
         CUTLO005  - 0.5%  lower critical value
         CUTLO001  - 0.1%  lower critical value

Note:
    In addition to the FLIGNER POLICELLO TEST command, the
    following commands can also be used:

        LET STATVAL = FLIGNER POLICELLO TEST        Y1 Y2
        LET STATCDF = FLIGNER POLICELLO TEST CDF    Y1 Y2
        LET PVALUE  = FLIGNER POLICELLO TEST PVALUE Y1 Y2
        LET PVALUE  = FLIGNER POLICELLO LOWER TAIL TEST PVALUE Y1 Y2
        LET PVALUE  = FLIGNER POLICELLO UPPER TAIL TEST PVALUE Y1 Y2

    In addition to the above LET commands, built-in statistics are
    supported for 30+ different commands (enter HELP STATISTICS for
    details).

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    T TEST                  = Perform a 2-sample t-test for location
    RANK SUM TEST           = Perform a 2-sample rank sum test for location
    MEDIAN TEST             = Perform a k-sample medians test
    VAN DER WAERDEN TEST    = Perform a k-sample Van Der Waerden test
    KRUSKAL WALLIS TEST     = Perform a k-sample Kruskal-Wallis test

Applications:
    Two Sample Analysis
 
Implementation Date:
    2023/08:
 
Program:
    . Step 1:   Read the data
    .
    skip 25
    read shoemake.dat y1 y2
    skip 0
    .
    . Step 2:   Generate the statistics
    .
    let statval = fligner policello test                        y1 y2
    let statcdf = fligner policello test cdf                    y1 y2
    let pvalue  = fligner policello test pvalue                 y1 y2
    let pvallt  = fligner policello test lower tail pvalue      y1 y2
    let pvalut  = fligner policello test upper tail pvalue      y1 y2
    let statval = round(statval,2)
    let statcdf = round(statcdf,2)
    let pvalue  = round(pvalue,2)
    let pvallt  = round(pvallt,2)
    let pvalut  = round(pvalut,2)
    .
    print "Fligner-Policello:"
    print "Test Statistic:                        ^statval"
    print "Test Statistic CDF:                    ^statcdf"
    print "Test Statistic P-Value:                ^pvalue"
    print "Test Statistic Lower Tailed P-Value:   ^pvallt"
    print "Test Statistic Upper Tailed P-Value:   ^pvalut"
    .
    . Step 3:   Perform the tests
    .
    fligner policello test                y1 y2
    lower tailed fligner policello test   y1 y2
    upper tailed fligner policello test   y1 y2

-----F LOCATION TEST--------------------------------------------------
 
F LOCATION TEST
 
Name:
    F LOCATION TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform a 1-factor F location test for the homogeneity of
    locations across samples.
 
Description:
    The F location test is actually a simplified 1-factor analysis
    of variance.  Dataplot includes the F location test as a
    distinct command in order to support the MIL-17 Handbook
    standard.  Dataplot supports most of the techniques in
    chapter 8 of the  MIL-17 Handbook as support for the RECIPE fits.

    More formally, the F location test is defined as:

    H0: u(1) = u(2) = ... = u(k)
    Ha: u(i) <> u(j) for at least one set of i and j
    Test Statistic:
       The F location test statistic is:

           F = NUM/DEM
       where 

           NUM = SUM[i=1][k][n(i)(xbar(i) - xbar)**2/(k-1)]
           DEM = SUM[i=1][k][SUM[j=1][n(i)][x(ij) - xbar(i))**2/(n-k)]
       
       where k is the number of samples, xbar is the overall mean,
       xbar(i) is the mean of the ith sample, n(i) is the number of
       observations in group i, and x(ij) is the jth observation
       in the ith group.
    Significance Level: alpha (typically alpha=0.05)
    Criticial Region:
        F > FPPF(1 - alpha, k-1, n-k) where FPPF
        is the percent point function of the F distribution with
        k-1 and n-k degrees of freedom.

Syntax:
    F LOCATION TEST <y> <groupid>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <groupid> is group (sample) identifier variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    F LOCATION TEST Y1  GROUP
    F LOCATION TEST Y1  GROUP  SUBSET GROUP > 2
 
Note:
    The various values printed by the F LOCATION TEST command are
    saved as parameters that can be used later by the analyst.
    Specifically, the following parameters are saved:
 
       STATVAL   = value of F location test statistic
       STATCDF   = F CDF value of F location test statistic
       CUTOFF0   = F percent point value (p=0)
       CUTOFF50  = F percent point value (p=.50)
       CUTOFF75  = F percent point value (p=.75)
       CUTOFF90  = F percent point value (p=.90)
       CUTOFF95  = F percent point value (p=.95)
       CUTOFF99  = F percent point value (p=.99)
       CUTOF999  = F percent point value (p=.999)
 
    Some of these parameters were not saved correctly in
    versions of Dataplot prior to 2000/9.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LEVENE TEST     = Compute Levene's test.
    BOX PLOT        = Generate a box plot.
    RECIPE FIT      = Perform a RECIPE analysis.
    GRUBBS TEST     = Compute a Grubbs test for outliers.
    ANOVA           = Perform an analysis of variance.

Reference:
    "MIL-HDBK-17 Volume 1: Guidelines for Characterization of
    Structural Materials", Depeartment of Defense, chapter 8.
    The URL for MIL-HDBK-17 is http://mil-17.udel.edu/.
 
Applications:
    Tolerance Studies in Reliability of Materials
 
Implementation Date:
    1997/12
 
Program:
    SKIP 25
    READ VANGEL32.DAT Y X B
    F LOCATION TEST Y X
    STATUS PARAMETERS
 
    The following output is generated:

  
           *******************************
           **      F LOCATION TEST Y X  **
           *******************************
      
      
                   F-TEST FOR SHIFT IN LOCATION
                      (ASSUMPTION: NORMALITY)
      
     1. STATISTICS
           NUMBER OF OBSERVATIONS    =       45
           NUMBER OF GROUPS          =        3
           F LOCATION TEST STATISTIC   =    45.30679
      
      
        FOR F LOCATION TEST STATISTIC
           0          % POINT    =    .0000000
           50         % POINT    =    .7047137
           75         % POINT    =    1.433075
           90         % POINT    =    2.433564
           95         % POINT    =    3.219942
           99         % POINT    =    5.149140
           99.9       % POINT    =    8.179383
      
      
              100.0000       % Point:     45.30679
      
     3. CONCLUSION (AT THE 5% LEVEL):
           THERE IS A SHIFT IN LOCATION.
           THUS: NOT HOMOGENOUS WITH RESPECT TO LOCATION.
      
      
           *****************************
           **      STATUS PARAMETERS  **
           *****************************
      
      
      
     PARAMETER INFINITY  HAS THE VALUE:      .3340000E+39
     PARAMETER PI        HAS THE VALUE:      .3141593E+01
     PARAMETER STATVAL   HAS THE VALUE:      .4530679E+02
     PARAMETER STATCDF   HAS THE VALUE:      .1000000E+01
     PARAMETER CUTOFF0   HAS THE VALUE:      .0000000E+00
     PARAMETER CUTOFF50  HAS THE VALUE:      .7047137E+00
     PARAMETER CUTOFF75  HAS THE VALUE:      .1433075E+01
     PARAMETER CUTOFF90  HAS THE VALUE:      .2433564E+01
     PARAMETER CUTOFF95  HAS THE VALUE:      .3219942E+01
     PARAMETER CUTOFF99  HAS THE VALUE:      .0000000E+00
     PARAMETER CUTOF999  HAS THE VALUE:      .0000000E+00
  
-----FLPDF (LET)--------------------------------
 
FLPDF
 
Name:
    FLPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Fatigue Life probability density function with shape
    parameter gamma.  The location parameter (mu) is assumed to be 1
    (see the NOTE below for information on other location parameters).
 
Description:
    The  Fatigue Life distribution has the following probability
    density function:
        pdf(x) = (IGPDF(X,GAMMA) + RIGPDF(X,GAMMA))/2
               = ((1+X)/2)*IGPDF(X,GAMMA)
    where IGPDF is Inverse Gausian distribution function, RIGPDF is the
    Reciprocal Inverse Gaussian distribution function, and GAMMA is the
    shape parameter.  It is defined for any non-negative real number.
    It has mean MU (see NOTE below) and standard deviation
    MU*GAMMA*SQRT(1+(5/4)*GAMMA**2).
 
    The FLPDF function evaluates this function for a given x value.
 
Syntax:
    LET <y2> = FLPDF(<y1>,GAMMA)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed Fatigue Life pdf value is stored;
          <GAMMA> is a positive integer (the shape parameter);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = FLPDF(3,10)
    LET A = FLPDF(A1,10)
    LET X2 = FLPDF(X1,10)
 
Note:
    The Fatigue Life distribution is symmetric and moderate tailed
    for small gammas.  It is highly skewed and long tailed for large
    gamma.  It approaches normality as gamma approaches zero.
 
Note:
    DATAPLOT computes this distribution for the case where MU = 1.
    For other values of MU, scale up by the MU parameter.  That is,
         LET Y = FLPDF(MU*X,GAMMA)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
    FCDF   = Compute the F cumulative distribution function.
    FPDF   = Compute the F probability density function.
    FPPF   = Compute the F percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    TCDF   = Compute the T cumulative distribution function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    WALPDF = Compute the Wald probability density function.
    WALPPF = Compute the Wald percent point function.
    WALCDF = Compute the Wald cumulative distribution function.
    FLPPF  = Compute the Fatigue Life percent point function.
    FLCDF  = Compute the Fatigue Life cumulative distribution function.
    IGPDF  = Compute the Inverse Gaussian probability density function.
    IGPPF  = Compute the Inverse Gaussian percent point function.
    IGCDF  = Compute the Inverse Gaussian cumulative distribution
             function.
    RIGPDF = Compute the Reciprocal Inverse Gaussian probability
             density function.
    RIGPPF = Compute the Reciprocal Inverse Gaussian percent point
             function.
    RIGCDF = Compute the Reciprocal Inverse Gaussian cumulative
             distribution function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, 1970.
 
Applications:
    Reliability
 
Implementation Date:
    90/5
 
Program:
    TITLE PLOT FLPDF FOR VARIOUS VALUES OF GAMMA
    SEGMENT 1 COORDINATES 69 88 74 88; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 69 84 74 84; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 69 80 74 80; SEGMENT 3 PATTERN DOT
    SEGMENT 4 COORDINATES 69 76 74 76; SEGMENT 4 PATTERN DASH2
    LEGEND 1 GAMMA = 1; LEGEND 1 COORDINATES 75 87
    LEGEND 2 GAMMA = 2; LEGEND 2 COORDINATES 75 83
    LEGEND 3 GAMMA = 5; LEGEND 3 COORDINATES 75 79
    LEGEND 4 GAMMA = .5; LEGEND 4 COORDINATES 75 75
    LINES SOLID DASH DOT DASH2
    YLIMITS 0 1.2; MAJOR YTIC MARK NUMBER 4; YTIC OFFSET 0 0.1
    PLOT FLPDF(X,1) FOR X = 0.01 0.01 3 AND
    PLOT FLPDF(X,2) FOR X = 0.01 0.01 3 AND
    PLOT FLPDF(X,5) FOR X = 0.1 0.01 3 AND
    PLOT FLPDF(X,0.5) FOR X = 0.2 0.01 3
 
-----FLPPF (LET)--------------------------------
 
FLPPF
 
Name:
    FLPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Fatigue Life percent point function with shape
    parameter gamma.  The location parameter (mu) is assumed to be 1
    (see the NOTE below for information on other location parameters).
 
Description:
    The  Fatigue Life distribution has the following probability
    density function:
        pdf(x) = (IGPDF(X,GAMMA) + RIGPDF(X,GAMMA))/2
               = ((1+X)/2)*IGPDF(X,GAMMA)
    where IGPDF is Inverse Gausian distribution function, RIGPDF is the
    Reciprocal Inverse Gaussian distribution function, and GAMMA is the
    shape parameter.  It is defined for any non-negative real number.
    It has mean MU (see NOTE below) and standard deviation
    MU*GAMMA*SQRT(1+(5/4)*GAMMA**2).
 
    The percent point function is the inverse of the cumulative
    distribution function.  The cumulative distribution sums the
    probability from 0 to the given x value.  The percent point
    function takes a cumulative probability value and computes the
    corresponding x value.
 
Syntax:
    LET <y2> = FLPPF(<y1>,GAMMA)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter in the range 0 to 1;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed Fatigue Life ppf values is stored;
          <GAMMA> is a positive integer (the shape parameter);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = FLPPF(0.9,10)
    LET A = FLPPF(A1,10)
    LET X2 = FLPPF(X1,10)
 
Note:
    The Fatigue Life distribution is symmetric and moderate tailed
    for small gammas.  It is highly skewed and long tailed for large
    gamma.  It approaches normality as gamma approaches zero.
 
Note:
    DATAPLOT computes this distribution for the case where MU = 1.
    For other values of MU, scale up by the MU parameter.  That is,
         LET Y = FLPPF(MU*X,GAMMA)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPDF = Compute the chi-square probability density function.
    FCDF   = Compute the F cumulative distribution function.
    FPDF   = Compute the F probability density function.
    FPPF   = Compute the F percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    TCDF   = Compute the T cumulative distribution function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    WALPDF = Compute the Wald probability density function.
    WALPPF = Compute the Wald percent point function.
    WALCDF = Compute the Wald cumulative distribution function.
    FLPDF  = Compute the Fatigue Life probability density function.
    FLCDF  = Compute the Fatigue Life cumulative distribution function.
    IGPDF  = Compute the Inverse Gaussian probability density function.
    IGPPF  = Compute the Inverse Gaussian percent point function.
    IGCDF  = Compute the Inverse Gaussian cumulative distribution
             function.
    RIGPDF = Compute the Reciprocal Inverse Gaussian probability
             density function.
    RIGPPF = Compute the Reciprocal Inverse Gaussian percent point
             function.
    RIGCDF = Compute the Reciprocal Inverse Gaussian cumulative
             distribution function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, 1970.
 
Applications:
    XX
 
Implementation Date:
    90/5
 
Program:
    TITLE PLOT FLPPF FOR VARIOUS VALUES OF GAMMA
    SEGMENT 1 COORDINATES 16 88 21 88; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 16 84 21 84; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 16 80 21 80; SEGMENT 3 PATTERN DOT
    SEGMENT 4 COORDINATES 16 76 21 76; SEGMENT 4 PATTERN DASH2
    LEGEND 1 GAMMA = 1; LEGEND 1 COORDINATES 22 87
    LEGEND 2 GAMMA = 2; LEGEND 2 COORDINATES 22 83
    LEGEND 3 GAMMA = 5; LEGEND 3 COORDINATES 22 79
    LEGEND 4 GAMMA = 0.5; LEGEND 4 COORDINATES 22 75
    XLIMITS 0 1; MAJOR XTIC NUMBER 6
    MINOR XTIC NUMBER 1; XTIC DECIMAL 1
    LINES SOLID DASH DOT DASH2
    . YLIMITS 0 5; MAJOR YTIC MARK NUMBER 6; YTIC OFFSET 0 0.3
    PLOT FLPPF(X,1) FOR X = 0.01 .01 0.99 AND
    PLOT FLPPF(X,2) FOR X = 0.01 .01 0.90 AND
    PLOT FLPPF(X,5) FOR X = 0.01 .01 0.70 AND
    PLOT FLPPF(X,0.5) FOR X = 0.01 .01 0.90
 
-----FLOOR (LET)--------------------------------
 
FLOOR
 
Name:
    FLOOR (LET)
 
Type:
    Library Function
 
Purpose:
    Return the integer portion of a number or variable rounded to
    negative infinity.
 
Syntax:
    LET <y2> = FLOOR(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1>
               is) where the computed integer values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = FLOOR(2.83)
    LET A = FLOOR(A1)
    LET X2 = FLOOR(X1)
    LET X2 = FLOOR(X1-4.2)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    STEP
 
Related Commands:
    CEIL   = Compute the integer value rounded to positive infinity.
    INT    = Compute the integer value rounded to zero.
    SIGN   = Compute the sign of a number.
    FRACT  = Compute the fractional portion of number.
    MSD    = Compute the most significant digit of a number.
    ROUND  = Round to the closest integer of a number.
 
Applications:
    Elementary function
 
Implementation Date:
    95/4
 
Program:
    LET Y1 = SEQUENCE -5 0.1 5
    LET Y2 = FLOOR(Y1)
    PRINT Y1 Y2
 
-----FLUCTUATION PLOT (LET)--------------------------------
 
FLUCTUATION PLOT
 
Name:
    FLUCTUATION PLOT (LET)
 
Type:
    Graphics Command
 
Purpose:
    Generate a fluctuation plot.

Description:
    The fluctuation plot is a variant of the mosaic plot.  The mosaic
    plot was proposed by John Hartigan as a method for visualizing the
    counts from contingency tables.  In the mosaic plot, a rectangle is
    drawn for every combination of categories where the area of the
    rectangle is proportional to the count.  To construct a mosaic plot,
    the following is done.

        1) The horizontal axis is divided according to the category
           counts of the first variable.

        2) If there is a second variable, then each vertical column is
           divided according to the counts of the second variable.

        3) If there are more than two variables, repeat steps 1 and 2
           according to the counts for each additional variable.  That
           is, each rectangle created in steps 1 and 2 is further
           sub-divided horizontally and vertically for the third and
           fourth variables.  This subdivision is repeated until all
           variables have been used.

    For the fluctuation plot, a grid is created so that is each
    combination of categories has a fixed position on the grid.

    At each grid position, two rectangles are drawn.  The first
    is drawn in a background color and is full size (i.e., the
    maximum count).  A second rectangle is drawn in a foreground
    color with a height proportional to the count for that particular
    combination of categories.  The background rectangle is drawn to
    give a sense of scale.  If you do not want this background
    rectangle, then set the color equal to the background color
    of the plot.

    Some analysts find the format of the flucuation plot easier to
    interpret than the mosaic plot.

    Although the mosaic and fluctuation plots were developed to
    visualize counts for categorical data, Dataplot can also
    generate the fluctuation plot for various statistics.  For example,
    you could use it to display mean values for several factor
    variables.  In particular, we have found it useful for displaying
    binomial probabilities.  For displaying the value of a statistic, the
    minimum value of the statistic over all combinations of categories
    will be drawn with zero height and the maximum value of the
    statistic over all categories will be drawn at the full height.
    Intermediate values will be scaled between the minimum and maximum
    values.

    The list of supported statistics can be obtained by entering

          HELP STATISTICS

    By default, the FLUCTUATION PLOT generates a single foreground
    color.  The CONTOUR option (see syntax 4) allows the foreground
    color to be set based on the value of the statistic relative
    to a "levels" variable (this borrows from the TABULATION PLOT--enter
    HELP TABULATION PLOT for details).  For example, you can specify
    two colors based on whether the statistic is above or below some
    threshold value.  Alternatively, you can also use the CONTOUR
    option to provide additional guidance on the value of the
    statistic.

Syntax 1:
    FLUCTUATION COUNT PLOT <x1> ... <xk>
                      <SUBSET/EXCEPT/FOR qualification>
    where <x1> ... <xk> is a list of one to six categorical variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax is used for the case where you have raw data (i.e., the
    data has not yet been cross tabulated) and the statistic of
    interest is the number of observations in each cell.

Syntax 2:
    FLUCTUATION <stat> PLOT <y1> ... <y3>  <x1> ... <xk>
                       <SUBSET/EXCEPT/FOR qualification>
    where <stat> is one of the supported statistics;
          <y1> ... <y3> is a list of one to three response variables
               (depending on how many variables <stat> requires);
          <x1> ... <xk> is a list of one to six categorical variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax is used for the case where you have raw data (i.e., the
    data has not yet been cross tabulated) and you are computing a
    statistic that requires one to three response variables.

Syntax 3:
    FLUCTUATION PLOT <m>    <SUBSET/EXCEPT/FOR qualification>
    where <m> is a matrix containing a two-way table;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax is used for the case where the data have already
    been cross-tabulated into a two-way table.  Although this is
    typically used for the COUNTS case, the table can in fact
    contain values for any statistic that has been previously
    cross-tabulated.

Syntax 4:
    FLUCTUATION <stat> CONTOUR PLOT <y1> ... <y3>  <x1> ... <xk> <ylevel>
                       <SUBSET/EXCEPT/FOR qualification>
    where <stat> is one of the supported statistics;
          <y1> ... <y3> is a list of one to three response variables
               (depending on how many variables <stat> requires);
          <x1> ... <xk> is a list of one to six categorical variables;
          <ylevel> is a variable that defines levels for the value of
               the statistic;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax can be used to specify different foreground colors
    based on the value of the statistic.

Examples:
    FLUCTUATION COUNT PLOT X1 X2 X3 X4
    FLUCTUATION BINOMIAL PROBABILITY PLOT Y X1 X2
    FLUCTUATION PLOT M

Note:
    When there is a single categorical variable, the division
    is performed horizontally.

    When there are two or more categorical variables, the division
    is first performed vertically, then horizontally.  This
    vertical/horizontal subdivision is repeated until all the
    categorical variables are accommodated.

    When there are two or more categorical variables, you can
    change the vertical/horizontal order to horizontal/vertical
    by entering the command

       SET FLUCTUATION PLOT DIRECTION X

    To restore the default order, enter

       SET FLUCTUATION PLOT DIRECTION Y

Note:
    In some cases, a few extreme values may dominate the plot.  You
    can specify minimum or maximum values with the commands

       SET FLUCTUATION PLOT FLOOR <value>
       SET FLUCTUATION PLOT CEILING <value>

    Values less than the floor value will be set to the floor value
    and values greater than the ceiling value are set to the ceiling
    value.

    The default is to use the minimum and maximum values of the
    computed statistic.  For the COUNT case, the floor value will
    be set to 0.  For the BINOMIAL PROBABILITY case, the floor and
    ceiling values will be set to 0 and 1, respectively.

    After the fluctuation plot is generated, Dataplot will save the
    internal parameters STATMINI and STATMAXI that contain the
    minimum and maximum values, respectively, of the computed
    statistic.

Note:
    By default, the width of the bars in the fluctuation plot are
    of constant width.  If you want the width of the bars to be
    proportional to the sample size for each combination of
    categories, enter the command

       SET FLUCTUATION PLOT WIDTH PROPORTIONAL

    To reset fixed width bars, enter the command

       SET FLUCTUATION PLOT WIDTH FIXED

    This option does not apply to the case where the statistic
    being computed is the frequency counts (COUNT).  In this case,
    the height of the bars already indicates the frequency counts.

Note:
    The example programs below demonstrate how to control the
    color for the bars in the fluctuation plot and also how to
    label the levels of the categories.

Note:
    For the following statistics

        BINOMIAL PROPORTION
        BINOMIAL RATIO
        MEAN
        MEDIAN
        DIFFERENCE OF MEAN
        DIFFERENCE OF BINOMIAL PROPORTION

    added the following command

       SET FLUCTUATION PLOT UNCERTAINTY INTERVAL <ON/OFF>

    If this option is set to ON, there are three rectangles that
    are drawn:

       1) The background rectangle is drawn as in the default
          case.

       2) A rectangle where the upper Y coordinate is the upper
          confidence limit and the lower Y coordinate is the lower
          confidence limit.

       3) A line is drawn at the point estimate.  In addition, a
          symbol (defined by the CHARACTER command) is also drawn 
          at the point estimate.

    In the default case, we set the color of the rectangles
    using the following commands (where the colors are set to
    your taste)

       line color g75 black
       region fill color g75 black
       region border color g75 black

    If the uncertainty option is set to on, we set the color of the
    three rectangles using the following commands (where again the
    colors are set to your taste)

       line color g75 red blue
       region fill color g75 red blue
       region border color g75 red blue

    The first 2 colors specify the background color for the rectangles
    below and above the statistic value, respectively.  Colors 3 and 4
    specify the foreground colors for the rectangles below and above
    the statistic value, respectively.  Typically we recommend that
    the same color be used as in the above example.

    By default, alpha is set to 0.05 for computing the uncertainty
    intervals.  To use a different value of alpha, enter

        LET ALPHA = 0.1

Note:
    By default, each factor variable is coded from 1 to NDIST with NDIST
    denoting the number of levels (i.e., distinct values for that factor
    variable).

    When some of the combinations of levels for the factor variables are
    missing, it is desirable to suppress this coding.

    The following command was added in order to specify whether or not
    this coding is applied:

       SET FLUCTUATION PLOT CODED <ON/OFF>

    Setting this option to OFF will use the original units for the factor
    variables.  Setting this option to ON (the default)  will used the
    coded values from 1 to NDIST.

Note:
    For the case where there are exactly two cross tabulation
    variables, it may be desirable to sort the rows and columns
    based on the value of the statistic.  This can be specified
    with the following commands

       SET FLUCTUATION SORTED ON
       SET FLUCTUATION SORTED OFF
       SET FLUCTUATION SORTED ROW
       SET FLUCTUATION SORTED COLUMN

    ON specifies that both the column and row direction will be
    sorted, OFF (the default) specifies that neither direction
    will be sorted, ROW specifies that the vertical direction
    will be sorted, and COLUMN specifies that the horizontal
    direction will be sorted.

    You can specify whether the sort is an ascending (the default)
    or a descending sort by entering the commands

       SET FLUCTUATION PLOT COLUMN SORT DIRECTION <ASCENDING/DESCENDING>
       SET FLUCTUATION PLOT ROW    SORT DIRECTION <ASCENDING/DESCENDING>

Note:
    Normally, the BINOMIAL PROPORTION or BINOMIAL RATIO statistics
    are based on then point estimate of the binomial probability.
    However, there may be occassions where you want to plot either
    the lower or the upper confidence limit.  You can specify this
    with the commands

       SET FLUCTUATION CONTOUR BINOMIAL PROPORTION POINT
       SET FLUCTUATION CONTOUR BINOMIAL PROPORTION LOWER
       SET FLUCTUATION CONTOUR BINOMIAL PROPORTION UPPER

Default:
    None
 
Synonyms:
    None

Related Commands:
    TABULATION PLOT               = Generate a tabulation plot.
    STATISTIC PLOT                = Generate a statistic versus subsample
                                    plot for one index variable.
    CROSS TABULATE PLOT           = Generate a statistic versus subsample
                                    plot for two index variables.
    ASSOCIATION PLOT              = Generate an association plot.
    SIEVE PLOT                    = Generate a sieve plot.
    ROSE PLOT                     = Generate a Rose plot.
    BINARY TABULATION PLOT        = Generate a binary tabulation plot.
    ROC CURVE                     = Generate a ROC curve.
    CROSS TABULATE                = Perform a cross-tabulation.
    CHI-SQUARE INDEPENDENCE TEST  = Perform a chi-square test for
                                    independence.
    ODDS RATIO INDEPENDENCE TEST  = Perform a log(odds ratio) test for
                                    independence.
    FISHER EXACT TEST             = Perform Fisher's exact test.
    ODDS RATIO                    = Compute the bias corrected odds ratio.
    LOG ODDS RATIO                = Compute the bias corrected
                                    log(odds ratio).

Reference:
    Unwin, Theus, and Hofmann (2006), "Graphics of Large Data
    Sets: Visualizing a Million", Springer, chapter 5.

    Friendly (2000), "Visualizing Categorical Data", SAS Institute
    Inc., p. 90.

Applications:
    Graphical Analysis of Categorical Data
 
Implementation Date:
    2009/01
    2009/09: Added uncertainty option for several statistics
    2010/07: Added contour option
    2017/11: Added uncertainty option for difference of means statistic
    2017/11: Added uncertainty option for difference of binomial
             proportion statistic
 
Program 1:
    .  Example from page 61 of Friendly
    .  Data denotes counts.
    read matrix m
     5  29 14 16
    15  54 14 10
    20  84 17 94
    68 119 26 7
    end of data
    .
    label case asis
    tic mark label case asis
    title case asis
    title offset 2
    .
    x3label
    title Fluctuation Plot
    y1label Eye Color
    x1label Hair Color
    tic offset units data
    xlimits 1 4
    major xtic mark number 4
    minor xtic mark number 0
    xtic mark offset 1 1
    x1tic mark label format alpha
    x1tic mark label content Black Brown Red Blond
    ylimits 1 4
    major ytic mark number 4
    minor ytic mark number 0
    ytic mark offset 1 1
    y1tic mark label format alpha
    y1tic mark label content Green Hazel Blue Brown
    y1tic mark label justification right
    .
    line color g75 black
    region fill color g75 black
    region border color g75 black
    .
    fluctuation plot m

Program 2:
    skip 25
    read alarm.dat inst src expalarm obsalarm
    let n = size expalarm
    let correct = 0 for i = 1 1 n
    let correct = 1 subset expalarm = 0 subset obsalarm = 0
    let correct = 1 subset expalarm = 1 subset obsalarm = 1
    .
    label case asis
    tic mark label case asis
    title case asis
    title offset 2
    .
    x3label
    title Fluctuation Plot of Binomial Probability for Correct Alarm
    y1label Instrument
    x1label Source
    tic offset units data
    xlimits 1 6
    major xtic mark number 6
    minor xtic mark number 0
    xtic mark offset 1 1
    ylimits 1 15
    major ytic mark number 15
    minor ytic mark number 0
    ytic mark offset 1 1
    .
    line color g75 black
    region fill color g75 black
    region border color g75 black
    .
    set fluctuation plot width proportional
    fluctuation binomial probability plot correct inst src

Program 3:
    skip 25
    read ripken.dat y x1 to x4
    .
    label case asis
    tic mark label case asis
    title case asis
    .
    x3label
    title Fluctuation Plot for Cal Ripken Mean Batting Average
    let string v1 = Low
    let string v2 = Middle
    let string v3 = Lefts:sp()High
    let string v4 = Low
    let string v5 = Middle
    let string v6 = Right:sp()High
    let igy = group label v1 to v6
    let string h1 = Inside
    let string h2 = Middlecr()Fastball
    let string h3 = Outside
    let string h4 = Inside
    let string h5 = Middlecr()Curveball
    let string h6 = Right
    let igx = group label h1 to h6
    .
    tic offset units data
    xlimits 1 6
    major xtic mark number 6
    minor xtic mark number 0
    xtic mark offset 1 1
    x1tic mark label format group label
    x1tic mark label content igx
    ylimits 1 6
    major ytic mark number 6
    minor ytic mark number 0
    ytic mark offset 1 1
    y1tic mark label format group label
    y1tic mark label content igy
    y1tic mark label justification right
    .
    line color g75 black
    region fill color g75 black
    region border color g75 black
    .
    fluctuation mean plot y x2 x1 x4 x3
    .
    move 50 92
    just center
    text (Minimun BA: ^statmini, Maximum BA: ^statmaxi)

Program 4:
    skip 25
    read alarm.dat inst src expalarm obsalarm
    let n = size expalarm
    let correct = 0 for i = 1 1 n
    let correct = 1 subset expalarm = 0 subset obsalarm = 0
    let correct = 1 subset expalarm = 1 subset obsalarm = 1
    .
    label case asis
    tic mark label case asis
    title case asis
    title offset 2
    frame corner coordinates 10 20 80 90
    .
    x3label
    title Binomial Probability for Correct Alarm
    y1label Instrument
    x1label Source
    tic offset units data
    xlimits 1 6
    major xtic mark number 6
    minor xtic mark number 0
    xtic mark offset 0.6 0.6
    ylimits 1 15
    major ytic mark number 15
    minor ytic mark number 0
    ytic mark offset 1 1
    y1label displacement 7
    .
    let p10 = 0.7
    let p20 = 1.01
    let ylevel = data p10 p20
    .
    line color g75 red dgreen
    region fill color g75 red dgreen
    region border color g75 red dgreen
    .
    set fluctuation plot width proportional
    fluctuation binomial probability contour plot correct inst src ylevel
    .
    let p1 = 0.20
    let p2 = 0.40
    let p3 = 0.60
    let p4 = 0.80
    let p5 = 1.01
    let ylevel = data p1 p2 p3 p4 p5
    let ncolor = 5
    let string color1 = red
    let string color2 = orange
    let string color3 = cyan
    let string color4 = blue
    let string color5 = dgreen
    region fill on all
    region fill color g75 ^color1 ^color2 ^color3 ^color4 ^color5
    region border color g75 ^color1 ^color2 ^color3 ^color4 ^color5
    line color g75 ^color1 ^color2 ^color3 ^color4 ^color5
    .
    fluctuation binomial probability contour plot correct inst src ylevel
    .
    box fill pattern solid
    box shadow hw 0 0
    justification left
    height 1.7
    .
    let xcoor1 = 81
    let xcoor2 = 85
    let xcoor3 = xcoor2 + 1
    let ycoor1 = 90
    let yinc   = 4
    let ycoor2 = ycoor1 - yinc
    .
    let kind = ncolor
    loop for k = 1 1 ncolor
        box fill color ^color^kind
        box xcoor1 ycoor1 xcoor2 ycoor2
        let ycoor3 = ycoor2 + 1
        move xcoor3 ycoor3
        let km1 = kind - 1
        let aval1 = ^p^km1
        let aval2 = ^p^kind
        let aval2 = min(1,aval2)
        if k < ncolor
           if k = 1
              text ^aval1 - ^aval2
           else
              text ^aval1 - ^aval2
           end of if
        else
           text <= ^aval1
        end of if
        let ycoor1 = ycoor2
        let ycoor2 = ycoor1 - yinc
        let kind = kind - 1
    end of loop

-----FNRCDF (LET)--------------------------------
 
FNRCDF
 
Name:
    FNRCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard folded normal cumulative distribution
    function.
 
Description:
    If X is normally distributed, then ABS(X) has a folded normal
    distribution.  The folded normal cumulative distribution can be
    expressed in terms of the standard normal cumulative
    distribution as:
       F(x,mu,sigma) = (1/sigma)*(NORCDF((x-mu)/sigma) -
                       NORCDF((-x-mu)/sigma))       x >= 0
    where NORCDF is the cumulative distribution function of a
    standard normal distribution and mu and sigma are the location
    and scale parameters of the parent normal distribution.  They are
    shape parameters for the folded normal distribution.  If mu
    is zero, the folded normal distribution reduces to a
    half-normal distribution.
 
Syntax:
    LET <y> = FNRCDF(<x>,<u>,<s>)   <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed folded normal cdf value is stored;
          <u> is a number, parameter, or variable that defines the
               location parameter of the parent normal distribution;
          <s> is a number, parameter, or variable that defines the
               scale parameter of the parent normal distribution;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = FNRCDF(3,2,0.7)
    LET X2 = FNRCDF(X1,U,SD)
 
Note:
    The folded normal distribution is typically used when
    measurements are taken without regard to sign and the
    underlying distribution is assumed to be normal.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FNRPDF = Compute the folded normal probability density
             function.
    FNRPPF = Compute the folded normal percent point function.
    FCAPDF = Compute the folded Cauchy probability density
             function.
    FCAPPF = Compute the folded normal percent point function.
    HCAPDF = Compute the half Cauchy probability density function.
    CAUCDF = Compute the Cauchy cumulative distribution function.
    CAUPDF = Compute the Cauchy probability density function.
    CAUPPF = Compute the Cauchy percent point function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    1996/1
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LET U = 0.5
    LET SD = 6
    X1LABEL U = ^U, SD = ^SD
    PLOT FNRCDF(X,U,SD) FOR X = 0  0.01 20
    LET U = 6
    LET SD = 0.5
    X1LABEL U = ^U, SD = ^SD
    PLOT FNRCDF(X,U,SD) FOR X = 0  0.01 8
    LET U = 2
    LET SD = 10
    X1LABEL U = ^U, SD = ^SD
    PLOT FNRCDF(X,U,SD) FOR X = 0  0.01 50
    LET U = 3
    LET SD = 2
    X1LABEL U = ^U, SD = ^SD
    PLOT FNRCDF(X,U,SD) FOR X = 0  0.01 10
    END OF MULTIPLOT

-----FNRPDF (LET)--------------------------------
 
FNRPDF
 
Name:
    FNRPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard folded normal probability density
    function.
 
Description:
    If X is normally distributed, then ABS(X) has a folded normal
    distribution.  The folded normal distribution can be expressed
    in terms of the standard normal distribution as:
       f(x,mu,sigma) = (1/sigma)*(NORPDF((x-mu)/sigma) +
                       NORPDF((x+mu)/sigma))       x >= 0
    where NORPDF is the probability density function of a standard
    normal distribution and mu and sigma are the location and
    scale parameters of the parent normal distribution.  They are
    shape parameters for the folded normal distribution.  If mu
    is zero, the folded normal distribution reduces to a
    half-normal distribution.
 
Syntax:
    LET <y> = FNRPDF(<x>,<u>,<s>)   <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed folded normal pdf value is stored;
          <u> is a number, parameter, or variable that defines the
               location parameter of the parent normal distribution;
          <s> is a number, parameter, or variable that defines the
               scale parameter of the parent normal distribution;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = FNRPDF(3,2,0.7)
    LET X2 = FNRPDF(X1,U,SD)
 
Note:
    The folded normal distribution is typically used when
    measurements are taken without regard to sign and the
    underlying distribution is assumed to be normal.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FNRCDF = Compute the folded normal cumulative distribution
             function.
    FNRPPF = Compute the folded normal percent point function.
    FCAPDF = Compute the folded Cauchy probability density
             function.
    FCAPPF = Compute the folded normal percent point function.
    HCAPDF = Compute the half Cauchy probability density function.
    CAUCDF = Compute the Cauchy cumulative distribution function.
    CAUPDF = Compute the Cauchy probability density function.
    CAUPPF = Compute the Cauchy percent point function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    1996/1
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LET U = 0.5
    LET SD = 6
    X1LABEL U = ^U, SD = ^SD
    PLOT FNRPDF(X,U,SD) FOR X = 0  0.01 20
    LET U = 6
    LET SD = 0.5
    X1LABEL U = ^U, SD = ^SD
    PLOT FNRPDF(X,U,SD) FOR X = 0  0.01 8
    LET U = 2
    LET SD = 10
    X1LABEL U = ^U, SD = ^SD
    PLOT FNRPDF(X,U,SD) FOR X = 0  0.01 50
    LET U = 3
    LET SD = 2
    X1LABEL U = ^U, SD = ^SD
    PLOT FNRPDF(X,U,SD) FOR X = 0  0.01 10
    END OF MULTIPLOT

-----FNRPPF (LET)--------------------------------
 
FNRPPF
 
Name:
    FNRPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard folded normal percent point function.
 
Description:
    If X is normally distributed, then ABS(X) has a folded normal
    distribution.
 
    The folded normal percent point function is computed
    numerically using a bisection method.

Syntax:
    LET <y> = FNRPPF(<p>,<u>,<s>)   <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, a number, or a parameter in the interval
               (0,1);
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed folded normal ppf value is stored;
          <u> is a number, parameter, or variable that defines the
               location parameter of the parent normal distribution;
          <s> is a number, parameter, or variable that defines the
               scale parameter of the parent normal distribution;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = FNRPPF(0.95,2,0.7)
    LET X2 = FNRPPF(P1,U,SD)
 
Note:
    The folded normal distribution is typically used when
    measurements are taken without regard to sign and the
    underlying distribution is assumed to be normal.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FNRCDF = Compute the folded normal cumulative distribution
             function.
    FNRPDF = Compute the folded normal probability density function.
    FCAPDF = Compute the folded Cauchy probability density
             function.
    FCAPPF = Compute the folded normal percent point function.
    HCAPDF = Compute the half Cauchy probability density function.
    CAUCDF = Compute the Cauchy cumulative distribution function.
    CAUPDF = Compute the Cauchy probability density function.
    CAUPPF = Compute the Cauchy percent point function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    1996/1
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LET U = 0.5
    LET SD = 6
    X1LABEL U = ^U, SD = ^SD
    PLOT FNRPPF(P,U,SD) FOR P = 0  0.01 0.99
    LET U = 6
    LET SD = 0.5
    X1LABEL U = ^U, SD = ^SD
    PLOT FNRPPF(P,U,SD) FOR P = 0  0.01 0.99
    LET U = 2
    LET SD = 10
    X1LABEL U = ^U, SD = ^SD
    PLOT FNRPPF(P,U,SD) FOR P = 0  0.01 0.99
    LET U = 3
    LET SD = 2
    X1LABEL U = ^U, SD = ^SD
    PLOT FNRPPF(P,U,SD) FOR P = 0  0.01 0.99
    END OF MULTIPLOT

-----FONT-------------------------------------------------------
 
FONT
 
Name:
    FONT
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Specifies the font
    1) of script resulting from the TEXT command to appear on diagrams;
    2) of script appearing in titles, labels and legends (resulting
       from the  TITLE, LABEL, and LEGEND) to appear on subsequent
       plots.
 
Description:
    The following fonts are permitted:
       TEKTRONIX
       SIMPLEX
       DUPLEX
       TRIPLEX
       TRIPLEX ITALIC
       COMPLEX
       SIMPLEX SCRIPT
       COMPLEX SCRIPT
    Specifying TEKTRONIX means to use the hardware characters on a
    given device.  Hardware characters can have a very different
    appearance on different graphics devices.  The other 7 fonts are
    standard Hershey fonts (as defined by Alan Hershey of the National
    Institute of Standards and Technology).  Hershey fonts are stroked
    vector fonts (i.e., they are generated with move and draw
    commands).  They can be scaled to any size and drawn at an
    arbitrary angle.
 
    At this time, DATAPLOT does not provide any built-in typeset
    quality fonts.  However, these can be generated on a few specific
    devices (see the NOTE below).
 
Syntax:
    FONT   <font>
    where <font> specifies the desired font.
 
Examples:
    FONT SIMPLEX
    FONT TRIPLEX
    FONT TRIPLEX ITALIC
 
Note:
    The FONT command sets the font for all text on a plot or diagram.
    There are commands to set the font for specific elements of a plot
    or diagram (see the RELATED COMMANDS section below).  The FONT
    command is used to set the default font and then the more specific
    commands are used to set the font for specific elements of the
    plot.
 
Note:
    Hardware characters do not interpert special symbols such as Greek
    characters and math symbols.  The special symbols are signified
    by an ().  Enter HELP TEXT SUBCOMMANDS for details.  The shift
    character sequence is printed as a single blank space (previous
    versions will print the shift sequence as is).  The exceptions are
    that upper and lower case shifts (UC(), LC() respectively) and the
    space character (SP()) are handled correctly with hardware
    characters.
 
Note:
    Some devices (specifically, Postscript, X11, and QMS) provide
    support for various built-in hardware fonts.  It is desirable to
    support these since many of them are typeset quality fonts.  This
    is done with the following commands:
       SET POSTSCRIPT FONT <font name>
       SET X11 FONT <font name>
       SET QMS FONT <fontname>
    Currently, 35 Postscript fonts and 9 QMS fonts are supported.
    The X11 driver supports whatever fonts are available on your
    implementation.  Enter HELP POSTSCRIPT, HELP QMS, or HELP X11 for
    more information on the available fonts.
 
    Only one hardware font can be active at a given time.  Users
    have asked about the possibility of printing Greek characters
    with the Postscript fonts.  Although the SYMBOL font can
    be specified (it uses the Greek alphabet), the more general
    case of automatically switching to the symbol font when a
    Greek character is specified (e.g., ALPH()) is not yet supported.
 
Note:
    DATAPLOT allows in-line font switching.  For example,
       FONT SIMPLEX
       TEXT SWITCH FROM SIMPLEX TO COMP()COMPLEX FONT
    starts with a simplex font and then converts to a complex font when
    the COMP() string is encountered.  The one limitation is that the
    hardware font (TEKTRONIX) is not supported.  That is, you cannot
    mix hardware fonts and software fonts in the same string.  The
    following shift characters are recognized:
        SIMP()   - shift to the simplex font
        DUPL()   - shift to the duplex font
        TRIP()   - shift to the triplex font
        COMP()   - shift to the complex font
        TRII()   - shift to the triplex italic font
        SIMS()   - shift to the simplex script font
        COMS()   - shift to the complex script font
 
Default:
    All characters are drawn with the Tektronix (i.e., hardware) font.
 
Synonyms:
    None
 
Related Commands:
    TITLE FONT         = Sets the font for the plot title.
    LEGEND FONT        = Sets the fonts for plot legends.
    LABEL FONT         = Sets the fonts for plot labels.
    TIC LABEL FONT     = Sets the fonts for tic mark labels.
    CHARACTER FONT     = Sets the fonts for plot characters.
    TEXT               = Writes a text string.
    CASE               = Sets the case for TEXT characters.
    HEIGHT             = Sets the height for TEXT characters.
    WIDTH              = Sets the width for TEXT characters.
    HW                 = Sets the height and width for TEXT characters.
    THICKNESS          = Sets the thickness of TEXT characters.
    COLOR              = Sets the color for TEXT characters.
    JUSTIFICATION      = Sets the justification for TEXT.
    ()                 = Allows math and Greek symbols in text.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XX
 
-----FOR-------------------------------------------------------
 
FOR
 
Name:
    FOR
 
Type:
    Keyword
 
Purpose:
    Specify row based subsets or intervals for functions.
 
Description:
    The FOR keyword serves 4 separate purposes--
       1) At the end of the PLOT commands (when plotting a function),
          it specifies the points of the function that are to be
          computed and plotted.  For example, PLOT SIN(X) FOR X =
          0 .1 6 plots the sine function starting with x = 0, at
          increments of .1, and stopping at the value 6.  That is, at
          the points, 0, .1, .2, .3, ..., 5.9, 6.0.
       2) At the end of the 3D-PLOT command (when plotting a surface
          function), it specifies the points of the function that are
          to be computed and plotted.  For example, PLOT EXP(-X*X-Y*Y)
          FOR X = -2 .2 2 FOR Y = -2 .2 2 plots the bivariate normal
          function with cross-hatch lines at x = -2.0, -1.8, -1.6, ...,
          1.8, 2.0, and at y = -2.0, -1.8, -1.6, ..., 1.8, 2.0.
       3) At the end of all graphical and analysis commands, and
          certain support commands, it specifies the elements
          (= "rows") of a variable to be operated on.  For example,
          PRINT X FOR I = 1 10 1000 prints the variables X starting
          with element 1, at increments of 10 elements, and stopping at
          element 1000.  That is, it prints X(1), X(11), X(21), ...,
          X(981), X(991).
       4) At the end of the LET sub-commands ROOTS, DERIVATIVE, and
          INTEGRAL, it specifies limits or evaluation points.  For
          example, LET R = ROOTS EXP(-X)+SIN(X**2) FOR X = 0 TO 5 finds
          all roots of the function in the domain X = 0 to X = 5.
 
Syntax 1: (For plotting functions via the PLOT command)
    PLOT <f> FOR <x>   = <x1> <xinc> <x2>
    where <f> is an explicit functional expression or a function name;
          <x> is the name of the dummy variable in the function (the
              horizontal axis variable);
          <x1> is a number or parameter that is the minimum value for
              the dummy variable;
          <xinc> is a number or parameter that is the increment for the
              dummy variable;
    and   <x2> is a number or parameter that is the maximum value for
              the dummy variable.
 
Syntax 2: (For plotting 3-d functions via the 3D-PLOT command)
    3D-PLOT <f> FOR <x> = <x1> <inc> <x2> FOR <y> = <y1> <inc> <y2>
    where <f> is an explicit functional expression or a function name;
          <x> is the name of one dummy variable in the function (one
              horizontal axis variable);
          <x1> is a number or parameter that is the minimum value for
              this dummy variable;
          <xinc> is a number or parameter that is the increment for
              this dummy variable;
          <x2> is a number or parameter that is the maximum value for
              this dummy variable;
          <y> is the name of the other dummy variable in the function
              (the other horizontal axis variable);
          <y1> is a number or parameter that is the minimum value for
              this dummy variable;
          <yinc> is a number or parameter that is the increment for
              this dummy variable;
    and   <y2> is a number or parameter that is the maximum value for
              this dummy variable.
 
Syntax 3: (For all graphics/analysis commands and some support commands)
    <Command>   FOR   I    =    <i1>   <inc>   <i2>
    where <Command> is any graphics or analysis command or certain
               support commands;
          <i1> is a number or parameter that is the element/row
               designation of the first element to be operated on;
          <inc> is a number or parameter that is the increment for the
               element/row;
    and   <i2> is a number or parameter that is the element/row
               designation of the last element to be operated on.
 
    Note that in this syntax, the variable must be FOR I (as opposed
    to FOR J or some other variable).  Using a name other than I can
    cause problems.
 
Syntax 4: (For certain math LET sub-commands)
    LET <y> = ROOTS <f> FOR <x> = <x1> TO <x2>
    LET <y> = DERIVATIVE <f> WRT <x> FOR <x> = <x1>
    LET <y> = INTEGRAL <f> WRT <x> FOR <x> = <x1> TO <x2>
    where <y> is a parameter or variable name;
          <f> is an explicit functional expression or a function name;
          <x> is the name of the dummy variable in the function (the
              horizontal axis variable);
          <x1> is a number or parameter that is
               a) (for ROOTS) the minimum point in the search region;
               b) (for DERIVATIVE) the point at which the derivative is
                  to be evaluated;
               c) (for INTEGRAL) the lower limit of integration;
    and   <x2> is a number or parameter that is
               a) (for ROOTS) the maximum point in the search region;
               b) (for INTEGRAL) the upper limit of integration.
 
Examples:
    PLOT SIN(X) FOR X = 0 .1 6
    PLOT F FOR X = A DEL B
 
    3D-PLOT X+Y FOR X = 0 1 5 FOR Y = 0 1 5
    3D-PLOT G FOR X = A1 DEL1 B1 A2 DEL2 B2
 
    HISTOGRAM Y FOR I = 20 1 50
    FIT (A+B*X)/(C+D*X) FOR I = 101 1 200
    SMOOTH Y FOR I = 200 1 500
    RETAIN Y FOR I = 10 10 200
 
    LET R=ROOTS SIN(X**2)*EXP(-X) WRT X FOR X = 0 TO 6
    LET A = DERIVATIVE F1 WRT X FOR X = 1.3
    LET A = INTEGRAL LOG(X) WRT X FOR X = 1 TO 2
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    PLOT    = Generates a data or function plot.
    3D-PLOT = Generates a 3-d data or function plot.
    LET     = Carries out math operations (and many other operations).
    SUBSET  = Allows specification of a subset.
    EXCEPT  = Allows exclusion-specification of a subset.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XX
 
-----FOURIER--------------------------------------------
 
FOURIER
The following are DATAPLOT Fourier commands:
    FOURIER TRANSFORM  = Compute the Fourier transform.
    INVERSE FOUR TRANS = Compute the inverse Fourier transform.
    FFT                = Compute the FFT.
    INVERSE FFT        = Compute the inverse FFT.
    FOURIER EXPONENT   = Set the Fourier exponent.
    PERIODOGRAM        = Generate a periodogram
    SPECTRUM           = Generate a spectral plot
 
-----FOURIER EXPONENT (SET)--------------------------------------------
 
FOURIER EXPONENT
 
Name:
    FOURIER EXPONENT (SET)
 
Type:
    Set Subcommand
 
Purpose:
    Specify which form of the Fourier transforms is used.
 
Description:
    Fourier Transforms can be expressed in either of the
    following ways:
 
 
 
 
 
Syntax:
    SET FOURIER EXPONENT <PLUS/MINUS>
    where
 
 
Examples:
    SET FOURIER EXPONENT PLUS
    SET FOURIER EXPONENT MINUS
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FFT                = Compute the Fast Fourier Transform.
    FOURIER TRANSFORM  = Compute the Fourier Transform.
    INVERSE FFT        = Compute the inverse Fast Fourier Transform.
    INVERSE FOUR TRANS = Compute the inverse Fourier Transform.
 
Reference:
 
 
Applications:
    XX
 
Implementation Date:
    XX.X
 
Program:
    XX
 
-----FOURIER TRANSFORM (LET)------------------------------------------
 
FOURIER TRANSFORM
 
Name:
    FOURIER TRANSFORM (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the Fourier transform of a variable.
 
Description:
    The Fourier transform converts a time domain function into a
    frequency domain function while the inverse Fourier transform
    converts a frequency domain function into a time domain function.
 
    If h(t) represents the function in the time domain while H(f)
    represents the function in the frequency domain, then the
    definitions of the Fourier transform and the inverse Fourier
    transformation respectively are:
        H(f) = integral[h(t)exp(2*PI*i*f*t)]dt
        h(t) = integral[H(f)exp(-2*PI*i*f*t)]df
    where the integral goes from minus infinity to plus infinity.  An
    alternate (mathematically equivalent) formulation specifies these
    transformations in terms of the angular frequency (radians per
    second) w, where w = 2*PI*f.  The equations then become:
        H(w) = integral[h(t)exp(i*w*t)]dt
        h(t) = (1/(2*PI))*integral[H(w)exp(-i*w*t)]dw
 
    In practice, functions are sampled at equally spaced discrete
    points.  The discrete Fourier transform and the discrete inverse
    Fourier transforms respectively are:
        H(n) = SUM(k=0 to N-1) [h(k)exp(2*PI*i*k*n/N)]
        h(k) = (1/N)*SUM(n=0 to N-1) [H(n)*exp(-2*PI*i*k*n/N]
    where k represents the sampled points in the time domain, lower
    case n represents the sampled points in the frequency domain, and
    N is the number of sampled points.
 
    DATAPLOT calculates the discrete Fourier and inverse Fourier
    transforms.  If you wish to calculate these transforms for a
    function, then evaluate this function at a series of points.  This
    can be accomplished with something like the following:
       LET FUNCTION F = <define the function in terms of X1>
       LET X1 = SEQUENCE 0 0.5 40
       LET Y1 = F
       LET R2 C2 = FOURIER TRANSFORM Y1
 
    See the REFERENCE section below for references which give a more
    detailed explanation of Fourier transforms.
 
Syntax:
    LET <r1> <c1> = FOURIER TRANSFORM <y1>
              <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a response variable for which the Fourier transform
               is to be computed;
          <r1> is a variable containing the real component of the
               calculated Fourier transform;
          <c1> is a variable containing the complex component of the
               calculated Fourier transform;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET RPART CPART = FOURIER TRANSFORM Y1
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    INVERSE FOUR TRANS = Compute the inverse Fourier transform.
    FFT                = Compute the fast Fourier transform.
    INVERSE FFT        = Compute the inverse FFT.
    COSINE TRANS       = Compute the cosine transformation.
    SINE TRANS         = Compute the sine transformation.
    SPECTRAL PLOT      = Generate a spectral plot.
 
Reference:
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", Press, Flannery, Teukolsky, and Vetterling.  Cambridge
    University Press, 1989 (chapter 12).
 
    "Fourier Analysis of Time Series: An Introduction", Peter
    Bloomfield, John Wiley and Sons, 1976.
 
Applications:
    Frequency analysis of time series, signal processing
 
Implementation Date:
    87/5
 
Program:
    LEGEND 1 TIME SERIES SMOOTHING
    LEGEND 2 FOURIER TRANSFORM PLOT (REAL & IMAG.)
    .
    LET X = SEQUENCE 0 .1 25.55
    LET YS = SIN(X)
    LET YN = NORMAL RANDOM NUMBERS FOR I = 1 1 256
    LET YN = YN/10
    LET Y = YS+YN
    .
    LET U V = FOURIER TRANSFORM Y
    LET NU = NUMBER U
    LET XU = SEQUENCE 1 1 NU
    LET XU = XU+50
    LET XV = XU+350
    .
    LET U = 2.5*U
    PLOT U VS XU AND
    PLOT V VS XV
 
-----FPDF (LET)--------------------------------
 
FPDF
 
Name:
    FPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the F probability density function with degrees of freedom
    parameters NU1 and NU2.
 
Description:
    The F distribution is the ratio of 2 chi-square distributions:
          F = (U/NU1)/(V/NU2)
    where U and V are 2 independent chi-square distributions with NU1
    and NU2 degrees of freedom respectively.
 
    The FPDF function evaluates this function for a given x value.  The
    input value should be greater than 0 and the degrees of freedom
    should be positive integers.
 
Syntax:
    LET <y2> = FPDF(<y1>,NU1,NU2)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter containing positive values;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed F pdf value is stored;
          <NU1> and <NU2> are positive integer numbers or parameters
               that define the degrees of freedom;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = FPDF(3,10,8)
    LET A = FPDF(A1,10,8)
    LET X2 = FPDF(X1,10,8)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
    FCDF   = Compute the F cumulative distribution function.
    FPPF   = Compute the F percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    TCDF   = Compute the T cumulative distribution function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    WALPDF = Compute the Wald probability density function.
    WALPPF = Compute the Wald percent point function.
    WALCDF = Compute the Wald cumulative distribution function.
    FLPDF  = Compute the Fatigue Life probability density function.
    FLPPF  = Compute the Fatigue Life percent point function.
    FLCDF  = Compute the Fatigue Life cumulative distribution function.
    IGPDF  = Compute the Inverse Gaussian probability density function.
    IGPPF  = Compute the Inverse Gaussian percent point function.
    IGCDF  = Compute the Inverse Gaussian cumulative distribution
             function.
    RIGPDF = Compute the Reciprocal Inverse Gaussian probability
             density function.
    RIGPPF = Compute the Reciprocal Inverse Gaussian percent point
             function.
    RIGCDF = Compute the Reciprocal Inverse Gaussian cumulative
             distribution function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, 1970.
 
Applications:
    XX
 
Implementation Date:
    XX.X
 
Program:
    TITLE PLOT FPDF FOR VARIOUS VALUES OF NU
    SEGMENT 1 COORDINATES 64 88 69 88; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 64 84 69 84; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 64 80 69 80; SEGMENT 3 PATTERN DOT
    SEGMENT 4 COORDINATES 64 76 69 76; SEGMENT 4 PATTERN DASH2
    LEGEND 1 NU1 = 5, NU2 = 5
    LEGEND 1 COORDINATES 70 87
    LEGEND 2 NU1 = 5, NU2 = 10
    LEGEND 2 COORDINATES 70 83
    LEGEND 3 NU1 = 10, NU2 = 5
    LEGEND 3 COORDINATES 70 79
    LEGEND 4 NU1 = 10, NU2 = 10
    LEGEND 4 COORDINATES 70 75
    YLIMITS 0 0.8; MAJOR YTIC NUMBER 9
    MINOR YTIC NUMBER 1; YTIC DECIMAL 1
    XLIMITS 0 5; XTIC OFFSET 0.5 1
    MAJOR XTIC NUMBER 6; MINOR XTIC NUMBER 1
    LINES SOLID DASH DOT DASH2
    PLOT FPDF(X,5,5) FOR X = 0 .05 6 AND
    PLOT FPDF(X,5,10) FOR X = 0 .05 6 AND
    PLOT FPDF(X,10,5) FOR X = 0 .05 6 AND
    PLOT FPDF(X,10,10) FOR X = 0 .05 6
 
-----FPPF (LET)--------------------------------
 
FPPF
 
Name:
    FPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the F percent point function with degrees of freedom
    parameters NU1 and NU2.
 
Description:
    The F distribution is the ratio of 2 chi-square distributions:
          F = (U/NU1)/(V/NU2)
    where U and V are 2 independent chi-square distributions with NU1
    and NU2 degrees of freedom respectively.
 
    The percent point function is the inverse of the cumulative
    distribution function.  The cumulative distribution sums the
    probability from 0 to the given x value.  The percent point
    function takes a cumulative probability value and computes the
    corresponding x value.
 
Syntax:
    LET <y2> = FPDF(<y1>,NU1,NU2)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter containing positive values;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed F ppf value is stored;
          <NU1> and <NU2> are positive integer numbers or parameters
               that define the degrees of freedom;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = FPPF(0.9,10,8)
    LET A = FPPF(A1,10,8)
    LET X2 = FPPF(X1,10,8)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
    FCDF   = Compute the F cumulative distribution function.
    FPDF   = Compute the F probability density function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    TCDF   = Compute the T cumulative distribution function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    WALPDF = Compute the Wald probability density function.
    WALPPF = Compute the Wald percent point function.
    WALCDF = Compute the Wald cumulative distribution function.
    FLPDF  = Compute the Fatigue Life probability density function.
    FLPPF  = Compute the Fatigue Life percent point function.
    FLCDF  = Compute the Fatigue Life cumulative distribution function.
    IGPDF  = Compute the Inverse Gaussian probability density function.
    IGPPF  = Compute the Inverse Gaussian percent point function.
    IGCDF  = Compute the Inverse Gaussian cumulative distribution
             function.
    RIGPDF = Compute the Reciprocal Inverse Gaussian probability
             density function.
    RIGPPF = Compute the Reciprocal Inverse Gaussian percent point
             function.
    RIGCDF = Compute the Reciprocal Inverse Gaussian cumulative
             distribution function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, 1970.
 
Applications:
    XX
 
Implementation Date:
    XX.X
 
Program:
    TITLE PLOT FPPF FOR VARIOUS VALUES OF NU
    SEGMENT 1 COORDINATES 16 88 21 88; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 16 84 21 84; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 16 80 21 80; SEGMENT 3 PATTERN DOT
    SEGMENT 4 COORDINATES 16 76 21 76; SEGMENT 4 PATTERN DASH2
    LEGEND 1 NU1 = 5, NU2 = 5
    LEGEND 1 COORDINATES 22 87
    LEGEND 2 NU1 = 5, NU2 = 10
    LEGEND 2 COORDINATES 22 83
    LEGEND 3 NU1 = 10, NU2=5
    LEGEND 3 COORDINATES 22 79
    LEGEND 4 NU1 = 10, NU2 = 10
    LEGEND 4 COORDINATES 22 75
    XLIMITS 0 1; MAJOR XTIC NUMBER 6
    MINOR XTIC NUMBER 1; XTIC DECIMAL 1
    YLIMITS 0 5
    LINES SOLID DASH DOT DASH2
    PLOT FPPF(X,5,5) FOR X = 0.01 .01 0.95 AND
    PLOT FPPF(X,5,10) FOR X = 0.01 .01 0.95 AND
    PLOT FPPF(X,10,5) FOR X = 0.01 .01 0.95 AND
    PLOT FPPF(X,10,10) FOR X = 0.01 .01 0.95
 
-----FRACT (LET)--------------------------------
 
FRACT
 
Name:
    FRACT (LET)
 
Type:
    Library Function
 
Purpose:
    Return the fractional part of a number.
 
Syntax:
    LET <y2> = FRACT(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed fractional values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = FRACT(14.284)
    LET A = FRACT(A1)
    LET X2 = FRACT(X1)
    LET X2 = FRACT(X1-4)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SIGN   = Compute the sign of a number.
    INT    = Compute the integer portion of a number.
    MSD    = Compute the most significant digit of a number.
    ROUND  = Round to the closest integer of a number.
 
Applications:
    XX
 
Implementation Date:
    XX.X
 
Program:
    LET Y1 = SEQUENCE 0 0.1 10.0
    LET Y2 = FRACT(Y1)
    PRINT Y1 Y2
 
-----FRACTAL (LET)------------------------------------------------
 
FRACTAL
 
Name:
    FRACTAL (LET)
 
Type:
    Subcommand under LET
 
Purpose:
    Generate a fractal sequence from a set of points.
 
Description:
    Given as set of points in the variables X1 and Y1, this command
    generates the following sequence:
        X2(1)  = X1(1)
        X2(2)  = X1(1) + (1/3)DELX
        X2(3) = X1(1) + (1/2)DEXLX - (SQRT(3)/6)DELY
        X2(4)  = X1(1) + (2/3)DELX
        X2(5)  = X1(2)
 
        Y2(1)  = Y1(1)
        Y2(2)  = Y1(1) + (1/3)DELY
        Y2(3)  = Y1(1) + (1/2)DELY _ (SQRT(3)/6)DELX
        Y2(4)  = Y1(1) + (2/3)DELY
        Y2(5)  = Y1(2)
 
    where DELX is the difference between 2 successive points in the X1
    variable (i.e., DELX(I) = X1(I+1)-X1(I)) and DELY is the difference
    between 2 successive points in the Y1 variable (i.e., DELY(I) =
    Y1(I+1)-Y1(I)).  These are the type of fractals used to generate
    Koch snowflakes and Koch curves.
 
Syntax:
    LET <x2> <y2> = FRACTAL <x1> <y1> <SUBSET/EXCEPT/FOR qualification>
    where <x1> is a variable;
          <y1> is a variable (same length as <x1>);
          <x2> is a variable where the computed fractal sequence
               corresponding to <x1> is saved (4 times as long as
               <x1>);
          <y2> is a variable where the computed fractal sequence
               corresponding to <y1> is saved (4 times as long as
               <y1>);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y2 X2 = FRACTAL Y1 X1
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FRACTAL PLOT         = Generate a fractal plot.
    CANTOR NUMBERS       = Generate a sequence of Cantor numbers.
    LOGISTIC NUMBERS     = Generate numbers from the Logistic sequence.
    JULIA                = Compute a Julia set.
    PHASE PLANE DIAGRAM  = Generate a phase plane diagram.
    PLOT                 = Plots data or functions.
 
Reference:
    "Infinity and the Mind", Rucker, (page 9).
 
Applications:
    Chaos
 
Implementation Date:
    88/7
 
Program 1:
    .  Draw a Koch snowflake through several iterations
    .
    READ X1 Y1
    0 1
    0.5 0
    1 1
    0 1
    END OF DATA
    .
    MULTIPLOT 2 3
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    LIMITS 0 1
    TIC OFFSET 0.4 0.4
    FRAME OFF
    FRAME CORNER COORDINATES 5 5 95 95
    TITLE OFFSET 1
    PRE-SORT OFF
    TITLE ORIGINAL DATA
    PLOT Y1 X1
    LOOP FOR K = 2 1 6
        LET J = K - 1
        LET Y2 X2 = FRACTAL Y1 X1
        TITLE KOCH SNOWFLAKE ITERATION ^K
        PLOT Y2 X2
        LET X1 = X2
        LET Y1 = Y2
    END OF LOOP
    END OF MULTIPLOT
 
Program 2:
    .  Draw a Koch curve through several iterations
    .
    READ X1 Y1
    0 0
    1 0
    END OF DATA
    .
    MULTIPLOT 2 3
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    LIMITS 0 1
    TIC OFFSET 0.4 0.4
    FRAME OFF
    FRAME CORNER COORDINATES 5 5 95 95
    TITLE OFFSET 1
    PRE-SORT OFF
    TITLE ORIGINAL LINE
    PLOT Y1 X1
    LOOP FOR K = 2 1 6
        LET J = K - 1
        LET Y2 X2 = FRACTAL Y1 X1
        TITLE KOCH CURVE ITERATION ^K
        PLOT Y2 X2
        LET X1 = X2
        LET Y1 = Y2
    END OF LOOP
    END OF MULTIPLOT
 
-----FRACTAL PLOT-----------------------------------------------
 
FRACTAL PLOT
 
Name:
    FRACTAL PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a fractal plot.
 
Description:
    DATAPLOT generates Iterated Function Systems fractals as defined by
    Micheal Barnsley.  Barnsley defines an affine transformation as:
         W(x) = W[X1] = [a b] [X1] + [e]
                 [X2]   [c d] [X2] + [f]
    Fractal plots are generated by applying one or more affine
    transformations in an iterative fashion to an initial starting
    point (DATAPLOT uses (0,0) as the starting point).  The points a,
    b, c, and d define scaling and rotation operations to be applied
    to the point.  The e and f points define a translation to be
    applied to the point.  An additional value is the probability
    weighting.  These weights are applied to a uniform random number
    generator to determine which of the affine transformations (if
    there is more than one) to apply at a given step.  The a, b, c, and
    d points are commonly expressed as:
         [a b] = [r1cos(alpha1)    -r2sin(alpha2)]
         [c d]   [r1sin(alpha1)     r2cos(alpha2)]
    This form makes the nature of the rotation and scaling more
    explicit.  In addition, DATAPLOT also supports an alternate form
    for specifying the scaling and rotation (this algorithm is due to
    William Withers of the US Naval Academy).  It performs the
    following rotation and scaling to obtain the a, b, c, and d
    points (this is an initial rotation, followed by scaling, and then
    followed by another rotation).
         [a b] = [cos(alpha) -sin(alpha)] [p 0] [cos(beta) sin(beta)]
         [c d]   [sin(alpha)  cos(alpha)] [q 0] [sin(beta) cos(beta)]
 
    DATAPLOT currently supports each of these methods for specifying
    fractals (earlier versions only support the Whither's method).
 
    For each of the 3 formats, one row of the input variables defines
    an affine transformation.  The columns specify one of the elements
    (e.g., a, b, etc.).
 
    If you do not wish to specify a probability weighting, simply
    specify all weights to be 1 or leave it off.  The translation
    factors are specified the same way for all 3 forms.
 
Syntax 1: (Whither's format)
    FRACTAL PLOT  <y1> <y2> <y3> <y4> <y5> <y6> <y7>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the variable containing the initial rotations;
          <y2> is the variable containing the X scalings;
          <y3> is the variable containing the Y scalings;
          <y4> is the variable containing the final rotations;
          <y5> is the variable containing the X translations;
          <y6> is the variable containing the Y translations;
          <y7> is an optional variable containing the probability
               weightings;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional and
               rarely used in this context.
 
Syntax 2: (Barnsley's format)
    FRACTAL PLOT  <a> <b> <c> <d> <e> <f> <y7>
                <SUBSET/EXCEPT/FOR qualification>
    where <a> is the variable containing the a values;
          <b> is the variable containing the b values;
          <c> is the variable containing the c values;
          <d> is the variable containing the d values;
          <e> is the variable containing the e values;
          <f> is the variable containing the f values;
          <y7> is an optional variable containing the probability
               weightings;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional and
               rarely used in this context.
 
Syntax 3: (rotation matrix format)
    FRACTAL PLOT  <y1> <y2> <y3> <y4> <y5> <y6> <y7>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the variable containing the alpha1 values;
          <y2> is the variable containing the r1 values;
          <y3> is the variable containing the r2 values;
          <y4> is the variable containing the alpha2 values;
          <y5> is the variable containing the X translations;
          <y6> is the variable containing the Y translations;
          <y7> is an optional variable containing the probability
               weightings;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional and
               rarely used in this context.
 
Examples:
    FRACTAL PLOT Y1 Y2 Y3 Y4 Y5 Y6
    FRACTAL PLOT Y1 Y2 Y3 Y4 Y5 Y6 Y7
 
Note:
    The FRACTAL TYPE command is used to specify the format of the
    fractal data.
 
Note:
    The following sample data files in the DATAPLOT reference
    directory contain examples of fractal data sets.  Just replace the
    READ section in the program example below.  These data files are
    in the Whither's format.
        FRACBRAN.DAT  - generate a branch
        FRACCHRI.DAT  - generate a Christmas tree
        FRACCLOU.DAT  - generate a cloud
        FRACFERN.DAT  - generate a fern
        FRACFRON.DAT  - generate a frond
        FRACGALA.DAT  - generate a galaxy
        FRACPENT.DAT  - generate a pentagon
        FRACSPIR.DAT  - generate a spiral
        FRACSQUA.DAT  - generate a square
        FRACTRIA.DAT  - generate a triangle
 
Note:
    The appearance of the plot is controlled by the LINE and CHARACTER
    settings.  Typically, you want to set the LINE to blank and the
    CHARACTER to a ".".  It is also recommended that you set the
    character font to simplex (or set the character justification to
    LEBO).  This is demonstrated in the example program below.
 
Note:
    Currently, DATAPLOT continues to generate the fractal plot until
    the maximum number of points for a plot has been reached.  This is
    20,000 on most current implementations.  The FRACTAL ITERATIONS
    command can be used to specify a smaller number (it is currently
    not possible to set a larger number).
 
Note:
    The 2 angle variables can be given in either radians or degrees.
    If they are given in angles, be sure to enter an ANGLE UNITS
    DEGREES command before the FRACTAL PLOT command.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LINES          = Sets the type for plot lines.
    CHARACTER      = Sets the type for plot characters.
    CHARACTER FONT = Sets the font for plot characters.
    ANGLE UNITS    = Specifies whether angles are given in degrees or
                     radians.
    PLOT           = Generates a data or function plot.
    MULTIPLOT      = Allows multiple plots per page
    FRACTAL (LET)  = Generate fractal data (of the kind used to create
                     Koch snowflakes).
 
Reference:
    DATAPLOT uses an algorithm provided by Douglass Withers of the US
    Naval Academy.
 
    "Fractals Everywhere", Micheal Barnsley, Academic Press, 1988.
 
    "Chaos, Fractals, and Dynamics: Computer Experiments in
    Mathematics", Robert Devaney, Addison-Wesley, 1990.
 
Applications:
    XX
 
Implementation Date:
    88/12
 
Program:
    .  Generate a fractal fern
    READ Y1 TO Y7
    180.000     0.160  0.001        180.000  0.000  0.000        1
      0.000     0.850  0.850         -2.500  1.600  0.000       15
    180.000     0.340  0.300        229.000  1.600  0.000        2
    109.709    -0.288  0.379        235.233  0.440  0.000        2
    END OF DATA
    FRAME OFF
    FRAME COORDINATES 5 5 95 95
    ANGLE UNITS DEGREES
    CHARACTER JUSTIFICATION LEBO
    CHARACTER .
    LINE BLANK
    FRACTAL TYPE WHITHERS
    FRACTAL PLOT Y1 Y2 Y3 Y4 Y5 Y6 Y7
 
-----FRACTAL ITERATIONS------------------------------------------
 
FRACTAL ITERATIONS
 
Name:
    FRACTAL ITERATIONS
 
Type:
    Support Command
 
Purpose:
    Specify the number of points generated by a FRACTAL PLOT command.
 
Description:
    DATAPLOT generates Iterated Function Systems fractals as defined by
    Micheal Barnsley.  Barnsley defines an affine transformation as:
         W(x) = W[X1] = [a b] [X1] + [e]
                 [X2]   [c d] [X2] + [f]
    Fractal plots are generated by applying one or more affine
    transformations in an iterative fashion to an initial starting
    point (DATAPLOT uses (0,0) as the starting point).  By default, the
    iteration is continued until the maximum number of points for a
    plot is reached (this is 20,000 on the default implementation, but
    it may be set higher on a given implementation).  The number of
    iterations can be set lower than this maximum, but it cannot be set
    higher.  See the documentation for the FRACTAL PLOT command for
    more details on how they are generated.
 
Syntax:
    FRACTAL ITERATIONS  <val>
    where <val> is a positive integer number or parameter that
               specifies the number of points.
 
Examples:
    FRACTAL ITERATIONS 10000
    FRACTAL ITERATIONS 5000
 
Note:
    If you need to generate more points than your current
    implementation allows, see your local DATAPLOT implementor.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FRACTAL PLOT   = Generate a fractal plot.
    FRACTAL TYPE   = Specify the format of the input data for the
                     FRACTAL PLOT command.
    FRACTAL (LET)  = Generate fractal data (of the kind used to create
                     Koch snowflakes).
 
Reference:
    "Fractals Everywhere", Micheal Barnsley, Academic Press, 1988.
 
Applications:
    XX
 
Implementation Date:
    93/6
 
Program:
    .  Generate a fractal fern
    READ Y1 TO Y7
    180.000     0.160  0.001        180.000  0.000  0.000        1
      0.000     0.850  0.850         -2.500  1.600  0.000       15
    180.000     0.340  0.300        229.000  1.600  0.000        2
    109.709    -0.288  0.379        235.233  0.440  0.000        2
    END OF DATA
    FRAME OFF
    FRAME COORDINATES 5 5 95 95
    ANGLE UNITS DEGREES
    CHARACTER JUSTIFICATION LEBO
    CHARACTER .
    LINE BLANK
    FRACTAL TYPE WHITHERS
    FRACTAL ITERATIONS 10000
    FRACTAL PLOT Y1 Y2 Y3 Y4 Y5 Y6 Y7
 
-----FRACTAL TYPE-----------------------------------------------
 
FRACTAL TYPE
 
Name:
    FRACTAL TYPE
 
Type:
    Support Command
 
Purpose:
    Specifies the format of the input data for a fractal plot command.
 
Description:
    DATAPLOT generates Iterated Function Systems fractals as defined by
    Micheal Barnsley.  Barnsley defines an affine transformation as:
         W(x) = W[X1] = [a b] [X1] + [e]
                 [X2]   [c d] [X2] + [f]
    Fractal plots are generated by applying one or more affine
    transformations in an iterative fashion to an initial starting
    point (DATAPLOT uses (0,0) as the starting point).  The points a,
    b, c, and d define scaling and rotation operations to be applied
    to the point.  The e and f points define a translation to be
    applied to the point.  An additional value is the probability
    weighting.  These weights are applied to a uniform random number
    generator to determine which of the affine transformations (if
    there is more than one) to apply at a given step.  The a, b, c, and
    d points are commonly expressed as:
         [a b] = [r1cos(alpha1)    -r2sin(alpha2)]
         [c d]   [r1sin(alpha1)     r2cos(alpha2)]
    This form makes the nature of the rotation and scaling more
    explicit.  In addition, DATAPLOT also supports an alternate form
    for specifying the scaling and rotation (this algorithm is due to
    William Withers of the US Naval Academy).  It performs the
    following rotation and scaling to obtain the a, b, c, and d
    points (this is an initial rotation, followed by scaling, and then
    followed by another rotation).
         [a b] = [cos(alpha) -sin(alpha)] [p 0] [cos(beta) sin(beta)]
         [c d]   [sin(alpha)  cos(alpha)] [q 0] [sin(beta) cos(beta)]
 
    DATAPLOT currently supports each of these methods for specifying
    fractals (earlier versions only support the Whither's method).
 
Syntax:
    FRACTAL TYPE <BARNSLEY/ANGLE/WHITHERS>
    where BARNSLEY specifies the Barnsley definition (i.e., specify the
              a, b, c, d in the above equations), ANGLE specifies the
              Barnsley definition transformed  to explicit scale and
              rotation factors (i.e., specify the r1, r2, alpha1, and
              alpha2 in the above equations), and WHITHERS specifies
              the Whither's format.
 
Examples:
    FRACTAL TYPE BARNSLEY
    FRACTAL TYPE ANGLE
    FRACTAL TYPE WHITHERS
 
Default:
    The default format is the Barnsley format (i.e., BARNSLEY).
    Earlier versions of DATAPLOT only support the Whither's format.
 
Synonyms:
    None
 
Related Commands:
    FRACTAL PLOT        = Generate a fractal plot.
    FRACTAL ITERATIONS  = Specify the number of points generated by
                          the FRACTAL PLOT command.
    FRACTAL (LET)       = Generate fractal data (of the kind used to
                          create Koch snowflakes).
 
Reference:
    "Fractals Everywhere", Micheal Barnsley, Academic Press, 1988.
 
Applications:
    XX
 
Implementation Date:
    88/12
 
Program:
    .  Generate a fractal fern
    READ Y1 TO Y7
    180.000     0.160  0.001        180.000  0.000  0.000        1
      0.000     0.850  0.850         -2.500  1.600  0.000       15
    180.000     0.340  0.300        229.000  1.600  0.000        2
    109.709    -0.288  0.379        235.233  0.440  0.000        2
    END OF DATA
    FRAME OFF
    FRAME COORDINATES 5 5 95 95
    ANGLE UNITS DEGREES
    CHARACTER JUSTIFICATION LEBO
    CHARACTER .
    LINE BLANK
    FRACTAL TYPE WHITHERS
    FRACTAL PLOT Y1 Y2 Y3 Y4 Y5 Y6 Y7
 
-----FRAME-------------------------------------------------------
 
FRAME
 
Name:
    ...FRAME
 
Type:
    Plot Control Command
 
Purpose:
    Specifies whether or not (and which) frames will appear on
    subsequent plots.
 
Description:
    The frame is the 4-sided box which surrounds the usual
    2-dimensional plot.  The default is for all 4 sides of the frame to
    appear.  The analyst can suppress each or all of the sides of the
    frame by specifying the pre-fix in the command (see the SYNTAX
    section below).
 
Syntax:
    <prefix>FRAME   <ON or OFF>
    where ON specifies that the frame is drawn while OFF specifies that
             it is not;
    and <prefix> is as follows:
       no prefix     refers to all 4 sides
       the prefix X  refers to both horizontal sides
       the prefix Y  refers to both vertical sides
       the prefix X1 refers to the lower horizontal side
       the prefix X2 refers to the upper horizontal side
       the prefix Y1 refers to the left  vertical   side
       the prefix Y2 refers to the right vertical   side.
 
Examples:
    FRAME ON
    FRAME OFF
    FRAME
    X2FRAME OFF
    Y2FRAME OFF
 
Note:
    A ...FRAME command with no arguments reverts the setting to
    default.  Thus X1FRAME with no arguments reverts the bottom
    horizontal frame line to on.  A ...FRAME command with no prefix
    refers to all 4 sides.  Thus FRAME OFF suppresses the frame lines
    on all 4 sides.  Note also that FRAME with no prefix and no
    arguments reverts the frame settings on all 4 sides to default.
 
Note:
    Turning off the frame also turns off the tic marks and the tic mark
    labels for that frame line.  It does not affect the axis label.
 
Default:
    All frame lines on.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    FRAME COLOR         = Sets the color for the plot frame.
    FRAME COORDINATES   = Sets the location for the plot frame.
    MINIMUM             = Sets the frame minima for subsequent  plots.
    MAXIMUM             = Sets the frame maxima for subsequent  plots.
    LIMITS              = Sets the frame limits for subsequent plots.
    GRID                = Sets the on/off switch for the plot grid.
    LOG                 = Sets the on/off switch for a log scale.
    TIC                 = Sets the on/off switch for the plot tics.
    MAJOR TIC NUMBER    = Sets the number of major tics.
    MINOR TIC NUMBER    = Sets the number of minor tics.
    TIC LABEL           = Sets the on/off switch for plot tic labels.
    TIC LABEL DECIMALS  = Sets the number of decimal places for plot
                          tic mark labels.
    MARGIN COLOR        = Sets the color for the plot margin.
    BACKGROUND COLOR    = Sets the color for the plot background.
    TITLE               = Sets the plot title.
    LABEL               = Sets the plot labels.
    LEGEND              = Sets the plot legends.
    LEGEND COORDINATES  = Sets the locations for plot legends.
    BOX COORDINATES     = Sets the locations for plot boxes.
    ARROW COORDINATES   = Sets the locations for plot arrows.
    SEGMENT COORDINATES = Sets the locations for plot segments.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    LET Y = DATA 2 5 9 15 28
    LET X = DATA 81 82 83 84 85
    .
    X1LIMITS 81 85
    XTIC OFFSET 1 1
    X1LABEL YEAR
    MINOR X1TIC MARK NUMBER 0
    Y1LABEL SALES
    BAR ON
    LINE BLANK
    BAR WIDTH 0.5
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    .
    TITLE DEFAULT FRAME
    PLOT Y VS X
    .
    TITLE LEFT AND RIGHT ONLY
    Y2FRAME OFF
    X2FRAME OFF
    PLOT Y VS X
    .
    TITLE BOTTOM FRAME ONLY
    Y1FRAME OFF
    PLOT Y VS X
    .
    TITLE NO FRAME
    FRAME OFF
    PLOT Y VS X
    END OF MULTIPLOT
 
-----FRAME COLOR-------------------------------------------------------
 
FRAME COLOR
 
Name:
    ...FRAME COLOR
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the color of the plot frame on subsequent plots.
 
Description:
    The frame is the 4-sided box which surrounds the usual
    2-dimensional plot.  The analyst can control the color of each or
    all of the sides of the frame by specifying the pre-fix in the
    command (see the SYNTAX section below).
 
    Dataplot provides two methods for specifying colors.

        1. Colors can be defined by name (or by the corresponding index).
           Dataplot adopted it's named colors from the X11 project.
           Currently, 162 named colors and 100 levels of grayscale are
           supported.  Grayscale can be specified with either G0, G1, ...,
           G100 (or -1, -2, ..., -100).  Many older devices support only a
           limited number of colors.  For these devices, unsupported colors
           will be mapped to one of the available colors.  To specify a
           named color, see Syntax 1.

        2. Most modern graphics devices support full RGB (RedBlueGreen)
           color.  You can alternatively specify RGB colors by entering
           three integer values to represent the Red, Green and Blue
           components, respectively.  These values should be in the range
           0 to 255.

    When setting the frame color, Dataplot first checks if the device
    supports RGB colors. If not, the named color will be used.  If the
    device does support RGB color, Dataplot will check if an RGB color
    has been specified.  If yes, then that RGB color is used.  If not,
    the named color will be used.

    To see the list of supported named colors (with the associated index
    number), see

    https://www.itl.nist.gov/div898/software/dataplot/refman1/ch11/homepage.htm

Syntax 1:
    <prefix>FRAME COLOR   <color>
    where <color> specifies the desired color;
    and   <prefix> is as follows:
       no prefix     refers to all 4 sides
       the prefix X  refers to both horizontal sides
       the prefix Y  refers to both vertical sides
       the prefix X1 refers to the lower horizontal side
       the prefix X2 refers to the upper horizontal side
       the prefix Y1 refers to the left  vertical   side
       the prefix Y2 refers to the right vertical   side.
 
Syntax 2:
    <prefix>FRAME RGB COLOR  <red>  <green>  <blue>
    where <red> is an integer number or parameter that specifies
                the red component;
          <green> is an integer number or parameter that specifies
                the green component;
          <blue> is an integer number or parameter that specifies
                the blue component;
    and   <prefix> is as follows:
       no prefix     refers to all 4 sides
       the prefix X  refers to both horizontal sides
       the prefix Y  refers to both vertical sides
       the prefix X1 refers to the lower horizontal side
       the prefix X2 refers to the upper horizontal side
       the prefix Y1 refers to the left  vertical   side
       the prefix Y2 refers to the right vertical   side.

    To turn off the RGB color, set the values to -1 (any negative value
    will work).  Values greater than 255 will be set to 255.

Examples:
    FRAME COLOR YELLOW
    FRAME COLOR RED
    FRAME COLOR
    X2FRAME COLOR CYAN
    Y2FRAME COLOR MAGENTA
    FRAME RGB COLOR 220 109 88
    XFRAME RGB COLOR 175 238 238
 
Note:
    A ...FRAME COLOR command with no arguments reverts the setting to
    default.  Thus X1FRAME COLOR with no arguments sets the bottom
    horizontal frame line color to black.  A ...FRAME COLOR command
    with no prefix refer to all 4 sides.  Thus FRAME COLOR GREEN sets
    the frame line color to green on all 4 sides.  Note also that FRAME
    COLOR with no prefix and no arguments reverts the frame color
    settings on all 4 sides to default.
 
Note:
    Normally all frame lines are set to the same color, so the most
    common form of this command is FRAME COLOR with no prefix.
 
Default:
    All frame lines are black.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    FRAME               = Sets the on/off switch for the plot frame.
    FRAME COORDINATES   = Sets the location for the plot frame.
    MINIMUM             = Sets the frame minima for subsequent  plots.
    MAXIMUM             = Sets the frame maxima for subsequent  plots.
    LIMITS              = Sets the frame limits for subsequent plots.
    GRID                = Sets the on/off switch for the plot grid.
    LOG                 = Sets the on/off switch for a log scale.
    TIC                 = Sets the on/off switch for the plot tics.
    MAJOR TIC NUMBER    = Sets the number of major tics.
    MINOR TIC NUMBER    = Sets the number of minor tics.
    TIC LABEL           = Sets the on/off switch for plot tic labels.
    TIC LABEL DECIMALS  = Sets the number of decimal places for plot
                          tic mark labels.
    MARGIN COLOR        = Sets the color for the plot margin.
    BACKGROUND COLOR    = Sets the color for the plot background.
    TITLE               = Sets the plot title.
    LABEL               = Sets the plot labels.
    LEGEND              = Sets the plot legends.
    LEGEND COORDINATES  = Sets the locations for plot legends.
    BOX COORDINATES     = Sets the locations for plot boxes.
    ARROW COORDINATES   = Sets the locations for plot arrows.
    SEGMENT COORDINATES = Sets the locations for plot segments.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    Pre-1987
    2020/11: Support for RGB colors
 
Program 1:
    SERIAL READ LEAD
    164 426 59 98 312 263 607 497 213 54 160 262 547 325 419 94 70
    END OF DATA
    SERIAL READ POT
    106 175 61 79 94 121 424 328 107 218 140 179 246 231 245 339 99
    END OF DATA
    .
    TITLE DEMONSTRATE FRAME COLOR COMMAND
    XFRAME COLOR RED
    YFRAME COLOR BLUE
    FRAME THICKNESS 0.5
    X1LABEL LEAD
    Y1LABEL POTASSIUM
    CHARACTER CIRCLE
    CHARACTER SIZE 1.5
    LINE BLANK ALL
    PLOT POT VS LEAD
 
Program 2:
    SERIAL READ LEAD
    164 426 59 98 312 263 607 497 213 54 160 262 547 325 419 94 70
    END OF DATA
    SERIAL READ POT
    106 175 61 79 94 121 424 328 107 218 140 179 246 231 245 339 99
    END OF DATA
    .
    TITLE DEMONSTRATE FRAME RGB COLOR COMMAND
    XFRAME COLOR RED
    YFRAME COLOR BLUE
    XFRAME RGB COLOR 220 109 88
    YFRAME RGB COLOR 175 238 238
    FRAME THICKNESS 0.5
    X1LABEL LEAD
    Y1LABEL POTASSIUM
    CHARACTER CIRCLE
    CHARACTER SIZE 1.5
    LINE BLANK ALL
    PLOT POT VS LEAD

-----FRAME COORDINATES------------------------------------------------
 
FRAME COORDINATES
 
Name:
    FRAME COORDINATES
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the coordinates of the frame to appear on subsequent
    plots.
 
Description:
    The frame is the 4-sided box which surrounds the usual
    2-dimensional plot.  The 2 pairs of coordinates define the (x,y)
    values for two opposing corners of the frame.
 
Syntax:
    FRAME COORDINATES  <x1>  <y1>  <x2>  <y2>
    where <x1> is a decimal number or parameter in the range 0 to 100
               that specifies the lower left corner X coordinate;
          <y1> is a decimal number or parameter in the range 0 to 100
               that specifies the lower left corner Y coordinate;
          <x2> is a decimal number or parameter in the range 0 to 100
               that specifies the upper right corner X coordinate;
          <y2> is a decimal number or parameter in the range 0 to 100
               that specifies the upper right corner Y coordinate.
 
Examples:
    FRAME COORDINATES 50 50 90 90
    FRAME COORDINATES 10 60 40 80
 
Default:
    The default frame corner coordinates are (15,20) and (85,90).
 
Synonyms:
    FRAME CORNER COORDINATES
 
Related Commands:
    FRAME               = Sets the on/off switch for the plot frame.
    PLOT                = Generates a data or function plot.
    FRAME COLOR         = Sets the color for the plot frame.
    FRAME COORDINATES   = Sets the location for the plot frame.
    MINIMUM             = Sets the frame minima for subsequent  plots.
    MAXIMUM             = Sets the frame maxima for subsequent  plots.
    LIMITS              = Sets the frame limits for subsequent plots.
    GRID                = Sets the on/off switch for the plot grid.
    LOG                 = Sets the on/off switch for a log scale.
    TIC                 = Sets the on/off switch for the plot tics.
    MAJOR TIC NUMBER    = Sets the number of major tics.
    MINOR TIC NUMBER    = Sets the number of minor tics.
    TIC LABEL           = Sets the on/off switch for plot tic labels.
    TIC LABEL DECIMALS  = Sets the number of decimal places for plot
                          tic mark labels.
    MARGIN COLOR        = Sets the color for the plot margin.
    BACKGROUND COLOR    = Sets the color for the plot background.
    TITLE               = Sets the plot title.
    LABEL               = Sets the plot labels.
    LEGEND              = Sets the plot legends.
    LEGEND COORDINATES  = Sets the locations for plot legends.
    BOX COORDINATES     = Sets the locations for plot boxes.
    ARROW COORDINATES   = Sets the locations for plot arrows.
    SEGMENT COORDINATES = Sets the locations for plot segments.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    SERIAL READ LEAD
    164 426 59 98 312 263 607 497 213 54 160 262 547 325 419 94 70
    END OF DATA
    SERIAL READ POT
    106 175 61 79 94 121 424 328 107 218 140 179 246 231 245 339 99
    END OF DATA
    XLIMITS 0 700
    YLIMITS 0 500
    .
    TITLE DEMONSTRATE FRAME COORDINATES COMMAND
    Y2FRAME OFF
    X2FRAME OFF
    X1LABEL LEAD
    Y1LABEL POTASSIUM
    CHARACTER CIRCLE
    CHARACTER SIZE 1.5
    LINE BLANK ALL
    PLOT POT VS LEAD
    .
    FRAME CORNER COORDINATES 81 20 89 90
    PRE-ERASE OFF
    FENCES ON
    LINES TUFTE BOX PLOT
    CHARACTERS TUFTE BOX PLOT
    LET N = SIZE POT
    LET X = 1 FOR I = 1 1 N
    XLIMITS 0 2
    FRAME OFF
    TITLE
    X1LABEL
    Y1LABEL
    BOX PLOT POT X
    .
    FRAME CORNER COORDINATES 15 86 85 94
    XLIMITS 0 700
    YLIMITS 0 2
    HORIZONTAL SWITCH ON
    BOX PLOT LEAD X
 
-----FRAME PATTERN-----------------------------------------------------
 
FRAME PATTERN
 
Name:
    ...FRAME PATTERN
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the pattern of the plot frame on subsequent plots.
 
Description:
    The frame is the 4-sided box which surrounds the usual
    2-dimensional plot.  The analyst may control the pattern of each or
    all of the sides of the frame by specifying the pre-fix in the
    command.
 
Syntax:
    <prefix>FRAME PATTERN   <pattern>
    where <pattern> specifies the desired line pattern (enter HELP LINE
             TYPES for a list of available line patterns);
    and   <prefix> is one of the following:
       no prefix     refers to all 4 sides
       the prefix X  refers to both horizontal sides
       the prefix Y  refers to both vertical sides
       the prefix X1 refers to the lower horizontal side
       the prefix X2 refers to the upper horizontal side
       the prefix Y1 refers to the left vertical side
       the prefix Y2 refers to the right vertical side.
 
Examples:
    FRAME PATTERN SOLID
    FRAME PATTERN DASH
    FRAME PATTERN
    X2FRAME PATTERN DOTT
    Y2FRAME PATTERN SOLID
 
Note:
    A ...FRAME PATTERN command with no arguments sets the default.
    Thus X1FRAME PATTERN with no arguments sets the bottom horizontal
    frame line pattern to solid.  A ...FRAME PATTERN command with no
    prefix refers to all 4 sides.  Thus FRAME PATTERN DASH sets the
    frame line pattern to dash on all 4 sides.  Note also that FRAME
    PATTERN with no prefix and no arguments reverts the frame pattern
    on all 4 sides to the default.
 
Note:
    Normally all frame lines are set to the same pattern, so the most
    common form of this command is FRAME PATTERN with no prefix.
 
Default:
    All frame lines are solid.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    FRAME               = Sets the on/off switch for the plot frame.
    FRAME COORDINATES   = Sets the location for the plot frame.
    MINIMUM             = Sets the frame minima for subsequent  plots.
    MAXIMUM             = Sets the frame maxima for subsequent  plots.
    LIMITS              = Sets the frame limits for subsequent plots.
    GRID                = Sets the on/off switch for the plot grid.
    LOG                 = Sets the on/off switch for a log scale.
    TIC                 = Sets the on/off switch for the plot tics.
    MAJOR TIC NUMBER    = Sets the number of major tics.
    MINOR TIC NUMBER    = Sets the number of minor tics.
    TIC LABEL           = Sets the on/off switch for plot tic labels.
    TIC LABEL DECIMALS  = Sets the number of decimal places for plot
                          tic mark labels.
    MARGIN COLOR        = Sets the color for the plot margin.
    BACKGROUND COLOR    = Sets the color for the plot background.
    TITLE               = Sets the plot title.
    LABEL               = Sets the plot labels.
    LEGEND              = Sets the plot legends.
    LEGEND COORDINATES  = Sets the locations for plot legends.
    BOX COORDINATES     = Sets the locations for plot boxes.
    ARROW COORDINATES   = Sets the locations for plot arrows.
    SEGMENT COORDINATES = Sets the locations for plot segments.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    SERIAL READ LEAD
    164 426 59 98 312 263 607 497 213 54 160 262 547 325 419 94 70
    END OF DATA
    SERIAL READ POT
    106 175 61 79 94 121 424 328 107 218 140 179 246 231 245 339 99
    END OF DATA
    .
    TITLE DEMONSTRATE FRAME COLOR COMMAND
    X1FRAME COLOR G10
    X2FRAME COLOR G90
    Y1FRAME COLOR G25
    Y2FRAME COLOR G75
    FRAME THICKNESS 0.3
    X1LABEL LEAD
    Y1LABEL POTASSIUM
    CHARACTER CIRCLE
    CHARACTER SIZE 1.5
    LINE BLANK ALL
    PLOT POT VS LEAD
 
-----FRAME THICKNESS--------------------------------------------------
 
FRAME THICKNESS
 
Name:
    ...FRAME THICKNESS
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the thickness of the plot frame on subsequent plots.
 
Description:
    The frame is the 4-sided box which surrounds the usual
    2-dimensional plot.  The analyst can control the thickness of each
    or all of the sides of the frame by specifying the pre-fix in the
    command (see the SYNTAX section below).
 
Syntax:
    <prefix>FRAME THICKNESS   <thickness>
    where <thickness> specifies the desired line thickness;
    and   <prefix> is as follows:
       no prefix     refers to all 4 sides
       the prefix X  refers to both horizontal sides
       the prefix Y  refers to both vertical sides
       the prefix X1 refers to the lower horizontal side
       the prefix X2 refers to the upper horizontal side
       the prefix Y1 refers to the left vertical side
       the prefix Y2 refers to the right vertical side.
 
Examples:
    FRAME THICKNESS 0.1
    FRAME THICKNESS 0.2
    FRAME THICKNESS
    X2FRAME THICKNESS 0.3
    Y2FRAME THICKNESS 0.1
 
Note:
    A ...FRAME THICKNESS command with no arguments sets the default.
    Thus X1FRAME THICKNESS with no arguments sets the bottom horizontal
    frame line thickness to 0.1.  A ...FRAME THICKNESS command with no
    prefix refers to all 4 sides.  Thus FRAME THICKNESS 0.1 sets the
    frame line thickness to 0.1 on all 4 sides.  Note also that FRAME
    THICKNESS with no prefix and no arguments reverts the frame
    thickness settings on all 4 sides to the default.
 
Note:
    Normally all frame lines are set to the same thickness, so the most
    common form of this command is FRAME THICKNESS with no prefix.
 
Default:
    All frame lines use the default thickness (0.1).
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    FRAME               = Sets the on/off switch for the plot frame.
    FRAME COLOR         = Sets the color for the plot frame.
    FRAME COORDINATES   = Sets the location for the plot frame.
    MINIMUM             = Sets the frame minima for subsequent  plots.
    MAXIMUM             = Sets the frame maxima for subsequent  plots.
    LIMITS              = Sets the frame limits for subsequent plots.
    GRID                = Sets the on/off switch for the plot grid.
    LOG                 = Sets the on/off switch for a log scale.
    TIC                 = Sets the on/off switch for the plot tics.
    MAJOR TIC NUMBER    = Sets the number of major tics.
    MINOR TIC NUMBER    = Sets the number of minor tics.
    TIC LABEL           = Sets the on/off switch for plot tic labels.
    TIC LABEL DECIMALS  = Sets the number of decimal places for plot
                          tic mark labels.
    MARGIN COLOR        = Sets the color for the plot margin.
    BACKGROUND COLOR    = Sets the color for the plot background.
    TITLE               = Sets the plot title.
    LABEL               = Sets the plot labels.
    LEGEND              = Sets the plot legends.
    LEGEND COORDINATES  = Sets the locations for plot legends.
    BOX COORDINATES     = Sets the locations for plot boxes.
    ARROW COORDINATES   = Sets the locations for plot arrows.
    SEGMENT COORDINATES = Sets the locations for plot segments.
 
Applications:
    XX
 
Implementation Date:
    Pre-1987
 
Program:
    SERIAL READ LEAD
    164 426 59 98 312 263 607 497 213 54 160 262 547 325 419 94 70
    END OF DATA
    SERIAL READ POT
    106 175 61 79 94 121 424 328 107 218 140 179 246 231 245 339 99
    END OF DATA
    .
    TITLE DEMONSTRATE FRAME THICKNESS COMMAND
    X1FRAME THICKNESS 0.1
    X2FRAME THICKNESS 0.3
    Y1FRAME THICKNESS 0.2
    Y2FRAME THICKNESS 0.4
    X1LABEL LEAD
    Y1LABEL POTASSIUM
    CHARACTER CIRCLE
    CHARACTER SIZE 1.5
    LINE BLANK ALL
    PLOT POT VS LEAD
 
-----FRECHET PLOT--------------------------------------
 
FRECHET PLOT
 
Name:
    FRECHET PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a Frechet plot.
 
Description:
    The Frechet plot can be used to determine whether the 2-parameter
    Frechet distribution is an appropriate distributional model for a set
    of data.

    The Frechet plot is formed by

      1. Sort the data.  Call these points y(i).

      2. The x-axis coordinates are LN(y(i)).

      3. The y-axis coordinates are -LN(-LN(p(i))) where

             p(i) = (i - 0.3)/(n + 0.4)

    If the data come from a 2-parameter Frechet distribution, then
    the points on this plot should be approximately linear.
 
    If you fit a line to the points on this plot, the intercept can be
    used as an estimate of the scale parameter and the slope can be used
    as an estimate of the shape parameter.  However, the plot is generally
    used to determine if a 2-parameter Frechet is appropriate.  If the
    plot is approximately linear, then parameter estimates would usually
    be determined by maximum likelihood using the command

        FRECHET MAXIMUM LIKELIHOOD Y

    Maximum likelihood estimates would generally be preferred over the
    Frechet plot estimates since its statistical properties are better
    understood.

    Currently, this plot is supported for the maximum version of the
    Frechet distribution.  It is also only supported for the case with
    no censoring.  It is also not supported for grouped data.

    The characteristics of these components are controlled through the
    LINE and CHARACTER commands.  This is demonstrated in the program
    examples below.

    If you have groups in the data, you can specify a "highlight" option
    to draw the points in the different groups with different attributes.
    For example, this can be used to draw outliers in a different color.
    This is demonstrated in the second program example below.
 
Syntax 1:
    FRECHET PLOT <y>       <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    HIGHLIGHT FRECHET PLOT <y>  <x>     <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <x> is a group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    FRECHET PLOT Y1
    HIGHLIGHT FRECHET PLOT Y1 X
 
Note:
    The following internal parameters are saved after a FRECHET PLOT.
    These parameters can be used like any user created parameter by
    the analyst.

        SHAPE   - the slope of the fitted line as an estimate of the
                  shape parameter
        SCAL    - the intercept of the fitted line as an estimate of the
                  scale parameter
        BPT1    - the 0.1% point of the best fit distribution
        BPT5    - the 0.5% point of the best fit distribution
        BP1     - the 1% point of the best fit distribution
        BP5     - the 5% point of the best fit distribution
        BP10    - the 10% point of the best fit distribution
        BP20    - the 20% point of the best fit distribution
        BP50    - the 50% point of the best fit distribution
        BP80    - the 80% point of the best fit distribution
        BP90    - the 90% point of the best fit distribution
        BP95    - the 95% point of the best fit distribution
        BP99    - the 99% point of the best fit distribution
        BP995   - the 99.5% point of the best fit distribution
        BP999   - the 99.9% point of the best fit distribution

    The percent point estimates are computed by using the estimates of
    scale (SCAL) and shape (SHAPE) obtained from the plot and plugging
    these values into the Frechet percent point function.
 
Note:
    The Frechet plot is similar in concept to a Frechet probability plot.
    However, a few distinctions should be noted.

       1. The Frechet plot is based on a 2-parameter Frechet distribution.
          A Frechet probability plot is based on a 3-parameter Frechet
          distribution.

       2. The Frechet plot linearization is specific to the Frechet
          distribution.  The probability plot linearization can be used
          for any distribution.  For the probability plot method, the
          ppcc plot is used to estimate the shape parameter and then the
          probability plot is used to estimate the location and scale
          parameters and to assess the goodness of fit.

Default:
    None
 
Synonyms:
    SUBSET is a synonym for HIGHLIGHT
 
Related Commands:
    LINES               = Sets the type for plot lines.
    CHARACTER           = Sets the type for plot characters.
    PROBABILITY PLOT    = Generates a probability plot.
    PPCC PLOT           = Generates a ppcc plot.
    NORMAL PLOT         = Generates a normal plot.
    WEIBULL PLOT        = Generates a Weibull plot.
    MAXIMUM LIKELIHOOD  = Estimate distribution parameters using
                          maximum likelihood.

Reference:
    Karl Bury (1999), "Statistical Distributions in Engineering",
    Cambridge University Press, chapter 16.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2013/10
 
Program 1:
    . Step 1:  Read the data
    .
    skip 25
    read frechet.dat y
    skip 0
    .
    . Step 2:  Set plot control features
    .
    label case asis
    title case asis
    title offset 2
    character X blank
    line blank solid
    title Frechet Plot for FRECHET.DAT
    y1label -LN(-LN(P(i)))
    x1label LN(y(i))
    x2label P(i) = (i - 0.3)/(n + 0.4)
    .
    . Step 3:  Generate the plot
    .
    frechet plot y
 
Program 2:
    . Demonstrate the HIGHLIGHT option
    .
    . Step 1:  Read the data
    .
    skip 25
    read frechet.dat y
    skip 0
    let n = size y
    let x = 0 for i = 1 1 n
    let x = 1 subset y > 22
    let x = 1 subset y < 14
    .
    . Step 2:  Set plot control features
    .
    label case asis
    title case asis
    title offset 2
    character circle circle blank
    character hw 1 0.75 all
    character fill on on
    character color black red
    line blank blank solid
    title Frechet Plot for FRECHET.DAT
    y1label -LN(-LN(P(i)))
    x1label LN(y(i))
    x2label P(i) = (i - 0.3)/(n + 0.4)
    .
    . Step 3:  Generate the plot
    .
    highlight frechet plot y x
 
-----FREQUENCY (LET)---------------------------------------------------
 
FREQUENCY
 
Name:
    FREQUENCY (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the frequencies of distinct values of a variable.
 
Description:
    One variable (Y) contains a set of values while a second variable
    (XD) contains a set of distinct values (generally smaller than the
    first variable).  The computed frequency variable (same size as XD)
    contains the number of times each value in XD occurred in Y.
 
Syntax:
    LET <freq> = FREQUENCY <y1> <xd>  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a response variable;
          <xd> is a variable containing the values to compute
              frequencies for (smaller than <y1>);
          <freq> is a variable where the computed frequencies are
              saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y2 = FREQUENCY Y1 XD
    LET YFREQ = FREQUENCY Y1 XD SUBSET XD > 0
 
Note:
    If you want a frequency table corresponding to the number of values
    of a variable falling within given intervals or bins (either
    DATAPLOT selected or user selected), then use the HISTOGRAM or
    FREQUENCY PLOT command to generate a histogram or frequency plot.
    The internal variables XPLOT and YPLOT will constitute a frequency
    table (XPLOT is the mid-point of the bin, YPLOT is the count for
    that bin).  Note that these variables are overwritten at the next
    plot.  However, you can copy them to your own variables (e.g., LET
    YCOUNT = YPLOT and LET XMDPT = XPLOT).
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FREQUENCY PLOT = Generate a frequency plot.
    HISTOGRAM      = Generate a histogram.
    STEM AND LEAF  = Generate a stem and leaf plot.
    COCODE         = Generate a cocoded variable.
    CODE           = Generate a coded variable.
    SEQUENCE       = Generate a sequence of numbers.
    PATTERN        = Generate numbers with a specific pattern.
 
Applications:
    XX
 
Implementation Date:
    XX.X
 
Program:
    LET Y1 = DATA 1 4 3 3 3 3 1 2 1 1 3 3 4 3 2 2 3
    LET XD = DISTINCT Y1
    LET Y2 = FREQUENCY Y1 XD
    The variable Y2 will contain the following values:
       4, 3, 8, 2 (corresponding to the number of times that 1, 2, 3, 4
       occur in Y1 respectively).
 
-----FREQUENCY PLOT---------------------------------------------------
 
FREQUENCY PLOT
 
Name:
    ... FREQUENCY PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a frequency plot.
 
Description:
    A frequency plot is a graphical data analysis technique for
    summarizing the distributional information of a variable.  The
    response variable is divided into equal sized intervals (or bins).
    The number of occurrences of the response variable is calculated
    for each bin.  The frequency plot then consists of:

       Vertical   axis = frequencies or relative frequencies;
       Horizontal axis = response variable (i.e., the mid-point of each
                         interval).

    There are 4 types of frequency plots:

          1) frequency plot (absolute counts);
          2) relative frequency plot (convert counts to proportions);
          3) cumulative frequency plot;
          4) cumulative relative frequency plot.

    The frequency plot and the histogram have the same information
    except the frequency plot has lines connecting the frequency values
    whereas the histogram has bars at the frequency values.
 
Syntax 1:
    <type>  <y>         <SUBSET/EXCEPT/FOR qualification>
    where <type> is one of FREQUENCY, RELATIVE FREQUENCY,
              CUMULATIVE FREQUENCY, CUMULATIVE RELATIVE FREQUENCY;
          <y> is the variable of raw data values which will appear on
              the horizontal axis;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used when you have raw data.  Note that <x> can
    be either a variable or a matrix.  If <x> is a matrix, then
    a histogram will be generated for all values in that matrix.
 
Syntax 2:
    <type>  <y>  <x>              <SUBSET/EXCEPT/FOR qualification>
    where <type> is one of FREQUENCY, RELATIVE FREQUENCY,
              CUMULATIVE FREQUENCY, CUMULATIVE RELATIVE FREQUENCY;
          <y> is a variable containing pre-computed frequencies;
          <x> is a variable containing the bin mid-points;
    and where the <SUBSET/EXCEPT/FOR qualification is optional.
 
    This syntax is used when you have grouped data with equi-sized
    bins.
 
Syntax 3:
    <type>  <y>  <xlow>  <xhigh>     <SUBSET/EXCEPT/FOR qualification>
    where <type> is one of FREQUENCY, RELATIVE FREQUENCY,
              CUMULATIVE FREQUENCY, CUMULATIVE RELATIVE FREQUENCY;
          <y> is a variable containing pre-computed frequencies;
          <xlow> is a variable containing the lower limits for the bins;
          <xhigh> is a variable containing the upper limits for the bins;
    and where the <SUBSET/EXCEPT/FOR qualification is optional.
 
    This syntax is used when you have grouped data with unequal sized
    bins.
 
Syntax 4:
    MULTIPLE FREQUENCY PLOT  <y1> ... <yk>
                             <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax will overlay multiple frequency plots on the
    same plot.

    Note that the response variables (<y1> ... <yk>) can be either
    variables or matrices (or a mix of variables and matrices).  For
    matrices, a frequency plot will be generated for all values in
    the matrix.

Syntax 5:
    REPLICATED FREQUENCY PLOT  <y>  <x1>
                               <SUBSET/EXCEPT/FOR qualification>
    where <y>  is the response variable;
          <x1> is a group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax will generate a frequency plot for each distinct
    value in the group-id variable.  The frequency plots will be
    generated on the same page.

Syntax 6:
    REPLICATED FREQUENCY PLOT  <y>  <x1> <x2>
                               <SUBSET/EXCEPT/FOR qualification>
    where <y>  is the response variable;
          <x1> is the first group-id variable;
          <x2> is the second group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax will cross tabulate the group-id variables and
    generate a frequency plot for each unique combination of values
    for the <x1> and <x2> group-id variables.  The frequency plots
    will be generated on the same page.
 
Examples:
    FREQUENCY PLOT TEMP
    RELATIVE FREQUENCY PLOT TEMP
    CUMULATIVE FREQUENCY PLOT TEMP
    CUMULATIVE RELATIVE FREQUENCY PLOT TEMP
    FREQUENCY PLOT COUNTS STATE
    RELATIVE FREQUENCY PLOT COUNTS STATE
    CUMULATIVE FREQUENCY PLOT COUNTS STATE
    CUMULATIVE RELATIVE FREQUENCY PLOT COUNTS STATE
 
Note:
    Although DATAPLOT does not have a FREQUENCY TABLE command, one can
    be generated with the following commands:

       FREQUENCY PLOT Y
       LET YFREQ = YPLOT
       LET XVAL = XPLOT

    Then the variables YFREQ and XVAL essentially contain a frequency
    table.  There is a LET subcommand called FREQUENCY.  However, it
    does not generate a frequency table in the sense that a frequency
    plot does.  You can also use the command

         LET Y2 X2 = BINNED Y

    for this purpose.
 
Note:
    By default, DATAPLOT uses a class width of 0.3 X the standard
    deviation of the variable.  Use the CLASS WIDTH command to override
    this default.  DATAPLOT also tends to generate a large number of
    zero frequency classes at the lower and upper tails.  This tends to
    compress the frequency plot on the horizontal axis.  Use the
    XLIMITS command or the CLASS LOWER and CLASS UPPER commands to
    avoid plotting these zero frequency classes.
 
    A number of alternative choices for class width can be set
    with the command

        SET HISTOGRAM CLASS WIDTH

    Enter HELP HISTOGRAM CLASS WIDTH for details.

Note:
    By default, Dataplot sets the lower and upper class limits to
    xbar -/+ 6*s (with xbar and s denoting the sample mean and
    standard deviation, respectively).  This can occassionally result
    in a few outlying points being excluded from the histogram.  To
    adjust the lower and upper class limits so that these outlying
    points are included, enter the command

        SET HISTOGRAM OUTLIERS ON

    To revert to the default, enter

       SET HISTOGRAM OUTLIERS OFF

Note:
    The FREQUENCY PLOT supports the TO syntax for the list
    of variable names.  This is most useful for the MULTIPLE
    case.

Default:
    None
 
Synonyms:
    A synonym for CUMULATIVE RELATIVE FREQUENCY PLOT is RELATIVE
    CUMULATIVE FREQUENCY PLOT.
 
Related Commands:
    HISTOGRAM            = Generates a histogram.
    KERNEL DENSITY PLOT  = Generates a histogram.
    PIE CHART            = Generates a pie chart.
    PERCENT POINT PLOT   = Generates a percent point plot.
    PROBABILITY PLOT     = Generates a probability plot.
    PPCC PLOT            = Generates probability plot correlation
                           coefficient plot.
    CLASS LOWER          = Sets the lower class minimum for histograms,
                           frequency plots, and pie charts.
    CLASS UPPER          = Sets the upper class maximum for histograms,
                           frequency plots, and pie charts.
    CLASS WIDTH          = Sets the class width for histograms, frequency
                           plots, and pie charts.
    MINIMUM              = Sets the frame minima for all plots.
    MAXIMUM              = Sets the frame maxima for all plots.
    LIMITS               = Sets the frame limits for all plots.
    PLOT                 = Generates a data or function plot.
    BARS                 = Sets the on/off switches for plot bars.
 
Reference:
    Most introductory statistics book discuss frequency polygons and
    histograms.
 
    David Scott (1992), "Multivariate Density Estimation",
    John Wiley, (chapter 3).
 
Applications:
    Exploratory Data Analysis, Distributional Analysis
 
Implementation Date:
    Pre-1987
 
Program:
    LET Y = NORMAL RANDOM NUMBERS FOR I = 1 1 1000
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    MULTIPLOT SCALE FACTOR 2
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    XLIMITS -5 5
    TITLE Counts Frequency Plot
    FREQUENCY PLOT Y
    TITLE Relative Frequency Plot
    RELATIVE FREQUENCY PLOT Y
    TITLE Cumulative Counts Frequency Plot
    CUMULATIVE FREQUENCY PLOT Y
    TITLE Cumulative Relative Frequency Plot
    CUMULATIVE RELATIVE FREQUENCY PLOT Y
    END OF MULTIPLOT
 
-----FREQUENCY TEST------------------------------------
 
FREQUENCY TEST
 
Name:
    FREQUENCY TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform a frequency or frequency within a block test for
    randomness.
 
Description:
    The frequency (or frequency within a block) test is used
    to test the randomness of a sequence of zeroes and ones
    (Dataplot will covert a data set with exactly two distinct
    values to a sequence of zeroes and ones).  The test is based
    on the proportion of zeroes and ones.  Specifically, it tests
    the closeness of the proportion of ones to 0.5.  The frequency
    within a block test is a refinement that tests the proportion
    of ones within M-value blocks.

    The frequency test is defined as follows.

    H0:          The data are random.
    Ha:          The data are not random.

    Test         The test statistic is
    Statistic: 
                     s(obs) = |S(n)|/SQRT(n)

                 with n denoting the number of observations in the
                 sequence and S(n = X1 + X2 + ... + X(n).  The
                 X(i) are the data values where the zero values
                 have been converted to negative ones.

    Significance alpha (typically set to 0.01 for this test)
    Level:
    
    Critical     s(obs) > NORPPF(1-alpha/2)
    Region:
 
    Conclusion:  Reject H0 if the test statistic is greater than
                 the critical value.

    For the frequency within a block test, we partition the
    input values into N=[n/m] non-overlapping blocks with n
    denoting the number of observations and m the number of
    observations within a block.  Any unused observations are
    discarded.  The frequency within a block test is then defined
    as follows.

    H0:          The data are random.
    Ha:          The data are not random.

    Test         Compute the proportion pi(i) of ones in each
    Statistic:   block (i.e., the number of ones in the block
                 divided by m).  The test statistic is

                 chi-square(obs) = 4*m*SUM[i=1 to N][(pi(i) - 0.5)**2]

    Significance alpha (typically set to 0.01 for this test)
    Level:
    
    Critical     Compute the p-value
    Region:
                     IGAMC(N/2,chi-square(N/2,chi-square(obs)/2)

                 with IGAMC denoting the incomplete gamma
                 function (enter HELP GAMIP for details).
 
    Conclusion:  Reject H0 if the p-value < alpha.


Syntax 1:
    FREQUENCY TEST   <y>    <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable being tested;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    MULTIPLE FREQUENCY TEST <y1> ... <yk>
                            <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of 1 to 30 response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    The keyword MULTIPLE is optional.  The frequency test will be
    performed on each response variable and these response variables
    can be matrices.  The TO syntax is supported for the variable list.

Syntax 3:
    REPLICATED FREQUENCY TEST <y> <x1> ... <xk>
                              <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <x1> ... <xk> is a list of 1 to 6 group-id variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax will cross-tabulate the group-id variables and performs
    the frequency test for each unique combination of cross-tabulated
    values.  For example, if X1 has 3 levels and X2 has 2 levels, there
    will be 6 frequency tests performed.  This syntax does not support
    matrix arguments and the keyword REPLICATED is required (to
    distinguish this from the MULTIPLE case).  The TO syntax is
    supported for the variable list.

Syntax 4:
    FREQUENCY BLOCK TEST   <y>    <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable being tested;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The length of the block is set by entering the command

        LET M = <value>

    before entering the FREQUENCY BLOCK TEST command.

Syntax 5:
    MULTIPLE FREQUENCY BLOCK TEST <y1> ... <yk>
                                  <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of 1 to 30 response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    The keyword MULTIPLE is optional.  The frequency test will be
    performed on each response variable and these response variables
    can be matrices.  The TO syntax is supported for the variable list.

Syntax 3:
    REPLICATED FREQUENCY BLOCK TEST <y> <x1> ... <xk>
                                    <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <x1> ... <xk> is a list of 1 to 6 group-id variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax will cross-tabulate the group-id variables and performs
    the frequency block test for each unique combination of
    cross-tabulated values.  For example, if X1 has 3 levels and X2 has
    2 levels, there will be 6 frequency block tests performed.  This
    syntax does not support matrix arguments and the keyword REPLICATED
    is required (to distinguish this from the MULTIPLE case).  The TO
    syntax is supported for the variable list.

Examples:
    FREQUENCY TEST Y
    FREQUENCY TEST Y1 TO Y10
    REPLICATED FREQUENCY TEST Y X1 X2

    LET M = 20
    FREQUENCY BLOCK TEST Y SUBSET TAG > 1
 
Note:
    The following statistics are also supported:

        LET A = FREQUENCY TEST                     Y
        LET A = FREQUENCY TEST CDF                 Y
        LET A = FREQUENCY WITHIN A BLOCK TEST      Y
        LET A = FREQUENCY WITHIN A BLOCK TEST CDF  Y

    Enter HELP STATISTICS to see what commands can use these
    statistics.

Note:
    If you want to test a uniform random number generator,
    you can use this test by converting the uniform random
    numbers to binomial random numbers.  For example,

        LET N = 1
        LET P = 0.5
        LET Y = BINOMIAL RANDOM NUMBERS FOR I = 1 1 1000
        FREQUENCY TEST Y

Note:
    The recommended minimum sample size for both the frequency test
    and for the frequency within a block test is 100.

    For the frequency within a block test, it is additionally
    recommended that the block size should be at least 20 and
    it should also be greater than or equal to 0.01 times the sample
    size.  It is recommended that the number of samples within
    a block be less than 100.

Default:
    None
 
Synonyms:
    FREQUENCY WITHIN A BLOCK TEST and FREQUENCY WITHIN BLOCK TEST
    are synonyms for FREQUENCY BLOCK TEST.
 
Related Commands:
    CUSUM TEST                = Perform a cumulative sum test for
                                randomness.
    RUNS TEST                 = Perform a runs test for randomness.
    ANDERSON-DARLING TEST     = Peform an Anderson-Darling test for
                                randomness.
    UNIFORM PROBABILITY PLOT  = Generate a uniform probability plot.
 
Reference:
    "A Statistical Test Suite for Random and Psuedorandom Number
    Generators for Cryptographic Applications", Andrew Rukhin,
    Juan Soto, James Nechvatal, Miles Smid, Elaine Barker,
    Stefan Leigh, Mark Levenson, Mark Vangel, David Banks,
    Alan Heckert, James Dray, San Vo, NIST SP 800-22, October, 2000.

 
Applications:
    Testing for Randomness
 
Implementation Date:
    2004/1
    2011/3: Support for MULTIPLE option
    2011/3: Support for REPLICATION option
    2011/3: Support for matrix arguments and the TO syntax
    2011/3: Output reformatted, added support for RTF output
    2011/3: Support for SET WRITE DECIMALS
    2011/3: Added FREQUENCY TEST statistics
 
Program:
    LET N = 1
    LET P = 0.5
    LET Y1 = BINOMIAL RANDOM NUMBERS FOR I = 1 1 200
    LET P = 0.58
    LET Y2 = BINOMIAL RANDOM NUMBERS FOR I = 1 1 200
    LET P = 0.65
    LET Y3 = BINOMIAL RANDOM NUMBERS FOR I = 1 1 200
    LET P = 0.85
    LET Y4 = BINOMIAL RANDOM NUMBERS FOR I = 1 1 200
    SET WRITE DECIMALS 4
    .
    FREQUENCY TEST Y1
    FREQUENCY TEST Y1 Y2 Y3
    .
    LET M = 20
    FREQUENCY BLOCK TEST Y1
  
-----FREQUENCY TO RAW---------------------------------------------
 
FREQUENCY TO RAW
 
Name:
    FREQUENCY TO RAW (LET)
 
Type:
    LET Subcommand
 
Purpose:
    Convert data in frequency format to raw format.
 
Description:
    At times, data will be collected in a frequency format
    (i.e., a value with a count of how many times that value
    occurred).  However, you may want to use Dataplot commands
    that expect the data to be given in a single column format.
    For example, if X = 2.3 has a count of 20, the value of
    2.3 will simply be repeated 20 times.

    Note that the maximum limit on the size of a Dataplot
    variables still applies.  So if the sum of the counts
    array exceeds this limit, an error will be returned.

Syntax:
    LET <y> = FREQUENCY TO RAW  <xval> <count>
                       <SUBSET/EXPCEPT/FOR qualification>
    where <xval> is a variable that contains the numeric values;
          <count> is a variable that contains the counts
               corresponding to <xval>;
          <y> is the variable to contain the raw data;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y = FREQUENCY TO RAW XVAL XFREQ
 
Default:
    None.
 
Synonyms:
    None
 
Related Commands:
    EXTEND        = Extends a variable by another variable.
    LET           = Creates, transforms, etc. a variable.
    STACK         = Convert a set of response variables to a
                    single response variable and a tag variable.
 
Applications:
    Data Management
 
Implementation Date:
    2004/5
 
Program:
    READ xval freq
    0  174
    1  112
    2  54
    3  14
    4  4
    5  1
    6  1
    END OF DATA
    LET Y = FREQUENCY TO RAW XVAL FREQ
    HERMITE MAXIMUM LIKELIHOOD Y
 
-----FRESNC (LET)--------------------------------
 
FRESNC
 
Name:
    FRESNC (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Fresnel cosine integral.
 
Description:
    The Fresnel cosine integral is defined as:
        C(x) = INTEGRAL(COS((PI/2)*t**2)dt
    where the integral is taken from 0 to x.

Syntax:
    LET <y> = FRESNC(<x>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, variable, or parameter;
          <y> is a variable or a parameter (depending on what <x> is
               where the computed FRESNC integral values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = FRESNC(0.1)
    LET A = FRESNC(X)
 
Note:
    DATAPLOT uses ACM algorithm 723 from the ACM Transactions of
    Mathematical Software (see the REFERENCE section below) to
    compute the Fresnel integrals.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FRESNS     = Compute the Fresnel sine integral.
    FRESNF     = Compute the Fresnel auxillary function f.
    FRESNG     = Compute the Fresnel auxillary function g.
    DAWS       = Compute the Dawson integral.
    ERF        = Compute the error function.
    ERFC       = Compute the complementary error function.
    SININT     = Compute the sine integral.
    SININT     = Compute the cosine integral.
    EXPINTN    = Compute the exponential integral of order N.
    LOGINT     = Compute the logarithmic integral.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 7).
 
    "Algorithm 723: Fresnel Integrals", Snyder, ACM Transactions on
    Mathematical Software, Volume 19, Number 4, 1993, (pp. 452-456).

Applications:
    Special Functions
 
Implementation Date:
    94/11
 
Program:
    TITLE AUTOMATIC
    PLOT FRESNC(X) FOR X = -5 0.1 5
 
-----FRESNF (LET)--------------------------------
 
FRESNF
 
Name:
    FRESNF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Fresnel auxillary function f.
 
Description:
    The Fresnel auxillary function f is defined as:
        f(x) = [0.5-S(x)]*COS(PI*x*x/2) - [0.5-C(x)]*SIN(PI*x*x/2)
    where S is the Fresnel sine integral function and C is the Fresnel
    cosine integral function.

Syntax:
    LET <y> = FRESNF(<x>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, variable, or parameter;
          <y> is a variable or a parameter (depending on what <x> is
               where the computed FRESNF integral values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = FRESNF(0.1)
    LET A = FRESNF(X)
 
Note:
    DATAPLOT uses ACM algorithm 723 from the ACM Transactions of
    Mathematical Software (see the REFERENCE section below) to
    compute the Fresnel integrals and Fresnel auxillary functions.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FRESNC     = Compute the Fresnel cosine integral.
    FRESNS     = Compute the Fresnel sine integral.
    FRESNG     = Compute the Fresnel auxillary function g.
    DAWS       = Compute the Dawson integral.
    ERF        = Compute the error function.
    ERFC       = Compute the complementary error function.
    SININT     = Compute the sine integral.
    SININT     = Compute the cosine integral.
    EXPINTN    = Compute the exponential integral of order N.
    LOGINT     = Compute the logarithmic integral.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 7).
 
    "Algorithm 723: Fresnel Integrals", Snyder, ACM Transactions on
    Mathematical Software, Volume 19, Number 4, 1993, (pp. 452-456).

Applications:
    Special Functions
 
Implementation Date:
    94/11
 
Program:
    TITLE AUTOMATIC
    PLOT FRESNF(X) FOR X = -5 0.1 5
 
-----FRESNG (LET)--------------------------------
 
FRESNG
 
Name:
    FRESNG (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Fresnel auxillary function g.
 
Description:
    The Fresnel auxillary function g is defined as:
        g(x) = [0.5-C(x)]*COS(PI*x*x/2) + [0.5-S(x)]*SIN(PI*x*x/2)
    where S is the Fresnel sine integral function and C is the Fresnel
    cosine integral function.

Syntax:
    LET <y> = FRESNG(<x>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, variable, or parameter;
          <y> is a variable or a parameter (depending on what <x> is
               where the computed FRESNG integral values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = FRESNG(0.1)
    LET A = FRESNG(X)
 
Note:
    DATAPLOT uses ACM algorithm 723 from the ACM Transactions of
    Mathematical Software (see the REFERENCE section below) to
    compute the Fresnel integrals and Fresnel auxillary functions.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FRESNC     = Compute the Fresnel cosine integral.
    FRESNS     = Compute the Fresnel sine integral.
    FRESNF     = Compute the Fresnel auxillary function f.
    DAWS       = Compute the Dawson integral.
    ERF        = Compute the error function.
    ERFC       = Compute the complementary error function.
    SININT     = Compute the sine integral.
    SININT     = Compute the cosine integral.
    EXPINTN    = Compute the exponential integral of order N.
    LOGINT     = Compute the logarithmic integral.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 7).
 
    "Algorithm 723: Fresnel Integrals", Snyder, ACM Transactions on
    Mathematical Software, Volume 19, Number 4, 1993, (pp. 452-456).

Applications:
    Special Functions
 
Implementation Date:
    94/11
 
Program:
    TITLE AUTOMATIC
    PLOT FRESNG(X) FOR X = -5 0.1 5
 
-----FRESNS (LET)--------------------------------
 
FRESNS
 
Name:
    FRESNS (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Fresnel sine integral.
 
Description:
    The Fresnel sine integral is defined as:
        C(x) = INTEGRAL(SIN((PI/2)*t**2)dt
    where the integral is taken from 0 to x.

Syntax:
    LET <y> = FRESNS(<x>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, variable, or parameter;
          <y> is a variable or a parameter (depending on what <x> is
               where the computed FRESNS integral values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = FRESNS(0.1)
    LET A = FRESNS(X)
 
Note:
    DATAPLOT uses ACM algorithm 723 from the ACM Transactions of
    Mathematical Software (see the REFERENCE section below) to
    compute the Fresnel integrals.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FRESNC     = Compute the Fresnel cosine integral.
    FRESNF     = Compute the Fresnel auxillary function f.
    FRESNG     = Compute the Fresnel auxillary function g.
    DAWS       = Compute the Dawson integral.
    ERF        = Compute the error function.
    ERFC       = Compute the complementary error function.
    SININT     = Compute the sine integral.
    SININT     = Compute the cosine integral.
    EXPINTN    = Compute the exponential integral of order N.
    LOGINT     = Compute the logarithmic integral.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 7).
 
    "Algorithm 723: Fresnel Integrals", Snyder, ACM Transactions on
    Mathematical Software, Volume 19, Number 4, 1993, (pp. 452-456).

Applications:
    Special Functions
 
Implementation Date:
    94/11
 
Program:
    TITLE AUTOMATIC
    PLOT FRESNS(X) FOR X = -5 0.1 5
 
-----FRIEDMAN TEST-----------------------------------------
 
FRIEDMAN TEST
 
Name:
    FRIEDMAN TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform a Friedman test that k treatments have identical effects.
 
Description:
    The Friedman test is a non-parametric test for analyzing
    randomized complete block designs.  It is an extension of
    the sign test when there may be more than two treatments.

    The Friedman test assumes that there are k experimental
    treatments (k >= 2).  The observations are arranged in
    p blocks, that is

                     Treatment
    Block  1    2      ...      k
      1   X11  X12     ...     X1k
      2   X21  X22     ...     X2k
      3   X31  X32     ...     X3k
     ...  ...  ...     ...     ...
      b   Xb1  Xb2     ...     Xbk

    Let R(Xij) be the rank assigned to Xij within block i (i.e.,
    ranks within a given row).  Average ranks are used in the case
    of ties.  The ranks are summed to obtain

         R(j) = SUM[i=1 to b]R(X(ij))

    Then the Friedman test is 

        H0: The treatment effects have identical effects
        HA: At least one treatment is different from at least
            one other treatment
        Test Statistic:
            T1 = 12/[b*k*(k+1)]*SUM[i=1 to k][(R(i) - b*(k+1)/2)**2]

            If there are ties, then

            T1 = (k-1)*SUM[i=1 to k][(R(i) - b*(k+1)/2)**2]/(A1 - C1)
                        
            where

            A1 = SUM[i=1 to b][j=1 to k][R(X(ij))]**2
            C1 = b*k*(k+1)**2/4

            Note that Conover recommends the statistic

            T2 = (b-1)*T1/(b*(k-1) - T1)

            since it has a more accurate approximate distribution.
            The T2 statistic is the two-way analysis of variance
            statistic computed on the ranks R(X(ij)).
        Significance Level: ALPHA
        Critical Region:
            T2 > FPPF(ALPHA,K-1,(b-1)*(k-1)) where FPPF is the F
            percent point function.
                   
            T1 > CHSPPF(ALPHA,K-1) where CHSPPF is the chi-square
            percent point function.

            The T1 approximation is sometimes poor, so the T2
            approximation is typically preferred.
        Conclusion: Reject the null hypothesis if the test
                    statistic is in the critical region.

    If the hypothesis of identical treatment effects is rejected,
    it is often desirable to determine which treatments are
    different (i.e., multiple comparisons).  Treatments i and j
    are considered different if

       |R(j) - R(i)| > TPPF(1-alpha/2,(k-1)*(b-1))*
             SQRT[2*(b*A1 - SUM[j=1 to k][R(j)**2]/((b-1)*(k-1))]

Syntax:
    FRIEDMAN TEST  <y>  <block> <treat>
                        <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <block> is a variable that identifies the block;
          <treat> is a variable that identifies the treatment;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    FRIEDMAN TEST Y BLOCK TREATMENT
    FRIEDMAN TEST Y X1 X2
    FRIEDMAN TEST Y BLOCK TREATMENT  SUBSET BLOCK > 2
 
Note:
    In Dataplot, the variables should be given as:
 
        Y   BLOCK   TREAT
       X11    1      1
       X12    1      2
       ...    1     ...
       X1k    1      k 
       X21    2      1
       X22    2      2
       ...    2     ...
       X2k    2      k 
 
       ...   ...    ...
 
 
       Xb1    b      1
       Xb2    b      2
       ...    b     ...
       Xb3    b      k 
 
    If your data are in a format similar to that given in the
    DESCRIPTION section (i.e., you have colums Y1 to Yk, each
    with b rows), you can convert it to the format required by
    Dataplot with the commands:

       LET NBLOCK = SIZE Y1
       LET BLOCKID = SEQUENCE 1 1 NBLOCK
       LET Y BLOCK TREAT = REPLICATED STACK Y1 Y2 Y3 Y4 Y5 BLOCKID
       FRIEDMAN TEST Y BLOCK TREAT

Note:
    The response, ranked response, block, and treatment are
    written to the file dpst1f.dat in the current directory.
 
    The treatment ranks and multiple comparisons are written to
    the file dpst2f.dat in the current directory.  Comparisons
    that are statistically significant at the 95% level are
    flagged with a single asterisk while comparisons that are
    statistically significant at the 99% level are flagged with
    two asterisks.

Note:
    The Friedman test is based on the following assumptions:

       1) The b rows are mutually independent.  That means that
          the results within one block (row) do not affect
          the results within other blocks.

       2) The data can be meaningfully ranked.

Note:
    The following statistics are also supported:

        LET A = FRIEDMAN TEST         Y X1 X2
        LET A = FRIEDMAN TEST CDF     Y X1 X2
        LET A = FRIEDMAN TEST PVALUE  Y X1 X2

    Enter HELP STATISTICS to see what commands can use these
    statistics.

Note:
    The Quade test is similar to the Friedman test.  A few distinctions:

        1) For k = 2, the Friedman test is equivalent to a sign test while
           the Quade test is equivalent to a signed rank test.

        2) According to Conover, the Quade test is typically more powerful
           for k < 5 while the Friedman test tends to become more powerful
           for k >= 5.

        3) The Friedman test only requires ordinal scale data (i.e., the
           data can be ranked) while the Quade test requires at least
           interval scale data (the range within a block can be computed).

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    QUADE TEST            = Perform a Quade test.
    ANOVA                 = Perform an analysis of variance.
    DURBIN TEST           = Perform a Durbin test for two-way
                            incomplete balanced block designs.
    COCHRAN TEST          = Perform a Cochran test for two-way
                            complete block designs (binary data).
    KRUSKAL WALLIS        = Perform a Kruskall Wallis test.
    SIGN TEST             = Perform a sign test.
    MEDIAN POLISH         = Carries out a robust ANOVA.
    T TEST                = Carries out a t test.
    RANK SUM TEST         = Perform a rank sum test.
    SIGNED RANK TEST      = Perform a signed rank test.
    BLOCK PLOT            = Generate a block plot.
    DEX SCATTER PLOT      = Generates a dex scatter plot.
    DEX ... PLOT          = Generates a dex plot for a statistic.
    DEX ... EFFECTS PLOT  = Generates a dex effects plot for a
 
Reference:
    "Practical Nonparametric Statistics", Third Edition, Wiley,
    1999, pp. 367-373.
    
 
Applications:
    Analysis of Variance
 
Implementation Date:
    2004/1
    2006/1: Corrected algorithm so it worked correctly on
            data that was not pre-ranked
 
Program:
    SKIP 25
    READ FRIEDMAN.DAT Y BLOCK TREAT
    SET WRITE DECIMALS 5
    FRIEDMAN Y BLOCK TREAT
 
-----FTCDF (LET)--------------------------------
 
FTCDF
 
Name:
    FTCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the folded t cumulative distribution function with NU
    degrees of freedom.  The degrees of freedom parameter should
    be a positive integer.
 
Description:
    The folded t distribution is the absolute value of the
    t distribution.  For details of the t distribution, enter
    HELP TPDF.

    The folded t cumulative distribution function is computed
    using the t cumulative distribution as follows:

       FTCDF(x,nu) = 2*TCDF(x,nu) - 1.0

    The folded t distribution provides an alternative to the
    half-normal or half-Cauchy in distributional modeling
    applications.  A folded t with 1 degree of freedom is
    equivalent to a half-Cauchy and the folded t approximates
    the half-normal as the degrees of freedom gets large (in
    practice, the approximation is quite good for degrees of
    freedom > 30).  Thus the folded t allows you to model
    with tails that can vary from normal to Cauchy in behavior.
 
Syntax:
    LET <y> = FTCDF(<x>,<nu>)     <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed folded t cdf value is stored;
          <nu> is a positive number or parameter that specifies the
               degrees of freedom;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = FTCDF(3,10)
    LET Y2 = FTCDF(X1,10)
    LET Y = FTCDF(X,10)  SUBSET X > 2
    PLOT FTCDF(X,3) FOR X = 0.01  0.01  10
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FTPDF   = Compute the folded t probability density function.
    FTPPF   = Compute the folded t percent point function.
    TPDF    = Compute the t probability density function.
    STPDF   = Compute the skewed t probability density function.
    HFNPDF  = Compute the half-normal probability density function.
    FNRPDF  = Compute the folded normal probability density function.
    HFCPDF  = Compute the half-Cauchy probability density function.
 
Reference:
    "Continuous Univariate Distributions, Volume 1", Second Edition,
    Johnson, Kotz, and Balakrishnan, Wiley, 1994.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2004/1
 
Program:
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    MULTIPLOT SCALE FACTOR
    MULTIPLOT 2 2
    TITLE AUTOMATIC
    PLOT FTCDF(X,1)  FOR X = 0  0.01  10
    PLOT FTCDF(X,5)  FOR X = 0  0.01  10
    PLOT FTCDF(X,10) FOR X = 0  0.01  10
    PLOT FTCDF(X,30) FOR X = 0  0.01  10
    END OF MULTIPLOT
 
-----FTPDF (LET)--------------------------------
 
FTPDF
 
Name:
    FTPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the folded t probability density function with NU
    degrees of freedom.  The degrees of freedom parameter should
    be a positive integer.
 
Description:
    The folded t distribution is the absolute value of the
    t distribution.  For details of the t distribution, enter
    HELP TPDF.

    The folded t distribution provides an alternative to the
    half-normal or half-Cauchy in distributional modeling
    applications.  A folded t with 1 degree of freedom is
    equivalent to a half-Cauchy and the folded t approximates
    the half-normal as the degrees of freedom gets large (in
    practice, the approximation is quite good for degrees of
    freedom > 30).  Thus the folded t allows you to model
    with tails that can vary from normal to Cauchy in behavior.
 
Syntax:
    LET <y> = FTPDF(<x>,NU)     <SUBSET/EXCEPT/FOR qualification>
    where <y> is a variable or a parameter;
          <x> is a variable or a parameter (depending on what <x> is)
               where the computed folded t pdf value is stored;
          <NU> is a positive number or parameter that specifies the
               degrees of freedom;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = FTPDF(3,10)
    LET Y2 = FTPDF(X1,10)
    LET Y = FTPDF(X,10)  SUBSET X > 2
    PLOT FTPDF(X,3) FOR X = 0.01  0.01  10
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FTCDF   = Compute the folded t cumulative distribution function.
    FTPPF   = Compute the folded t percent point function.
    TPDF    = Compute the t probability density function.
    STPDF   = Compute the skewed t probability density function.
    HFNPDF  = Compute the half-normal probability density function.
    FNRPDF  = Compute the folded normal probability density function.
    HFCPDF  = Compute the half-Cauchy probability density function.
 
Reference:
    "Continuous Univariate Distributions, Volume 1", Second Edition,
    Johnson, Kotz, and Balakrishnan, Wiley, 1994.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2004/1
 
Program:
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    MULTIPLOT SCALE FACTOR
    MULTIPLOT 2 2
    TITLE AUTOMATIC
    PLOT FTPDF(X,1)  FOR X = 0  0.01  10
    PLOT FTPDF(X,5)  FOR X = 0  0.01  10
    PLOT FTPDF(X,10) FOR X = 0  0.01  10
    PLOT FTPDF(X,30) FOR X = 0  0.01  10
    END OF MULTIPLOT
 
-----FTPPF (LET)--------------------------------
 
FTPPF
 
Name:
    FTPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the folded t percent point function with NU degrees
    of freedom.  The degrees of freedom parameter should be a
    positive integer.
 
Description:
    The folded t distribution is the absolute value of the
    t distribution.  For details of the t distribution, enter
    HELP TPDF.

    The folded t percent point function is computed using the
    t percent point as follows:

       FTPPF(p,nu) = TPPF((1 + p)/2,nu)

    The folded t distribution provides an alternative to the
    half-normal or half-Cauchy in distributional modeling
    applications.  A folded t with 1 degree of freedom is
    equivalent to a half-Cauchy and the folded t approximates
    the half-normal as the degrees of freedom gets large (in
    practice, the approximation is quite good for degrees of
    freedom > 30).  Thus the folded t allows you to model
    with tails that can vary from normal to Cauchy in behavior.
 
Syntax:
    LET <y> = FTPPF(<p>,<nu>)     <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, a number or a parameter in the range
               (0,1];
          <y> is a variable or a parameter (depending on what <p> is)
               where the computed folded t ppf value is stored;
          <nu> is a positive number or parameter that specifies the
               degrees of freedom;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = FTPPF(0.95,10)
    LET Y2 = FTPPF(P1,10)
    PLOT FTPPF(P,3) FOR P = 0  0.01  0.95
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FTCDF   = Compute the folded t cumulative distribution function.
    FTPDF   = Compute the folded t probability density function.
    TPDF    = Compute the t probability density function.
    STPDF   = Compute the skewed t probability density function.
    HFNPDF  = Compute the half-normal probability density function.
    FNRPDF  = Compute the folded normal probability density function.
    HFCPDF  = Compute the half-Cauchy probability density function.
 
Reference:
    "Continuous Univariate Distributions, Volume 1", Second Edition,
    Johnson, Kotz, and Balakrishnan, Wiley, 1994.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2004/1
 
Program:
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    MULTIPLOT SCALE FACTOR
    MULTIPLOT 2 2
    TITLE AUTOMATIC
    PLOT FTPPF(P,1)  FOR X = 0  0.01  0.99
    PLOT FTPPF(P,5)  FOR X = 0  0.01  0.99
    PLOT FTPPF(P,10) FOR X = 0  0.01  0.99
    PLOT FTPPF(P,30) FOR X = 0  0.01  0.99
    END OF MULTIPLOT
 
-----FUNCTION BLOCK-----------------------------------------------------
 
FUNCTION BLOCK
 
Name:
    FUNCTION BLOCK
 
Type:
    Analysis Command
 
Purpose:
    Defines a function via a group of Dataplot commands.
 
Description:
    Dataplot allows users to define their own functions using a
    Fortran-like syntax.  For example,

        LET FUNCTION F = (x-a0)/a1
        LET FUNCTION F = X1**2
        LET FUNCTION G = P*(L-X)/(E*I)

    User defined functions can be used in subsequent commands such as
    PLOT and LET (basically any place that a built-in Dataplot function
    can be used).

    Although Dataplot functions can be powerful, they do have some
    important limitations for some applications.  In particular, Dataplot
    functions are evaluated on a "row by row" basis.  Many statistical
    applications involve root finding or optimization for functions that
    involve sums of some kind.

    Function blocks were introduced to address this limitation.  Function
    blocks allow you to define functions using various Dataplot LET
    subcommands.

    Function blocks are created using the CAPTURE syntax.  For
    example,

        CAPTURE FUNCTION BLOCK ONE F A G
        LET C2 = 1/G
        LET Y2 = Y**G
        LET W  = Y2*Z
        LET A1 = SUM W
        LET A2 = SUM Y2
        LET A  = C2 - (A1/A2) + C1
        END OF CAPTURE

    The function block contains the following components

        1. CAPTURE FUNCTION BLOCK - this initiates the creation
           of the function block.  The CAPTURE command is typically
           used to direct Dataplot output to a file.  However,  in this
           case it saves the specified commands in an internal
           structure that can be accessed later.

        2. ONE - up to three function blocks can be defined.  In this
           example, "ONE" specifies that this is function block one.
           You can redefine these three function blocks as often as
           you need in a Dataplot session.

        3. F - this is the name of the function block.  This is the
           name that will be used to execute the function block in
           subsequent commands.  This follows the rules for other
           Dataplot names (i.e., up to eight alphanumeric characters).

        4. A - this is name of the parameter that will contain the
           response for the function block.  This is the value that
           is typically defined in the last line of the function block.
           In this example, the response is a parameter.  However, in
           some cases, it may be a variable.

        5. G - this is a parameter that is being updated by the
           function block.  In this case, we have only one parameter.
           In some cases, you may have more than one parameter.

           For example, in an optimization problem, you may be
           looking for the value of the parameter that minimizes
           (or maximizes) the value of a function.  The OPTIMIZE
           command will search over the specified parameter (G in
           this example) to find the optimal value.

           Parameters that remain fixed do not need to be specified
           on the CAPTURE command.

           Up to 20 parameters can be specified for a given function
           block.

    The following Dataplot commands can be included in a function block:

         1. LET ... = PATTERN ...
         2. LET ... = DATA ...
         3. LET ... = ... RANDOM NUMBERS ...
         4. ARITHMETIC OPERATIONS
         5. STATISTIC LET SUB-COMMANDS
         6. MATH LET SUB-COMMANDS
            The following MATH LET sub-commands are not allowed:

            a. MATRIX sub-commands
            b. DERIVATIVE
            c. NUMERICALDERIVATIVE
            d. INTEGRAL
            e. RUNGE-KUTTA
            f. OPTIMIZE
            g. ROOTS

    The arithmetic operations and statistics LET sub-commands are of
    particular interest.  Commands that are not supported are not added
    to the function block during the CAPTURE operation.  Up to 30
    commands can be saved to a given function block.

    Currently, function blocks can be used with the following commands:

         1. PLOT <function>
         2. 3D-PLOT <function>
         3. LET ... = ROOTS ...
         4. LET ... = OPTIMIZE ...
         5. LET ... = INTEGRAL ...
         6. LET ... = NUMERICAL DERIVATIVE ...

Syntax 1:
    CAPTURE FUNCTION BLOCK <one/two/three> <name>  <resp> <parameter list>
    where <one/two/three> specifies which function block is being
              created;
          <name> is the name of the function block;
          <resp> is the name of parameter or a variable that is the result
                of the function block;
    and where <parameter list> is a list of 1 to 20 parameter names.

    This syntax is used to create the contents of a function block.
 
Syntax 2:
    LIST FUNCTION BLOCK <one/two/three>
    where <one/two/three> specifies which function block is being listed.

    This syntax is used to list the contents of a function block.

Examples:
    capture function block one f a sigma gamma
    let c1 = n*(log(gamma) - gamma*log(sigma))
    let c2 = (gamma - 1)*ylogsum
    let y2 = (y/sigma)**gamma
    let c3 = sum y2
    let a  = c1 + c2 - c3
    end of capture

Note:
    Error checking (e.g., matching parenthesis, valid number of
    arguments for a built-in function) is performed when the function
    block is evaluated, not when it is created.

Note:
    There may be cases where you cannot create the needed function even
    with the FUNCTION BLOCK command.  The LET ... = EXECUTE ... command
    can be used to run an external prorgram.  That is, your function
    block can use the EXECUTE command to compute the desired function.
    You can create the external program in whatever language is most
    convenient for your application.  The basic requirement is that the
    resulting external file can be run from the command line and that it
    can read from standard input and write to standard output.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LET                   = Carries out a variety of operations on
                            variables, parameters, and functions.
    LET FUNCTION          = Define a function.
    EXECUTE               = Run an external program.
    PLOT                  = Plot a function of one variable.
    3D-PLOT               = Plot a function of two variables.
    ROOTS                 = Find the roots of a univariate function.
    OPTIMIZE              = Find the maximum (or minimum) of a function.
    INTEGRAL              = Find the integral of a function.
    NUMERICAL DERIVATIVE  = Find the numerical derivative of a function.
 
Applications:
    Mathematics
 
Implementation Date:
    2015/10
 
Program 1:
    . Purpose:  Demonstrate the use of function blocks
    .
    . Step 1:   Read the data
    .
    skip 25
    read weibbury.dat y
    skip 0
    .
    . Step 2:   Define the function block
    .
    let n = size y
    let z = log(y)
    let zsum = sum z
    let c1 = zsum/n
    .
    capture function block one f a g
    let c2 = 1/g
    let y2 = y**g
    let w  = y2*z
    let a1 = sum w
    let a2 = sum y2
    let a  = c2 - (a1/a2) + c1
    end of capture
    .
    list function block one
    .
    . Step 3:   Plot the function
    .
    title offset 2
    title case asis
    label case ais
    y1label Function Response A
    x1label G Parameter 
    title Function Block with Plot Command
    plot f for g = 2  0.01 20
    delete g
    .
    . Step 3:   Now use it to solve an equation
    .
    capture screen on
    capture fb.out
    let yroot = roots f wrt g for g = 2  20
    end of capture
    let ztemp = yroot(1)
    .
    line dash
    drawsdsd 15 0 85 0
    drawdsds ztemp 20 ztemp 90
    .
    let yinte = integral f wrt g for g = 2  6
    print yinte aval
    .
    let yder = numerical derivative f wrt g for g = 4.2
    let gtemp = sequence 2 0.05 6
    let yd = numerical derivative f wrt gtemp
    y1label Numerical Derivative
    plot yd gtemp
 
Program 2:
    . Purpose:  Demonstrate the use of function blocks in univariate
    .           optimization
    .
    . Step 1:   Read the data
    .
    skip 25
    read weibbury.dat y
    skip 0
    .
    . Step 2:   Define the function block
    .
    set optimization maximum
    capture function block one f a gamma
    let a  = weibull ppcc statistic y
    end of capture
    .
    list function block one
    .
    . Step 3:   Plot the function
    .
    title offset 2
    title case asis
    label case ais
    y1tic mark offset 0  0.05
    tic mark offset units data
    y1label PPCC Value
    x1label Gamma Parameter 
    title Function Block for PPCC Statistic
    plot f for gamma = 0.10 0.05 50
    delete gamma
    .
    . Step 3:   Now use it to perform an optimization
    .
    let yopt = optimize f wrt gamma for gamma = 0.1 50
    .
    line dash
    let fvalue = -fvalue
    drawsdsd 15 fvalue 85 fvalue
    drawdsds yopt 20 yopt 90
    .
    let gamma = round(yopt,3)
    let ppcc = round(fvalue,3)
    case asis
    just center
    move 50 5
    text Gamma: ^gamma, PPCC: ^ppcc
 
Program 3:
    . Purpose:  Demonstrate the use of function blocks in multivariate
    .           optimization
    .
    . Step 1:   Read the data
    .
    skip 25
    read weibbury.dat y
    skip 0
    .
    . Step 2:   Define the function block
    .
    let n = size y
    let ylog = log(y)
    let ylogsum = sum ylog
    let ylsd = sd ylog
    let ghat = 1.28/ylsd
    let ytemp = y**ghat
    let sighat = sum ytemp
    let sighat = sighat/n
    .
    capture function block one f a sigma gamma
    let c1 = n*(log(gamma) - gamma*log(sigma))
    let c2 = (gamma - 1)*ylogsum
    let y2 = (y/sigma)**gamma
    let c3 = sum y2
    let a  = c1 + c2 - c3
    end of capture
    .
    list function block one
    .
    . Step 3:   Generate Weibull plot to obtain start values
    .
    weibull plot y
    .
    . Step 3:   Now use it to perform an optimization
    .
    let gamma = beta
    let sigma = eta
    set optimization maximum
    optimization method line finite
    let yopt = optimize f wrt sigma gamma
    .
    3d-plot f  for sigma = 40  0.5  60 for gamma = 5 0.1 10

-----FUNCTION-------------------------------------------------------
 
FUNCTION
 
Name:
    FUNCTION
 
Type:
    Keyword
 
Purpose:
    Symbolic name for DATAPLOT's functions file.  It is used with the
    SEARCH and LIST functions.
 
Description:
    DATAPLOT's functions file contains a list of DATAPLOT functions
    (grouped by category) with a brief (one line) description.  It is a
    subset of the dictionary file.  The dictionary file also includes
    macro files, program files, and data files.
 
Syntax:
    None
 
Examples:
    SEARCH FUNCTION CHSCDF
    LIST FUNCTION FOR I = 1 1 35
 
Note:
    The FUNCTION file is stored in the DATAPLOT directory.  It
    has the name FUNCTION (or function for Unix systems).  The exact
    file name and the directory where it is stored can vary depending
    on the installation (see your local DATAPLOT implementor to find
    the exact name on your system).
 
Note:
    If DATAPLOT is unable to open the functions file, it is most likely
    because the directory name is not specified correctly in the local
    DATAPLOT code.  See your local DATAPLOT implementor to have this
    corrected.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SEARCH        = Search a file for a string.
    LIST          = Lists the contents of a file.
    DIRECTORY     = Symbolic name for DATAPLOT's directory file.
    DICTIONAY     = Symbolic name for DATAPLOT's dictionary file.
    DATASETS      = Symbolic name for DATAPLOT's data sets file.
    DESIGNS       = Symbolic name for DATAPLOT's design of experiments
                    file.
    SYNTAX        = Symbolic name for DATAPLOT's syntax file.
    MACROS        = Symbolic name for DATAPLOT's macros file.
    PROGRAMS      = Symbolic name for DATAPLOT's programs file.
    DISTRIBU      = Symbolic name for DATAPLOT's distributions file.
    COMMANDS      = Symbolic name for DATAPLOT's commands file.
 
Applications:
    XX
 
Implementation Date:
    93/12
 
Program:
    XX
 
---------------------------------------------------------
 
 
 
 


























































-------------------------  *G*  ZZZZZ--------------------
 
-----GALCDF (LET)--------------------------------
 
GALCDF
 
Name:
    GALCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized asymmetric Laplace cumulative
    distribution function.
 
Description:
    The standard form of the generalized asymmetric Laplace
    distribution has the following probability density function:

        f(x,kappa,tau) =
            [SQRT(2/PI)*
            EXP((SQRT(2)/2)*((1/kappa)-kappa)*x)/GAMMA(tau)]*
            ((SQRT(2)*ABS(x)/(kappa+(1/kappa))**(tau-0.5)*
            K(tau-0.5)((SQRT(2)/2)*((1/kappa)+kappa)*ABS(x))
            kappa, tau > 0

    where K(lambda)(.) is the modified Bessel function of the
    of the third kind of order lambda and GAMMA is the gamma
    function.

    The standard generalized asymmetric Laplace distribution can
    be generalized with location and scale parameters in the usual
    way.

    If kappa = 1, the distribution is symmetric.  If tau = 1, the
    generalized asymmetric Laplace distribution reduces to the
    asymmetric Laplace distribution.  If tau = 1 and kappa =1, the
    generalized asymmetric Laplace distribution reduces to the
    Laplace distribution.  Enter
    HELP ADEPDF or HELP DEXPDF for details.

    The cumulative distribution function is computed by
    numerically integrating the probability density function.
    Dataplot performs the integration using the DQAGI routine
    from the Slatec library.

Syntax:
    LET <y> = GALCDF(<x>,<k>,<tau>,<loc>,<scale>)
                                <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable or a parameter;
          <k> is a positive number of parameter that specifies the
              value of the first shape parameter;
          <tau> is a positive number of parameter that specifies the
              value of the second shape parameter;
          <loc> is an optional number or parameter that specifies the
              value of the location parameter;
          <scale> is an optional positive number or parameter that
              specifies the value of the scale parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed generalized asymmetric Laplace cdf
               value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y = GALCDF(3,1,0.5)
    LET Y = GALCDF(X1,K,TAU)
    PLOT GALCDF(X,K,TAU) FOR X = -5 0.01 5
 
Note:
    Kotz, Kozubowski, and Podgorski define an alternate
    parameterization based on the parameter mu.  These
    parameterizations are related by:

       mu     = (1/SQRT(2))*((1/kappa) - kappa)
       kappa  = SQRT(2)/(mu + SQRT(2 + mu**2))

    The mu parameter can be any real number.  A value of
    mu = 0 reduces to the symmetric generalized Laplace case
    (i.e., kappa = 1).

    By default, Dataplot uses the k parameterization.  To use
    the mu parameterization, enter the command

        SET ASYMMETRIC DOUBLE EXPONENTIAL DEFINITION MU

    To reset the k parameterization, enter the command

        SET ASYMMETRIC DOUBLE EXPONENTIAL DEFINITION K
    
Note:
    DATAPLOT uses the routine BESK from the SLATEC Common Mathematical
    Library to compute the modified Bessel function of the third
    kind.  SLATEC is a large set of high quality, portable, public
    domain Fortran routines for various mathematical capabilities
    maintained by seven federal laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GALPDF = Compute the generalized asymmetric Laplace probability
             density function.
    GALPPF = Compute the generalized asymmetric Laplace percent
             point function.
    ADEPDF = Compute the asymmetric Laplace probability density
             function.
    SDEPDF = Compute the skew double exponential probability
             density function.
    DEXPDF = Compute the double exponential probability density
             function.
    GIGPDF = Compute the generalized inverse Gaussian probability
             density function.
    BEIPDF = Compute the Bessel I-function probability density
             function.
    BEKPDF = Compute the Bessel K-function probability density
             function.
    EXPPDF = Compute the exponential probability density function.
 
Reference:
    "The Laplace Distribution and Generalizations: A Revisit with
    Applications to Communications, Economics, Engineering, and
    Finance", Birkhauser, 2001, pp. 179-192.

Applications:
    Distributional Modeling
 
Implementation Date:
    8/2004
 
Program:
    Y1LABEL Probability
    X1LABEL X
    LABEL CASE ASIS
    TITLE CASE ASIS
    CASE ASIS
    Y1LABEL DISPLACEMENT 12
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    LINE SOLID DASH DOTTED
    TITLE Kappa = 0.5, 1.0, 1.5, TAU = 0.5
    PLOT GALCDF(X,0.5,0.5) FOR X = -5 0.1 5 AND
    PLOT GALCDF(X,1.0,0.5) FOR X = -5 0.1 5 AND
    PLOT GALCDF(X,1.5,0.5) FOR X = -5 0.1 5
    TITLE Kappa = 0.5, 1.0, 1.5, TAU = 1.0
    PLOT GALCDF(X,0.5,1.0) FOR X = -5 0.1 5 AND
    PLOT GALCDF(X,1.0,1.0) FOR X = -5 0.1 5 AND
    PLOT GALCDF(X,1.5,1.0) FOR X = -5 0.1 5
    TITLE Kappa = 0.5, 1.0, 1.5, TAU = 1.5
    PLOT GALCDF(X,0.5,1.5) FOR X = -5 0.1 5 AND
    PLOT GALCDF(X,1.0,1.5) FOR X = -5 0.1 5 AND
    PLOT GALCDF(X,1.5,1.5) FOR X = -5 0.1 5
    TITLE Kappa = 0.5, 1.0, 1.5, TAU = 2.0
    PLOT GALCDF(X,0.5,2.0) FOR X = -5 0.1 5 AND
    PLOT GALCDF(X,1.0,2.0) FOR X = -5 0.1 5 AND
    PLOT GALCDF(X,1.5,2.0) FOR X = -5 0.1 5
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATIONC CENTER
    TEXT Generalized Asymmetric Laplace Distribution
 
-----GALPDF (LET)--------------------------------
 
GALPDF
 
Name:
    GALPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized asymmetric Laplace probability density
    function.
 
Description:
    The standard form of the generalized asymmetric Laplace
    distribution has the following probability density function:

        f(x,kappa,tau) =
            [SQRT(2/PI)*
            EXP((SQRT(2)/2)*((1/kappa)-kappa)*x)/GAMMA(tau)]*
            ((SQRT(2)*ABS(x)/(kappa+(1/kappa))**(tau-0.5)*
            K(tau-0.5)((SQRT(2)/2)*((1/kappa)+kappa)*ABS(x))
            kappa, tau > 0

    where K(lambda)(.) is the modified Bessel function of the
    of the third kind of order lambda and GAMMA is the gamma
    function.

    The standard generalized asymmetric Laplace distribution can
    be generalized with location and scale parameters in the usual
    way.

    If kappa = 1, the distribution is symmetric.

    If tau = 1, the generalized asymmetric Laplace distribution
    reduces to the asymmetric Laplace distribution.  If tau = 1
    and kappa =1, the generalized asymmetric Laplace distribution
    reduces to the Laplace distribution.  Enter
    HELP ADEPDF or HELP DEXPDF for details.

Syntax:
    LET <y> = GALPDF(<x>,<k>,<tau>,<loc>,<scale>)
                                <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable or a parameter;
          <k> is a positive number of parameter that specifies the
              value of the first shape parameter;
          <tau> is a positive number of parameter that specifies the
              value of the second shape parameter;
          <loc> is an optional number or parameter that specifies the
              value of the location parameter;
          <scale> is an optional positive number or parameter that
              specifies the value of the scale parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed generalized asymmetric Laplace pdf
               value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y = GALPDF(3,1,0.5)
    LET Y = GALPDF(X1,K,TAU)
    PLOT GALPDF(X,K,TAU) FOR X = -5 0.01 5
 
Note:
    Kotz, Kozubowski, and Podgorski define an alternate
    parameterization based on the parameter mu.  These
    parameterizations are related by:

       mu     = (1/SQRT(2))*((1/kappa) - kappa)
       kappa  = SQRT(2)/(mu + SQRT(2 + mu**2))

    The mu parameter can be any real number.  A value of
    mu = 0 reduces to the symmetric generalized Laplace case
    (i.e., kappa = 1).

    By default, Dataplot uses the k parameterization.  To use
    the mu parameterization, enter the command

        SET ASYMMETRIC DOUBLE EXPONENTIAL DEFINITION MU

    To reset the k parameterization, enter the command

        SET ASYMMETRIC DOUBLE EXPONENTIAL DEFINITION K
    
Note:
    DATAPLOT uses the routine BESK from the SLATEC Common Mathematical
    Library to compute the modified Bessel function of the third
    kind.  SLATEC is a large set of high quality, portable, public
    domain Fortran routines for various mathematical capabilities
    maintained by seven federal laboratories.

Note:
    To generate generalized asymmetric Laplace random numbers, enter
    the commands

        LET K = <value>
        LET TAU = <value>
        LET Y = GENERALIZED ASYMMETRIC LAPLACE RANDOM NUMBERS ...
                FOR I = 1 1 N

    To generate a generalized asymmetric Laplace probability plot
    or a generalized asymmetric Laplace Kolmogorov-Smirnov or
    chi-square goodness of fit test, enter the following commands

        LET K = <value>
        LET TAU = <value>
        GENERALIZED ASYMMETRIC LAPLACE PROBABILITY PLOT Y
        GENERALIZED ASYMMETRIC LAPLACE KOLMOGOROV SMIRNOV ...
                   GOODNESS OF FIT Y
        GENERALIZED ASYMMETRIC LAPLACE CHI-SQUARE GOODNESS OF FIT Y
       
    To generate a PPCC or Kolmogorov-Smirnov plot, enter the
    following commands

        LET K1 = <value>
        LET K2 = <value>
        LET TAU1 = <value>
        LET KTAU2 = <value>
        GENERALIZED ASYMMETRIC DOUBLE EXPONENTIAL PPCC PLOT Y
        GENERALIZED ASYMMETRIC DOUBLE EXPONENTIAL KS PLOT Y

    The default values for K1 and K2 are 0.2 and 5.  The default
    values of TAU1 and TAU2 are 0.2 and 5.0.

    If you have requested the mu parameterization, then you
    you need to enter the command

        LET MU = <value>

    in place of

        LET K = <value>

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GALCDF = Compute the generalized asymmetric Laplace cumulative
             distribution function.
    GALPPF = Compute the generalized asymmetric Laplace percent
             point function.
    ADEPDF = Compute the asymmetric Laplace probability density
             function.
    SDEPDF = Compute the skew double exponential probability
             density function.
    DEXPDF = Compute the double exponential probability density
             function.
    GIGPDF = Compute the generalized inverse Gaussian probability
             density function.
    BEIPDF = Compute the Bessel I-function probability density
             function.
    BEKPDF = Compute the Bessel K-function probability density
             function.
    EXPPDF = Compute the exponential probability density function.
 
Reference:
    "The Laplace Distribution and Generalizations: A Revisit with
    Applications to Communications, Economics, Engineering, and
    Finance", Birkhauser, 2001, pp. 179-192.

Applications:
    Distributional Modeling
 
Implementation Date:
    8/2004
 
Program:
    Y1LABEL Probability
    X1LABEL X
    LABEL CASE ASIS
    TITLE CASE ASIS
    CASE ASIS
    Y1LABEL DISPLACEMENT 12
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    LINE SOLID DASH DOTTED
    TITLE Kappa = 0.5, 1.0, 1.5, TAU = 0.5
    PLOT GALPDF(X,0.5,0.5) FOR X = -5 0.1 5 AND
    PLOT GALPDF(X,1.0,0.5) FOR X = -5 0.1 5 AND
    PLOT GALPDF(X,1.5,0.5) FOR X = -5 0.1 5
    TITLE Kappa = 0.5, 1.0, 1.5, TAU = 1.0
    PLOT GALPDF(X,0.5,1.0) FOR X = -5 0.1 5 AND
    PLOT GALPDF(X,1.0,1.0) FOR X = -5 0.1 5 AND
    PLOT GALPDF(X,1.5,1.0) FOR X = -5 0.1 5
    TITLE Kappa = 0.5, 1.0, 1.5, TAU = 1.5
    PLOT GALPDF(X,0.5,1.5) FOR X = -5 0.1 5 AND
    PLOT GALPDF(X,1.0,1.5) FOR X = -5 0.1 5 AND
    PLOT GALPDF(X,1.5,1.5) FOR X = -5 0.1 5
    TITLE Kappa = 0.5, 1.0, 1.5, TAU = 2.0
    PLOT GALPDF(X,0.5,2.0) FOR X = -5 0.1 5 AND
    PLOT GALPDF(X,1.0,2.0) FOR X = -5 0.1 5 AND
    PLOT GALPDF(X,1.5,2.0) FOR X = -5 0.1 5
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATIONC CENTER
    TEXT Generalized Asymmetric Laplace Distribution
 
-----GALPPF (LET)--------------------------------
 
GALPPF
 
Name:
    GALPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized asymmetric Laplace percent point
    function.
 
Description:
    The standard form of the generalized asymmetric Laplace
    distribution has the following probability density function:

        f(x,kappa,tau) =
            [SQRT(2/PI)*
            EXP((SQRT(2)/2)*((1/kappa)-kappa)*x)/GAMMA(tau)]*
            ((SQRT(2)*ABS(x)/(kappa+(1/kappa))**(tau-0.5)*
            K(tau-0.5)((SQRT(2)/2)*((1/kappa)+kappa)*ABS(x))
            kappa, tau > 0

    where K(lambda)(.) is the modified Bessel function of the
    of the third kind of order lambda and GAMMA is the gamma
    function.

    The standard generalized asymmetric Laplace distribution can
    be generalized with location and scale parameters in the usual
    way.

    If kappa = 1, the distribution is symmetric.  If tau = 1, the
    generalized asymmetric Laplace distribution reduces to the
    asymmetric Laplace distribution.  If tau = 1 and kappa =1, the
    generalized asymmetric Laplace distribution reduces to the
    Laplace distribution.  Enter
    HELP ADEPDF or HELP DEXPDF for details.

    The cumulative distribution function is computed by
    numerically integrating the probability density function.
    Dataplot performs the integration using the DQAGI routine
    from the Slatec library.  The percent point function is
    then computed by numerically inverting the cumulative
    distribution function using the DFZERO subroutine from
    the Slatec library.

Syntax:
    LET <y> = GALPPF(<p>,<k>,<tau>,<loc>,<scale>)
                                <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, number or a parameter in the interval
              (0,1);
          <k> is a positive number of parameter that specifies the
              value of the first shape parameter;
          <tau> is a positive number of parameter that specifies the
              value of the second shape parameter;
          <loc> is an optional number or parameter that specifies the
              value of the location parameter;
          <scale> is an optional positive number or parameter that
              specifies the value of the scale parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed generalized asymmetric Laplace ppf
               value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y = GALPPF(0.95,1,0.5)
    LET Y = GALPPF(P,K,TAU)
    PLOT GALPPF(P,K,TAU) FOR P = 0.01 0.01 0.99
 
Note:
    Kotz, Kozubowski, and Podgorski define an alternate
    parameterization based on the parameter mu.  These
    parameterizations are related by:

       mu     = (1/SQRT(2))*((1/kappa) - kappa)
       kappa  = SQRT(2)/(mu + SQRT(2 + mu**2))

    The mu parameter can be any real number.  A value of
    mu = 0 reduces to the symmetric generalized Laplace case
    (i.e., kappa = 1).

    By default, Dataplot uses the k parameterization.  To use
    the mu parameterization, enter the command

        SET ASYMMETRIC DOUBLE EXPONENTIAL DEFINITION MU

    To reset the k parameterization, enter the command

        SET ASYMMETRIC DOUBLE EXPONENTIAL DEFINITION K
    
Note:
    DATAPLOT uses the routine BESK from the SLATEC Common Mathematical
    Library to compute the modified Bessel function of the third
    kind.  SLATEC is a large set of high quality, portable, public
    domain Fortran routines for various mathematical capabilities
    maintained by seven federal laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GALCDF = Compute the generalized asymmetric Laplace cumulative
             distribution function.
    GALPDF = Compute the generalized asymmetric Laplace probability
             density function.
    ADEPDF = Compute the asymmetric Laplace probability density
             function.
    SDEPDF = Compute the skew double exponential probability
             density function.
    DEXPDF = Compute the double exponential probability density
             function.
    GIGPDF = Compute the generalized inverse Gaussian probability
             density function.
    BEIPDF = Compute the Bessel I-function probability density
             function.
    BEKPDF = Compute the Bessel K-function probability density
             function.
    EXPPDF = Compute the exponential probability density function.
 
Reference:
    "The Laplace Distribution and Generalizations: A Revisit with
    Applications to Communications, Economics, Engineering, and
    Finance", Birkhauser, 2001, pp. 179-192.

Applications:
    Distributional Modeling
 
Implementation Date:
    8/2004
 
Program:
    X1LABEL Probability
    Y1LABEL X
    LABEL CASE ASIS
    TITLE CASE ASIS
    CASE ASIS
    Y1LABEL DISPLACEMENT 12
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    LINE SOLID DASH DOTTED
    TITLE Kappa = 0.5, 1.0, 1.5, TAU = 0.5
    PLOT GALPPF(P,0.5,0.5) FOR P = 0.01 0.01 0.99 AND
    PLOT GALPPF(P,1.0,0.5) FOR P = 0.01 0.01 0.99 AND
    PLOT GALPPF(P,1.5,0.5) FOR P = 0.01 0.01 0.99
    TITLE Kappa = 0.5, 1.0, 1.5, TAU = 1.0
    PLOT GALPPF(P,0.5,1.0) FOR P = 0.01 0.01 0.99 AND
    PLOT GALPPF(P,1.0,1.0) FOR P = 0.01 0.01 0.99 AND
    PLOT GALPPF(P,1.5,1.0) FOR P = 0.01 0.01 0.99
    TITLE Kappa = 0.5, 1.0, 1.5, TAU = 1.5
    PLOT GALPPF(P,0.5,1.5) FOR P = 0.01 0.01 0.99 AND
    PLOT GALPPF(P,1.0,1.5) FOR P = 0.01 0.01 0.99 AND
    PLOT GALPPF(P,1.5,1.5) FOR P = 0.01 0.01 0.99
    TITLE Kappa = 0.5, 1.0, 1.5, TAU = 2.0
    PLOT GALPPF(P,0.5,2.0) FOR P = 0.01 0.01 0.99 AND
    PLOT GALPPF(P,1.0,2.0) FOR P = 0.01 0.01 0.99 AND
    PLOT GALPPF(P,1.5,2.0) FOR P = 0.01 0.01 0.99
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATIONC CENTER
    TEXT Generalized Asymmetric Laplace Distribution
 
-----GAMCDF (LET)--------------------------------
 
GAMCDF
 
Name:
    GAMCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the gamma cumulative distribution
    function.
 
Description:
    The standard form of the gamma distribution has the following
    probability density function:
       f(x) = x**(gamma-1)*exp(-x)/GAMMA(gamma)     for x > 0
    where gamma is a positive number that is the shape parameter and
    GAMMA is the standard Gamma function (see the documentation for
    the GAMMA command for details of this function).  The mean and
    standard deviation of the standard gamma distribution are gamma and
    sqrt(gamma) respectively.  The cumulative distribution is the area
    from negative infinity to x (i.e., the integral of the above
    function).
 
    The input value can be any positive real number.
 
Syntax:
    LET <y2> = GAMCDF(<y1>,<gamma>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, a number, or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed gamma cdf value is saved;
          <gamma> is a number or parameter that specifies the shape
               parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GAMCDF(3,1.5)
    LET X2 = GAMCDF(X1,GAMMA)
 
Note:
    If gamma is 1, this distribution reduces to the exponential
    distribution.
 
Note:
    The general form of the gamma distribution is:
       f(x) = ((x-u)/beta)**(gamma-1)*exp(-(x-u)beta)
                  /(beta*(GAMMA(gamma))                  for x > u
    The parameter u is a location parameter and the parameter beta is a
    scale parameter that must be greater than 0.  The cdf values for
    the general gamma distributions can be computed by doing
    something like the following:
        LET U = <value>
        LET BETA = <value>
        PLOT (1/BETA)*GAMCDF((X-U)/BETA) FOR X = U .1 10
    The general gamma distribution has a mean and standard deviation of
    gamma*beta and beta*sqrt(gamma) respectively.  The gamma
    distribution with gamma = (v/2) and beta = 2 where v is a positive
    integer is a chi-square distribution with v degrees of freedom.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GAMPPF = Compute the gamma percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    EXPCDF = Compute the exponential cumulative distribution function.
    EXPPDF = Compute the exponential probability density function.
    EXPPPF = Compute the exponential percent point function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, Houghton
    Mifflin, 1970 (chapter 17).
 
Applications:
    XX
 
Implementation Date:
    94/4
 
Program:
    MAJOR YTIC NUMBER 6; MINOR YTIC NUMBER 1
    YLIMITS 0 1; YTIC DECIMAL 1
    XLIMITS 0 5; XTIC OFFSET 0.6 0.6
    TITLE PLOT GAMCDF FOR VARIOUS VALUES OF GAMMA
    SEGMENT 1 COORDINATES 16 88 21 88; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 16 84 21 84; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 16 80 21 80; SEGMENT 3 PATTERN DOT
    SEGMENT 4 COORDINATES 16 76 21 76; SEGMENT 4 PATTERN DASH2
    LEGEND 1 GAMMA = 1; LEGEND 1 COORDINATES 22 87
    LEGEND 2 GAMMA = 0.5; LEGEND 2 COORDINATES 22 83
    LEGEND 3 GAMMA = 2; LEGEND 3 COORDINATES 22 79
    LEGEND 4 GAMMA = 5; LEGEND 4 COORDINATES 22 75
    LINES SOLID DASH DOT DASH2
    PLOT GAMCDF(X,1) FOR X = 0.01 0.01 5.5 AND
    PLOT GAMCDF(X,0.5) FOR X = 0.01 0.01 5.5 AND
    PLOT GAMCDF(X,2) FOR X = 0.01 0.01 5.5 AND
    PLOT GAMCDF(X,5) FOR X = 0.01 0.01 5.5
 
-----GAMCHAZ (LET)--------------------------------
 
GAMCHAZ
 
Name:
    GAMCHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the gamma cumulative hazard
    function.
 
Description:
    The standard form of the gamma distribution has the following
    cumulative hazard function:
       H(x) = -LOG[1 - GAMCDF(x,gamma)]        x, gamma > 0
    where gamma is the shape parameter and GAMCDF is the cumulative
    distribution functions of the gamma distribution.
 
Syntax:
    LET <y> = GAMCHAZ(<x>,<gamma>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a positive number, a number, or a variable;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed gamma cumulative hazard value is
               saved;
          <gamma> is a number or parameter that specifies the shape
               parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GAMCHAZ(3,1.5)
    LET X2 = GAMCHAZ(X1,GAMMA)
 
Note:
    If gamma is 1, this distribution reduces to the exponential
    distribution.  If gamma is an integer, then this distribution is
    also known as an Erlang distribution.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GAMCDF  = Compute the gamma cumulative distribution function.
    GAMPDF  = Compute the gamma probability density function.
    GAMPPF  = Compute the gamma percent point function.
    GAMHAZ  = Compute the gamma hazard function.
    WEIPDF  = Compute the Weibull probability density function.
    EXPPDF  = Compute the exponential probability density function.
    CHSPDF  = Compute the chi-square probability density function.
    IGAPDF  = Compute the inverted gamma probability density function.
    GGDPDF  = Compute the generalized gamma probability density
              function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994 (chapter 17).
 
    "Statistical Distributions", 2nd. Edition, Evans, Hastings, and
    Peacock, Wiley and Sons, 1993 (chapter 18).

Applications:
    Reliability
 
Implementation Date:
    1998/4
 
Program:
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT 2 2
    TITLE CASE ASIS
    TITLE Gamma Cumulative Hazard (Gamma = 1)
    PLOT GAMCHAZ(X,1) FOR X = 0.1 0.1 5.5
    TITLE Gamma Cumulative Hazard (Gamma = 0.5)
    PLOT GAMCHAZ(X,0.5) FOR X = 0.1 0.1 5.5
    TITLE Gamma Cumulative Hazard (Gamma = 2)
    PLOT GAMCHAZ(X,2) FOR X = 0.1 0.1 5.5
    TITLE Gamma Cumulative Hazard (Gamma = 5)
    PLOT GAMCHAZ(X,5) FOR X = 0.1 0.1 10
    END OF MULTIPLOT
 
-----GAMHAZ (LET)--------------------------------
 
GAMHAZ
 
Name:
    GAMHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the gamma hazard function.
 
Description:
    The standard form of the gamma distribution has the following
    hazard function:
       h(x) = GAMPDF(x,gamma)/(1 - GAMCDF(x,gamma))     x, gamma > 0
    where gamma is the shape parameter and GAMPDF and GAMCDF are
    the probability density and cumulative distribution functions
    of the gamma distribution respectively.
 
Syntax:
    LET <y> = GAMHAZ(<x>,<gamma>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a positive number, a number, or a variable;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed gamma hazard value is saved;
          <gamma> is a number or parameter that specifies the shape
               parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GAMCDF(3,1.5)
    LET X2 = GAMCDF(X1,GAMMA)
 
Note:
    If gamma is 1, this distribution reduces to the exponential
    distribution.  If gamma is an integer, then this distribution is
    also known as an Erlang distribution.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GAMCDF  = Compute the gamma cumulative distribution function.
    GAMPDF  = Compute the gamma probability density function.
    GAMPPF  = Compute the gamma percent point function.
    GAMCHAZ = Compute the gamma cumulative hazard function.
    WEIPDF  = Compute the Weibull probability density function.
    EXPPDF  = Compute the exponential probability density function.
    CHSPDF  = Compute the chi-square probability density function.
    IGAPDF  = Compute the inverted gamma probability density function.
    GGDPDF  = Compute the generalized gamma probability density
              function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994 (chapter 17).
 
    "Statistical Distributions", 2nd. Edition, Evans, Hastings, and
    Peacock, Wiley and Sons, 1993 (chapter 18).

Applications:
    Reliability
 
Implementation Date:
    1998/4
 
Program:
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT 2 2
    TITLE CASE ASIS
    TITLE Gamma Hazard Function (Gamma = 1)
    PLOT GAMHAZ(X,1) FOR X = 0.1 0.1 5.5
    TITLE Gamma Hazard Function (Gamma = 0.5)
    PLOT GAMHAZ(X,0.5) FOR X = 0.1 0.1 5.5
    TITLE Gamma Hazard Function (Gamma = 2)
    PLOT GAMHAZ(X,2) FOR X = 0.1 0.1 5.5
    TITLE Gamma Hazard Function (Gamma = 5)
    PLOT GAMHAZ(X,5) FOR X = 0.1 0.1 10
    END OF MULTIPLOT
 
-----GAMMA (LET)--------------------------------
 
GAMMA
 
Name:
    GAMMA (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the gamma function.
 
Description:
    The gamma function is defined as:
        GAMMA(ALPHA) = INTEGRAL(t**(ALPHA-1)*EXP(-t)dt)
    where the integral is taken from 0 to infinity and ALPHA is a
    positive real number.
 
Syntax:
    LET <y2> = GAMMA(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter containing positive values;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed gamma values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GAMMA(1)
    LET A = GAMMA(A1)
    LET X2 = GAMMA(X1)
    LET X2 = GAMMA(X1-4)
 
Note:
    For integer values of ALPHA, the gamma function redues to a
    factorial.  Specifically,
        GAMMA(ALPHA)=(ALPHA-1)!
 
Note:
    The Beta function can be computed from the gamma function.
        BETA(Z,W) = GAMMA(Z)*GAMMA(W)/GAMMA(Z+W)
 
Note:
    The gamma function can overflow even for moderate values of
    ALPHA.  The LOGGAMMA function can be used in these cases.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LOGGAMMA   = Compute the log (to base e) gamma function.
    GAMMAI     = Compute the incomplete Gamma function.
    GAMMAIP    = Compute an alternate form of the incomplete gamma
                 function.
    GAMMAIC    = Compute the complementary incomplete Gamma function.
    GAMMAR     = Compute the reciprocal gamma function.
    TRICOMI    = Compute Tricomi's incomplete gamma function.
    DIGAMMA    = Compute the digamma function.
 
Reference:
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", Press, Flannery, Teukolsky, and Vetterling.  Cambridge
    University Press, 1989 (pages 156-159).
 
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 6).
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    TITLE AUTOMATIC
    YLIMITS 0 100
    PLOT GAMMA(X) FOR X = 0.01 0.01 6
 
-----GAMMAI (LET)--------------------------------
 
GAMMAI
 
Name:
    GAMMAI (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the incomplete gamma function.
 
Description:
    The incomplete gamma function is defined as:
        GAMMAI(X,A) = INTEGRAL(T**(A-1)*EXP(-T))dt    X >= 0,  A > 0
    where the integral is taken from 0 to x.
 
    An alternate form of the incomplete gamma function is defined as:
        GAMMAIP(X,A) = (1/GAMMA(A))*INTEGRAL(T**(A-1)*EXP(-T))dt
                                                      X >= 0,  A > 0
    where the integral is taken from 0 to x and GAMMA is the gamma
    function.  This form can be computed with the DATAPLOT function
    GAMMAIP.  See the documentation for the GAMMA function for the
    formula for the gamma function.
 
Syntax:
    LET <y2> = GAMMAI(<y1>,<a>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a non-negative number, variable or parameter;
          <a> is a positive number, parameter, or variable; 
          <y2> is a variable or a parameter (depending on what <y1> 
               and <a> are) where the computed incomplete gamma values
               are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GAMMAI(2.3,1)
    LET A = GAMMAI(X,A1)
    LET X2 = GAMMAI(X1,4.2)
 
Note:
    DATAPLOT uses the routine DGAMI from the SLATEC Common Mathematical
    Library to compute this function.  SLATEC is a large set of high
    quality, portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GAMMA      = Compute the gamma function.
    LOGGAMMA   = Compute the log (to base e) gamma function.
    GAMMAIP    = Compute an alternate form of the incomplete gamma
                 function.
    GAMMAIC    = Compute the complementary incomplete Gamma function.
    GAMMAR     = Compute the reciprocal gamma function.
    TRICOMI    = Compute Tricomi's incomplete gamma function.
    DIGAMMA    = Compute the digamma function.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 6).
 
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", 2nd Edition, Press, Flannery, Teukolsky, and
    Vetterling, Cambridge University Press, 1992 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE INCOMPLETE GAMMA FUNCTIONS
    LINE SOLID DASH DOT
    PLOT GAMMAI(X,0.5) FOR X = 0.01 0.01 5 AND
    PLOT GAMMAI(X,1) FOR X = 0.01 0.01 5 AND
    PLOT GAMMAI(X,3) FOR X = 0.1 0.1 10 AND
    PLOT GAMMAI(X,5) FOR X = 0.1 0.1 10
 
-----GAMMAIC (LET)--------------------------------
 
GAMMAIC
 
Name:
    GAMMAIC (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the complementary incomplete gamma function.
 
Description:
    The complementary incomplete gamma function is defined as:
        GAMMAIC(X,A) = INTEGRAL(T**(A-1)*EXP(-T))dt    X >= 0
    where the integral is taken from x to infinity.
 
    If X is zero, then A must be positive.  Otherwise, A can be any
    real value.  Also, there can be a loss of precision if A is too
    near a negative integer.
 
Syntax:
    LET <y2> = GAMMAIC(<y1>,<a>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a non-negative number, variable or parameter;
          <a> is a number, parameter, or variable; 
          <y2> is a variable or a parameter (depending on what <y1> 
               and <a> are) where the computed incomplete gamma values
               are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GAMMAIC(2.3,1)
    LET A = GAMMAIC(X,A1)
    LET X2 = GAMMAIC(X1,4.2)
 
Note:
    DATAPLOT uses the routine DGAMIC from the SLATEC Common
    Mathematical Library to compute this function.  SLATEC is a large
    set of high quality, portable, public domain Fortran routines for
    various mathematical capabilities maintained by seven federal
    laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GAMMA      = Compute the gamma function.
    LOGGAMMA   = Compute the log (to base e) gamma function.
    GAMMAIP    = Compute an alternate form of the incomplete gamma
                 function.
    GAMMAI     = Compute the incomplete Gamma function.
    GAMMAR     = Compute the reciprocal gamma function.
    TRICOMI    = Compute Tricomi's incomplete gamma function.
    DIGAMMA    = Compute the digamma function.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 6).
 
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", 2nd Edition, Press, Flannery, Teukolsky, and
    Vetterling, Cambridge University Press, 1992 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE COMPLEMENTARY INCOMPLETE GAMMA FUNCTIONS
    LINE SOLID DASH DOT
    PLOT GAMMAIC(X,0.5) FOR X = 0.01 0.01 5 AND
    PLOT GAMMAIC(X,1) FOR X = 0.01 0.01 5 AND
    PLOT GAMMAIC(X,3) FOR X = 0.1 0.1 10 AND
    PLOT GAMMAIC(X,5) FOR X = 0.1 0.1 10
 
-----GAMMAIP (LET)--------------------------------
 
GAMMAIP
 
Name:
    GAMMAIP (LET)
 
Type:
    Library Function
 
Purpose:
    Compute an alternate form of the incomplete gamma function.
 
Description:
    The incomplete gamma function is defined as:
        GAMMAIP(X,A) = INTEGRAL(T**(A-1)*EXP(-T))dt    X >= 0,  A > 0
    where the integral is taken from 0 to x.
 
    An alternate form of the incomplete gamma function is defined as:
        GAMMAIP(X,A) = (1/GAMMA(A))*INTEGRAL(T**(A-1)*EXP(-T))dt
                                                      X >= 0,  A > 0
    where the integral is taken from 0 to x and GAMMA is the gamma
    function.  

    This function computes the alternate form.  The DATAPLOT function
    GAMMAI can be used to compute the first form of the incomplete
    gamma function.  See the documentation for the GAMMA function for
    the formula for the gamma function.
 
Syntax:
    LET <y2> = GAMMAIP(<y1>,<a>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a non-negative number, variable or parameter;
          <a> is a positive number, parameter, or variable; 
          <y2> is a variable or a parameter (depending on what <y1> 
               and <a> are) where the computed incomplete gamma values
               are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GAMMAIP(2.3,1)
    LET A = GAMMAIP(X,A1)
    LET X2 = GAMMAIP(X1,4.2)
 
Note:
    DATAPLOT uses  a slightly modified form of the routine DGAMI from
    the SLATEC Common Mathematical Library to compute this function.
    SLATEC is a large set of high quality, portable, public domain
    Fortran routines for various mathematical capabilities maintained
    by seven federal laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GAMMA      = Compute the gamma function.
    LOGGAMMA   = Compute the log (to base e) gamma function.
    GAMMAI     = Compute the incomplete gamma function.
    GAMMAIC    = Compute the complementary incomplete Gamma function.
    GAMMAR     = Compute the reciprocal gamma function.
    TRICOMI    = Compute Tricomi's incomplete gamma function.
    DIGAMMA    = Compute the digamma function.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 6).
 
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", 2nd Edition, Press, Flannery, Teukolsky, and
    Vetterling, Cambridge University Press, 1992 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE INCOMPLETE GAMMA FUNCTIONS
    LINE SOLID DASH DOT
    PLOT GAMMAIP(X,0.5) FOR X = 0.01 0.01 5 AND
    PLOT GAMMAIP(X,1) FOR X = 0.01 0.01 5 AND
    PLOT GAMMAIP(X,3) FOR X = 0.1 0.1 10 AND
    PLOT GAMMAIP(X,5) FOR X = 0.1 0.1 10
 
-----GAMMA MOMENT ESTIMATES (LET)-------------------------------------
 
GAMMA MOMENT ESTIMATES
 
Name:
    GAMMA MOMENT ESTIMATES (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Estimate the parameters of the 3-parameter gamma distribution based
    on summary statistics.
 
Description:
    In most cases, we prefer to estimate the parameters of the 3-parameter
    gamma distribution using the 3-PARAMETER GAMMA MLE Y command.  However,
    this assumes that we have the full data set.  In some cases, we may
    only have summary statistics available.

    The input array, say X, should contain the following values:

        X(1) = the sample mean
        X(2) = the sample standard deviation
        X(3) = the sample skewness
        X(4) = the sample minimum
        X(5) = the sample size

    If one of the values is not available, then you can enter either
    CPUMIN or the statistic missing value.  For example, if the skewness
    is not available, you can do one of the following:

        PROBE CPUMIN
        LET CPUMIN = PROBVAL
        LET X(3) = CPUMIN

    or

        SET STATISTIC MISSING VALUE -9999
        LET X(3) = -9999

    The following output vector, say Y, is returned:

        Y(1) = 3-parameter moment estimate for location
        Y(2) = 3-parameter moment estimate for scale
        Y(3) = 3-parameter moment estimate for shape
        Y(4) = 3-parameter modified moment estimate for scale
        Y(5) = 3-parameter modified moment estimate for shape
        Y(6) = 3-parameter moment estimate for scale

    Any of these moment estimates that cannot be computed will be set to
    CPUMIN.  This can happen if certain summary statistics are not provided
    or if the equation solvers are not able to find a solution.

    The 3-parameter gamma moment and modified moment estimates are computed
    using the codes provided on pages 363-364 of Cohen and Whitten.

Syntax:
    LET <y> = GAMMA MOMENT ESTIMATES  <x>
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is the variable containing the summary statistics;
          <y> is a variable containing the gamma moment estimates;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional and rarely
          used for this command.
 
Examples:
    LET Y = GAMMA MOMENT ESTIMATES X
 
Default:
    None
 
Synonyms:
    None
 
Reference:
    Cohen and Whitten (1988), "Parameter Estimation in Reliability and Life
    Span Models", Marcel Dekker, p. 61 and pp. 363-364.

Related Commands:
    WEIBULL MOMEMENT ESTIMATE      = Generate moment estimates for the
                                     Weibull distribution.
    LOGNORMAL MOMEMENT ESTIMATE    = Generate moment estimates for the
                                     lognormal distribution.
    INVERSE GAUSSIAN MOME ESTIMATE = Generate moment estimates for the
                                     inverse gaussian distribution.
    MAXIMUM LIKELIHOOD             = Perform maximum likelihood estimation
                                     for various distributions.
    BEST DISTRIBUTIONAL FIT        = Perform a best distributional fit
                                     analysis.
    PPCC PLOT                      = Generate a probability plot
                                     correlation coefficient plot.
    PROBABILITY PLOT               = Generate a probability plot.

Applications:
    Reliability
 
Implementation Date:
    2014/4
 
Program:
    . Purpose:  Test GAMMA MOMEMNT ESTIMATES command
    .
    . Step 1:   Read data
    .
    .           Data from
    .
    .           Cohen and Whitten (1988), "Parameter Estimation in
    .           Reliability  and Life Span Models", Dekker, p. 54.
    .
    serial read x
    0.654  0.613  0.315  0.449  0.297
    0.402  0.379  0.423  0.379  0.3235
    0.269  0.740  0.418  0.412  0.494
    0.416  0.338  0.392  0.484  0.265
    end of data
    .
    let xmean = mean x
    let xsd   = sd   x
    let xmin  = mini x
    let xskew = skew x
    let n = size x
    let z = data xmean xsd xskew xmin n
    .
    let y = gamma moment estimates z
    .
    let numdec = 5
    .
    let locmom   = y(1); let locmom   = round(locmom,numdec)
    let scalemom = y(2); let scalemom = round(scalemom,numdec)
    let gammamom = y(3); let gammamom = round(gammamom,numdec)
    let locmmom  = y(4); let locmmom  = round(locmmom,numdec)
    let scalmmom = y(5); let scalmmom = round(scalmmom,numdec)
    let gammmmom = y(6); let gammmmom = round(gammmmom,numdec)
    .
    let xmean = round(xmean,numdec)
    let xsd   = round(xsd,numdec)
    let xskew = round(xskew,numdec)
    let xmin  = round(xmin,numdec)
    .
    print "Gamma Parameter Estimates From Summary Data"
    print " "
    print " "
    print "Sample Mean:      ^xmean"
    print "Sample SD:        ^xsd"
    print "Sample Skewness:  ^xskew"
    print "Sample Minimum:   ^xmin"
    print "Sample Size:      ^n"
    print " "
    print " "
    print "3-Parameter Gamma Moment Estimates:"
    print "Location:         ^locmom"
    print "Scale:            ^scalemom"
    print "Shape:            ^gammamom"
    print " "
    print " "
    print "3-Parameter Gamma Modified Moment Estimates:"
    print "Location:         ^locmmom"
    print "Scale:            ^scalmmom"
    print "Shape:            ^gammmmom"

-----GAMMAR (LET)--------------------------------
 
GAMMAR
 
Name:
    GAMMAR (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the reciprocal gamma function.
 
Description:
    The reciprocal gamma function is defined as:
        GAMMAR(ALPHA) = 1.0/INTEGRAL(X**(ALPHA-1)*EXP(-X)dx)
    where the integral is taken from 0 to infinity and ALPHA is a
    positive real number.
 
Syntax:
    LET <y2> = GAMMAR(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter containing positive values;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed reciprocal gamma values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GAMMAR(1)
    LET A = GAMMAR(A1)
    LET X2 = GAMMAR(X1)
 
Note:
    DATAPLOT uses the routine DGAMR from the SLATEC Common Mathematical
    Library to compute this function.  SLATEC is a large set of high
    quality, portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GAMMA      = Compute the gamma function.
    LOGGAMMA   = Compute the log (to base e) gamma function.
    GAMMAI     = Compute the incomplete Gamma function.
    GAMMAIP    = Compute an alternate form of the incomplete gamma
                 function.
    GAMMAIC    = Compute the complementary incomplete Gamma function.
    GAMMAR     = Compute the reciprocal gamma function.
    TRICOMI    = Compute Tricomi's incomplete gamma function.
    DIGAMMA    = Compute the digamma function.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 6).
 
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", 2nd Edition, Press, Flannery, Teukolsky, and
    Vetterling, Cambridge University Press, 1992 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE AUTOMATIC
    PLOT GAMMAR(X) FOR X = 0.01 0.01 6
 
-----GAMPDF (LET)--------------------------------
 
GAMPDF
 
Name:
    GAMPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the gamma probability density
    function.
 
Description:
    The standard form of the gamma distribution has the following
    probability density function:
       f(x) = x**(gamma-1)*exp(-x)/GAMMA(gamma)     for x > 0
    where gamma is a positive number that is the shape parameter and
    GAMMA is the standard Gamma function (see the documentation for
    the GAMMA command for details of this function).  The mean and
    standard deviation of the standard gamma distribution are gamma and
    sqrt(gamma) respectively.
 
    The input value can be any positive real number.
 
Syntax:
    LET <y2> = GAMPDF(<y1>,<gamma>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a positive number, a number, or a variable;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed gamma cdf value is saved;
          <gamma> is a number or parameter that specifies the shape
               parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GAMPDF(3,1.5)
    LET X2 = GAMPDF(X1,GAMMA)
 
Note:
    If gamma is 1, this distribution reduces to the exponential
    distribution.  If gamma is an integer, then this distribution is
    also known as an Erlang distribution.
 
Note:
    The general form of the gamma distribution is:
       f(x) = ((x-u)/beta)**(gamma-1)*exp(-(x-u)beta)
                  /(beta*(GAMMA(gamma))                  for x > u
    The parameter u is a location parameter and the parameter beta is a
    scale parameter that must be greater than 0.  The pdf values for
    the general gamma distributions can be computed by doing
    something like the following:
        LET U = <value>
        LET BETA = <value>
        PLOT (1/BETA)*GAMPDF((X-U)/BETA) FOR X = U .1 10
    The general gamma distribution has a mean and standard deviation of
    gamma*beta and beta*sqrt(gamma) respectively.  The gamma
    distribution with gamma = (v/2) and beta = 2 where v is a positive
    integer is a chi-square distribution with v degrees of freedom.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GAMCDF = Compute the gamma cumulative distribution function.
    GAMPPF = Compute the gamma percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    EXPCDF = Compute the exponential cumulative distribution function.
    EXPPDF = Compute the exponential probability density function.
    EXPPPF = Compute the exponential percent point function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, Houghton
    Mifflin, 1970 (chapter 17).
 
    "Statistical Distributions", 2nd. Edition, Evans, Hastings, and
    Peacock, Wiley and Sons, 1993 (chapter 18).

Applications:
    Reliability
 
Implementation Date:
    94/9
 
Program:
    MAJOR YTIC NUMBER 6; MINOR YTIC NUMBER 1
    YLIMITS 0 1; YTIC DECIMAL 1
    XLIMITS 0 10; XTIC OFFSET 0.6 0.6
    TITLE PLOT GAMPDF FOR VARIOUS VALUES OF GAMMA
    SEGMENT 1 COORDINATES 79 88 84 88; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 79 84 84 84; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 79 80 84 80; SEGMENT 3 PATTERN DOT
    SEGMENT 4 COORDINATES 79 76 84 76; SEGMENT 4 PATTERN DASH2
    LEGEND 1 GAMMA = 1; LEGEND 1 COORDINATES 78 87
    LEGEND 2 GAMMA = 0.5; LEGEND 2 COORDINATES 78 83
    LEGEND 3 GAMMA = 2; LEGEND 3 COORDINATES 78 79
    LEGEND 4 GAMMA = 5; LEGEND 4 COORDINATES 78 75
    LEGEND JUSTIFICATION RIGHT
    LINES SOLID DASH DOT DASH2
    PLOT GAMPDF(X,1) FOR X = 0.1 0.1 5.5 AND
    PLOT GAMPDF(X,0.5) FOR X = 0.1 0.1 5.5 AND
    PLOT GAMPDF(X,2) FOR X = 0.1 0.1 5.5 AND
    PLOT GAMPDF(X,5) FOR X = 0.1 0.1 10
 
-----GAMPPF (LET)--------------------------------
 
GAMPPF
 
Name:
    GAMPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the gamma percent point function.
 
Description:
    The standard form of the gamma distribution has the following
    probability density function:
       f(x) = x**(gamma-1)*exp(-x)/GAMMA(gamma)     for x > 0
    where gamma is a positive number that is the shape parameter and
    GAMMA is the standard Gamma function (see the documentation for
    the GAMMA command for details of this function).  The mean and
    standard deviation of the standard gamma distribution are gamma and
    sqrt(gamma) respectively.
 
    The percent point function is the inverse of the cumulative
    distribution function.  The cumulative distribution sums the
    probability from 0 to the given x value (i.e., the integral of the
    above function).  The percent point function takes a cumulative
    probability value and computes the corresponding x value.
 
    The input value is a real number between 0 and 1 (since it
    corresponds to a probability).
 
Syntax:
    LET <y2> = GAMPPF(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, a number, or a parameter in the range 0
               to 1;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed gamma ppf value is stored;
          <gamma> is a number or parameter that specifies the shape
               parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GAMPPF(0.9)
    LET X2 = GAMPPF(X1)
 
Note:
    If gamma is 1, this distribution reduces to the exponential
    distribution.
 
Note:
    The general form of the gamma distribution is:
       f(x) = ((x-u)/beta)**(gamma-1)*exp(-(x-u)beta)
                  /(beta*(GAMMA(gamma))                  for x > u
    The parameter u is a location parameter and the parameter beta is a
    scale parameter that must be greater than 0.  The general gamma
    distribution has a mean and standard deviation of gamma*beta and
    beta*sqrt(gamma) respectively.  The gamma distribution with gamma
    = (v/2) and beta = 2 where v is a positive integer is a chi-square
    distribution with v degrees of freedom.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GAMPPF = Compute the gamma percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    EXPCDF = Compute the exponential cumulative distribution function.
    EXPPDF = Compute the exponential probability density function.
    EXPPPF = Compute the exponential percent point function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, Houghton
    Mifflin, 1970 (chapter 17).
 
Applications:
    XX
 
Implementation Date:
    1994/04
 
Program:
    MAJOR XTIC NUMBER 6; MINOR XTIC NUMBER 1
    XLIMITS 0 1; XTIC DECIMAL 1; YLIMITS 0 12
    SEGMENT 1 COORDINATES 16 88 21 88; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 16 84 21 84; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 16 80 21 80; SEGMENT 3 PATTERN DOT
    SEGMENT 4 COORDINATES 16 76 21 76; SEGMENT 4 PATTERN DASH2
    LEGEND 1 GAMMA = 1; LEGEND 1 COORDINATES 22 87
    LEGEND 2 GAMMA = 0.5; LEGEND 2 COORDINATES 22 83
    LEGEND 3 GAMMA = 2; LEGEND 3 COORDINATES 22 79
    LEGEND 4 GAMMA = 5; LEGEND 4 COORDINATES 22 75
    LINES SOLID DASH DOT DASH2
    TITLE PLOT GAMPPF FOR VARIOUS VALUES OF GAMMA
    PLOT GAMPPF(X,1) FOR X = 0.01 .01 0.99 AND
    PLOT GAMPPF(X,0.5) FOR X = 0.01 .01 0.99 AND
    PLOT GAMPPF(X,2) FOR X = 0.01 .01 0.99 AND
    PLOT GAMPPF(X,5) FOR X = 0.01 .01 0.99

-----GATHER (LET)-------------------------------------
 
GATHER
 
Name:
    GATHER (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Extract rows of a variable based on index values
    contained in another variable.
 
Description:
    It is sometimes convenient to extract specific rows
    of a variable.  Although this can usually be accomplished
    using SUBSET/EXCEPT/FOR clauses, the GATHER command can
    sometimes be more convenient.  This is particularly true
    if the desired rows do not follow a regular pattern.
    Also, if you are going to perform an extensive set of
    operations on the subset of the data, it may be more
    convenient to use the GATHER command than to use the
    SUBSET command on many subsequent commands.

    With the GATHER command, we define a separate variable
    that contains the specific rows we want to extract.

    If you modify the extracted data and want to save these
    modified values back to the original variable, you can
    use the SCATTER command.   Enter HELP SCATTER for further
    information.

    The first program example shows a simple artificial example to
    demonstrate the basic syntax.  The second and third examples
    show non-trivial examples of the GATHER command.

Syntax:
    LET <y> = GATHER <x>  <index>
    where <x> is a response variable;
          <index> is a variable containing row numbers;
    and   <y> is a variable (of length equal to <index>) that
          contains the rows of <x> corresponding to <index>.
 
Examples:
    LET Y = GATHER X INDEX
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SCATTER            = Save data from a variable to specified
                         rows of another variable based on an
                         index variable.
    SEQUENCE           = Generate a patterned sequence of values.
    SORT               = Sort a column of numbers.
    RANK               = Rank a column of numbers.
    CODE               = Code a column of numbers.
    SUBSET             = Specifies a subset to be included in a plot,
                         analysis, or LET command.
    RETAIN             = Retain specified rows or a subset of a
                         variable.
 
Applications:
    Data Transformation
 
Implementation Date:
    2008/11
 
Program 1:
    let n = 30
    let xseq = sequence 1 1 n
    let x = normal rand numb for i = 1 1 n
    let iindex = data 10  14  8  23  19
    .
    let y = gather x iindex
    set write decimals 3
    print xseq x iindex y

Program 2:
    .  Purpose: Need to randomly sample bottles from a box of 81 bottles.
    .
    .           3 temperatures: -20, 5, 25
    .           3 times:        1 day, 3 days, 7 days
    .                           (7 days also has a temperature of -80)
    .           4 levels
    .
    .           This gives us 2*3*4 + 1*4*4 = 40 combinations.  Generate a
    .           sampling plan for 2 replications for each combination.
    .
    .  Step 0:  Set the random number generator
    .
    dimension 100 columns
    set random number generator fibonacci congruential
    seed 55609
    set write decimals 0
    .
    .  Step 1:  Assign the combinations in arbitrary order
    .
    let temp = data -80 -20 -20 -20 5 5 5 25 25 25
    let time = data   7   1   3   7 1 3 7  1  3  7
    let ncomb1 = size temp
    let nlevel = 4
    let temp = combine temp temp temp temp
    let time = combine time time time time
    let level = sequence 1 ncomb1 1 nlevel
    let ncomb2 = size temp
    .
    .  Step 2:  Randomly permute the combinations
    .
    let ntemp = size temp
    let zperm = random permutation for i = 1 1 ntemp
    let x1 = gather temp  zperm
    let x2 = gather time  zperm
    let x3 = gather level zperm
    delete zperm
    .
    let nrepl = 2
    loop for k = 2 1 nrepl
        let zperm = random permutation for i = 1 1 ntemp
        let x1t = gather temp  zperm
        let x2t = gather time  zperm
        let x3t = gather level zperm
        let x1 = combine x1 x1t
        let x2 = combine x2 x2t
        let x3 = combine x3 x3t
    end of loop
    let n  = size x1
    .
    .  Step 2:  Now randomize the vial selection
    .
    let nbottle = 81
    let bottleid = sequence 1 1 nbottle
    let xperm = random permutation for i = 1 1 nbottle
    retain bottleid xperm  subset xperm <= n
    .
    .  Step 3:  Now match time/temp to bottle id
    .
    let temp2  = gather x1 xperm
    let time2  = gather x2 xperm
    let level2 = gather x3 xperm
    .
    write2 perm.out "Permutation   Temperature   Time   Level   Bottle-ID"
    write2 perm.out "----------------------------------------------------"
    set write format  F14.0,F11.0,F7.0,F8.0,F12.0
    write2 perm.out xperm temp2 time2 level2 bottleid
 
Program 3:
    . Purpose:  Reproduce the Reliability Analyses given at:
    .
    .           https://www.itl.nist.gov/div898/handbook/apr/section4/apr46.htm
    .
    .           This script shows a non-trivial use of the GATHER command
    .           that greatly speeded up the analysis.
    . Source:   Thanks to Jonathan H. Morgan for submitting this example.
    . Description: Perform a weighted sampling with replacement.  This example
    .              builds on the reliability analyses discussed in sections
    .              8.3.1.5 and 8.4.6 of the NIST/SEMATECH e-Handbook of
    .              Statistical Methods
    .              (http://www.itl.nist.gov/div898/handbook).  In these
    .              analyses, the authors constructed a posterior distribution
    .              of Mean Time Between Failures (MTBF).  This is a common
    .              approach because samples of equipment failure rates tend
    .              to be small, making frequentist approaches impractical in
    .              many cases.  Based on these analyses, the authors confirmed
    .              that a 600 hour MTBF objective fell within a 80% credible
    .              interval.  In addition to summarizing the posterior, it is
    .              useful to average over our uncertainty to provide an
    .              intuition about model trends.  What might we expect in the
    .              future based on what we know of the prior and posterior?
    .              We do this by performing a weighted re-sampling from the
    .              prior and posterior distributions based on the prior and
    .              posterior likelihoods using GATHER.
    .
    . Step 0:   Define the output devices and dimension the workspace
    .
    dimension 1000000 rows
    .
    device 2 close
    let string fplot = gather_script.ps
    set ipl1na ^fplot
    device 2 postscript
    .
    . Step 1:  Initialize some plot control settings and the random number
    .          generator
    .
    y2frame off; x2frame off
    grid thickness 0.01; grid on
    set random number generator fibonacci congruential
    seed 33497
    .
    . Step 2:  Generate the Data for Mean Time Between Failures Analysis
    .
    let prob = sequence 0 0.001 0.999
    let ngroup = size prob
    let alpha = 4
    let beta = 3309
    .
    . Step 3: Calculate the MTBF Posterior
    .
    let post = igappf(prob,alpha,0, beta) for i = 1 1 ngroup
    retain post prob for i = 1 1 1000
    .
    .         Flipping Probabilities for the Purpose of Plotting
    .
    LET prob = REVERSE prob
    .
    .         Calculating Intervals for Plotting Purposes
    .
    let p09 = igappf(0.9,alpha,0, beta)
    let p08 = igappf(0.8,alpha,0,beta)
    let p05 = igappf(0.5,alpha,0,beta)
    let p01 = igappf(0.1,alpha,0,beta)
    .
    . Step 4: Calculate the MTBF Posterior
    .
    .         Plotting to Confirm Results
    .
    x1label Mean Time Between Failures Objective
    y1label Probability of Exceeding Objective
    label size 2
    y1label displacement 10
    title Estimated Product Reliability
    line color brown
    .
    plot prob post
    line color blue
    drawdata p09 0 p09 0.1
    drawdata p05 0 p05 0.5
    drawdata p08 0 p08 0.2
    drawdata p01 0 p01 0.9
    case lower
    font complex
    move 5 4
    text alph()' = 2 + 2 fails, beta()' = 1400 + 1909 hours
    move 63 4
    text lamb() =
    case asis
    move 68 4
    text 1/GSUP()-1
    move 75 4
    text (1/a, 4, 1/3309)
    .
    . Step 5: Sampling from the Posterior Distribution with Replacement Using
    .         GATHER
    .
    .          Notes: The routine performs weighted samples by comparing the
    .                 weights to values generated from a uniform random
    .                 distribution scaled to encapsulate the range of the 
    .                 weights, in this case the posterior values.  The
    .                 routine's scale parameters reduce the number of maxloop
    .                 draws necessary to generate the sample.  Random draws
    .                 are included in the random sample if the sample's weight
    .                 is greater than the random draw from the comparison
    .                 distribution.  A macro of the routine such as
    .                 weighted_macro facilitates performing weighted sampling
    .                 with replacement.
    .
    .         Returning Probabilities Back to their Original Order
    .
    let prob = reverse prob
    .
    .         Specifying the Iteration and Location Parameters for Sampling
    .         the Posterior
    .
    let n_samp = 10000
    let maxloop = 10*n_samp
    let loc = minimum post
    let scale = maximum post
    let i_loc = 1
    let i_scale = size prob
    .
    .         Generate Two Sets of Uniform Random Numbers for Selecting Based
    .         on Likelihood
    .
    let i_value = uniform random numbers for I = 1 1 maxloop
    let i_value = loc + scale*i_value
    .
    let ind = uniform random numbers for i = 1 1 maxloop
    let ind = i_loc + i_scale*ind
    let index = ceil(ind) - 1
    .
    .         Now draw weighted samples from the posterior: post_sam
    .
    let index2 = sequence 1 1 maxloop
    let val_i  = gather i_value index2
    let val    = gather post index
    .
    let tag = 0 for i = 1 1 maxloop
    let diff = val - val_i
    let tag = 1 subset diff > 0
    retain index subset tag = 1
    retain index for i = 1 1 n_samp
    let post_sam = gather prob index
    .
    delete loc scale i_loc i_scale i_value index ind index2 val val_i tag diff
    .
    .         Estimating Prior MTBF
    .
    let prior = igappf(prob, 2, 0, 1400) for i = 1 1 ngroup 
    .
    .         Specifying the iteration and location parameters for sampling
    .         the prior
    .
    let maxloop = 1000000
    let loc = minimum prior
    let scale = maximum prior
    let i_loc = 1
    let i_scale = size prob
    .
    .         Generate two sets of uniform random numbers for selecting
    .         based on likelihood
    .
    let i_value = uniform random numbers for i = 1 1 maxloop
    let i_value = loc + scale*i_value
    .
    let ind = uniform random numbers for i = 1 1 maxloop
    let ind = i_loc + i_scale*ind
    let index = ceil(ind) - 1
    .
    .         Now draw weighted samples from the prior: pri_samp
    .
    let index2 = sequence 1 1 maxloop
    let val_i  = gather i_value index2
    let val    = gather post index
    .
    let tag = 0 for i = 1 1 maxloop
    let diff = val - val_i
    let tag = 1 subset diff > 0
    retain index subset tag = 1
    retain index for i = 1 1 n_samp
    let pri_samp = gather prob index
    delete loc scale i_loc i_scale i_value index ind index2 val val_i tag diff
    .
    .         Assessing the model by generating prior and posterior
    .         predicative distributions
    .
    .         Generating predictions based on weighted samples of the
    .         prior likelihoods
    .
    let n_sim = size pri_samp 
    let pri_val = igappf(pri_samp, 2, 0, 1400) for i = 1 1 n_sim
    .
    .         Generating predictions based on weighted samples of the
    .         posterior likelihoods
    .
    let n_sim = size post_sam 
    let pred_val = igappf(post_sam, alpha, 0, beta) for i = 1 1 n_sim
    .
    .         Plotting Predicative Distributions
    .
    x1label Mean Time Between Failures Objective
    y1label Density
    x1limit 0 6000
    y1limit 0 0.001
    y1label displacement 12
    major xtic mark number 5
    major ytic mark number 3
    title Weighted Predicative Distributions
    line color brown blue
    multiple kernel density plot pred_val pri_val
    .
    line thickness 0.2
    line color blue
    drawdata 3000 0.001 3500 0.001
    movedata 3550 0.000985
    hw 2 1
    text Prior 
    .
    line color brown
    drawdata 3000 0.00085 3500 0.00085
    movedata 3550 0.00084
    text Posterior 
    line thickness 0.1
    .
    .         As expected, the weighted posterior predicative distribution is
    .         centered on higher MTFB values than the prior weighted
    .         predicative distribution.  Comparing the two distributions, we
    .         can see the additional information included in the posterior
    .         has reduced the predictions’ variance.  The weighted posterior
    .         predicative distribution is skewed to the right compared to the
    .         posterior prediction (median MTBF of 1213 compared to 901), as
    .         is the weighted prior predicative distribution.  The rightward
    .         shift is because most of the mass of the posterior is centered
    .         on MTFB values between 495 and 1897, and thus more of the
    .         samples are of values in this range.  The corresponding shift
    .         in the weighted prior results in a peak occurring at a MTBF of
    .         967 very close to the posterior’s median. Substantively, these
    .         findings suggest that the posterior predictions are likely to
    .         be conservative, as MTBF values under 400 are unlikely.
    .         Nevertheless, we should take this result with a grain of salt
    .         given that the posterior itself is based on a very small sample.
 
-----GCD (LET)--------------------------------
 
GCD
 
Name:
    GCD (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the greatest common divisor of two integers.
 
Syntax:
    LET <y> = GCD(<x1>,<x2>)  <SUBSET/EXCEPT/FOR qualification>
    where <x1> is a number, parameter, or variable (real numbers are
               rounded to integer values);
          <x2> is a number, parameter, or variable (real numbers are
               rounded to integer values);
          <y> is a variable or a parameter (depending on what <x1> and
               <x2> are) where the computed greatest common divisor
               is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GCD(14,38)
    LET A = GCD(X1,X2)
    LET A = GCD(X1,3)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    INT    = Compute the integer value rounded to zero.
    ROUND  = Round to the closest integer of a number.
    FLOOR  = Compute the integer value rounded to negative infinity.
    CEIL   = Compute the integer value rounded to positive infinity.
    SIGN   = Compute the sign of a number.
    FRACT  = Compute the fractional portion of number.
    MSD    = Compute the most significant digit of a number.
 
Applications:
    Defining functions
 
Implementation Date:
    Pre-1987
 
Program:
    XX

-----GD---------------------------------------------------------
 
GD
 
Name:
    GD
 
Type:
    Output Device Command
 
Purpose:
    Create PNG, JPEG, GIF, BMP and TIFF format graphics files.
 
Description:
    PNG, JPEG and GIF format graphics files are useful for web
    applications since most web browsers provide native support
    for these formats (i.e., the graphs can be viewed using the
    an <img> tag without the use of a plug-in).  These formats
    can also be useful for importing graphs into word processing
    and presentation programs since many of these program can
    import these type of files directly.  In addition, if you
    need a graphic in a specific image format, many image
    conversion programs can convert these formats into a wide
    variety of other image formats.  Several additional formats are
    supported (see Note section below), but PNG, JPEG and GIF are the
    most commonly used.

    Dataplot implements these formats using the GD library.   The GD
    library was originally developed by Thomas Boutell.  It is now
    maintained and developed as an open source library.  The web
    page for GD is located at

        https://libgd.github.io/

    and the source code can be downloaded at

        https://github.com/libgd/libgd/releases

    The GD library is used by the popular PHP, Perl and Ruby software
    programs (as well as other programs), so it will be available on
    most Linux/Unix platforms.  If it is not already installed, there
    are packages for the most common Linux/Unix distros.

    Dataplot is not particularly sensitive to which version
    of the GD library you have on your system.  Any reasonably
    current version should suffice.  The major restriction is
    that GD 1.x versions are no longer supported (GD changed
    some calling sequences in moving to the 2.x versions).  The
    Dataplot code is now updated to use the 2.x calling
    sequence  This change was made in the 03/2006 version of
    Dataplot.

Syntax:
    DEVICE <1/2/3> GD <format>
    where <format> is one of PNG, JPEG, GIF, BMP, WBMP, TIFF, TARGA,
    or WEBP.
 
    This form designates one of DATAPLOT's 3 devices as an GD device.
    For the GD device, DEVICE 2 is typically used.
 
Examples:
    DEVICE 2 GD PNG
    DEVICE 2 GD JPEG
    DEVICE 2 GD GIF
 
Note:
    DATAPLOT must be linked with the proper GD libraries in order for
    the GD driver to work.  If this is not the case, contact your
    local Dataplot installer.
 
Note:
    Dataplot upgraded to the 2.1 version of GD July, 2014.  With this
    upgrade, Dataplot now supports several additional image formats.

       1 - added support for the BMP format.  This device was available
           in previous versions of GD, but I had not activated it for
           Dataplot.  BMP is a common format in the Windows environment.
 
       2 - added support for the WBPM format.  This device was available
           in previous versions of GD, but I had not activated it for
           Dataplot.  WBMP is a black and white format that was originally
           intended for mobile/wireless applications.  It is not commonly
           used anymore.
 
       3 - added support for TGA (Targa format).  Note that this format
           is coded but has not been tested.
 
       4 - added support for TIFF.  Note that this option requires that
           the "libtiff" library be installed, so this format may not be
           available in some Dataplot installations.
 
       5 - the webp format is supported if the VPX library is available.
           This is a relatively new format championed by Google.  It is
           primarily intended for viewing videos on the web.  This format
           will probably not be available on most Dataplot installations.

    Version 2.3.2 added support for the AVIF and HEIF formats.  We have
    not yet updated Dataplot to support these formats.

    Be aware that some of these formats require external libraries
    that may not be available with the version of the GD library
    installed on your local platform.

    The basic GD implementation uses the libraries: zlib, libpng,
    libjpeg, and libfreetype.  These should be included with most GD
    installations.  The libtiff library is typically available on most
    Linux platforms.  However, the libraries for the webp, AVIF and HEIF
    formats are less likely to be available.

Note:
    There are several alternative methods for generating PNG/JPEG/GIF
    files with Dataplot.  For example,

       1. Dataplot can generate Postscript (PDF files can be generated
          using Ghostscript) and Scalable Vector Graphics (SVG) graphics
          files.  Using the open source GIMP software, the Postscript or
          SVG file can be converted to a number of different common image
          formats.  The advantage of this method is that it maintains the
          high quality of the original Postscript/SVG file (GIMP uses
          anti-aliasing when converting from a vector format to a
          bit map format).  The disadvantage is that it requires an
          additional manual step.

          There are other software programs that can convert
          Postscript/SVG to bit map formats.  However, not all of these
          programs perform anti-aliasing, so the quality may vary.

       2. The Windows version of Ghostview can convert Postscript/PDF
          files to JPEG.

       3. Either Ghostscript or the ImageMagick convert program can be
          used to automatically convert Dataplot's Postscript output
          to PNG or JPEG.  For details, enter

              HELP POSTSCRIPT CONVERT

       4. The Dataplot CAIRO device driver supports PNG/JPEG/GIF.
          However this driver is still in "beta" mode.

Note:
    Typically, for PNG or JPEG output, it is desirable to put
    each plot in a separate file with a unique name.  This can
    be accomplished with a sequence of commands like the following:

        SET IPL1NA  PLOT1.PNG
        DEVICE 2 GD PNG
           generate first plot
        DEVICE 2 CLOSE
        SET IPL1NA  PLOT2.PNG
        DEVICE 2 GD PNG
           generate second plot
        DEVICE 2 CLOSE

    The SET IPL1NA command specifies the name of the file.  Note
    that this name is currently converted to upper case.
    This command should come before the DEVICE 2 GD command.
 
Note:
    The default image size is 600 pixels by 450 pixels.  You
    can change the default size of the image by using the
    DEVICE ... PICTURE POINTS command.  For example,

        SET IPL1NA  PLOT1.PNG
        DEVICE 2 GD PNG
        DEVICE 2 PICTURE POINTS  300 300
           generate first plot
        DEVICE 2 CLOSE

Note:
    GD supports hardware text in the following two ways:

       1) There are 5 built-in fonts: TINY, SMALL, MEDIUM, LARGE,
          or GIANT.  These will be available for all GD
          installations.  These are fixed size fonts.

       2) GD supports the use of True Type fonts using the Free Type
          library.  If you have True Type fonts (these fonts are
          identified with a ".ttf" file extension) installed on your
          system, you can specify that Dataplot use these fonts with
          the command

              SET GD FONT <font name>

          Note that you must specify the full path name for the font
          name.  For example

              SET GD FONT /usr/share/fonts/gnu-free/FreeSansBold.ttf

          There are several ways to locate or obtain True Type fonts.

          a) Dataplot provides a limited number of True Type fonts in the
             "fonts" directory in the Dataplot auxilary files directory.
             On Linux systems, this is often one of

                /usr/local/lib/dataplot/fonts
                /usr/lib/dataplot/fonts

             On Windows platforms, this is

                C:\Program Files (x86)\NIST\DATAPLOT\FONTS

          b) Many platforms will have libraries of True Type fonts
             already installed.

             For example, on the Red Hat Enterprise version 8 (including
             derivative CentOS and Rocky) Linux system, a number of True
             Type fonts are availabe in

                 /usr/share/fonts

             There are a number of sub-directories under this that
             contain the fonts.  For example the "gnu-free" sub-directory
             contains the following fonts

                 FreeMonoBoldOblique.ttf
                 FreeMonoBold.ttf
                 FreeMonoOblique.ttf
                 FreeMono.ttf
                 FreeSansBoldOblique.ttf
                 FreeSansBold.ttf
                 FreeSansOblique.ttf
                 FreeSans.ttf
                 FreeSerifBoldItalic.ttf
                 FreeSerifBold.ttf
                 FreeSerifItalic.ttf
                 FreeSerif.ttf

             These directories contain some fonts with ".ttf" file
             name extensions and some with ".otf" file name extensions.
             Only the ".ttf" font files should be used with the GD
             driver.

             Under Windows 10, many fonts are stored in the

                 C:\WINDOWS\FONTS

             directory.  True Type fonts are identified with a ".ttf"
             file name extension.  Note that you free to use these fonts
             with Dataplot.  However, Microsoft does not grant
             re-distribution rights, so none of these are included in the
             Dataplot "fonts" directory.

          c) There are both commercial and freely downloadable True Type
             fonts available on the Internet.

Note:
    There are two color models supported.  The "fixed" mode uses
    a color palette with a maximum of 256 colors.  The "true" mode
    supports RGB mode where each of the three components can be
    set from 0 to 255.

    To specify the color model, enter

        SET GD COLOR <TRUE/FIXED>

    The default is FIXED.  The TRUE mode is recommended if you are
    going to be generating image plots.  Otherwise the FIXED option
    should be sufficient for most applications.

Note:
    Dataplot also uses the GD library to read image data in the
    supported formats.  Enter HELP READ IMAGE for details.

Note:
    The 2023/10 version of Dataplot corrected a number of issues with
    the GD driver.

       1) Dashed and dotted lines now work.

       2) Region fills were fixed.  Rectangular regions are performed
          in hardware (i.e., by the GD library) while non-rectangular
          fills are performed in software (i.e., by Dataplot).

          The following command was added

                SET GD HARDWARE FILL <ON/OFF>

          The default is OFF and this is recommended.  The ON option is
          currently intended for testing purposes and it is recommended
          that this option be left as OFF.  The ON option specifies
          that non-rectangular regions be filled in hardware.

       3) Fixed the background color when true color mode is specified.

Default:
    If no device is specified, the default device is PNG.
 
Synonyms:
    None

Device Notes:
    1) HARDWARE TEXT - the GD driver supports 5 built-in fonts.  In
       addition, True Type fonts are supported if available.  The
       True Type font can be specified with the

            SET GD FONT <font-name>

       command.

    2) COLOR - GD supports the full range of 163 colors supported
       by Dataplot.  Full RGB color is supported in true color mode.

    3) HARDWARE FILL - Solid area fills for rectangles are performed in
       hardware (i.e., by the GD library) and non-rectangular fills
       are performed in software (i.e., by Dataplot).

    4) DASH PATTERNS - The following dash patterns are available:
                       DASH  - 3 pixels on, 3 pixels off;
                       DOT   - 1 pixel on, 1 pixels off;
                       DASH2 - 4 pixels on, 2 pixels off
                       DASH3 - 3 pixels on, 3 pixels off,
                               1 pixel on, 1 pixel off; 
                       DASH4 - 2 pixels on, 2 pixels off.
                       DASH5 - 2 pixels on, 1 pixels off,
                               1 pixel on, 1 pixel off; 

    5) LINE WIDTH - Thick lines are generated in software (i.e., by
       Dataplot).

    6) GRAPHICS INPUT - The CROSS-HAIR command is not supported
       for this device.

    7) The CHARACTER PIXEL option is supported on this device.
 
Related Commands:
    POSTSCRIPT            = Direct graphical output to a Postscript
                            device.
    HPGL                  = Direct graphical output to an HPGL device.
    SVG                   = Generate graphical output in Scalable
                            Vector Graphics (SVG) format.
    DEVICE                = Specify certain actions for the graphics
                            output.
 
Applications:
    Web Applications, Graphics Import Into Other Programs
 
Implementation Date:
    2001/02
    2006/02: Upgraded to the 2.x version of the GD library
    2008/03: Support for true color mode
    2008/03: Support for hardware text
    2008/03: Support for reading image files
    2014/07: Added support for TIFF, BPM, WBPM, TGA and WEBPP formats
    2020/11: Increased number of supported colors in FIXED mode from
             89 to 163
    2023/10: Fixed dashed/dotted lines
    2023/10: Fixed region fill
    2023/10: Fixed background color for true color mode
 
Program 1:
    background color yellow
    . Following path name is for a Rocky 8 system
    set gd font /usr/share/fonts/gnu-free/FreeSansBold.ttf
    set ipl1na gd.jpg
    device 2 gd jpeg
    device 2 font tektronix
    .
    char hw 1 0.75 2 1.5
    char x y
    char color blue red
    line color blue red
    .
    title offset 2
    title Sample Plot
    title case asis
    y1label y axis
    x1label x axis
    label color green
    title color green
    .
    legend 1 direction vertical
    legend 1 just lece
    legend 1 coordinates 55 22
    legend 1 left
    legend 2 direction vertical
    legend 2 just cece
    legend 2 coordinates 55 32
    legend 2 center
    legend 3 direction vertical
    legend 3 just rice
    legend 3 coordinates 55 42
    legend 3 top
    .
    plot x    for x = 1 1 9 and
    plot x**2 for x = 1 1 9
    .
    just lebo
    move 25 75
    text Bottom
    just cece
    move 35 75
    text Center
    just rito
    move 45 75
    text Top
    draw 25 75 55 75
    draw 25 80 25 70
    draw 35 80 35 70
    draw 45 80 45 70
    .
    draw 50 22 60 22
    draw 50 32 60 32
    draw 50 42 60 42

Program 2:
    . Path name for font will be implementation dependent
    set gd font /usr/local/lib/dataplot/fonts/futuram.ttf
    set ipl1na gd2a.jpg
    device 2 gd jpeg
    device 2 font tektronix
    .
    char hw 1 0.75 2 1.5
    char circle box
    char color blue red
    char fill on on
    line solid solid
    line color blue ivory
    .
    grid on
    xgrid pattern dotted
    ygrid pattern dashed
    .
    title offset 2
    title Test Filled Characters/Futuram Font
    title case asis
    y1label y axis
    x1label x axis
    .
    plot x    for x = 1 1 9 and
    plot x**2 for x = 1 1 9
    .
    box shadow hw 0 0
    box fill pattern solid
    box fill color red
    box 20 70 30 85
    grid off
    .
    device 2 close
    background color white
    . Path name for font will be implementation dependent
    set gd font /usr/local/lib/dataplot/fonts/arial.ttf
    set ipl1na gd2b.jpg
    device 2 gd jpeg
    device 2 font tektronix
    .
    line color black black
    line da3 da5
    .
    title offset 2
    title Test Dash and Dot Lines/Arial Font
    title case asis
    y1label y axis
    x1label x axis
    .
    plot x    for x = 1 1 9 and
    plot x**2 for x = 1 1 9
    .
    device 2 close
    background color white
    set ipl1na gd2c.jpg
    . Path name for font will be implementation dependent
    set gd font /usr/local/lib/dataplot/fonts/Tahoma.ttf
    device 2 gd jpeg
    device 2 font tektronix
    .
    line solid solid
    line thickness 0.2 0.3
    .
    title offset 2
    title Test Line Thickness/Tahoma Font
    title case asis
    y1label y axis
    x1label x axis
    .
    plot x    for x = 1 1 9 and
    plot x**2 for x = 1 1 9
    .
    device 2 close
    set gd color true
    background color blue
    . Path name for font will be implementation dependent
    set gd font /usr/share/fonts/gnu-free/FreeSerifBold.ttf
    set ipl1na gd2d.jpg
    device 2 gd jpeg
    device 2 font tektronix
    .
    frame color yellow
    tic mark color yellow
    tic mark label color yellow
    title color cyan
    label color cyan
    .
    line solid solid
    line thickness 0.3 all
    line color blue red
    line rgb color 86 180 233 204 121 167
    character size 3 3
    character box circle
    character fill on on
    character rgb color 86 180 233 204 121 167
    .
    title offset 2
    title Test True Color Mode/Serif Bold Font
    title case asis
    y1label y axis
    x1label x axis
    .
    plot x    for x = 1 1 9 and
    plot x**2 for x = 1 1 9
    .
    device 2 close
    set gd color true
    background rgb color 50 98 211
    . Path name for font will be implementation dependent
    set gd font /usr/share/fonts/gnu-free/FreeSans.ttf
    set ipl1na gd2e.jpg
    device 2 gd jpeg
    device 2 font tektronix
    .
    frame color yellow
    tic mark color yellow
    tic mark label color yellow
    title color cyan
    label color cyan
    .
    line solid solid
    line thickness 0.3 all
    line color blue red
    line rgb color 86 180 233 204 121 167
    character size 3 3
    character box circle
    character fill on on
    character rgb color 86 180 233 204 121 167
    .
    title offset 2
    title Test True Color Mode/Sans Font
    title case asis
    y1label y axis
    x1label x axis
    .
    plot x    for x = 1 1 9 and
    plot x**2 for x = 1 1 9
    .
    device 2 close

-----GE (LET)--------------------------------
 
GE
 
Name:
    GE (LET)
 
Type:
    Library Function
 
Purpose:
    Return a 1 if the first number is greater than or equal to the second
    and return a 0 otherwise.

Description:
    SUBSET clauses do not support syntax like the following:

         LET Y = Y1  SUBSET Y1 > Y2
         LET Y = Y1  SUBSET Y1 >= Y2
         LET Y = Y1  SUBSET Y1 < Y2
         LET Y = Y1  SUBSET Y1 <= Y2
         LET Y = Y1  SUBSET Y1 = Y2
         LET Y = Y1  SUBSET Y1 <> Y2

    where Y1 and Y2 are both variables.

    This command is most typically used to create a tag variable
    that can be used on subsequent SUBSET clauses.  For example,
    suppose that Y1 and Y2 are two previously created variables and
    we want to sum the values of Y1 that are greater than or equal to
    the corresponding rows of Y2.

        LET TAG = GE(Y1,Y2)
        LET Y1SUM = SUM Y1 SUBSET TAG = 1
 
Syntax:
    LET <tag> = GE(<y1>,<y2>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter;
          <tag> is a variable or a parameter (depending on what <y1> and
               <y2> are) where the computed values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET TAG = GE(Y1,Y2)
    LET A = GE(3,2)

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GT       = Return 1 where the first number is greater than the second
               number and 0 otherwise.
    LT       = Return 1 where the first number is less than the second
               number and 0 otherwise.
    LE       = Return 1 where the first number is less than or
               equal to the second number and zero otherwise.
    EQ       = Return 1 where the first number is equal to the second
               number and zero otherwise.
    NE       = Return 1 where the first number is not equal to the second
               number and zero otherwise.
 
Applications:
    Data Management
 
Implementation Date:
    2021/06
 
Program:
    SKIP 25
    READ NATR332.DAT Y1 Y2
    LET TAG = GE(Y1,Y2)
    LET NGE = SUM TAG SUBSET TAG = 1
    LET N = SIZE Y1
    LET NLT = N - NGE
    PRINT "Number of rows where Y1 >= Y2:   ^NGE"
    PRINT "Number of rows where Y1 <  Y2:   ^NLT"
 
-----GEECDF (LET)--------------------------------
 
GEECDF
 
Name:
    GEECDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the geometric extreme exponential
    cumulative distribution function with tail length parameter
    GAMMA.
 
Description:
    The standard form of the geometric extreme exponential
    cumualtive distribution function is:
       F(x) = 1 - gamma/[EXP(x) + gamma - 1]       x >= 0; gamma > 0
 
Syntax:
    LET <y2> = GEECDF(<y1>,GAMMA)   <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, number, or parameter;
          <y2> is a variable or a parameter (depending on what <y1>
               is) where the computed geometric extreme exponential
               cdf value is stored;
          <GAMMA> is a positive number or parameter that specifies the
               tail length parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GEECDF(3,2)
    LET A = GEECDF(A1,4)
    LET X2 = GEECDF(X1,8)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GEECHAZ    = Compute the geometric extreme exponential cumulative
                 hazard function.
    GEEHAZ     = Compute the geometric extreme exponential hazard
                 function.
    GEEPDF     = Compute the geometric extreme exponential probability
                 denisty function.
    GEEPPF     = Compute the geometric extreme exponential percent
                 point function.
    IWEPDF     = Compute the inverted Weibull probability density
                 function.
    WEIPDF     = Compute the Weibull probability density function.
    GAMPDF     = Compute the gamma probability density function.
    CHSPDF     = Compute the chi-square probability density function.
    NORPDF     = Compute the normal probability density function.
    LGNPDF     = Compute the lognormal probability density function.
    PPCC PLOT  = Generate a PPCC plot.
    PROB PLOT  = Generate a probability plot.
    RAND NUMB  = Generate random numbers.
 
Reference:
    "CAN DATA RECOGNOZE ITS PARENT DISTRIBUTION?",
    MARSHALL, MEZA, OLKIN, JOURNAL OF COMPUTATIONAL
    AND GRAPHICAL STATISTICS, SEPTEMBER, 2001, PP. 555-580.
 
Applications:
    Reliability Analysis
 
Implementation Date:
    2001/11
 
Program:
    MULTIPOT 2 2
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT SCALE FACTOR 2
    Y1LABEL Probability
    Y1LABEL DISPLACEMENT 12
    X1LABEL X
    TITLE GEECDF (GAMMA = 0.5)
    PLOT GEECDF(X,0.5) FOR X = 0.01 0.01 5
    TITLE GEECDF (GAMMA = 1)
    PLOT GEECDF(X,1) FOR X = 0.01 0.01 5
    TITLE GEECDF (GAMMA = 2)
    PLOT GEECDF(X,2) FOR X = 0.01 0.01 5
    TITLE GEECDF (GAMMA = 5)
    PLOT GEECDF(X,5) FOR X = 0.01 0.01 5
    END OF MULTIPLOT
 
-----GEECHAZ (LET)--------------------------------
 
GEECHAZ
 
Name:
    GEECHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the geometric extreme exponential
    cumulative hazard function with tail length parameter GAMMA.
 
Description:
    The standard form of the geometric extreme exponential
    cumulative hazard function is:
       H(x) = -LOG{gamma/[EXP(x) + gamma - 1]}   x >= 0; gamma > 0
 
Syntax:
    LET <y2> = GEECHAZ(<y1>,GAMMA)   <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, number, or parameter;
          <y2> is a variable or a parameter (depending on what <y1>
               is) where the computed geometric extreme exponential
               cumulative hazard value is stored;
          <GAMMA> is a positive number or parameter that specifies the
               tail length parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GEECHAZ(3,2)
    LET A = GEECHAZ(A1,4)
    LET X2 = GEECHAZ(X1,8)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GEECDF     = Compute the geometric extreme exponential cumulative
                 distribution function.
    GEEHAZ     = Compute the geometric extreme exponential hazard
                 function.
    GEEPDF     = Compute the geometric extreme exponential 
                 probability density function.
    GEEPPF     = Compute the geometric extreme exponential percent
                 point function.
    IWEPDF     = Compute the inverted Weibull probability density
                 function.
    WEIPDF     = Compute the Weibull probability density function.
    GAMPDF     = Compute the gamma probability density function.
    CHSPDF     = Compute the chi-square probability density function.
    NORPDF     = Compute the normal probability density function.
    LGNPDF     = Compute the lognormal probability density function.
    PPCC PLOT  = Generate a PPCC plot.
    PROB PLOT  = Generate a probability plot.
    RAND NUMB  = Generate random numbers.
 
Reference:
    "CAN DATA RECOGNOZE ITS PARENT DISTRIBUTION?",
    MARSHALL, MEZA, OLKIN, JOURNAL OF COMPUTATIONAL
    AND GRAPHICAL STATISTICS, SEPTEMBER, 2001, PP. 555-580.
 
Applications:
    Reliability Analysis
 
Implementation Date:
    2001/11
 
Program:
    MULTIPOT 2 2
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT SCALE FACTOR 2
    Y1LABEL Probability
    Y1LABEL DISPLACEMENT 12
    X1LABEL X
    TITLE GEECHAZ (GAMMA = 0.5)
    PLOT GEECHAZ(X,0.5) FOR X = 0.01 0.01 5
    TITLE GEECHAZ (GAMMA = 1)
    PLOT GEECHAZ(X,1) FOR X = 0.01 0.01 5
    TITLE GEECHAZ (GAMMA = 2)
    PLOT GEECHAZ(X,2) FOR X = 0.01 0.01 5
    TITLE GEECHAZ (GAMMA = 5)
    PLOT GEECHAZ(X,5) FOR X = 0.01 0.01 5
    END OF MULTIPLOT
 
-----GEEHAZ (LET)--------------------------------
 
GEEHAZ
 
Name:
    GEEHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the geometric extreme exponential
    hazard function with tail length parameter GAMMA.
 
Description:
    The standard form of the geometric extreme exponential
    hazard function is:
       h(x) = {gamma*EXP(x)/[(EXP(x)+gamma-1)**2]}/
              {gamma/[EXP(x) + gamma - 1]}   x >= 0; gamma > 0
 
Syntax:
    LET <y2> = GEEHAZ(<y1>,GAMMA)   <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, number, or parameter;
          <y2> is a variable or a parameter (depending on what <y1>
               is) where the computed geometric extreme exponential
               hazard value is stored;
          <GAMMA> is a positive number or parameter that specifies the
               tail length parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GEEHAZ(3,2)
    LET A = GEEHAZ(A1,4)
    LET X2 = GEEHAZ(X1,8)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GEECDF     = Compute the geometric extreme exponential cumulative
                 distribution function.
    GEECHAZ    = Compute the geometric extreme exponential cumulative
                 hazard function.
    GEEPDF     = Compute the geometric extreme exponential 
                 probability density function.
    GEEPPF     = Compute the geometric extreme exponential percent
                 point function.
    IWEPDF     = Compute the inverted Weibull probability density
                 function.
    WEIPDF     = Compute the Weibull probability density function.
    GAMPDF     = Compute the gamma probability density function.
    CHSPDF     = Compute the chi-square probability density function.
    NORPDF     = Compute the normal probability density function.
    LGNPDF     = Compute the lognormal probability density function.
    PPCC PLOT  = Generate a PPCC plot.
    PROB PLOT  = Generate a probability plot.
    RAND NUMB  = Generate random numbers.
 
Reference:
    "CAN DATA RECOGNOZE ITS PARENT DISTRIBUTION?",
    MARSHALL, MEZA, OLKIN, JOURNAL OF COMPUTATIONAL
    AND GRAPHICAL STATISTICS, SEPTEMBER, 2001, PP. 555-580.
 
Applications:
    Reliability Analysis
 
Implementation Date:
    2001/11
 
Program:
    MULTIPOT 2 2
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT SCALE FACTOR 2
    Y1LABEL Probability
    Y1LABEL DISPLACEMENT 12
    X1LABEL X
    TITLE GEEHAZ (GAMMA = 0.5)
    PLOT GEEHAZ(X,0.5) FOR X = 0.01 0.01 5
    TITLE GEEHAZ (GAMMA = 1)
    PLOT GEEHAZ(X,1) FOR X = 0.01 0.01 5
    TITLE GEEHAZ (GAMMA = 2)
    PLOT GEEHAZ(X,2) FOR X = 0.01 0.01 5
    TITLE GEEHAZ (GAMMA = 5)
    PLOT GEEHAZ(X,5) FOR X = 0.01 0.01 5
    END OF MULTIPLOT
 
-----GEEPDF (LET)--------------------------------
 
GEEPDF
 
Name:
    GEEPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the geometric extreme exponential
    probability density function with tail length parameter GAMMA.
 
Description:
    The standard form of the geometric extreme exponential
    probability density function is:
       f(x) = gamma*EXP(x)/[(EXP(x)+gamma-1)**2]   x >= 0; gamma > 0
 
Syntax:
    LET <y2> = GEEPDF(<y1>,GAMMA)   <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, number, or parameter;
          <y2> is a variable or a parameter (depending on what <y1>
               is) where the computed geometric extreme exponential
               pdf value is stored;
          <GAMMA> is a positive number or parameter that specifies the
               tail length parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GEEPDF(3,2)
    LET A = GEEPDF(A1,4)
    LET X2 = GEEPDF(X1,8)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GEECDF     = Compute the geometric extreme exponential cumulative
                 distribution function.
    GEECHAZ    = Compute the geometric extreme exponential cumulative
                 hazard function.
    GEEHAZ     = Compute the geometric extreme exponential hazard
                 function.
    GEEPPF     = Compute the geometric extreme exponential percent
                 point function.
    IWEPDF     = Compute the inverted Weibull probability density
                 function.
    WEIPDF     = Compute the Weibull probability density function.
    GAMPDF     = Compute the gamma probability density function.
    CHSPDF     = Compute the chi-square probability density function.
    NORPDF     = Compute the normal probability density function.
    LGNPDF     = Compute the lognormal probability density function.
    PPCC PLOT  = Generate a PPCC plot.
    PROB PLOT  = Generate a probability plot.
    RAND NUMB  = Generate random numbers.
 
Reference:
    "CAN DATA RECOGNOZE ITS PARENT DISTRIBUTION?",
    MARSHALL, MEZA, OLKIN, JOURNAL OF COMPUTATIONAL
    AND GRAPHICAL STATISTICS, SEPTEMBER, 2001, PP. 555-580.
 
Applications:
    Reliability Analysis
 
Implementation Date:
    2001/11
 
Program:
    MULTIPOT 2 2
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT SCALE FACTOR 2
    Y1LABEL Probability
    Y1LABEL DISPLACEMENT 12
    X1LABEL X
    TITLE GEEPDF (GAMMA = 0.5)
    PLOT GEEPDF(X,0.5) FOR X = 0.01 0.01 5
    TITLE GEEPDF (GAMMA = 1)
    PLOT GEEPDF(X,1) FOR X = 0.01 0.01 5
    TITLE GEEPDF (GAMMA = 2)
    PLOT GEEPDF(X,2) FOR X = 0.01 0.01 5
    TITLE GEEPDF (GAMMA = 5)
    PLOT GEEPDF(X,5) FOR X = 0.01 0.01 5
    END OF MULTIPLOT
 
-----GEEPPF (LET)--------------------------------
 
GEEPPF
 
Name:
    GEEPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the geometric extreme exponential
    percent point function with tail length parameter GAMMA.
 
Description:
    The standard form of the geometric extreme exponential
    percent point function is:
       G(p) = LOG[(gamma/(1-p)) +1 - gamma]    0 <= p < 1; gamma > 0
 
Syntax:
    LET <y2> = GEEPPF(<y1>,GAMMA)   <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, number, or parameter;
          <y2> is a variable or a parameter (depending on what <y1>
               is) where the computed geometric extreme exponential
               ppf value is stored;
          <GAMMA> is a positive number or parameter that specifies the
               tail length parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GEEPPF(3,2)
    LET A = GEEPPF(A1,4)
    LET X2 = GEEPPF(X1,8)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GEECDF     = Compute the geometric extreme exponential cumulative
                 distribution function.
    GEECHAZ    = Compute the geometric extreme exponential cumulative
                 hazard function.
    GEEHAZ     = Compute the geometric extreme exponential hazard
                 function.
    GEEPDF     = Compute the geometric extreme exponential
                 probability density function.
    IWEPDF     = Compute the inverted Weibull percent point
                 function.
    WEIPDF     = Compute the Weibull percent point function.
    GAMPDF     = Compute the gamma percent point function.
    CHSPDF     = Compute the chi-square percent point function.
    NORPDF     = Compute the normal percent point function.
    LGNPDF     = Compute the lognormal percent point function.
    PPCC PLOT  = Generate a PPCC plot.
    PROB PLOT  = Generate a probability plot.
    RAND NUMB  = Generate random numbers.
 
Reference:
    "CAN DATA RECOGNOZE ITS PARENT DISTRIBUTION?",
    MARSHALL, MEZA, OLKIN, JOURNAL OF COMPUTATIONAL
    AND GRAPHICAL STATISTICS, SEPTEMBER, 2001, PP. 555-580.
 
Applications:
    Reliability Analysis
 
Implementation Date:
    2001/11
 
Program:
    MULTIPOT 2 2
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT SCALE FACTOR 2
    X1LABEL Probability
    Y1LABEL DISPLACEMENT 12
    Y1LABEL X
    TITLE GEEPPF (GAMMA = 0.5)
    PLOT GEEPPF(P,0.5) FOR P = 0 0.01 0.99
    TITLE GEEPPF (GAMMA = 1)
    PLOT GEEPPF(P,1) FOR P = 0 0.01 0.99
    TITLE GEEPPF (GAMMA = 2)
    PLOT GEEPPF(P,2) FOR P = 0 0.01 0.99
    TITLE GEEPPF (GAMMA = 5)
    PLOT GEEPPF(P,5) FOR P = 0 0.01 0.99
    END OF MULTIPLOT
 
-----GENERAL-------------------------------------------------------
 
GENERAL
 
Name:
    GENERAL
 
Type:
    Output Device Command
 
Purpose:
    Direct graphical output to a device independent format (a DATAPLOT
    specific metafile).
 
Description:
    The metafile contains an English-like description of the plot.
    Specifying GENERAL CODED generates abbreviated forms of the
    commands (in practice there is not much advantage to this form).
    Specifying GENERAL CGM produces a metafile in the ANSI standard CGM
    format (see help for CGM for more information).
 
    The purpose of generating a metafile is typically to make it
    available to some sort of post processor that supports a graphics
    device that DATAPLOT does not.  There is a DATAPLOT post processor
    program (which is independent of the DATAPLOT program) which can
    translate the metafile.  See the NOTE below for more details.
 
    You may have a local post processor that does support either the
    DATAPLOT specific metafile or the CGM metafile.  In this case,
    many post processors can also accept various types of device
    specific files as input.  Of the devices supported by DATAPLOT,
    the HP-GL, Postscript, and Tektronix 4014 formats are the most
    likely to be supported in this way.
 
Syntax 1:
    GENERAL
    GENERAL CODED
    GENERAL CGM
    This form designates device 1 (i.e., the terminal) as a GENERAL
    device.  This form is rarely used since metafiles are typically
    sent to a file so they can be post-processed.
 
Syntax 2:
    DEVICE <1/2/3> GENERAL
    DEVICE <1/2/3> GENERAL CODED
    DEVICE <1/2/3> GENERAL CGM
    This form designates one of DATAPLOT's 3 devices (it will typically
    be device 2) to be a GENERAL device.
 
Examples:
    GENERAL
    DEVICE 1 GENERAL
    DEVICE 2 GENERAL
    DEVICE 3 GENERAL
    DEVICE 2 GENERAL CODED
    DEVICE 2 GENERAL CGM
 
Note:
    The DATAPLOT post processor is run independently of DATAPLOT.  The
    following versions of the program are available:
    1) A version using the DISSPLA graphical subroutine library.
    2) A version using the TEMPLATE graphical subroutine library.
    3) Versions for specific graphics devices (currently for Calcomp,
       Postscript, and X11 devices).  However, these devices are now
       available directly in DATAPLOT, so there is no need for them.
    4) A skeleton version, which can be modified to support a local
       graphics library or graphics device.  There is a manual for the
       DATAPLOT post processor that gives more information on how to do
       this.  Post processors tend to be adequate solutions for
       off-line devices such as plotters and film recorders.  They are
       not very useful for terminal devices (although these can be
       useful for previewing or for debugging a driver before trying to
       install it directly into DATAPLOT).
 
    The DATAPLOT post processor can translate DATAPLOT GENERAL format
    files and Tektronix 4014 format files.  However, it does not
    translate CGM metafiles.  The CGM files should be usable by post
    processors that support CGM.
 
    Contact Alan Heckert (301-975-2899, heckert@cam.nist.gov) to obtain
    a copy of the post processor.
 
Note:
    In order to support post processors with varying degrees of
    capability, several SET commands are available to control the
    output produced by the metafiles.
 
    SET GENERAL REGION FILL [ON/OFF] - if OFF, region fills are
      generated with move and draw commands.  If ON, a pattern
      identifier is specified and the post processor generates the
      region fill.
 
    SET GENERAL JUSTIFICATION [ON/OFF] - if OFF, text strings are
      justified before being plotted.  If ON, a justification is
      specified and the post processor does the justification.
 
    SET GENERAL FONT [OFF/ON] - if OFF, software fonts are  generated
      as move and draw commands.  If ON, the name of the font and the
      text string are specified and the post processor draws it.
 
    SET GENERAL PEN WIDTH [OFF/ON] - if OFF, a line width parameter is
      specified and the line is drawn once (i.e., the post processor
      draws the wide lines).  If ON, the line is drawn multiple times
      to handle wide lines.
 
    SET GENERAL PEN THICKNESS [width] - sets the line width (in
      DATAPLOT 0. to 100. coordinates) to use when multiple lines are
      used to draw wide lines.
 
Default:
    Off
 
Synonyms:
    None
DEVICE NOTES
    The following notes apply to how attributes are stored in the
    metafile.  Be aware that a post processor can do things differently
    when drawing the metafile on a specific device (e.g., it may draw
    area fills in software even though the metafile specifies a
    hardware fill).
    1) HARDWARE TEXT - GENERAL hardware characters can be scaled to any
       size.  Vertical strings are specified as vertical strings (it
       is up to the post processor to rotate them however).
    2) COLOR - The GENERAL driver supports 8 colors.  Enter the SHOW
       COLORS GENERAL to list the color mapping.
    3) HARDWARE FILL - The GENERAL file specifies the boundary of the
       region and an index identifying the type of fill.  See the
       SET GENERAL REGION FILL note above for instructions on how to
       generate software fills directly in the metafile.
    4) DASH PATTERNS - The GENERAL file identifies the dash pattern
       with an index.  There is a unique index for each dash pattern
       supported by DATAPLOT.
    5) LINE WIDTH - The GENERAL device draws thick lines by drawing one
       line and specifying a width parameter.  See the SET GENERAL
       PEN WIDTH note above for instructions on how to draw thick
       lines by drawing multiple lines instead.
    6) GRAPHICS INPUT - The CROSS-HAIR command is ignored for this
       device.
 
Related Commands:
    CGM                   = Direct graphical output to a CGM metafile.
    CALCOMP               = Direct graphical output to a Calcomp
                            device.
    POSTSCRIPT            = Direct graphical output to a Postscript
                            device.
    TEKTRONIX             = Direct graphical output to a Tektronix
                            device.
    HPGL                  = Direct graphical output to an HP-GL device.
    DEVICE                = Specify certain actions for the graphics
                            output.
    SET GENE REGION FILL  = Specify whether region fills are done in
                            hardware or software.
    SET GENERAL PEN WIDTH = Specify whether wide lines are drawn in
                            hardware or software.
    SET GENERAL PEN THICK = Specify the width of a single line when
                            drawing wide lines.
    SET GENERAL FONT      = Specify whether software fonts are drawn by
                            DATAPLOT or the post processor.
    SET GENERAL JUST      = Specify whether text justification is
                            handled by DATAPLOT or the post processor.
 
Applications:
    XX
 
Implementation Date:
    89/2
 
Program:
    XX
 
-----GENERALIZED JACCARD COEFFICIENT (LET)-----------------------------

GENERALIZED JACCARD COEFFICIENT
GENERALIZED JACCARD DISTANCE

Name:
    GENERALIZED JACCARD COEFFICIENT (LET)
    GENERALIZED JACCARD DISTANCE (LET)

Type:
    Let Subcommand

Purpose:
    Compute the generalized Jaccard coefficient or the generalized
    Jaccard distance between two variables.

Description:
    The generalized Jaccard coefficient between two variabes X and Y is

        J(X,Y) = SUM[i=1 to n][MIN(X(i),Y(i)]/SUM[i=1 to n][MAX(X(i),Y(i)]

    The Jaccard distance is then defined as 1 - J(X,Y).

Syntax 1:
    LET <par> = GENERALIZED JACCARD COEFFICIENT <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed generalized Jaccard
              coefficient is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Syntax 2:
    LET <par> = GENERALIZED JACCARD DISTANCE <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed generalized Jaccard
              distance is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Examples:
    LET A = GENERALIZED JACCARD COEFFICIENT Y1 Y2
    LET A = GENERALIZED JACCARD DISTANCE Y1 Y2
    LET A = GENERALIZED JACCARD COEFFICIENT Y1 Y2 ...
            SUBSET Y1 >= 0  SUBSET Y2 >= 0

Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BINARY JACCARD DISSIMILARITY = Compute the Jaccard dissimilarity
                                   coeficient for two binary variables.
    COSINE DISTANCE              = Compute the cosine distance.
    MANHATTAN DISTANCE           = Compute the Euclidean distance.
    EUCLIDEAN DISTANCE           = Compute the Euclidean distance.
    MATRIX DISTANCE              = Compute various distance metrics for
                                   a matrix.
    GENERATE MATRIX <stat>       = Compute a matrix of pairwise statistic
                                   values.

Applications:
    Mathematics
 
Implementation Date:
    2017/08
 
Program 1:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET DIST  = GENERALIZED JACCARD DISTANCE Y1 Y2
    SET WRITE DECIMALS 4
    TABULATE GENERALIZED JACCARD DISTANCE Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    LET NDIST = UNIQUE X
    XLIMITS 1 NDIST
    MAJOR X1TIC MARK NUMBER NDIST
    MINOR X1TIC MARK NUMBER 0
    CHAR X
    LINE BLANK
    LABEL CASE ASIS
    CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    TITLE Generalized Jaccard Distance (IRIS.DAT)
    Y1LABEL Generalized Jaccard Distance
    GENERALIZED JACCARD DISTANCE PLOT Y1 Y2 X
 
Program 2:
    set write decimals 3
    dimension 100 columns
    .
    skip 25
    read iris.dat y1 y2 y3 y4
    skip 0
    .
    let z = generate matrix generalized jaccard coefficient y1 y2 y3 y4
    print z

-----GENERATE MATRIX (LET)----------------------------------------
 
GENERATE MATRIX
 
Name:
    GENERATE MATRIX (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Given a list of k variables, generate a kxk matrix containing
    all the pairwise values of a specified statistic that requires
    exactly two response variables.
 
Description:
    This command can be useful for certain types of multivariate
    analysis.  For example, it can be used to generate a dissimilarity
    or distance matrix for a cluster analysis.

    The specified statistic should require exactly two response
    variables to compute.  Examples include correlation and
    covariances, various distance measures, differences of location
    or scale statistics, and so on.  Statistics that require a single
    response variable or more than two response variables will return
    an error.

    A number of supported statistics that require two response
    variables have the second variable as a group-id variable.
    Although this command will not generate a syntax error for
    these cases, the resulting statistics will not be meaningful.

Syntax:
    LET <mat1> = GENERATE MATRIX <stat> <var1> ... <vark>
                 <SUBSET/EXCEPT/FOR qualification>
    where <stat> is one of Dataplot's supported statistics that
                 requires exactly two response variable;
          <var1> ... <vark> is a list of previously defined variables;
          <mat1> is a matrix where the resulting matrix is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET C = GENERATE MATRIX CORRELATION X1 X2 X3 X4
    LET D = GENERATE MATRIX MANHATTAN DISTANCE Y1 Y2 Y3 Y4 Y5
 
Note:
    The columns of a matrix are accessible as variables by appending
    an index to the matrix name.  For example, the 4x4 matrix C has
    columns C1, C2, C3, and C4.  These columns can be operated on
    like any other Dataplot variable.
 
Note:
    For a list of supported statistics, enter

        HELP STATISTICS
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CREATE MATRIX            = Create a matrix from a list of variables.
    CORRELATION MATRIX       = Create a correlation matrix from a matrix
                               of response variables.
    STATISTIC                = Provides a list of supported statistics.
 
Applications:
    Multivariate Analyis
 
Implementation Date:
    2017/08
 
Program:
    set write decimals 3
    dimension 100 columns
    .
    skip 25
    read iris.dat y1 y2 y3 y4
    skip 0
    .
    . Step 2:   Generate the matrix
    .
    let m = generate matrix correlation y1 y2 y3 y4
    print m
    .
    let m = generate matrix euclidean distance y1 y2 y3 y4
    print m
    .
    let m = generate matrix difference of means y1 y2 y3 y4
    print m
 
-----GENERATOR MULTIPLICATION (LET)-----------------------------------
 
GENERATOR MULTIPLICATION
 
Name:
    GENERATOR MULTIPLICATION (LET)
 
Type:
    Let Subcommand
 
Purpose:
 
 
Description:
 
 
Syntax:
    LET <y1> = GENERATOR MULTIPLICATION <x1> <x2>
                    <SUBSET/EXCEPT/FOR qualification>
    where <x1> is a variable ...   ;
          <x2> is a variable ...   ;
          <y1> is a variable where the generated values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    XX
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COCODE         = Generate a cocoded variable.
    CODE           = Generate a coded variable.
    SEQUENCE       = Generate a sequence of numbers.
    PATTERN        = Generate numbers with a specific pattern.
 
Applications:
    Design of Experiments
 
Implementation Date:
    12.89
 
Program:
    XX
 
-----GEOCDF (LET)--------------------------------
 
GEOCDF
 
Name:
    GEOCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the geometric cumulative distribution function.
 
Description:
    The geometric distribution is used when there are exactly two
    mutually exclusive outcomes of a trial.  These outcomes are often
    called successes and failures.  The geometric probability
    distribution is the distribution of the number of failures before
    obtaining the first success.  It has the following probability
    density function:
       geopdf(x;x,p) = p*(1-p)**x
    where p is the probability of a success on a single trial.  This
    distribution has a mean of (1-p)/p and a standard deviation of
    sqrt((1-p)/p**2).
 
    The cumulative distribution is the probability of obtaining x or
    fewer failure before obtaining the first success.  It is calculated
    as:
       geocdf(x;x,p) = 1.0 - (1.0-p)**(x+1.0)
 
Syntax:
    LET <y2> = GEOCDF(<y1>,<p>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a non-negative integer variable, number, or
               parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed geometric cdf value is stored;
          <p> is a number or parameter between 0 and 1 that is the
               probability of success on a single trial;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GEOCDF(3,0.5)
    LET X2 = GEOCDF(X1,0.3)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GEOPDF = Compute the geometric probability density function.
    GEOPPF = Compute the geometric percent point function.
    BINCDF = Compute the binomial cumulative distribution function.
    BINPDF = Compute the binomial probability density function.
    BINPPF = Compute the binomial percent point function.
    POIPDF = Compute the Poisson probability density function.
    POICDF = Compute the Poisson cumulative distribution function.
    POIPPF = Compute the Poisson percent point function.
    NBCDF  = Compute the negative binomial cumulative distribution
             function.
    NBPDF  = Compute the negative binomial probability density
             function.
    NBPPF  = Compute the negative binomial percent point function.
 
Reference:
    "An Introduction to Probability Theory and Its Applications, Volume
    I", 2nd edition, Feller, Wiley and Sons, 1957 (pp. 155-157, 210).
 
    "Discrete Univariate Distributions", Johnson and Kotz, Houghton
    Mifflin, 1969 (chapter 5).
 
Applications:
    XX
 
Implementation Date:
    94/4
 
Program:
    YLIMITS 0 1
    MAJOR YTIC NUMBER 6
    MINOR YTIC NUMBER 1
    YTIC DECIMAL 1
    XLIMITS 0 50
    XTIC OFFSET 0.5 0.5
    LINE BLANK
    SPIKE ON
    SPIKE LINE DASH
    CHARACTER CIRCLE
    CHARACTER FILL ON
    CHARACTER SIZE 1.2
    TITLE AUTOMATIC
    X1LABEL NUMBER OF TRIALS TILL FIRST SUCCESS
    Y1LABEL PROBABILITY
    PLOT GEOCDF(X,0.1) FOR X = 0 1 50
 
-----GEOMETRIC MEAN (LET)-----------------------------------------
 
GEOMETRIC MEAN
 
Name:
    GEOMETRIC MEAN (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the geometric mean for a variable.
 
Description:
    The geometric mean is defined as:
 
         XGM = (PRODUCT(Xi))**(1/N)

Syntax:
    LET <par> = GEOMETRIC MEAN <y1> <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the response variable;
          <par> is a parameter where the computed geometric mean
              is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GEOMETRIC MEAN Y1
    LET A = GEOMETRIC MEAN Y1 SUBSET TAG > 2
 
Note:
    Support for the geometric mean has been added to the 
    following plots:

       GEOMETRIC MEAN PLOT
       BOOTSTRAP GEOMETRIC MEAN PLOT
       JACKNIFE GEOMETRIC MEAN PLOT
       CROSS TABULATE GEOMETRIC MEAN PLOT
       INTERACTION  GEOMETRIC MEAN PLOT

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    MEAN                           = Compute the mean.
    MEDIAN                         = Compute the median.
    GEOMETRIC STANDARD DEVIATION   = Compute the geometric standard
                                     deviation.
    STATISTIC  PLOT                = Generate a statistic vs.
                                     subset plot.
    BOOTSTRAP PLOT                 = Generate a bootstrap plot.
    JACKNIFE PLOT                  = Generate a jacknife plot.
    CROSS TABULATE PLOT            = Generate a cross tabulate plot.
    INTERACTION PLOT               = Generate an interaction plot.

 
Applications:
    Data Analysis
 
Implementation Date:
    2000/1
 
Program:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET A1 = GEOMETRIC MEAN Y1
 
-----GEOMETRIC STANDARD DEVIATION (LET)-----------------------------
 
GEOMETRIC STANDARD DEVIATION
 
Name:
    GEOMETRIC STANDARD DEVIATION (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the geometric standard deviation for a variable.
 
Description:
    The geometric standard deviation is defined as:
 
         GSD = EXP(SD(LOG(Xi)))

Syntax:
    LET <par> = GEOMETRIC STANDARD DEVIATION  <y1>
                          <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the response variable;
          <par> is a parameter where the computed geometric standard
              deviation is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GEOMETRIC STANDARD DEVIATION Y1
    LET A = GEOMETRIC STANDARD DEVIATION Y1 SUBSET TAG > 2
 
Note:
    Support for the geometric standard deviation has been added
    to the following plots:

       GEOMETRIC STANDARD DEVIATION PLOT
       BOOTSTRAP GEOMETRIC STANDARD DEVIATION PLOT
       JACKNIFE GEOMETRIC STANDARD DEVIATION PLOT
       CROSS TABULATE GEOMETRIC STANDARD DEVIATION PLOT
       INTERACTION  GEOMETRIC STANDARD DEVIATION PLOT

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    STANDARD DEVIATION    = Compute the standard deviation.
    MAD                   = Compute the median absolute deviation.
    GEOMETRIC MEAN        = Compute the geometric mean.
    STATISTIC  PLOT       = Generate a statistic vs.  subset plot.
    BOOTSTRAP PLOT        = Generate a bootstrap plot.
    JACKNIFE PLOT         = Generate a jacknife plot.
    CROSS TABULATE PLOT   = Generate a cross tabulate plot.
    INTERACTION PLOT      = Generate an interaction plot.

 
Applications:
    Data Analysis
 
Implementation Date:
    2000/1
 
Program:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET A1 = GEOMETRIC STANDARD DEVIATION Y1
 
-----GEOPDF (LET)--------------------------------
 
GEOPDF
 
Name:
    GEOPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the geometric probability density function.
 
Description:
    The geometric distribution is used when there are exactly two
    mutually exclusive outcomes of a trial.  These outcomes are often
    called successes and failures.  The geometric probability
    distribution is the distribution of the number of failures before
    obtaining the first success.  It has the following probability
    density function:

       geopdf(x;x,p) = p*(1-p)**x       x = 0, 1, 2, ...

    where p is the probability of a success on a single trial.  This
    distribution has a mean of (1-p)/p and a standard deviation of
    sqrt((1-p)/p**2).
 
Syntax:
    LET <y2> = GEOPDF(<y1>,<p>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a non-negative integer variable, number, or
               parameter;
          <p> is a number or parameter between 0 and 1 that is the
               probability of success on a single trial;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed geometric pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GEOPDF(3,0.5)
    LET X2 = GEOPDF(X1,0.3)
 
Note:
    The default definition of the geometric definition is the
    number of failures before the first success is obtained in a
    sequence of Bernoulli trials.

    An alternate definition is the number of trials up to and
    including the first success in a sequence of Bernoulli
    trials.  This definition simply shifts the geometric
    distribution to start at X = 1 rather than at X = 0.  The
    The probability mass function in this case is

       geopdf(x;p) = p*(1-p)**(x-1)       x = 1, 2, ...

    where p is the probability of a success on a single trial.  This
    distribution has a mean of 1/p and a standard deviation of
    sqrt((1-p)/p**2).
 
    To specify the alternate definition, enter the command

       SET GEOMETRIC DEFINITION DLMF

    DLMF stands for the Digital Library of Mathematical Functions.
    The DLMF uses this alternate definition.

    To reset the default definition, enter the command
    
       SET GEOMETRIC DEFINITION JOHNSON AND KOTZ

Note:
    For a number of commands utilizing the geometric distribution,
    it is convenient to bin the data.  There are two basic ways of
    binning the data.

      1) For some commands (histograms, maximum likelihood
         estimation), bins with equal size widths are
         required.  This can be accomplished with the
         following commands:

            LET AMIN = MINIMUM Y
            LET AMAX = MAXIMUM Y
            LET AMIN2 = AMIN - 0.5
            LET AMAX2 = AMAX + 0.5
            CLASS MINIMUM AMIN2
            CLASS MAXIMUM AMAX2
            CLASS WIDTH 1
            LET Y2 X2 = BINNED

      2) For some commands, unequal width bins may be
         helpful.  In particular, for the chi-square goodness
         of fit, it is typically recommended that the minimum
         class frequency be at least 5.  In this case, it may
         be helpful to combine small frequencies in the tails.
         Unequal class width bins can be created with the
         commands

            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = INTEGER FREQUENCY TABLE Y

         If you already have equal width bins data, you can
         use the commands
         
            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = COMBINE FREQUENCY TABLE Y2 X2

         The MINSIZE parameter defines the minimum class
         frequency.  The default value is 5.

Note:
    You can generate geometric random numbers, probability
    plots, and chi-square goodness of fit tests with the
    following commands:

       LET P = <value>
       LET Y = GEOMETRIC RANDOM NUMBERS FOR I = 1 1 N

       GEOMETRIC PROBABILITY PLOT Y
       GEOMETRIC PROBABILITY PLOT Y2 X2
       GEOMETRIC PROBABILITY PLOT Y3 XLOW XHIGH

       GEOMETRIC CHI-SQUARE GOODNESS OF FIT Y
       GEOMETRIC CHI-SQUARE GOODNESS OF FIT Y2 X2
       GEOMETRIC CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    The maximum likelihood estimate of p can be obtained
    with the command

       GEOMETRIC MAXIMUM LIKELIHOOD Y 

    The formula for the maximum likelihood estimate is:
 
       1/(xbar+1)

    with xbar denoting the sample mean.

    You can generate an estimate of p based on the maximum
    ppcc value or the minimum chi-square goodness of fit
    with the commands

        LET P1 = <value>
        LET P2 = <value>
        GEOMETRIC KS PLOT Y
        GEOMETRIC KS PLOT Y2 X2
        GEOMETRIC KS PLOT Y3 XLOW XHIGH
        GEOMETRIC PPCC PLOT Y
        GEOMETRIC PPCC PLOT Y2 X2
        GEOMETRIC PPCC PLOT Y3 XLOW XHIGH

    The default values of p1 and p2 are 0.05 and 0.95,
    respectively.  Due to the discrete nature of the percent
    point function for discrete distributions, the ppcc plot
    will not be smooth.  For that reason, if there is sufficient
    sample size the KS PLOT (i.e., the minimum chi-square value)
    is typically preferred.  However, it may sometimes be useful
    to perform one iteration of the PPCC PLOT to obtain a rough
    idea of an appropriate neighborhood for the shape parameters
    since the minimum chi-square statistic can generate extremely
    large values for non-optimal values of the shape parameters.
    Also, since the data is integer values, one of the binned
    forms is preferred for these commands.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GEOCDF = Compute the geometric cumulative distribution function.
    GEOPPF = Compute the geometric percent point function.
    BINCDF = Compute the binomial cumulative distribution function.
    BINPDF = Compute the binomial probability density function.
    BINPPF = Compute the binomial percent point function.
    POIPDF = Compute the Poisson probability density function.
    POICDF = Compute the Poisson cumulative distribution function.
    POIPPF = Compute the Poisson percent point function.
    NBCDF  = Compute the negative binomial cumulative distribution
             function.
    NBPDF  = Compute the negative binomial probability density
             function.
    NBPPF  = Compute the negative binomial percent point function.
 
Reference:
    "An Introduction to Probability Theory and Its Applications,
    Volume I", 2nd edition, Feller, Wiley and Sons, 1957
    (pp. 155-157, 210).
 
    "Discrete Univariate Distributions", Johnson and Kotz, Houghton
    Mifflin, 1969 (chapter 5).
 
Applications:
    Distributional Modeling
 
Implementation Date:
    1994/4
 
Program:
    XLIMITS 0 25
    XTIC OFFSET 0.5 0.5
    LINE BLANK
    SPIKE ON
    SPIKE LINE DASH
    CHARACTER CIRCLE
    CHARACTER FILL ON
    CHARACTER SIZE 1.2
    TITLE AUTOMATIC
    X1LABEL NUMBER OF TRIALS TILL FIRST SUCCESS
    Y1LABEL PROBABILITY
    PLOT GEOPDF(X,0.1) FOR X = 0 1 25
 
-----GEOPPF (LET)--------------------------------
 
GEOPPF
 
Name:
    GEOPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the geometric percent point function.
 
Description:
    The geometric distribution is used when there are exactly two
    mutually exclusive outcomes of a trial.  These outcomes are often
    called successes and failures.  The geometric probability
    distribution is the distribution of the number of failures before
    obtaining the first success.  It has the following probability
    density function:
       geopdf(x;x,p) = p*(1-p)**x
    where p is the probability of a success on a single trial.  This
    disrtibution has a mean of (1-p)/p and a standard deviation of
    sqrt((1-p)/p**2).
 
    The percent point function is the inverse of the cumulative
    distribution function.  The cumulative distribution sums the
    probability from 0 to the given x value.  The percent point
    function takes a cumulative probability value and computes the
    corresponding x value.
 
    The input value is a real number between 0 and 1 (since it
    corresponds to a probability).
    number.
 
Syntax:
    LET <y2> = GEOPPF(<y1>,<p>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, a number, or a parameter in the range 0
              to 1;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed geometric ppf value is stored;
          <p> is a number or parameter between 0 and 1 that is the
               probability of success on a single trial;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GEOPPF(0.9,0.5)
    LET X2 = GEOPPF(X1,0.7)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GEOCDF = Compute the geometric cumulative distribution function.
    GEOPPF = Compute the geometric percent point function.
    BINCDF = Compute the binomial cumulative distribution function.
    BINPDF = Compute the binomial probability density function.
    BINPPF = Compute the binomial percent point function.
    POIPDF = Compute the Poisson probability density function.
    POICDF = Compute the Poisson cumulative distribution function.
    POIPPF = Compute the Poisson percent point function.
    NBCDF  = Compute the negative binomial cumulative distribution
             function.
    NBPDF  = Compute the negative binomial probability density
             function.
    NBPPF  = Compute the negative binomial percent point function.
 
Reference:
    "An Introduction to Probability Theory and Its Applications, Volume
    I", 2nd edition, Feller, Wiley and Sons, 1957 (pp. 155-157, 210).
 
    "Discrete Univariate Distributions", Johnson and Kotz, Houghton
    Mifflin, 1969 (chapter 5).
 
Applications:
    XX
 
Implementation Date:
    94/4
 
Program:
    XLIMITS 0 1
    MAJOR XTIC NUMBER 6
    MINOR XTIC NUMBER 1
    XTIC DECIMAL 1
    TITLE AUTOMATIC
    X1LABEL PROBABILITY
    Y1LABEL NUMBER OF SUCCESSES
    PLOT GEOPPF(X,0.1) FOR X = 0.01 0.01 0.99
 
-----GEPCDF (LET)--------------------------------
 
GEPCDF
 
Name:
    GEPCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized Pareto cumulative distribution function
    with shape parameter GAMMA.
 
Description:
    The generalized Pareto distribution for the maximum order statistic
    has the following probability density function for all positive x:
       f(x)=(1+gamma*x)**(-(1/gamma)-1)
    GAMMA can be any real number.  If GAMMA is 0, the probability
    density function is defined to be:
       f(x)=exp(-x)
    The cumulative distribution is the area from 0 to x (i.e., the
    integral) of the above function, and it has the form:
       cdf(x)=1-(1+gamma*x)**(-1/gamma)
    For gamma equal 0, the cdf function is:
       cdf(x) = 1-exp(-x)
 
Syntax:
    LET <y2> = GEPCDF(<y1>,GAMMA)   <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, number, or parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed generalized Pareto cdf value is
               stored;
          <GAMMA> is a number or parameter that specifies the shape
               parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GEPCDF(3,2)
    LET A = GEPCDF(A1,8)
 
Note:
    The SET MINMAX command is used to specify whether the minimum order
    statistic or the maximum order statistic form is used.
    Specifically, SET MINMAX 1 specifies the minimum order statistic
    while SET MINMAX 2 specifies the maximum order statistic.
    Currently, only the maximum order statistic form is supported.
    However, the SET MINMAX command is still required.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GEPPDF = Compute the generalized Pareto probability density
             function.
    GEPPPF = Compute the generalized Pareto percent point function.
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    FCDF   = Compute the F cumulative distribution function.
    FPDF   = Compute the F probability density function.
    FPPF   = Compute the F percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    TCDF   = Compute the T cumulative distribution function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
    WEICDF = Compute the Weibull cumulative probability density
             function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994.
 
Applications:
    Extreme Value Analysis
 
Implementation Date:
    94/2
 
Program:
    SEGMENT 1 COORDINATES 69 38 74 38; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 69 34 74 34; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 69 30 74 30; SEGMENT 3 PATTERN DOT
    SEGMENT 4 COORDINATES 69 26 74 26; SEGMENT 4 PATTERN DASH2
    LEGEND 1 GAMMA = 1; LEGEND 1 COORDINATES 75 37
    LEGEND 2 GAMMA = 2; LEGEND 2 COORDINATES 75 33
    LEGEND 3 GAMMA = 5; LEGEND 3 COORDINATES 75 29
    LEGEND 4 GAMMA = .5; LEGEND 4 COORDINATES 75 25
    XLIMITS 0 5; YLIMITS 0 1
    MAJOR YTIC NUMBER 6; MINOR YTIC NUMBER 1; YTIC DECIMAL 1
    TITLE PLOT GEPCDF FOR VARIOUS VALUES OF GAMMA
    LINES SOLID DASH DOT DASH2
    SET MINMAX 2
    PLOT GEPCDF(X,1) FOR X = 0.01 0.01 5 AND
    PLOT GEPCDF(X,2) FOR X = 0.01 0.01 5 AND
    PLOT GEPCDF(X,5) FOR X = 0.01 0.01 5 AND
    PLOT GEPCDF(X,0.5) FOR X = 0.01 0.01 5
 
-----GEPCHAZ (LET)--------------------------------
 
GEPCHAZ
 
Name:
    GEPCHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized Pareto cumulative hazard function with
    shape parameter GAMMA.
 
Description:
    The generalized Pareto distribution for the maximum order statistic
    has the following cumulative hazard function:
       H(x)=-LOG(1 - GEPCDF(x,gamma)    x > 0
    where gamma is the shape parameter and GEPCDF is the cumulative
    distribution function of the generalized Pareto distribution.
    If gamma is negative, the cumulative hazard function is:
       H(x)=-LOG(1 - GEPCDF(x,gamma)    x >= -1/gamma
 
Syntax:
    LET <y> = GEPCHAZ(<x>,GAMMA)     <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed generalized Pareto cumulative hazard
              value is stored;
          <GAMMA> is a positive number or parameter that specifies the
              shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GEPCHAZ(3,2)
    LET A = GEPCHAZ(A1,4)
 
Note:
    The SET MINMAX command is used to specify whether the minimum order
    statistic or the maximumorder statistic form is used. Specifically,
    SET MINMAX 1 specifies the minimum order statistic while SET MINMAX
    2 specifies the maximum order statistic.  Currently, only the
    maximum order statistic form is supported, so it is not
    necessary to specify the SET MINMAX command.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GEPCDF  = Compute the generalized Pareto cumulative distribution
              function.
    GEPPDF  = Compute the generalized Pareto probability density
              function.
    GEPPPF  = Compute the generalized Pareto percent point function.
    GEPHAZ  = Compute the generalized Pareto hazard function.
    CHSPDF  = Compute the chi-square probability density function.
    NORPDF  = Compute the normal probability density function.
    WEIPDF  = Compute the Weibull probability density function.
    EV1PDF  = Compute the Gumbel (EV1) probability density function.
    EV2PDF  = Compute the Gumbel (EV1) probability density function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, 1970.
 
Applications:
    Reliability, Extreme Value Analysis
 
Implementation Date:
    1998/4
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    TITLE CASE ASIS
    TITLE Generalized Pareto Cumulative Hazard (Gamma = 1)
    PLOT GEPCHAZ(X,1) FOR X = 0.01 0.01 5
    TITLE Generalized Pareto Cumulative Hazard (Gamma = 2)
    PLOT GEPCHAZ(X,2) FOR X = 0.01 0.01 5
    TITLE Generalized Pareto Cumulative Hazard (Gamma = 5)
    PLOT GEPCHAZ(X,5) FOR X = 0.01 0.01 5
    TITLE Generalized Pareto Cumulative Hazard (Gamma = 0.5)
    PLOT GEPCHAZ(X,0.5) FOR X = 0.01 0.01 5
    END OF MULTIPLOT
 
-----GEPHAZ (LET)--------------------------------
 
GEPHAZ
 
Name:
    GEPHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized Pareto hazard function with
    shape parameter GAMMA.
 
Description:
    The generalized Pareto distribution for the maximum order statistic
    has the following hazard function:
       h(x)=1/(1 + gamma*x)       x > 0
    If gamma is negative, the hazard function is:
       h(x)=1/(1 + gamma*x)       x > = -1/gamma
 
Syntax:
    LET <y> = GEPHAZ(<x>,GAMMA)     <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed generalized Pareto hazard value
              is stored;
          <GAMMA> is a positive number or parameter that specifies the
              shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GEPHAZ(3,2)
    LET A = GEPHAZ(A1,4)
 
Note:
    The SET MINMAX command is used to specify whether the minimum order
    statistic or the maximumorder statistic form is used. Specifically,
    SET MINMAX 1 specifies the minimum order statistic while SET MINMAX
    2 specifies the maximum order statistic.  Currently, only the
    maximum order statistic form is supported, so it is not
    necessary to specify the SET MINMAX command.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GEPCDF  = Compute the generalized Pareto cumulative distribution
              function.
    GEPPDF  = Compute the generalized Pareto probability density
              function.
    GEPPPF  = Compute the generalized Pareto percent point function.
    GEPCHAZ = Compute the generalized Pareto cumulative hazard
              function.
    CHSPDF  = Compute the chi-square probability density function.
    NORPDF  = Compute the normal probability density function.
    WEIPDF  = Compute the Weibull probability density function.
    EV1PDF  = Compute the Gumbel (EV1) probability density function.
    EV2PDF  = Compute the Gumbel (EV1) probability density function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, 1970.
 
Applications:
    Reliability, Extreme Value Analysis
 
Implementation Date:
    1998/4
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    TITLE CASE ASIS
    TITLE Generalized Pareto Hazard Function (Gamma = 1)
    PLOT GEPHAZ(X,1) FOR X = 0.01 0.01 5
    TITLE Generalized Pareto Hazard Function (Gamma = 2)
    PLOT GEPHAZ(X,2) FOR X = 0.01 0.01 5
    TITLE Generalized Pareto Hazard Function (Gamma = 5)
    PLOT GEPHAZ(X,5) FOR X = 0.01 0.01 5
    TITLE Generalized Pareto Hazard Function (Gamma = 0.5)
    PLOT GEPHAZ(X,0.5) FOR X = 0.01 0.01 5
    END OF MULTIPLOT
 
-----GEPPDF (LET)--------------------------------
 
GEPPDF
 
Name:
    GEPPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized Pareto probability density function with
    shape parameter GAMMA.
 
Description:
    The generalized Pareto distribution has the following probability
    density function for all positive x:

       f(x)=(1+gamma*x)**(-(1/gamma)-1)

    GAMMA can be any real number.  If GAMMA is 0, the probability
    density function is defined to be:

       f(x)=exp(-x)
 
    If GAMMA is negative, the domain of the function is 0 to
    -1/GAMMA.

    Note that the generalized Pareto is also commonly defined as
    (e.g., Johnson, Kotz, and Balakrsihnan):

       f(x)=(1-gamma*x)**((1/gamma)-1)

    That is, the sign of GAMMA is reversed.  In this case, the
    restricted domain applies to positive values of GAMMA.

    To specify this alternate definition, enter the command

       SET GENERALIZED PARETO DEFINITION  JOHNSON  (or KOTZ)

    To restore the default definition, enter the command

       SET GENERALIZED PARETO DEFINITION  SIMIU

Syntax:
    LET <y2> = GEPPDF(<y1>,GAMMA)   <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, number, or parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
              where the computed generalized Pareto pdf value is stored;
          <GAMMA> is a positive number or parameter that specifies the
              shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GEPPDF(3,2)
    LET A = GEPPDF(A1,4)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GEPCDF = Compute the generalized Pareto cumulative distribution
             function.
    GEPHAZ = Compute the generalized Pareto hazard function.
    GEPPPF = Compute the generalized Pareto percent point function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
    FCDF   = Compute the F cumulative distribution function.
    FPDF   = Compute the F probability density function.
    FPPF   = Compute the F percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    TCDF   = Compute the T cumulative distribution function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", Second Edition,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994, pp. 614-620.
 
Applications:
    Extreme Value Analysis
 
Implementation Date:
    1994/2
    2004/6: Support for alternative defintion.
 
Program:
    SEGMENT 1 COORDINATES 69 88 74 88; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 69 84 74 84; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 69 80 74 80; SEGMENT 3 PATTERN DOT
    SEGMENT 4 COORDINATES 69 76 74 76; SEGMENT 4 PATTERN DASH2
    LEGEND 1 GAMMA = 1; LEGEND 1 COORDINATES 75 87
    LEGEND 2 GAMMA = 2; LEGEND 2 COORDINATES 75 83
    LEGEND 3 GAMMA = 5; LEGEND 3 COORDINATES 75 79
    LEGEND 4 GAMMA = 0.5; LEGEND 4 COORDINATES 75 75
    TITLE PLOT GEPPDF FOR VARIOUS VALUES OF GAMMA
    LINES SOLID DASH DOT DASH2
    SET MINMAX 2
    PLOT GEPPDF(X,1) FOR X = 0.01 0.01 5 AND
    PLOT GEPPDF(X,2) FOR X = 0.01 0.01 5 AND
    PLOT GEPPDF(X,5) FOR X = 0.01 0.01 5 AND
    PLOT GEPPDF(X,0.5) FOR X = 0.01 0.01 5
 
-----GEPPPF (LET)--------------------------------
 
GEPPPF
 
Name:
    GEPPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized Pareto percent point function with shape
    parameter GAMMA.
 
Description:
    The generalized Pareto distribution for the maximum order statistic
    has the following probability density function for all positive x:
       f(x)=(1+gamma*x)**(-(1/gamma)-1)
    GAMMA can be any real number.  If GAMMA is 0, the probability
    density function is defined to be:
       f(x)=exp(-x)
    The percent point function is the inverse of the cumulative
    distribution function.  The cumulative distribution sums the
    probability from 0 to the given x value.  The percent point
    function takes a cumulative probability value and computes the
    corresponding x value.
 
Syntax:
    LET <y2> = GEPPPF(<y1>,GAMMA)    <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, number, or parameter containing values
              between 0 and 1;
          <y2> is a variable or a parameter (depending on what <y1> is)
              where the computed generalized Pareto ppf value is stored;
          <GAMMA> is a positive number or parameter that specifies the
              shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GEPPPF(0.9,2)
    LET A = GEPPPF(A1,8)
 
Note:
    The SET MINMAX command is used to specify whether the minimum order
    statistic or the maximumorder statistic form is used. Specifically,
    SET MINMAX 1 specifies the minimum order statistic while SET MINMAX
    2 specifies the maximum order statistic.  Currently, only the
    maximum order statistic form is supported.  However, the SET MINMAX
    command is still required.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GEPCDF = Compute the generalized Pareto cumulative distribution
             function.
    GEPPDF = Compute the generalized Pareto probability density
             function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPDF = Compute the chi-square probability density function.
    FCDF   = Compute the F cumulative distribution function.
    FPDF   = Compute the F probability density function.
    FPPF   = Compute the F percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    TCDF   = Compute the T cumulative distribution function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the generalized Pareto percent point function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994.
 
Applications:
    Extreme Value Analysis
 
Implementation Date:
    94/2
 
Program:
    SEGMENT 1 COORDINATES 16 88 21 88; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 16 84 21 84; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 16 80 21 80; SEGMENT 3 PATTERN DOT
    SEGMENT 4 COORDINATES 16 76 21 76; SEGMENT 4 PATTERN DASH2
    LEGEND 1 GAMMA = 1; LEGEND 1 COORDINATES 22 87
    LEGEND 2 GAMMA = 2; LEGEND 2 COORDINATES 22 83
    LEGEND 3 GAMMA = 5; LEGEND 3 COORDINATES 22 79
    LEGEND 4 GAMMA = 0.5; LEGEND 4 COORDINATES 22 75
    XLIMITS 0 1; XTIC DECIMAL 1
    MAJOR XTIC NUMBER 6; MINOR XTIC NUMBER 1
    LINES SOLID DASH DOT DASH2
    TITLE PLOT GEPPPF FOR VARIOUS VALUES OF GAMMA
    YLIMITS 0 10; MAJOR YTIC MARK NUMBER 6; YTIC OFFSET 0 0.3
    PLOT GEPPPF(X,1) FOR X = 0.01 .01 0.99 AND
    PLOT GEPPPF(X,2) FOR X = 0.01 .01 0.99 AND
    PLOT GEPPPF(X,5) FOR X = 0.01 .01 0.99 AND
    PLOT GEPPPF(X,0.5) FOR X = 0.01 .01 0.99
 
-----GETCDF (LET)--------------------------------
 
GETCDF
 
Name:
    GETCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Geeta cumulative distribution function.
 
Description:
    The Geeta distribution has the following probability
    mass function:

       p(x;theta,beta)=
           (beta*x-1  x)*theta**(x-1)*(1-theta)**(beta*x-x)/
           (beta*x-1)
           x = 1, 2, 3, ,...;  0 < theta < 1;  1 <= beta < 1/theta

    with theta and beta denoting the shape parameters.
 
    The Geeta distribution is sometimes parameterized in terms
    of its mean, mu, instead of theta.  This results in the
    following probability mass function:

        p(x;mu,beta)=
            (beta*x-1  x)*((mu-1)/(beta*mu-1))**(x-1)*
            (mu*(beta-1)/(beta*mu-1))**(beta*x-x)/(beta*x-1)
            x = 1, 2, 3, ,...
            mu >= 1; beta > 1

    For this parameterization, the variance is

        sigma**2 = mu*(mu-1)*(beta*mu-1)/(beta-1)

    This probability mass function is also given in the form:

        p(x;mu,beta)=
            (beta*x-1  x)*((mu-1)/(beta*mu-mu))**(x-1)*
            (mu*(beta-1)/(beta*mu-1))**(beta*x-1)/(beta*x-1)

    Dataplot supports both parameterizations (see the Note
    section below).

    The cumulative distribution function is computed by summing
    the probability mass function.

Syntax:
    LET <y> = GETCDF(<x>,<shape>,<beta>) 
               <SUBSET/EXCEPT/FOR qualification>
    where <x> is a positive integer variable, number, or parameter;
          <shape> is a number, parameter, or variable that specifies
               the valuie of theta (or mu);
          <beta> is a number, parameter, or variable that
               specifies the second shape parameter;
          <y> is a variable or a parameter (depending on what <x>
               is) where the computed Geeta cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GETCDF(3,0.5,1.4)
    LET Y = GETCDF(X,0.3,1.6)
    PLOT GETCDF(X,0.3,1.6) FOR X = 1  1  20

Note:
    To use the MU parameterization, enter the command

       SET GEETA DEFINITION MU

    To restore the THETA parameterization, enter the command

       SET GEETA DEFINITION THETA

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GETPDF                   = Compute the Geeta probability
                               mass function.
    GETPPF                   = Compute the Geeta percent point
                               function.
    CONPDF                   = Compute the Consul probability mass
                               function.
    GLSPDF                   = Compute the generalized logarithmic
                               series probability mass function.
    DLGPDF                   = Compute the logarithmic series
                               probability mass function.
    YULPDF                   = Compute the Yule probability
                               mass function.
    ZETPDF                   = Compute the Zeta probability
                               mass function.
    BGEPDF                   = Compute the beta geometric
                               probability mass function.
    POIPDF                   = Compute the Poisson probability
                               mass function.
    BINPDF                   = Compute the binomial probability
                               mass function.

Reference:
    Consul and Famoye (2006), "Lagrangian Probability
    Distribution", Birkhauser, chapter 8.

    Consul (1990), "Geeta Distribution and its Properties",
    Communications in Statistics--Theory and Methods, 19,
    pp. 3051-3068.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/8
 
Program:
    set geeta definition theta
    title size 3
    tic label size 3
    label size 3
    legend size 3
    height 3
    x1label displacement 12
    y1label displacement 15
    .
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    label case asis
    title case asis
    case asis
    tic offset units screen
    tic offset 3 3
    title displacement 2
    y1label Probability
    x1label X
    .
    ylimits 0 1
    major ytic mark number 6
    minor ytic mark number 3
    xlimits 0 20
    line blank
    spike on
    .
    multiplot 2 2
    .
    title Theta = 0.3, Beta = 1.8
    plot getcdf(x,0.3,1.8) for x = 1 1 20
    .
    title Theta = 0.5, Beta = 1.5
    plot getcdf(x,0.5,1.5) for x = 1 1 20
    .
    title Theta = 0.7, Beta = 1.2
    plot getcdf(x,0.7,1.2) for x = 1 1 20
    .
    title Theta = 0.9, Beta = 1.1
    plot getcdf(x,0.9,1.1) for x = 1 1 20
    .
    end of multiplot
    .
    justification center
    move 50 97
    text Cumulative Distributions for Geeta Distribution

-----GETPDF (LET)--------------------------------
 
GETPDF
 
Name:
    GETPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Geeta probability mass function.
 
Description:
    The Geeta distribution has the following probability
    mass function:

       p(x;theta,beta)=
           (beta*x-1  x)*theta**(x-1)*(1-theta)**(beta*x-x)/
           (beta*x-1)
           x = 1, 2, 3, ,...;  0 < theta < 1;  1 <= beta < 1/theta

    with theta and beta denoting the shape parameters.
 
    The mean and variance of the Geeta distribution are:

        mu       = (1-theta)/(1-theta*beta)
        sigma**2 = (beta-1)*theta*(1-theta)/(1-theta*beta)**3

    The Geeta distribution is sometimes parameterized in terms
    of its mean, mu, instead of theta.  This results in the
    following probability mass function:

        p(x;mu,beta)=
            (beta*x-1  x)*((mu-1)/(beta*mu-1))**(x-1)*
            (mu*(beta-1)/(beta*mu-1))**(beta*x-x)/(beta*x-1)
            x = 1, 2, 3, ,...
            mu >= 1; beta > 1

    For this parameterization, the variance is

        sigma**2 = mu*(mu-1)*(beta*mu-1)/(beta-1)

    This probability mass function is also given in the form:

        p(x;mu,beta)=
            (beta*x-1  x)*((mu-1)/(beta*mu-mu))**(x-1)*
            (mu*(beta-1)/(beta*mu-1))**(beta*x-1)/(beta*x-1)

    Dataplot supports both parameterizations (see the Note
    section below).

Syntax:
    LET <y> = GETPDF(<x>,<shape>,<beta>) 
               <SUBSET/EXCEPT/FOR qualification>
    where <x> is a positive integer variable, number, or parameter;
          <shape> is a number, parameter, or variable that specifies
               the valuie of theta (or mu);
          <beta> is a number, parameter, or variable that
               specifies the second shape parameter;
          <y> is a variable or a parameter (depending on what <x>
               is) where the computed Geeta pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GETPDF(3,0.5,1.4)
    LET Y = GETPDF(X,0.3,1.6)
    PLOT GETPDF(X,0.3,1.6) FOR X = 1  1  20

Note:
    For a number of commands utilizing the Geeta distribution,
    it is convenient to bin the data.  There are two basic ways
    of binning the data.

      1) For some commands (histograms, maximum likelihood
         estimation), bins with equal size widths are
         required.  This can be accomplished with the
         following commands:

            LET AMIN = MINIMUM Y
            LET AMAX = MAXIMUM Y
            LET AMIN2 = AMIN - 0.5
            LET AMAX2 = AMAX + 0.5
            CLASS MINIMUM AMIN2
            CLASS MAXIMUM AMAX2
            CLASS WIDTH 1
            LET Y2 X2 = BINNED

      2) For some commands, unequal width bins may be
         helpful.  In particular, for the chi-square goodness
         of fit, it is typically recommended that the minimum
         class frequency be at least 5.  In this case, it may
         be helpful to combine small frequencies in the tails.
         Unequal class width bins can be created with the
         commands

            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = INTEGER FREQUENCY TABLE Y

         If you already have equal width bins data, you can
         use the commands
         
            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = COMBINE FREQUENCY TABLE Y2 X2

         The MINSIZE parameter defines the minimum class
         frequency.  The default value is 5.

Note:
    To use the MU parameterization, enter the command

       SET GEETA DEFINITION MU

    To restore the THETA parameterization, enter the command

       SET GEETA DEFINITION THETA

Note:
    You can generate Geeta random numbers, probability plots,
    and chi-square goodness of fit tests with the following
    commands:

       LET N = VALUE
       LET THETA = <value>  (or LET MU = <value>)
       LET BETA = <value>
       LET Y = GEETA RANDOM NUMBERS FOR I = 1 1 N

       GEETA PROBABILITY PLOT Y
       GEETA PROBABILITY PLOT Y2 X2
       GEETA PROBABILITY PLOT Y3 XLOW XHIGH

       GEETA CHI-SQUARE GOODNESS OF FIT Y
       GEETA CHI-SQUARE GOODNESS OF FIT Y2 X2
       GEETA CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    To obtain the method of moment estimates, the mean and
    ones frequency estimates, and the maximum likelihood
    estimates of mu and beta, enter the command

        GEETA MAXIMUM LIKELIHOOD Y
        GEETA MAXIMUM LIKELIHOOD Y2 X2

    The moment estimates of mu and beta are:

        MUHAT = XBAR
        BETAHAT = (S**2 - XBAR*(XBAR-1))/(S**2 - XBAR**2*(XBAR-1))

    with XBAR and S**2 denoting the sample mean and sample
    variance, respectively.

    The mean and ones frequency estimate of mu is

        MUHAT = XBAR

    The estimate of beta is then the solution of the equation

        ((beta-1)*XBAR/(beta*XBAR-1))**(beta-1) - (N1/N) = 0

    with n1 and n denoting the ones frequency and sample size,
    respectively.

    The maximum likelihood estimate of mu is

        MUHAT = XBAR

    The estimate of beta is then the solution of the equation

        ((beta-1)*XBAR/(beta*XBAR-1))**(beta-1) - (1/(n*XBAR))*
        SUM[X=2 to k][SUM[i=2 to k][x*n(x)/(beta*x-1)]] = 0

    You can generate estimates of theta (or mu) and beta based
    on the maximum ppcc value or the minimum chi-square goodness
    of fit with the commands

        LET THETA1 = <value>
        LET THETA2 = <value>

    or
        LET MU1    = <value>
        LET MU2    = <value>

        LET BETA1  = <value>
        LET BETA2  = <value>
        GEETA KS PLOT Y
        GEETA KS PLOT Y2 X2
        GEETA KS PLOT Y3 XLOW XHIGH
        GEETA PPCC PLOT Y
        GEETA PPCC PLOT Y2 X2
        GEETA PPCC PLOT Y3 XLOW XHIGH

    The default values of theta1 and theta2 are 0.05 and 0.95,
    respectively.  The default values for mu1 and mu2 are 1 and 5,
    respectively.  The default values for beta1 and beta2 are
    1.05 and 5, respectively.  Note that when the theta
    parameterization is used, values of beta that do
    not lie in the interval 1 <= beta <= 1/theta are skipped.
    Due to the discrete nature of the percent point function
    for discrete distributions, the ppcc plot will not be smooth.
    For that reason, if there is sufficient sample size the
    KS PLOT (i.e., the minimum chi-square value) is typically
    preferred.  However, it may sometimes be useful to perform
    one iteration of the PPCC PLOT to obtain a rough idea of an
    appropriate neighborhood for the shape parameters since the
    minimum chi-square statistic can generate extremely large
    values for non-optimal values of the shape parameters.
    Also, since the data is integer values, one of the binned
    forms is preferred for these commands.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GETCDF                   = Compute the Geeta cumulative
                               distribution function.
    GETPPF                   = Compute the Geeta percent point
                               function.
    CONPDF                   = Compute the Consul probability mass
                               function.
    GLSPDF                   = Compute the generalized logarithmic
                               series probability mass function.
    DLGPDF                   = Compute the logarithmic series
                               probability mass function.
    YULPDF                   = Compute the Yule probability
                               mass function.
    ZETPDF                   = Compute the Zeta probability
                               mass function.
    BGEPDF                   = Compute the beta geometric
                               probability mass function.
    POIPDF                   = Compute the Poisson probability
                               mass function.
    BINPDF                   = Compute the binomial probability
                               mass function.
    INTEGER FREQUENCY TABLE  = Generate a frequency table at
                               integer values with unequal bins.
    COMBINE FREQUENCY TABLE  = Convert an equal width frequency
                               table to an unequal width frequency
                               table.
    KS PLOT                  = Generate a minimum chi-square plot.
    PPCC PLOT                = Generate a ppcc plot.
    PROBABILITY PLOT         = Generate a probability plot.
    MAXIMUM LIKELIHOOD       = Perform maximum likelihood
                               estimation for a distribution.
 
Reference:
    Consul and Famoye (2006), "Lagrangian Probability
    Distribution", Birkhauser, chapter 8.

    Consul (1990), "Geeta Distribution and its Properties",
    Communications in Statistics--Theory and Methods, 19,
    pp. 3051-3068.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/8
 
Program 1:
    set geeta definition theta
    title size 3
    tic label size 3
    label size 3
    legend size 3
    height 3
    x1label displacement 12
    y1label displacement 15
    .
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    label case asis
    title case asis
    case asis
    tic offset units screen
    tic offset 3 3
    title displacement 2
    y1label Probability Mass
    x1label X
    .
    ylimits 0 1
    major ytic mark number 6
    minor ytic mark number 3
    xlimits 0 20
    line blank
    spike on
    .
    multiplot 2 2
    .
    title Theta = 0.3, Beta = 1.8
    plot getpdf(x,0.3,1.8) for x = 1 1 20
    .
    title Theta = 0.5, Beta = 1.5
    plot getpdf(x,0.5,1.5) for x = 1 1 20
    .
    title Theta = 0.7, Beta = 1.2
    plot getpdf(x,0.7,1.2) for x = 1 1 20
    .
    title Theta = 0.9, Beta = 1.1
    plot getpdf(x,0.9,1.1) for x = 1 1 20
    .
    end of multiplot
    .
    justification center
    move 50 97
    text Probability Mass Functions for Generalized Logarithmic Series

Program 2:
    SET GEETA DEFINITION MU
    LET MU   = 4.2
    LET BETA = 2.2
    LET Y = GEETA RANDOM NUMBERS FOR I = 1 1 500
    .
    LET Y3 XLOW XHIGH = INTEGER FREQUENCY TABLE Y
    CLASS LOWER 0.5
    CLASS WIDTH 1
    LET AMAX = MAXIMUM Y
    LET AMAX2 = AMAX + 0.5
    CLASS UPPER AMAX2
    LET Y2 X2 = BINNED Y
    .
    GEETA MLE Y
    RELATIVE HISTOGRAM Y2 X2
    LIMITS FREEZE
    PRE-ERASE OFF
    LINE COLOR BLUE
    PLOT GETPDF(X,MUML,BETAML) FOR X = 1  1  AMAX
    LIMITS
    PRE-ERASE ON
    LINE COLOR BLACK
    LET MU    = MUML
    LET BETA  = BETAML
    GEETA CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH
    CASE ASIS
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Mu = ^MUML, Beta = ^BETAML
    MOVE 50 93
    TEXT Minimum Chi-Square = ^STATVAL, 95% CV = ^CUTUPP95
    .
    LABEL CASE ASIS
    X1LABEL Mu
    Y1LABEL Minimum Chi-Square
    GEETA KS PLOT Y3 XLOW XHIGH
    LET MU    = SHAPE1
    LET BETA  = SHAPE2
    GEETA CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Mu = ^MU, Beta = ^Beta
    MOVE 50 93
    TEXT Minimum Chi-Square = ^MINKS, 95% CV = ^CUTUPP95

-----GETPPF (LET)--------------------------------
 
GETPPF
 
Name:
    GETPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Geeta percent point function.
 
Description:
    The Geeta distribution has the following probability
    mass function:

       p(x;theta,beta)=
           (beta*x-1  x)*theta**(x-1)*(1-theta)**(beta*x-x)/
           (beta*x-1)
           x = 1, 2, 3, ,...;  0 < theta < 1;  1 <= beta < 1/theta

    with theta and beta denoting the shape parameters.
 
    The Geeta distribution is sometimes parameterized in terms
    of its mean, mu, instead of theta.  This results in the
    following probability mass function:

        p(x;mu,beta)=
            (beta*x-1  x)*((mu-1)/(beta*mu-1))**(x-1)*
            (mu*(beta-1)/(beta*mu-1))**(beta*x-x)/(beta*x-1)
            x = 1, 2, 3, ,...
            mu >= 1; beta > 1

    For this parameterization, the variance is

        sigma**2 = mu*(mu-1)*(beta*mu-1)/(beta-1)

    This probability mass function is also given in the form:

        p(x;mu,beta)=
            (beta*x-1  x)*((mu-1)/(beta*mu-mu))**(x-1)*
            (mu*(beta-1)/(beta*mu-1))**(beta*x-1)/(beta*x-1)

    Dataplot supports both parameterizations (see the Note
    section below).

    The cumulative distribution function is computed by summing
    the probability mass function.  The percent point function
    is computed by summing the cumulative distribution function
    until the appropriate probability is reached.

Syntax:
    LET <y> = GETPPF(<p>,<shape>,<beta>) 
               <SUBSET/EXCEPT/FOR qualification>
    where <p> is a positive integer variable, number, or parameter
               in the interval (0,1);
          <shape> is a number, parameter, or variable that specifies
               the value of theta (or mu);
          <beta> is a number, parameter, or variable that
               specifies the second shape parameter;
          <y> is a variable or a parameter (depending on what <p>
               is) where the computed Geeta ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GETPPF(0.95,0.5,1.4)
    LET Y = GETPPF(P,0.3,1.6)
    PLOT GETPPF(P,0.3,1.6) FOR P = 0  0.01  0.99

Note:
    To use the MU parameterization, enter the command

       SET GEETA DEFINITION MU

    To restore the THETA parameterization, enter the command

       SET GEETA DEFINITION THETA

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GETCDF                   = Compute the Geeta cumulative
                               distribution function.
    GETPDF                   = Compute the Geeta probability
                               mass function.
    CONPDF                   = Compute the Consul probability mass
                               function.
    GLSPDF                   = Compute the generalized logarithmic
                               series probability mass function.
    DLGPDF                   = Compute the logarithmic series
                               probability mass function.
    YULPDF                   = Compute the Yule probability
                               mass function.
    ZETPDF                   = Compute the Zeta probability
                               mass function.
    BGEPDF                   = Compute the beta geometric
                               probability mass function.
    POIPDF                   = Compute the Poisson probability
                               mass function.
    BINPDF                   = Compute the binomial probability
                               mass function.

Reference:
    Consul and Famoye (2006), "Lagrangian Probability
    Distribution", Birkhauser, chapter 8.

    Consul (1990), "Geeta Distribution and its Properties",
    Communications in Statistics--Theory and Methods, 19,
    pp. 3051-3068.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/8
 
Program:
    set geeta definition theta
    title size 3
    tic label size 3
    label size 3
    legend size 3
    height 3
    x1label displacement 12
    y1label displacement 15
    .
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    label case asis
    title case asis
    case asis
    tic offset units screen
    tic offset 3 3
    title displacement 2
    x1label Probability
    y1label X
    .
    xlimits 0 1
    major xtic mark number 6
    minor xtic mark number 3
    .
    multiplot 2 2
    .
    title Theta = 0.3, Beta = 1.8
    plot getppf(p,0.3,1.8) for p = 0  0.01  0.99
    .
    title Theta = 0.5, Beta = 1.5
    plot getppf(p,0.5,1.5) for p = 0  0.01  0.99
    .
    title Theta = 0.7, Beta = 1.2
    plot getppf(p,0.7,1.2) for p = 0  0.01  0.99
    .
    title Theta = 0.9, Beta = 1.1
    plot getppf(p,0.9,1.1) for p = 0  0.01  0.99
    .
    end of multiplot
    .
    justification center
    move 50 97
    text Percent Point Functions for Geeta

-----GEVCDF (LET)--------------------------------
 
GEVCDF
 
Name:
    GEVCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the generalized extreme value 
    cumulative distribution function.
 
Description:
    For positive gamma, the standard form of the generalized
    extreme value cumulative distribution is:
       F(x,gamma) = EXP{-[1 - gamma*x]**(1/gamma)}
                    -infinity < x < 1/gamma; gamma > 0
    For negative gamma, the standard form of the generalized
    extreme value cumulative distribution is:
       F(x,gamma) = EXP{-[1 - gamma*x]**(1/gamma)}
                    1/gamma < x < infinity; gamma < 0
    For gamma equal zero, the standard form of the generalized
    extreme value cumulative distribution is:
       F(x,gamma) = EXP{-EXP(x)}
                    -infinity < x < infinity; gamma=0
 
Syntax:
    LET <y> = GEVCDF(<x>,<gamma>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed generalized extreme value cdf value
               is saved;
          <gamma> is a number or parameter that specifies the shape
               parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GEVCDF(-3,1.5)
    LET X2 = GEVCDF(X1,GAMMA)
 
Note:
    For positive gamma, the general form of the generalized
    extreme value cumulative distribution is:
       F(x,gamma) = EXP{-[1 - gamma*((x-mu)/sigma)]**(1/gamma)}
              -infinity < x < mu + sigma/gamma; gamma > 0
    For negative gamma, the general form of the generalized
    extreme value cumulative distribution is:
       F(x,gamma) = EXP{-[1 - gamma*((x-mu)/sigma)]**(1/gamma)}
              mu + sigma/gamma < x < infinity; gamma < 0
    For gamma equal zero, the general form of the generalized
    extreme value cumulative distribution is:
       F(x,gamma) = EXP[-EXP((x-mu)/sigma)]
              -infinity < x < infinity; gamma = 0

    where u is a location parameter and sigma is a shape parameter.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GEVPDF = Compute the genralized extreme value probability
             density function.
    GEVPPF = Compute the genralized extreme value percent point
             function.
    EV2PDF = Compute the extreme value type II probability density
             function.
    EV1PDF = Compute the extreme value type I probability density
             function.
    WEIPDF = Compute the Weibull probability density function.
    EXPPDF = Compute the exponential probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 2", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994, (pp. 75-76).
 
Applications:
    Extreme Value Analysis
 
Implementation Date:
    1995/9
 
Program:
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LET GAMMA = DATA 0.0 0.5 -0.5 1.0 -1.0 2.0 -2.0 5.0 -5.0
    LET START = DATA -5 -4 -1.99 -3 -0.99 -3 -0.49 -3 -0.19
    LET STOP = DATA 5 1.99 4 0.99 3 0.49 3 0.19 3
    .
    LOOP FOR K = 1 1 9
       LET G = GAMMA(K)
       X1LABEL GAMMA = ^G
       LET A1 = START(K)
       LET A2 = STOP(K)
       PLOT GEVCDF(X,G) FOR X = A1 0.01 A2
    END OF LOOP
    END OF MULTIPLOT

-----GEVPDF (LET)--------------------------------
 
GEVPDF
 
Name:
    GEVPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the generalized extreme value 
    probability density function.
 
Description:
    For positive gamma, the standard form of the generalized
    extreme value probability density is:
       f(x,gamma) = EXP{-[1 - gamma*x]**(1/gamma)}*
                    [1-gamma*x]**(1/gamma-1)
                    -infinity < x < 1/gamma; gamma > 0
    For negative gamma, the standard form of the generalized
    extreme value probability density is:
       f(x,gamma) = EXP{-[1 - gamma*x]**(1/gamma)}*
                    [1-gamma*x]**(1/gamma-1)
                    1/gamma < x < infinity; gamma < 0
    For gamma equal zero, the standard form of the generalized
    extreme value probability density is:
       f(x,gamma) = EXP{-EXP[-x]*EXP[-x]}
                    -infinity < x < infinity; gamma=0
 
Syntax:
    LET <y> = GEVPDF(<x>,<gamma>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed generalized extreme value pdf value
               is saved;
          <gamma> is a number or parameter that specifies the shape
               parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GEVPDF(-3,1.5)
    LET X2 = GEVPDF(X1,GAMMA)
 
Note:
    For positive gamma, the general form of the generalized
    extreme value probability density is:
       f(x,gamma) = EXP{-[1 - gamma*((x-mu)/sigma)]**(1/gamma)}*
                    (1/sigma)*[1-gamma*((x-mu)/sigma)]**(1/gamma-1)
                    -infinity < x < mu + sigma/gamma; gamma > 0
    For negative gamma, the general form of the generalized
    extreme value probability density is:
       f(x,gamma) = EXP{-[1 - gamma*((x-mu)/sigma)]**(1/gamma)}*
                    (1/sigma)*[1-gamma*((x-mu)/sigma)]**(1/gamma-1)
                    mu + sigma/gamma < x < infinity; gamma < 0
    For gamma equal zero, the general form of the generalized
    extreme value probability density is:
       f(x,gamma) = EXP{-EXP[-((x-mu)/sigma)]*
                    (1/sigma)*EXP[-((x-mu)/sigma)]}
                    -infinity < x < infinity; gamma = 0

    where u is a location parameter and sigma is a shape parameter.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GEVCDF = Compute the genralized extreme value cumulative
             distribution function.
    GEVPPF = Compute the genralized extreme value percent point
             function.
    EV2PDF = Compute the extreme value type II probability density
             function.
    EV1PDF = Compute the extreme value type I probability density
             function.
    WEIPDF = Compute the Weibull probability density function.
    EXPPDF = Compute the exponential probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 2", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994, (pp. 75-76).
 
Applications:
    Extreme Value Analysis
 
Implementation Date:
    1995/9
 
Program:
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LET GAMMA = DATA 0.0 0.5 -0.5 1.0 -1.0 2.0 -2.0 5.0 -5.0
    LET START = DATA -5 -4 -1.99 -3 -0.99 -3 -0.49 -3 -0.19
    LET STOP = DATA 5 1.99 4 0.99 3 0.49 3 0.19 3
    .
    LOOP FOR K = 1 1 9
       LET G = GAMMA(K)
       X1LABEL GAMMA = ^G
       LET A1 = START(K)
       LET A2 = STOP(K)
       PLOT GEVPDF(X,G) FOR X = A1 0.01 A2
    END OF LOOP
    END OF MULTIPLOT

-----GEVPPF (LET)--------------------------------
 
GEVPPF
 
Name:
    GEVPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the generalized extreme value 
    percent point function.
 
Description:
    For non-zero gamma, the standard form of the generalized
    extreme value percent point function is:
       G(p,gamma) = [1 - LOG(p)**gamma]/gamma
    For gamma equal zero, the standard form of the generalized
    extreme value percent point is:
       G(p,gamma) = -LOG[LOG(1/p)]
 
Syntax:
    LET <y> = GEVPPF(<p>,<gamma>)  <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <p> is)
               where the computed generalized extreme value pdf value
               is saved;
          <gamma> is a number or parameter that specifies the shape
               parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GEVPPF(0.95,1.5)
    LET X2 = GEVPPF(P,GAMMA)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GEVCDF = Compute the genralized extreme value cumulative
             distribution function.
    GEVPDF = Compute the genralized extreme value probability
             density function.
    EV2PDF = Compute the extreme value type II probability density
             function.
    EV1PDF = Compute the extreme value type I probability density
             function.
    WEIPDF = Compute the Weibull probability density function.
    EXPPDF = Compute the exponential probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 2", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994, (pp. 75-76).
 
Applications:
    Extreme Value Analysis
 
Implementation Date:
    1995/9
 
Program:
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LET GAMMA = DATA 0.0 0.5 -0.5 1.0 -1.0 2.0 -2.0 5.0 -5.0
    LET START = DATA -5 -4 -1.99 -3 -0.99 -3 -0.49 -3 -0.19
    LET STOP = DATA 5 1.99 4 0.99 3 0.49 3 0.19 3
    .
    LOOP FOR K = 1 1 9
       LET G = GAMMA(K)
       X1LABEL GAMMA = ^G
       PLOT GEVPPF(P,G) FOR P = 0.01  0.01 0.95
    END OF LOOP
    END OF MULTIPLOT

-----GEXCDF (LET)--------------------------------
 
GEXCDF
 
Name:
    GEXCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized exponential cumulative distribution
    function.
 
Description:
    The generalized exponential distribution has the following
    probability density function:
       f(x,l1,l12,s) = (l1+l12*(1-EXP(-s*x)))*
              EXP[-l1*x-l12*x+(l12/s)*(1-EXP(-s*x))]     for x >= 0
    where l1, l12, and s are positive shape parameters.  The
    cumulative distribution has the formula:
       F(x,l1,l12,s) = 1 - 
              EXP[-l1*x-l12*x+(l12/s)*(1-EXP(-s*x))]     for x >= 0

 
    This distribution is the marginal distribution for a joint
    bivariate exponential distribution proposed in a paper by Ryu
    (see the Reference section below).

Syntax:
    LET <y> = GEXCDF(<x>,<l1>,<l12>,<s>)
                                   <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed generalized exponential pdf value is
               saved;
          <l1> is variable, a number, or a parameter that specifies
               the first shape parameter;
          <l12> is variable, a number, or a parameter that specifies
               the second shape parameter;
          <s> is variable, a number, or a parameter that specifies
               the third shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GEXCDF(3,0.5,2,1.5)
    LET X2 = GEXCDF(X1,LAM1,LAM12,SD)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GEXPDF = Compute the generalized exponential probability
             density function.
    GEXPPF = Compute the generalized exponential percent point
             function.
    EXPCDF = Compute the exponential cumulative distribution function.
    EXPPDF = Compute the exponential probability density function.
    EXPPPF = Compute the exponential percent point function.
    DEXCDF = Compute the double exponential cumulative distribution
             function.
    DEXPDF = Compute the double exponential probability density
             function.
    DEXPPF = Compute the double exponential percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
 
Reference:
    "An Extension of Marshall and Olkin's Bivariate Exponential
    Distribution", Ryu, Journal of the American Statistical
    Association, 1993, (pp. 1458-1465).

    "Continuous Univariate Distributions--Vol. I", 2nd. Ed., Johnson,
    Kotz, and Balakrishnan, John Wiley and Sons, 1994, (page 555).

Applications:
    Reliability
 
Implementation Date:
    96/2
 
Program:
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    X1LABEL X
    Y1LABEL PROBABILITY
    .
    PLOT GEXCDF(X,0.1,0.1,0.5) FOR X = 0 0.01 10
    PLOT GEXCDF(X,0.5,0.5,2) FOR X = 0 0.01 10
    PLOT GEXCDF(X,5,0.5,2) FOR X = 0 0.01 10
    PLOT GEXCDF(X,0.5,5,2) FOR X = 0 0.01 10
    END OF MULTIPLOT
 
-----GEXPDF (LET)--------------------------------
 
GEXPDF
 
Name:
    GEXPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized exponential probability density
    function.
 
Description:
    The generalized exponential distribution has the following
    probability density function:
       f(x,l1,l12,s) = (l1+l12*(1-EXP(-s*x)))*
              EXP[-l1*x-l12*x+(l12/s)*(1-EXP(-s*x))]     for x >= 0
    where l1, l12, and s are positive shape parameters.
 
    This distribution is the marginal distribution for a joint
    bivariate exponential distribution proposed in a paper by Ryu
    (see the Reference section below).

Syntax:
    LET <y> = GEXPDF(<x>,<l1>,<l12>,<s>)
                                   <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed generalized exponential pdf value is
               saved;
          <l1> is variable, a number, or a parameter that specifies
               the first shape parameter;
          <l12> is variable, a number, or a parameter that specifies
               the second shape parameter;
          <s> is variable, a number, or a parameter that specifies
               the third shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GEXPDF(3,0.5,2,1.5)
    LET X2 = GEXPDF(X1,LAM1,LAM12,SD)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GEXCDF = Compute the generalized exponential cumulative
             distribution function.
    GEXPPF = Compute the generalized exponential percent point
             function.
    EXPCDF = Compute the exponential cumulative distribution function.
    EXPPDF = Compute the exponential probability density function.
    EXPPPF = Compute the exponential percent point function.
    DEXCDF = Compute the double exponential cumulative distribution
             function.
    DEXPDF = Compute the double exponential probability density
             function.
    DEXPPF = Compute the double exponential percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
 
Reference:
    "An Extension of Marshall and Olkin's Bivariate Exponential
    Distribution", Ryu, Journal of the American Statistical
    Association, 1993, (pp. 1458-1465).

    "Continuous Univariate Distributions--Vol. I", 2nd. Ed., Johnson,
    Kotz, and Balakrishnan, John Wiley and Sons, 1994, (page 555).

Applications:
    Reliability
 
Implementation Date:
    96/2
 
Program:
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    X1LABEL X
    Y1LABEL PROBABILITY
    .
    PLOT GEXPDF(X,0.1,0.1,0.5) FOR X = 0 0.01 10
    PLOT GEXPDF(X,0.5,0.5,2) FOR X = 0 0.01 10
    PLOT GEXPDF(X,5,0.5,2) FOR X = 0 0.01 10
    PLOT GEXPDF(X,0.5,5,2) FOR X = 0 0.01 10
    END OF MULTIPLOT
 
-----GEXPPF (LET)--------------------------------
 
GEXPPF
 
Name:
    GEXPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized exponential percent point function.
 
Description:
    The generalized exponential distribution has the following
    probability density function:
       f(x,l1,l12,s) = (l1+l12*(1-EXP(-s*x)))*
              EXP[-l1*x-l12*x+(l12/s)*(1-EXP(-s*x))]     for x >= 0
    where l1, l12, and s are positive shape parameters.

    The percent point function is calculated numerically using a
    bisection method.
 
    This distribution is the marginal distribution for a joint
    bivariate exponential distribution proposed in a paper by Ryu
    (see the Reference section below).

Syntax:
    LET <y> = GEXPPF(<p>,<l1>,<l12>,<s>)
                                   <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, a number, or a parameter in the range
              (0,1);
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed generalized exponential ppf value is
               saved;
          <l1> is variable, a number, or a parameter that specifies
               the first shape parameter;
          <l12> is variable, a number, or a parameter that specifies
               the second shape parameter;
          <s> is variable, a number, or a parameter that specifies
               the third shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GEXPPF(0.95,0.5,2,1.5)
    LET X2 = GEXPPF(X1,LAM1,LAM12,SD)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GEXCDF = Compute the generalized exponential cumulative
             distribution function.
    GEXPDF = Compute the generalized exponential probability
             density function.
    EXPCDF = Compute the exponential cumulative distribution function.
    EXPPDF = Compute the exponential probability density function.
    EXPPPF = Compute the exponential percent point function.
    DEXCDF = Compute the double exponential cumulative distribution
             function.
    DEXPDF = Compute the double exponential probability density
             function.
    DEXPPF = Compute the double exponential percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
 
Reference:
    "An Extension of Marshall and Olkin's Bivariate Exponential
    Distribution", Ryu, Journal of the American Statistical
    Association, 1993, (pp. 1458-1465).

    "Continuous Univariate Distributions--Vol. I", 2nd. Ed., Johnson,
    Kotz, and Balakrishnan, John Wiley and Sons, 1994, (page 555).

Applications:
    Reliability
 
Implementation Date:
    96/2
 
Program:
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    Y1LABEL X
    X1LABEL PROBABILITY
    .
    PLOT GEXPPF(P,0.1,0.1,0.5) FOR P = 0 0.01 0.99
    PLOT GEXPPF(P,0.5,0.5,2) FOR P = 0 0.01 0.99
    PLOT GEXPPF(P,5,0.5,2) FOR P = 0 0.01 0.99
    PLOT GEXPPF(P,0.5,5,2) FOR P = 0 0.01 0.99
    END OF MULTIPLOT
 
-----GGDCDF (LET)--------------------------------
 
GGDCDF
 
Name:
    GGDCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the generalized gamma probability
    density function.
 
Description:
    The standard form of the generalized gamma distribution has the
    following probability density function:
       f(x,k,c) = c*x**(kc-1)*EXP(-x**c)/GAMMA(k)  x > 0, k > 0, c <>0
    where k and c are shape parameters and GAMMA is the complete gamma
    function.  The cumulative distribution is the area under under
    the curve from 0 to x (i.e., the integral of the above function.
    It has the formula:
       F(x,k,c) = GAMMAI(x**c,k)/GAMMA(k)
    where GAMMA is the complete gamma function and GAMMAI is the
    incomplete gamma function. 
 
Syntax:
    LET <y2> = GGDCDF(<y1>,<k>,<c>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a positive number, parameter, or a variable;
          <y2> is a variable or a parameter (depending on what <y1>
               is) where the computed generalized gamma cdf value is
               saved;
          <k> is a positive number, parameter, or variable that
               specifies the first shape parameter;
          <c> is a non-zero number, parameter, or variable that
               specifies the second shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GAMCDF(3,1.5.0.6)
    LET X2 = GAMCDF(X1,GAMMA,POWER)
 
Note:
    If c is 1, this distribution reduces to the standard gamma
    distribution.  If k is 1, this distribution reduces to a Weibull
    distribution.  If k =1/2 and c = 2, it reduces to a half-normal
    distribution.  Several other common distributions are special
    cases of the generalized gamma distribution.
 
    The second shape parameter can be negative (but not zero).
    Specifically, if c = -1, the generalized gamma is the inverted
    gamma distribution.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GGDPDF = Compute the generalized gamma probability density
             function.
    GGDPPF = Compute the generalized gamma percent point function.
    GAMCDF = Compute the gamma cumulative distribution function.
    GAMPDF = Compute the gamma probability density function.
    GAMPPF = Compute the gamma percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    EXPCDF = Compute the exponential cumulative distribution function.
    EXPPDF = Compute the exponential probability density function.
    EXPPPF = Compute the exponential percent point function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
 
Reference:
    "Continuous Univariate Distributions", 2nd. ed., Johnson, Kotz, 
    and Balakrishnan, John Wiley and Sons, 1994 (chapter 17).
 
    "Statistical Distributions", 2nd. Edition, Evans, Hastings, and
    Peacock, Wiley and Sons, 1993 (chapter 18).

Applications:
    XX
 
Implementation Date:
    95/5
 
Program:
    LET G = DATA 1 1 1 0.5 0.5 0.5 2 2 2
    LET C = DATA 0.5 1 2 0.5 1 2 0.5 1 2
    LET START = DATA 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01
    LET INC = DATA 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01
    LET STOP = DATA 5 5 5 5 5 5 5 5 5
    .
    MULTIPLOT 3 3; MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LOOP FOR K = 1 1 9
       LET G1 = G(K)
       LET C1 = C(K)
       LET FIRST = START(K)
       LET LAST = STOP(K)
       LET INCT = INC(K)
       X1LABEL GAMMA = ^G1
       X2LABEL C = ^C1
       PLOT GGDCDF(X,G1,C1) FOR X = FIRST INCT LAST
    END OF LOOP
    END OF MULTIPLOT
 
-----GGDCHAZ (LET)--------------------------------
 
GGDCHAZ
 
Name:
    GGDCHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the generalized gamma cumulative
    hazard function.
 
Description:
    The standard form of the generalized gamma distribution has the
    following cumulative hazard function:
       H(x,k,c) =-LOG[1 - GGDCDF(x,k,c))  x, k > 0,  c <> 0
    where k and c are shape parameters and GGDCDF is the cumulative
    distribution function of the generalized gamma distribution.
 
Syntax:
    LET <y> = GGDCHAZ(<x>,<k>,<c>)   <SUBSET/EXCEPT/FOR qualification>
    where <x> is a positive number, parameter, or a variable;
          <y> is a variable or a parameter (depending on what <x>
              is) where the computed generalized gamma cumulative
              hazard value is saved;
          <k> is a positive number, parameter, or variable that
              specifies the first shape parameter;
          <c> is a non-zero number, parameter, or variable that
              specifies the second shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GGDCHAZ(3,1.5.0.6)
    LET X2 = GGDCHAZ(X1,GAMMA,POWER)
 
Note:
    If c is 1, this distribution reduces to the standard gamma
    distribution.  If k is 1, this distribution reduces to a Weibull
    distribution.  If k =1/2 and c = 2, it reduces to a half-normal
    distribution.  Several other common distributions are special
    cases of the generalized gamma distribution.
 
    The second shape parameter can be negative (but not zero).
    Specifically, if c = -1, the generalized gamma is the inverted
    gamma distribution.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GGDCDF  = Compute the generalized gamma cumulative distribution
              function.
    GGDPDF  = Compute the generalized gamma probability density
              function.
    GGDPPF  = Compute the generalized gamma percent point function.
    GGDHAZ  = Compute the generalized gamma hazard function.
    GAMPDF  = Compute the gamma probability density function.
    IGAPDF  = Compute the inverted gamma probability density function.
    WEIPDF  = Compute the Weibull probability density function.
    EXPPDF  = Compute the exponential probability density function.
    CHSPDF  = Compute the chi-square probability density function.
 
Reference:
    "Continuous Univariate Distributions", 2nd. ed., Johnson, Kotz, 
    and Balakrishnan, John Wiley and Sons, 1994 (chapter 17).
 
    "Statistical Distributions", 2nd. Edition, Evans, Hastings, and
    Peacock, Wiley and Sons, 1993 (chapter 18).

Applications:
    Reliability
 
Implementation Date:
    98/4
 
Program:
    LET G = DATA 1 1 1 0.5 0.5 0.5 2 2 2
    LET C = DATA 0.5 1 2 0.5 1 2 0.5 1 2
    LET START = DATA 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01
    LET INC = DATA 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01
    LET STOP = DATA 5 5 5 5 5 5 5 5 5
    .
    MULTIPLOT 3 3; MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LOOP FOR K = 1 1 9
       LET G1 = G(K)
       LET C1 = C(K)
       LET FIRST = START(K)
       LET LAST = STOP(K)
       LET INCT = INC(K)
       X1LABEL GAMMA = ^G1
       X2LABEL C = ^C1
       PLOT GGDCHAZ(X,G1,C1) FOR X = FIRST INCT LAST
    END OF LOOP
    END OF MULTIPLOT
 
-----GGDHAZ (LET)--------------------------------
 
GGDHAZ
 
Name:
    GGDHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the generalized gamma hazard
    function.
 
Description:
    The standard form of the generalized gamma distribution has the
    following hazard function:
       h(x,k,c) =GGDPDF(x,k,c)/(1 - GGDCDF(x,k,c))  x, k > 0,  c <> 0
    where k and c are shape parameters and GGDPDF and GGDCDF are the
    probability density and cumulative distribution functions of
    the generalized gamma distribution.
 
Syntax:
    LET <y> = GGDHAZ(<x>,<k>,<c>)   <SUBSET/EXCEPT/FOR qualification>
    where <x> is a positive number, parameter, or a variable;
          <y> is a variable or a parameter (depending on what <x>
              is) where the computed generalized gamma hazard
              value is saved;
          <k> is a positive number, parameter, or variable that
              specifies the first shape parameter;
          <c> is a non-zero number, parameter, or variable that
              specifies the second shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GGDHAZ(3,1.5.0.6)
    LET X2 = GGDHAZ(X1,GAMMA,POWER)
 
Note:
    If c is 1, this distribution reduces to the standard gamma
    distribution.  If k is 1, this distribution reduces to a Weibull
    distribution.  If k =1/2 and c = 2, it reduces to a half-normal
    distribution.  Several other common distributions are special
    cases of the generalized gamma distribution.
 
    The second shape parameter can be negative (but not zero).
    Specifically, if c = -1, the generalized gamma is the inverted
    gamma distribution.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GGDCDF  = Compute the generalized gamma cumulative distribution
              function.
    GGDPDF  = Compute the generalized gamma probability density
              function.
    GGDPPF  = Compute the generalized gamma percent point function.
    GGDCHAZ = Compute the generalized gamma cumulative hazard
              function.
    GAMPDF  = Compute the gamma probability density function.
    IGAPDF  = Compute the inverted gamma probability density function.
    WEIPDF  = Compute the Weibull probability density function.
    EXPPDF  = Compute the exponential probability density function.
    CHSPDF  = Compute the chi-square probability density function.
 
Reference:
    "Continuous Univariate Distributions", 2nd. ed., Johnson, Kotz, 
    and Balakrishnan, John Wiley and Sons, 1994 (chapter 17).
 
    "Statistical Distributions", 2nd. Edition, Evans, Hastings, and
    Peacock, Wiley and Sons, 1993 (chapter 18).

Applications:
    Reliability
 
Implementation Date:
    98/4
 
Program:
    LET G = DATA 1 1 1 0.5 0.5 0.5 2 2 2
    LET C = DATA 0.5 1 2 0.5 1 2 0.5 1 2
    LET START = DATA 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01
    LET INC = DATA 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01
    LET STOP = DATA 5 5 5 5 5 5 5 5 5
    .
    MULTIPLOT 3 3; MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LOOP FOR K = 1 1 9
       LET G1 = G(K)
       LET C1 = C(K)
       LET FIRST = START(K)
       LET LAST = STOP(K)
       LET INCT = INC(K)
       X1LABEL GAMMA = ^G1
       X2LABEL C = ^C1
       PLOT GGDHAZ(X,G1,C1) FOR X = FIRST INCT LAST
    END OF LOOP
    END OF MULTIPLOT
 
-----GGDPDF (LET)--------------------------------
 
GGDPDF
 
Name:
    GGDPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the generalized gamma probability
    density function.
 
Description:
    The standard form of the generalized gamma distribution has the
    following probability density function:
       f(x,k,c) = c*x**(kc-1)*EXP(-x**c)/GAMMA(k)  x > 0, k > 0, c <>0
    where k and c are shape parameters and GAMMA is the complete gamma
    function.
 
Syntax:
    LET <y2> = GGDPDF(<y1>,<k>,<c>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a positive number, parameter, or a variable;
          <y2> is a variable or a parameter (depending on what <y1>
               is) where the computed generalized gamma pdf value is
               saved;
          <k> is a positive number, parameter, or variable that
               specifies the first shape parameter;
          <c> is a non-zero number, parameter, or variable that
               specifies the second shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GGDPDF(3,1.5.0.6)
    LET X2 = GGDPDF(X1,GAMMA,POWER)
 
Note:
    If c is 1, this distribution reduces to the standard gamma
    distribution.  If k is 1, this distribution reduces to a Weibull
    distribution.  If k =1/2 and c = 2, it reduces to a half-normal
    distribution.  Several other common distributions are special
    cases of the generalized gamma distribution.
 
    The second shape parameter can be negative (but not zero).
    Specifically, if c = -1, the generalized gamma is the inverted
    gamma distribution.

Note:
    The general form of the generalized gamma distribution is:
       f(x,k,c,a,b) = c*(x-a)**(kc-1)*EXP(-((x-a)/b)**c)/[b**(k*c)*
                      GAMMA(k)]     x > 0, k > 0, c <>0, a > 0, b > 0
    The parameter a is a location parameter and the parameter b is a
    scale parameter.  The pdf values for the general generalized
    gamma distributions can be computed by doing something like the
    following:
        LET A = <value>
        LET B = <value>
        PLOT (1/B)*GGDPDF((X-A)/B)     FOR X = A .1 10
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GGDCDF = Compute the generalized gamma cumulative distribution
             function.
    GGDPPF = Compute the generalized gamma percent point function.
    GAMCDF = Compute the gamma cumulative distribution function.
    GAMPDF = Compute the gamma probability density function.
    GAMPPF = Compute the gamma percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    EXPCDF = Compute the exponential cumulative distribution function.
    EXPPDF = Compute the exponential probability density function.
    EXPPPF = Compute the exponential percent point function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
 
Reference:
    "Continuous Univariate Distributions", 2nd. ed., Johnson, Kotz, 
    and Balakrishnan, John Wiley and Sons, 1994 (chapter 17).
 
    "Statistical Distributions", 2nd. Edition, Evans, Hastings, and
    Peacock, Wiley and Sons, 1993 (chapter 18).

Applications:
    Distributional Modeling
 
Implementation Date:
    1995/5
 
Program:
    LET G = DATA 1 1 1 0.5 0.5 0.5 2 2 2
    LET C = DATA 0.5 1 2 0.5 1 2 0.5 1 2
    LET START = DATA 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01
    LET INC = DATA 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01
    LET STOP = DATA 5 5 5 5 5 5 5 5 5
    .
    MULTIPLOT 3 3; MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LOOP FOR K = 1 1 9
       LET G1 = G(K)
       LET C1 = C(K)
       LET FIRST = START(K)
       LET LAST = STOP(K)
       LET INCT = INC(K)
       X1LABEL GAMMA = ^G1
       X2LABEL C = ^C1
       PLOT GGDPDF(X,G1,C1) FOR X = FIRST INCT LAST
    END OF LOOP
    END OF MULTIPLOT
 
-----GGDPPF (LET)--------------------------------
 
GGDPPF
 
Name:
    GGDPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the generalized gamma percent point
    function.
 
Description:
    The standard form of the generalized gamma distribution has the
    following probability density function:
       f(x,k,c) = c*x**(kc-1)*EXP(-x**c)/GAMMA(k)  x > 0, k > 0, c <>0
    where k and c are shape parameters and GAMMA is the complete gamma
    function.
 
    The percent point function is the inverse of the cumulative
    distribution function.  The cumulative distribution sums the
    probability from 0 to the given x value (i.e., the integral of the
    above function).  The percent point function takes a cumulative
    probability value and computes the corresponding x value.
 
    The input value is a real number between 0 and 1 (since it
    corresponds to a probability).
 
Syntax:
    LET <y2> = GGDPPF(<y1>,<k>,<c>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a number, a parameter, or a variable in the range
               0 to 1;
          <y2> is a variable or a parameter (depending on what <y1>
               is) where the computed generalized gamma ppf value is
               saved;
          <k> is a positive number, parameter, or variable that
               specifies the first shape parameter;
          <c> is a non-zero number, parameter, or variable that
               specifies the second shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GGDPPF(0.9,2,3))
    LET X2 = GGDPPF(X1,K,C)
Note:
    If c is 1, this distribution reduces to the standard gamma
    distribution.  If k is 1, this distribution reduces to a Weibull
    distribution.  If k =1/2 and c = 2, it reduces to a half-normal
    distribution.  Several other common distributions are special
    cases of the generalized gamma distribution.
 
    The second shape parameter can be negative (but not zero).
    Specifically, if c = -1, the generalized gamma is the inverted
    gamma distribution.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GGDCDF = Compute the generalized gamma cumulative distribution
             function.
    GGDPPF = Compute the generalized gamma percent point function.
    GAMCDF = Compute the gamma cumulative distribution function.
    GAMPDF = Compute the gamma probability density function.
    GAMPPF = Compute the gamma percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    EXPCDF = Compute the exponential cumulative distribution function.
    EXPPDF = Compute the exponential probability density function.
    EXPPPF = Compute the exponential percent point function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
 
Reference:
    "Continuous Univariate Distributions", 2nd. ed., Johnson, Kotz, 
    and Balakrishnan, John Wiley and Sons, 1994 (chapter 17).
 
    "Statistical Distributions", 2nd. Edition, Evans, Hastings, and
    Peacock, Wiley and Sons, 1993 (chapter 18).

Applications:
    XX
 
Implementation Date:
    95/5
 
Program:
    LET G = DATA 1 1 1 0.5 0.5 0.5 2 2 2
    LET C = DATA 0.5 1 2 0.5 1 2 0.5 1 2
    LET START = DATA 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01
    LET INC = DATA 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01 0.01
    LET STOP = DATA 5 5 5 5 5 5 5 5 5
    .
    MULTIPLOT 3 3; MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    XLIMITS 0 1
    MAJOR XTIC NUMBER 6
    MINOR XTIC NUMBER 1
    XTIC DECIMAL 1
    Y1LABEL X
    X1LABEL PROBABILITY
    LOOP FOR K = 1 1 9
       LET G1 = G(K)
       LET C1 = C(K)
       X1LABEL GAMMA = ^G1
       X2LABEL C = ^C1
       PLOT GGDPPF(P,G1,C1) FOR P = 0.01 0.01 0.99
    END OF LOOP
    END OF MULTIPLOT
 
-----GHCDF (LET)--------------------------------
 
GHCDF
 
Name:
    GHCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the g-and-h cumulative distribution function.
 
Description:
    The g-and-h distribution is defined in terms of its percent point
    function:

       G(p,g,h) = (EXP(g*Zp) - 1)*EXP(h*Zp**2/2)/g

    with Zp denoting the normal percent point function of p.
    When g = 0 and h = 0, the g-and-h distribution reduces to
    a standard normal distribution.

    The g-and-h cumulative distribution is computed by numerically
    inverting the percent point function using a bisection
    method.

    The value of g controls the degree of skewness.  For g = 0,
    the distribution is symmetric.  As the absolute value of
    g increases, the amount of the skewness increases.  The
    sign of g controls the direction of the skewness (but not
    the amount).  Positive values of g skew the distribution
    to the right tail while negative values of g skew the
    distribution to the left tail.  Values for g are typically
    in the range (-1,1).

    The value of h controls the elongation, or how heavy the
    tails are, of the distribution.  For h = 0, the elongation
    is equivalent to that of a normal distribution.  For h = 1,
    the elongation is equivalent to that of a Cauchy distribution.
    Values of h are typically in the range (0,1).

    Specifying values for both g and h gives this distribution
    great flexibility in modeling data.

    The g-and-h distribution can be generalized with scale parameters
    in the usual way.

Syntax:
    LET <y> = GHCDF(<x>,<g>,<h>,<loc>,scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter;
          <g> is a number or parameter that specifies the skewness
               shape parameter;
          <h> is a number or parameter that specifies the elongation
               shape parameter;
          <loc> is a number or parameter that specifies the location
               parameter;
          <scale> is a number or parameter that specifies the scale
               parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed g-and-h cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    Note that the location and scale parameters are optional.

Examples:
    LET A = GHCDF(0.9,0.5,0.2)
    LET Y = GHCDF(X,0.5,0.2)
    PLOT GHCDF(X,0.5,0.2) FOR X = -5 0.1 5
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GHPDF  = Compute the g-and-h probability density function.
    GHPPF  = Compute the g-and-h percent point function.
    LAMPDF = Compute the Tukey-Lambda probability density function.
    NORPDF = Compute the standard normal probability density function.
    LOGPDF = Compute the logistic probability density function.
    JSUPDF = Compute the Johnson SU probability density function.
 
Reference:
    "Summarizing Shape Numerically: The g-and-h Distributions",
    David C. Hoaglin, chapter 11 in "Exploring Data Tables, Trends,
    and Shapes", Eds. Hoaglin, Mosteller, and Tukey, Wiley, 1985.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2004/5
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT SCALE FACTOR 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    Y1LABEL X
    X1LABEL PROBABILITY
    X1LABEL DISPLACEMENT 12
    Y1LABEL DISPLACEMENT 12
    TITLE G = 0.2, H = 0.2
    PLOT GHCDF(X,0.5,0.5) FOR X = -10  0.1  10
    TITLE G = 0.5, H = 0.2
    PLOT GHCDF(X,0.5,0.2) FOR X = -10  0.1  10
    TITLE G = 0.2, H = 0.5
    PLOT GHCDF(X,0.2,0.5) FOR X = -10  0.1  10
    TITLE G = 0.5, H = 0.5
    PLOT GHCDF(X,0.5,0.5) FOR X = -10  0.1  10
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT G-AND-H DISTRIBUTIONS
 
-----GHOSTSCRIPT PATH (SET)---------------------------------------
 
GHOSTSCRIPT PATH
 
Name:
    GHOSTSCRIPT PATH (SET)
 
Type:
    Set Subcommand
 
Purpose:
    Specify the path to the Ghostscript command on your local platform.
 
Description:
    Ghostscript/Ghostview can be used externally from Dataplot to
    view Dataplot generated Postscript files.  It can also be used
    to print these Postscript files on non-Postscript devices.

    Dataplot uses Ghostscript internally in the following two contexts:

    1) The CAPTURE HTML command is used to generate the Dataplot
       output in HTML format.  If device 2 is set to Postscript,
       Dataplot will run Ghostscript to convert the Postscript graph
       to JPEG format.  Dataplot will insert an <IMG> tag in the
       HTML file to the JPEG file.

    2) The SET POSTSCRIPT CONVERT command is used to specify either
       JPEG, PDF (Portable Document Format), TIFF, PBM, PGM, PPM, or
       PNM.  If one of these devices is set and a Postscript device
       is closed, then Dataplot invokes Ghostscript to convert the
       Postscript output to the specified device.  The original
       Postscript file is preserved.  The new file has the same
       name with the file extension replaced with "jpg", "pdf",
       "tif", "pbm", "pgm", "ppm", or "pnm".

       The purpose of this command is to automatically generate
       output in a format suitable for importing into an external
       program (e.g., Word, Power Point, Photoshop, Gimp).
       Although most programs will import Postscript, this capability
       provides a number of options that should cover most programs.

    These two capabilities assumes that Ghostscript is installed on
    your local system.  Currently, these commands have been implemented
    on Unix (this includes Linux, Mac OSX, and FreeBSD) and Windows
    platforms.  It can easily be extended to any platform (e.g.,
    VAX VMS) to which Ghostscript has been ported.

    For Unix platforms, Ghostscript is launched with a "gs" command.
    On Windows platforms, Ghostscript is launched with
    "C:\GS\GS704\GS\BIN\GSWIN32C.EXE".

    If these default paths are not correct for your local
    platform, then you can enter the following command:

        SET GHOSTSCRIPT PATH  <path-name>

    where <path-name> is the path to the directory that contains
    the Ghostscript executable.  For example, on my Windows system,
    I use

        SET GHOSTSCRIPT PATH F:\GS\GS704\GS\BIN\

    Note that the Ghostscript command itself is not included.  The
    ending "\" is optional (Dataplot will automatically add it if
    it is omitted).

    If you need this command, we suggest adding it to your Dataplot
    startup file "dplogf.tex".

Syntax:
    SET GHOSTSCRIPT PATH <path>
    where <path> identifies the directory containing the Ghostscript
    executable file.
 
Examples:
    SET GHOSTSCRIPT PATH D:\GS\GS7.04\BIN\
    SET GHOSTSCRIPT PATH C:\GS\GS8.0\BIN\
 
Note:
    Note that the default path assumes that you are running version
    7.04 on Windows.  Ghostscript just recently released version
    8.0.  For Dataplot purposes, any version starting with 6.51
    should suffice.  If you have an earlier version, then you need
    to upgrade to a more current version.

Default:
    The default is "C:\GS\GS7.04\BIN\" on Windows.  For Unix, no
    path is assumed (i.e., it is assumed that Ghostscript is in
    your default path).
 
Synonyms:
    None
 
Related Commands:
    DEVICE xx POSTSCRIPT      = Set the device to Postscript.
    POSTSCRIPT CONVERT        = Specify the device that Postscript
                                output will be converted to.
    PP                        = Print the current plot.
    SET GHOSTVIEW PATH        = Set the directory where Ghostview (and
                                GSPRINT) is installed.
    SET GHOSTSCRIPT PRINTER   = Use Ghostview as the default printer
                                under Windows.
 
Applications:
    Graphics Output
 
Implementation Date:
    2003/1
 
Program:
    SET GHOSTSCRIPT PATH /usr/local/src/bin/
    SET POSTSCRIPT CONVERT JPEG
    DEVICE 2 POSTSCRIPT
    PLOT SIN(X) FOR X = -6 0.1 6
    DEVICE 2 CLOSE
    SYSTEM xv dppl1f.jpg
 
-----GHOSTSCRIPT PRINTER (SET)---------------------------------------
 
GHOSTSCRIPT PRINTER
 
Name:
    GHOSTSCRIPT PRINTER (SET)
 
Type:
    Set Subcommand
 
Purpose:
    Specify whether the Ghostview/Ghostscript GSPRINT command is
    used to implement the PP command.
 
Description:
    Under Windows, printing Dataplot graphs has been a bit of an
    issue.  Dataplot supports Postscript printers and printers
    that provide HPGL emulation (i.e., most HP LaserJet printers)
    directly.  However, there is no built-in support for the
    various ink jet and desk jet printers.  The recommended
    solution has been to install the freely downloadable
    Ghostview/Ghostscript software and use this to print Dataplot
    generated Postscript files on non-Postscript printers.  The
    limitations of this approach were that the PP command (which
    prints the most recent graph from within a Dataplot session) was
    not available and you had to run a separate program to print your
    graphs.

    Ghostview also provides the command "GSPRINT" that will
    run ghostscript automatically to print a Postscript file
    on a generic Windows printer.  The use of GSPRINT allows the PP
    command to work with any generic Windows printer.

    In order to make use of GSPRINT, We have added the following
    command to Dataplot:

       SET GHOSTSCRIPT PRINTER <ON/OFF>

    If set to OFF (the default), then the Dataplot PP command
    will execute the following command:

       COPY DPPL2F.DAT  <printer-id>

    If set to ON, then the Dataplot PP command will execute the
    following command:
 
    C:\Ghostgum\Ghostview\GSPRINT.EXE -printer "printer-id" DPPL2F.DAT
 
    If you want the PP command to print to either a Postscript
    printer or a printer with HP-GL emulation, then it is
    recommended that you leave this switch set to OFF.  For all
    other printers, we recommend you set this switch to ON.

    If you set this to ON, then use DEVICE 2 POSTSCRIPT as the
    device for DPPL1F.DAT (DEVICE 3, used for DPPL2F.DAT, defaults
    to Postscript).  If you want to print the DPPL1F.DAT file (which
    will contain all plots generated since the DEVICE 2 command),
    then you can do something like the following:

        DEVICE 2 POSTSCRIPT
          ...  generate one or more plots ...
        DEVICE 2 CLOSE
        SYSTEM  C:\Ghostgum\Ghostview\GSPRINT.EXE  DPPL1F.DAT

    There are three issues that you need to be aware of.

    1) Entering SET GHOSTSCRIPT PRINTER ON assumes that you have
       installed Ghostview/Ghostscript on your local machine.  The
       version of Ghostscript must be at least 6.5 (which is fairly
       old by now).  Note that we include a copy of Ghostview/Ghostscript
       on the Dataplot CD and on the Dataplot ftp site.  You can also
       download it from the Ghostview site:
 
           http://www.cs.wisc.edu/~ghost/
 
    2) If you did not install Ghostview in the default directory
       (C:\Ghostgum\GhostView), then you can specify the directory
       containing the Ghostview program (and the GSPRINT program) with
       the following command:
 
           SET GHOSTVIEW PATH  <path-name>
 
       For example, if you installed Ghostview on the D: drive, enter
       the following:
 
           SET GHOSTVIEW PATH D:\Ghostgum\Ghostview\

    3) By default, GSPRINT will send the plot to the default printer.
       If you want to use a printer that is not your default printer,
       you can do one of the following:

       a) Use the Windows "Printers" menu (under the Programs/Settings
          menu or under the Control Panel menu) to temporarily redefine
          which printer is the default printer.

       b) You can use the Dataplot SET PRINTER command to define the
          name of the printer.

         The names for network printers are site specific.  Talk to your
         local site administrators to determine the names for your
         network printers (I cannot help you with this part).

         One recommendation is to run GSPRINT independently of Dataplot
         to test the correct names for the network printers you need
         to support.  As these network names can be rather long and
         hard to remember, if you commonly use more than one printer, you
         can write a macro for each printer that sets the appropriate
         name for that printer.  That is, instead of entering the
         SET PRITNER command each time, simply call the appropriate
         macro (that way, you only have to get the name right once).

         Be aware that GSPRINT can be picky about how the printer name
         is entered.

Syntax:
    SET GHOSTSCRIPT PRINTER <ON/OFF>
    where ON specifies that GSPRINT will be used and OFF specifies
    that GSPRINT will not be used.
 
Examples:
    SET GHOSTSCRIPT PRINTER ON
    SET GHOSTSCRIPT PRINTER OFF
 
Note:
    I recommend adding the following code to your C:\DATAPLOT\DPLOGF.TEX
    file (this is a startup file that is run when Dataplot is first
    initiated.  Change the network printer id's to ones that are
    appropriate for your local site.

    .  FOR DEVICE 2 AND DEVICE 3 (file devices), THERE ARE 3 CASES:
    .
    .    i) You want to access a Postscript printer
    .   ii) You want to access a printer with HP-GL emulation
    .       (e.g., most HP LaserJet printers)
    .  iii) You want to access a generic printer that has neither
    .       Postscript or HPGL capability.
    .
    .       Set IDEV to 1, 2, or 3 based on the above.  Also, you may
    .       need to define the name of your network printer (the actual
    .       name will need to be obtained from your local site
    .       system administrator).
    .
    IDEV = 3
    .
    IF IDEV = 1
       . Postscript Case.  Set printer to PRN: for a local printer, to
       . the appropriate network id for a network printer.
       . SET PRINTER PRN:
       SET PRINTER "\\DCIS-NT3\HP8_PS"
       DEVICE 2 POSTSCRIPT
    ELSE IF IDEV = 2
       . HP-GL Case.  Set printer to PRN: for a local printer, to
       . the appropriate network id for a network printer.
       . SET PRINTER PRN:
       SET PRINTER "\\DCIS-NT3\HP8"
       DEVICE 2 HPGL LJET
    ELSE
      . Generic printer case.  Use the Ghostscript/Ghostview "GSPRINT" command.
      . This assumes that Ghostscript (at least version 6.5) and Ghostview have
      . been installed.  If the path for Ghostview is not "C:\Ghostgum\Gsview",
      . Then set the correct path with the "SET GHOSTVIEW PATH" command.
      . If you do not want to access your default printer, then use the
      . SET PRINTER command to specify the printer id.
      .  SET PRINTER "\\DCIS-NT3\HP8 - HP 8000 Series PCL 5e"
      .  SET PRINTER "\\DCIS-NT3\HP8_PS - HP LaserJet 8000 Series PS"
      . SET GHOSTSCRIPT PATH F:\GHOSTGUM\GSVIEW\
      SET GHOSTSCRIPT PRINTER ON
    END IF

Default:
    The default is OFF.
 
Synonyms:
    None
 
Related Commands:
    PP                  = Print the current plot.
    SET GHOSTVIEW PATH  = Set the directory where Ghostview (and
                          GSPRINT) is installed.
    SET PRINTER         = Set the printer used for the PP command.
 
Applications:
    Windows Printing
 
Implementation Date:
    2002/11
 
Program:
    SET GHOSTSCRIPT PRINTER ON
    PLOT SIN(X) FOR X = -6 0.1 6
    PP
 
-----GHPDF (LET)--------------------------------
 
GHPDF
 
Name:
    GHPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the g-and-h probability density function.
 
Description:
    The g-and-h distribution is defined in terms of its percent point
    function:

       G(p,g,h) = (EXP(g*Zp) - 1)*EXP(h*Zp**2/2)/g

    with Zp denoting the normal percent point function of p.
    When g = 0 and h = 0, the g-and-h distribution reduces to
    a standard normal distribution.

    The g-and-h probability density function is computed by
    taking the numerical derivative of the cumulative distribution
    function (which is turn computed by numerically inverting the
    percent point function using a bisection method).

    The value of g controls the degree of skewness.  For g = 0,
    the distribution is symmetric.  As the absolute value of
    g increases, the amount of the skewness increases.  The
    sign of g controls the direction of the skewness (but not
    the amount).  Positive values of g skew the distribution
    to the right tail while negative values of g skew the
    distribution to the left tail.  Values for g are typically
    in the range (-1,1).

    The value of h controls the elongation, or how heavy the
    tails are, of the distribution.  For h = 0, the elongation
    is equivalent to that of a normal distribution.  For h = 1,
    the elongation is equivalent to that of a Cauchy distribution.
    Values of h are typically in the range (0,1).

    Specifying values for both g and h gives this distribution
    great flexibility in modeling data.

    The g-and-h distribution can be generalized with location and
    scale parameters in the usual way.
 
Syntax:
    LET <y> = GHPDF(<x>,<g>,<h>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter;
          <g> is a number or parameter that specifies the skewness
               shape parameter;
          <h> is a number or parameter that specifies the elongation
               shape parameter;
          <loc> is a number or parameter that specifies the location
               parameter;
          <scale> is a number or parameter that specifies the scale
               parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed g-and-h pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    Note that the location and scale parameters are optional.

Examples:
    LET A = GHPDF(0.9,0.5,0.2)
    LET Y = GHPDF(X,0.5,0.2)
    PLOT GHPDF(X,0.5,0.2) FOR X = -5 0.1 5

Note:
    G-and-h random numbers, probability plots, and goodness
    of fit tests can be generated with the commands:

       LET G = <value>
       LET H = <value>
       LET Y = GH RANDOM NUMBERS FOR I = 1 1 N
       GH PROBABILITY PLOT Y
       GH KOLMOGOROV SMIRNOV GOODNESS OF FIT Y
       GH CHI-SQUARE GOODNESS OF FIT Y

    The following commands can be used to estimate the shape
    parameters for the g-and-h distribution:

       LET G1 = <value>
       LET G2 = <value>
       LET H1 = <value>
       LET H2 = <value>
       GH PPCC PLOT Y
       GH KS PLOT Y

    The default values for G1 and G2 are -1 and 1.  The default values
    for H1 and H2 are 0 and 1.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GHCDF  = Compute the g-and-h cumulative distribution function.
    GHPPF  = Compute the g-and-h percent point function.
    LAMPDF = Compute the Tukey-Lambda probability density function.
    NORPDF = Compute the standard normal probability density function.
    LOGPDF = Compute the logistic probability density function.
    JSUPDF = Compute the Johnson SU probability density function.
 
Reference:
    "Summarizing Shape Numerically: The g-and-h Distributions",
    David C. Hoaglin, chapter 11 in "Exploring Data Tables, Trends,
    and Shapes", Eds. Hoaglin, Mosteller, and Tukey, Wiley, 1985.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2004/5
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT SCALE FACTOR 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    Y1LABEL X
    X1LABEL PROBABILITY
    X1LABEL DISPLACEMENT 12
    Y1LABEL DISPLACEMENT 12
    TITLE G = 0.2, H = 0.2
    PLOT GHPDF(X,0.5,0.5) FOR X = -10  0.1  10
    TITLE G = 0.5, H = 0.2
    PLOT GHPDF(X,0.5,0.2) FOR X = -10  0.1  10
    TITLE G = 0.2, H = 0.5
    PLOT GHPDF(X,0.2,0.5) FOR X = -10  0.1  10
    TITLE G = 0.5, H = 0.5
    PLOT GHPDF(X,0.5,0.5) FOR X = -10  0.1  10
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT G-AND-H DISTRIBUTIONS
 
-----GHPPF (LET)--------------------------------
 
GHPPF
 
Name:
    GHPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the g-and-h percent point function.
 
Description:
    The percent point function of the g-and-h distribution is
    defined as follows:

       G(p,g,h) = (EXP(g*Zp) - 1)*EXP(h*Zp**2/2)/g

    with Zp denoting the normal percent point function of p.
    When g = 0 and h = 0, the g-and-h distribution reduces to
    a standard normal distribution.

    The value of g controls the degree of skewness.  For g = 0,
    the distribution is symmetric.  As the absolute value of
    g increases, the amount of the skewness increases.  The
    sign of g controls the direction of the skewness (but not
    the amount).  Positive values of g skew the distribution
    to the right tail while negative values of g skew the
    distribution to the left tail.  Values for g are typically
    in the range (-1,1).

    The value of h controls the elongation, or how heavy the
    tails are, of the distribution.  For h = 0, the elongation
    is equivalent to that of a normal distribution.  For h = 1,
    the elongation is equivalent to that of a Cauchy distribution.
    Values of h are typically in the range (0,1).

    Specifying values for both g and h gives this distribution
    great flexibility in modeling data.

    The input value is a real number between 0 and 1 (since it
    corresponds to a probability).
 
    The g-and-h distribution can be generalized with location and
    scale parameters in the usual way.

Syntax:
    LET <y> = GHPPF(<p>,<g>,<h>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, number, or parameter in the range 0
               to 1;
          <g> is a number or parameter that specifies the skewness
               shape parameter;
          <h> is a number or parameter that specifies the elongation
               shape parameter;
          <loc> is a number or parameter that specifies the location
               parameter;
          <scale> is a number or parameter that specifies the scale
               parameter;
          <y> is a variable or a parameter (depending on what <p> is)
               where the computed g-and-h ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    Note that the location and scale parameters are optional.

Examples:
    LET A = GHPPF(0.95,0.5,0.2)
    LET Y = GHPPF(P,0.5,0.2)
    PLOT GHCDF(P,0.5,0.2) FOR P = 0.01  0.01  0.01
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GHCDF  = Compute the g-and-h cumulative distribution function.
    GHPDF  = Compute the g-and-h probability density function.
    LAMPDF = Compute the Tukey-Lambda probability density function.
    NORPDF = Compute the standard normal probability density function.
    LOGPDF = Compute the logistic probability density function.
    JSUPDF = Compute the Johnson SU probability density function.
 
Reference:
    "Summarizing Shape Numerically: The g-and-h Distributions",
    David C. Hoaglin, chapter 11 in "Exploring Data Tables, Trends,
    and Shapes", Eds. Hoaglin, Mosteller, and Tukey, Wiley, 1985.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2004/5
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT SCALE FACTOR 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    Y1LABEL X
    X1LABEL PROBABILITY
    X1LABEL DISPLACEMENT 12
    Y1LABEL DISPLACEMENT 12
    TITLE G = 0.2, H = 0.2
    PLOT GHPPF(P,0.2,0.2) FOR P = 0.01 .01 0.99
    TITLE G = 0.5, H = 0.2
    PLOT GHPPF(P,0.5,0.2) FOR P = 0.01 .01 0.99
    TITLE G = 0.2, H = 0.5
    PLOT GHPPF(P,0.2,0.5) FOR P = 0.01 .01 0.99
    TITLE G = 0.5, H = 0.5
    PLOT GHPPF(P,0.5,0.5) FOR P = 0.01 .01 0.99
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT G-AND-H DISTRIBUTIONS
 
-----GIGCDF (LET)--------------------------------
 
GIGCDF
 
Name:
    GIGCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized inverse Gaussian cumulative distribution
    function.
 
Description:
    The standard form of the generalized inverse Gaussian
    distribution has the following probability density function:

        f(x;chi,lambda,theta) =
            C*x**(theta-1)*EXP(-(1/2)*(lambda*x+chi/x))
            X > 0; chi, lambda > 0; -INF < theta < INF

    where

        C = (lambda/x)**(theta/2)/[2*K(0)(SQRT(chi*lambda))]
            chi, lambda > 0

          = lambda**theta/[2**theta*GAMMA(theta)]
            chi = 0; lambda, theta > 0

          = 2**theta/[x**theta*GAMMA(-theta)]
            chi > 0; lambda=0; theta < 0

    where K(nu)(.) is the modified Bessel function of the
    of the third kind of order nu and GAMMA is the gamma
    function.

    The standard generalized inverse Gaussian distribution can
    be generalized with location and scale parameters in the usual
    way.

    The cumulative distribution function is computed by
    numerically integrating the probability density function.
    Dataplot performs the integration using the DQAG routine
    from the Slatec library.

Syntax:
    LET <y> = GIGCDF(<x>,<chi>,<lambda>,<theta>,<loc>,<scale>)
                                <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <chi> is a positive number of parameter that specifies the
              value of the first shape parameter;
          <lambda> is a positive number of parameter that specifies
              the value of the second shape parameter;
          <theta> is a positive number of parameter that specifies
              the value of the third shape parameter;
          <loc> is an optional number or parameter that specifies the
              value of the location parameter;
          <scale> is an optional positive number or parameter that
              specifies the value of the scale parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed generalized inverse Gaussian cdf
               value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y = GIGCDF(3,2,0.5,3)
    LET Y = GIGCDF(X1,CHI,LAMBDA,THETA)
    PLOT GIGCDF(X,CHI,LAMBDA,THETA) FOR X = 0.01  0.01  10
 
Note:
    DATAPLOT uses the routine DBESK from the SLATEC Common Mathematical
    Library to compute the modified Bessel function of the third
    kind.  SLATEC is a large set of high quality, portable, public
    domain Fortran routines for various mathematical capabilities
    maintained by seven federal laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GIGPDF = Compute the generalized inverse Gaussian probability
             density function.
    GIGPPF = Compute the generalized inverse Gaussian percent point
             function.
    GALPDF = Compute the generalized asymmetric Laplace probability
             density function.
    IGCDF  = Compute the inverse Gaussian probability density
             function.
    BEICDF = Compute the Bessel I-function probability density
             function.
    BEKCDF = Compute the Bessel K-function probability density
             function.
    GAMCDF = Compute the gamma probability density function.
 
Reference:
    Johnson, Kotz, and Balakrishnan, (1994), "Continuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 284-285.

Applications:
    Distributional Modeling
 
Implementation Date:
    8/2004
 
Program:
    Y1LABEL Probability
    X1LABEL X
    LABEL CASE ASIS
    TITLE CASE ASIS
    CASE ASIS
    Y1LABEL DISPLACEMENT 12
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    LINE COLOR BLACK BLUE RED GREEN
    TITLE CHI = 0.5, LAMBDA = 2, THETA = 0.5, 1.0, 2.0, 5.0
    PLOT GIGCDF(X,0.5,2.0,0.5) FOR X = 0.01  0.01  10 AND
    PLOT GIGCDF(X,0.5,2.0,1.0) FOR X = 0.01  0.01  10 AND
    PLOT GIGCDF(X,0.5,2.0,2.0) FOR X = 0.01  0.01  10 AND
    PLOT GIGCDF(X,0.5,2.0,5.0) FOR X = 0.01  0.01  10
    TITLE CHI = 2.0, LAMBDA = 0.5, THETA = 0.5, 1.0, 2.0, 5.0
    PLOT GIGCDF(X,2.0,0.5,0.5) FOR X = 0.01  0.01  10 AND
    PLOT GIGCDF(X,2.0,0.5,1.0) FOR X = 0.01  0.01  10 AND
    PLOT GIGCDF(X,2.0,0.5,2.0) FOR X = 0.01  0.01  10 AND
    PLOT GIGCDF(X,2.0,0.5,5.0) FOR X = 0.01  0.01  10
    TITLE CHI = 2.0, LAMBDA = 2.0, THETA = 0.5, 1.0, 2.0, 5.0
    PLOT GIGCDF(X,2.0,2.0,0.5) FOR X = 0.01  0.01  10 AND
    PLOT GIGCDF(X,2.0,2.0,1.0) FOR X = 0.01  0.01  10 AND
    PLOT GIGCDF(X,2.0,2.0,2.0) FOR X = 0.01  0.01  10 AND
    PLOT GIGCDF(X,2.0,2.0,5.0) FOR X = 0.01  0.01  10
    TITLE CHI = 0.5, LAMBDA = 0.5, THETA = 0.5, 1.0, 2.0, 5.0
    PLOT GIGCDF(X,0.5,0.5,0.5) FOR X = 0.01  0.01  10 AND
    PLOT GIGCDF(X,0.5,0.5,1.0) FOR X = 0.01  0.01  10 AND
    PLOT GIGCDF(X,0.5,0.5,2.0) FOR X = 0.01  0.01  10 AND
    PLOT GIGCDF(X,0.5,0.5,5.0) FOR X = 0.01  0.01  10
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT Generalized Inverse Gaussian Distribution
 
-----GIGPDF (LET)--------------------------------
 
GIGPDF
 
Name:
    GIGPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized inverse Gaussian probability density
    function.
 
Description:
    The standard form of the generalized inverse Gaussian
    distribution has the following probability density function:

        f(x;chi,lambda,theta) =
            C*x**(theta-1)*EXP(-(1/2)*(lambda*x+chi/x))
            X > 0; chi, lambda > 0; -INF < theta < INF

    where

        C = (lambda/x)**(theta/2)/[2*K(0)(SQRT(chi*lambda))]
            chi, lambda > 0

          = lambda**theta/[2**theta*GAMMA(theta)]
            chi = 0; lambda, theta > 0

          = 2**theta/[x**theta*GAMMA(-theta)]
            chi > 0; lambda=0; theta < 0

    where K(nu)(.) is the modified Bessel function of the
    of the third kind of order nu and GAMMA is the gamma
    function.

    The standard generalized inverse Gaussian distribution can
    be generalized with location and scale parameters in the usual
    way.

Syntax:
    LET <y> = GIGPDF(<x>,<chi>,<lambda>,<theta>,<loc>,<scale>)
                                <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <chi> is a positive number of parameter that specifies the
              value of the first shape parameter;
          <lambda> is a positive number of parameter that specifies
              the value of the second shape parameter;
          <theta> is a positive number of parameter that specifies
              the value of the third shape parameter;
          <loc> is an optional number or parameter that specifies the
              value of the location parameter;
          <scale> is an optional positive number or parameter that
              specifies the value of the scale parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed generalized inverse Gaussian pdf
               value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y = GIGPDF(3,2,0.5,3)
    LET Y = GIGPDF(X1,CHI,LAMBDA,THETA)
    PLOT GIGPDF(X,CHI,LAMBDA,THETA) FOR X = 0.01  0.01  10
 
Note:
    DATAPLOT uses the routine DBESK from the SLATEC Common Mathematical
    Library to compute the modified Bessel function of the third
    kind.  SLATEC is a large set of high quality, portable, public
    domain Fortran routines for various mathematical capabilities
    maintained by seven federal laboratories.

Note:
    To generate generalized inverse Gaussian random numbers, enter
    the commands

        LET CHI = <value>
        LET LAMBDA = <value>
        LET THETA = <value>
        LET Y = GENERALIZED INVERSE GAUSSIAN RANDOM NUMBERS ...
                FOR I = 1 1 N

    To generate a generalized inverse Gaussian probability plot
    or a generalized inverse Gaussian Kolmogorov-Smirnov or
    chi-square goodness of fit test, enter the following commands

        LET CHI = <value>
        LET LAMBDA = <value>
        LET THETA = <value>
        GENERALIZED INVERSE GAUSSIAN PROBABILITY PLOT Y
        GENERALIZED INVERSE GAUSSIAN KOLMOGOROV SMIRNOV ...
                   GOODNESS OF FIT Y
        GENERALIZED INVERSE GAUSSIAN CHI-SQUARE GOODNESS OF FIT Y
       
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GIGCDF = Compute the generalized inverse Gaussian cumulative
             distribution function.
    GIGPPF = Compute the generalized inverse Gaussian percent point
             function.
    GALPDF = Compute the generalized asymmetric Laplace probability
             density function.
    IGPDF  = Compute the inverse Gaussian probability density
             function.
    BEIPDF = Compute the Bessel I-function probability density
             function.
    BEKPDF = Compute the Bessel K-function probability density
             function.
    GAMPDF = Compute the gamma probability density function.
 
Reference:
    Johnson, Kotz, and Balakrishnan, (1994), "Continuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 284-285.

Applications:
    Distributional Modeling
 
Implementation Date:
    8/2004
 
Program:
    Y1LABEL Probability
    X1LABEL X
    LABEL CASE ASIS
    TITLE CASE ASIS
    CASE ASIS
    Y1LABEL DISPLACEMENT 12
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    LINE COLOR BLACK BLUE RED GREEN
    TITLE CHI = 0.5, LAMBDA = 2, THETA = 0.5, 1.0, 2.0, 5.0
    PLOT GIGPDF(X,0.5,2.0,0.5) FOR X = 0.01  0.01  10 AND
    PLOT GIGPDF(X,0.5,2.0,1.0) FOR X = 0.01  0.01  10 AND
    PLOT GIGPDF(X,0.5,2.0,2.0) FOR X = 0.01  0.01  10 AND
    PLOT GIGPDF(X,0.5,2.0,5.0) FOR X = 0.01  0.01  10
    TITLE CHI = 2.0, LAMBDA = 0.5, THETA = 0.5, 1.0, 2.0, 5.0
    PLOT GIGPDF(X,2.0,0.5,0.5) FOR X = 0.01  0.01  10 AND
    PLOT GIGPDF(X,2.0,0.5,1.0) FOR X = 0.01  0.01  10 AND
    PLOT GIGPDF(X,2.0,0.5,2.0) FOR X = 0.01  0.01  10 AND
    PLOT GIGPDF(X,2.0,0.5,5.0) FOR X = 0.01  0.01  10
    TITLE CHI = 2.0, LAMBDA = 2.0, THETA = 0.5, 1.0, 2.0, 5.0
    PLOT GIGPDF(X,2.0,2.0,0.5) FOR X = 0.01  0.01  10 AND
    PLOT GIGPDF(X,2.0,2.0,1.0) FOR X = 0.01  0.01  10 AND
    PLOT GIGPDF(X,2.0,2.0,2.0) FOR X = 0.01  0.01  10 AND
    PLOT GIGPDF(X,2.0,2.0,5.0) FOR X = 0.01  0.01  10
    TITLE CHI = 0.5, LAMBDA = 0.5, THETA = 0.5, 1.0, 2.0, 5.0
    PLOT GIGPDF(X,0.5,0.5,0.5) FOR X = 0.01  0.01  10 AND
    PLOT GIGPDF(X,0.5,0.5,1.0) FOR X = 0.01  0.01  10 AND
    PLOT GIGPDF(X,0.5,0.5,2.0) FOR X = 0.01  0.01  10 AND
    PLOT GIGPDF(X,0.5,0.5,5.0) FOR X = 0.01  0.01  10
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT Generalized Inverse Gaussian Distribution
 
-----GIGPPF (LET)--------------------------------
 
GIGPPF
 
Name:
    GIGPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized inverse Gaussian percent point function.
 
Description:
    The standard form of the generalized inverse Gaussian
    distribution has the following probability density function:

        f(x;chi,lambda,theta) =
            C*x**(theta-1)*EXP(-(1/2)*(lambda*x+chi/x))
            X > 0; chi, lambda > 0; -INF < theta < INF

    where

        C = (lambda/x)**(theta/2)/[2*K(0)(SQRT(chi*lambda))]
            chi, lambda > 0

          = lambda**theta/[2**theta*GAMMA(theta)]
            chi = 0; lambda, theta > 0

          = 2**theta/[x**theta*GAMMA(-theta)]
            chi > 0; lambda=0; theta < 0

    where K(nu)(.) is the modified Bessel function of the
    of the third kind of order nu and GAMMA is the gamma
    function.

    The standard generalized inverse Gaussian distribution can
    be generalized with location and scale parameters in the usual
    way.

    The cumulative distribution function is computed by
    numerically integrating the probability density function.
    Dataplot performs the integration using the DQAG routine
    from the Slatec library.  The percent point function is
    then computed by numerically inverting the cumulative
    distribution function using the DFZERO subroutine from
    the Slatec library.

Syntax:
    LET <y> = GIGPPF(<p>,<chi>,<lambda>,<theta>,<loc>,<scale>)
                                <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, a number, or a parameter in the
              interval (0,1);
          <chi> is a positive number of parameter that specifies the
              value of the first shape parameter;
          <lambda> is a positive number of parameter that specifies
              the value of the second shape parameter;
          <theta> is a positive number of parameter that specifies
              the value of the third shape parameter;
          <loc> is an optional number or parameter that specifies the
              value of the location parameter;
          <scale> is an optional positive number or parameter that
              specifies the value of the scale parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed generalized inverse Gaussian ppf
               value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y = GIGPPF(0.95,2,0.5,3)
    LET Y = GIGPPF(P,CHI,LAMBDA,THETA)
    PLOT GIGPPF(P,CHI,LAMBDA,THETA) FOR P = 0.01  0.01  0.99
 
Note:
    DATAPLOT uses the routine DBESK from the SLATEC Common Mathematical
    Library to compute the modified Bessel function of the third
    kind.  SLATEC is a large set of high quality, portable, public
    domain Fortran routines for various mathematical capabilities
    maintained by seven federal laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GIGCDF = Compute the generalized inverse Gaussian cumulative
             distribution function.
    GIGPDF = Compute the generalized inverse Gaussian probability
             density function.
    GALPDF = Compute the generalized asymmetric Laplace probability
             density function.
    IGCDF  = Compute the inverse Gaussian probability density
             function.
    BEICDF = Compute the Bessel I-function probability density
             function.
    BEKCDF = Compute the Bessel K-function probability density
             function.
    GAMCDF = Compute the gamma probability density function.
 
Reference:
    Johnson, Kotz, and Balakrishnan, (1994), "Continuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 284-285.

Applications:
    Distributional Modeling
 
Implementation Date:
    8/2004
 
Program:
    Y1LABEL Probability
    X1LABEL X
    LABEL CASE ASIS
    TITLE CASE ASIS
    CASE ASIS
    Y1LABEL DISPLACEMENT 12
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    LINE COLOR BLACK BLUE RED GREEN
    TITLE CHI = 0.5, LAMBDA = 2, THETA = 0.5, 1.0, 2.0, 5.0
    PLOT GIGPPF(P,0.5,2.0,0.5) FOR P = 0.01  0.01  0.99 AND
    PLOT GIGPPF(P,0.5,2.0,1.0) FOR P = 0.01  0.01  0.99 AND
    PLOT GIGPPF(P,0.5,2.0,2.0) FOR P = 0.01  0.01  0.99 AND
    PLOT GIGPPF(P,0.5,2.0,5.0) FOR P = 0.01  0.01  0.99
    TITLE CHI = 2.0, LAMBDA = 0.5, THETA = 0.5, 1.0, 2.0, 5.0
    PLOT GIGPPF(P,2.0,0.5,0.5) FOR P = 0.01  0.01  0.99 AND
    PLOT GIGPPF(P,2.0,0.5,1.0) FOR P = 0.01  0.01  0.99 AND
    PLOT GIGPPF(P,2.0,0.5,2.0) FOR P = 0.01  0.01  0.99 AND
    PLOT GIGPPF(P,2.0,0.5,5.0) FOR P = 0.01  0.01  0.99
    TITLE CHI = 2.0, LAMBDA = 2.0, THETA = 0.5, 1.0, 2.0, 5.0
    PLOT GIGPPF(P,2.0,2.0,0.5) FOR P = 0.01  0.01  0.99 AND
    PLOT GIGPPF(P,2.0,2.0,1.0) FOR P = 0.01  0.01  0.99 AND
    PLOT GIGPPF(P,2.0,2.0,2.0) FOR P = 0.01  0.01  0.99 AND
    PLOT GIGPPF(P,2.0,2.0,5.0) FOR P = 0.01  0.01  0.99
    TITLE CHI = 0.5, LAMBDA = 0.5, THETA = 0.5, 1.0, 2.0, 5.0
    PLOT GIGPPF(P,0.5,0.5,0.5) FOR P = 0.01  0.01  0.99 AND
    PLOT GIGPPF(P,0.5,0.5,1.0) FOR P = 0.01  0.01  0.99 AND
    PLOT GIGPPF(P,0.5,0.5,2.0) FOR P = 0.01  0.01  0.99 AND
    PLOT GIGPPF(P,0.5,0.5,5.0) FOR P = 0.01  0.01  0.99
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT Generalized Inverse Gaussian Distribution
 
-----GINI MEAN DIFFERENCE LOG RATIO (LET)----------------------------
 
GINI MEAN DIFFERENCE LOG RATIO
 
Name:
    GINI MEAN DIFFERENCE LOG RATIO (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the log of the ratio of the Gini mean differences for two
    response variables.
 
Description:
    Given a response variable X with observations x1, x2, ..., xn sorted
    from low value to high value, the Gini mean difference is defined as:

        GMD = (2/(n*(n-1))*SUM[i=1 to n][SUM[j < i]
              [ABS(x(i) - x(j)]]
            = (2/(n*(n-1))*SUM[i=1 to n-1][i*(n-i)*(x(i+1) - x(i))]

    where ABS is the absolute value and n is the sample size.

    The Gini mean difference was proposed by Gini (1912) and is
    the average absolute differences in all pairs of observations.
    Note that this is a measure of dispersion that does not depend
    on a measure of location.

    This command computes the log of the ratio of the Gini mean
    differences of two variables.  If the Gini mean differences are
    equal, the ratio of the Gini mean differences is equal to 1 and the
    log of the ratio is equal to 0.  This can be the basis of a
    robust alternative approach to testing for equal dispersion.
    Tena (2009) discusses this in more detail.

Syntax:
    LET <par> = GINI MEAN DIFFERENCE LOG RATIO <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Gini mean difference
               log ratio is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GINI MEAN DIFFERENCE LOG RATIO Y1 Y2
    LET A = GINI MEAN DIFFERENCE LOG RATIO Y1 Y2 SUBSET Y2 > 0

Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GINI MEAN DIFFERENCE        = Compute the Gini mean differences of
                                  a variable.
    MEDIAN ABSOLUTE DEVIATION   = Compute the median absolute
                                  deviation of a variable.
    AVERAGE ABSOLUTE DEVIATION  = Compute the average absolute
                                  deviation of a variable.
    STANDARD DEVIATION          = Compute the standard deviation of a
                                  variable.
    VARIANCE                    = Compute the variance of a variable.
    RANGE                       = Compute the range of a variable.
 
References:
    Tena (2009), "Test Procedures for Equality of Two Variances in
    Delta Distributions," Dissertations, 695,
    https://scholarworks.wmich.edu/dissertations/695.

    Gini (1921), "Measurement of Inequality in Incomes," The Economic
    Journal, 31, pp. 124-126.

Applications:
    Data Analysis
 
Implementation Date:
    2023/07
 
Program:
    SKIP 25
    READ AUTO83B.DAT Y1 Y2
    RETAIN Y2 SUBSET Y2 > 0
    .
    BOOTSTRAP SAMPLES 10000
    TITLE CASE ASIS
    LABEL CASE ASIS
    CASE ASIS
    .
    TITLE Bootstrap Plot for Gini Mean Difference Log Ratio
    X1LABEL Bootstrap Sample
    X2LABEL Dataset: AUTO83B.DAT
    Y1LABEL Gini Mean Difference Log Ratio
    .
    BOOTSTRAP GINI MEAN DIFFERENCE LOG RATIO PLOT Y1 Y2
    .
    LET LCL = ROUND(B025,3)
    LET UCL = ROUND(B975,3)
    JUSTIFICATION CENTER
    MOVE 50 3
    TEXT Lower 95% Confidence Limit: ^LCL, Upper 95% Confidence Limit: ^UCL
    LINE DOTTED
    LINE COLOR RED
    DRAWSDSD 15 ^LCL 85 ^LCL
    DRAWSDSD 15 ^UCL 85 ^UCL
 
-----GINI MEAN DIFFERENCE (LET)-------------------------------
 
GINI MEAN DIFFERENCE
 
Name:
    GINI MEAN DIFFERENCE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the Gini mean difference for a variable.
 
Description:
    Given a response variable X with observations x1, x2, ..., xn sorted
    from low value to high value, the Gini mean difference is defined as:

        GMD = (2/(n*(n-1))*SUM[i=1 to n][SUM[j < i]
              [ABS(x(i) - x(j)]]
            = (2/(n*(n-1))*SUM[i=1 to n-1][i*(n-i)*(x(i+1) - x(i))]

    where ABS is the absolute value and n is the sample size.

    The Gini mean difference was proposed by Gini (1912) and is
    the average absolute differences in all pairs of observations.
    Note that this is a measure of dispersion that does not depend
    on a measure of location.

Syntax:
    LET <par> = GINI MEAN DIFFERENCE <y>
                <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the computed Gini mean difference
               is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GINI MEAN DIFFERENCE Y1
    LET A = GINI MEAN DIFFERENCE Y1 SUBSET TAG > 2

Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GINI MEAN DIFFERENCE LOG RATIO = Compute the log of the ratio
                                     of the Gini mean differences of
                                     two samples.
    MEDIAN ABSOLUTE DEVIATION      = Compute the median absolute
                                     deviation of a variable.
    AVERAGE ABSOLUTE DEVIATION     = Compute the average absolute
                                     deviation of a variable.
    STANDARD DEVIATION             = Compute the standard deviation of a
                                     variable.
    VARIANCE                       = Compute the variance of a variable.
    RANGE                          = Compute the range of a variable.
 
References:
    Tena (2009), "Test Procedures for Equality of Two Variances in
    Delta Distributions," Dissertations, 695,
    https://scholarworks.wmich.edu/dissertations/695.

    Gini (1921), "Measurement of Inequality in Incomes," The Economic
    Journal, 31, pp. 124-126.

Applications:
    Data Analysis
 
Implementation Date:
    2023/07
 
Program 1:
    SKIP 25
    READ ROSNER.DAT Y
    .
    BOOTSTRAP SAMPLES 10000
    TITLE CASE ASIS
    LABEL CASE ASIS
    CASE ASIS
    .
    TITLE Bootstrap Plot for Gini Mean Difference
    X1LABEL Bootstrap Sample
    X2LABEL Dataset: ROSNER.DAT
    Y1LABEL Gini Mean Difference
    .
    BOOTSTRAP GINI MEAN DIFFERENCE PLOT Y
    .
    LET LCL = ROUND(B025,3)
    LET UCL = ROUND(B975,3)
    JUSTIFICATION CENTER
    MOVE 50 5
    TEXT Lower 95% Confidence Limit: ^LCL, Upper 95% Confidence Limit: ^UCL
    LINE DOTTED
    LINE COLOR RED
    LINE THICKNESS 0.3
    DRAWSDSD 15 ^LCL 85 ^LCL
    DRAWSDSD 15 ^UCL 85 ^UCL
 
Program 2:
    SKIP 25
    READ GEAR.DAT Y X
    .
    TITLE CASE ASIS
    LABEL CASE ASIS
    CASE ASIS
    .
    CHARACTER CIRCLE BLANK
    CHARACTER HW 1 0.75
    CHARACTER FILL ON
    LINE BLANK SOLID
    .
    XLIMITS 1 10
    MAJOR X1TIC MARK NUMBER 10
    MINOR X1TIC MARK NUMBER 0
    TIC MARK OFFSET UNITS DATA
    X1TIC MARK OFFSET 0.5 0.5
    .
    Y1LABEL Gini Mean Difference
    X1LABEL Batch ID
    TITLE Gini Mean Difference Plot for GEAR.DAT
    .
    GINI MEAN DIFFERENCE PLOT Y X

-----GLDCDF (LET)--------------------------------
 
GLDCDF
 
Name:
    GLDCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized Tukey-Lambda cumulative distribution
    function.
 
Description:
    The generalized Tukey-Lambda distribution is defined in terms
    of its percent point function.  Note that there are two
    parameterizations of this distribution in the literature.

    The original parameterization, referred to as the RS
    generalized Tukey-Lambda distribution, given by Ramberg and
    Schmeiser has the percent point function

       G(p;lambda1,lambda2,lambda3,lambda4) = 
             lambda1 + (p**lambda3 - (1-p)**lambda4)/lambda2

    with lambda1, lambda2, lambda3, and lambda4 denoting the
    location, the scale, and the two shape parameters,
    respectively.

    One drawback of this parameterization is that it does not
    define a valid probability distribution for certain values
    of the parameters.  Futhermore, the regions that do not define
    a valid probability distribution are not simple.  For this
    reason, Friemer, Mudholkar, Kollia, and Lin developed an
    alternative parameterization, referred to as the FMLKL
    generalized Tukey-Lambda distribution, that has the
    percent point function

       G(p;lambda1,lambda2,lambda3,lambda4) = 
          lambda1 + (1/lambda2)*
          [(p**lambda3-1)/lambda3 - ((1-p)**lambda4-1)/lambda4]/
          lambda2 > 0

    with lambda1, lambda2, lambda3, and lambda4 denoting the
    location, the scale, and the two shape parameters,
    respectively.

    Note that lambda3 = 0 or lambda4 = 0 results in division
    by zero in the above formula.

    If lambda3 = 0, then

       (p**lambda3 - 1)/lambda3 = log(p)

    Likewise, if lambda4 = 0, then

       ((1-p)**lambda4 - 1)/lambda4 = log(1-p)

    The advantage of the FMKL parameterization is that it defines
    a valid probability distribution for all real values of
    lambda3 and lambda4.  For this reason, Dataplot uses the
    FMKL parameterization.

    The generalized Tukey-Lambda cumulative distribution function
    is computed by numerically inverting the percent point
    function.

    A few relevant properties for this distribution are:

       1. If lambda3 = lambda4, then the generalized Tukey-Lambda
          distribution reduces to the symmetric Tukey-Lambda
          distribution.

       2. The lambda3 parameter controls the behavior of the lower
          tail.  If lambda3 > 0, then the distribution is bounded
          below at -1/lambda3.  If lambda3 <= 0, then the
          distribution is unbounded below.

       3. The lambda4 parameter controls the behavior of the upper
          tail.  If lambda4 > 0, then the distribution is bounded
          above at 1/lambda4.  If lambda4 <= 0, then the
          distribution is unbounded above.

       4. The kth moment is finite only if
          min(lambda3,lambda4) > -1/k.  So this distribution
          has finite mean only if min(lambda3,lambda4) > -1
          and finite variance only if min(lambda3,lambda4) > -0.5.

Syntax:
    LET <y> = GLDCDF(<x>,<l3>,<l4>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter;
          <l3> is a number or parameter that specifies the
               first shape parameter;
          <l4> is a number or parameter that specifies the
               second shape parameter;
          <loc> is a number or parameter that specifies the location
               parameter;
          <scale> is a number or parameter that specifies the scale
               parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed generalized Tukey-Lambda cdf value
               is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    Note that the location and scale parameters are optional.

Examples:
    LET A = GLDCDF(0.9,0.5,0.2)
    LET Y = GLDCDF(X,0.5,0.2)
    PLOT GLDCDF(X,0.5,0.2) FOR X = -2 0.01 5

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GLDPDF            = Compute the generalized Tukey-Lambda
                        probability density function.
    GLDPPF            = Compute the generalized Tukey-Lambda
                        percent point function.
    LAMCDF            = Compute the Tukey-Lambda probability
                        density function.
    GHCDF             = Compute the g-and-h probability density
                        function.
    JSUCDF            = Compute the Johnson SU probability density
                        function.
    JSBCDF            = Compute the Johnson SB probability density
                        function.

Reference:
    Ramberg and Schmeiser (1972), "An Approximate Method for
    Generating Symmetric Random Variables", Communications of
    the Association for Computing Machinery, 15, pp. 987-990.
 
    Ramberg and Schmeiser (1974), "An Approximate Method for
    Generating Asymmetric Random Variables", Communications of
    the Association for Computing Machinery, 17, pp. 78-82.
 
    Ozturk and Dale (1985), "Least Squares Estimation of the
    Parameters of the Generalized Lambda Distribution",
    Technometrics, Vol. 27, No. 1, pp. 81-84.

    Friemer, Mudholkar, Kollia, and Lin (1988), "A Study of
    the Generalized Lambda Family", Communications in
    Statistics-Theory and Methods, 17, pp. 3547-3567.

    King and MacGillivray (1999), "A Starship Estimation
    Method for the Generalized Lambda Distributions",
    Australia and New Zealand Journal of Statistics,
    41(3), pp. 353-374.

    Karian and Dudewicz (2000), Fitting Statistical
    Distributions: The Generalized Bootstrap Methods,
    New York, Chapman & Hall.
    
    Su (2005), "A Discretized Approach to Flexibly Fit
    Generalized Lambda Distributions to Data", Journal of
    Modern Applied Statistical Methods, Vol. 4, No. 2,
    pp. 408-424.

Applications:
    Distributional Modeling

Implementation Date:
    2006/3

Program:
    MULTIPLOT 4 4
    MULTIPLOT SCALE FACTOR 2.5
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    LABEL CASE ASIS
    X1LABEL X
    Y1LABEL Probability
    X1LABEL DISPLACEMENT 16
    Y1LABEL DISPLACEMENT 18
    TITLE DISPLACEMENT 2
    XLIMITS -10 10
    LET LAMBDA3 = DATA -0.5 0 0.5 2
    LET LAMBDA4 = DATA -0.5 0 0.5 2
    LOOP FOR K = 1 1 4
        LET L3 = LAMBDA3(K)
        LET XLOW = -10
        IF L3 > 0
           LET XLOW = -1/L3
        END OF IF
        LOOP FOR L = 1 1 4
            LET L4 = LAMBDA4(L)
            LET XUPP = 10
            IF L4 > 0
               LET XUPP = 1/L4
            END OF IF
            TITLE L3 = ^L3, L4 = ^L4
            PLOT GLDCDF(X,L3,L4) FOR X = XLOW  0.01  XUPP
        END OF LOOP
    END OF LOOP
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATION CENTER
    CASE ASIS
    TEXT Generalized Tukey-Lambda Distributions

-----GLDPDF (LET)--------------------------------
 
GLDPDF
 
Name:
    GLDPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized Tukey-Lambda probability density
    function.
 
Description:
    The generalized Tukey-Lambda distribution is defined in terms
    of its percent point function.  Note that there are two
    parameterizations of this distribution in the literature.

    The original parameterization, referred to as the RS
    generalized Tukey-Lambda distribution, given by Ramberg and
    Schmeiser has the percent point function

       G(p;lambda1,lambda2,lambda3,lambda4) = 
             lambda1 + (p**lambda3 - (1-p)**lambda4)/lambda2

    with lambda1, lambda2, lambda3, and lambda4 denoting the
    location, the scale, and the two shape parameters,
    respectively.

    One drawback of this parameterization is that it does not
    define a valid probability distribution for certain values
    of the parameters.  Futhermore, the regions that do not define
    a valid probability distribution are not simple.  For this
    reason, Friemer, Mudholkar, Kollia, and Lin developed an
    alternative parameterization, referred to as the FMLKL
    generalized Tukey-Lambda distribution, that has the
    percent point function

       G(p;lambda1,lambda2,lambda3,lambda4) = 
          lambda1 + (1/lambda2)*
          [(p**lambda3-1)/lambda3 - ((1-p)**lambda4-1)/lambda4]/
          lambda2 > 0

    with lambda1, lambda2, lambda3, and lambda4 denoting the
    location, the scale, and the two shape parameters,
    respectively.

    Note that lambda3 = 0 or lambda4 = 0 results in division
    by zero in the above formula.

    If lambda3 = 0, then

       (p**lambda3 - 1)/lambda3 = log(p)

    Likewise, if lambda4 = 0, then

       ((1-p)**lambda4 - 1)/lambda4 = log(1-p)

    The advantage of the FMKL parameterization is that it defines
    a valid probability distribution for all real values of
    lambda3 and lambda4.  For this reason, Dataplot uses the
    FMKL parameterization.

    Although the probability density function does not exist
    in simple closed form, it can be computed from the following
    relationship:

       f(x) = 1/G'(F(x))

    with f, F, and G' denoting the probability density function,
    the cumulative distribution function, and the derivative
    of the percent point function, respectively.  The derivative
    of the percent point function is also known as the sparsity
    function.
    
    Using the above, the probability density function for the
    standard generalized Tukey-Lambda distribution (FMKL
    parameterization) is

       f(x;lambda3,lambda4) =
           1/[F(x)**(lambda3-1) + (1-F(x))**(lambda4-1)]

    with F(x) denoting the generalized Tukey-Lambda cumulative
    distribution function.  F(x) is computed by numerically
    inverting the percent point function.
 
    The Tukey-Lambda distribution provides a flexible model
    for symmetric distributions.  The generalized Tukey-Lambda
    distribution provides a flexible model for asymmetric
    distributions.

    A few relevant properties for this distribution are:

       1. If lambda3 = lambda4, then the generalized Tukey-Lambda
          distribution reduces to the symmetric Tukey-Lambda
          distribution.

       2. The lambda3 parameter controls the behavior of the lower
          tail.  If lambda3 > 0, then the distribution is bounded
          below at -1/lambda3.  If lambda3 <= 0, then the
          distribution is unbounded below.

       3. The lambda4 parameter controls the behavior of the upper
          tail.  If lambda4 > 0, then the distribution is bounded
          above at 1/lambda4.  If lambda4 <= 0, then the
          distribution is unbounded above.

       4. The kth moment is finite only if
          min(lambda3,lambda4) > -1/k.  So this distribution
          has finite mean only if min(lambda3,lambda4) > -1
          and finite variance only if min(lambda3,lambda4) > -0.5.

Syntax:
    LET <y> = GLDPDF(<x>,<l3>,<l4>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter;
          <l3> is a number or parameter that specifies the
               first shape parameter;
          <l4> is a number or parameter that specifies the
               second shape parameter;
          <loc> is a number or parameter that specifies the location
               parameter;
          <scale> is a number or parameter that specifies the scale
               parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed generalized Tukey-Lambda pdf value
               is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    Note that the location and scale parameters are optional.

Examples:
    LET A = GLDPDF(0.9,0.5,0.2)
    LET Y = GLDPDF(X,0.5,0.2)
    PLOT GLDPDF(X,0.5,0.2) FOR X = -2 0.01 5

Note:
    Generalized Tukey-Lambda random numbers, probability plots,
    and goodness of fit tests can be generated with the commands:

       LET LAMBDA3 = <value>
       LET LAMBDA4 = <value>
       LET Y = GENERALIZED TUKEY LAMBDA RANDOM NUMBERS FOR I = 1 1 N
       GENERALIZED TUKEY LAMBDA PROBABILITY PLOT Y
       GENERALIZED TUKEY LAMBDA KOLMOGOROV SMIRNOV GOODNESS OF FIT Y
       GENERALIZED TUKEY LAMBDA CHI-SQUARE GOODNESS OF FIT Y

    The following commands can be used to estimate the shape
    parameters for the generalized Tukey-Lambda distribution:

       LET LAMBDA31 = <value>
       LET LAMBDA32 = <value>
       LET LAMBDA41 = <value>
       LET LAMBDA42 = <value>
       GENERALIZED TUKEY-LAMBDA PPCC PLOT Y

    The default values for LAMBDA31, LAMBDA32, LAMBDA41, and
    LAMBDA42 are -1, 5, -1 and 5, respectively.

    We are still resolving some issues with the
    GENERALIZED TUKEY LAMBDA KS PLOT command, so we recommend
    that you not use this for now.

    Alternatively, you can perform a least squares regression
    fit using the following commands:

        LET Y = SORT Y
        LET N = SIZE Y
        LET PIN = UNIFORM ORDER STATISTIC MEDIANS FOR I = 1 1 N
        FIT Y = GLDPPF(PIN,L3,L4,ALOC,ASCALE)

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GLDCDF            = Compute the generalized Tukey-Lambda
                        cumulative distribution function.
    GLDPPF            = Compute the generalized Tukey-Lambda
                        percent point function.
    LAMPDF            = Compute the Tukey-Lambda probability
                        density function.
    GHPDF             = Compute the g-and-h probability density
                        function.
    JSUPDF            = Compute the Johnson SU probability density
                        function.
    JSBPDF            = Compute the Johnson SB probability density
                        function.
    PPCC PLOT         = Generate a ppcc plot.
    PROBABILITY PLOT  = Generate a probability plot.
 
Reference:
    Ramberg and Schmeiser (1972), "An Approximate Method for
    Generating Symmetric Random Variables", Communications of
    the Association for Computing Machinery, 15, pp. 987-990.
 
    Ramberg and Schmeiser (1974), "An Approximate Method for
    Generating Asymmetric Random Variables", Communications of
    the Association for Computing Machinery, 17, pp. 78-82.
 
    Ozturk and Dale (1985), "Least Squares Estimation of the
    Parameters of the Generalized Lambda Distribution",
    Technometrics, Vol. 27, No. 1, pp. 81-84.

    Friemer, Mudholkar, Kollia, and Lin (1988), "A Study of
    the Generalized Lambda Family", Communications in
    Statistics-Theory and Methods, 17, pp. 3547-3567.

    King and MacGillivray (1999), "A Starship Estimation
    Method for the Generalized Lambda Distributions",
    Australia and New Zealand Journal of Statistics,
    41(3), pp. 353-374.

    Karian and Dudewicz (2000), Fitting Statistical
    Distributions: The Generalized Bootstrap Methods,
    New York, Chapman & Hall.
    
    Su (2005), "A Discretized Approach to Flexibly Fit
    Generalized Lambda Distributions to Data", Journal of
    Modern Applied Statistical Methods, Vol. 4, No. 2,
    pp. 408-424.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/3
 
Program:
    MULTIPLOT 4 4
    MULTIPLOT SCALE FACTOR 2.5
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    LABEL CASE ASIS
    X1LABEL X
    Y1LABEL Probability Density
    X1LABEL DISPLACEMENT 16
    Y1LABEL DISPLACEMENT 18
    TITLE DISPLACEMENT 2
    XLIMITS -10 10
    LET LAMBDA3 = DATA -0.5 0 0.5 2
    LET LAMBDA4 = DATA -0.5 0 0.5 2
    LOOP FOR K = 1 1 4
        LET L3 = LAMBDA3(K)
        LET XLOW = -10
        IF L3 > 0
           LET XLOW = -1/L3
        END OF IF
        LOOP FOR L = 1 1 4
            LET L4 = LAMBDA4(L)
            LET XUPP = 10
            IF L4 > 0
               LET XUPP = 1/L4
            END OF IF
            TITLE L3 = ^L3, L4 = ^L4
            PLOT GLDPDF(X,L3,L4) FOR X = XLOW  0.01  XUPP
        END OF LOOP
    END OF LOOP
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATION CENTER
    CASE ASIS
    TEXT Generalized Tukey-Lambda Distributions

-----GLDPPF (LET)--------------------------------
 
GLDPPF
 
Name:
    GLDPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized Tukey-Lambda percent point function.
 
Description:
    The generalized Tukey-Lambda distribution is defined in terms
    of its percent point function.  Note that there are two
    parameterizations of this distribution in the literature.

    The original parameterization, referred to as the RS
    generalized Tukey-Lambda distribution, given by Ramberg and
    Schmeiser has the percent point function

       G(p;lambda1,lambda2,lambda3,lambda4) = 
             lambda1 + (p**lambda3 - (1-p)**lambda4)/lambda2

    with lambda1, lambda2, lambda3, and lambda4 denoting the
    location, the scale, and the two shape parameters,
    respectively.

    One drawback of this parameterization is that it does not
    define a valid probability distribution for certain values
    of the parameters.  Futhermore, the regions that do not define
    a valid probability distribution are not simple.  For this
    reason, Friemer, Mudholkar, Kollia, and Lin developed an
    alternative parameterization, referred to as the FMLKL
    generalized Tukey-Lambda distribution, that has the
    percent point function

       G(p;lambda1,lambda2,lambda3,lambda4) = 
          lambda1 + (1/lambda2)*
          [(p**lambda3-1)/lambda3 - ((1-p)**lambda4-1)/lambda4]/
          lambda2 > 0

    with lambda1, lambda2, lambda3, and lambda4 denoting the
    location, the scale, and the two shape parameters,
    respectively.

    Note that lambda3 = 0 or lambda4 = 0 results in division
    by zero in the above formula.

    If lambda3 = 0, then

       (p**lambda3 - 1)/lambda3 = log(p)

    Likewise, if lambda4 = 0, then

       ((1-p)**lambda4 - 1)/lambda4 = log(1-p)

    The advantage of the FMKL parameterization is that it defines
    a valid probability distribution for all real values of
    lambda3 and lambda4.  For this reason, Dataplot uses the
    FMKL parameterization.

    The Tukey-Lambda distribution provides a flexible model
    for symmetric distributions.  The generalized Tukey-Lambda
    distribution provides a flexible model for asymmetric
    distributions.

    A few relevant properties for this distribution are:

       1. If lambda3 = lambda4, then the generalized Tukey-Lambda
          distribution reduces to the symmetric Tukey-Lambda
          distribution.

       2. The lambda3 parameter controls the behavior of the lower
          tail.  If lambda3 > 0, then the distribution is bounded
          below at -1/lambda3.  If lambda3 <= 0, then the
          distribution is unbounded below.

       3. The lambda4 parameter controls the behavior of the upper
          tail.  If lambda4 > 0, then the distribution is bounded
          above at 1/lambda4.  If lambda4 <= 0, then the
          distribution is unbounded above.

       4. The kth moment is finite only if
          min(lambda3,lambda4) > -1/k.  So this distribution
          has finite mean only if min(lambda3,lambda4) > -1
          and finite variance only if min(lambda3,lambda4) > -0.5.

Syntax:
    LET <y> = GLDPPF(<p>,<l3>,<l4>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, number, or parameter in the range (0,1);
          <l3> is a number or parameter that specifies the
               first shape parameter;
          <l4> is a number or parameter that specifies the
               second shape parameter;
          <loc> is a number or parameter that specifies the location
               parameter;
          <scale> is a number or parameter that specifies the scale
               parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed generalized Tukey-Lambda ppf value
               is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    Note that the location and scale parameters are optional.

Examples:
    LET A = GLDPPF(0.9,0.5,0.2)
    LET Y = GLDPPF(P,0.5,0.2)
    PLOT GLDPPF(P,0.5,0.2) FOR P = 0  0.01  1

Note:
    Generalized Tukey-Lambda random numbers, probability plots,
    and goodness of fit tests can be generated with the commands:

       LET LAMBDA3 = <value>
       LET LAMBDA4 = <value>
       LET Y = GENERALIZED TUKEY LAMBDA RANDOM NUMBERS FOR I = 1 1 N
       GENERALIZED TUKEY LAMBDA PROBABILITY PLOT Y
       GENERALIZED TUKEY LAMBDA KOLMOGOROV SMIRNOV GOODNESS OF FIT Y
       GENERALIZED TUKEY LAMBDA CHI-SQUARE GOODNESS OF FIT Y

    The following commands can be used to estimate the shape
    parameters for the generalized Tukey-Lambda distribution:

       LET LAMBDA31 = <value>
       LET LAMBDA32 = <value>
       LET LAMBDA41 = <value>
       LET LAMBDA42 = <value>
       GENERALIZED TUKEY-LAMBDA PPCC PLOT Y

    The default values for LAMBDA31, LAMBDA32, LAMBDA41, and
    LAMBDA42 are -1, 5, -1 and 5, respectively.

    We are still resolving some issues with the
    GENERALIZED TUKEY LAMBDA KS PLOT command, so we recommend
    that you not use this for now.

    Alternatively, you can perform a least squares regression
    fit using the following commands:

        LET Y = SORT Y
        LET N = SIZE Y
        LET PIN = UNIFORM ORDER STATISTIC MEDIANS FOR I = 1 1 N
        FIT Y = GLDPPF(PIN,L3,L4,ALOC,ASCALE)

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GLDCDF            = Compute the generalized Tukey-Lambda
                        cumulative distribution function.
    GLDPDF            = Compute the generalized Tukey-Lambda
                        probability density function.
    LAMPPF            = Compute the Tukey-Lambda probability
                        density function.
    GHPPF             = Compute the g-and-h probability density
                        function.
    JSUPPF            = Compute the Johnson SU probability density
                        function.
    JSBPPF            = Compute the Johnson SB probability density
                        function.
    PPCC PLOT         = Generate a ppcc plot.
    PROBABILITY PLOT  = Generate a probability plot.
 
Reference:
    Ramberg and Schmeiser (1972), "An Approximate Method for
    Generating Symmetric Random Variables", Communications of
    the Association for Computing Machinery, 15, pp. 987-990.
 
    Ramberg and Schmeiser (1974), "An Approximate Method for
    Generating Asymmetric Random Variables", Communications of
    the Association for Computing Machinery, 17, pp. 78-82.
 
    Ozturk and Dale (1985), "Least Squares Estimation of the
    Parameters of the Generalized Lambda Distribution",
    Technometrics, Vol. 27, No. 1, pp. 81-84.

    Friemer, Mudholkar, Kollia, and Lin (1988), "A Study of
    the Generalized Lambda Family", Communications in
    Statistics-Theory and Methods, 17, pp. 3547-3567.

    King and MacGillivray (1999), "A Starship Estimation
    Method for the Generalized Lambda Distributions",
    Australia and New Zealand Journal of Statistics,
    41(3), pp. 353-374.

    Karian and Dudewicz (2000), Fitting Statistical
    Distributions: The Generalized Bootstrap Methods,
    New York, Chapman & Hall.
    
    Su (2005), "A Discretized Approach to Flexibly Fit
    Generalized Lambda Distributions to Data", Journal of
    Modern Applied Statistical Methods, Vol. 4, No. 2,
    pp. 408-424.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/3
 
Program:
    MULTIPLOT 4 4
    MULTIPLOT SCALE FACTOR 2.5
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    LABEL CASE ASIS
    Y1LABEL X
    X1LABEL Probability
    X1LABEL DISPLACEMENT 16
    Y1LABEL DISPLACEMENT 18
    TITLE DISPLACEMENT 2
    LET LAMBDA3 = DATA -0.5 0 0.5 2
    LET LAMBDA4 = DATA -0.5 0 0.5 2
    LOOP FOR K = 1 1 4
        LET L3 = LAMBDA3(K)
        LET XLOW = 0
        IF L3 <= 0
           LET XLOW = 0.01
        END OF IF
        LOOP FOR L = 1 1 4
            LET L4 = LAMBDA4(L)
            LET XUPP = 1
            IF L4 <= 0
               LET XUPP = 0.99
            END OF IF
            TITLE L3 = ^L3, L4 = ^L4
            PLOT GLDPPF(P,L3,L4) FOR P = XLOW  0.01  XUPP
        END OF LOOP
    END OF LOOP
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATION CENTER
    CASE ASIS
    TEXT Generalized Tukey-Lambda Distributions

-----GLOCDF (LET)--------------------------------
 
GLOCDF
 
Name:
    GLOCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the type I generalized logistic
    cumulative distribution function with shape parameter alpha.
 
Description:
    The standard form of the type I generalized logistic
    distribution has the following cumulative distribution function:
       F(x,alpha) = 1/[(1 + EXP(-x))**alpha]
                    -infinity < x < infinity; alpha > 0
 
Syntax:
    LET <y> = GLOCDF(<x>,<alpha>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable or a parameter;
          <alpha> is a number or parameter that specifies
               the value of the shape parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed generalized logistic cdf value is
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GLOCDF(3,2)
    LET X2 = GLOCDF(X1,ALPHA)
 
Note:
    The general form of the type I generalized logistic
    distribution has the following probability density function:
       F(x,alphamu.sigma) = 1/[(1 + EXP(-(x-mu)/sigma))**alpha]
                    -infinity < x < infinity; alpha > 0
    where u is the location parameter and sigma is the scale
    parameter.
 
Note:
    Johnson, Kotz, and Balakrishnan (see Reference section
    below) also define type II, type III, and type IV generalized
    logistic distributions.  These are not currently supported
    by Dataplot.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GLOPDF = Compute the generalized logistic probability density
             function.
    GLOPPF = Compute the generalized logistic percent point
             function.
    LOGPDF = Compute the logistic probability density function.
    NORPDF = Compute the normal probability density function.
    LGNPDF = Compute the logmormal probability density function.
    EXPPDF = Compute the exponential probability density function.
 
Reference:
    "Continuous Univariate Distributions - 2", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994
    (pp. 140-147).
 
Applications:
    Distributunial Modeling
 
Implementation Date:
    1995/12
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE GLOCDF FOR X = -10  0.01  10
    X1LABEL X
    Y1LABEL PROBABILITY
    LET G = DATA 1  2  5  0.5
    LEGEND 1 COORDINATES 25 87
    .
    LOOP FOR K = 1 1 4
       LET GAMMA = G(K)
       LEGEND 1 GAMMA = ^GAMMA
       PLOT GLOCDF(X,GAMMA) FOR X = -10  0.01  10
    END OF LOOP
    END OF MULTIPLOT
 
-----GLOPDF (LET)--------------------------------
 
GLOPDF
 
Name:
    GLOPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the type I generalized logistic
    probability density function with shape parameter alpha.
 
Description:
    The standard form of the type I generalized logistic
    distribution has the following probability density function:
       f(x,alpha) = alpha/{EXP(x)*(1 + EXP(-x))**(alpha+1)}
                    -infinity < x < infinity; alpha > 0
 
Syntax:
    LET <y> = GLOPDF(<x>,<alpha>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable or a parameter;
          <alpha> is a number or parameter that specifies
               the value of the shape parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed generalized logistic pdf value is
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GLOPDF(3,2)
    LET X2 = GLOPDF(X1,ALPHA)
 
Note:
    The general form of the type I generalized logistic
    distribution has the following probability density function:
       f(x,alpha) = alpha/{EXP((x-mu)/sigma)*
                    (1 + EXP(-((x-mu)/sigma)))**(alpha+1)}
                    -infinity < x < infinity; alpha > 0
    where u is the location parameter and sigma is the scale
    parameter.
 
Note:
    Johnson, Kotz, and Balakrishnan (see Reference section
    below) also define type II, type III, and type IV generalized
    logistic distributions.  These are not currently supported
    by Dataplot.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GLOCDF = Compute the generalized logistic cumulative
             distribution function.
    GLOPPF = Compute the generalized logistic percent point
             function.
    LOGPDF = Compute the logistic probability density function.
    NORPDF = Compute the normal probability density function.
    LGNPDF = Compute the logmormal probability density function.
    EXPPDF = Compute the exponential probability density function.
 
Reference:
    "Continuous Univariate Distributions - 2", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994
    (pp. 140-147).
 
Applications:
    Distributunial Modeling
 
Implementation Date:
    1995/12
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE GLOPDF FOR X = -10  0.01  10
    X1LABEL X
    Y1LABEL PROBABILITY
    LET G = DATA 1  2  5  0.5
    LEGEND 1 COORDINATES 25 87
    .
    LOOP FOR K = 1 1 4
       LET GAMMA = G(K)
       LEGEND 1 GAMMA = ^GAMMA
       PLOT GLOPDF(X,GAMMA) FOR X = -10  0.01  10
    END OF LOOP
    END OF MULTIPLOT
 
-----GLOPPF (LET)--------------------------------
 
GLOPPF
 
Name:
    GLOPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the type I generalized logistic
    percent point function with shape parameter alpha.
 
Description:
    The standard form of the type I generalized logistic
    distribution has the following percent point function:
       G(p,alpha) = -LOG[(1 - p**alpha)/(p**alpha)]
 
Syntax:
    LET <y> = GLOPPF(<p>,<alpha>)  <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable or a parameter;
          <alpha> is a number or parameter that specifies
               the value of the shape parameter;
          <y> is a variable or a parameter (depending on what <p> is)
               where the computed generalized logistic ppf value is
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GLOPPF(0.95,2)
    LET X2 = GLOPPF(P,ALPHA)
 
Note:
    The general form of the type I generalized logistic
    distribution has the following percent point function:
       G(p,alpha,mu,sigma) = mu - sigma*LOG[(1-p**alpha)/(p**alpha)]
    where u is the location parameter and sigma is the scale
    parameter.
 
Note:
    Johnson, Kotz, and Balakrishnan (see Reference section
    below) also define type II, type III, and type IV generalized
    logistic distributions.  These are not currently supported
    by Dataplot.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GLOCDF = Compute the generalized logistic cumulative
             distribution function.
    GLOPDF = Compute the generalized logistic probability density
             function.
    LOGPDF = Compute the logistic probability density function.
    NORPDF = Compute the normal probability density function.
    LGNPDF = Compute the logmormal probability density function.
    EXPPDF = Compute the exponential probability density function.
 
Reference:
    "Continuous Univariate Distributions - 2", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994
    (pp. 140-147).
 
Applications:
    Distributunial Modeling
 
Implementation Date:
    1995/12
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE GLOPPF FOR P = 0.01  0.01  0.99
    Y1LABEL X
    X1LABEL PROBABILITY
    LET G = DATA 1  2  5  0.5
    LEGEND 1 COORDINATES 25 87
    XLIMITS 0 1
    MINOR XTIC MARK NUMBER 1
    XTIC DECIMAL 1
    .
    LOOP FOR K = 1 1 4
       LET GAMMA = G(K)
       LEGEND 1 GAMMA = ^GAMMA
       PLOT GLOPPF(P,GAMMA) FOR P = 0.01  0.01  0.99
    END OF LOOP
    END OF MULTIPLOT
 
-----GLSCDF (LET)--------------------------------
 
GLSCDF
 
Name:
    GLSCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized logarithmic series cumulative
    distribution function.
 
Description:
    The generalized logarithmic series distribution has the
    following cumulative distribution function:

       p(x;theta,beta) = Gamma(beta*x+1)*theta**x*
           (1-theta)**(beta*x-x)/
           x!*(beta*x)*Gamma(beta*x-x+1)*[-LOG(1-theta)]
           x = 1, 2, 3, ,...
           0 < theta < 1; 1 <= beta < 1/theta

    with theta and beta denoting the shape parameters and
    Gamma denoting the gamma function (enter HELP GAMMA for
    details).
 
    The cumulative distribution function is computed using the
    following recurrence relation given by Consul and Famoye:

       P(x+1;theta,beta) = (beta - x/(x+1))*theta*
             (1-theta)**(beta-1)*
             PROD[j=1 to x-1][1 + beta/(beta*x-j)]*P(x;theta,beta)

    where

       P(1;theta,beta) = theta*(1-theta)**(beta-1)/
                         {-LOG(1-theta)}

Syntax:
    LET <y> = GLSCDF(<x>,<theta>,<beta>) 
               <SUBSET/EXCEPT/FOR qualification>
    where <x> is a positive integer variable, number, or parameter;
          <theta> is a number, parameter, or variable in the range 
               (0,1) that specifies the first shape parameter;
          <beta> is a number, parameter, or variable that
               specifies the second shape parameter;
          <y> is a variable or a parameter (depending on what <x>
               is) where the computed generalized logarithmic
               series cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GLSCDF(3,0.5,1.4)
    LET Y = GLSCDF(X,0.3,1.6)
    PLOT GLSCDF(X,0.3,1.6) FOR X = 1  1  20

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GLSPDF                   = Compute the generalized logarithmic
                               series probability mass function.
    GLSPPF                   = Compute the generalized logarithmic
                               series percent point function.
    DLGPDF                   = Compute the logarithmic series
                               probability mass function.
    YULPDF                   = Compute the Yule probability
                               mass function.
    ZETPDF                   = Compute the Zeta probability
                               mass function.
    BGEPDF                   = Compute the beta geometric
                               probability mass function.
    POIPDF                   = Compute the Poisson probability
                               mass function.
    BINPDF                   = Compute the binomial probability
                               mass function.
 
Reference:
    Consul and Famoye (2006), "Lagrangian Probability
    Distribution", Birkhauser, chapter 11.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/8
 
Program:
    title size 3
    tic label size 3
    label size 3
    legend size 3
    height 3
    x1label displacement 12
    y1label displacement 15
    .
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    label case asis
    title case asis
    case asis
    tic offset units screen
    tic offset 3 3
    title displacement 2
    y1label Probability
    x1label X
    .
    ylimits 0 1
    major ytic mark number 6
    minor ytic mark number 3
    xlimits 0 20
    line blank
    spike on
    .
    multiplot 2 2
    .
    title Theta = 0.3, Beta = 1.8
    plot glscdf(x,0.3,1.8) for x = 1 1 20
    .
    title Theta = 0.5, Beta = 1.5
    plot glscdf(x,0.5,1.5) for x = 1 1 20
    .
    title Theta = 0.7, Beta = 1.2
    plot glscdf(x,0.7,1.2) for x = 1 1 20
    .
    title Theta = 0.9, Beta = 1.1
    plot glscdf(x,0.9,1.1) for x = 1 1 20
    .
    end of multiplot
    .
    justification center
    move 50 97
    text Cumulative Distribution for Generalized Logarithmic Series

-----GLSPDF (LET)--------------------------------
 
GLSPDF
 
Name:
    GLSPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized logarithmic series probability mass
    function.
 
Description:
    The generalized logarithmic series distribution has the
    following probability mass function:

       p(x;theta,beta) = Gamma(beta*x+1)*theta**x*
           (1-theta)**(beta*x-x)/
           x!*(beta*x)*Gamma(beta*x-x+1)*[-LOG(1-theta)]
           x = 1, 2, 3, ,...
           0 < theta < 1; 1 <= beta < 1/theta

    with theta and beta denoting the shape parameters and
    Gamma denoting the gamma function (enter HELP GAMMA for
    details).
 
    Note that there are several distributions in the literature
    that are called the generalized logarithmic series
    distribution.  We are using the definition given in
    Consul and Famoye (see References below).

Syntax:
    LET <y> = GLSPDF(<x>,<theta>,<beta>) 
               <SUBSET/EXCEPT/FOR qualification>
    where <x> is a positive integer variable, number, or parameter;
          <theta> is a number, parameter, or variable in the range 
               (0,1) that specifies the first shape parameter;
          <beta> is a number, parameter, or variable that
               specifies the second shape parameter;
          <y> is a variable or a parameter (depending on what <x>
               is) where the computed generalized logarithmic
               series pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GLSPDF(3,0.5,1.4)
    LET Y = GLSPDF(X,0.3,1.6)
    PLOT GLSPDF(X,0.3,1.6) FOR X = 1  1  20

Note:
    For a number of commands utilizing the generalized
    logarithmic series distribution, it is convenient to bin
    the data.  There are two basic ways of binning the data.

      1) For some commands (histograms, maximum likelihood
         estimation), bins with equal size widths are
         required.  This can be accomplished with the
         following commands:

            LET AMIN = MINIMUM Y
            LET AMAX = MAXIMUM Y
            LET AMIN2 = AMIN - 0.5
            LET AMAX2 = AMAX + 0.5
            CLASS MINIMUM AMIN2
            CLASS MAXIMUM AMAX2
            CLASS WIDTH 1
            LET Y2 X2 = BINNED

      2) For some commands, unequal width bins may be
         helpful.  In particular, for the chi-square goodness
         of fit, it is typically recommended that the minimum
         class frequency be at least 5.  In this case, it may
         be helpful to combine small frequencies in the tails.
         Unequal class width bins can be created with the
         commands

            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = INTEGER FREQUENCY TABLE Y

         If you already have equal width bins data, you can
         use the commands
         
            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = COMBINE FREQUENCY TABLE Y2 X2

         The MINSIZE parameter defines the minimum class
         frequency.  The default value is 5.

Note:
    You can generate generalized logarithmic series random
    numbers, probability plots, and chi-square goodness of fit
    tests with the following commands:

       LET N = VALUE
       LET THETA = <value>
       LET BETA = <value>
       LET Y = GENERALIZED LOGARITHMIC SERIES ...
               RANDOM NUMBERS FOR I = 1 1 N

       GENERALIZED LOGARITHMIC SERIES PROBABILITY PLOT Y
       GENERALIZED LOGARITHMIC SERIES PROBABILITY PLOT Y2 X2
       GENERALIZED LOGARITHMIC SERIES PROBABILITY PLOT ...
                   Y3 XLOW XHIGH

       GENERALIZED LOGARITHMIC SERIES CHI-SQUARE ...
                   GOODNESS OF FIT Y
       GENERALIZED LOGARITHMIC SERIES CHI-SQUARE ...
                   GOODNESS OF FIT Y2 X2
       GENERALIZED LOGARITHMIC SERIES CHI-SQUARE ...
                   GOODNESS OF FIT Y3 XLOW XHIGH

    To obtain the method of moment estimates, the mean and
    ones frequency estimates, and the maximum likelihood
    estimates of theta and beta, enter the command

        GENERALIZED LOGARITHMIC SERIES MAXIMUM LIKELIHOOD Y
        GENERALIZED LOGARITHMIC SERIES MAXIMUM LIKELIHOOD Y2 X2

    The moment estimate of theta is the solution of the
    equation

        (1-theta)*XBAR**3/alpha**2 - theta**2*(s**2+XBAR**2)  = 0

    with XBAR and s**2 denoting the sample mean and sample
    variance, respectively, and where

        alpha = 1/-LOG(1-theta)

    The moment estimate of beta is then

        beta = (1/theta) - alpha/XBAR

    The mean and ones frequency estimate of theta is the
    solution of the equation

        LOG(theta) + ((1/theta) -
        (1/XBAR)*(-1/LOG(1-theta) - 1)*LOG(1-theta) -
        LOG(-LOG(1-theta)) - LOG(f1/n) = 0

    with f1 and n denoting the ones frequency and sample size,
    respectively.  The estimate of beta is then

        beta = (1/theta) - alpha/XBAR

    The maximum likelihood estimates are the solutions to the
    equations:

        (n*XBAR/theta) - (beta-1)*n*XBAR/(1-theta) +
        n/((1-theta)*LOG(1-theta)) = 0

        n*XBAR*LOG(1-theta) +
        SUM[x=2 to k][SUM[i=1 to x-1][x*n(x)/(beta*x-i)]] = 0

    with n(x) denoting the frequency at the value x.

    You can generate estimates of theta and beta based on the
    maximum ppcc value or the minimum chi-square goodness of fit
    with the commands

        LET THETA1 = <value>
        LET THETA2 = <value>
        LET BETA1  = <value>
        LET BETA2  = <value>
        GENERALIZED LOGARITHMIC SERIES KS PLOT Y
        GENERALIZED LOGARITHMIC SERIES KS PLOT Y2 X2
        GENERALIZED LOGARITHMIC SERIES KS PLOT Y3 XLOW XHIGH
        GENERALIZED LOGARITHMIC SERIES PPCC PLOT Y
        GENERALIZED LOGARITHMIC SERIES PPCC PLOT Y2 X2
        GENERALIZED LOGARITHMIC SERIES PPCC PLOT Y3 XLOW XHIGH

    The default values of theta1 and theta2 are 0.05 and 0.95,
    respectively.  The default values for beta1 and beta2 are
    1.05 and 5, respectively.  Note that values of beta that do
    not lie in the interval 1 <= beta <= 1/theta are skipped.
    Due to the discrete nature of the percent point function
    for discrete distributions, the ppcc plot will not be smooth.
    For that reason, if there is sufficient sample size the
    KS PLOT (i.e., the minimum chi-square value) is typically
    preferred.  However, it may sometimes be useful to perform
    one iteration of the PPCC PLOT to obtain a rough idea of an
    appropriate neighborhood for the shape parameters since the
    minimum chi-square statistic can generate extremely large
    values for non-optimal values of the shape parameters.
    Also, since the data is integer values, one of the binned
    forms is preferred for these commands.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GLSCDF                   = Compute the generalized logarithmic
                               series cumulative distribution
                               function.
    GLSPPF                   = Compute the generalized logarithmic
                               series percent point function.
    DLGPDF                   = Compute the logarithmic series
                               probability mass function.
    YULPDF                   = Compute the Yule probability
                               mass function.
    ZETPDF                   = Compute the Zeta probability
                               mass function.
    BGEPDF                   = Compute the beta geometric
                               probability mass function.
    POIPDF                   = Compute the Poisson probability
                               mass function.
    BINPDF                   = Compute the binomial probability
                               mass function.
    INTEGER FREQUENCY TABLE  = Generate a frequency table at
                               integer values with unequal bins.
    COMBINE FREQUENCY TABLE  = Convert an equal width frequency
                               table to an unequal width frequency
                               table.
    KS PLOT                  = Generate a minimum chi-square plot.
    PPCC PLOT                = Generate a ppcc plot.
    PROBABILITY PLOT         = Generate a probability plot.
    MAXIMUM LIKELIHOOD       = Perform maximum likelihood
                               estimation for a distribution.
 
Reference:
    Consul and Famoye (2006), "Lagrangian Probability
    Distribution", Birkhauser, chapter 11.

    Famoye (1995), "On Certain Methods of Estimation for
    Generalized Logarithmic Series Distribution", Journal of
    Applied Statistical Sciences, 2, pp. 103-117.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/8
 
Program 1:
    title size 3
    tic label size 3
    label size 3
    legend size 3
    height 3
    x1label displacement 12
    y1label displacement 15
    .
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    label case asis
    title case asis
    case asis
    tic offset units screen
    tic offset 3 3
    title displacement 2
    y1label Probability Mass
    x1label X
    .
    ylimits 0 1
    major ytic mark number 6
    minor ytic mark number 3
    xlimits 0 20
    line blank
    spike on
    .
    multiplot 2 2
    .
    title Theta = 0.3, Beta = 1.8
    plot glspdf(x,0.3,1.8) for x = 1 1 20
    .
    title Theta = 0.5, Beta = 1.5
    plot glspdf(x,0.5,1.5) for x = 1 1 20
    .
    title Theta = 0.7, Beta = 1.2
    plot glspdf(x,0.7,1.2) for x = 1 1 20
    .
    title Theta = 0.9, Beta = 1.1
    plot glspdf(x,0.9,1.1) for x = 1 1 20
    .
    end of multiplot
    .
    justification center
    move 50 97
    text Probability Mass Functions for Generalized Logarithmic Series

Program 2:
    LET THETA = 0.7
    LET BETA  = 1.2
    LET Y = GENERALIZED LOGARITHMIC SERIES RANDOM NUMBERS ...
            FOR I = 1 1 500
    .
    LET Y3 XLOW XHIGH = INTEGER FREQUENCY TABLE Y
    CLASS LOWER 0.5
    CLASS WIDTH 1
    LET AMAX = MAXIMUM Y
    LET AMAX2 = AMAX + 0.5
    CLASS UPPER AMAX2
    LET Y2 X2 = BINNED Y
    .
    GENERALIZED LOGARITHMIC SERIES MLE Y
    RELATIVE HISTOGRAM Y2 X2
    LIMITS FREEZE
    PRE-ERASE OFF
    LINE COLOR BLUE
    PLOT GLSPDF(X,THETAML,BETAML) FOR X = 0  1  AMAX
    LIMITS
    PRE-ERASE ON
    LINE COLOR BLACK
    LET THETA = THETAML
    LET BETA  = BETAML
    GENERALIZED LOGARITHMIC SERIES CHI-SQUARE GOODNESS OF FIT ...
        Y3 XLOW XHIGH
    CASE ASIS
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Theta = ^THETAML, Beta = ^BETAML
    MOVE 50 93
    TEXT Minimum Chi-Square = ^STATVAL, 95% CV = ^CUTUPP95
    .
    LABEL CASE ASIS
    X1LABEL Theta
    Y1LABEL Minimum Chi-Square
    GENERALIZED LOGARITHMIC SERIES KS PLOT Y3 XLOW XHIGH
    LET THETA = SHAPE1
    LET BETA  = SHAPE2
    GENERALIZED LOGARITHMIC SERIES CHI-SQUARE GOODNESS OF FIT ...
        Y3 XLOW XHIGH
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Theta = ^THETA, Beta = ^BETAML
    MOVE 50 93
    TEXT Minimum Chi-Square = ^MINKS, 95% CV = ^CUTUPP95

-----GLSPPF (LET)--------------------------------
 
GLSPPF
 
Name:
    GLSPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized logarithmic series percent point
    function.
 
Description:
    The generalized logarithmic series distribution has the
    following probability mass function:

       p(x;theta,beta) = Gamma(beta*x+1)*theta**x*
           (1-theta)**(beta*x-x)/
           x!*(beta*x)*Gamma(beta*x-x+1)*[-LOG(1-theta)]
           x = 1, 2, 3, ,...
           0 < theta < 1; 1 <= beta < 1/theta

    with theta and beta denoting the shape parameters and
    Gamma denoting the gamma function (enter HELP GAMMA for
    details).
 
    The cumulative distribution function is computed using the
    following recurrence relation given by Consul and Famoye:

      p(x+1;theta,beta) = (beta - x/(x+1))*theta*(1-theta)**(beta-1)*
                          PROD[j=1 to x-1][1 + beta/(beta*x-j)]*
                          P(x;theta,beta)

    where

       P(1;theta,beta) = theta*(1-theta)**(beta-1)/
                         {-LOG(1-theta)}

    The percent point function is computed by summing the
    above recurence relation until the the specified probability
    is obtained.

Syntax:
    LET <y> = GLSPPF(<p>,<theta>,<beta>) 
               <SUBSET/EXCEPT/FOR qualification>
    where <p> is a positive integer variable, number, or parameter
               in the range (0,1];
          <theta> is a number, parameter, or variable in the range 
               (0,1) that specifies the first shape parameter;
          <beta> is a number, parameter, or variable that
               specifies the second shape parameter;
          <y> is a variable or a parameter (depending on what <x>
               is) where the computed generalized logarithmic
               series ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GLSPPF(0.95,0.5,1.4)
    LET Y = GLSPPF(P,0.3,1.6)
    PLOT GLSPPF(P,0.3,1.6) FOR P = 0  0.01 0.99

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GLSCDF                   = Compute the generalized logarithmic
                               series cumulative distribution
                               function.
    GLSPDF                   = Compute the generalized logarithmic
                               series probability mass function.
    DLGPDF                   = Compute the logarithmic series
                               probability mass function.
    YULPDF                   = Compute the Yule probability
                               mass function.
    ZETPDF                   = Compute the Zeta probability
                               mass function.
    BGEPDF                   = Compute the beta geometric
                               probability mass function.
    POIPDF                   = Compute the Poisson probability
                               mass function.
    BINPDF                   = Compute the binomial probability
                               mass function.
 
Reference:
    Consul and Famoye (2006), "Lagrangian Probability
    Distribution", Birkhauser, chapter 11.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/8
 
Program:
    title size 3
    tic label size 3
    label size 3
    legend size 3
    height 3
    x1label displacement 12
    y1label displacement 15
    .
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    label case asis
    title case asis
    case asis
    tic offset units screen
    tic offset 3 3
    title displacement 2
    x1label Probability
    y1label X
    .
    xlimits 0 1
    major xtic mark number 6
    minor xtic mark number 3
    .
    multiplot 2 2
    .
    title Theta = 0.3, Beta = 1.8
    plot glsppf(p,0.3,1.8) for p = 0  0.01  0.99
    .
    title Theta = 0.5, Beta = 1.5
    plot glsppf(p,0.5,1.5) for p = 0  0.01  0.99
    .
    title Theta = 0.7, Beta = 1.2
    plot glsppf(p,0.7,1.2) for p = 0  0.01  0.99
    .
    title Theta = 0.9, Beta = 1.1
    plot glsppf(p,0.9,1.1) for p = 0  0.01  0.99
    .
    end of multiplot
    .
    justification center
    move 50 97
    text Percent Points for Generalized Logarithmic Series

-----GLGCDF (LET)--------------------------------
 
GLGCDF
 
Name:
    GLGCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized lost games cumulative distribution
    function.
 
Description:
    The formula for the generalized lost games probability mass
    x function is

        p(x;p,j,a) = (2*x+a-2*j-1)!a*p**(a+x-j)*
                     (1-p)**(x-j)/{(x+a-j)!*(x-j)!}
                     x = j, j + 1, ...; 0.5 < p < 1, a > 0

    with p, j, and a denoting the shape parameters.  The
    j parameter is restricted to non-negative integers.

    The cumulative distribution function is computed from
    the recurrence relation

        p(x;p,j,a) = (2*x+a-2*j-1)*(2*x+a-2*j-2)*p*(1-p)*p(x;p,j,a)/
                     {(x-j)*(x+a-j)}

        p(0;p,j,a)=p**a

Syntax:
    LET <y> = GLGCDF(<x>,<p>,<j>,<a>)
                         <SUBSET/EXCEPT/FOR qualification>
    where <x> is a positive integer variable, number, or
               parameter;
          <p> is a number or parameter in the range (0.5,1)
               that specifies the first shape parameter;
          <j> is a number or parameter denoting a positive
               integer that specifies the second shape parameter;
          <a> is a number or parameter denoting a positive
               integer that specifies the third shape parameter;
          <y> is a variable or a parameter where the computed
               generalized lost games cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GLGCDF(5,0.7,3,2.6)
    LET Y = GLGCDF(X1,0.7,2,4)
    PLOT GLGCDF(X,0.6,5,3) FOR X = 5  1  30
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GLSPDF                   = Compute the generalized lost games
                               probability mass function.
    GLSPPF                   = Compute the generalized lost games
                               percent point function.
    LOSCDF                   = Compute the lost games probability
                               mass function.
    BTACDF                   = Compute the Borel-Tanner probability
                               mass function.
    POICDF                   = Compute the Poisson probability
                               mass function.
    HERCDF                   = Compute the Hermite probability
                               mass function.
    BINCDF                   = Compute the binomial probability
                               mass function.
    NBCDF                    = Compute the negative binomial
                               probability mass function.
    GEOCDF                   = Compute the geometric probability
                               mass function.

Reference:
    Luc Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 758-759.
 
    Kemp and Kemp (1992), "A Group-Dynamic Model and the
    Lost-Games Distribution", Communications in Statistics--
    Theory and Methods, 21(3), pp. 791-798.

    Kemp and Kemp (1968), "On a Distribution Associated with
    Certain Stochastic Processes", Journal of the Royal
    Statistical Society, Series B, 30, pp. 401-410.

    Johnson, Kotz, and Kemp (2006),  "Univariate Discrete
    Distributions", Third Edition, Wiley, pp. 503-505.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/11
 
Program:
    title size 3
    tic label size 3
    label size 3
    legend size 3
    height 3
    x1label displacement 12
    y1label displacement 15
    .
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    label case asis
    title case asis
    case asis
    tic offset units screen
    tic offset 3 3
    title displacement 2
    y1label Probability
    x1label X
    .
    major ytic mark number 6
    minor ytic mark number 3
    ylimits 0 1
    line color black red blue
    .
    multiplot 2 2
    .
    title P = 0.55, J = 4
    x2label Black: A = 4, Red: A = 3, Blue:  A = 5
    plot glgcdf(x,0.55,4,4) for x = 4  1  20 and
    plot glgcdf(x,0.55,4,3) for x = 4  1  20 and
    plot glgcdf(x,0.55,4,5) for x = 4  1  20
    .
    title P = 0.6, J = 4
    x2label Black: A = 4, Red: A = 3, Blue:  A = 5
    plot glgcdf(x,0.6,4,4) for x = 4  1  20 and
    plot glgcdf(x,0.6,4,3) for x = 4  1  20 and
    plot glgcdf(x,0.6,4,5) for x = 4  1  20
    .
    title P = 0.7, J = 4
    x2label Black: A = 4, Red: A = 3, Blue:  A = 5
    plot glgcdf(x,0.7,4,4) for x = 4  1  20 and
    plot glgcdf(x,0.7,4,3) for x = 4  1  20 and
    plot glgcdf(x,0.7,4,5) for x = 4  1  20
    .
    title P = 0.8, J = 4
    x2label Black: A = 4, Red: A = 3, Blue:  A = 5
    plot glgcdf(x,0.8,4,4) for x = 4  1  20 and
    plot glgcdf(x,0.8,4,3) for x = 4  1  20 and
    plot glgcdf(x,0.8,4,5) for x = 4  1  20
    .
    end of multiplot
    .
    justification center
    move 50 97
    text Cumulative Distribution Functions for Generalized Lost Games

-----GLGPDF (LET)--------------------------------
 
GLGPDF
 
Name:
    GLGPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized lost games probability mass function.
 
Description:
    The formula for the generalized lost games probability mass
    x function is

        p(x;p,j,a) = (2*x+a-2*j-1)!a*p**(a+x-j)*
                     (1-p)**(x-j)/{(x+a-j)!*(x-j)!}
                     x = j, j + 1, ...; 0.5 < p < 1, a > 0

    with p, j, and a denoting the shape parameters.  The
    j parameter is restricted to non-negative integers.

    This distribution is a generalization of the lost games
    distribution.  The lost games distribution is used to model
    the "gamblers ruin" problem.  For this problem, p is the
    probability that the gambler loses one unit (1 - p is the
    probability that the gambler wins one unit).  The value of
    j is the number of units the gambler starts with.  The
    lost games distribution is then the distribution of the number
    of games lost until the gambler loses all of his fortune.
    This problem is referred to as the gambler's ruin since if
    the probability of winning is less than 0.5, the gambler will
    eventually lose all of his fortune with probability 1.
    Kemp and Kemp documented the applicability of the lost
    games distribution to a number of different applications.
    Enter HELP LOSPDF for details on the lost games distribution.

    The generalized lost games distribution generalizes the
    lost games distribution with the additional parameter
    "a".  The case where a = j is equivalent to the lost
    games distribution.

Syntax:
    LET <y> = GLGPDF(<x>,<p>,<j>,<a>)
                         <SUBSET/EXCEPT/FOR qualification>
    where <x> is a positive integer variable, number, or
               parameter;
          <p> is a number or parameter in the range (0.5,1)
               that specifies the first shape parameter;
          <j> is a number or parameter denoting a positive
               integer that specifies the second shape parameter;
          <a> is a number or parameter denoting a positive
               integer that specifies the third shape parameter;
          <y> is a variable or a parameter where the computed
               generalized lost games pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GLGPDF(5,0.7,3,2.6)
    LET Y = GLGPDF(X1,0.7,2,4)
    PLOT GLGPDF(X,0.6,5,3) FOR X = 5  1  30
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Note:
    For a number of commands utilizing the generalized lost games
    distribution, it is convenient to bin the data.  There
    are two basic ways of binning the data.

      1) For some commands (histograms, maximum likelihood
         estimation), bins with equal size widths are
         required.  This can be accomplished with the
         following commands:

            LET AMIN = MINIMUM Y
            LET AMAX = MAXIMUM Y
            LET AMIN2 = AMIN - 0.5
            LET AMAX2 = AMAX + 0.5
            CLASS MINIMUM AMIN2
            CLASS MAXIMUM AMAX2
            CLASS WIDTH 1
            LET Y2 X2 = BINNED

      2) For some commands, unequal width bins may be
         helpful.  In particular, for the chi-square goodness
         of fit, it is typically recommended that the minimum
         class frequency be at least 5.  In this case, it may
         be helpful to combine small frequencies in the tails.
         Unequal class width bins can be created with the
         commands

            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = INTEGER FREQUENCY TABLE Y

         If you already have equal width bins data, you can
         use the commands
         
            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = COMBINE FREQUENCY TABLE Y2 X2

         The MINSIZE parameter defines the minimum class
         frequency.  The default value is 5.

Note:
    You can generate generalized lost games random numbers,
    probability plots, and chi-square goodness of fit tests
    with the following commands:

       LET N = VALUE
       LET J = <value>
       LET P = <value>
       LET A = <value>
       LET Y = GENERALIZED LOST GAMES RANDOM NUMBERS FOR I = 1 1 N

       GENERALIZED LOST GAMES PROBABILITY PLOT Y
       GENERALIZED LOST GAMES PROBABILITY PLOT Y2 X2
       GENERALIZED LOST GAMES PROBABILITY PLOT Y3 XLOW XHIGH

       GENERALIZED LOST GAMES CHI-SQUARE GOODNESS OF FIT Y
       GENERALIZED LOST GAMES CHI-SQUARE GOODNESS OF FIT Y2 X2
       GENERALIZED LOST GAMES CHI-SQUARE GOODNESS OF FIT ...
                   Y3 XLOW XHIGH

    To obtain method of moment and maximum likelihood estimates
    for the parameters, enter the commands (the first syntax is
    for unbinned data, the second case is for binned data):

       GENERALIZED LOST GAMES MAXIMUM LIKELIHOOD Y
       GENERALIZED LOST GAMES MAXIMUM LIKELIHOOD Y X

    For the method of moment/maximum likelihood estimates,
    it is assumed that J is known (the typical procedure is
    to shift the distribution based on the minimum data value
    and solve the J = 0 case).  The formulas for these estimates
    are given in the Kemp and Kemp article (see References
    below).

    The method of moment estimates of p and a are then

        phat = 0.5 + {xbar + SQRT[xbar*(xbar+8*s**2)]/{8*s**2}

        ahat = xbar*(1/(1-phat) - 2)

    with xbar and s**2 denoting the sample mean and variance,
    respectively.

    The maximum likelihood estimates are:

       1) Use the minimum value as the estimate of J and then
          shift the data to start at zero.

       2) To obtain the estimates for p and a, solve the
          follwing simultaneous equations.

             N*SUM[x >=0 ][f(x)*{(a+x)/p - x/(1-p)} = 0

             N*SUM[x >= 0][f(x)*{LOG(p) + 1/a + PSI(a+2*x) - 
               PSI(a+x-1)}] = 0

          with N, f(x), and PSI denoting the total sample
          size, the frequency for calss X = x, and the 
          digamma function, respectively.

          The second equation can also be written as


             N*LOG(p) + (N*(1-f(0))/a +
               N*SUM[x >= 2][f(x)*SUM[k=1 to x-1][1/(a+x+k)]]
               = 0

    For a given value of j, generate estimates of p and a based
    on the maximum ppcc value or the minimum chi-square goodness
    of fit with the commands

        LET J = <value>
        LET P1 = <value>
        LET P2 = <value>
        LET A1 = <value>
        LET A2 = <value>
        GENERALIZED LOST GAMES KS PLOT Y
        GENERALIZED LOST GAMES KS PLOT Y2 X2
        GENERALIZED LOST GAMES KS PLOT Y3 XLOW XHIGH
        GENERALIZED LOST GAMES PPCC PLOT Y
        GENERALIZED LOST GAMES PPCC PLOT Y2 X2
        GENERALIZED LOST GAMES PPCC PLOT Y3 XLOW XHIGH

    The default values of p1 and p2 are 0.55 and 0.95,
    respectively.  The default values of a1 and a2 are 0.5 and
    10.  The value of j should typically be set to the minimum
    value of the data.  Due to the discrete nature of the percent
    point function for discrete distributions, the ppcc plot will
    not be smooth.  For that reason, if there is sufficient sample
    size the KS PLOT (i.e., the minimum chi-square value) is
    typically preferred.  Also, since the data is integer values,
    one of the binned forms is preferred for these commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GLSCDF                   = Compute the generalized lost games
                               cumulative distribution function.
    GLSPPF                   = Compute the generalized lost games
                               percent point function.
    LOSPDF                   = Compute the lost games probability
                               mass function.
    BTAPDF                   = Compute the Borel-Tanner probability
                               mass function.
    POIPDF                   = Compute the Poisson probability
                               mass function.
    HERPDF                   = Compute the Hermite probability
                               mass function.
    BINPDF                   = Compute the binomial probability
                               mass function.
    NBPDF                    = Compute the negative binomial
                               probability mass function.
    GEOPDF                   = Compute the geometric probability
                               mass function.
    INTEGER FREQUENCY TABLE  = Generate a frequency table at
                               integer values with unequal bins.
    COMBINE FREQUENCY TABLE  = Convert an equal width frequency
                               table to an unequal width frequency
                               table.
    KS PLOT                  = Generate a minimum chi-square plot.

Reference:
    Luc Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 758-759.
 
    Kemp and Kemp (1992), "A Group-Dynamic Model and the
    Lost-Games Distribution", Communications in Statistics--
    Theory and Methods, 21(3), pp. 791-798.

    Kemp and Kemp (1968), "On a Distribution Associated with
    Certain Stochastic Processes", Journal of the Royal
    Statistical Society, Series B, 30, pp. 401-410.

    Johnson, Kotz, and Kemp (2006),  "Univariate Discrete
    Distributions", Third Edition, Wiley, pp. 503-505.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/11
 
Program 1:
    title size 3
    tic label size 3
    label size 3
    legend size 3
    height 3
    x1label displacement 12
    y1label displacement 15
    .
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    label case asis
    title case asis
    case asis
    tic offset units screen
    tic offset 3 3
    title displacement 2
    y1label Probability Mass
    x1label X
    .
    major ytic mark number 6
    minor ytic mark number 3
    xlimits 0 20
    line color black red blue
    .
    multiplot 2 2
    .
    title P = 0.55, J = 4
    x2label Black: A = 4, Red: A = 3, Blue:  A = 5
    plot glgpdf(x,0.55,4,4) for x = 4  1  20 and
    plot glgpdf(x,0.55,4,3) for x = 4  1  20 and
    plot glgpdf(x,0.55,4,5) for x = 4  1  20
    .
    title P = 0.6, J = 4
    x2label Black: A = 4, Red: A = 3, Blue:  A = 5
    plot glgpdf(x,0.6,4,4) for x = 4  1  20 and
    plot glgpdf(x,0.6,4,3) for x = 4  1  20 and
    plot glgpdf(x,0.6,4,5) for x = 4  1  20
    .
    title P = 0.7, J = 4
    x2label Black: A = 4, Red: A = 3, Blue:  A = 5
    plot glgpdf(x,0.7,4,4) for x = 4  1  20 and
    plot glgpdf(x,0.7,4,3) for x = 4  1  20 and
    plot glgpdf(x,0.7,4,5) for x = 4  1  20
    .
    title P = 0.8, J = 4
    x2label Black: A = 4, Red: A = 3, Blue:  A = 5
    plot glgpdf(x,0.8,4,4) for x = 4  1  20 and
    plot glgpdf(x,0.8,4,3) for x = 4  1  20 and
    plot glgpdf(x,0.8,4,5) for x = 4  1  20
    .
    end of multiplot
    .
    justification center
    move 50 97
    text Probability Mass Functions for Generalized Lost Games

Program 2:
    let j = 3
    let p = 0.6
    let a = 4.2
    let y = generalized lost games random numbers for i = 1 1 500
    .
    let y3 xlow xhigh = integer frequency table y
    class lower 2.5
    class width 1
    let amax = maximum y
    let amax2 = amax + 0.5
    class upper amax2
    let y2 x2 = binned y
    let y3 xlow xhigh = combine frequency table y2 x2
    .
    generalized lost games mle y2 x2
    .
    let p = pml
    let a = aml
    generalized lost games chi-square goodness of fit y3 xlow xhigh
    .
    label case asis
    x1label A (Curves Represent Values of P)
    y1label Minimum Chi-Square
    let p1 = 0.55
    let p2 = 0.95
    let a1 = 0.5
    let a2 = 10
    generalized lost games ks plot y3 xlow xhigh
    let p = shape1
    let a = shape2
    case asis
    justification center
    move 50 5
    text P = ^p, A = ^a
    generalized lost games chi-square goodness of fit y3 xlow xhigh
    .
    relative histogram y2 x2
    limits freeze
    pre-erase off
    line color blue
    label
    title Generalized Lost Games Fit: Phat = ^p, Ahat = ^a (j = ^j)
    plot glgpdf(x,p,j,a) for x = r  1  amax
    title
    limits
    pre-erase on
    line color black
 
-----GLGPPF (LET)--------------------------------
 
GLGPPF
 
Name:
    GLGPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized lost games percent point
    function.
 
Description:
    The formula for the generalized lost games probability mass
    x function is

        p(x;p,j,a) = (2*x+a-2*j-1)!a*p**(a+x-j)*
                     (1-p)**(x-j)/{(x+a-j)!*(x-j)!}
                     x = j, j + 1, ...; 0.5 < p < 1, a > 0

    with p, j, and a denoting the shape parameters.  The
    j parameter is restricted to non-negative integers.

    The cumulative distribution function is computed from
    the recurrence relation

        p(x;p,j,a) = (2*x+a-2*j-1)*(2*x+a-2*j-2)*p*(1-p)*p(x;p,j,a)/
                     {(x-j)*(x+a-j)}

        p(0;p,j,a)=p**a

    The percent point function is computed by generating the
    cumulative distribution function until the appropriate
    probability is reached.

Syntax:
    LET <y> = GLGPPF(<x>,<p>,<j>,<a>)
                         <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter in the range
               (0,1);
          <p> is a number or parameter in the range (0.5,1)
               that specifies the first shape parameter;
          <j> is a number or parameter denoting a positive
               integer that specifies the second shape parameter;
          <a> is a number or parameter denoting a positive
               integer that specifies the third shape parameter;
          <y> is a variable or a parameter where the computed
               generalized lost games ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GLGPPF(0.95,0.7,3,2.6)
    LET Y = GLGPPF(P1,0.7,2,4)
    PLOT GLGPPF(P,0.6,5,3) FOR P = 0  0.01  0.99
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GLSCDF                   = Compute the generalized lost games
                               cumulative distribution function.
    GLSPDF                   = Compute the generalized lost games
                               probability mass function.
    LOSPPF                   = Compute the lost games probability
                               mass function.
    BTAPPF                   = Compute the Borel-Tanner probability
                               mass function.
    POIPPF                   = Compute the Poisson probability
                               mass function.
    HERPPF                   = Compute the Hermite probability
                               mass function.
    BINPPF                   = Compute the binomial probability
                               mass function.
    NBPPF                    = Compute the negative binomial
                               probability mass function.
    GEOPPF                   = Compute the geometric probability
                               mass function.

Reference:
    Luc Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 758-759.
 
    Kemp and Kemp (1992), "A Group-Dynamic Model and the
    Lost-Games Distribution", Communications in Statistics--
    Theory and Methods, 21(3), pp. 791-798.

    Kemp and Kemp (1968), "On a Distribution Associated with
    Certain Stochastic Processes", Journal of the Royal
    Statistical Society, Series B, 30, pp. 401-410.

    Johnson, Kotz, and Kemp (2006),  "Univariate Discrete
    Distributions", Third Edition, Wiley, pp. 503-505.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/11
 
Program:
    title size 3
    tic label size 3
    label size 3
    legend size 3
    height 3
    x1label displacement 12
    y1label displacement 15
    .
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    label case asis
    title case asis
    case asis
    tic offset units screen
    tic offset 3 3
    title displacement 2
    x1label Probability
    y1label X
    .
    major xtic mark number 6
    minor xtic mark number 3
    xlimits 0 1
    line color black red blue
    .
    multiplot 2 2
    .
    title P = 0.55, J = 4
    x2label Black: A = 4, Red: A = 3, Blue:  A = 5
    plot glgcdf(x,0.55,4,4) for x = 0  0.01  0.99 and
    plot glgcdf(x,0.55,4,3) for x = 0  0.01  0.99 and
    plot glgcdf(x,0.55,4,5) for x = 0  0.01  0.99
    .
    title P = 0.6, J = 4
    x2label Black: A = 4, Red: A = 3, Blue:  A = 5
    plot glgcdf(x,0.6,4,4) for x = 0  0.01  0.99 and
    plot glgcdf(x,0.6,4,3) for x = 0  0.01  0.99 and
    plot glgcdf(x,0.6,4,5) for x = 0  0.01  0.99
    .
    title P = 0.7, J = 4
    x2label Black: A = 4, Red: A = 3, Blue:  A = 5
    plot glgcdf(x,0.7,4,4) for x = 0  0.01  0.99 and
    plot glgcdf(x,0.7,4,3) for x = 0  0.01  0.99 and
    plot glgcdf(x,0.7,4,5) for x = 0  0.01  0.99
    .
    title P = 0.8, J = 4
    x2label Black: A = 4, Red: A = 3, Blue:  A = 5
    plot glgcdf(x,0.8,4,4) for x = 0  0.01  0.99 and
    plot glgcdf(x,0.8,4,3) for x = 0  0.01  0.99 and
    plot glgcdf(x,0.8,4,5) for x = 0  0.01  0.99
    .
    end of multiplot
    .
    justification center
    move 50 97
    text Percent Point Functions for Generalized Lost Games

-----GL2CDF (LET)--------------------------------
 
GL2CDF
 
Name:
    GL2CDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the type 2 generalized logistic cumulative
    distribution function with shape parameter alpha.
 
Description:
    The standard form of the type 2 generalized logistic
    distribution has the cumulative distribution function:

       F(x;alpha) = 1 - EXP(-alpha*x)/(1 + EXP(-x))**(alpha)
                    alpha > 0
 
    The general form of the type 2 generalized logistic
    cumulative distribution function can be obtained by replacing
    x in the above formula with (x-loc)/scale.

Syntax:
    LET <y> = GL2CDF(<x>,<alpha>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number or parameter;
          <alpha> is a number or parameter that specifies
               the value of the shape parameter;
          <loc> is a number or parameter that specifies
               the value of the location parameter;
          <scale> is a number or parameter that specifies
               the value of the scale parameter;
          <y> is a variable or a parameter (depending on what
               <x> is) where the computed generalized logistic
               type 2 cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The location and scale parameters are optional.

Examples:
    LET A = GL2CDF(3,2)
    LET X2 = GL2CDF(X1,ALPHA)
    PLOT GL2CDF(X,ALPHA) FOR X = -5  0.01  5
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GL2CDF = Compute the generalized logistic type 2
             cumulative distribution function.
    GL2PPF = Compute the generalized logistic type 2
             percent point function.
    GLOPDF = Compute the generalized logistic type 1
             probability density function.
    GL3PDF = Compute the generalized logistic type 3
             probability density function.
    GL4PDF = Compute the generalized logistic type 4
             probability density function.
    GL5PDF = Compute the generalized logistic (Hosking
             parameterization) probability density function.
    LOGPDF = Compute the logistic probability density function.
    NORPDF = Compute the normal probability density function.
    LGNPDF = Compute the logmormal probability density function.
 
Reference:
    "Continuous Univariate Distributions - 2", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994
    (pp. 140-147).
 
Applications:
    Distributunial Modeling
 
Implementation Date:
    2006/3
 
Program:
    LET A = DATA 0.5  1  2  5
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE DISPLACEMENT 2
    X1LABEL X
    Y1LABEL Probability
    X1LABEL DISPLACEMENT 12
    Y1LABEL DISPLACEMENT 15
    .
    LOOP FOR K = 1 1 4
       LET ALPHA = A(K)
       TITLE Alpha = ^ALPHA
       PLOT GL2CDF(X,ALPHA) FOR X = -5  0.01  5
    END OF LOOP
    END OF MULTIPLOT
    CASE ASIS
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT Generalized Logistic Type 2 CDF's
 
-----GL2PDF (LET)--------------------------------
 
GL2PDF
 
Name:
    GL2PDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the type 2 generalized logistic probability
    density function with shape parameter alpha.
 
Description:
    The standard form of the type 2 generalized logistic
    distribution has the probability density function:

       f(x;alpha) = alpha*EXP(x)/(1 + EXP(x))**(alpha+1)
                    alpha > 0
 
    The general form of the type 2 generalized logistic
    probability density function can be obtained by replacing
    x in the above formula with (x-loc)/scale.

Syntax:
    LET <y> = GL2PDF(<x>,<alpha>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number or parameter;
          <alpha> is a number or parameter that specifies
               the value of the shape parameter;
          <loc> is a number or parameter that specifies
               the value of the location parameter;
          <scale> is a number or parameter that specifies
               the value of the scale parameter;
          <y> is a variable or a parameter (depending on what
               <x> is) where the computed generalized logistic
               type 2 pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The location and scale parameters are optional.

Examples:
    LET A = GL2PDF(3,2)
    LET X2 = GL2PDF(X1,ALPHA)
    PLOT GL2PDF(X,ALPHA) FOR X = -5  0.01  5
 
Note:
    For the type 2 parameterization, a value of alpha = 1 results
    in the logistic distribution.  Values of alpha < 1 result in
    left-skewed distributions and values of alpha > 1 result in
    right-skewed distributions.

Note:
    Generalized logistic type 2 random numbers, probability plots,
    and goodness of fit tests can be generated with the commands:

       LET ALPHA = <value>
       LET Y = GENERALIZED LOGISTIC TYPE 2 RANDOM NUMBERS ...
               FOR I = 1 1 N
       GENERALIZED LOGISTIC TYPE 2 PROBABILITY PLOT Y
       GENERALIZED LOGISTIC TYPE 2 KOLMOGOROV SMIRNOV GOODNESS ...
               OF FIT Y
       GENERALIZED LOGISTIC TYPE 2 CHI-SQUARE GOODNESS OF FIT Y

    The following commands can be used to estimate the shape
    parameter for the generalized logistic type 2 distribution:

       LET ALPHA1 = <value>
       LET ALPHA2 = <value>
       GENERALIZED LOGISTIC TYPE 2 PPCC PLOT Y
       GENERALIZED LOGISTIC TYPE 2 KS PLOT Y

    The default values for ALPHA1 and ALPHA2 are 0.1 and
    10, respectively.

    Bootstrap samples for these plots can be obtained with the
    commands

       LET ALPHA1 = <value>
       LET ALPHA2 = <value>
       BOOTSTRAP GENERALIZED LOGISTIC TYPE 2 PLOT Y
       BOOTSTRAP GENERALIZED LOGISTIC TYPE 2 KS PLOT Y

Note:
    Johnson, Kotz, and Balakrishnan (see Reference section
    below) also define type 1, type 3, type 4, and a
    parameterization due to Hoskings generalized logistic
    distributions.  These are also supported by Dataplot
    (see the Related Commands section below).

    If a random variable, X, follows a type 2 generalized logistic
    distribution, then -X follows a type 1 generalized logistic
    distribution.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GL2CDF = Compute the generalized logistic type 2
             cumulative distribution function.
    GL2PPF = Compute the generalized logistic type 2
             percent point function.
    GLOPDF = Compute the generalized logistic type 1
             probability density function.
    GL3PDF = Compute the generalized logistic type 3
             probability density function.
    GL4PDF = Compute the generalized logistic type 4
             probability density function.
    GL5PDF = Compute the generalized logistic (Hosking
             parameterization) probability density function.
    LOGPDF = Compute the logistic probability density function.
    NORPDF = Compute the normal probability density function.
    LGNPDF = Compute the logmormal probability density function.
 
Reference:
    "Continuous Univariate Distributions - 2", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994
    (pp. 140-147).
 
Applications:
    Distributunial Modeling
 
Implementation Date:
    2006/3
 
Program:
    LET A = DATA 0.5  1  2  5
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE DISPLACEMENT 2
    X1LABEL X
    Y1LABEL Probability Density
    X1LABEL DISPLACEMENT 12
    Y1LABEL DISPLACEMENT 15
    .
    LOOP FOR K = 1 1 4
       LET ALPHA = A(K)
       TITLE Alpha = ^ALPHA
       PLOT GL2PDF(X,ALPHA) FOR X = -5  0.01  5
    END OF LOOP
    END OF MULTIPLOT
    CASE ASIS
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT Generalized Logistic Type 2 PDF's
 
-----GL2PPF (LET)--------------------------------
 
GL2PPF
 
Name:
    GL2PPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the type 2 generalized logistic percent point
    function with shape parameter alpha.
 
Description:
    The standard form of the type 2 generalized logistic
    distribution has the cumulative distribution function:

       F(x;alpha) = 1 - EXP(-alpha*x)/(1 + EXP(-x))**(alpha)
                    alpha > 0

    The generalized logistic type 2 percent point function is
    computed by numerically inverting the cumulative
    distribution function.

    The general form of the type 2 generalized logistic
    cumulative distribution function can be obtained by replacing
    x in the above formula with (x-loc)/scale.

Syntax:
    LET <y> = GL2PPF(<p>,<alpha>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, number or parameter;
          <alpha> is a number or parameter that specifies
               the value of the shape parameter;
          <loc> is a number or parameter that specifies
               the value of the location parameter;
          <scale> is a number or parameter that specifies
               the value of the scale parameter;
          <y> is a variable or a parameter (depending on what
               <p> is) where the computed generalized logistic
               type 2 ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The location and scale parameters are optional.

Examples:
    LET A = GL2PPF(0.95,2)
    LET X2 = GL2PPF(P1,ALPHA)
    PLOT GL2PPF(P,ALPHA) FOR P = 0.01  0.01  0.99
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GL2CDF = Compute the generalized logistic type 2
             cumulative distribution function.
    GL2PDF = Compute the generalized logistic type 2
             porbability density function.
    GLOPDF = Compute the generalized logistic type 1
             probability density function.
    GL3PDF = Compute the generalized logistic type 3
             probability density function.
    GL4PDF = Compute the generalized logistic type 4
             probability density function.
    GL5PDF = Compute the generalized logistic (Hosking
             parameterization) probability density function.
    LOGPDF = Compute the logistic probability density function.
    NORPDF = Compute the normal probability density function.
    LGNPDF = Compute the logmormal probability density function.
 
Reference:
    "Continuous Univariate Distributions - 2", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994
    (pp. 140-147).
 
Applications:
    Distributunial Modeling
 
Implementation Date:
    2006/3
 
Program:
    LET A = DATA 0.5  1  2  5
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE DISPLACEMENT 2
    Y1LABEL X
    X1LABEL Probability
    X1LABEL DISPLACEMENT 12
    Y1LABEL DISPLACEMENT 15
    .
    LOOP FOR K = 1 1 4
       LET ALPHA = A(K)
       TITLE Alpha = ^ALPHA
       PLOT GL2PPF(P,ALPHA) FOR P = 0.01  0.01  0.99
    END OF LOOP
    END OF MULTIPLOT
    CASE ASIS
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT Generalized Logistic Type 2 PPF's
 
-----GL3CDF (LET)--------------------------------
 
GL3CDF
 
Name:
    GL3CDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the type 3 generalized logistic cumulative
    distribution function with shape parameter alpha.
 
Description:
    The standard form of the type 3 generalized logistic
    distribution has the probability density function:

       f(x;alpha) = (1/BETA(alpha,alpha))*
                    EXP(-alpha*x)/(1 + EXP(-x))**(2*alpha)
                    alpha > 0
 
    The general form of the type 3 generalized logistic
    probability density function can be obtained by replacing
    x in the above formula with (x-loc)/scale.

    The generalized logistic type 3 cumulative distribution
    function is computed by numerically integrating the
    probability density function.  Dataplot uses the DQAGI
    routine from the Slatec library to perform the
    integration.

Syntax:
    LET <y> = GL3CDF(<x>,<alpha>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number or parameter;
          <alpha> is a number or parameter that specifies
               the value of the shape parameter;
          <loc> is a number or parameter that specifies
               the value of the location parameter;
          <scale> is a number or parameter that specifies
               the value of the scale parameter;
          <y> is a variable or a parameter (depending on what
               <x> is) where the computed generalized logistic
               type 3 cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The location and scale parameters are optional.

Examples:
    LET A = GL3CDF(3,2)
    LET X2 = GL3CDF(X1,ALPHA)
    PLOT GL3CDF(X,ALPHA) FOR X = -5  0.01  5
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GL3PDF = Compute the generalized logistic type 3
             probability density function.
    GL3PPF = Compute the generalized logistic type 3
             percent point function.
    GLOCDF = Compute the generalized logistic type 1
             probability density function.
    GL2CDF = Compute the generalized logistic type 2
             probability density function.
    GL4CDF = Compute the generalized logistic type 4
             probability density function.
    GL5CDF = Compute the generalized logistic (Hosking
             parameterization) probability density function.
    LOGCDF = Compute the logistic probability density function.
    NORCDF = Compute the normal probability density function.
    LGNCDF = Compute the logmormal probability density function.
 
Reference:
    "Continuous Univariate Distributions - 2", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994
    (pp. 140-147).
 
Applications:
    Distributunial Modeling
 
Implementation Date:
    2006/3
 
Program:
    LET A = DATA 0.5  1  2  5
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE DISPLACEMENT 2
    X1LABEL X
    Y1LABEL Probability
    X1LABEL DISPLACEMENT 12
    Y1LABEL DISPLACEMENT 15
    .
    LOOP FOR K = 1 1 4
       LET ALPHA = A(K)
       TITLE Alpha = ^ALPHA
       PLOT GL3CDF(X,ALPHA) FOR X = -5  0.01  5
    END OF LOOP
    END OF MULTIPLOT
    CASE ASIS
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT Generalized Logistic Type 3 CDF's
 
-----GL3PDF (LET)--------------------------------
 
GL3PDF
 
Name:
    GL3PDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the type 3 generalized logistic probability
    density function with shape parameter alpha.
 
Description:
    The standard form of the type 3 generalized logistic
    distribution has the probability density function:

       f(x;alpha) = (1/BETA(alpha,alpha))*
                    EXP(-alpha*x)/(1 + EXP(-x))**(2*alpha)
                    alpha > 0
 
    The general form of the type 3 generalized logistic
    probability density function can be obtained by replacing
    x in the above formula with (x-loc)/scale.

Syntax:
    LET <y> = GL3PDF(<x>,<alpha>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number or parameter;
          <alpha> is a number or parameter that specifies
               the value of the shape parameter;
          <loc> is a number or parameter that specifies
               the value of the location parameter;
          <scale> is a number or parameter that specifies
               the value of the scale parameter;
          <y> is a variable or a parameter (depending on what
               <x> is) where the computed generalized logistic
               type 3 pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The location and scale parameters are optional.

Examples:
    LET A = GL3PDF(3,2)
    LET X2 = GL3PDF(X1,ALPHA)
    PLOT GL3PDF(X,ALPHA) FOR X = -5  0.01  5
 
Note:
    The generalized logistic type 3 distribution is symmetric
    for all values of alpha.  A value of alpha = 1 results
    in the logistic distribution.  Values of alpha < 1 result in
    in heavier tails than the logistic distribution while values
    of alpha > 1 result in shorter tails than the logistic
    distribution.

Note:
    Generalized logistic type 3 random numbers, probability plots,
    and goodness of fit tests can be generated with the commands:

       LET ALPHA = <value>
       LET Y = GENERALIZED LOGISTIC TYPE 3 RANDOM NUMBERS ...
               FOR I = 1 1 N
       GENERALIZED LOGISTIC TYPE 3 PROBABILITY PLOT Y
       GENERALIZED LOGISTIC TYPE 3 KOLMOGOROV SMIRNOV GOODNESS ...
               OF FIT Y
       GENERALIZED LOGISTIC TYPE 3 CHI-SQUARE GOODNESS OF FIT Y

    The following commands can be used to estimate the shape
    parameter for the generalized logistic type 3 distribution:

       LET ALPHA1 = <value>
       LET ALPHA2 = <value>
       GENERALIZED LOGISTIC TYPE 3 PPCC PLOT Y
       GENERALIZED LOGISTIC TYPE 3 KS PLOT Y

    The default values for ALPHA1 and ALPHA2 are 0.1 and 3,
    respectively.

Note:
    Johnson, Kotz, and Balakrishnan (see Reference section
    below) also define type 1, type 3, type 4, and a
    parameterization due to Hoskings generalized logistic
    distributions.  These are also supported by Dataplot
    (see the Related Commands section below).

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GL3CDF = Compute the generalized logistic type 3
             cumulative distribution function.
    GL3PPF = Compute the generalized logistic type 3
             percent point function.
    GLOPDF = Compute the generalized logistic type 1
             probability density function.
    GL2PDF = Compute the generalized logistic type 2
             probability density function.
    GL4PDF = Compute the generalized logistic type 4
             probability density function.
    GL5PDF = Compute the generalized logistic (Hosking
             parameterization) probability density function.
    LOGPDF = Compute the logistic probability density function.
    NORPDF = Compute the normal probability density function.
    LGNPDF = Compute the logmormal probability density function.
 
Reference:
    "Continuous Univariate Distributions - 2", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994
    (pp. 140-147).
 
Applications:
    Distributunial Modeling
 
Implementation Date:
    2006/3
 
Program:
    LET A = DATA 0.5  1  2  5
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE DISPLACEMENT 2
    X1LABEL X
    Y1LABEL Probability Density
    X1LABEL DISPLACEMENT 12
    Y1LABEL DISPLACEMENT 15
    .
    LOOP FOR K = 1 1 4
       LET ALPHA = A(K)
       TITLE Alpha = ^ALPHA
       PLOT GL3PDF(X,ALPHA) FOR X = -5  0.01  5
    END OF LOOP
    END OF MULTIPLOT
    CASE ASIS
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT Generalized Logistic Type 3 PDF's
 
-----GL3PPF (LET)--------------------------------
 
GL3PPF
 
Name:
    GL3PPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the type 3 generalized logistic percent
    point function with shape parameter alpha.
 
Description:
    The standard form of the type 3 generalized logistic
    distribution has the probability density function:

       f(x;alpha) = (1/BETA(alpha,alpha))*
                    EXP(-alpha*x)/(1 + EXP(-x))**(2*alpha)
                    alpha > 0
 
    The general form of the type 3 generalized logistic
    probability density function can be obtained by replacing
    x in the above formula with (x-loc)/scale.

    The generalized logistic type 3 cumulative distribution
    function is computed by numerically integrating the
    probability density function.  Dataplot uses the DQAGI
    routine from the Slatec library to perform the
    integration.  The percent point function is then
    computed by numerically inverting the cumulative
    distribution function.

Syntax:
    LET <y> = GL3PPF(<p>,<alpha>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, number or parameter in the range
               [0,1];
          <alpha> is a number or parameter that specifies
               the value of the shape parameter;
          <loc> is a number or parameter that specifies
               the value of the location parameter;
          <scale> is a number or parameter that specifies
               the value of the scale parameter;
          <y> is a variable or a parameter (depending on what
               <p> is) where the computed generalized logistic
               type 3 ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The location and scale parameters are optional.

Examples:
    LET A = GL3PPF(0.95,2)
    LET X2 = GL3PPF(P1,ALPHA)
    PLOT GL3PPF(P,ALPHA) FOR P = 0.01  0.01  0.99
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GL3CDF = Compute the generalized logistic type 3
             cumulative distribution function.
    GL3PDF = Compute the generalized logistic type 3
             probability density function.
    GLOCDF = Compute the generalized logistic type 1
             probability density function.
    GL2CDF = Compute the generalized logistic type 2
             probability density function.
    GL4CDF = Compute the generalized logistic type 4
             probability density function.
    GL5CDF = Compute the generalized logistic (Hosking
             parameterization) probability density function.
    LOGCDF = Compute the logistic probability density function.
    NORCDF = Compute the normal probability density function.
    LGNCDF = Compute the logmormal probability density function.
 
Reference:
    "Continuous Univariate Distributions - 2", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994
    (pp. 140-147).
 
Applications:
    Distributunial Modeling
 
Implementation Date:
    2006/3
 
Program:
    LET A = DATA 0.5  1  2  5
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE DISPLACEMENT 2
    Y1LABEL X
    X1LABEL Probability
    X1LABEL DISPLACEMENT 12
    Y1LABEL DISPLACEMENT 15
    .
    LOOP FOR K = 1 1 4
       LET ALPHA = A(K)
       TITLE Alpha = ^ALPHA
       PLOT GL3PPF(P,ALPHA) FOR P = 0.01  0.01  0.99
    END OF LOOP
    END OF MULTIPLOT
    CASE ASIS
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT Generalized Logistic Type 3 PPF's
 
-----GL4CDF (LET)--------------------------------
 
GL4CDF
 
Name:
    GL4CDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the type 4 generalized logistic cumulative
    distribution function with shape parameters p and q.
 
Description:
    The standard form of the type 4 generalized logistic
    distribution has the probability density function:

       f(x;p,q) = (1/BETA(p,q))*
                    EXP(-q*x)/(1 + EXP(-x))**(p+q)
                    p, q > 0
 
    The general form of the type 4 generalized logistic
    probability density function can be obtained by replacing
    x in the above formula with (x-loc)/scale.

    The generalized logistic type 4 cumulative distribution
    function is computed by numerically integrating the
    probability density function.  Dataplot uses the DQAGI
    routine from the Slatec library to perform the
    integration.
    
Syntax:
    LET <y> = GL4CDF(<x>,<p>,<q>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number or parameter;
          <p> is a number or parameter that specifies
               the value of the first shape parameter;
          <q> is a number or parameter that specifies
               the value of the second shape parameter;
          <loc> is a number or parameter that specifies
               the value of the location parameter;
          <scale> is a number or parameter that specifies
               the value of the scale parameter;
          <y> is a variable or a parameter (depending on what
               <x> is) where the computed generalized logistic
               type 4 cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The location and scale parameters are optional.

Examples:
    LET A = GL4CDF(3,2,0.5)
    LET X2 = GL4CDF(X1,P,Q)
    PLOT GL4CDF(X,P,Q) FOR X = -5  0.01  5
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GL4PDF = Compute the generalized logistic type 4
             probability density function.
    GL4PPF = Compute the generalized logistic type 4
             percent point function.
    GLOCDF = Compute the generalized logistic type 1
             probability density function.
    GL2CDF = Compute the generalized logistic type 2
             probability density function.
    GL3CDF = Compute the generalized logistic type 3
             probability density function.
    GL5CDF = Compute the generalized logistic (Hosking
             parameterization) probability density function.
    LOGCDF = Compute the logistic probability density function.
    NORCDF = Compute the normal probability density function.
    LGNCDF = Compute the logmormal probability density function.
 
Reference:
    "Continuous Univariate Distributions - 2", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994
    (pp. 140-147).
 
Applications:
    Distributunial Modeling
 
Implementation Date:
    2006/3
 
Program:
    LET PA = DATA 0.5  1  2
    LET QA = DATA 0.5  1  2
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 3
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE DISPLACEMENT 2
    X1LABEL X
    Y1LABEL Probability
    X1LABEL DISPLACEMENT 14
    Y1LABEL DISPLACEMENT 15
    .
    LOOP FOR K = 1 1 3
       LET P = PA(K)
       LOOP FOR L = 1 1 3
           LET Q = QA(L)
           TITLE P = ^P, Q = ^Q
           PLOT GL4CDF(X,P,Q) FOR X = -5  0.01  5
       END OF LOOP
    END OF LOOP
    END OF MULTIPLOT
    CASE ASIS
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT Generalized Logistic Type 4 CDF's
 
-----GL4PDF (LET)--------------------------------
 
GL4PDF
 
Name:
    GL4PDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the type 4 generalized logistic probability
    density function with shape parameters p and q.
 
Description:
    The standard form of the type 4 generalized logistic
    distribution has the probability density function:

       f(x;p,q) = (1/BETA(p,q))*
                    EXP(-q*x)/(1 + EXP(-x))**(p+q)
                    p, q > 0
 
    The general form of the type 4 generalized logistic
    probability density function can be obtained by replacing
    x in the above formula with (x-loc)/scale.

Syntax:
    LET <y> = GL4PDF(<x>,<p>,<q>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number or parameter;
          <p> is a number or parameter that specifies
               the value of the first shape parameter;
          <q> is a number or parameter that specifies
               the value of the second shape parameter;
          <loc> is a number or parameter that specifies
               the value of the location parameter;
          <scale> is a number or parameter that specifies
               the value of the scale parameter;
          <y> is a variable or a parameter (depending on what
               <x> is) where the computed generalized logistic
               type 4 pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The location and scale parameters are optional.

Examples:
    LET A = GL4PDF(3,2,0.5)
    LET X2 = GL4PDF(X1,P,Q)
    PLOT GL4PDF(X,P,Q) FOR X = -5  0.01  5
 
Note:
    The generalized logistic type 1, type 2, and type 3
    distributions are all special cases of the generalized
    logistic type 4 distribution.

Note:
    Generalized logistic type 4 random numbers, probability plots,
    and goodness of fit tests can be generated with the commands:

       LET P = <value>
       LET Q = <value>
       LET Y = GENERALIZED LOGISTIC TYPE 4 RANDOM NUMBERS ...
               FOR I = 1 1 N
       GENERALIZED LOGISTIC TYPE 3 PROBABILITY PLOT Y
       GENERALIZED LOGISTIC TYPE 3 KOLMOGOROV SMIRNOV GOODNESS ...
               OF FIT Y
       GENERALIZED LOGISTIC TYPE 3 CHI-SQUARE GOODNESS OF FIT Y

    The following commands can be used to estimate the shape
    parameter for the generalized logistic type 3 distribution:

       LET P1 = <value>
       LET P2 = <value>
       LET Q1 = <value>
       LET Q2 = <value>
       GENERALIZED LOGISTIC TYPE 4 PPCC PLOT Y
       GENERALIZED LOGISTIC TYPE 4 KS PLOT Y

    The default values for P1 and P2 are 0.1 and
    10, respectively.  The default values for Q1 and Q2 are
    0.1 and 10, respectively.

Note:
    Johnson, Kotz, and Balakrishnan (see Reference section
    below) also define type 1, type 3, type 4, and a
    parameterization due to Hoskings generalized logistic
    distributions.  These are also supported by Dataplot
    (see the Related Commands section below).

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GL4CDF = Compute the generalized logistic type 4
             cumulative distribution function.
    GL4PPF = Compute the generalized logistic type 4
             percent point function.
    GLOPDF = Compute the generalized logistic type 1
             probability density function.
    GL2PDF = Compute the generalized logistic type 2
             probability density function.
    GL3PDF = Compute the generalized logistic type 3
             probability density function.
    GL5PDF = Compute the generalized logistic (Hosking
             parameterization) probability density function.
    LOGPDF = Compute the logistic probability density function.
    NORPDF = Compute the normal probability density function.
    LGNPDF = Compute the logmormal probability density function.
 
Reference:
    "Continuous Univariate Distributions - 2", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994
    (pp. 140-147).
 
Applications:
    Distributunial Modeling
 
Implementation Date:
    2006/3
 
Program:
    LET PA = DATA 0.5  1  2
    LET QA = DATA 0.5  1  2
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 3
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE DISPLACEMENT 2
    X1LABEL X
    Y1LABEL Probability Density
    X1LABEL DISPLACEMENT 14
    Y1LABEL DISPLACEMENT 15
    .
    LOOP FOR K = 1 1 3
       LET P = PA(K)
       LOOP FOR L = 1 1 3
           LET Q = QA(L)
           TITLE P = ^P, Q = ^Q
           PLOT GL4PDF(X,P,Q) FOR X = -5  0.01  5
       END OF LOOP
    END OF LOOP
    END OF MULTIPLOT
    CASE ASIS
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT Generalized Logistic Type 4 PDF's

-----GL5CDF (LET)--------------------------------
 
GL5CDF
 
Name:
    GL5CDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the type 5 generalized logistic cumulative
    distribution function with shape parameter alpha.
 
Description:
    Johnson, Kotz, and Balakrishnan (see Reference Section
    below) define five different versions of the generalized
    logistic distribution.  The first four are referred to as
    type 1, type 2, type 3, and type 4.  The fifth is a
    version used by Hosking.  Although they do not give this
    version a specific name, Dataplot refers to it as either the
    generalized logistic type 5 or the Hosking generalized logistic
    distribution.

    The standard form of the Hosking generalized logistic
    distribution has the cumulative distribution function:

       F(x;alpha) = 1/(1 + (1 - alpha*x)**(1/alpha))
                    x <= 1/alpha  when alpha > 0
                    x >= 1/alpha  when alpha < 0

    The general form of the Hosking generalized logistic
    cumulative distribution function can be obtained by replacing
    x in the above formula with (x-loc)/scale.

Syntax:
    LET <y> = GL5CDF(<x>,<alpha>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number or parameter;
          <alpha> is a number or parameter that specifies
               the value of the shape parameter;
          <loc> is a number or parameter that specifies
               the value of the location parameter;
          <scale> is a number or parameter that specifies
               the value of the scale parameter;
          <y> is a variable or a parameter (depending on what
               <x> is) where the computed generalized logistic
               type 5 cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    The location and scale parameters are optional.

Examples:
    LET A = GL5CDF(-3,2)
    LET X2 = GL5CDF(X1,ALPHA)
    PLOT GL5CDF(X,2) FOR X = -5  0.01  0.5
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GL5PDF = Compute the generalized logistic type 5
             (Hosking) probability density function.
    GL5PPF = Compute the generalized logistic type 5
             (Hosking) percent point function.
    GLOCDF = Compute the generalized logistic type 1
             probability density function.
    GL2CDF = Compute the generalized logistic type 2
             probability density function.
    GL3CDF = Compute the generalized logistic type 3
             probability density function.
    GL4CDF = Compute the generalized logistic type 4
             probability density function.
    LOGCDF = Compute the logistic probability density function.
    NORCDF = Compute the normal probability density function.
    LGNCDF = Compute the logmormal probability density function.
 
Reference:
    "Continuous Univariate Distributions - 2", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994
    (pp. 140-147).
 
Applications:
    Distributunial Modeling
 
Implementation Date:
    2006/3
 
Program:
    LET A = DATA -1 -0.75 -0.5 -0.25 0 0.25 0.5 0.75 1
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 3
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE DISPLACEMENT 2
    X1LABEL X
    Y1LABEL Probability
    X1LABEL DISPLACEMENT 12
    Y1LABEL DISPLACEMENT 15
    .
    LOOP FOR K = 1 1 9
       LET ALPHA = A(K)
       LET XSTART = -5
       LET XSTOP = 5
       IF ALPHA > 0
          LET XSTOP = 1/ALPHA
       END OF IF
       IF ALPHA < 0
          LET XSTART = 1/ALPHA
       END OF IF
       TITLE Alpha = ^ALPHA
       PLOT GL5CDF(X,ALPHA) FOR X = XSTART  0.01  XSTOP
    END OF LOOP
    END OF MULTIPLOT
    CASE ASIS
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT Generalized Logistic Type 5 CDF's
 
-----GL5PDF (LET)--------------------------------
 
GL5PDF
 
Name:
    GL5PDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the type 5 generalized logistic probability
    density function with shape parameter alpha.
 
Description:
    Johnson, Kotz, and Balakrishnan (see Reference Section
    below) define five different versions of the generalized
    logistic distribution.  The first four are referred to as
    type 1, type 2, type 3, and type 4.  The fifth is a
    version used by Hosking.  Although they do not give this
    version a specific name, Dataplot refers to it as either the
    generalized logistic type 5 or the Hosking generalized logistic
    distribution.

    The standard form of the Hosking generalized logistic
    distribution has the probability density function:

       f(x;alpha) = (1 - alpha*x)**((1/alpha)-1)/
                    [1 + (1 - alpha*x)**(1/alpha)]**2
                    x <= 1/alpha  when alpha > 0
                    x >= 1/alpha  when alpha < 0

    The general form of the Hosking generalized logistic
    probability density function can be obtained by replacing
    x in the above formula with (x-loc)/scale.

Syntax:
    LET <y> = GL5PDF(<x>,<alpha>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number or parameter;
          <alpha> is a number or parameter that specifies
               the value of the shape parameter;
          <loc> is a number or parameter that specifies
               the value of the location parameter;
          <scale> is a number or parameter that specifies
               the value of the scale parameter;
          <y> is a variable or a parameter (depending on what
               <x> is) where the computed generalized logistic
               type 5 pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    The location and scale parameters are optional.

Examples:
    LET A = GL5PDF(-3,2)
    LET X2 = GL5PDF(X1,ALPHA)
    PLOT GL5PDF(X,2) FOR X = -5  0.01  0.5
 
Note:
    For this parameterization, alpha = 0 is equivalent to the
    logistic distribution.

Note:
    Hosking generalized logistic random numbers, probability plots,
    and goodness of fit tests can be generated with the commands:

       LET ALPHA = <value>
       LET Y = HOSKING GENERALIZED LOGISTIC RANDOM NUMBERS ...
               FOR I = 1 1 N
       HOSKING GENERALIZED LOGISTIC PROBABILITY PLOT Y
       HOSKING GENERALIZED LOGISTIC KOLMOGOROV SMIRNOV ...
               GOODNESS OF FIT Y
       HOSKING GENERALIZED LOGISTIC CHI-SQUARE GOODNESS OF FIT Y

    The following commands can be used to estimate the shape
    parameter for the Hosking generalized logistic distribution:

       LET ALPHA1 = <value>
       LET ALPHA2 = <value>
       HOSKING GENERALIZED LOGISTIC PPCC PLOT Y
       HOSKING GENERALIZED LOGISTIC KS PLOT Y

    The default values for ALPHA1 and ALPHA2 are -2 and
    2, respectively.

    Bootstrap samples for these plots can be obtained with the
    commands

       LET ALPHA1 = <value>
       LET ALPHA2 = <value>
       BOOTSTRAP GENERALIZED LOGISTIC TYPE 2 PLOT Y
       BOOTSTRAP GENERALIZED LOGISTIC TYPE 2 KS PLOT Y

    Alternatively, L-moment based estimates can be obtained with
    the command

       GENERALIZED LOGISTIC MLE Y

    Note that fitting becomes more problematic the further that
    the absolute value of alpha is from zero.  The greater the
    absolute value of alpha, the greater the occurence of extreme
    values which distort the fitting procedures.

    Some informal simulations showed good performance for
    an absolute value less than 1 (excellent for |alpha| <= 0.5).
    However, the performance rapidly declines as |alpha| gets
    larger than 1.  For that reason, be sure to apply fitting
    diagnostics (probability plots, goodness of fit tests) when
    fitting this distribution.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    TYPE 5 can be used as a synonym for HOSKING.  For example, the
    following commands are equivalent:

        LET Y = HOSKING GENERALIZED LOGISTIC RANDOM NUMBERS FOR I = 1 1 100
        LET Y = GENERALIZED LOGISTIC HOSKING RANDOM NUMBERS FOR I = 1 1 100
        LET Y = TYPE 2 GENERALIZED LOGISTIC RANDOM NUMBERS FOR I = 1 1 100
        LET Y = TYPE II GENERALIZED LOGISTIC RANDOM NUMBERS FOR I = 1 1 100
        LET Y = GENERALIZED LOGISTIC TYPE 2 RANDOM NUMBERS FOR I = 1 1 100
        LET Y = GENERALIZED LOGISTIC TYPE II RANDOM NUMBERS FOR I = 1 1 100
 
Related Commands:
    GL5CDF = Compute the generalized logistic type 5
             (Hosking) cumulative distribution function.
    GL5PPF = Compute the generalized logistic type 5
             (Hosking) percent point function.
    GLOPDF = Compute the generalized logistic type 1
             probability density function.
    GL2PDF = Compute the generalized logistic type 2
             probability density function.
    GL3PDF = Compute the generalized logistic type 3
             probability density function.
    GL4PDF = Compute the generalized logistic type 4
             probability density function.
    LOGPDF = Compute the logistic probability density function.
    NORPDF = Compute the normal probability density function.
    LGNPDF = Compute the logmormal probability density function.
 
Reference:
    "Continuous Univariate Distributions - 2", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994
    (pp. 140-147).
 
Applications:
    Distributunial Modeling
 
Implementation Date:
    2006/3
 
Program:
    LET A = DATA -1 -0.75 -0.5 -0.25 0 0.25 0.5 0.75 1
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 3
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE DISPLACEMENT 2
    X1LABEL X
    Y1LABEL Probability Density
    X1LABEL DISPLACEMENT 12
    Y1LABEL DISPLACEMENT 15
    .
    LOOP FOR K = 1 1 9
       LET ALPHA = A(K)
       LET XSTART = -5
       LET XSTOP = 5
       IF ALPHA > 0
          LET XSTOP = 1/ALPHA
       END OF IF
       IF ALPHA < 0
          LET XSTART = 1/ALPHA
       END OF IF
       TITLE Alpha = ^ALPHA
       PLOT GL5PDF(X,ALPHA) FOR X = XSTART  0.01  XSTOP
    END OF LOOP
    END OF MULTIPLOT
    CASE ASIS
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT Generalized Logistic Type 5 PDF's
 
-----GL5PPF (LET)--------------------------------
 
GL5PPF
 
Name:
    GL5PPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the type 5 generalized logistic percent point
    function with shape parameter alpha.
 
Description:
    Johnson, Kotz, and Balakrishnan (see Reference Section
    below) define five different versions of the generalized
    logistic distribution.  The first four are referred to as
    type 1, type 2, type 3, and type 4.  The fifth is a
    version used by Hosking.  Although they do not give this
    version a specific name, Dataplot refers to it as either the
    generalized logistic type 5 or the Hosking generalized logistic
    distribution.

    The standard form of the Hosking generalized logistic
    distribution has the percent point function:

       G(p;alpha) = (1/alpha)*[1 - ((1/p) - 1)**alpha]

    The general form of the Hosking generalized logistic
    percent point function can be obtained from the relation

       G(p;alpha,loc,scale) = loc + scale*G(p;alpha)

Syntax:
    LET <y> = GL5PPF(<p>,<alpha>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, number or parameter;
          <alpha> is a number or parameter that specifies
               the value of the shape parameter;
          <loc> is a number or parameter that specifies
               the value of the location parameter;
          <scale> is a number or parameter that specifies
               the value of the scale parameter;
          <y> is a variable or a parameter (depending on what
               <p> is) where the computed generalized logistic
               type 5 ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    The location and scale parameters are optional.

Examples:
    LET A = GL5PPF(0.95,0.5)
    LET X2 = GL5PPF(P1,ALPHA)
    PLOT GL5PPF(P,0.22) FOR P = 0.01  0.01  0.99
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GL5CDF = Compute the generalized logistic type 5
             (Hosking) cumulative distribution function.
    GL5PDF = Compute the generalized logistic type 5
             (Hosking) probability density function.
    GLOPPF = Compute the generalized logistic type 1
             probability density function.
    GL2PPF = Compute the generalized logistic type 2
             probability density function.
    GL3PPF = Compute the generalized logistic type 3
             probability density function.
    GL4PPF = Compute the generalized logistic type 4
             probability density function.
    LOGPPF = Compute the logistic probability density function.
    NORPPF = Compute the normal probability density function.
    LGNPPF = Compute the logmormal probability density function.
 
Reference:
    "Continuous Univariate Distributions - 2", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994
    (pp. 140-147).
 
Applications:
    Distributunial Modeling
 
Implementation Date:
    2006/3
 
Program:
    LET A = DATA -1 -0.75 -0.5 -0.25 0 0.25 0.5 0.75 1
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 3
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE DISPLACEMENT 2
    Y1LABEL X
    X1LABEL Probability
    X1LABEL DISPLACEMENT 12
    Y1LABEL DISPLACEMENT 15
    .
    LOOP FOR K = 1 1 9
       LET ALPHA = A(K)
       LET XSTART = 0.01
       LET XSTOP = 0.99
       IF ALPHA > 0
          LET XSTOP = 1
       END OF IF
       IF ALPHA < 0
          LET XSTART = 0
       END OF IF
       TITLE Alpha = ^ALPHA
       PLOT GL5PPF(P,ALPHA) FOR P = XSTART  0.01  XSTOP
    END OF LOOP
    END OF MULTIPLOT
    CASE ASIS
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT Generalized Logistic Type 5 PPF's
 
-----GL4PPF (LET)--------------------------------
 
GL4PPF
 
Name:
    GL4PPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the type 4 generalized logistic percent
    point function with shape parameters p and q.
 
Description:
    The standard form of the type 4 generalized logistic
    distribution has the probability density function:

       f(x;p,q) = (1/BETA(p,q))*
                    EXP(-q*x)/(1 + EXP(-x))**(p+q)
                    p, q > 0
 
    The general form of the type 4 generalized logistic
    probability density function can be obtained by replacing
    x in the above formula with (x-loc)/scale.

    The generalized logistic type 4 cumulative distribution
    function is computed by numerically integrating the
    probability density function.  Dataplot uses the DQAGI
    routine from the Slatec library to perform the
    integration.  The percent point function is then
    computed by numerically inverting the cumulative
    distribution function.
    
Syntax:
    LET <y> = GL4PPF(<x>,<p>,<q>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number or parameter in the range
               [0,1];
          <p> is a number or parameter that specifies
               the value of the first shape parameter;
          <q> is a number or parameter that specifies
               the value of the second shape parameter;
          <loc> is a number or parameter that specifies
               the value of the location parameter;
          <scale> is a number or parameter that specifies
               the value of the scale parameter;
          <y> is a variable or a parameter (depending on what
               <x> is) where the computed generalized logistic
               type 4 ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The location and scale parameters are optional.

Examples:
    LET A = GL4PPF(0.95,2,0.5)
    LET X2 = GL4PPF(X1,P,Q)
    PLOT GL4PPF(X,P,Q) FOR X = -5  0.01  5
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GL4CDF = Compute the generalized logistic type 4
             cumulative distribution function.
    GL4PDF = Compute the generalized logistic type 4
             probability density function.
    GLOPPF = Compute the generalized logistic type 1
             probability density function.
    GL2PPF = Compute the generalized logistic type 2
             probability density function.
    GL3PPF = Compute the generalized logistic type 3
             probability density function.
    GL5PPF = Compute the generalized logistic (Hosking
             parameterization) probability density function.
    LOGPPF = Compute the logistic probability density function.
    NORPPF = Compute the normal probability density function.
    LGNPPF = Compute the logmormal probability density function.
 
Reference:
    "Continuous Univariate Distributions - 2", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994
    (pp. 140-147).
 
Applications:
    Distributunial Modeling
 
Implementation Date:
    2006/3
 
Program:
    LET PA = DATA 0.5  1  2
    LET QA = DATA 0.5  1  2
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 3
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE DISPLACEMENT 2
    Y1LABEL X
    X1LABEL Probability
    X1LABEL DISPLACEMENT 14
    Y1LABEL DISPLACEMENT 15
    .
    LOOP FOR K = 1 1 3
       LET P = PA(K)
       LOOP FOR L = 1 1 3
           LET Q = QA(L)
           TITLE P = ^P, Q = ^Q
           PLOT GL4PPF(X,P,Q) FOR X = 0.01  0.01  0.99
       END OF LOOP
    END OF LOOP
    END OF MULTIPLOT
    CASE ASIS
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT Generalized Logistic Type 4 PPF's
 
-----GMCCDF (LET)--------------------------------
 
GMCCDF
 
Name:
    GMCCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized McLeish cumulative distribution
    function.
 
Description:
    The standard form of the generalized McLeish distribution has
    the following probability density function:

        f(X;ALPHA,A) = [1/(SQRT(PI)*GAMMA(ALPHA))]*
                       (ABS(X)/2)**(ALPHA-1/2)*K(X,ALPHA-1/2)
                       *(1-A**2)**ALPHA*EXP(A*X)
                       alpha > 0, |A| < 1
 
    with

        K(X,N)  = the modified Bessel function of the second kind
        GAMMA   = the gamma function

    The standard generalized McLeish distribution can be
    generalized with location and scale parameters in the usual
    way.

    The cumulative distribution function is computed by
    numerically integrating the probability density function.
    Dataplot performs the integration using the DQAG routine
    from the Slatec library.

Syntax:
    LET <y> = GMCCDF(<x>,<alpha>,<a>,<loc>,<scale>)
                                <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <alpha> is a positive number of parameter that specifies
              the value of the first shape parameter;
          <a> is a positive number of parameter that specifies
              the value of the second shape parameter;
          <loc> is an optional number or parameter that specifies
              the value of the location parameter;
          <scale> is an optional positive number or parameter that
              specifies the value of the scale parameter;
          <y> is a variable or a parameter (depending on what <x>
              is) where the computed generalized McLeish cdf value
              is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y = GMCCDF(3,1.5,0.8)
    LET Y = GMCCDF(X1,ALPHA,A)
    PLOT GMCCDF(X,ALPHA,A) FOR X = -10  0.01  10
 
Note:
    DATAPLOT uses the routine DBESK from the SLATEC Common
    Mathematical Library to compute the modified Bessel function
    of the second kind.  SLATEC is a large set of high quality,
    portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal
    laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GMCPDF = Compute the generalized McLeish probability density
             function.
    GMCPPF = Compute the generalized McLeish percent point function.
    MCLPDF = Compute the McLeish probability density function.
    GALPDF = Compute the generalized asymmetric Laplace cumulative
             distribution function.
    GIGPDF = Compute the generalized inverse Gaussian probability
             density function.
    BEIPDF = Compute the Bessel I-function probability density
             function.
    BEKPDF = Compute the Bessel K-function probability density
             function.
 
Reference:
    Johnson, Kotz, and Balakrisnan, "Continuous Univariate
    Distributions--Volume I", Second Edition, Wiley, 1994,
    pp. 50-53.

Applications:
    Distributional Modeling
 
Implementation Date:
    8/2004
 
Program:
    Y1LABEL Probability
    X1LABEL X
    LABEL CASE ASIS
    TITLE CASE ASIS
    CASE ASIS
    Y1LABEL DISPLACEMENT 12
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    LET A = 0.8
    TITLE Alpha = 1.5, A = 0.8
    PLOT GMCCDF(X,1.5,A) FOR X = -30  0.1 30
    LET A = -0.8
    TITLE Alpha = 1.5, A = -0.8
    PLOT GMCCDF(X,1.5,A) FOR X = -30  0.1 30
    LET A = 0.2
    TITLE Alpha = 1.5, A = 0.2
    PLOT GMCCDF(X,1.5,A) FOR X = -30  0.1 30
    LET A = -0.2
    TITLE Alpha = 1.5, A = -0.2
    PLOT GMCCDF(X,1.5,A) FOR X = -30  0.1 30
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT Generalized McLeish Cumulative Distribution
 
-----GMCPDF (LET)--------------------------------
 
GMCPDF
 
Name:
    GMCPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized McLeish probability density function.
 
Description:
    The standard form of the generalized McLeish distribution has
    the following probability density function:

        f(X;ALPHA,A) = [1/(SQRT(PI)*GAMMA(ALPHA))]*
                       (ABS(X)/2)**(ALPHA-1/2)*K(X,ALPHA-1/2)
                       *(1-A**2)**ALPHA*EXP(A*X)
                       alpha > 0, |A| < 1
 
    with

        K(X,N)  = the modified Bessel function of the second kind
        GAMMA   = the gamma function


    The standard generalized McLeish distribution can be
    generalized with location and scale parameters in the usual
    way.

Syntax:
    LET <y> = GMCPDF(<x>,<alpha>,<a>,<loc>,<scale>)
                                <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <alpha> is a positive number of parameter that specifies
              the value of the first shape parameter;
          <a> is a positive number of parameter that specifies
              the value of the second shape parameter;
          <loc> is an optional number or parameter that specifies
              the value of the location parameter;
          <scale> is an optional positive number or parameter that
              specifies the value of the scale parameter;
          <y> is a variable or a parameter (depending on what <x>
              is) where the computed generalized McLeish pdf value
              is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y = GMCPDF(3,1.5,0.8)
    LET Y = GMCPDF(X1,ALPHA,A)
    PLOT GMCPDF(X,ALPHA,A) FOR X = -10  0.01  10
 
Note:
    DATAPLOT uses the routine DBESK from the SLATEC Common
    Mathematical Library to compute the modified Bessel function
    of the second kind.  SLATEC is a large set of high quality,
    portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal
    laboratories.

Note:
    To generate generalized McLeish random numbers, enter the
    commands

        LET ALPHA = <value>
        LET A = <value>
        LET Y = GENERALIZED MCLEISH RANDOM NUMBERS FOR I = 1 1 N

    To generate a generalized McLeish probability plot or a McLeish
    Kolmogorov-Smirnov or chi-square goodness of fit test, enter
    the following commands

        LET ALPHA = <value>
        LET A= <value>
        GENERALIZED MCLEISH PROBABILITY PLOT Y
        GENERALIZED MCLEISH KOLMOGOROV SMIRNOV GOODNESS OF FIT Y
        GENRALIZED MCLEISH CHI-SQUARE GOODNESS OF FIT Y
       
    To generate a PPCC or Kolmogorov-Smirnov plot, enter the
    following commands

        LET ALPHA1 = <value>
        LET ALPHA2 = <value>
        LET A1 = <value>
        LET A2 = <value>
        GENERALIZED MCLEISH PPCC PLOT Y
        GENERALIZED MCLEISH KS PLOT Y

    The default values for ALPHA1 and ALPHA2 are 0.5 and 10
    and the default values for A1 and A2 are -0.8 and 0.8.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GMCCDF = Compute the generalized McLeish cumulative
             distribution function.
    GMCPPF = Compute the generalized McLeish percent point function.
    MCLPDF = Compute the McLeish probability density function.
    GALPDF = Compute the generalized asymmetric Laplace cumulative
             distribution function.
    GIGPDF = Compute the generalized inverse Gaussian probability
             density function.
    BEIPDF = Compute the Bessel I-function probability density
             function.
    BEKPDF = Compute the Bessel K-function probability density
             function.
 
Reference:
    Johnson, Kotz, and Balakrisnan, "Continuous Univariate
    Distributions--Volume I", Second Edition, Wiley, 1994,
    pp. 50-53.

Applications:
    Distributional Modeling
 
Implementation Date:
    8/2004
 
Program:
    Y1LABEL Probability
    X1LABEL X
    LABEL CASE ASIS
    TITLE CASE ASIS
    CASE ASIS
    Y1LABEL DISPLACEMENT 12
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    LET A = 0.8
    TITLE Alpha = 1.5, A = 0.8
    PLOT GMCPDF(X,1.5,A) FOR X = -30  0.1 30
    LET A = -0.8
    TITLE Alpha = 1.5, A = -0.8
    PLOT GMCPDF(X,1.5,A) FOR X = -30  0.1 30
    LET A = 0.2
    TITLE Alpha = 1.5, A = 0.2
    PLOT GMCPDF(X,1.5,A) FOR X = -30  0.1 30
    LET A = -0.2
    TITLE Alpha = 1.5, A = -0.2
    PLOT GMCPDF(X,1.5,A) FOR X = -30  0.1 30
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT Generalized McLeish Distribution
 
-----GMCPPF (LET)--------------------------------
 
GMCPPF
 
Name:
    GMCPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized McLeish cumulative distribution
    function.
 
Description:
    The standard form of the generalized McLeish distribution has
    the following probability density function:

        f(X;ALPHA,A) = [1/(SQRT(PI)*GAMMA(ALPHA))]*
                       (ABS(X)/2)**(ALPHA-1/2)*K(X,ALPHA-1/2)
                       *(1-A**2)**ALPHA*EXP(A*X)
                       alpha > 0, |A| < 1
 
    with

        K(X,N)  = the modified Bessel function of the second kind
        GAMMA   = the gamma function

    The standard generalized McLeish distribution can be
    generalized with location and scale parameters in the usual
    way.

    The cumulative distribution function is computed by
    numerically integrating the probability density function.
    Dataplot performs the integration using the DQAG routine
    from the Slatec library.  The percent point function is
    then computed by numerically inverting the cumulative
    distribution function using the DFZERO subroutine from
    the Slatec library.

Syntax:
    LET <y> = GMCPPF(<p>,<alpha>,<a>,<loc>,<scale>)
                                <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, a number, or a parameter;
          <alpha> is a positive number of parameter that specifies
              the value of the first shape parameter;
          <a> is a positive number of parameter that specifies
              the value of the second shape parameter;
          <loc> is an optional number or parameter that specifies
              the value of the location parameter;
          <scale> is an optional positive number or parameter that
              specifies the value of the scale parameter;
          <y> is a variable or a parameter (depending on what <x>
              is) where the computed generalized McLeish ppf value
              is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y = GMCPPF(0.95,1.5,0.8)
    LET Y = GMCPPF(P1,ALPHA,A)
    PLOT GMCPPF(P,ALPHA,A) FOR P = 0.01 0.01 0.99
 
Note:
    DATAPLOT uses the routine DBESK from the SLATEC Common
    Mathematical Library to compute the modified Bessel function
    of the second kind.  SLATEC is a large set of high quality,
    portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal
    laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GMCCDF = Compute the generalized McLeish cumulative
             distribution function.
    GMCPDF = Compute the generalized McLeish probability density
             function.
    MCLPDF = Compute the McLeish probability density function.
    GALPDF = Compute the generalized asymmetric Laplace cumulative
             distribution function.
    GIGPDF = Compute the generalized inverse Gaussian probability
             density function.
    BEIPDF = Compute the Bessel I-function probability density
             function.
    BEKPDF = Compute the Bessel K-function probability density
             function.
 
Reference:
    Johnson, Kotz, and Balakrisnan, "Continuous Univariate
    Distributions--Volume I", Second Edition, Wiley, 1994,
    pp. 50-53.

Applications:
    Distributional Modeling
 
Implementation Date:
    8/2004
 
Program:
    X1LABEL Probability
    Y1LABEL X
    LABEL CASE ASIS
    TITLE CASE ASIS
    CASE ASIS
    Y1LABEL DISPLACEMENT 12
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    LET A = 0.8
    TITLE Alpha = 1.5, A = 0.8
    PLOT GMCPPF(P,1.5,A) FOR P = 0.01  0.01 0.99
    LET A = -0.8
    TITLE Alpha = 1.5, A = -0.8
    PLOT GMCPPF(P,1.5,A) FOR P = 0.01  0.01  0.99
    LET A = 0.2
    TITLE Alpha = 1.5, A = 0.2
    PLOT GMCPPF(P,1.5,A) FOR P = 0.01  0.01  0.99
    LET A = -0.2
    TITLE Alpha = 1.5, A = -0.2
    PLOT GMCPPF(P,1.5,A) FOR P = 0.01  0.01  0.99
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT Generalized McLeish Percent Point Function

-----GMINOR-------------------------------------------------------
 
GMINOR
 
Name:
    GMINOR
 
Type:
    Plot Control Command
 
Purpose:
    Specifies whether or not minor grid lines appear on subsequent
    plots.
 
Description:
    Grid lines are drawn at the major tic marks.  Minor grid lines are
    drawn at the minor tic marks.  Major and minor grid lines are
    independent of each other (that is, you can draw minor grid lines
    without drawing major grid lines and vice versa).  Typically when a
    grid is desired, only the major grid is drawn.  However, there are
    some occasions where an analyst might want both (e.g., many
    analysts prefer minor grids on for log scale charts).
 
Syntax 1:
    GMINOR   <ON or OFF>
    where ON specifies that the minor grid is drawn while OFF specifies
             that the minor grid is not drawn.
 
    This form applies to  both the horizontal and the vertical minor
    grid lines.
 
Syntax 2:
    XGMI   <ON or OFF>
    where ON specifies that the minor grid is drawn while OFF specifies
             that the minor grid is not drawn.
 
    This form only applies to the vertical minor grid lines.
 
Syntax 3:
    YGMI   <ON or OFF>
    where ON specifies that the minor grid is drawn while OFF specifies
             that the minor grid is not drawn.
 
    This form only applies to the horizontal minor grid lines.
 
Examples:
    GMINOR ON
    GMINOR OFF
    GMINOR
    XGMINOR ON
    YGMINOR ON
 
Note:
    The GMINOR command with no argument is equivalent to GMINOR ON.
 
Note:
    The minor grid uses the same attributes (GRID COLOR, GRID PATTERN,
    and GRID THICKNESS) as the major grid.  If it is critical that they
    be different, draw the plot twice (using the LIMITS command and the
    PRE-ERASE OFF command after the first plot).  Draw the major grid
    (and set its attributes) with the first plot and the minor grid
    (with its attributes) with the second plot.
 
Default:
    The default is no minor grid lines.
 
Synonyms:
    XYGM and YXGM are synonyms for GMINOR.
 
Related Commands:
    GRID                = Sets the on/off switch for the plot grid.
    GRID COLOR          = Sets the color for the plot grid.
    GRID PATTERN        = Sets the line type for the plot grid.
    GRID THICKNESS      = Sets the line thickness for the plot grid.
    PLOT                = Generates a data or function plot.
    FRAME               = Sets the on/off switch for the plot frame.
    FRAME COLOR         = Sets the color for the plot frame.
    FRAME COORDINATES   = Sets the location for the plot frame.
    MINIMUM             = Sets the frame minima for subsequent  plots.
    MAXIMUM             = Sets the frame maxima for subsequent  plots.
    LIMITS              = Sets the frame limits for subsequent plots.
    LOG                 = Sets the on/off switch for a log scale.
    TIC                 = Sets the on/off switch for the plot tics.
    MAJOR TIC NUMBER    = Sets the number of major tics.
    MINOR TIC NUMBER    = Sets the number of minor tics.
    TIC LABEL           = Sets the on/off switch for plot tic labels.
    TIC LABEL DECIMALS  = Sets the number of decimal places for plot
                          tic mark labels.
    MARGIN COLOR        = Sets the color for the plot margin.
    BACKGROUND COLOR    = Sets the color for the plot background.
    TITLE               = Sets the plot title.
    LABEL               = Sets the plot labels.
    LEGEND              = Sets the plot legends.
    LEGEND COORDINATES  = Sets the locations for plot legends.
    BOX COORDINATES     = Sets the locations for plot boxes.
    ARROW COORDINATES   = Sets the locations for plot arrows.
    SEGMENT COORDINATES = Sets the locations for plot segments.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    XX
 
Program:
    LET LEAD = DATA ...
       164 426 59 98 312 263 607 497 213 54 160 262 547 325 419 94 70
    LET POT = DATA ...
       106 175 61 79 94 121 424 328 107 218 140 179 246 231 245 339 99
    TITLE DEMONSTRATE GMINOR COMMAND
    GRID THICKNESS 0.1
    GRID ON
    GMINOR ON
    X1LABEL LEAD
    Y1LABEL POTASSIUM
    CHARACTER CIRCLE
    CHARACTER SIZE 1.5
    LINE BLANK ALL
    PLOT POT VS LEAD
 
-----GNBCDF (LET)--------------------------------
 
GNBCDF
 
Name:
    GNBCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized negative binomial cumulative
    distribution function.
 
Description:
    The generalized negative binomial distribution has the
    following probability mass function:

        p(x;theta,beta,m)=
            (m/(m+beta*x)*
            (m+beta*x  x)*theta**x*(1-theta)**(m+beta*x-x)
            x = 0, 1, 2, 3, ,...
            0 < theta < 1; beta = 0 or 1 <= beta <= 1/theta;
            m > 0 (m a positive integer if beta = 0)

    with theta, beta, and m denoting the shape parameters.
 
    The cumulative distribution function is computed using
    the following recurrence relation

        p(x+1) = (m+(beta-1)*x+beta)/(x+1)*
                 theta*(1-theta)**(beta-1)*
                 PROD[j=1 TO x-1][1 + beta/(m+beta*x-j)]*P(x)

Syntax:
    LET <y> = GNBCDF(<x>,<theta>,<beta>,<m>) 
               <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative integer variable, number, or
               parameter;
          <theta> is a number, parameter, or variable in the range 
               (0,1) that specifies the first shape parameter;
          <beta> is a number, parameter, or variable that
               specifies the second shape parameter;
          <m> is a positive number, parameter, or variable that
               specifies the third shape parameter;
          <y> is a variable or a parameter (depending on what <x>
               is) where the computed generalized negative
               binomial pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GNBCDF(3,0.5,1.4,2)
    LET Y = GNBCDF(X,0.3,1.6,2)
    PLOT GNBCDF(X,0.3,1.6,0.5) FOR X = 0  1  20

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GNBPDF                   = Compute the generalized negative
                               binomial probability mass function.
    GNBPPF                   = Compute the generalized negative
                               binomial percent point function.
    GLSPDF                   = Compute the generalized logarithmic
                               series probability density function.
    NBCPF                    = Compute the negative binomial
                               probability mass function.
    LPOPDF                   = Compute the Lagrange Poisson
                               probability mass function.
    GETPDF                   = Compute the Geeeta probability
                               mass function.
    CONPDF                   = Compute the Consul probability
                               mass function.
 
Reference:
    Consul and Famoye (2006), "Lagrangian Probability
    Distribution", Birkhauser, chapter 10.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/7
 
Program:
    title size 3
    tic label size 3
    label size 3
    legend size 3
    height 3
    x1label displacement 12
    y1label displacement 15
    .
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    label case asis
    title case asis
    case asis
    tic offset units screen
    tic offset 3 3
    title displacement 2
    y1label Probability
    x1label X
    .
    ylimits 0 1
    major ytic mark number 6
    minor ytic mark number 3
    xlimits 0 20
    line blank
    spike on
    .
    multiplot 2 2
    .
    title Theta = 0.2, Beta = 1.2, M = 2
    plot gnbcdf(x,0.2,1.2,2) for x = 0 1 20
    .
    title Theta = 0.4, Beta = 1.2, M = 2
    plot gnbcdf(x,0.4,1.2,2) for x = 0 1 20
    .
    title Theta = 0.6, Beta = 1.2, M = 2
    plot gnbcdf(x,0.6,1.2,2) for x = 0 1 20
    .
    title Theta = 0.8, Beta = 1.2, M = 2
    plot gnbcdf(x,0.8,1.2,2) for x = 0 1 20
    .
    end of multiplot
    .
    justification center
    move 50 97
    text CDF Functions for Generalized Negative Binomial

-----GNBPDF (LET)--------------------------------
 
GNBPDF
 
Name:
    GNBPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized negative binomial probability mass
    function.
 
Description:
    The generalized negative binomial distribution has the
    following probability mass function:

        p(x;theta,beta,m)=
            (m/(m+beta*x)*
            (m+beta*x  x)*theta**x*(1-theta)**(m+beta*x-x)
            x = 0, 1, 2, 3, ,...
            0 < theta < 1; beta = 0 or 1 <= beta <= 1/theta;
            m > 0 (m a positive integer if beta = 0)

    with theta, beta, and m denoting the shape parameters.
 
Syntax:
    LET <y> = GNBPDF(<x>,<theta>,<beta>,<m>) 
               <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative integer variable, number, or
               parameter;
          <theta> is a number, parameter, or variable in the range 
               (0,1) that specifies the first shape parameter;
          <beta> is a number, parameter, or variable that
               specifies the second shape parameter;
          <m> is a positive number, parameter, or variable that
               specifies the third shape parameter;
          <y> is a variable or a parameter (depending on what <x>
               is) where the computed generalized negative
               binomial pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GNBPDF(3,0.5,1.4,2)
    LET Y = GNBPDF(X,0.3,1.6,2)
    PLOT GNBPDF(X,0.3,1.6,0.5) FOR X = 1  1  20

Note:
    For a number of commands utilizing the generalized
    negative binomial distribution, it is convenient to bin
    the data.  There are two basic ways of binning the data.

      1) For some commands (histograms, maximum likelihood
         estimation), bins with equal size widths are
         required.  This can be accomplished with the
         following commands:

            LET AMIN = MINIMUM Y
            LET AMAX = MAXIMUM Y
            LET AMIN2 = AMIN - 0.5
            LET AMAX2 = AMAX + 0.5
            CLASS MINIMUM AMIN2
            CLASS MAXIMUM AMAX2
            CLASS WIDTH 1
            LET Y2 X2 = BINNED

      2) For some commands, unequal width bins may be
         helpful.  In particular, for the chi-square goodness
         of fit, it is typically recommended that the minimum
         class frequency be at least 5.  In this case, it may
         be helpful to combine small frequencies in the tails.
         Unequal class width bins can be created with the
         commands

            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = INTEGER FREQUENCY TABLE Y

         If you already have equal width bins data, you can
         use the commands
         
            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = COMBINE FREQUENCY TABLE Y2 X2

         The MINSIZE parameter defines the minimum class
         frequency.  The default value is 5.

Note:
    You can generate generalized negative binomial random
    numbers, probability plots, and chi-square goodness of fit
    tests with the following commands:

       LET N = VALUE
       LET THETA = <value>
       LET BETA = <value>
       LET Y = GENERALIZED NEGATIVE BINOMIAL ...
               RANDOM NUMBERS FOR I = 1 1 N

       GENERALIZED NEGATIVE BINOMIAL PROBABILITY PLOT Y
       GENERALIZED NEGATIVE BINOMIAL PROBABILITY PLOT Y2 X2
       GENERALIZED NEGATIVE BINOMIAL PROBABILITY PLOT ...
                   Y3 XLOW XHIGH

       GENERALIZED NEGATIVE BINOMIAL CHI-SQUARE ...
                   GOODNESS OF FIT Y
       GENERALIZED NEGATIVE BINOMIAL CHI-SQUARE ...
                   GOODNESS OF FIT Y2 X2
       GENERALIZED NEGATIVE BINOMIAL CHI-SQUARE ...
                   GOODNESS OF FIT Y3 XLOW XHIGH

    To obtain the method of moment estimates, the mean and
    ones frequency estimates, and the maximum likelihood
    estimates of theta and beta, enter the command

        GENERALIZED NEGATIVE BINOMIAL MAXIMUM LIKELIHOOD Y
        GENERALIZED NEGATIVE BINOMIAL MAXIMUM LIKELIHOOD Y2 X2

    The moment estimate of theta is the solution of the equation

        thetahat = 1 - 0.5*A + (A**2/4 - 1)**(0.5)

    where

       A = -2 + (xbar*s3 - 3*s2**2)**2/(xbar*s2**3)

    The estimates of beta and m are then

       betahat = {1 - SQRT(xbar*(1-thetahat)/s2)}/thetahat
       mhat    = xbar*(1-thetahat*betahat)/thetahat

    where

       xbar = sample mean
       s2   = sample variance
       s3   = sample third moment
            
    The moments and zero frequency estimate of theta is the
    solution of the equation

       s2*(LOG(F0)**2/xbar**3 -
       (1-theta)*(LOG(1-theta))**2/theta**2 = 0

    where F0 is the frequency at x = 0 divided by the sample
    size.

    The estimates of beta and m are then

       mhat    = SQRT{(1-thetahat)*xbar**3/s2}/thetahat
       betahat = (1/thetahat) - mhat/xbar


    The moments and ratio of frequencies estimate of theta is
    the solution of the equattion

       {(2/theta) - (2/theta)*SQRT(xbar*(1-theta)/s2)-1}*
       LOG(1-theta) - LOG(s2*F10**2/xbar**3) = 0

    where

       F0  = frequency at x = 0 divided by sample size
       F1  = frequency at x = 1 divided by sample size
       F10 = F1/F0

    The estimates of m and beta are then

       mhat = SQRT{(1-thetahat)*xbar**3/s2}/theta
       betahat = (1/thetahat) - mhat/xbar
        
    The maximum likelihood estimates of beta and m are the
    solution to the equations

       (N-N(0))*xbar/m - SUM[x=2 to k][SUM[i=1 to x-1]
       [(x-xbar)*N(x)/(m+beta*x-i]] = 0

       N*xbar*LOG(1-xbar/(m+beta*xbar)) +
       SUM[x=2 to k][SUM[i=1 to x-1]
       [x*N(x)/(m+beta*x-i]] = 0

    where

       N       = sample size
       N(i)    = frequency at x = i

    The estimate of theta is then

       thetahat = xbar/(mhat+beta*xbar)

    The details of these estimates are given in Consul and
    Famoye.  These authors performed simulation studies that
    showed that the above methods generate fits that generate
    acceptable goodness of fit values.  However, the
    estimates are not close to the true values (this results
    from quite different values of the parameters that
    generate similar probabilities).  They found that using
    estimation methods based on the truncated generalized
    negative binomial distribution generated estimates that
    were close to the true values.  We are currently
    investigating these methods for inclusion into a
    future version of Dataplot.
  
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GNBCDF                   = Compute the generalized negative
                               binomial cumulative distribution
                               function.
    GNBPPF                   = Compute the generalized negative
                               binomial percent point function.
    GLSPDF                   = Compute the generalized logarithmic
                               series probability density function.
    NBPDF                    = Compute the negative binomial
                               probability mass function.
    LPOPDF                   = Compute the Lagrange Poisson
                               probability mass function.
    GETPDF                   = Compute the Geeeta probability
                               mass function.
    CONPDF                   = Compute the Consul probability
                               mass function.
    INTEGER FREQUENCY TABLE  = Generate a frequency table at
                               integer values with unequal bins.
    COMBINE FREQUENCY TABLE  = Convert an equal width frequency
                               table to an unequal width frequency
                               table.
    PROBABILITY PLOT         = Generate a probability plot.
    MAXIMUM LIKELIHOOD       = Perform maximum likelihood
                               estimation for a distribution.
 
Reference:
    Consul and Famoye (2006), "Lagrangian Probability
    Distribution", Birkhauser, chapter 10.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/7
 
Program 1:
    title size 3
    tic label size 3
    label size 3
    legend size 3
    height 3
    x1label displacement 12
    y1label displacement 15
    .
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    label case asis
    title case asis
    case asis
    tic offset units screen
    tic offset 3 3
    title displacement 2
    y1label Probability Mass
    x1label X
    .
    ylimits 0 1
    major ytic mark number 6
    minor ytic mark number 3
    xlimits 0 20
    line blank
    spike on
    .
    multiplot 2 2
    .
    title Theta = 0.2, Beta = 1.2, M = 2
    plot gnbpdf(x,0.2,1.2,2) for x = 0 1 20
    .
    title Theta = 0.4, Beta = 1.2, M = 2
    plot gnbpdf(x,0.4,1.2,2) for x = 0 1 20
    .
    title Theta = 0.6, Beta = 1.2, M = 2
    plot gnbpdf(x,0.6,1.2,2) for x = 0 1 20
    .
    title Theta = 0.8, Beta = 1.2, M = 2
    plot gnbpdf(x,0.8,1.2,2) for x = 0 1 20
    .
    end of multiplot
    .
    justification center
    move 50 97
    text Probability Mass Functions for Generalized Logarithmic Series

Program 2:
    let theta = 0.3
    let beta = 3
    let m = 1.5
    .
    let y = generalized negative binomial rand numb for i = 1 1 1000
    .
    let a = maximum y
    class lower -0.5
    let a2 = a + 0.5
    class upper a2
    class width 1
    let y2 x2 = binned y
    relative hist y2 x2
    pre-erase off
    limits freeze
    line color blue
    plot gnbpdf(x,theta,beta,m) for x = 0 1 a
    limits
    pre-erase off
    line color black
    .
    generalized negative binomial mle y
    .
    let theta = thetaml
    let beta = betaml
    let m = mml
    let y3 xlow xhigh = combine frequency table y2 x2
    generalized negative binomial chi-square goodness of fit y3 xlow xhigh
    .
    character x
    line blank
    generalized negative binomial probability plot y2 x2

-----GNBPPF (LET)--------------------------------
 
GNBPPF
 
Name:
    GNBPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized negative binomial percent point
    function.
 
Description:
    The generalized negative binomial distribution has the
    following probability mass function:

        p(x;theta,beta,m)=
            (m/(m+beta*x)*
            (m+beta*x  x)*theta**x*(1-theta)**(m+beta*x-x)
            x = 0, 1, 2, 3, ,...
            0 < theta < 1; beta = 0 or 1 <= beta <= 1/theta;
            m > 0 (m a positive integer if beta = 0)

    with theta, beta, and m denoting the shape parameters.
 
    The cumulative distribution function is computed using
    the following recurrence relation

        p(x+1) = (m+(beta-1)*x+beta)/(x+1)*
                 theta*(1-theta)**(beta-1)*
                 PROD[j=1 TO x-1][1 + beta/(m+beta*x-j)]*P(x)

    The percent point is computed by generating the cdf
    function until the appropriate probability is obtained.

Syntax:
    LET <y> = GNBPPF(<p>,<theta>,<beta>,<m>) 
               <SUBSET/EXCEPT/FOR qualification>
    where <p> is an integer variable, number, or
               parameter in the interval (0,1];
          <theta> is a number, parameter, or variable in the range 
               (0,1) that specifies the first shape parameter;
          <beta> is a number, parameter, or variable that
               specifies the second shape parameter;
          <m> is a positive number, parameter, or variable that
               specifies the third shape parameter;
          <y> is a variable or a parameter (depending on what <x>
               is) where the computed generalized negative
               binomial ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GNBPPF(0.95,0.5,1.4,2)
    LET Y = GNBPPF(P,0.3,1.6,2)
    PLOT GNBPPF(P,0.3,1.6,0.5) FOR P = 0  0.01  0.99

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GNBCDF                   = Compute the generalized negative
                               binomial cumulative distribution
                               function.
    GNBPDF                   = Compute the generalized negative
                               binomial probability mass function.
    GLSPDF                   = Compute the generalized logarithmic
                               series probability density function.
    NBCPF                    = Compute the negative binomial
                               probability mass function.
    LPOPDF                   = Compute the Lagrange Poisson
                               probability mass function.
    GETPDF                   = Compute the Geeeta probability
                               mass function.
    CONPDF                   = Compute the Consul probability
                               mass function.
 
Reference:
    Consul and Famoye (2006), "Lagrangian Probability
    Distribution", Birkhauser, chapter 10.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/7
 
Program:
    title size 3
    tic label size 3
    label size 3
    legend size 3
    height 3
    x1label displacement 12
    y1label displacement 15
    .
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    label case asis
    title case asis
    case asis
    tic offset units screen
    tic offset 3 3
    title displacement 2
    x1label Probability
    y1label X
    .
    ylimits 0 1
    major ytic mark number 6
    minor ytic mark number 3
    xlimits 0 20
    line blank
    spike on
    .
    multiplot 2 2
    .
    title Theta = 0.2, Beta = 1.2, M = 2
    plot gnbppf(p,0.2,1.2,2) for 0  0.01  0.99
    .
    title Theta = 0.4, Beta = 1.2, M = 2
    plot gnbppf(p,0.4,1.2,2) for 0  0.01  0.99
    .
    title Theta = 0.6, Beta = 1.2, M = 2
    plot gnbppf(p,0.6,1.2,2) for 0  0.01  0.99
    .
    title Theta = 0.8, Beta = 1.2, M = 2
    plot gnbppf(p,0.8,1.2,2) for 0  0.01  0.99
    .
    end of multiplot
    .
    justification center
    move 50 97
    text PPF Functions for Generalized Negative Binomial

-----GOMCDF (LET)--------------------------------
 
GOMCDF
 
Name:
    GOMCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Gompertz cumulative distribution function with
    shape parameters C and B.
 
Description:
    The Gompertz distribution has the following cumulative
    distribution function:
          F(x,c,b) = 1 - EXP[-b*(c**x - 1)/LOG(c)]
                            x >= 0; b > 0; c >= 1
 
Syntax:
    LET <y> = GOMCDF(<x>,<c>,<b>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable containing positive
               values;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed Gompertz cdf value is stored;
          <c> is a positive number, parameter, or variable that
               specifies the first shape parameter;
          <b> is a positive number, parameter, or variable that
               specifies the second shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GOMCDF(0.3,10,8)
    LET A = GOMCDF(A1,10,8)
    LET X2 = GOMCDF(X1,2,6)
 
Note:
    If c is 1, this distribution reduces to an exponential
    distribution.  The Gompertz distribution can be interpreted
    as a truncated extreme value type I distribution.

Note:
    There are several forms given for the Gompertz distribution
    in the literature.  Some of these are given by Johnson,
    Kotz, and Balakrishnan (see Reference below).  In particular,
    one form uses the parameter alpha where alpha = LOG(c).
    Simple replace c with EXP(alpha) in the pdf formula given
    above.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GOMPDF = Compute the Gompertz probability density function.
    GOMPPF = Compute the Gompertz percent point function.
    EXPPDF = Compute the exponential probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EV1PDF = Compute the extreme value type I probability density
             function.
    EV2PDF = Compute the extreme value type II probability density
             function.
 
Reference:
    "Continuous Univariate Distributions Volume 2", 2nd. ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley and Sons, 1994,
    (pp. 25-26, 81-85).
 
Applications:
    Life Testing
 
Implementation Date:
    1995/10
 
Program:
    LET C1 = 1.1 1.1 1.1 2 2 2 5 5 5
    LET B1 = DATA 0.5 1 2 0.5 1 2 0.5 1 2
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LOOP FOR K = 1 1 9
       LET C = C1(K)
       LET B = B1(K)
       X1LABEL C = ^C, B = ^B
       PLOT GOMCDF(X,C,B) FOR X = 0  0.01  5
    END OF LOOP
    END OF MULTIPLOT
 
-----GOMPDF (LET)--------------------------------
 
GOMPDF
 
Name:
    GOMPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Gompertz probability density function with shape
    parameters C and B.
 
Description:
    The Gompertz distribution has the following probability density
    function:
          f(x,c,b) = b*c**x*EXP[-b*(c**x-1)/LOG(c)]
                            x >= 0; b > 0; c >= 1
 
Syntax:
    LET <y> = GOMPDF(<x>,<c>,<b>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable containing positive
               values;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed Gompertz pdf value is stored;
          <c> is a positive number, parameter, or variable that
               specifies the first shape parameter;
          <b> is a positive number, parameter, or variable that
               specifies the second shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GOMPDF(0.3,10,8)
    LET A = GOMPDF(A1,10,8)
    LET X2 = GOMPDF(X1,2,6)
 
Note:
    If c is 1, this distribution reduces to an exponential
    distribution.  The Gompertz distribution can be interpreted
    as a truncated extreme value type I distribution.

Note:
    There are several forms given for the Gompertz distribution
    in the literature.  Some of these are given by Johnson,
    Kotz, and Balakrishnan (see Reference below).  In particular,
    one form uses the parameter alpha where alpha = LOG(c).
    Simple replace c with EXP(alpha) in the pdf formula given
    above.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GOMCDF = Compute the Gompertz cumulative distribution function.
    GOMPPF = Compute the Gompertz percent point function.
    EXPPDF = Compute the exponential probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EV1PDF = Compute the extreme value type I probability density
             function.
    EV2PDF = Compute the extreme value type II probability density
             function.
 
Reference:
    "Continuous Univariate Distributions Volume 2", 2nd. ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley and Sons, 1994,
    (pp. 25-26, 81-85).
 
Applications:
    Life Testing
 
Implementation Date:
    1995/10
 
Program:
    LET C1 = 1.1 1.1 1.1 2 2 2 5 5 5
    LET B1 = DATA 0.5 1 2 0.5 1 2 0.5 1 2
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LOOP FOR K = 1 1 9
       LET C = C1(K)
       LET B = B1(K)
       X1LABEL C = ^C, B = ^B
       PLOT GOMPDF(X,C,B) FOR X = 0  0.01  5
    END OF LOOP
    END OF MULTIPLOT
 
-----GOMPPF (LET)--------------------------------
 
GOMPPF
 
Name:
    GOMPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Gompertz percent point function with shape
    parameters C and B.
 
Description:
    The Gompertz distribution has the following percent point
    function:
          f(x,c,b) = b*c**x*EXP[-b*(c**x-1)/LOG(c)]
                            x >= 0; b > 0; c >= 1
 
Syntax:
    LET <y> = GOMPPF(<p>,<c>,<b>)  <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or variable containing positive
               values;
          <y> is a variable or a parameter (depending on what <p> is)
               where the computed Gompertz ppf value is stored;
          <c> is a positive number, parameter, or variable that
               specifies the first shape parameter;
          <b> is a positive number, parameter, or variable that
               specifies the second shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GOMPPF(0.95,10,8)
    LET A = GOMPPF(A1,10,8)
    LET X2 = GOMPPF(P1,B,C)
 
Note:
    If c is 1, this distribution reduces to an exponential
    distribution.  The Gompertz distribution can be interpreted
    as a truncated extreme value type I distribution.

Note:
    There are several forms given for the Gompertz distribution
    in the literature.  Some of these are given by Johnson,
    Kotz, and Balakrishnan (see Reference below).  In particular,
    one form uses the parameter alpha where alpha = LOG(c).
    Simple replace c with EXP(alpha) in the pdf formula given
    above.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GOMCDF = Compute the Gompertz cumulative distribution function.
    GOMPDF = Compute the Gompertz probability density function.
    EXPPDF = Compute the exponential probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EV1PDF = Compute the extreme value type I probability density
             function.
    EV2PDF = Compute the extreme value type II probability density
             function.
 
Reference:
    "Continuous Univariate Distributions Volume 2", 2nd. ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley and Sons, 1994,
    (pp. 25-26, 81-85).
 
Applications:
    Life Testing
 
Implementation Date:
    1995/10
 
Program:
    LET C1 = 1.1 1.1 1.1 2 2 2 5 5 5
    LET B1 = DATA 0.5 1 2 0.5 1 2 0.5 1 2
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LOOP FOR K = 1 1 9
       LET C = C1(K)
       LET B = B1(K)
       X1LABEL C = ^C, B = ^B
       PLOT GOMPPF(P,C,B) FOR P = 0.01 0.01 0.99
    END OF LOOP
    END OF MULTIPLOT
 
-----GOODNESS OF FIT------------------------------------
 
GOODNESS OF FIT
 
Name:
    GOODNESS OF FIT
 
Type:
    Analysis Command
 
Purpose:
    Perform Anderson-Darling, Kolmogorov-Smirnov, chi-square, or
    PPCC distributional goodness of fit tests.
 
Description:
    There are a number of tests for assessing the goodness of fit
    for a distributional model.  Several of these have been
    incorporated into this command.  Specifically, the following
    goodness of fit methods are supported:

        1) Kolmogorov-Smirnov
        2) Anderson-Darling
        3) Chi-Square
        4) PPCC

    Detailed descriptions of each of these methods is given below
    in the Notes section.  As a general comment, goodness of fit
    methods are typically based on comparing the cumulative distribution
    of the data with a theoretical distribution or comparing the
    quantiles of the data with the a theoretical percent point
    function.

    Previous versions of Dataplot supported separate commands
    (ANDERSON DARLING TEST, KOLMOGOROV SMIRNOV GOODNESS OF FIT TEST,
    and CHI-SQUARE GOODNESS OF FIT TEST).  These separate commands
    have been replaced with the unified GOODNESS OF FIT command and
    are no longer available).

    Some comments on this command.

       1) Dataplot separates the estimation of distribution parameters
          from the goodness of fit assessment (the old version of the
          ANDERSON DARLING TEST would generate the maximum likelihood
          estimates if the user did not specify them).

          The location and scale parameters are specified generically
          with the following commands:

              LET KSLOC = <value>
              LET KSSCALE = <value>

          The location and scale parameters default to 0 and 1 if not
          specified.

          For distributions with one or more shape parameters, you
          should enter the values of the shape parameter.

          For a list of appropriate parameter values, enter 

              HELP PROBABILITY DISTRIBUTIONS 

          or see

              http://www.itl.nist.gov/div898/software/dataplot/
              refman2/auxillar/probdist.htm

       2) For certain methods/distributions, appropriate critical
          values may be tabulated in published articles.  Alternatively,
          critical values can be generated dynamically.  See the Notes
          section below for each individual method for more information.

          Dynamically generated critical values are determined by
          generating 10,000 monte carlo simulations (and therefore
          computing 10,000 values of the goodness of fit  statistic).
          The value of the goodness of fit statistic for the original
          data is compared to these monte carlo values to determine
          critical values and p-values.

          These dynamically generated critical values should be close
          to the published values, but they may not match exactly.
          This is due to the use of different random number generators
          and seed values.  The differences tend to be greatest for
          small sample sizes.

          The advantage of using published tables is speed.  The
          advantage of dynamically generated critical values is that
          a greater number of distributions are supported and there
          is more flexibility in specifying the alpha for the
          critical values (published tables are typically limited to
          a few values of alpha).

       3) If critical values are determined dynamically, there are
          two distinct cases,

          a) In the first case, we assume that the parameters are
             known.

          b) In the second case, we assume that the parameters are
             not known (this is the more common case).

          This affects how the simulation is performed.  In both cases,
          for a given simulation random numbers are generated using
          the specified parameters.  For the case where the parameters
          are assumed known, the goodness of fit statistic is computed
          using the assumed known parameters.  For the case where the
          parameters are assumed unknown, the parameters are estimated
          from the simulated random numbers first and then the goodness
          of fit statistic is computed using these fitted parameters.

          To specify which case is used, enter the command

              SET GOODNESS OF FIT FULLY SPECIFIED <ON/OFF>

          where ON means the parameters are assumed known and OFF means
          the parameters are assumed unknown.

          When the parameters must be estimated from the data, you can
          specify the fit method to use with the following command

               SET GOODNESS OF FIT FIT METHOD <ML/PPCC/DEFAULT>

          with ML and PPCC denoting maximum likelihood and PPCC
          methods, respectively.  Using DEFAULT will select the fit
          method based on the goodness of fit criterion selected. For
          the DEFAULT choice, the Kolmogorov-Smirnov and Anderson-Darling
          goodness of fit criterion will use maximum likelihood and the
          PPCC goodness of fit criterion will use PPCC fitting.  The
          chi-square method uses a chi-square approximation to obtain the
          critical values, so no simulation is required.  The ML method
          will only be supported for distributions for which Dataplot
          supports maximum likelihood estimation.

          If maximum likelihood estimation is used, the following
          command can be used

              SET DISTRIBITIONAL FIT TYPE <method>

          See the Note: section below for details.

Syntax 1:
    <dist>  <method>  GOODNESS OF FIT  <y>
                      <SUBSET/EXCEPT/FOR qualification>
    where <dist> is one Dataplot's supported distributions;
          <method> is one of ANDERSON DARLING, KOLMOGOROV SMIRNOV,
              CHI-SQUARE, or PPCC;
          <y> is the response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    Enter HELP PROBABILITY DISTRIBUTIONS for a list of supported
    distributions and the name of any required parameters.

Syntax 2:
    <dist>  <method>  MULTIPLE GOODNESS OF FIT  <y1> ... <yk>
                      <SUBSET/EXCEPT/FOR qualification>
    where <dist> is one Dataplot's supported distributions;
          <method> is one of ANDERSON DARLING, KOLMOGOROV SMIRNOV,
              CHI-SQUARE, or PPCC;
          <y1> ... <yk> is a list of 1 to 30 response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax will generate the goodness of fit statistic for
    each variable in the list.

    Note that the syntax

         <dist> <method> MULTIPLE GOODNESS OF FIT Y1 TO Y4

    is supported.  This is equivalent to

         <dist> <method> MULTIPLE GOODNESS OF FIT Y1 Y2 Y3 Y4

Syntax 3:
    <dist>  <method>  REPLICATED GOODNESS OF FIT <y> <x1> ... <xk>   
                      <SUBSET/EXCEPT/FOR qualification>
    where <dist> is one Dataplot's supported distributions;
          <method> is one of ANDERSON DARLING, KOLMOGOROV SMIRNOV,
              CHI-SQUARE, or PPCC;
          <y> is the response variable;
          <x1> ... <xk> is a list of 1 to 6 group-id variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax peforms a cross-tabulation of <x1> ... <xk> and performs
    a goodness of fit test for each unique combination of cross-tabulated
    values.  For example, if X1 has 3 levels and X2 has 2 levels, there
    will be a total of 6 goodness of fit tests performed.

    Note that the syntax

         <dist> <method>  REPLICATED GOODNESS OF FIT Y X1 TO X4

    is supported.  This is equivalent to

         <dist> <method>  REPLICATED GOODNESS OF FIT Y X1 X2 X3 X4

Syntax 4:
    <dist>  CHI-SQUARE  GOODNESS OF FIT  <y> <x>
                        <SUBSET/EXCEPT/FOR qualification>
    where <dist> is one Dataplot's supported distributions;
          <y> is a variable of pre-computed frequencies;
          <x> is a variable containing the mid-points of the bins;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for the case where you have binned data with
    equal size bins.

    Currently, only the chi-square goodness of fit method is supported
    for grouped data (although this may change in future releases).

Syntax 5:
    <dist>  CHI-SQUARE  GOODNESS OF FIT  <y> <xlow> <xhigh>
                        <SUBSET/EXCEPT/FOR qualification>
    where <dist> is one Dataplot's supported distributions;
          <y> is a variable of pre-computed frequencies;
          <xlow> is a variable containing the lower limits of the bins;
          <xhigh> is a variable containing the upper limits of the bins;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for the case where you have binned data with
    unequal size bins.

    Currently, only the chi-square goodness of fit method is supported
    for grouped data (although this may change in future releases).

Examples:
    LET GAMMA = 2.5
    LET KSLOC = 5
    LET KSSCALE = 10
    WEIBULL ANDERSON DARLING GOODNESS OF FIT Y
    WEIBULL KOLMOGOROV SMIRNOV GOODNESS OF FIT Y
    WEIBULL PPCC GOODNESS OF FIT Y
    WEIBULL CHI-SQUARE GOODNESS OF FIT Y

Note:
    The Kolmogorov-Smirnov (K-S) test is based on the empirical
    distribution function (ECDF).  Given N data points
    Y(1), Y(2), ..., Y(n), the ECDF is defined as

        E(n) = n(i)/N

    where n(i) is the number of points less than Y(i).  This is a
    step function that increases by 1/N at the value of each data point.

    We can graph a plot of the empirical distribution function with
    a cumulative distribution function for a given distribution.  The
    K-S test is based on the maximum distance between these two curves.
    Specifically, the test statistic is

        D = max |F(Y(i)) - i/N|

    where F is the theoretical cumulative distribution of the
    distribution being tested.
   
    An attractive feature of this test is that the distribution of the
    K-S test statistic itself does not depend on the underlying
    cumulative distribution function being tested.  Another advantage is
    that it is an exact test (the chi-square goodness of fit depends on
    an adequate sample size for the approximations to be valid). Despite
    these advantages, the K-S test has several important limitations:

       1) It only applies to continuous distributions (there are
          extensions for discrete distributions, although these
          are not yet implemented in Dataplot). 
 
       2) The K-S test looks for the maximum difference wherever it
          occurs.  That is, it is equally sensitive to differences
          at the centers and tails of the distribution.  Some
          analysts prefer the Anderson-Darling test since it is
          designed to be more sensitive in the tails of the distribution.

       3) The attractive feature that the critical values do not
          depend on the underlying distribution only applies if the
          distribution is fully specified (i.e., the parameters are
          assumed known).

          If the SET GOODNESS OF FIT FULLY SPECIFIED OFF command is
          entered, the K-S test will generate the critical values
          dynamically.
          
          For the fully specified case, you can specify whether to
          use published critical values (limited to a few specific
          values of alpha) or determine a more complete distribution
          via simulation with the command

              SET KOLMOGOROV SMIRNOV CRITICAL VALUES <TABLE/SIMULATION>

          There are several formulations for obtaining the tabled
          critical values in the literature.  Dataplot uses the critical
          values from Chakravart, Laha, and Roy (see Reference: below).

Note:
    The Anderson-Darling test (Stephens, 1974) is used to test if a
    sample of data comes from a specific distribution.  It is a
    modification of the Kolmogorov-Smirnov (K-S) test and
    gives more weight to the tails than the K-S test.  The K-S
    test is distribution free in the sense that the critical values
    do not depend on the specific distribution being tested.  The
    Anderson-Darling test makes use of the specific distribution in
    calculating critical values.  This has the advantage of allowing
    a more sensitive test and the disadvantage that critical values
    must be calculated for each distribution.  For cases where published
    tables are not available, critical values can be computed dynamically
    via simulation.  This extends the number of distributions for which
    the Anderson-Darling test can be used.

    To specify whether published tables or simulation will be used
    to generate the critical values, enter the command (if the
    specified distribution does not support published tables,
    simulation will automatically be used).

         SET ANDERSON DARLING CRITICAL VALUES <TABLE/SIMULATION>

    Currently, Dataplot supports critical values from published tables

         1) normal,
         2) lognormal,
         3) exponential,
         4) Weibull, and
         5) extreme value type 1 (Gumbel)
         6) logistic
         7) double exponential
         8) uniform (0,1)
         9) generalized Pareto
        10) Cauchy
        11) Extreme Value Type 2 (Frechet)

    Dynamic simulation of critical values for other distributions
    is available when there is a built-in maximum likelihood
    estimation procedure available (see the Note section below for
    the SET DISTRIBUTIONAL FIT TYPE command for a complete list of
    supported distributions).

    Note that the uniform (0,1) case can be used for fully
    specified distributions (i.e., the shape, location, and
    scale parameters are not estimated from the data).  Simply
    apply the appropriate CDF function to the data (this transforms
    it to a (0,1) interval) and apply the uniform (0,1) test to
    the transformed data.

    The Anderson-Darling test statistic is

         A**2 = -N - S

    where 

         S = SUM[i=1 to N][((2*i-1)/N){LOG(F(Y(i)+LOG(1-F(Y(N+1-i)))}]

    where F is the cumulative distribution function of interest.

Note:
    The basic idea behind the chi-square goodness of fit test
    is to divide the range of the data into a number of
    intervals.  Then the number of points that fall into each
    interval is compared to expected number of points for that
    interval if the data in fact come from the hypothesized
    distribution.  More formally, the chi-square goodness of fit
    test statistic can be defined as follows.

    For the chi-square goodness of fit, the data is divided into k bins
    and the test statistic is defined as

        Chi-Square = SUM[i=1 to k][(O(i) - E(i))**2/E(i)]

    where O(i) is the observed frequency for bin i, and E(i) is the
    expected frequency for bin i.  The expected frequency is calculated by

        E(i) = F(Y(u)) - F(Y(l))

    where F is the cumulative distribution function for the distribution
    being tested, Y(u) is the upper limit for class i, and Y(l) is the
    lower limit for class i.

    This test is sensitive to the choice of bins.  There is no optimal
    choice for the bin width (since the optimal bin width depends on the
    distribution).  Most reasonable choices should produce similar, but
    not identical, results.

    This test is most frequently used when the data are received in
    pre-binned form (for raw data, the Anderson-Darling test is more
    powerful).  However, you can use the chi-square test for raw data
    (you typically will want to have a reasonably large data set before
    using this).  For raw data, you can specify the binning with the
    commands CLASS WIDTH, CLASS LOWER, and CLASS UPPER.  The default
    class width is 0.3 times the sample standard deviation.  To
    specify other default algorithms, enter HELP HISTOGRAM CLASS WIDTH.

    For the chi-square approximation to be valid, the expected frequency
    should be at least 5.  The chi-square approximation may not be valid
    for small samples, and if some of the counts are less than five, you
    may need to combine some bins in the tails.

    The test statistic follows, approximately, a chi-square distribution
    with (k - c) degrees of freedom where k is the number of non-empty
    cells and c = the number of parameters (including location and
    scale parameters and shape parameters) for the distribution + 1.
    For example, for a 3-parameter Weibull distribution, c = 4.

    The primary advantage of the chi square goodnes of fit test is that
    it is quite general.  It can be applied for any distribution, either
    discrete or continuous, for which the cumulative distribution function
    can be computed.  Dataplot supports the chi-square goodness of fit
    test for all distributions for which it supports a CDF function.

    There are several disadvantages:

       1) The test is sensitive to how the binning of the
          data is performed.

       2) It requires sufficient sample size so that the minimum
          expected frequency is five.

       3) It is generally not as powerful as other goodness of fit
          tests such as the Anderson-Darling.

Note:
    The PPCC method is supported for location/scale distributions
    and for distributions with a single shape parameter.  Critical
    values are generated dynamically via simulation.

    For more information on the PPCC method, enter HELP PPCC PLOT.
    Also see the NIST/SEMATACH e-Handbook of Statistical Methods:

    http://www.itl.nist.gov/div898/handbook/eda/section3/ppccplot.htm

Note:
    When the Anderson-Darling and Kolmogorov-Smirnov methods generate
    critical values dynamically, the maximum likelihood method is used
    to estimate the distribution parameters from the simulated data.

    For several distributions, you can choose an alternative estimation
    method using the command

        SET DISTRIBUTIONAL FIT TYPE <value>

    where <value> can be one of the following

        ML                       - use the default maximum likelihood,
                                   available for normal, uniform,
                                   logistic, double exponential, Cauchy,
                                   Gumbel, Slash, 1-para exponential,
                                   2-para exponential, folded normal,
                                   1-para Rayleigh, 2-para Rayleigh,
                                   1-para Maxwell, 2-para Maxwell,
                                   2-para Weibull, 3-para Weibull,
                                   2-para inverted Weibull,
                                   2-para lognormal, 2-para gamma,
                                   2-para inverted gamma,
                                   2-para geom extreme exponential,
                                   2-para fatigue life,
                                   2-para Frechet,
                                   2-para Burr Type 10,
                                   2-para logistic exponential,
                                   2-para Von Mises (location/shape),
                                   triangular, Topp and Leone,
                                   power, reflected power,
                                   generalized Pareto, 2-para alpha,
                                   asymmetric Laplace, Pareto,
                                   truncated Pareto,
                                   2-para brittle fiber Weibull,
                                   2-para beta, 4-para beta,
                                   beta normal, two-sided power,
                                   reflected generalized Topp and Leone,
                                   normal mixture
        BC (or BIAS CORRECTED)   - use the bias corrected maximum
                                   likelihood, available for
                                   1-para exponential,
                                   2-para exponential,
                                   2-para Weibull,
                                   2-para inverted Weibull,
                                   2-para Frechet
        MOMENT                   - use the moment estimates, available for
                                   uniform, Gumbel, 1-para Maxwell,
                                   2-para Maxwell, 2-para gamma,
                                   2-para inverted gamma,
                                   2-para fatigue life, 2-para Beta,
                                   4-para Beta, Pareto,
                                   generalized Pareto,
        MODIFIED MOMENT          - use the modified moment estimates,
                                   available for the 3-para Weibull,
                                   2-para Rayleigh,
                                   3-para inverted Weibull, Pareto
        LMOMENT                  - use the L-moment estimates, available
                                   for generalized Pareto, generalized
                                   extreme value, Wakeby
                                   Pearson Type 3, generalized logistic
                                   type 5, Kappa
        PERCENTILE               - use Zynakis percentile method for the
                                   3-para Weibull or 3-para inverted
                                   Weibull
        WYCOFF BAIN ENGLEHARDT   - use Wycoff, Bain, Englehardt percentile
                                   method for the 3-para Weibull or
                                   3-para inverted Weibull
        ELEMENTAL PERCENTILE     - use the elemental percentile method,
                                   available for the generalized Pareto,
                                   generalized extremed value
        ORDER STATISTIC          - use the order statistic method,
                                   available for Cauchy
        WEIGHTED ORDER STATISTIC - use the weighted order statistic
                                   method, available for Cauchy

    Note that the above list gives the distributions for which
    dynamic critical values can be obtained by simulation when the
    parameters are assumed unknown for the Anderson-Darling and
    Kolmogorov-Smirnov methods.  If a particular distribution only
    supports a single method (e.g., several currently only support
    L-moment estimates), that method will always be used.  If you
    specify a method that is not supported for a given distribution,
    the default method (usually maximum likelihood) will be used.

    Also note that a given estimation method for a particular
    distribution may fail for certain data sets.  Since a large number
    of simulated data sets are generated, this may be an issue
    for some distributions.  The output will return the number of
    times a failure in the estimation procedure was detected in the
    simulations.

Default:
    None
 
Synonyms:
    GOODNESS OF FIT TEST is a synonym for GOODNESS OF FIT
    GOF is a synonym for GOODNESS OF FIT
 
Related Commands:
    WILK-SHAPIRO TEST       = Perform Wilk-Shapiro test for normality.
    MAXIMUM LIKELIHOOD      = Perform maximum likelihood estimation for
                              a number of distributions.
    PROBABILITY PLOT        = Generates a probability plot.
    PPCC PLOT               = Generates probability plot correlation
                              coefficient plot.
    RANDOM NUMBERS          = Generate random numbers.
    HISTOGRAM               = Generates a histogram.
 
Reference:
    Stephens, M. A. (1974), "EDF Statistics for Goodness of Fit and
    Some Comparisons," Journal of the American Statistical Association,
    Vol. 69, pp. 730-737.

    Stephens, M. A. (1976), "Asymptotic Results for Goodness-of-Fit
    Statistics with Unknown Parameters," Annals of Statistics,
    Vol. 4, pp. 357-369.

    Stephens, M. A.  (1977), "Goodness of Fit for the Extreme Value
    Distribution," Biometrika, Vol. 64, pp. 583-588.

    Stephens, M. A. (1977), "Goodness of Fit with Special Reference to
    Tests for Exponentiality," Technical Report No. 262, Department of
    Statistics, Stanford University, Stanford, CA.

    Stephens, M. A. (1979), "Tests of Fit for the Logistic Distribution
    Based on the Empirical Distribution Function," Biometrika, Vol. 66,
    pp. 591-595.

    "MIL-HDBK-17 Volume 1: Guidelines for Characterization of
    Structural Materials", Depeartment of Defense, chapter 8.
    The URL for MIL-HDBK-17 is http://mil-17.udel.edu/.

    V. Choulakian and M. A. Stephens (2001), "Goodness-of-Fit Tests for
    the Generalized Pareto Distribution", Technometrics, Vol. 43, No. 4,
    pp. 478-484.

    James J. Filliben (1975), "The Probability Plot Correlation
    Coefficient Test for Normality," Technometrics, Vol. 17, No. 1.
 
    Chakravart, Laha, and Roy (1967), "Handbook of Methods of Applied
    Statistics, Volume I," John Wiley, pp. 392-394.
 
    Snedecor and Cochran (1989), "Statistical Methods", Eight Edition,
    Iowa State, 1989, pp. 76-79.

Applications:
    Distributional Modeling
 
Implementation Date:
    2009/10
 
Program:
    .  Step 1: Read the data
    .
    .          Following data from Jeffery Fong of the NIST
    .          Applied and Computational Mathematics Division.
    .          This is strength data in ksi units.
    .
    read y
    18.830
    20.800
    21.657
    23.030
    23.230
    24.050
    24.321
    25.500
    25.520
    25.800
    26.690
    26.770
    26.780
    27.050
    27.670
    29.900
    31.110
    33.200
    33.730
    33.760
    33.890
    34.760
    35.750
    35.910
    36.980
    37.080
    37.090
    39.580
    44.045
    45.290
    45.381
    end of data
    .
    .  Step 2: Apply goodness of fit tests for Weibull distribution
    .          based on ML estimates
    .
    set write decimals 5
    3-parameter weibull mle y
    let ksloc = locml
    let ksscale = scaleml
    let gamma = shapeml
    .
    .          Anderson-Darling
    .
    set anderson darling critical values table
    weibull anderson darling goodness of fit y
    set anderson darling critical values simulation
    weibull anderson darling goodness of fit y
    .
    .  Step 3: Apply goodness of fit tests for normal distribution
    .
    normal mle y
    let ksloc = xmean
    let ksscale = xsd
    .
    set anderson darling critical values table
    normal anderson darling goodness of fit y
    set anderson darling critical values simulation
    normal anderson darling goodness of fit y
    set kolmogorov smirnov critical values simulation
    normal kolmogorov smirnov goodness of fit y

-----GOODST (LET)--------------------------------
 
GOODST
 
Name:
    GOODST (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Goodwin and Stanton integral.
 
Description:
    The Goodwin and Stanton integral is defined as:

        f(x) = INTEGRAL[EXP(-t**2)/(t+x)dt]     x>=0

    where the integral is defined from 0 to x.

    Dataplot computes this function using ACM Algorithm 757 (see
    Reference: below).
 
Syntax:
    LET <y> = GOODST(<x>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative number, variable or parameter;
          <y> is a variable or a parameter (depending on what <x> 
               is) where the computed Goodwin and Stanton integral
               values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GOODST(2)
    LET A = GOODST(X) 
    LET X2 = GOODST(X) FOR X1 = 0.1 0.1 3.0
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ABRAM      = Compute the Abramowitz integral.
    CLAUSN     = Compute the Clausen integral.
    DEBYE      = Compute the Debye function.
    EXP3       = Compute the cubic exponential integral.
    LOBACH     = Compute the Lobachevski integral.
    SYNCH1     = Compute the synchrotron radiation function.
    SYNCH2     = Compute the synchrotron radiation function.
    STROM      = Compute the Stromgren integral.
    TRAN       = Compute the transport integral.
 
Reference:
    "ACM Transactions of Mathematical Software", Allan MacLead,
    Vol. 22, No. 3, September, 1996, pp. 288-301.
 
Applications:
    Special Functions
 
Implementation Date:
    1999/6
 
Program:
    TITLE AUTOMATIC
    PLOT GOODST(X) FOR X = 0 0.01 10
 
-----GRADS-------------------------------------------------------
 
GRADS
 
Name:
    GRADS
 
Type:
    Support Command
 
Purpose:
    Specifies that all subsequent trigonometric calculations (e.g.,
    LET Y = SIN(X) and ANGLE 50) be carried out in grads (as opposed to
    radians or degrees).
 
Description:
    Grads are rarely used for trigonometric calculations, so this is a
    rarely used command.
 
Syntax:
    GRADS   <ON or OFF>
    where ON specifies that grads are to be used while OFF specifies
    that radians are to be used.
 
Examples:
    GRADS
    GRADS ON
    GRADS OFF
 
Note:
    Entering GRADS with no arguments is equivalent to entering
    GRADS ON.
 
Default:
    Radians are used for trigonometric calculations.
 
Synonyms:
    None
 
Related Commands:
    TEXT        = Writes a text string.
    DEGREES     = Sets the angle units to degrees.
    RADIANS     = Sets the angle units to radians.
    ANGLE UNITS = Sets the angle units (to degrees, radians, or grads).
    ANGLE       = Sets the angle for a TEXT string.
    FONT        = Sets the font for TEXT characters.
 
Applications:
    XX
 
Implementation Date:
    Pre-1987
 
Program:
    XX
 
-----GREP-------------------------------------------------

GREP

Name:
    GREP
 
Type:
    Support Command
 
Purpose:
    This command searches one or more files for a specified
    string using an operating system specific command.
 
Description:
    This command uses an operating system command to search
    one or more files for a specified string.

    For Unix/Linux/MacOS systems, the GREP command issues a

        grep ....

    command to the operating system.

    For Windows systems, the GREP command issues a

        FINDSTR ....

    command to the operating system.

    The string that follows the GREP on the command line
    is passed to the operating system as is.  Dataplot does no
    error checking of this string.

    This is a system dependent command.  It is currently supported
    for Unix/Linux/MacOS and Windows platforms.

Syntax:
    GREP  <str>  <file-list>
    where <str> is a string to be matched;
    and   <file-list> is a string specifying the files to search.

    If <str> contains spaces, it should be enclosed in quotes.

Examples:
    GREP FIT  *.DP
    GREP RESSD  *.OUT
    GREP FIT  *.DP  >  FIT_COMMANDS.OUT
 
Note:
    The GREP capability can be implemented by direct use of the
    SYSTEM command.  For example, under Linux do something like

         system grep  fit  *.dp

    The motivation for adding this as a separate command is to
    allow the capability to be implemented in an operating
    system independent way.  This can be useful when writing
    general purpose macros that may be used on different
    operating systems.

Note:
    The Dataplot SEARCH command can also be used to search
    files.

    The SEARCH command has the advantage that it can find files in the
    Dataplot directories without specifying the full path name and
    supports a few special keywords for a few specific files.  The
    GREP command has the advantage that it can search multiple files
    and you can use wild cards in specifying the file names to search.
    The GREP command is also not limited to printing a maximum of
    80 characters for matching lines.

Note:
    Both the Linux grep command and the Windows FINDSTR commands
    support a number of different options for displaying
    the output.  A few of these are supported as follows.

    By default, the search will not be case sensitive.  To specify
    a case sensitive search, enter the command

         SET GREP CASE NOIGNORE

    To reset the default of case insenstive search, enter the command

         SET GREP CASE IGNORE

    This adds an "/I" option under Windows and a "-i" option under Linux.

    If you specify a directory name to search and you want the files
    in that directory to be searched, enter the command

         SET GREP RECURSIVE ON

    To reset the default of no recursive search, enter the command

         SET GREP RECURSIVE OFF

    This adds a "/S" option under Windows and a "-r" option under Linux.

    By default, the line number in the file where a match is found will
    be included in the output.  If you want to suppress the line number,
    enter the command

         SET GREP LINE NUMBERS OFF

    To reset the default of including the line numbers, enter the command

         SET GREP LINE NUMBERS ON

    This adds a "/N" option under Windows and a "-n" option under Linux.

    If you only want to return lines that match exactly, enter the
    command

         SET GREP EXACT MATCH ON

    To reset the default of not requiring an exact line match, enter the
    command

         SET GREP EXACT MATCH OFF

    This adds a "/X" option under Windows and a "-x" option under Linux.

    If you want to return lines that do not match, then enter the command

         SET GREP NO MATCH ON

    To reset the default of not requiring an exact line match, enter the
    command

         SET GREP NO MATCH OFF

    This adds a "/V" option under Windows and a "-v" option under Linux.

    If you want to only print the file name where a match is found,
    enter the command

         SET GREP FILE NAME ONLY ON

    To reset the default of including the specific lines in the file
    that match, enter the command

         SET GREP FILE NAME ONLY OFF

    This adds a "/M" option under Windows and a "-l" option under Linux.

    If you want to use options not supported by one of the above
    SET commands, you can enter them manually.  For example,
    under Linux you can do something like

         grep -w  FIT  *.DP

    The "-w" match will only match FIT where FIT is a complete word
    in the file.

Note:
    If you would like to save the output of the GREP command to
    a file there are two ways to do it.

    The first way is to use the CAPTURE command.  For example

        CAPTURE GREP  grep.out
        GREP FIT  *.DP *.TXT
        END OF CAPTURE

    Alternativey, you can use the ">" syntax at the end of the
    command.   For example

        GREP FIT  *.DP *.TXT   > grep.out

Note:
    File names are case sensitive on Unix/Linux/MacOS file
    systems.  For this reason, case is preserved in passing the
    file name to the operating system.

Default:
    None
 
Synonyms:
    FINDSTR is a synonym for GREP

Related Commands:
    SYSTEM      = Enter an operating system command within a
                  Dataplot session.
    SEARCH      = Search a file for a given string.
    CAT         = Display the contents of a file.
    CD          = Change the current working directory.
    PWD         = Retrieve the current working directory.
    MKDIR       = Create a new di
    RM          = Delete one or more files.
    DIR         = List the contents of a directory.
 
Applications:
    Interactive Usage
 
Implementation Date:
    2019/09
 
Program:
    grep FIT  *.DP *.TXT  macros/*.DP macros/*.TXT
 
-----GRID-------------------------------------------------------
 
GRID
 
Name:
    ...GRID
 
Type:
    Plot Control Command
 
Purpose:
    Specifies whether or not grid lines appear on subsequent plots.
 
Description:
    Grid lines are drawn at the major tic marks (the GMINOR command can
    be used to specify that grid lines be drawn at minor tic marks).
 
    The analyst can independently control both the horizontal and
    vertical grid lines by specifying the pre-fix in the command.
 
Syntax:
    <prefix>GRID   <ON or OFF>
    where ON specifies that the grid is drawn while OFF specifies that
             the grid is not drawn;
    and   <prefix> is as follows:
             no prefix     refers to both grid lines
             the prefix X  refers to vertical grids
             the prefix Y  refers to horizontal grids.
 
Examples:
    GRID ON
    GRID OFF
    GRID
    XGRID ON
    YGRID ON
 
Note:
    The GRID command with no argument is equivalent to GRID ON.
 
Default:
    The default is no grid lines.
 
Synonyms:
    None
 
Related Commands:
    GRID COLOR          = Sets the color for the plot grid.
    GRID PATTERN        = Sets the line type for the plot grid.
    GRID THICKNESS      = Sets the line thickness for the plot grid.
    GMINOR              = Sets the on/off switch for the plot minor
                          grid.
    PLOT                = Generates a data or function plot.
    FRAME               = Sets the on/off switch for the plot frame.
    FRAME COLOR         = Sets the color for the plot frame.
    FRAME COORDINATES   = Sets the location for the plot frame.
    MINIMUM             = Sets the frame minima for subsequent  plots.
    MAXIMUM             = Sets the frame maxima for subsequent  plots.
    LIMITS              = Sets the frame limits for subsequent plots.
    LOG                 = Sets the on/off switch for a log scale.
    TIC                 = Sets the on/off switch for the plot tics.
    MAJOR TIC NUMBER    = Sets the number of major tics.
    MINOR TIC NUMBER    = Sets the number of minor tics.
    TIC LABEL           = Sets the on/off switch for plot tic labels.
    TIC LABEL DECIMALS  = Sets the number of decimal places for plot
                          tic mark labels.
    MARGIN COLOR        = Sets the color for the plot margin.
    BACKGROUND COLOR    = Sets the color for the plot background.
    TITLE               = Sets the plot title.
    LABEL               = Sets the plot labels.
    LEGEND              = Sets the plot legends.
    LEGEND COORDINATES  = Sets the locations for plot legends.
    BOX COORDINATES     = Sets the locations for plot boxes.
    ARROW COORDINATES   = Sets the locations for plot arrows.
    SEGMENT COORDINATES = Sets the locations for plot segments.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    XX
 
Program:
    LET LEAD = DATA ...
       164 426 59 98 312 263 607 497 213 54 160 262 547 325 419 94 70
    LET POT = DATA ...
       106 175 61 79 94 121 424 328 107 218 140 179 246 231 245 339 99
    TITLE DEMONSTRATE GRID COMMAND
    GRID ON
    X1LABEL LEAD
    Y1LABEL POTASSIUM
    CHARACTER CIRCLE
    CHARACTER SIZE 1.5
    LINE BLANK ALL
    PLOT POT VS LEAD
 
-----GRID COLOR-------------------------------------------------------
 
GRID COLOR
 
Name:
    ...GRID COLOR
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the color of the grid lines on subsequent plots.
 
Description:
    The analyst can independently control the color of the horizontal
    and vertical grid lines by specifying the pre-fix in the command.
 
    Dataplot provides two methods for specifying colors.

        1. Colors can be defined by name (or by the corresponding index).
           Dataplot adopted it's named colors from the X11 project.
           Currently, 162 named colors and 100 levels of grayscale are
           supported.  Grayscale can be specified with either G0, G1, ...,
           G100 (or -1, -2, ..., -100).  Many older devices support only a
           limited number of colors.  For these devices, unsupported colors
           will be mapped to one of the available colors.  To specify a
           named color, see Syntax 1.

        2. Most modern graphics devices support full RGB (RedBlueGreen)
           color.  You can alternatively specify RGB colors by entering
           three integer values to represent the Red, Green and Blue
           components, respectively.  These values should be in the range
           0 to 255.

    When setting the grid RGB color, Dataplot first checks if the device
    supports RGB colors. If not, the named color will be used.  If the
    device does support RGB color, Dataplot will check if an RGB color
    has been specified.  If yes, then that RGB color is used.  If not,
    the named color will be used.

    To see the list of supported named colors (with the associated index
    number), see

    https://www.itl.nist.gov/div898/software/dataplot/refman1/ch11/homepage.htm

Syntax 1:
    <prefix>GRID COLOR   <color>
    where <color> specifies the desired color;
    and   <prefix> is one of the following:
       no prefix     refers to both grid lines
       the prefix X  refers to vertical grids
       the prefix Y  refers to horizontal grids.
 
Syntax 2:
    <prefix>GRID RGB COLOR  <red>  <green>  <blue>
    where <red> is an integer number or parameter that specifies
                the red component;
          <green> is an integer number or parameter that specifies
                the green component;
          <blue> is an integer number or parameter that specifies
                the blue component;
    and   <prefix> is one of the following:
       no prefix     refers to both grid lines
       the prefix X  refers to vertical grids
       the prefix Y  refers to horizontal grids.
 
    To turn off the RGB color, set the values to -1 (any negative value
    will work).  Values greater than 255 will be set to 255.

Examples:
    GRID COLOR YELLOW
    GRID COLOR RED
    GRID COLOR
    XGRID COLOR CYAN
    YGRID COLOR MAGENTA
    GRID RGB COLOR 220 109 88
    YGRID RGB COLOR 175 238 238
 
Note:
    The GRID COLOR command with no arguments reverts the grid color to
    default.
 
Default:
    The default is black (but the default is for the grid lines
    themselves to be off.)
 
Synonyms:
    None
 
Related Commands:
    GRID                = Sets the on/off switch for the plot grid.
    GRID PATTERN        = Sets the line type for the plot grid.
    GRID THICKNESS      = Sets the line thickness for the plot grid.
    GMINOR              = Sets the on/off switch for the plot minor
                          grid.
    PLOT                = Generates a data or function plot.
    FRAME               = Sets the on/off switch for the plot frame.
    FRAME COLOR         = Sets the color for the plot frame.
    FRAME COORDINATES   = Sets the location for the plot frame.
    MINIMUM             = Sets the frame minima for subsequent  plots.
    MAXIMUM             = Sets the frame maxima for subsequent  plots.
    LIMITS              = Sets the frame limits for subsequent plots.
    LOG                 = Sets the on/off switch for a log scale.
    TIC                 = Sets the on/off switch for the plot tics.
    MAJOR TIC NUMBER    = Sets the number of major tics.
    TIC LABEL           = Sets the on/off switch for plot tic labels.
    TIC LABEL DECIMALS  = Sets the number of decimal places for plot
                          tic mark labels.
    MARGIN COLOR        = Sets the color for the plot margin.
    BACKGROUND COLOR    = Sets the color for the plot background.
    TITLE               = Sets the plot title.
    LABEL               = Sets the plot labels.
    LEGEND              = Sets the plot legends.
    LEGEND COORDINATES  = Sets the locations for plot legends.
    BOX COORDINATES     = Sets the locations for plot boxes.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    Pre-1987
    2020/11: Support for RGB colors
 
Program 1:
    LET LEAD = DATA ...
       164 426 59 98 312 263 607 497 213 54 160 262 547 325 419 94 70
    LET POT = DATA ...
       106 175 61 79 94 121 424 328 107 218 140 179 246 231 245 339 99
    TITLE DEMONSTRATE GRID COLOR COMMAND
    GRID ON
    GRID THICKNESS 0.3
    GRID PATTERN DASH
    XGRID COLOR RED
    YGRID COLOR BLUE
    X1LABEL LEAD
    Y1LABEL POTASSIUM
    CHARACTER CIRCLE
    CHARACTER SIZE 1.5
    LINE BLANK ALL
    PLOT POT VS LEAD
 
Program 2:
    LET LEAD = DATA ...
       164 426 59 98 312 263 607 497 213 54 160 262 547 325 419 94 70
    LET POT = DATA ...
       106 175 61 79 94 121 424 328 107 218 140 179 246 231 245 339 99
    TITLE DEMONSTRATE GRID RGB COLOR COMMAND
    GRID ON
    GRID THICKNESS 0.3
    GRID PATTERN DASH
    XGRID COLOR RED
    YGRID COLOR BLUE
    XGRID RGB COLOR 220 109 88
    YGRID RGB COLOR 175 238 238
    X1LABEL LEAD
    Y1LABEL POTASSIUM
    CHARACTER CIRCLE
    CHARACTER SIZE 1.5
    LINE BLANK ALL
    PLOT POT VS LEAD
 
-----GRID PATTERN-----------------------------------------------------
 
GRID PATTERN
 
Name:
    ...GRID PATTERN
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the line type of the grid on subsequent plots.
 
Description:
    The analyst can independently control the line pattern  of the
    horizontal and vertical grid patterns by specifying the pre-fix in
    the command.
 
Syntax:
    <prefix>GRID PATTERN   <line type>
    where <line type> specifies the desired line type (enter HELP LINE
             TYPES for a list of available line styles);
    and   <prefix> is one of the following:
             no prefix     refers to both grid patterns
             the prefix X  refers to vertical grids
             the prefix Y  refers to horizontal grids.
 
Examples:
    GRID PATTERN SOLID
    GRID PATTERN DASH
    GRID PATTERN
    XGRID PATTERN DASH3
    YGRID PATTERN DOT
 
Note:
    The GRID PATTERN command with no arguments reverts the grid
    type to default.
 
Note:
    The combination
       GRID ON
       GRID PATTERN BLANK
    would yield the same effect as
       GRID OFF
 
Default:
    The default is dotted (but the default is for the grid lines
    themselves to be off.)
 
Synonyms:
    None
 
Related Commands:
    GRID                = Sets the on/off switch for the plot grid.
    GRID COLOR          = Sets the color for the plot grid.
    GRID THICKNESS      = Sets the line thickness for the plot grid.
    GMINOR              = Sets the on/off switch for the plot minor
                          grid.
    PLOT                = Generates a data or function plot.
    FRAME               = Sets the on/off switch for the plot frame.
    FRAME COLOR         = Sets the color for the plot frame.
    FRAME COORDINATES   = Sets the location for the plot frame.
    MINIMUM             = Sets the frame minima for subsequent  plots.
    MAXIMUM             = Sets the frame maxima for subsequent  plots.
    LIMITS              = Sets the frame limits for subsequent plots.
    LOG                 = Sets the on/off switch for a log scale.
    TIC                 = Sets the on/off switch for the plot tics.
    MAJOR TIC NUMBER    = Sets the number of major tics.
    MINOR TIC NUMBER    = Sets the number of minor tics.
    TIC LABEL           = Sets the on/off switch for plot tic labels.
    TIC LABEL DECIMALS  = Sets the number of decimal places for plot
                          tic mark labels.
    MARGIN COLOR        = Sets the color for the plot margin.
    BACKGROUND COLOR    = Sets the color for the plot background.
    TITLE               = Sets the plot title.
    LABEL               = Sets the plot labels.
    LEGEND              = Sets the plot legends.
    LEGEND COORDINATES  = Sets the locations for plot legends.
    BOX COORDINATES     = Sets the locations for plot boxes.
    ARROW COORDINATES   = Sets the locations for plot arrows.
    SEGMENT COORDINATES = Sets the locations for plot segments.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    XX
 
Program:
    LET LEAD = DATA ...
       164 426 59 98 312 263 607 497 213 54 160 262 547 325 419 94 70
    LET POT = DATA ...
       106 175 61 79 94 121 424 328 107 218 140 179 246 231 245 339 99
    TITLE DEMONSTRATE GRID PATTERN COMMAND
    GRID ON
    XGRID PATTERN DOTTED
    YGRID PATTERN DASH
    X1LABEL LEAD
    Y1LABEL POTASSIUM
    CHARACTER CIRCLE
    CHARACTER SIZE 1.5
    LINE BLANK ALL
    PLOT POT VS LEAD
 
-----GRID THICKNESS---------------------------------------------------
 
GRID THICKNESS
 
Name:
    ...GRID THICKNESS
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the thickness of the grid lines on subsequent plots.
 
Description:
    The analyst can independently control the thickness of the
    horizontal and vertical grid lines by specifying the pre-fix in the
    command.
 
Syntax:
    <prefix>GRID THICKNESS   <thickness>
    where <thickness> is a number or parameter that specifies the
             desired line thickness;
    and   <prefix> is one of the following:
              no prefix     refers to both grid lines
              the prefix X  refers to vertical grids
              the prefix Y  refers to horizontal grids.
 
Examples:
    GRID THICKNESS 0.1
    GRID THICKNESS 0.2
    XGRID THICKNESS 0.2
    YGRID THICKNESS 0.1
 
Note:
    The GRID THICKNESS command with no arguments reverts the grid
    thickness to default.
 
Default:
    The default is 0.1 (but the default is for the grid lines
    themselves to be off.)
 
Synonyms:
    None
 
Related Commands:
    GRID                = Sets the on/off switch for the plot grid.
    GRID COLOR          = Sets the color for the plot grid.
    GRID PATTERN        = Sets the line type for the plot grid.
    GMINOR              = Sets the on/off switch for the plot minor
                          grid.
    PLOT                = Generates a data or function plot.
    FRAME               = Sets the on/off switch for the plot frame.
    FRAME COLOR         = Sets the color for the plot frame.
    FRAME COORDINATES   = Sets the location for the plot frame.
    MINIMUM             = Sets the frame minima for subsequent  plots.
    MAXIMUM             = Sets the frame maxima for subsequent  plots.
    LIMITS              = Sets the frame limits for subsequent plots.
    LOG                 = Sets the on/off switch for a log scale.
    TIC                 = Sets the on/off switch for the plot tics.
    MAJOR TIC NUMBER    = Sets the number of major tics.
    MINOR TIC NUMBER    = Sets the number of minor tics.
    TIC LABEL           = Sets the on/off switch for plot tic labels.
    TIC LABEL DECIMALS  = Sets the number of decimal places for plot
                          tic mark labels.
    MARGIN COLOR        = Sets the color for the plot margin.
    BACKGROUND COLOR    = Sets the color for the plot background.
    TITLE               = Sets the plot title.
    LABEL               = Sets the plot labels.
    LEGEND              = Sets the plot legends.
    LEGEND COORDINATES  = Sets the locations for plot legends.
    BOX COORDINATES     = Sets the locations for plot boxes.
    ARROW COORDINATES   = Sets the locations for plot arrows.
    SEGMENT COORDINATES = Sets the locations for plot segments.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    XX
 
Program:
    LET LEAD = DATA ...
       164 426 59 98 312 263 607 497 213 54 160 262 547 325 419 94 70
    LET POT = DATA ...
       106 175 61 79 94 121 424 328 107 218 140 179 246 231 245 339 99
    TITLE DEMONSTRATE GRID THICKNESS COMMAND
    GRID ON
    XGRID THICKNESS 0.3
    YGRID THICKNESS 0.1
    X1LABEL LEAD
    Y1LABEL POTASSIUM
    CHARACTER CIRCLE
    CHARACTER SIZE 1.5
    LINE BLANK ALL
    PLOT POT VS LEAD
 
-----GROUND-------------------------------------------------------
 
GROUND
 
Name:
    GROUND
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Draws a ground (a component used in electronic circuit diagrams).
 
Description:
    The 2 pairs of coordinates define the (x,y) values for the entry
    point and the tip (respectively) of the ground.
 
Syntax:
    GROUND   <x1>   <y1>   <x2>   <y2>
    where <x1> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for the entry point of the
               grid;
          <y1> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for the entry point of the
               grid;
          <x2> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for the tip of the grid.
    and   <y2> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for the tip of the grid.
 
Examples:
    GROUND 50 50 50 30
    GROUND 30 30 30 25
    GROUND 40 80 40 85
    GROUND X1 Y1 X2 Y2
 
Note:
    The line style (i.e., solid, dash), color, and thickness are
    controlled by the LINE, LINE COLOR, and LINE THICKNESS commands.
 
Note:
    The keywords DATA and RELATIVE were added to the TRIANGLE
    command 7/1997.  These keywords are independent and can
    be used separately or together.  For example, 
    TRIANGLE DATA, TRIANGLE RELATIVE, or TRIANGLE DATA RELATIVE.
    The word DATA should come before the word RELATIVE if both
    appear.

    DATA means that the coordinates are specified in terms of
    the data units of the most recent plot rather than Dataplot
    0 to 100 screen units.

    RELATIVE means that the coordinates of the first point
    are drawn in absolute coordinates an all subsequent points
    in the figure are relative to that first point.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    AMPLIFIER        = Draws an amplifier.
    CAPACITOR        = Draws a capacitor.
    INDUCTOR         = Draws an inductor.
    RESISTOR         = Draws a resistor.
    DRAW             = Draws a line.
    MOVE             = Moves to a point.
    LINES            = Sets the line type for figures and plot lines.
    LINE THICKNESSES = Sets the line thickness for figures and  plot
                       lines.
    LINE COLOR       = Sets the line colors for figures and plot lines.
    CROSS-HAIR       = Activates and reads the cross-hair.
    TEXT             = Writes a text string.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    Pre-1987
 
Program:
    LINE SOLID
    LINE COLOR BLACK
    LINE THICKNESS 0.2
    GROUND 20 70 50 70
    MOVE 20 90
    TEXT GROUND COORDINATES (20,70), (50,70)
 
-----GROUPED CORRELATION (LET)--------------------------------
 
GROUPED CORRELATION
 
Name:
    GROUPED CORRELATION (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the grouped correlation coefficient between two variables.
 
Description:
    At times, you may data in the form of a bivariate frequency table.
    For example, something like

         X/Y  | 10-20    20-30     30-40    40-50    50-60
        ================================================
        15-25 |   6        3         0        0        0
        25-35 |   3       16        10        0        0
        35-45 |   0       10        15        7        0
        45-55 |   0        0         7       10        4
        55-65 |   0        0         0        4        5

    In Dataplot, you would create the data as

             X     Y  FREQ
         =================
            20    15     6
            20    25     3
            20    35     0
            20    45     0
            20    55     0
            30    15     3
            30    25    16
            30    35    10
            30    45     0
            30    55     0
            40    15     0
            40    25    10
            40    35    15
            40    45     7
            40    55     0
            50    15     0
            50    25     0
            50    35     7
            50    45    10
            50    55     4
            60    15     0
            60    25     0
            60    35     0
            60    45     4
            60    55     5

    The computational formula for the grouped correlation is

        r = {n*SUM[i=1 to k][f(i)*x(i)*y(i)] -
            (SUM[i=1 to k][x(i)])*(SUM[i=1 to k][y(i)])}/
            {SQRT((n*SUM[i=1 to k][f(i)*x(i)**2] -
            (SUM[i=1 to k][f(i)*x(i)])**2)*
            ((n*SUM[i=1 to k][f(i)*y(i)**2] -
            (SUM[i=1 to k][f(i)*y(i)])**2)))}

    where

        k     = the number of groups
        f(i)  = the frequency of the i-th group
        n     = the sum of the f(i) (i.e., the total frequency)
        x(i)  = the mid-point of the i-th group for the x variable
        y(i)  = the mid-point of the i-th group for the y variable

    If the groups are equally spaced (the distances between x(i) and
    x(i+1) are equal for all i and the distances between y(i) and y(i+1)
    are equal for all i), then computational convenience Dataplot will
    use coded values for the x(i) and the y(i).

    If you have groups with zero frequency, you may either omit or
    include these groups in your data.  Dataplot strips out the zero
    frequency groups automatically before computing the grouped
    correlation.

Syntax:
    LET <par> = GROUPED CORRELATION <y1> <y2> <freq>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <freq> is the variable containing the frequencies;
          <par> is a parameter where the computed grouped correlation is
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GROUPED CORRELATION Y1 Y2 FREQ
 
Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    WEIGHTED CORRELATION        = Compute a weighted correlation
                                  coefficient.
    CORRELATION                 = Compute the correlation of two variables.
    CORRELATION MATRIX          = Generate a correlation matrix.
    RANK CORRELATION            = Compute the rank correlation of two
                                  variables.
    KENDALLS TAU                = Compute the Kendall tau correlation of
                                  two variables.
 
Reference:
    Selby (1974), "CRC Standard Mathematical Tables", 22nd Edition,
    CRC Press, p. 577.

Applications:
    Frequency Data
 
Implementation Date:
    2018/11
 
Program:
    set write decimals 4
    .
    read x  y  freq
     20    15  6
     20    25  3
     20    35  0
     20    45  0
     20    55  0
     30    15  3
     30    25 16
     30    35 10
     30    45  0
     30    55  0
     40    15  0
     40    25 10
     40    35 15
     40    45  7
     40    55  0
     50    15  0
     50    25  0
     50    35  7
     50    45 10
     50    55  4
     60    15  0
     60    25  0
     60    35  0
     60    45  4
     60    55  5
    end of data
    .
    let cor = grouped correlation x y freq
    set parameter expand digits 2
    print "Group Correlation: ^cor"
 
-----GROUP LABEL TO STRINGS-------------------------------------------
 
GROUP LABEL TO STRINGS
 
Name:
    GROUP LABEL TO STRINGS
 
Type:
    Let Subcommand
 
Purpose:
    Convert group labels to strings.
 
Description:
    The GROUP LABEL command can be used to convert previously read 
    character data to group labels.  Group labels are primarily
    used with the TIC MARK LABEL FORMAT and TIC MARK LABEL CONTENT
    commands.

    It may sometimes be useful to convert these group labels to
    individual strings to permit greater flexibility in how they
    are used.

    With this command, you define a base name.  Then an integer is
    appended to the base name to create the individual strings.  For
    example, if the base name is S and there are 10 values in the
    group label variable, this command will create the strings S1, S2,
    ..., S10.

    Currently, a maximum of 999 strings can be created with this
    command.

Syntax:
    LET <sbase> = GROUP LABEL TO STRINGS  <ig>
    where <sbase> is the base name for the strings to be created;
    and   <ig> is a previously created group label variable name.

Examples:
    LET SOUT = GROUP LABEL TO STRINGS IG
 
Note:
    The number of strings generated by this command will be saved
    in the internal parameter NUMSTRIN.

Note:
    The total number of characters that DATAPLOT can use for storing
    functions and strings is set when DATAPLOT is built.  The current
    default (11/2008) is 50,000 characters.  Previous versions may set
    this limit at 1,000 or 10,000 characters.  This limit applies to
    the combined number of characters for all functions and strings.

    The current maximum number of names (i.e., for all parameters,
    variables, matrices, and functions/strings) is currently set to
    50,000.

    An error message will be generated if either of these limits is
    exceeded when running this command.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GROUP LABEL            = Create a group label variable from previously
                             read character data or previously defined
                             strings.
    CHARACTER CODE         = Convert previously read character data to
                             a coded numeric variable.
    CONVERT CHARACTER      = Specify whether Dataplot READ comamnd will
                             try to read character fields.
    LET STRING             = Defines a string.
    READ STRING            = Reads a string from a file.
    TIC MARK LABEL FORMAT  = Specify the format for tic mark labels.
    TIC MARK LABEL CONTENT = Specify the content for tic mark labels.

Applications:
    Data Management
 
Implementation Date:
    10/2011
 
Program:
    set convert character on
    skip 25
    read draft69c.dat rank day month
    .
    let ig = group label month
    let smonth = group label to strings ig
    print smonth1 to smonth^numstrin
 
-----GROUP LABEL---------------------------------------------
 
GROUP LABEL
 
Name:
    GROUP LABEL (LET)
 
Type:
    Subcommand under LET
 
Purpose:
    Converts previously read character data, literal text strings,
    or previously defined strings to group labels.
 
Description:
    Dataplot can now read character data using the
 
        SET CONVERT CHARACTER ON

    command.  This command stores the character fields in the
    file "dpchzf.dat".

    The two primary uses of character data are:

       1) Provide a row identifier for the data.

       2) Define a group (or factor) variable.  For example, we
          can identify sex by coding males as M and females as F.

    In the context of Dataplot, we can use groups in two contexts.

       1) The group variable can be used in a numerical context.
          For example,

              BOX PLOT Y X

          Here, X is the group-id variable.

          The command CHARACTER CODE (or ALPHABETIC CHARACTER CODE)
          can be used to create a coded numeric variable from
          a character variable saved in the file dpchzf.dat.

       2) We may want to use the group label for labeling.  In
          this case, we typically want to use the character coding.

          The GROUP LABEL command is used to create character
          group labels from a character variable saved in
          the file dpchzf.dat.

          The GROUP LABEL will extract and save the unique rows for
          the specified character variable.

          As of version 1/2004, Dataplot can use the group labels
          for the tic mark labels on a plot.  Enter

              HELP TIC MARK LABEL FORMAT
              HELP TIC MARK LABEL CONTENT

          for details.  We anticipate additional uses of group
          labels in subsequent releases of Dataplot.
Syntax 1:
    LET <ig> = GROUP LABEL <ix>
    where <ix> specifies the name of the character variable in
               the file dpzchf.dat;
    and   <ig> specifies the name for the group label variable.

    The character variable is originally created with a READ
    command where the SET CONVERT CHARACTER ON was entered prior
    to the READ.

Syntax 2:
    LET <ig> = GROUP LABEL <str1> .... <strk>
    where <str1> ... <strk> denote k literal text strings.

    This syntax can be used to define a group label variable
    by entering explicit text strings.  Each string is separated
    by one or more spaces.  If the text string contains a space,
    enter the space as SP() since in this context, quotes are not
    used to delineate the strings (a quote will simply be
    considered part of the text string).

Syntax 3:
    LET <ig> = GROUP LABEL <str1> ... <strk>
    where <str1> ... <strk> denote k previously defined strings.

    This syntax can be used to define a group label variable
    based on previously defined strings.  Note that this syntax
    supports the TO clause.  That is,

       LET IG = GROUP LABEL S1 TO S5

    will create the group label variable from the previously
    defined strings S1, S2, S3, S4, and S5.

    Note that if any of the names listed are not previously
    defined strings, then all of the names will be interpreted
    as literal text (i.e., Syntax 2).

Examples:
    SET CONVERT CHARACTER ON
    READ TEST.DAT  Y X IX
    LET IG = GROUP LABEL IX

    LET IG = GROUP LABEL CASESP()1 CASESP()2 CASESP()3

    LET STRING S1 = Case 1
    LET STRING S2 = Case 2
    LET STRING S3 = Case 3
    LET STRING S4 = Case 4
    LET STRING S5 = Case 5
    LET IG = GROUP LABEL S1 TO S5

Note:
    Dataplot allows a maximum of five group label variables.
    You may reuse a group label variable by using the name of a
    previously entered group label.

    The maximum number of levels for a given group is
    MAXOBV/100 with MAXOBV denoting the maximum number of
    observations for a variable (this is typically set to either
    100,000 or 20,000).

Note:
    The SORT BY <statistic> command can be used to generate
    sorted plots.  This command returns an index variable that
    can be used to conveniently sort the tick mark labels created
    using the GROUP LABEL command.  Enter HELP SORT BY for details.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    READ                        = Carries out a column-wise input of
                                  data.
    CONVERT CHARACTER           = Specify how Dataplot will handle
                                  character data.
    CHARACTER CODE              = Converts character data to a coded
                                   numeric variable.
    ALPHABETIC CHARACTER CODE   = Converts character data to a coded
                                  numeric variable.
    ROWLABELS                   = Define row labels from character
                                  data.
    SORT BY                     = Sort a response variable and a
                                  group-id variable by a statistic.
    TIC MARK LABEL FORMAT       = Specify the format for tick mark
                                  labels.
    TIC MARK LABEL CONTENT      = Specify the content for alphabetic
                                  tick mark labels.
 
Applications:
    Input/Output
 
Implementation Date:
    2004/1
    2006/1: Added Syntax 2 and Syntax 3 versions of the command
 
Program:
    set convert character on
    skip 25
    read draft69c.dat rank day month
    .
    let ig = group label month
    x1tic mark label format group label
    x1tic mark label content ig
    x1tic mark label font simplex
    x1tic mark label angle 45
    x1tic mark label displacement 10
    let xcode = character code month
    .
    major xtic mark number 12
    minor xtic mark number 0
    xlimits 1 12
    xtic offset 0.5 0.5
    .
    char box plot
    line box plot
    fences on
    .
    box plot rank xcode

-----GRUBBS TEST------------------------------------
 
GRUBBS TEST
 
Name:
    GRUBBS TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform a Grubbs test for outliers.
 
Description:
    The Grubbs test, also know as the maximum normalized residual
    test, can be used to test for outliers in a univariate
    data set.  Note that this test assumes normality, so you
    test the data for normality before applying the Grubbs test.

    More formally, the Grubbs test can be defined as follows.

    H0:          There are no outliers in the data.
    Ha:          There is at least one outlier in the data.

    Test         G = MAX(ABS(Y(i) - YBAR))/s
    Statistc:    where YBAR and s are the sample mean and
                 standard deviation of the data.  That is,
                 the Grubbs test statistic is the largest
                 absolute deviation from the sample mean in
                 units of the sample standard deviation.

    Significance alpha
    Level:
    
    Critical     The hypothesis of no outliers is rejected if
    Region:      G > [(N-1)/SQRT(N)]*SQRT[(t(1-alpha/2(2*N),N-2)**2/
                            (N - 2 + t(1-alpha/(2*N),N-2)**2)]
                 where t is the critical value of the t distribution.
 
    Note that the above is actually a combination of the following
    two tests:

        1) the test that the minimum value is an outlier.

        2) the test that the maximum value is an outlier.

    To generate these one-sided tests, the test statistic is

         G = (YBAR - Ymin)/s

    or

         G = (Ymax - YBAR)/s

    The significance level in the TPPF function needs to be
    doubled for the one-sided tests.

    You can request that one of the one-sided tests be
    performed (see the Syntax section).

    Typically, graphical methods such as the box plot or histogram
    are used to detect outliers.  However, the Grubbs test can
    be used if you prefer a more formal test.

Syntax 1:
    GRUBBS TEST   <y>    <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable being tested;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax performs the two-sided test.

Syntax 2:
    GRUBBS MINIMUM TEST   <y>    <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable being tested;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax performs the one-sided test for the minimum value.

Syntax 3:
    GRUBBS MAXIMUM TEST   <y>    <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable being tested;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax performs the one-sided test for the maximum value.

Syntax 4:
    GRUBBS TEST <y> <labid>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable being tested;
          <labid> is a variable containing the lab-id corresponding
              to each value of the response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax can also be used with the MINIMUM and MAXIMUM version
    of the tests.  The <labid> variable is used to identify the
    lab-id of the minimum and maximum points.  However, it is not
    used in the computation of the statistic.

Syntax 5:
    GRUBBS MULTIPLE TEST <y1> ... <yk>   
                         <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of up to k response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax can also be used with the MINIMUM and MAXIMUM version
    of the tests.  This syntax performs a Grubb test on <y1>, then
    on <y2>, and so on.  Up to 30 response variables may be specified.

    Note that the syntax

         GRUBB MULTIPLE TEST Y1 TO Y4

    is supported.  This is equivalent to

         GRUBB MULTIPLE TEST Y1 Y2 Y3 Y4

Syntax 6:
    GRUBBS REPLICATED TEST <y> <x1> ... <xk>   
                           <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the response variable;
          <x1> ... <xk> is a list of up to k group-id variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax can also be used with the MINIMUM and MAXIMUM version
    of the tests.  This syntax peforms a cross-tabulation of
    <x1> ... <xk> and performs a Grubbs test for each unique
    combination of cross-tabulated values.  For example, if
    X1 has 3 levels and X2 has 2 levels, there will be a total of
    6 Grubbs tests performed.

    Up to six group-id variables can be specified.

    Note that the syntax

         GRUBB REPLICATED TEST Y X1 TO X4

    is supported.  This is equivalent to

         GRUBB REPLICATED TEST Y X1 X2 X3 X4

Examples:
    GRUBBS TEST Y1
    GRUBBS TEST Y1 LABID
    GRUBBS MULTIPLE TEST Y1 Y2 Y3
    GRUBBS REPLICATED TEST Y X1 X2
    GRUBBS TEST Y1   SUBSET TAG > 2
    GRUBBS MINIMUM TEST Y1
    GRUBBS MAXIMUM TEST Y1

Note:
    Masking and swamping are two issues that can affect outlier tests.

    Masking can occur when we specify too few outliers in the test. For
    example, if we are testing for a single outlier when there are in
    fact two (or more) outliers, these additional outliers may influence
    the value of the test statistic enough so that no points are
    declared as outliers.

    On the other hand, swamping can occur when we specify too many
    outliers in the test. For example, if we are testing for two
    outliers when there is in fact only a single outlier, both points
    may be declared outliers.

    The possibility of masking and swamping are an important reason
    why it is useful to complement formal outlier tests with graphical
    methods. Graphics can often help identify cases where masking or
    swamping may be an issue.

    Also, masking is one reason that trying to apply a single outlier
    test sequentially can fail. If there are multiple outliers, masking
    may cause the outlier test for the first outlier to return a
    conclusion of no outliers (and so the testing for any additional
    outliers is not done).

    The Grubbs test is used to check for a single outlier.  If there
    are in fact multiple outliers, the results of the Grubbs test can
    be distorted.

    If multiple outliers are suspected, then the Tietjen-Moore or the
    generalized extreme studentized deviate tests may be preferred.
    The Tietjen-Moore test is a generalization of the Grubbs test
    for the case where multiple outliers may be present.  The
    Tietjen-Moore test requires that the number of suspected outliers
    be specified exactly while the generalized extreme studentized
    deviate test only requires that an upper bound on the suspected
    number of outliers be specified.

Note:
    Tests for outliers are dependent on knowing the distribution of
    the data.  The Grubbs test assumes that the data come from an
    approximately normal distribution.  For this reason, it is
    strongly recommended that the Grubbs test be complemented with
    a normal probability test.  If the data are not approximately
    normally distributed, then the Grubbs test may be detecting
    the non-normality of the data rather than the presence of an
    outlier.

Note:
    You can specify the number of digits in the Grubbs output with
    the command

        SET WRITE DECIMALS <value>

Note:
    The GRUBBS TEST command automatically saves the following
    parameters:

       STATVAL    = the value of the test statistic
       CUTOFF0    = the 0 percent point of the reference distribution
       CUTOFF50   = the 50 percent point of the reference distribution
       CUTOFF75   = the 75 percent point of the reference distribution
       CUTOFF90   = the 90 percent point of the reference distribution
       CUTOFF95   = the 95 percent point of the reference distribution
       CUTOFF975  = the 97.5 percent point of the reference distribution
       CUTOFF99   = the 99 percent point of the reference distribution

    If the MULTIPLE or REPLICATED option is used, these values will
    be written to the file "dpst1f.dat" instead.

Note:
    In addition to the GRUBBS TEST command, the following commands
    can also be used:

        LET A = GRUBBS CDF Y
        LET A = GRUBBS DIRECTION Y
        LET A = GRUBBS INDEX Y
        LET A = GRUBBS Y

    The GRUBBS INDEX returns the row index of the most extreme
    point and GRUBBS DIRECTION specifies whether the most extreme
    point is in the minimum direction (a -1 is returned) or the
    maximum direction (a +1 is returned).

    In addition to the above LET command, built-in statistics are
    supported for about 17 different commands (enter HELP STATISTICS
    for details).

Note:
    The ASTM E178-16a addresses the case where an independent estimate
    of the standard deviation is available.  In this case, this
    independent estimate of the standard deviation replaces the
    standard deviation based on the current sample data in the
    test statistic for Grubbs test.  This independent estimate of
    the standard deviation will also have an associated degrees of
    freedom (typically the sample size of the data used to compute
    this independent estimate of standard deviation).

    Alternatively, the population standard deviation may be considered
    to be known accurately (usually based on extensive historical
    data).

    In either of these cases, the critical values for the Grubbs
    test are modified.

    To support these options, enter the commands

       SET GRUBB STANDARD DEVIATION <value>
       SET GRUBB DEGREES OF FREEDOM <value>

    If the specified standard deviation is positive, Dataplot
    uses the formulas based on the independent estimate of the
    standard deviation.  If the degrees of freedom are not specified,
    a value of 10,000 will be used.  Essentially, any value greater
    than 120 is effectively treated as a "known" population standard
    deviation.

    To compute the critical values using simulation, enter the command

        SET GRUBB TEST CRITICAL VALUES SIMULATION

    To reset the default of basing the critical values on a
    formula, enter

        SET GRUBB TEST CRITICAL VALUES FORMULA

    The formula from the E178 standard is

        Tn(alpha) = t(alpha/n,nu)*SQRT(1 - (1/n))

    where t is the percent point function of the t distribution and nu
    is the degrees of freedom.  For the "known" standard deviation case,
    the t distribution is replaced with a normal distribution.

Default:
    None
 
Synonyms:
    MULTIPLE GRUBBS TEST is a synonym for GRUBBS MULTIPLE TEST
    REPLICATED GRUBBS TEST is a synonym for GRUBBS REPLICATED TEST
 
Related Commands:
    TIETJEN-MOORE TEST          = Perform the Tietjen-Moore outlier
                                  test.
    EXTREME STUDENTIZED DEVIATE = Perform the generalized extreme
                                  studentized deviate outlier test.
    DIXON TEST                  = Perform the Dixon outlier test.
    DAVID TEST                  = Perform the David, Hartley and
                                  Pearson outlier test.
    SKEWNESS OUTLIER TEST       = Perform the skewness outlier test.
    KURTOSIS OUTLIER TEST       = Perform the kurtosis outlier test.
    ANDERSON DARLING TEST       = Perform the Anderson-Darling test for
                                  normality.
    WILK SHAPIRO TEST           = Perform the Wilk-Shapiro test for
                                  normality.
    PROBABILITY PLOT            = Generates a probability plot.
    HISTOGRAM                   = Generate a histogram.
    BOX PLOT                    = Generate a box plot.
 
Reference:
    Grubbs, F. E., "Procedures for Detecting Outlying Observations
    in Samples", Technometrics, Vol. 11, No. 4, February, 1969,
    pp. 1-21.

    Stefansky, W., "Rejecting Outliers in Factorial Designs",
    Technometrics, Vol. 14, 1972, pp. 469-479. 
 
    E178 - 16A (2016), "Standard Practice for Dealing with Outlying
    Observations", ASTM International, 100 Barr Harbor Drive,
    PO Box C700, West Conshohocken, PA 19428-2959, USA.

Applications:
    Outlier Detection
 
Implementation Date:
    1998/5
    2005/5: Corrected the significance levels for the two-sided
            case (previous version was actually using the
            significance level for the one-sided case)
    2005/5: Added support for the one-sided tests
    2006/3: Replaced 2005/5 update for one-sided tests with
            Syntax 2 and Syntax 3
    2009/10: Significantly modified the output format
    2009/10: Added support for Syntax 4, Syntax 5, and Syntax 6
    2019/10: Added support for an independent estimate of the
             standard deviation
 
Program:
    SKIP 25
    READ VANGEL31.DAT Y
    SET WRITE DECIMALS 4
    GRUBBS TEST Y

    The following output is generated:
  
           *************************
           **      GRUBBS TEST Y  **
           *************************

                Grubb Test for Outliers: Test for Minimum and Maximum
                               (Assumption: Normality)
     
    Response Variable: Y
     
    H0: There are no outliers
    Ha: The extreme point is an outlier
     
    Summary Statistics:
    Number of Observations:                              38
    Sample Minimum:                                147.0000
    ID for Sample Minimum:                                1
    Sample Maximum:                                231.0000
    ID for Sample Maximum:                               38
    Sample Mean:                                   185.7894
    Sample SD:                                      18.5954
     
    Grubbs Test Statistic Value:                     2.4312
     
     
    Percent Points of the Reference Distribution
    -----------------------------------
      Percent Point               Value
    -----------------------------------
                0.0    =          0.000
               50.0    =          2.392
               75.0    =          2.601
               90.0    =          2.846
               95.0    =          3.013
               97.5    =          3.169
               99.0    =          3.355
              100.0    =          6.001
     
    Conclusions (Upper 1-Tailed Test)
    ----------------------------------------------
      Alpha    CDF   Critical Value     Conclusion
    ----------------------------------------------
        10%    90%            2.846      Accept H0
         5%    95%            3.013      Accept H0
       2.5%  97.5%            3.169      Accept H0
         1%    99%            3.355      Accept H0

-----GT (LET)--------------------------------
 
GT
 
Name:
    GT (LET)
 
Type:
    Library Function
 
Purpose:
    Return a 1 if the first number is greater than the second
    and return a 0 otherwise.

Description:
    SUBSET clauses do not support syntax like the following:

         LET Y = Y1  SUBSET Y1 > Y2
         LET Y = Y1  SUBSET Y1 >= Y2
         LET Y = Y1  SUBSET Y1 < Y2
         LET Y = Y1  SUBSET Y1 <= Y2
         LET Y = Y1  SUBSET Y1 = Y2
         LET Y = Y1  SUBSET Y1 <> Y2

    where Y1 and Y2 are both variables.

    This command is most typically used to create a tag variable
    that can be used on subsequent SUBSET clauses.  For example,
    suppose that Y1 and Y2 are two previously created variables and
    we want to sum the values of Y1 that are greater than the
    corresponding rows of Y2.

        LET TAG = GT(Y1,Y2)
        LET Y1SUM = SUM Y1 SUBSET TAG = 1
 
Syntax:
    LET <tag> = GT(<y1>,<y2>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter;
          <tag> is a variable or a parameter (depending on what <y1> and
               <y2> are) where the computed values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET TAG = GT(Y1,Y2)
    LET A = GT(3,2)

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GE       = Return 1 where the first number is greater than or
               equal to the second number and 0 otherwise.
    LT       = Return 1 where the first number is less than the second
               number and 0 otherwise.
    LE       = Return 1 where the first number is less than or
               equal to the second number and zero otherwise.
    EQ       = Return 1 where the first number is equal to the second
               number and zero otherwise.
    NE       = Return 1 where the first number is not equal to the second
               number and zero otherwise.
 
Applications:
    Data Management
 
Implementation Date:
    2021/06
 
Program:
    SKIP 25
    READ NATR332.DAT Y1 Y2
    LET TAG = GT(Y1,Y2)
    LET NGT = SUM TAG SUBSET TAG = 1
    LET TAG = LT(Y1,Y2)
    LET NLT = SUM TAG SUBSET TAG = 1
    LET TAG = EQ(Y1,Y2)
    LET NEQ = SUM TAG SUBSET TAG = 1
    PRINT "Number of rows where Y1 > Y2:   ^NGT"
    PRINT "Number of rows where Y1 < Y2:   ^NLT"
    PRINT "Number of rows where Y1 = Y2:   ^NEQ"
 
-----GTLCDF (LET)--------------------------------
 
GTLCDF
 
Name:
    GTLCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized Topp and Leone cumulative distribution
    function with shape parameters alpha and beta.
 
Description:
    The generalized Topp and Leone distribution has the following
    cumulative distribution function:

       F(x;alpha,beta,a,b) = ((x-a)/(b-a))**beta*
                             {alpha - (alpha-1)*((x-a)/(b-a))}**beta
                             a <= x <= b; 0 < alpha <= 2; beta > 0

    with alpha and beta denoting the shape parameters and
    a and b the lower and upper limits, respectively.

    The case where a = 0 and b = 1 is referred to as the
    standard generalized Topp and Leone distribution.  It
    has the following cumulative distribution function:

       F(x;alpha,beta) = x**beta*{alpha - (alpha-1)*x}**beta
                         a <= x <= b; 0 < alpha <= 2; beta > 0

    The lower and upper limits are related to the location
    and scale parameters as follows:

        location = a
        scale    = b - a

Syntax:
    LET <y> = GTLCDF(<x>,<alpha>,<beta>,<a>,<b>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable containing
              values in the interval (a,b);
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed generalized Topp and Leone
              cdf value is stored;
          <alpha> is a number, parameter, or variable in the
              interval (0, 2) that specifies the first shape
              parameter;
          <beta> is a positive number, parameter, or variable that
              specifies the second shape parameter;
          <a> is a number, parameter, or variable that
              specifies the lower limit;
          <b> is a number, parameter, or variable that
              specifies the upper limit;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <a> and <b> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = GTLCDF(0.3,0.2,1.2)
    LET Y = GTLCDF(X,0.5,2)
    PLOT GTLCDF(X,2,3) FOR X = 0  0.01  1
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GTLPDF = Compute the generalized Topp and Leone probability
             density function.
    GTLPPF = Compute the generalized Topp and Leone percent point
             function.
    RGTPDF = Compute the reflected generalized Topp and Leone
             probability density function.
    TOPPDF = Compute the Topp and Leone probability density
             function.
    TSPPDF = Compute the two-sided power probability density
             function.
    BETPDF = Compute the beta probability density function.
    TRIPDF = Compute the triangular probability density function.
    TRAPDF = Compute the trapezoid probability density function.
    UNIPDF = Compute the uniform probability density function.
    POWPDF = Compute the power probability density function.
    JSBPDF = Compute the Johnson SB probability density function.
 
Reference:
    Samuel Kotz and J. Rene Van Dorp 2004, "Beyond Beta:
    Other Continuous Families of Distributions with Bounded
    Support and Applications", World Scientific, chapter 7.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/2
 
Program 1:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 3
    .
    LET ALPHA = 2
    LET BETA  = 3
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT GTLCDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 1.5
    LET BETA  = 6
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT GTLCDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 1.5
    LET BETA  = 2
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT GTLCDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 1.5
    LET BETA  = 1
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT GTLCDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 0.5
    LET BETA  = 2
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT GTLCDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 0.5
    LET BETA  = 1
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT GTLCDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 0.5
    LET BETA  = 0.75
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT GTLCDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 0.5
    LET BETA  = 0.25
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT GTLCDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 1
    LET BETA  = 1
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT GTLCDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    END OF MULTIPLOT

-----GTLPDF (LET)--------------------------------
 
GTLPDF
 
Name:
    GTLPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized Topp and Leone probability density
    function with shape parameters alpha and beta.
 
Description:
    The generalized Topp and Leone distribution has the following
    probability density function:

       f(x;alpha,beta,a,b) = beta*{alpha*((x-a)/b-a)) - 
                             (alpha - 1)*((x-a)/(b-a))**2}**{beta-1)*
                             (alpha - 2*(alpha - 1)*((x-a)/(b-a)))
                             a <= x <= b, beta > 0, 0 < alpha <= 2
 
    with alpha and beta denoting the shape parameters and
    a and b the lower and upper limits, respectively.

    The case where a = 0 and b = 1 is referred to as the
    standard generalized Topp and Leone distribution.  It
    has the following probability density function:

       f(x;alpha,beta) = beta*{alpha*x - (alpha - 1)*x**2}**{beta-1)*
                         (alpha - 2*(alpha - 1)*x)  
                         0 <= x <= 1, beta > 0, 0 < alpha <= 2

    The lower and upper limits are related to the location
    and scale parameters as follows:

        location = a
        scale    = b - a

    Kotz and van Dorp have proposed this distribution as an
    alternative to the beta distribution.

Syntax:
    LET <y> = GTLPDF(<x>,<alpha>,<beta>,<a>,<b>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable containing
              values in the interval (a,b);
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed generalized Topp and Leone
              pdf value is stored;
          <alpha> is a number, parameter, or variable in the
              interval (0, 2) that specifies the first shape
              parameter;
          <beta> is a positive number, parameter, or variable that
              specifies the second shape parameter;
          <a> is a number, parameter, or variable that
              specifies the lower limit;
          <b> is a number, parameter, or variable that
              specifies the upper limit;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <a> and <b> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = GTLPDF(0.3,0.2,1.2)
    LET Y = GTLPDF(X,0.5,2)
    PLOT GTLPDF(X,2,3) FOR X = 0  0.01  1
 
Note:
    Generalized Topp and Leone random numbers, probability plots,
    and goodness of fit tests can be generated with the commands:

       LET ALPHA = <value>
       LET BETA = <value>
       LET A = <value>
       LET B = <value>
       LET Y = GENERALIZED TOPP LEONE RANDOM NUMBERS FOR I = 1 1 N
       GENERALIZED TOPP LEONE PROBABILITY PLOT Y
       GENERALIZED TOPP LEONE PROBABILITY PLOT Y2 X2
       GENERALIZED TOPP LEONE PROBABILITY PLOT Y3 XLOW XHIGH
       GENERALIZED TOPP LEONE KOLMOGOROV SMIRNOV GOODNESS OF FIT Y
       GENERALIZED TOPP LEONE CHI-SQUARE GOODNESS OF FIT Y2 X2
       GENERALIZED TOPP LEONE CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    The following commands can be used to estimate the alpha
    and beta shape parameters for the generalized Topp and Leone
    distribution:

       LET ALPHA1 = <value>
       LET ALPHA2 = <value>
       LET BETA1 = <value>
       LET BETA2 = <value>
       GENERALIZED TOPP LEONE PPCC PLOT Y
       GENERALIZED TOPP LEONE PPCC PLOT Y2 X2
       GENERALIZED TOPP LEONE PPCC PLOT Y3 XLOW XHIGH
       GENERALIZED TOPP LEONE KS PLOT Y
       GENERALIZED TOPP LEONE KS PLOT Y2 X2
       GENERALIZED TOPP LEONE KS PLOT Y3 XLOW XHIGH

    The default values for ALPHA1 and ALPHA2 are 0.1 and 2.
    The default values for BETA1 and BETA2 are 0.5 and 10.

    The probability plot can then be used to estimate the
    lower and upper limits (lower limit = PPA0,
    upper limit = PPA0 + PPA1).

    The following options may be useful for these commands.

       1) Instead of generating the ppcc plot or ks plot on
          the original data, we can generate them on
          selected percentiles of the data.  For example,
          if we have 1,000 points, we can choose to generate
          the plots on 100 evenly spaced percentiles with
          the command

             SET PPCC PLOT DATA POINTS 100

          This can be used to speed up the generation of 
          the plot for larger data sets.

       2) For the ks plot, we can fix the location and scale.
          This is equivalent to assuming that the lower and
          upper limits are known (e.g., we could use the
          data minimum and maximum as the lower and upper
          limit values).  Given that the lower and upper
          limits are LOWLIM and UPPLIM, enter the commands

             LET KSLOC   = LOWLIM
             LET KSSCALE = UPPLIM

          The ppcc plot is invariant to location and scale,
          so we cannot fix the lower and upper limits.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GTLCDF = Compute the generalized Topp and Leone cumulative
             distribution function.
    GTLPPF = Compute the generalized Topp and Leone percent point
             function.
    RGTCDF = Compute the reflected generalized Topp and Leone
             probability density function.
    TOPPDF = Compute the Topp and Leone probability density
             function.
    TSPPDF = Compute the two-sided power probability density
             function.
    BETPDF = Compute the beta probability density function.
    TRIPDF = Compute the triangular probability density function.
    TRAPDF = Compute the trapezoid probability density function.
    UNIPDF = Compute the uniform probability density function.
    POWPDF = Compute the power probability density function.
    JSBPDF = Compute the Johnson SB probability density function.
 
Reference:
    Samuel Kotz and J. Rene Van Dorp 2004, "Beyond Beta:
    Other Continuous Families of Distributions with Bounded
    Support and Applications", World Scientific, chapter 7.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/2
 
Program 1:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 3
    .
    LET ALPHA = 2
    LET BETA  = 3
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT GTLPDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 1.5
    LET BETA  = 6
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT GTLPDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 1.5
    LET BETA  = 2
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT GTLPDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 1.5
    LET BETA  = 1
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT GTLPDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 0.5
    LET BETA  = 2
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT GTLPDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 0.5
    LET BETA  = 1
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT GTLPDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 0.5
    LET BETA  = 0.75
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT GTLPDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 0.5
    LET BETA  = 0.25
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT GTLPDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 1
    LET BETA  = 1
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT GTLPDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    END OF MULTIPLOT
 
Program 2:
    let alpha = 1.5
    let beta = 2
    .
    let y = generalized topp leone rand numb for i = 1 1 200
    .
    let alphsav = alpha
    let betasav = beta
    generalized topp leone ppcc plot y
    just center
    move 50 5
    let alpha = shape1
    let beta = shape2
    text maxppcc = ^maxppcc, Alpha = ^alpha, Beta = ^beta
    move 50 2
    text Alphasav = ^alphsav, Betasav = ^betasav
    .
    char x
    line blank
    generalized topp leone prob plot y
    move 50 5
    text PPA0 = ^ppa0, PPA1 = ^ppa1
    move 50 2
    let upplim = ppa0 + ppa1
    text Lower Limit = ^ppa0, Upper Limit = ^upplim
    char blank
    line solid
    .
    let ksloc = ppa0
    let ksscale = upplim
    generalized topp leone kolm smir goodness of fit y
    .
    bootstrap generalized topp leone plot y

-----GTLPPF (LET)--------------------------------
 
GTLPPF
 
Name:
    GTLPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized Topp and Leone percent point function
    with shape parameters alpha and beta.
 
Description:
    The standard generalized Topp and Leone distribution has the
    following percent point function:

        G(p;alpha,beta)
           = p**(1/beta)                        for alpha = 1
           = {-alpha + SQRT(alpha**2 - 4*(1-alpha)*(-p**(1/beta))}/
             {2*(1-alpha)} 
                         for 0 < alpha < 1 and 1 < alpha <= 2
           0 <= p <= 1, beta > 0
 
    with alpha and beta denoting the shape parameters.

    The standard distribution can be generalized with
    lower and upper bound parameters, a and b respectively,
    by utilizing the following relation:

        G(p;alpha,beta,a,b) = a + (b-a)*G(p;alpha,beta,0,1)

    The lower and upper limits are related to the location
    and scale parameters as follows:

        location = a
        scale    = b - a

Syntax:
    LET <y> = GTLPPF(<p>,<alpha>,<beta>,<a>,<b>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or variable containing
              values in the interval (0,1);
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed generalized Topp and Leone
              ppf value is stored;
          <alpha> is a number, parameter, or variable in the
              interval (0, 2) that specifies the first shape
              parameter;
          <beta> is a positive number, parameter, or variable that
              specifies the second shape parameter;
          <a> is a number, parameter, or variable that
              specifies the lower limit;
          <b> is a number, parameter, or variable that
              specifies the upper limit;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <a> and <b> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = GTLPPF(0.95,0.2,1.2)
    LET Y = GTLPPF(P,0.5,2)
    PLOT GTLPPF(P,2,3) FOR P = 0  0.01  1
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GTLCDF = Compute the generalized Topp and Leone cumulative
             distribution function.
    GTLPDF = Compute the generalized Topp and Leone probability
             density function.
    RGTPDF = Compute the reflected generalized Topp and Leone
             probability density function.
    TOPPDF = Compute the Topp and Leone probability density
             function.
    TSPPDF = Compute the two-sided power probability density
             function.
    BETPDF = Compute the beta probability density function.
    TRIPDF = Compute the triangular probability density function.
    TRAPDF = Compute the trapezoid probability density function.
    UNIPDF = Compute the uniform probability density function.
    POWPDF = Compute the power probability density function.
    JSBPDF = Compute the Johnson SB probability density function.
 
Reference:
    Samuel Kotz and J. Rene Van Dorp 2004, "Beyond Beta:
    Other Continuous Families of Distributions with Bounded
    Support and Applications", World Scientific, chapter 7.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/2
    2007/9: Replaced bisection computation with explicit formula
 
Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 3
    .
    LET ALPHA = 2
    LET BETA  = 3
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT GTLPPF(P,ALPHA,BETA) FOR P = 0  0.01  1
    .
    LET ALPHA = 1.5
    LET BETA  = 6
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT GTLPPF(P,ALPHA,BETA) FOR P = 0  0.01  1
    .
    LET ALPHA = 1.5
    LET BETA  = 2
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT GTLPPF(P,ALPHA,BETA) FOR P = 0  0.01  1
    .
    LET ALPHA = 1.5
    LET BETA  = 1
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT GTLPPF(P,ALPHA,BETA) FOR P = 0  0.01  1
    .
    LET ALPHA = 0.5
    LET BETA  = 2
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT GTLPPF(P,ALPHA,BETA) FOR P = 0  0.01  1
    .
    LET ALPHA = 0.5
    LET BETA  = 1
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT GTLPPF(P,ALPHA,BETA) FOR P = 0  0.01  1
    .
    LET ALPHA = 0.5
    LET BETA  = 0.75
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT GTLPPF(P,ALPHA,BETA) FOR P = 0  0.01  1
    .
    LET ALPHA = 0.5
    LET BETA  = 0.25
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT GTLPPF(P,ALPHA,BETA) FOR P = 0  0.01  1
    .
    LET ALPHA = 1
    LET BETA  = 1
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT GTLPPF(P,ALPHA,BETA) FOR P = 0  0.01  1
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Generalized Topp and Leone PPF Functions
 
-----GTRCDF (LET)--------------------------------
 
GTRCDF
 
Name:
    GTRCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized trapezoidal cumulative distribution
    function.
 
Description:
    The generalized trapezoidal distribution has the following
    cumulative distribution function:

      Ff(x|a,b,c,d,nu1,nu3,alpha) =
           0                                x < a
           2*alpha*(b-a)*nu3*((x-a)/(b-a))**nu1/
           [2*alpha*(b-a)*nu3+(alpha+1)*(c-b)*nu1*nu3+2*(d-c)*nu1]
                                            a <= x < b
           2*alpha*(b-a)*nu3+2*(x-b)*nu1*nu3*
           [1 + ((alpha-1)/2)*((2*c-b-x)/(c-b))]/
           [2*alpha*(b-a)*nu3+(alpha+1)*(c-b)*nu1*nu3+2*(d-c)*nu1]
           
                                            b <= x < c
           1 - {2*(d-c)*nu1*((d-x)/(d-c))**nu3/
           [2*alpha*(b-a)*nu3+(alpha+1)*(c-b)*nu1*nu3+2*(d-c)*nu1]}
                                            c <= x < d
           1                                x >= d

 
Syntax:
    LET <y> = GTRCDF(<x>,<a>,<b>,<c><d>,<nu1>,<nu3>,<alpha>)
                             <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter containing values in
              the interval (a,d);
          <a> is a number, parameter, or variable that specifies the
              first shape parameter;
          <b> is a number, parameter, or variable that specifies the
              second shape parameter;
          <c> is a number, parameter, or variable that specifies the
              third shape parameter;
          <d> is a number, parameter, or variable that specifies the
              fourth shape parameter;
          <nu1> is a number, parameter, or variable that specifies the
              fifth shape parameter;
          <nu3> is a number, parameter, or variable that specifies the
              sixth shape parameter;
          <alpha> is a number, parameter, or variable that specifies
              the seventh shape parameter;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GTRCDF(0.65,0,0.2,0.8,1,2,2,0.5)
    LET Y = GTRCDF(X,0,0.2,0.8,1,2,2,0.5)
    LET Y = GTRCDF(X,A,B,C,D,NU1,NU3,ALPHA)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GTRPDF = Compute the generalized trapezoidal probability
             density function.
    GTRPPF = Compute the generalized trapezoidal percent point
             function.
    TRAPDF = Compute the trapezoidal probability density function.
    TRIPDF = Compute the triangular probability density function.
    UNIPDF = Compute the uniform probability density function.
    SEMPDF = Compute the semi-circular probability density function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "Generalized Trapezoidal Distributions", van Dorp and Kotz,
    Metrika, Vol. 58, Issue 1, July, 2003.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2004/1
 
Program:
    TITLE GENERALIZED TRAPEZOIDAL DISTRIBUTION
    LET A = 0
    LET B = 0.2
    LET C = 0.8
    LET D = 1
    LET NU1 = 1.5
    LET NU3 = 2.2
    LET ALPHA = 0.5
    PLOT GTRCDF(X,A,B,C,D,NU1,NU3,ALPHA) FOR X = A 0.01 D

-----GTRPDF (LET)--------------------------------
 
GTRPDF
 
Name:
    GTRPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized trapezoidal probability density
    function.
 
Description:
    The regular trapezoidal distribution has the following
    probability density function:

       f(x|a,b,c,d) = u*((x-a)/(b-a))       a <= x < b
                    = u                     b <= x < c
                    = u*((d-x)/(d-c))       c <= x < d
                    = 0                     elsewhere

    where

       u = 2/(d + c - b - a)
       a <= b <= c <= d

    Trapezoidal distributions may be appropriate for modeling
    processes that can be represented by the following three stages:

      1) a growth stage
      2) a period of relative stability stage
      3) a decay stage

    The trapezoidal model is probably the simplest model of this
    type (i.e., the growth and decline stages are linear and the
    stability stage is constant).

    The generalized trapezoidal distribution allows more
    flexibility in modeling these stages.  Specifically, the
    growth and decay stages may exhibit nonlinear convex or
    concave behavioir.  In addition, the stability stage may
    be linearly increasing or decreasing.

    The generalized trapezoid distribution has the following
    probability density function:

       f(x|a,b,c,d,nu1,nu3,alpha) =
           2*alpha*nu1*nu3*((x-a)/(b-a)**(nu1-1)/
           [2*alpha*(b-a)*nu3+(alpha+1)*(c-b)*nu1*nu3+2*(d-c)*nu1]
                                            a <= x < b
           2*nu1*nu3*[(alpha-1)*((c-a)/(b-a))+1]
           [2*alpha*(b-a)*nu3+(alpha+1)*(c-b)*nu1*nu3+2*(d-c)*nu1]
           
                                            b <= x < c
           2*nu1*nu3*((x-a)/(b-a)**(nu1-1)/
           [2*alpha*(b-a)*nu3+(alpha+1)*(c-b)*nu1*nu3+2*(d-c)*nu1]
                    = u*((d-x)/(d-c))       c <= x < d
                    = 0                     elsewhere

    Dorp and Kotz (see Reference below) show that the generalized
    trapezoid can be defined as a mixture

       fx(x) = SUM[i=1 to 3][pi(i)*f(xi)(x)]    a <= x <= d
               0                                elsewhere

    where

       f(x1)(x|a,b,nu1) = (nu1/(b-a))*((x-a)/(b-a))**(nu1-1)
                                                a <= x < b, nu1 > 0
       f(x2)(x|b,c,alpha) = 2*[(1-alpha)*x + alpha*c-b]/
                            [(alpha+1)*(c-b)**2]
                                                b <= x <= c, alpha > 0
       f(x3)(x|c,d,nu3) = (nu3/(d-c))*((d-x)/(d-c))**(nu3-1)
                                                c <= x < d, nu3 > 0

    and

       pi(1) = 2*alpha*(b-a)*nu3/
               [2*alpha*(b-a)*nu3+(alpha+1)*(c-b)*nu1*nu3+2*(d-c)*nu1]
       pi(2) = (alpha+1)*(c-b)*nu1*nu3
               [2*alpha*(b-a)*nu3+(alpha+1)*(c-b)*nu1*nu3+2*(d-c)*nu1]
       pi(3) = 2*(d-c)*nu1/
               [2*alpha*(b-a)*nu3+(alpha+1)*(c-b)*nu1*nu3+2*(d-c)*nu1]

    This form may be more useful for modeling and fitting.

 
Syntax:
    LET <y> = GTRPDF(<x>,<a>,<b>,<c><d>,<nu1>,<nu3>,<alpha>)
                             <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter containing values in
              the interval (a,d);
          <a> is a number, parameter, or variable that specifies the
              first shape parameter;
          <b> is a number, parameter, or variable that specifies the
              second shape parameter;
          <c> is a number, parameter, or variable that specifies the
              third shape parameter;
          <d> is a number, parameter, or variable that specifies the
              fourth shape parameter;
          <nu1> is a number, parameter, or variable that specifies the
              fifth shape parameter;
          <nu3> is a number, parameter, or variable that specifies the
              sixth shape parameter;
          <alpha> is a number, parameter, or variable that specifies
              the seventh shape parameter;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GTRPDF(0.65,0,0.2,0.8,1,2,2,0.5)
    LET Y = GTRPDF(X,0,0.2,0.8,1,2,2,0.5)
    LET Y = GTRPDF(X,A,B,C,D,NU1,NU3,ALPHA)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GTRPDF = Compute the generalized trapezoidal cumulative
             distribution function.
    GTRPPF = Compute the generalized trapezoidal percent point
             function.
    TRAPDF = Compute the trapezoidal probability density function.
    TRIPDF = Compute the triangular probability density function.
    UNIPDF = Compute the uniform probability density function.
    SEMPDF = Compute the semi-circular probability density function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "Generalized Trapezoidal Distributions", van Dorp and Kotz,
    Metrika, Vol. 58, Issue 1, July, 2003.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2004/1
 
Program:
    TITLE GENERALIZED TRAPEZOIDAL DISTRIBUTION
    LET A = 0
    LET B = 0.2
    LET C = 0.8
    LET D = 1
    LET NU1 = 1.5
    LET NU3 = 2.2
    LET ALPHA = 0.5
    PLOT GTRPDF(X,A,B,C,D,NU1,NU3,ALPHA) FOR X = A 0.01 D

-----GTRPPF (LET)--------------------------------
 
GTRPPF
 
Name:
    GTRPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the generalized trapezoidal percent point function.
 
Description:
    The generalized trapezoidal distribution has the following
    cumulative distribution function:

      Ff(x|a,b,c,d,nu1,nu3,alpha) =
           0                                x < a
           2*alpha*(b-a)*nu3*((x-a)/(b-a))**nu1/
           [2*alpha*(b-a)*nu3+(alpha+1)*(c-b)*nu1*nu3+2*(d-c)*nu1]
                                            a <= x < b
           2*alpha*(b-a)*nu3+2*(x-b)*nu1*nu3*
           [1 + ((alpha-1)/2)*((2*c-b-x)/(c-b))]/
           [2*alpha*(b-a)*nu3+(alpha+1)*(c-b)*nu1*nu3+2*(d-c)*nu1]
           
                                            b <= x < c
           1 - {2*(d-c)*nu1*((d-x)/(d-c))**nu3/
           [2*alpha*(b-a)*nu3+(alpha+1)*(c-b)*nu1*nu3+2*(d-c)*nu1]}
                                            c <= x < d
           1                                x >= d

    The algorithm for the generalized trapezoid percent point
    function is to compute the cumulative distribution function
    at the points a, b, c, and d to determine an appropriate
    bracketing interval.  Then the appropriate equation above is
    inverted to find the value of the percent point function.
    For the interval b <= x < c, a bisection method is used.
 
Syntax:
    LET <y> = GTRPPF(<p>,<a>,<b>,<c><d>,<nu1>,<nu3>,<alpha>)
                             <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter containing values in
              the interval (a,d);
          <a> is a number, parameter, or variable that specifies the
              first shape parameter;
          <b> is a number, parameter, or variable that specifies the
              second shape parameter;
          <c> is a number, parameter, or variable that specifies the
              third shape parameter;
          <d> is a number, parameter, or variable that specifies the
              fourth shape parameter;
          <nu1> is a number, parameter, or variable that specifies the
              fifth shape parameter;
          <nu3> is a number, parameter, or variable that specifies the
              sixth shape parameter;
          <alpha> is a number, parameter, or variable that specifies
              the seventh shape parameter;
          <y> is a variable or a parameter (depending on what <p> is)
              where the computed ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = GTRPPF(0.95,0,0.2,0.8,1,2,2,0.5)
    LET Y = GTRPPF(P,0,0.2,0.8,1,2,2,0.5)
    LET Y = GTRPPF(P,A,B,C,D,NU1,NU3,ALPHA)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GTRCDF = Compute the generalized trapezoidal cumulativ
             distribution function.
    GTRPDF = Compute the generalized trapezoidal probability
             density function.
    TRAPDF = Compute the trapezoidal probability density function.
    TRIPDF = Compute the triangular probability density function.
    UNIPDF = Compute the uniform probability density function.
    SEMPDF = Compute the semi-circular probability density function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "Generalized Trapezoidal Distributions", van Dorp and Kotz,
    Metrika, Vol. 58, Issue 1, July, 2003.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2004/1
 
Program:
    TITLE GENERALIZED TRAPEZOIDAL DISTRIBUTION
    LET A = 0
    LET B = 0.2
    LET C = 0.8
    LET D = 1
    LET NU1 = 1.5
    LET NU3 = 2.2
    LET ALPHA = 0.5
    PLOT GTRPPF(P,A,B,C,D,NU1,NU3,ALPHA) FOR P = 0  0.01  1

-----SET GUI (SET)--------------------------------------------
 
GUI
 
Name:
    SET GUI (SET)
 
Type:
    Set Subcommand
 
Purpose:
    Notify Dataplot that the GUI is running.
 
Description:
    If Dataplot is running in the Graphical User Interface (GUI) mode, a
    few operations are not allowed.  The most important of these is
    that reading from the terminal is not allowed (READ with no file
    name, PAUSE command).  This command is issued by the Tcl/Tk scripts
    (the GUI is currently implemented using the Tcl/TK scripting
    language) and is not typically entered directly by the Dataplot
    user.

    If you set this switch to ON while running the command line
    version, Dataplot will continue to run.  However, a few specific
    commands will not work as expected.  If you set this switch to
    OFF while the GUI is running, the GUI will hang if a READ
    (with no file name) or PAUSE command is entered.

Syntax:
    SET GUI <ON/OFF>
    where ON specifies the GUI is running and OFF specifies the GUI
             is not running.
 
Examples:
    SET GUI ON
    SET GUI OFF

Default:
    OFF, will automatically be set to ON if the GUI is running.
 
Synonyms:
    None
 
Related Commands:
    GUI STATUS VARIABLES    = Status command for the GUI.
    GUI WRITE ALL VARIABLES = Write variables for the GUI.
    GUI SAVE PLOT CONTROL   = Save plot control values for the GUI.
 
Applications:
    Running Dataplot GUI
 
Implementation Date:
    2004/12
 
Program:
    XX
 
-------------------------------------------------------------
 
 
 
 
 
 












































































-------------------------  *H*  ZZZZZ--------------------
 
-----H15 (LET)-----------------------------------------
 
H15
 
Name:
    H15 (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the H15 robust location or scale estimate of a variable.
 
Description:
    The H15 location and scale estimates are computed as follows.

    Let X = x1, x2, ..., xp denote the response values and x* and s*
    denote the robust estimates of location and scale, respectively.
    The initial estimate for x* is the median.  The initial estimate
    for s* is

        s* = MAD(X)/0.6745

    where MAD is the median absolute deviation.

    To update the values for x* and s*, calculate

        delta = c s*

        x(i)* = x* - delta    if x(i) < x* - delta
              = x* + delta    if x(i) > x* + delta
              = x(i)          otherwise

    The updated values of x* and s* are

        x* = SUM[i=1 to p][x(i)*]/p
        s* = (1/beta**2)*SQRT{SUM[i=1 to p][(x(i)* - x*)**2]/(p - 1)}

    This process is iterated until the values of x* and s* converge.

    For H15, c = 1.5 and beta = 0.778.  There are several alternative
    estimates that use different values for c and beta.  Specifically,

	H10: c = 1.0 and beta = 0.516
        H12: c = 1.1 and beta = 0.578
        H12: c = 1.2 and beta = 0.635
        H13: c = 1.3 and beta = 0.688
        H14: c = 1.4 and beta = 0.736
        H16: c = 1.6 and beta = 0.816
        H17: c = 1.7 and beta = 0.849
        H18: c = 1.8 and beta = 0.877
        H19: c = 1.9 and beta = 0.900
        H20: c = 2.0 and beta = 0.921

    Dataplot currently supports the H10, H12, H15, H17, H20 variations of
    this command.  The H15 variant is the most commonly used.

    In the ISO 5725-5 and ISO 13528 standards, H15 is referred to as
    "Algorithm A".

Syntax 1:
    LET <par> = <stat> LOCATION  <y>
                <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <stat> is one of H10, H12, H15, H17, H20;
          <par> is a parameter where the computed h15 location
              value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    LET <par> = <stat> SCALE  <y>
                <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <stat> is one of H10, H12, H15, H17, H20;
          <par> is a parameter where the computed h15 scale
              value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET ALOC = H15 LOCATION Y
    LET ASCALE = H15 SCALE Y
    LET ALOC = H15 LOCATION Y  SUBSET Y > 0
    LET ALOC = H20 LOCATION Y
 
Note:
    Dataplot uses the Ripley algorithm to compute these statistics.

Note:
    This method is referred to as Algorithm A in the ISO 13528 standard.
    The description of the algorithm is taken from that standard.

Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    MEAN                   = Compute the mean of a variable.
    MEDIAN                 = Compute the median of a variable.
    RANGE                  = Compute the range of a variable.
    VARIANCE               = Compute the variance of a variable.
    STANDARD DEVIATION     = Compute the standard deviation of a variable.
    MAD                    = Compute the median absolute deviation of a variable.
    HOMOSCEDASTICITY PLOT  = Compute the standard deviation of a variable.
 
Applications:
    Data Analysis, Proficiency Analysis
 
Reference:
    Analytical Methods Committee, "Robust Statistics--How Not to Reject
    Outliers: Part 1. Basic Concepts", Analyst, December 1989, Vol. 1.

    ISO 13528 (2005), "Statistical Methods for use in proficiency
    testing by interlaboratory comparisons," Section C.2 Algorithm S.

Implementation Date:
    2010/12
 
Program:
    SKIP 25
    READ GEAR.DAT Y X
    LET A = H15 LOCATION Y
    .
    LABEL CASE ASIS
    Y1LABEL H15 Location
    X1LABEL Batch
    H15 LOCATION PLOT Y X
    .
    LET A = H15 LOCATION Y
    SET WRITE DECIMALS 4
    SET LET CROSS TABULATE COLLAPSE
    LET XGROUP = CROSS TABULATE GROUP ONE X
    LET YMEAN = CROSS TABULATE H15 LOCATION Y X
    LET YSD   = CROSS TABULATE H15 SCALE    Y X
    PRINT XGROUP YMEAN YSD
 
-----HALT-----------------------------------------------------
 
HALT
 
Name:
    HALT
 
Type:
    Support Command
 
Purpose:
    Exit from DATAPLOT.
 
Syntax:
    HALT
 
Examples:
    HALT
 
Default:
    None
 
Synonyms:
    EXIT
    STOP
    QUIT
    BYE
    END
 
Applications:
    XX
 
Implementation Date:
    Pre-1987
 
Program:
    XX
 
-----HAMMING DISTANCE (LET)-------------------------------------
 
HAMMING DISTANCE
 
Name:
    HAMMING DISTANCE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the Hamming distance between two variables.
 
Description:
    The Hamming distance is typically computed between two strings of
    equal length.  In this case, the Hamming distance of the two strings
    is the count of the number of positions in the two strings that are
    different.

    This command takes two numeric variables of equal length.  It returns
    the number of elements in the two variables that are different (i.e.,
    X(1) is compared to Y(1), X(2) is compared to Y(2), and so on).  Often
    these two variables will consist of a sequence of 1's and 0's, but
    this command is not restricted to that case.
 
    The STRING HAMMING DISTANCE can be used to compute the Hamming distance
    of two strings.

Syntax:
    LET <par> = HAMMING DISTANCE <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Hamming distance
              is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Examples:
    LET A = HAMMING DISTANCE Y1 Y2
    LET A = HAMMING DISTANCE Y1 Y2  SUBSET Y1 > 0 SUBSET Y2 > 0

Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    MANHATTAN DISTANCE      = Compute the Manhattan distance.
    COSINE DISTANCE         = Compute the cosine distance.
    EUCLIDEAN DISTANCE      = Compute the Euclidean distance.
    MATRIX DISTANCE         = Compute various distance metrics for
                              a matrix.

Applications:
    Mathematics
 
Implementation Date:
    2018/10
 
Program:
    LET Y1 = DATA 1 1 0 0
    LET Y2 = DATA 1 0 1 0
    LET DIST  = HAMMING DISTANCE Y1 Y2
    SET WRITE DECIMALS 0
    PRINT DIST

-----HARDCOPY-------------------------------------------------------
 
HARDCOPY
 
Name:
    HARDCOPY
 
Type:
    Output Device Command
 
Purpose:
    Specifies that all subsequent plots should be automatically copied
    onto the local hardcopy unit.
 
Description:
    This command only applies to the Tektronix 4014 type terminals with
    a Tektronix 4631 hard copy unit.  This hard copy device is now
    fairly obsolete, so this command is rarely used.  The PP command
    can be used to send the most recent plot to a printer on some
    installations.  Enter HELP PP for details.
 
Syntax:
    HARDCOPY   <ON or OFF>  <number of copies>
    where ON specifies that subsequent plots should be copied while OFF
             specifies they should not be copied;
    and   <copies> is an optional integer number or parameter that
             specifies the number of copies to make (1 copy is made if
             this argument is omitted).
 
Examples:
    HARDCOPY ON
    HARDCOPY
    HARDCOPY OFF
    HARDCOPY ON 3
 
Note:
    HARDCOPY with no arguments is equivalent to HARDCOPY ON 1 .
 
Default:
    The default is no copying of plots.
 
Synonyms:
    None
 
Related Commands:
    PLOT       = Generates a data or function plot.
    COPY DELAY = Sets the delay after screen hardcopying.
    BELL       = Sets the automatic bell switch for plots.
    PRE-ERASE  = Sets the automatic pre-erase switch for plots.
    SEQUENCE   = Sets the automatic sequence switch for plots.
    RING       = Rings the bell (immediately).
    ERASE      = Erases the screen (immediately).
    COPY       = Copies the screen (immediately).
 
Applications:
    XX
 
Implementation Date:
    Pre-1987
 
Program:
    XX
 
-----HARMONIC MEAN (LET)-----------------------------------------
 
HARMONIC MEAN
 
Name:
    HARMONIC MEAN (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the harmonic mean for a variable.
 
Description:
    The harmonic mean is defined as:
 
         XHM = N/SUM(1/Xi)

Syntax:
    LET <par> = HARMONIC MEAN <y1> <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the response variable;
          <par> is a parameter where the computed harmonic mean
              is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = HARMONIC MEAN Y1
    LET A = HARMONIC MEAN Y1 SUBSET TAG > 2
 
Note:
    Support for the harmonic mean has been added to the 
    following plots:

       HARMONIC MEAN PLOT
       BOOTSTRAP HARMONIC MEAN PLOT
       JACKNIFE HARMONIC MEAN PLOT
       CROSS TABULATE HARMONIC MEAN PLOT
       INTERACTION  HARMONIC MEAN PLOT

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    MEAN                 = Compute the mean.
    MEDIAN               = Compute the median.
    GEOMETRIC MEAN       = Compute the harmonic mean.
    STATISTIC  PLOT      = Generate a statistic vs. subset plot.
    BOOTSTRAP PLOT       = Generate a bootstrap plot.
    JACKNIFE PLOT        = Generate a jacknife plot.
    CROSS TABULATE PLOT  = Generate a cross tabulate plot.
    INTERACTION PLOT     = Generate an interaction plot.

 
Applications:
    Data Analysis
 
Implementation Date:
    2000/1
 
Program:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET A1 = HARMONIC MEAN Y1
 
-----HARMNUMB (LET)--------------------------------
 
HARMNUMB
 
Name:
    HARMNUMB (LET)
 
Type:
    Library Function
 
Purpose:
    Compute harmonic numbers or generalized harmonic numbers.
 
Description:
    The generalized harmonic number is

        H(n,m) = SUM[k = 1 to n][1/k**m]

    The case where m = 1 is referred to as the harmonic
    number and has the formula

        H(n) = SUM[k = 1 to n][1/k]

    The m parameter is restricted to values greater than 1.

Syntax 1:
    LET <y> = HARMNUMB(<n>)    <SUBSET/EXCEPT/FOR qualification>
    where <n> is a number, variable, or parameter (> 1);
          <y> is a variable or a parameter (depending on what <x> 
               is) where the computed harmonic number is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax computes the harmonic number.
 
Syntax 2:
    LET <y> = HARMNUMB(<n>,<m>)   <SUBSET/EXCEPT/FOR qualification>
    where <n> is a positive integer number, parameter or variable;
          <m> is a number, parmeter, or variable (> 1);
          <y> is a variable or a parameter (depending on what <x> 
               is) where the computed harmonic number is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax computes the generalized harmonic number.
 
Examples:
    LET A = HARMNUMB(200)
    LET A = HARMNUMB(200,1.5)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Note:
    The zeta function is the limiting case of the generalized
    harmonic number as n goes to infinity.

Note:
    The Zipf probability mass and cunulative distribution
    functions can be defined in terms of generalized harmonic
    numbers.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ZETA       = Compute the Riemann zeta function.
    ZIPPDF     = Compute the Zipf probability mass function.
    ETA        = Compute the eta function.
    CATLAN     = Compute the Catlan Beta function.
    LAMBDA     = Compute the lambda function.
 
Reference:
    "Atlas For Computing Mathematical Functions",
    William J. Thompson, John wiley & Sons, 1997.
 
    "AMS 55: Handbook of Mathematical Functions", Abramowitz and
    Stegun, Eds., Washington, DC, National Bureau of Standards,
    1964.

Applications:
    Special Functions
 
Implementation Date:
    2006/5
 
Program:
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    case asis
    label case asis
    title case asis
    tic offset units screen
    tic offset 3 3
    title displacement 2
    y1label displacement 17
    x1label displacement 12
    x1label N
    y1label Harmonic Number
    .
    multiplot 2 2
    .
    let m = 1.5
    title M = ^m
    plot harmnumb(n,m) for n = 1 1 100
    .
    let m = 2.0
    title M = ^m
    plot harmnumb(n,m) for n = 1 1 100
    .
    let m = 2.5
    title M = ^m
    plot harmnumb(n,m) for n = 1 1 100
    .
    let m = 3.0
    title M = ^m
    plot harmnumb(n,m) for n = 1 1 100
    .
    end of multiplot
    .
    justification center
    move 50 97
    text Generalized Harmonic Numbers (N = 1 to 100)
 
-----HAZARD (LET)-------------------------------------
 
HAZARD
 
Name:
    HAZARD (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the hazard for a set of failure times.
 
Description:
    The hazard is constructed as follows:

       1) Sort and rank the N failure times from shortest to longest
          failure time.  Note that the hazard can accomodate
          data where the time may be a censoring time rather
          than a failure time (i.e., the unit was taken out of
          service before it failed).

       2) Calculate a hazard value at each of the failure times.
          Note that the hazard is only caclulated at failure
          times, not censoring times.  The hazard is:

             100.0*(1/(N-K+1)

          where K is the rank of the failure time.  This expresses
          the hazard as a percentage.  You can express the hazard
          as a proportion by omitting the multiplication by 100.

Syntax:
    LET <y> = HAZARD <x>  <tag>
                              <SUBSET/EXCEPT/FOR qualification>
    where <x> is the variable containing the failure times;
          <tag> is a variable that indicates whether the corresponding
              element of <x> is a failure time or a censoring
              time;
          <y> is a variable (of length 1 less than <x1>) where the
               hazards are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    A value of 0 for <tag> is used to signify a censoring time and
    a value of 1 for <tag> is used to signify a failure time.
    Dataplot uses 0.5 as the cutoff.  That is, any value greater
    than or equal to 0.5 is interpreted as a failure time.

Examples:
    LET Y = HAZARD X CENSOR
    LET Y = HAZARD X CENSOR SUBSET CENSOR = 1
 
Note:
    Hazards are only computed for failure times (i.e., where
    <tag> = 1), not censoring times.  The saved hazards (<y>)
    are set to 0 for censoring times.  If you just want to keep
    the hazards at failure times, do something like:

        LET Y = HAZARD X CENSOR
        RETAIN Y SUBSET CENSOR = 1

    The censoring times do affect the value of the hazard since
    they are used in determining the rank.  If you only want the
    failure times to be used in the calculation of the hazard, do
    something like the following:

        LET Y = HAZARD X CENSOR SUBSET CENSOR = 1
        RETAIN Y SUBSET CENSOR = 1

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CUMULATIVE HAZARD  = Compute the cumulative hazard for a
                         variable.
    HAZARD PLOT        = Generate a hazard plot.
    PROBABILITY PLOT   = Generate a probability plot.
    WEIBULL PLOT       = Generate a Weibull plot.
    INTERARRIVAL TIME  = Compute the interarrival times of a
                         variable.
 
Applications:
    Reliability
 
Implementation Date:
    1998/5
 
Program:
    SKIP 25
    READ HAHN.DAT Y TAG
    LET TAG = 0 SUBSET TAG = 2
    LET Z = HAZARD Y TAG
 
-----H CONSISTENCY PLOT--------------------------------------
 
H CONSISTENCY PLOT
K CONSISTENCY PLOT
COCHRAN VARIANCE PLOT
 
Name:
    H CONSISTENCY PLOT
    K CONSISTENCY PLOT
    COCHRAN VARIANCE PLOT
 
Type:
    Graphics Command
 
Purpose:
    Given a response variable and associated variables containing
    laboratory id's and material id's, generate a plot of one
    of the following versus material/laboratory:

       1. h-consistency statistic
       2. k-consistency statistic
       3. Cochran variance outlier statistic
 
Description:
    The h-consistency and k-consistency statistics are discussed in the
    ASTM E691 standard for interlaboratory analysis

       "Standard Practice for Conducting an Interlaboratory Study
       to Determine the Precision of a Test Method", ASTM
       International, 100 Barr Harbor Drive, PO BOX C700,
       West Conshohoceken, PA 19428-2959, USA.

    This standard addresses the situation where there are two factors
    (material and laboratory) and there is a full factorial balanced
    design (i.e., each combination of material and laboratory is run
    with an equal number of replications).

    John Mandel has also discussed the h- and k-statistics in
    various publications (see the References section below).

    The h-consistency statistic is a measure of the between laboratory
    consistency and is defined in the ASTM E691 standard as

       h    = d/s(xtilde)
 
    with

       d          = cell deviation (cell average - average of cell
                    averages)
       s(xtilde)  = standard deviations of cell averages

    Essentially, h is standardized deviation from the grand averages.
    The critical value is computed as

       hcv = +/- (p-1)*t/SQRT(p*(t**2+p-2))

    where p denotes the number of laboratories and t denotes the
    percent point function of the t distribution with p - 2 degrees
    of freedom.  The h consistency plot draws lines at the critical values
    corresponding to alpha = 0.5% (i.e., the 0.9975 and 0.0025 percent
    points of the t distribution).  These are the values recommended in
    the E691 standard.

    The k-consistency statistic is a measure of the within laboratory
    consistency and is defined in the ASTM E691 standard as

       k    = s/s(r)
 
    with

       s      = cell standard deviation
       s(r)   = repeatability standard deviation

    Essentially, k is the ratio of the cell standard devition to the
    pooled value.  The critical value is computed as

        kcv = SQRT(p/(1 + (p-1)/F))

    where p denotes the number of laboratories and F denotes the
    percent point function of the F distribution with (n-1) and
    (p-1)*(n-1) degrees of freedom.  The k consistency plot draws
    a line at the critical value corresponding to alpha = 0.5%
    (i.e., the 0.995 percent point of the F distribution).  This is
    the value recommended in the E691 standard.

    The Cochran variance outlier test is a test for assessing the
    homogeneity of variances.  It is essentially an outlier test for
    largest (or smallest) variance.  Given k groups of data, some
    analyses assume the standard deviations (or equivalently, variances)
    are equal for the k groups.  For example, the F test used in the
    one-factor analysis of variance problem can be sensitive to unequal
    standard deviations in the k levels of the factor.

    The Levene and Bartlett tests are alternative tests widely used for
    assessing the homogeneity of variances in the one-factor (with k
    levels)  case.  Although the Cochran test has a similar purpose to
    the Levene and Bartlett tests, it tends to be used in a somewhat
    different context.  The Levene and Bartlett test are used to assess
    overall homogeneity and are typically used in the context of deciding
    whether a specific test (e.g., an F test) is appropriate for a given
    set of data.  These tests do not identify which variances are
    different.  On the other hand, the Cochran variance outlier test tends
    to be used in the context of interlaboratory analysis.  In this case,
    we are primarily interested in identifying laboratories that are
    "different".  For example, a laboratory with an unusually large
    variance may indicate the need for close examination of that
    laboratory's practices.

    Cochran's test is essentially an outlier test.  Cochran's original
    test statistic is defined as

         C = largest s(i)**2/SUM[i=1 to k][s(i)**2]

    That is, it is the ratio of the largest variance to the sum of the
    variances.  This is an upper-tailed test for the maximum variance.
    The critical values can be computed from

         Cul(alpha,n,k) = 1/[1 + (k-1)/FPPF(alpha/k,(n-1),(k-1)*(n-1))]

    where

         Cul   = the upper critical value (i.e., variance is an outlier
                 if the test statistic is greater than Cul)
         alpha = the significance level
         n     = the number of observations in each group
         k     = the number of groups
         FPPF  = the percent point function of the F distribution

    Some comments on this test.

        1. It assumes that the data in each group are normally
           distributed.

        2. It assumes the sample sizes in each group are equal.

        3. It tests for the maximum variance only (i.e., no test for
           the minimum variance).

    't Lam (2009) has extended the Cochran test to support unequal sample
    sizes and to also test for the minimum variance.  He refers to this
    as the G statistic.  Dataplot generates the G statistic rather than
    the C statistic for this test.  When the sample sizes are in fact
    equal, the G statistic for the maximum variance is equivalent to the
    Cochran C statistic.

    The G statistic for the j-th group is

        G(j) = nu(j)*s(j)**2/SUM[i=1 to k][nu(i)*s(i)**2]

    where nu(i) = n(i) - 1 with n(i) denoting the sample size of the i-th
    group.

    The critical value for testing the maximum variance is

         Gul(alpha,nu(j),nupool,k) = 1/[1 + (nupool/nu(j) - 1)/
                                     FPPF(alpha/k,nu(j),nupool-nu(j))]

    where

        nupool   = pooled degrees of freedom
                 = SUM[i=1 to k][nu(i)]
        nu(j)    = the degrees of freedom corresponding to the maximum
                   variance

    Reject the null hypothesis that the maximum variance is an outlier if
    the test statistic is greater than the critical value.

    The critical value for testing the minimum variance is

        Gll(alpha,nu(j),nupool,k) = 1/[1 + (nupool/nu(j) - 1)/
                                    FPPF(1 - (alpha/k),nu(j),nupool-nu(j))]

    In this case, nu(j) corresponds to the minimum variance.  Reject the
    null hypothesis that the minimum variance is an outlier if the test
    statistic is less than the critical value.

    A two-sided test can also be performed.  Just use alpha/2 in place of
    alpha in the above formulas.  Although the 't Lam article provides a
    method for determining whether the maximum or minimum variance is more
    extreme, Dataplot will simply return the test statistic and critical
    values for both the maximum and the minimum cases.

    Note that with the G statistic, we are actually testing for the
    maximum (or minimum) value of the G statistic rather than the maximum
    (or minimum) variance.  If the sample sizes are equal (or at least
    approximately equal), this should be equivalent.  However, if there is
    a large difference in sample sizes, this may not be the case.  That
    is, we are testing the maximum nu(j)*s(j)**2 rather than the
    maximum s(j)**2.

Syntax 1:
    H CONSISTENCY PLOT <y>  <labid>  <matid>
                       <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <labid> is a variable that specifies the lab-id;
          <matid> is a variable that specifies the material-id;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax plots the h-consistency statistic.  The variables
    must all be of equal length.

Syntax 2:
    K CONSISTENCY PLOT <y>  <labid>  <matid>
                       <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <labid> is a variable that specifies the lab-id;
          <matid> is a variable that specifies the material-id;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax plots the k-consistency statistic.  The variables
    must all be of equal length.

Syntax 3:
    COCHRAN VARIANCE PLOT <y>  <labid>  <matid>
                       <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <labid> is a variable that specifies the lab-id;
          <matid> is a variable that specifies the material-id;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax plots the Cochran variance statistic.  The variables
    must all be of equal length.

Examples:
    H CONSISTENCY PLOT Y LABID MATID
    K CONSISTENCY PLOT Y LABID MATID
    COCHRAN VARIANCE PLOT Y LABID MATID
    H CONSISTENCY PLOT Y LABID MATID  SUBSET MATID > 2

Note:
    There are two formats for the plots.  By default, the values are
    plotted linearly.  That is, given three laboratories and three
    materials, the x-axis is laid out as

       LAB:  1  2  3  1  2  3  1  2  3
       MAT:  1  1  1  2  2  2  3  3  3
       X:    1  2  3  4  5  6  7  8  9

    Alternatively, you can stack the lab values so that the x-axis is
    laid out as

       LAB:  1  1  1
             2  2  2
             3  3  3
       MAT:  1  2  3
       X:    1  2  3

    To specify the stacked alternative, enter the command

       SET H CONSISTENCY PLOT TYPE STACKED

    To reset the line linear option, enter the command

       SET H CONSISTENCY PLOT TYPE DEFAULT

Note:
    By default, the x-axis is defined by "laboratories within
    materials".

    To defined the x-axis as "materials within laboratories",
    enter the command

        SET H CONSISTENCY PLOT MATERIALS WITHIN LABORATORIES

    To reset the default, enter

        SET H CONSISTENCY PLOT LABORATORIES WITHIN MATERIALS

    We find it useful to generate both versions of the plot.  Although
    the information being displayed is the same, different types of
    patterns may be clearer in one or the other of these plots.

Note:
    For better separation between laboratories (or materials), you
    can enter the command

        SET H CONSISTENCY PLOT GAP <value>

    where <value> is a non-negative integer.  So in the above
    example,

        SET H CONSISTENCY PLOT GAP 1

    yields

       LAB:  1  2  3  1  2  3  1  2  3
       MAT:  1  1  1  2  2  2  3  3  3
       X:    1  2  3  5  6  7  9 10 11

Note:
    In some studies, the number of laboratories may be fairly
    large.  In these cases, you may want to split the laboratories
    into multiple plots for better resolution.  However, you want
    to include all laboratories and materials in the computation
    of the h- and k-consistency statistics.  Simply using the
    SUBSET clause to specify which laboratories (or materials) are
    excluded from the plot will also exclude them from the computation
    of the statistics.

    To address this, the following commands were added

        SET H CONSISTENCY PLOT LABORATORY FIRST <value>
        SET H CONSISTENCY PLOT LABORATORY LAST  <value>
        SET H CONSISTENCY PLOT MATERIAL   FIRST <value>
        SET H CONSISTENCY PLOT MATERIAL   LAST  <value>

    These commands allow you to specify the range of laboratories
    (or materials) to be displayed while still using the full set
    in computing the statistics.  Note that these commands limit
    you to contiguous ranges of laboratories or materials.

Note:
    In some sense, these plots are used to identify outliers.  However,
    Mandel has emphasized that the purpose is primarily identification
    of systematic patterns rather than rejection of outlying
    laboratories.

    That is, if there are laboratories that are systematically higher or
    systematically lower than the others, then the test protocol should be
    carefully examined.  Although rejection may be warranted in the case
    of an obvious error, the real purpose is to improve the underlying
    measurement process.  That is, does the method itself produce consist
    results with different laboratories?  Was the specification of the
    method clear enough so that different laboratories imnplemented it in
    a consistent manner?

Default:
    None
 
Synonyms:
    The various SET H CONSISTENCY PLOT commands can also be given
    as SET K CONSISTENCY PLOT or SET COCHRAN VARIANCE PLOT.  Regardless
    of which is used, the SET commands will apply to all threee
    variations of the plot.
 
Related Commands:
    E691 INTERLAB       = Perform an interlaboratory analysis based
                          on the E691 standard.
    TWO FACTOR PLOT     = Generate a run sequence plot with two
                          factor variables.
    TWO WAY ROW PLOT    = Generate a plot based on Mandel's row
                          linear analysis for two-way tables.

References:
    "Standard Practice for Conducting an Interlaboratory Study
    to Determine the Precision of a Test Method", ASTM
    International, 100 Barr Harbor Drive, PO BOX C700,
    West Conshohoceken, PA 19428-2959, USA.
 
    Mandel (1994), "Analyzing Interlaboratory Data According to ASTM
    Standard E691", Quality and Statistics: Total Quality Management,
    ASTM STP 1209, Kowalewski, Ed., American Society for Testing and
    Materials, Philadelphia, PA 1994, pp. 59-70.

    Mandel (1993), "Outliers in Interlaboratory Testing", Journal of
    Testing and Evaluation, Vol. 21, No. 2, pp. 132-135.

    Mandel (1995), "Structure and Outliers in Interlaboratory Studies",
    Journal of Testing and Evaluation, Vol. 23, No. 5, pp. 364-369.

    Mandel (1991), "Evaluation and Control of Measurements", Marcel
    Dekker, Inc.

Applications:
    Interlaboratory Studies
 
Implementation Date:
    2015/5
 
Program 1:
    . Step 1:   Read the data
    .
    skip 25
    read mandel6.dat y labid matid
    .
    . Step 2:   Default plot control settings
    .
    case asis
    label case asis
    tic mark label case asis
    title case asis
    title offset 2
    multiplot corner coordinates 5 5 95 95
    multiplot scale factor 2
    .
    . Step 3:   Plot options
    .
    let nlab = unique labid
    let nmat = unique matid
    let ntot = nlab*nmat
    .
    xlimits 1 ntot
    major x1tic mark number ntot
    minor x1tic mark number 0
    x1tic mark offset 1 1
    x1tic mark label off
    legend 1 MATERIAL:
    legend 2 LAB:
    legend 1 justification right
    legend 2 justification right
    legend 1 coordinates 14 12
    legend 2 coordinates 14 15
    legend 1 size 1.7
    legend 2 size 1.7
    spike on
    spike base 0
    line blank solid solid solid
    line color black black red red
    .
    . Step 4:   Generate the plot
    .
    title h Consistency Plot for  Pentosans in Wood Pulp: Laboratories within Materials
    h consistency plot y labid matid
    .
    just left
    let atemp = round(hcv,2)
    movesd 87 atemp
    text ^atemp
    let atemp = -atemp
    movesd 87 atemp
    text ^atemp
    .
    let ycoorz = 16
    let xcoor = 1
    justification center
    height 1.0
    .
    loop for k = 1 1 ntot
        moveds xcoor ycoorz
        let ktemp = mod(k-1,nlab) + 1
        text ^ktemp
        let xcoor = xcoor + 1
    end of loop
    .
    height 1.5
    let ycoorz = 12
    let xcoor = (nlab/2)+0.5
    line color red
    line dash
    loop for k = 1 1 nmat
        moveds xcoor ycoorz
        let ival = k
        text ^ival
        if k < nmat
           let xcoor2 = xcoor + (nlab/2)
           drawdsds xcoor2 20 xcoor2 90
        end of if
        let xcoor = xcoor + nlab
    end of loop
    line color black
    line blank

Program 2:
    . Step 1:   Read the data
    .
    skip 25
    read mandel6.dat y labid matid
    .
    . Step 2:   Default plot control settings
    .
    case asis
    label case asis
    tic mark label case asis
    title case asis
    title offset 2
    multiplot corner coordinates 5 5 95 95
    multiplot scale factor 2
    .
    . Step 3:   Plot options
    .
    let nlab = unique labid
    let nmat = unique matid
    let ntot = nlab*nmat
    .
    set h consistency plot materials within Laboratories
    xlimits 1 ntot
    major x1tic mark number ntot
    minor x1tic mark number 0
    x1tic mark offset 1 1
    x1tic mark label off
    legend 1 MATERIAL:
    legend 2 LAB:
    legend 1 justification right
    legend 2 justification right
    legend 1 coordinates 14 15
    legend 2 coordinates 14 12
    legend 1 size 1.7
    legend 2 size 1.7
    spike on
    spike base 0
    line blank solid solid solid
    line color black black red red
    .
    . Step 4:   Generate the plot
    .
    title h Consistency Plot for Pentosans in Wood Pulp: Materials within Laboratories
    h consistency plot y labid matid
    .
    just left
    let atemp = round(hcv,2)
    movesd 87 atemp
    text ^atemp
    let atemp = -atemp
    movesd 87 atemp
    text ^atemp
    .
    let ycoorz = 16
    let xcoor = 1
    justification center
    height 1.0
    .
    loop for k = 1 1 ntot
        moveds xcoor ycoorz
        let ktemp = mod(k-1,nmat) + 1
        text ^ktemp
        let xcoor = xcoor + 1
    end of loop
    .
    height 1.5
    let ycoorz = 12
    let xcoor = (nmat/2)+0.5
    line color red
    line dash
    loop for k = 1 1 nlab
        moveds xcoor ycoorz
        let ival = k
        text ^ival
        if k < nlab
           let xcoor2 = xcoor + (nmat/2)
           drawdsds xcoor2 20 xcoor2 90
        end of if
        let xcoor = xcoor + nmat
    end of loop
    line color black
    line blank

-----H CONSISTENCY STATISTIC (LET)--------------------------
 
H CONSISTENCY STATISTIC
 
Name:
    H CONSISTENCY STATISTIC (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the h-consistency statistic of a variable as defined
    by the ASTM E691 standard.
 
Description:
    The h-consistency statistic is defined in the
    ASTM E 691 - 99 standard as

       h    = d/s(xtilde) (between laboratory consistency statistic)
 
    with

       d          = cell deviation (cell average - average of cell
                    averages)
       s(xtilde)  = standard deviations of cell averages

Syntax 1:
    LET <h> = H CONSISTENCY STATISTIC <y> <labid>
               <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <labid> is a lab-id variable;
          <h> is a variable where the h-consistency statistic
              values are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used to compute the h-consistency statistic
    for a single material.  The number of h-values is equal to
    the number of laboratories.

Syntax 2:
    LET <h> = H CONSISTENCY STATISTIC <y> <labid> <matid>
               <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <labid> is a lab-id variable;
          <matid> is a material-id variable;
          <h> is a variable where the h-consistency statistic
              values are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used to compute the h-consistency statistic
    for multiple materials.  The number of h-values is equal to
    the number of materials times the number of laboratories.

Examples:
    LET A = H CONSISTENCY STATISTIC Y LAB
    LET HVAL = H CONSISTENCY STATISTIC Y LAB MAT
    LET HVAL = H CONSISTENCY STATISTIC Y LAB MAT SUBSET MAT > 2
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    E691 INTERLAB             = Perform an E691 interlab analysis.
    K CONSISTENCY STATISTIC   = Compute the k-consistency statistic.
 
Reference:
    "Standard Practice for Conducting an Interlaboratory Study
    to Determine the Precision of a Test Method", ASTM
    International, 100 Barr Harbor Drive, PO BOX C700,
    West Conshohoceken, PA 19428-2959, USA.

Applications:
    Interlaboratory Analysis
 
Implementation Date:
    2005/4
 
Program:
    SKIP 25
    READ GLUCOSE.DAT Y MATID LABID
    .
    LET HVAL = H CONSISTENCY STATISTIC Y LABID MATID
 
-----HEAVE (LET)--------------------------------
 
HEAVE
 
Name:
    HEAVE (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Heaveside function.
 
Description:
    The Heaveside function is equal to 1 if the input value is
    greater than or equal to zero and equal to 0 otherwise.  DATAPLOT
    also allows 2 optional parameters, say A and B.  Then the function
    is equal to 1 if the input value is between (inclusive) A and B
    and equal to zero otherwise.  If no second argument is given,
    it is assumed to be zero and if no third argument is given, it is
    assumed to be machine infinity.

    This second form is useful for defining functions that vary
    over different ranges of the input variable.  For example, to
    define a function that is X**2 for positive values and X**3 for
    negative values, enter the following command:

        LET FUNCTION F = X**2*HEAVE(X) + X**3*HEAVE(X,-3.4/10**37,0)
        PLOT F FOR X = -5 0.01 5
 
Syntax:
    LET <y> = HEAVE(<x>,<a>,<b>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <a> is an optional number, parameter, or variable which
               defines the lower cut-off value;
          <b> is an optional number, parameter, or variable which
               defines the upper cut-off value;
          <y> is a variable or a parameter (depending on what <x>, 
               <a>, and <b> are) where the computed heaveside function
               is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = HEAVE(X)
    LET A = HEAVE(X,4)
    LET X2 = HEAVE(X,0.5,1.0)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ABS     = Compute the absolute value of a number.
    SQRT    = Compute the square root of a number.
    EXP     = Compute the exponential of a number.
    MOD     = Compute the modulo (i.e., the remainder of x/y) of two
              numbers.
    MIN     = Compute the minimum of two numbers.
    MAX     = Compute the maximum of two numbers.
    DIM     = Compute the positive difference of two numbers.
 
Applications:
    Defining functions
 
Implementation Date:
    Pre-1987
 
Program 1:
    TITLE AUTOMATIC
    Y1TIC OFFSET 0.1 0.1
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDIANTES 0 0 100 100
    PLOT HEAVE(X) FOR X = -5 0.01 5
    PLOT HEAVE(X,2) FOR X = -5 0.01 5
    PLOT HEAVE(X,1,4) FOR X = -5 0.01 5
    PLOT HEAVE(X,4,1) FOR X = -5 0.01 5
    END OF MULTIPLOT
 
Program 2:
    .  USE HEAVESIDE FUNCTION TO GENERATE PDF'S OF RICE
    .  DISTRIBUTIONS.  LET A AND B DEFINE THE LOWER AND
    .  UPPER TRUNCATION POINTS RESPECTIVELY AND MEAN AND SD THE
    .  MEAN AND STANDARD DEVIATION OF THE NORMAL DISTRIBUTION.
    .
    LET FUNCTION F1 = (X/SD**2)*EXP(-(X**2+MEAN**2)/(2*SD**2))
    LET FUNCTION F = F1*BESSI0(MEAN*X/SD**2)*HEAVE(X)
    TITLE RICE DISTRIBUTION
    XLIMITS 0 10
    XTIC OFFSET 0.1
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDIANTES 0 0 100 100
    LET MEAN = 0.5
    LET SD = 2.2
    X1LABEL U = ^MEAN, S = ^SD
    PLOT F FOR X = 0 .01 10
    LET MEAN = -3
    LET SD = 0.5
    X1LABEL U = ^MEAN, S = ^SD
    PLOT F FOR X = 0 .01 6
    LET MEAN = 0
    LET SD = 1
    X1LABEL U = ^MEAN, S = ^SD
    PLOT F FOR X = 0 .01 10
    LET MEAN = 5
    LET SD = 4
    X1LABEL U = ^MEAN, S = ^SD
    PLOT F FOR X = 0 .01 10
    END OF MULTIPLOT

-----HEDGES G CONFIDENCE LIMITS--------------------------
 
HEDGES G CONFIDENCE LIMITS
 
Name:
    HEDGES G CONFIDENCE LIMITS
 
Type:
    Analysis Command
 
Purpose:
    Generates a confidence interval for the Hedge's g statistic.
 
Description:
    The Hedge's g statistic is used to measure the effect size for the
    difference between two means.  The formula is

        g = (ybar1 - ybar2)/s(p)

    with ybar1, ybar2, and s(p) denoting the mean of sample 1, the mean
    of sample 2, and the pooled standard deviation, respectively.

    The formula for the pooled standard deviation is

        s(p) = SQRT{((n1-1)*s1**2 + (n2-1)*s2**2)/((n1-1) + (n2-1))}

    with s1 and n1 denoting the standard deviation and number of
    observations for sample 1, respectively, and s2 and n2 denoting the
    standard deviation and number of observations for sample 2,
    respectively.

    The Hedge's g statistic expresses the difference of the means in
    units of the pooled standard deviation.  It is typically used in
    the context where one of the samples is a control sample.  That is,
    we are interested in the effect size relative to a control sample.

    The confidence interval for the Hedge's g statistic is

        g +/- NORPPF(1-(alpha/2))*G(se)

    where

       NORPPF   = the percent point function of the normal distribution
       G(se)    = the standard error of the g statistic
                = SQRT((n1+n2)/(n1*n2) + g**2/(2*(n1+n2))

Syntax:
    HEDGES G CONFIDENCE LIMITS <y1>  <y2>   <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Examples:
    HEDGES G CONFIDENCE LIMITS Y1 Y2
    HEDGES G CONFIDENCE LIMITS Y1 Y2  SUBSET TAG = 1
 
Note:
    Hedge's g is similar to the Cohen's d statistic and the Glass g
    statistic.  The difference is what is used for the estimate of the
    pooled standard deviation.  The Hedge's g uses a sample size weighted
    pooled standard deviation while Cohen's d uses

         s(p) = SQRT((s1**2 + s2**2)/2)

    That is, Cohen's d does not weight the standard deviations based on
    the sample sizes.

    These statistic are typically used to compare an experimental sample
    to a control sample.  The Glass g statistic uses the standard
    deviation of the control sample rather than the pooled standard
    deviation.  His argument for this is that experimental samples with
    very different standard deviations can result in significant
    differences in the g statistic for equivalent differences in the
    mean.  So the Glass g statistic measures the difference in means in
    units of the control sample standard deviation.

    Hedge's g, Cohen's d, and Glass's g are interpreted in the same way.
    Cohen recommend the following rule of thumb

         0.2  => small effect
         0.5  => medium effect
         0.8  => large effect

    However, Cohen did suggest caution for this rule of thumb as the
    meaning of small, medium and large may vary depending on the context
    of a particular study.

    The Hedge's g statistic is generally preferred to Cohen's d statistic.
    It has better small sample properties and has better propoerties when
    the sample sizes are signigicantly different.  For large samples where
    n1 and n2 are similar, the two statistics should be almost the same.
    The Glass g statistic may be preferred when the standard deviations
    are quite different.
 
Note:
    In many cases, there are multiple experimental groups being compared 
    to a control.  This could be either a separate control sample for each
    experiment (e.g., we are comparing effect sizes from different
    experiments) or a common control (e.g., different laboratories are
    measuring identical material and are being compared to a reference
    measurement). In these cases, you can compute the Hedge's g (or
    Glass's g or Cohen's d) for each experiment relative to its control
    group.  You can then obtain an "overall" value of the statistic by
    averaging these individual statistics.

Note:
    In addition to the HEDGES G CONFIDENCE LIMIT command,
    the following commands can also be used:

        LET ALPHA = 0.05

        LET A = HEDGES G LOWER CONFIDENCE LIMIT Y1 Y2
        LET A = HEDGES G UPPER CONFIDENCE LIMIT Y1 Y2
        LET A = HEDGES G STANDARD ERROR Y1 Y2

    In addition to the above LET commands, built-in statistics are
    supported for 20+ different commands (enter HELP STATISTICS for
    details).

Default:
    None
 
Synonyms:
    CONFIDENCE INTERVAL is a synonym for CONFIDENCE LIMITS
 
Related Commands:
    HEDGES G                  = Compute Hedge's g statistic.
    T TEST                    = Perform a two sample t-test.
    QUANTILE QUANTILE PLOT    = Generate a quantile-quantile plot.
 
References:
    Hedges and Olkin (1985), "Statistical Methods for Meta-Analysis",
    New York: Academic Press.

    Durlak (2009), "How to Select, Calculate, and Interpret Effect
    Sizes", Journal of Pediatric Psychology, Vol. 34, No. 9, pp. 917-928.
 
    Hedges (1981), "Distribution Theory for Glass's Estimator of Effect
    Size and Related Estimators", Journal of Educational Statistics,
    Vol. 6, No. 2, pp. 107-128.

    Cohen (1977), "Statistical Power Analysis for the Behavioral
    Sciences", Routledge.

    Glass (1976), "Primary, Secondary, and Meta-Analysis of Research",
    Educational Researcher, Vol. 5, pp. 3-8.

Applications:
    Confirmatory Data Analysis
 
Implementation Date:
    2018/08
 
Program:
    SKIP 25
    READ AUTO83B.DAT Y1 Y2
    DELETE Y2 SUBSET Y2 < 0
    SET WRITE DECIMALS 5
    .
    LET HG    = HEDGES G Y1 Y2
    LET HGSE  = HEDGES G STANDARD ERROR Y1 Y2
    LET HGLCL = HEDGES G LOWER CONFIDENCE LIMIT Y1 Y2
    LET HGUCL = HEDGES G UPPER CONFIDENCE LIMIT Y1 Y2
    .
    PRINT HG HGSE HGLCL HGUCL
    HEDGES G CONFIDENCE LIMITS Y1 Y2

-----HEDGES G (LET)--------------------------------------
 
HEDGES G
 
Name:
    HEDGES G (LET)
    BIAS CORRECTED HEDGES G (LET)
    COHENS D (LET)
    GLASS G (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the Hedge's g (or the bias corrected Hedge's g) statistic
    for two response variables.
 
Description:
    The Hedge's g statistic is used to measure the effect size for the
    difference between means.  The formula is

        g = (ybar1 - ybar2)/s(p)

    with ybar1, ybar2, and s(p) denoting the mean of sample 1, the mean
    of sample 2, and the pooled standard deviation, respectively.

    The formula for the pooled standard deviation is

        s(p) = SQRT{((n1-1)*s1**2 + (n2-1)*s2**2)/((n1-1) + (n2-1))}

    with s1 and n1 denoting the standard deviation and number of
    observations for sample 1, respectively, and s2 and n2 denoting the
    standard deviation and number of observations for sample 2,
    respectively.

    The Hedge's g statistic expresses the difference of the means in
    units of the pooled standard deviation.

    For small samples, the following bias correction is recommended

         ((n-3)/(n-2.25))*SQRT((n-2)/n)

    where n = n1 + n2.  This bias correction is typically recommended
    when n < 50.

    NOTE: The bias term above is given in Durlak.  The original
          approximation given by Hedges is

              1 - 3/(4*n - 9)

          The term being approximated is

              J(n1 + n2 - 2)

          where

             J(x) = Gamma(x/2)/{SQRT(x/2)*Gamma((x-1)/2))}

          with Gamma denoting the Gamma function.

          Running a comparison indicated that Hedge's original
          approximation is more accurate than that given by Durlak.
          The 2018/08 version of Dataplot modified the bias correction
          to use the original J function with Gamma functions for
          n1 + n2 <= 40 and to use Hedge's original approximation
          otherwise.

    Hedge's g is similar to the Cohen's d statistic and the Glass g
    statistic.  The difference is what is used for the estimate of the
    pooled standard deviation.  The Hedge's g uses a sample size weighted
    pooled standard deviation while Cohen's d uses

         s(p) = SQRT((s1**2 + s2**2)/2)

    That is, Cohen's d does not weight the standard deviations based on
    the sample sizes.

    These statistic are typically used to compare an experimental sample
    to a control sample.  The Glass g statistic uses the standard
    deviation of the control sample rather than the pooled standard
    deviation.  His argument for this is that experimental samples with
    very different standard deviations can result in significant
    differences in the g statistic for equivalent differences in the
    mean.  So the Glass g statistic measures the difference in means in
    units of the control sample standard deviation.

    Hedge's g, Cohen's d, and Glass's g are interpreted in the same way.
    Cohen recommend the following rule of thumb

         0.2  => small effect
         0.5  => medium effect
         0.8  => large effect

    However, Cohen did suggest caution for this rule of thumb as the
    meaning of small, medium and large may vary depending on the context
    of a particular study.

    The Hedge's g statistic is generally preferred to Cohen's d statistic.
    It has better small sample properties and has better propoerties when
    the sample sizes are signigicantly different.  For large samples where
    n1 and n2 are similar, the two statistics should be almost the same.
    The Glass g statistic may be preferred when the standard deviations
    are quite different.

    In many cases, there are multiple experimental groups being compared 
    to a control.  This could be either a separate control sample for each
    experiment (e.g., we are comparing effect sizes from different
    experiments) or a common control (e.g., different laboratories are
    measuring identical material and are being compared to a reference
    measurement). In these cases, you can compute the Hedge's g (or
    Glass's g or Cohen's d) for each experiment relative to its control
    group.  You can then obtain an "overall" value of the statistic by
    averaging these individual statistics.

Syntax 1:
    LET <par> = HEDGES G <y1> <y2>    <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Hedge's g statistic
               is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax computes Hedge's g statistic without the bias correction.
 
Syntax 2:
    LET <par> = BIAS CORRECTED HEDGES G <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed bias corrected
               Hedge's g statistic is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes Hedge's g statistic with the bias correction.
 
Syntax 3:
    LET <par> = GLASS G <y1> <y2>    <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Glass's g statistic
               is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax computes Glass's g statistic.

    The <y2> variable will be treated as the "control" sample.  That is,
    the standard deviation of <y2> will be used as the pooled standard
    deviation.
 
Syntax 4:
    LET <par> = COHEN D <y1> <y2>    <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Cohen's d statistic
               is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax computes Cohen's d statistic.
 
Examples:
    LET A = HEDGES G Y1 Y2
    LET A = BIAS CORRECTED HEDGES G Y1 Y2
    LET A = BIAS CORRECTED HEDGES G Y1 Y2  SUBSET Y1 > 0
    LET A = GLASS G Y1 Y2
    LET A = COHEN D Y1 Y2
 
Note:
    This statistic can be used in a large number of plots and commands.
    For details, enter

        HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    MEAN                            = Compute the mean.
    STANDARD DEVIATION              = Compute the standard deviation.
    DIFFERENCE OF MEANS             = Compute the difference of means.
    BLAND ALTMAN PLOT               = Generate a Bland Altman plot.
    BIHISTOGRAM                     = Generate a bi-histogram plot.
    QUANTILE QAUNTILE PLOT          = Generate a quantile-quantile plot.
 
References:
    Hedges (1981), "Distribution Theory for Glass's Estimator of Effect
    Size and Related Estimators", Journal of Educational Statistics,
    Vol. 6, No. 2, pp. 107-128.

    Cohen (1977), "Statistical Power Analysis for the Behavioral
    Sciences", Routledge.

    Glass (1976), "Primary, Secondary, and Meta-Analysis of Research",
    Educational Researcher, Vol. 5, pp. 3-8.

    Durlak (2009), "How to Select, Calculate, and Interpret Effect Sizes",
    Journal of Pediatric Psychology, Vol. 34, No. 9, pp. 917-928.

    Hedges and Olkin (1985), "Statistical Methods for Meta-Analysis",
    New York: Academic Press.

Applications:
    Data Analysis
 
Implementation Date:
    2017/07
    2018/08: Modified bias correction term for Hedge's G
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = HEDGES G Y1 Y2
    TABULATE HEDGES G Y1 Y2 X
    .
    LABEL CASE ASIS
    TITLE CASE ASIS
    Y1LABEL Hedge's G Statistic
    X1LABEL Group
    TITLE Hedge's G Statistic for IRIS.DAT
    X1TIC MARK OFFSET 0.5 0.5
    TIC MARK OFFSET UNITS DATA
    CHAR X
    LINE BLANK
    HEDGES G PLOT Y1 Y2 X
    .
    Y1LABEL Hedge's G Statistic
    X1LABEL Group
    TITLE Bootstrap of Hedge's G Statistic for IRIS.DAT
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP SAMPLES 1000
    BOOTSTRAP HEDGES G PLOT Y1 Y2 X 
 
-----HEIGHT-------------------------------------------------------
 
HEIGHT
 
Name:
    HEIGHT
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Specifies the height of various diagrammatic graphics components:
        1) letters (from the TEXT command);
        2) numerals (from the TEXT command);
        3) mathematics symbols (from the TEXT command);
        4) arrow head length (from the ARROW command);
        5) capacitor bar height (from the CAPACITOR command);
        6) resistor wrinkle height (from the RESISTOR command);
        7) inductor loop height (from the INDUCTOR COMMAND).
 
Description:
    The height of the character is from the visible bottom of the
    character to the visible top of the character.  The vertical
    spacing between characters is not counted (that is controlled by
    the VERTICAL SPACING command).  The height is in decimal units of
    0 to 100.  A height of 0 would be negligibly small while  a height
    of 100 would be full screen vertical distance.
 
Syntax:
    HEIGHT   <n>
    where <n> is a number or parameter in decimal units of 0 to 100
    that specifies the desired height.
 
Examples:
    HEIGHT 10
    HEIGHT 3
    HEIGHT 2.55
    HEIGHT H
 
Note:
    The HEIGHT command with no arguments reverts the height to the
    default.
 
Note:
    If hardware characters are used (FONT TEKTRONIX), DATAPLOT uses the
    closest size available on that device.  Note that some devices have
    only 1 hardware character size and most have only a few discrete
    sizes.
 
Note:
    There are also commands to control the heights of each of the
    elements of a plot (see the RELATED COMMANDS section).
 
Default:
    The default height is 1.5.
 
Synonyms:
    None
 
Related Commands:
    TEXT               = Writes a text string.
    TITLE SIZE         = Sets the height of the plot title.
    LABEL SIZE         = Sets the height of the plot labels.
    LEGEND SIZE        = Sets the height of the plot legends.
    TIC LABEL SIZE     = Sets the height of the plot tic mark labels.
    WIDTH              = Sets the width for TEXT characters.
    HW                 = Sets the height and width for TEXT characters.
    VERTICAL SPACING   = Sets the vertical spacing between text lines.
    HORIZONTAL SPACING = Sets the horizontal spacing between text
                         characters.
    FONT               = Sets the font for TEXT characters.
    CASE               = Sets the case for TEXT characters.
    THICKNESS          = Sets the thickness of TEXT characters.
    COLOR              = Sets the color for TEXT characters.
    JUSTIFICATION      = Sets the justification for TEXT characters.
    CR                 = Sets the carriage return position after text.
    LF                 = Sets the line feed position after text.
    CRLF               = Sets the carriage return/line feed position
                         after text.
    MARGIN             = Sets the carriage return column after text.
    ()                 = Allows math and Greek characters in text.
    MOVE               = Moves to a point.
    CROSS-HAIR (or CH) = Activates and reads the cross-hair.
    ERASE              = Erases the screen (immediately).
    COPY               = Copies the screen (immediately).
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    VERTICAL SPACING 6
    CRLF ON
    MARGIN 10
    FONT DUPLEX
    .
    HEIGHT 4
    MOVE 5 95
    TEXT JAPAN's 6-POINT PROGRAM FOR
    MOVE 5 89
    TEXT QUALITY MANUFACTURING
    MOVE 10 80
    HEIGHT 2.2
    TEXT CIRC() QUALITY AUDITS
    TEXT CIRC() COMPANY-WIDE QUALITY CONTROL (CWQC)
    TEXT CIRC() QUALITY TRAINING AND EDUCATION
    TEXT CIRC() APPLICATION OF STATISTICAL METHODS
    TEXT CIRC() QUALITY CIRCLE ACTIVITIES
    TEXT CIRC() NATION-WIDE QUALITY CONTROL PROMOTIONAL ACTIVITIES
    HEIGHT 2
    MOVE 5 10
    TEXT SOURCE: Q.C. TRENDS WINTER 1985, PAGES 22-23.
 
-----HELP-------------------------------------------------------
 
HELP
 
Name:
    HELP
 
Type:
    Support Command
 
Purpose:
    Prints the on-line documentation for either a command or a command
    category.
 
Description:
    Help information is printed one screen at a time.  The SET HELP
    LINES command can be used to define the number of lines per screen
    for your terminal.  The HELP command assumes an 80 character wide
    terminal (the maximum line is 71 characters).
 
    DATAPLOT commands are grouped into categories: GRAPHICS, PLOT
    CONTROL, ANALYSIS, SUPPORT, OUTPUT DEVICES, DIAGRAMMATIC GRAPHICS,
    FUNCTIONS, KEYWORDS, and LET SUBCOMMANDS.  Entering HELP followed
    by one of these categories will list the commands available in this
    category.
 
    In addition, the following document general considerations (as
    opposed to specific commands): TEXT SUBCOMMANDS, CAPITILIZATION,
    SUBSCRIPTS, GREEK SYMBOLS, MATH SYMBOLS, MISC SYMBOLS, CHARACTER
    TYPES, LINE TYPES, and COLOR TYPES.
 
    Entering HELP followed by a command gives the syntax of the
    command as well as examples of its use.
 
Syntax:
    HELP   <command>
    where <command> is the name of a command or a topic for which help
    is needed.
 
Examples:
    HELP
    HELP PLOT
    HELP FIT
    HELP LET
    HELP 3D-PLOT
    HELP READ
    HELP GRAPHICS
    HELP ANALYSIS
 
Note:
    The HELP command with no arguments prints out a brief overview of
    DATAPLOT.
 
Note:
    The documentation for the HELP facility tends to lag behind the
    inclusion of new capabilities.  The NEWS command documents new
    capabilities in DATAPLOT.  If you do not find the topic under HELP,
    be sure to check the NEWS file.
 
Note:
    In general, the on-line help facility is intended to provide
    detailed information for a specific command.  It is not intended as
    a tutorial for learning how to use DATAPLOT.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    NEWS       = Lists the news file.
    BUGS       = Lists the bugs file.
    STATUS     = Displays dimension, variable, parameter, and function
                 information.
    PROBE      = Displays the value of an internal variable.
    SET        = Sets the value of an internal variable.
    HELP LINES = Sets the number of lines per help screen.
 
Applications:
    On-Line Help
 
Implementation Date:
    Pre-1987 (HELP files are frequently updated)
 
Program:
    HELP
    HELP GRAPHICS
    HELP PLOT
    PLOT X**2 FOR X = 1 1 9
 
-----HELP LINES (SET)--------------------------------------------
 
HELP LINES
 
Name:
    HELP LINES (SET)
 
Type:
    Set Subcommand
 
Purpose:
    Define the number of lines to be printed to the screen when a HELP
    command is entered before waiting for a carriage return.
 
Description:
    This command allows lengthy help messages to be read one screen at
    a time.
 
Syntax:
    SET HELP LINES <value>
    where <value> is a positive integer number or parameter.
 
Examples:
    SET HELP LINES 20
    SET HELP LINES 50
 
Default:
    Help screens are listed 20 lines at a time.
 
Synonyms:
    None
 
Related Commands:
    HELP               = Access on-line help.
    SET LIST LINES     = Define number of lines to a screen for the
                         LIST command.
 
Applications:
    Online Help
 
Implementation Date:
    Pre-1987
 
Program:
    SET HELP LINES 30
    HELP FIT
 
-----HERCDF (LET)--------------------------------
 
HERCDF
 
Name:
    HERCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Hermite cumulative distribution function.
 
Description:
    If X1 and X2 are independent Poisson random variables
    with shape parameters alpha*beta and (1/2)*alpha**2,
    respectively, then X1 + 2*X2 follows a Hermite distribution 
    with shape parameters alpha and beta.

    Some sources in the literature use the parameterization

       a = a1 = alpha*beta
       b = a2 = 0.5*alpha**2

    The shape parameters alpha and beta can be expressed in
    terms of a1 and a2 as

       alpha = SQRT(2*b)
       beta = a/SQRT(2*b)

    The probability mass function for the Hermite distribution is:

       p(x,alpha,beta) = (alpha**x*H(x)(beta)/x!)*p(x=0,alpha,beta)

    with H(x) denoting the modified Hermite polynomial:

       H(x)(beta) = SUM[j=0 to INT(N/2)]
                    [N!*X**(N-2*j)/((N-2(j)!j!2**j)]

    The first few terms are:

       p(x=0) = EXP[-alpha*beta - alpha**2/2]
       p(X=1) = alpha*beta*p(X=0)
       p(X=2) = (alpha**2*(beta**2+1)/2!)*p(X=0)
       p(X=3) = (alpha**3*(beta**3+3*beta)/3!)*p(X=0)
       p(X=4) = (alpha**4*(beta**4+6*beta**2+3)/4!)*p(X=0)
       p(X=5) = (alpha**5*(beta**5+10*beta**3+15*beta)/5!)*p(X=0)
              
    A general recuurence relation is:

       p(x=x+1) = (1/(x+1))*alpha*beta*p(X=x) + alpha**2*p(X=x-1)

    For x <= 25, Dataplot uses the above recurrence relation to
    compute the probabilities.  For x > 25, Dataplot uses an
    asymptotic formula due to Patel (see Reference section below)
    to compute the probabilities.
 
Syntax:
    LET <y> = HERCDF(<x>,<alpha>,<beta>)
               <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative integer variable, number, or
              parameter (a warning message is printed if it is not);
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed Hermite cdf value is stored;
          <alpha> is a number or parameter that specifies the
               first shape parameter of the Hermite distribution;
          <beta> is a number or parameter that specifies the
               second shape parameter of the Hermite distribution;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = HERCDF(3,0.5,2)
    LET X2 = HERCDF(X1,ALPHA,BETA)
    PLOT HERCDF(X,0.8,1.4) FOR X = 0 1 20
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    HERPDF = Compute the Hermite probability density function.
    HERPPF = Compute the Hermite percent point function.
    POIPDF = Compute the Poisson cumulative distribution function.
    BINPDF = Compute the binomial probability density function.
    NBPDF  = Compute the negative binomial probability density
             function.
    GEOPDF = Compute the geometric probability density function.
 
Reference:
    "Discrete Univariate Distributions" Second Edition, Johnson,
    and Kotz, and Kemp, Wiley, 1992, pp. 357-364.

    "An Asymptotic Expression for Cumulative Sum of Probabilities
    of the Hermite Distribution", Y. C. Patel, Communications in
    Statistics--Theory and Methods, 14, pp. 2233-2241.

    "Some Properties of the Hermite Distribution", Kemp and Kemp,
    Biometrika (1965), 52, 3 and 4, P. 381.

    "Even Point Estimation and Moment Estimation in Hermite
    Distributions", Y. C. Patel, Biometrics, 32, December, 1976,
    pp. 865-873.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2004/4
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    XTIC OFFSET 0.5 0.5
    LINE BLANK
    SPIKE ON
    TITLE AUTOMATIC
    X1LABEL X
    Y1LABEL PROBABILITY
    TITLE SIZE 3
    PLOT HERCDF(X,0.5,2) FOR X = 0 1 50
    PLOT HERCDF(X,2,0.5) FOR X = 0 1 50
    PLOT HERCDF(X,0.5,0.5) FOR X = 0 1 50
    PLOT HERCDF(X,2,2) FOR X = 0 1 50
    END OF MULTIPLOT
 
-----HERMITE (LET)--------------------------------
 
HERMITE
 
Name:
    HERMITE (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Hermite polynomial of order N.
 
Description:
    From Abramowitz and Stegum (see Reference below), a system of
    nth degree polynomials f(x,n) is called orthogonal on the
    interval a<=x<=b with respect to a weight function w(x) if it
    satisfies the equation:
        INTEGRAL[w(x)*f(x,n)*f(x,m)]dx = 0   m<>n, (m,n = 0, 1, 2, ...

    Hermite polynomials use the weight function EXP(-x**2) and are
    orthogonal for all real x.

    DATAPLOT calculates the  Hermite polynomials using the following
    recurrence relation:
        H(x,n) = 2*x*H(x,n-1)-2*n*H(x,n-2)
    where the first few terms for the recuurence were obtained from
    the Handbook of Mathematical Functions (see the REFERENCE below).
 
Syntax 1:
    LET <y> = HERMITE(<x>,<n>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <n> is a non-negative integer number, parameter, or variable
              that specifies the order of the Hermite polynomial;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed Hermite polynomial value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    LET <y> = LNHERMIT(<x>,<n>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <n> is a non-negative integer number, parameter, or variable
              that specifies the order of the Hermite polynomial;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed Hermite polynomial value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This form of the command computes the logarithm of the absolute
    value of the Hermite polynomial.  It is included primarily for use
    in intermediate calculations to avoid overflow problems.  It is
    typically used with the HERMSGN function.

Syntax 3:
    LET <y> = HERMSGN(<x>,<n>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <n> is a non-negative integer number, parameter, or variable
              that specifies the order of the Hermite polynomial;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed Hermite polynomial value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This form of the command computes the sign of the Hermite
    polynomial.  It is included primarily for use in intermediate
    calculations to avoid overflow problems.  It is typically used
    with the HERMSGN function.  It returns a 1 if the Hermite
    polynomial is positive, a -1 if the Hermite polynomial is
    negative, and a 0 if the Hermite polynomial is 0.

Examples:
    LET A = HERMITE(-1,4)
    LET X2 = HERMITE(X1,10)
    LET X2 = HERMITE(X1-0.2,N)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHEBT    = Compute the Chebychev polynomial first kind, order N.
    CHEBU    = Compute the Chebychev polynomial second kind, order N.
    JACOBIP  = Compute the Jacobi polynomial of order N.
    LAGUERRE = Compute the Laguerre polynomial of order N.
    ULTRASPH = Compute the ultrasperical polynomial of order N.
    LEGENDRE = Compute the Legendre polynomial of order N.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 22).
 
Applications:
    Mathematics
 
Implementation Date:
    95/7
 
Program:
    TITLE CASE ASIS; LABEL CASE ASIS
    LINE SOLID DASH DOT DASH2
    X1LABEL X
    .
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE Hermite Polynomials (order 2 thru 5)
    Y1LABEL Hn(x)
    YMINIMUM 0
    YTIC OFFSET 100 0
    PLOT HERMITE(X,2) FOR X = 0 .01 3 AND
    PLOT HERMITE(X,3) FOR X = 0 .01 3 AND
    PLOT HERMITE(X,4) FOR X = 0 .01 3 AND
    PLOT HERMITE(X,5) FOR X = 0 .01 3
    .
    TITLE Scaled Hermite Polynomials (order 2 thru 5)
    Y1LABEL Hn(x)/n**3
    YLIMITS 0 30
    YTIC OFFSET 2 2
    PLOT HERMITE(X,2)/(2**3) FOR X = 0 .01 3 AND
    PLOT HERMITE(X,3)/(3**3) FOR X = 0 .01 3 AND
    PLOT HERMITE(X,4)/(4**3) FOR X = 0 .01 3 AND
    PLOT HERMITE(X,5)/(5**3) FOR X = 0 .01 3
    YLIMITS; YTIC OFFSET 0 0
    .
    TITLE Scaled Hermite Polynomials (order 2 thru 5)
    Y1LABEL Hn(x/SQRT(2))
    PLOT HERMITE(X/SQRT(2),2)/(2**3) FOR X = 0 .01 3 AND
    PLOT HERMITE(X/SQRT(2),3)/(3**3) FOR X = 0 .01 3 AND
    PLOT HERMITE(X/SQRT(2),4)/(4**3) FOR X = 0 .01 3 AND
    PLOT HERMITE(X/SQRT(2),5)/(5**3) FOR X = 0 .01 3
    .
    TITLE Weber functions (order 2 thru 5)
    Y1LABEL EXP(-x**2/4)*Hn(x/SQRT(2))
    LET FUNCTION F = EXP(-X**2)*HERMITE(X/SQRT(2),N)
    LET N = 2; PLOT F FOR X = -5 .01 5 AND
    LET N = 3; PLOT F FOR X = -5 .01 5 AND
    LET N = 4; PLOT F FOR X = -5 .01 5 AND
    LET N = 5; PLOT F FOR X = -5 .01 5
    END OF MULTIPLOT
 
-----HERPDF (LET)--------------------------------
 
HERPDF
 
Name:
    HERPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Hermite probability density function.
 
Description:
    If X1 and X2 are independent Poisson random variables
    with shape parameters alpha*beta and (1/2)*alpha**2,
    respectively, then X1 + 2*X2 follows a Hermite distribution 
    with shape parameters alpha and beta.

    Some sources in the literature use the parameterization

       a = a1 = alpha*beta
       b = a2 = 0.5*alpha**2

    The shape parameters alpha and beta can be expressed in
    terms of a1 and a2 as

       alpha = SQRT(2*b)
       beta = a/SQRT(2*b)

    The probability mass function for the Hermite distribution is:

       p(x,alpha,beta) = (alpha**x*H(x)(beta)/x!)*p(x=0,alpha,beta)

    with H(x) denoting the modified Hermite polynomial:

       H(x)(beta) = SUM[j=0 to INT(N/2)]
                    [N!*X**(N-2*j)/((N-2(j)!j!2**j)]

    The first few terms are:

       p(x=0) = EXP[-alpha*beta - alpha**2/2]
       p(X=1) = alpha*beta*p(X=0)
       p(X=2) = (alpha**2*(beta**2+1)/2!)*p(X=0)
       p(X=3) = (alpha**3*(beta**3+3*beta)/3!)*p(X=0)
       p(X=4) = (alpha**4*(beta**4+6*beta**2+3)/4!)*p(X=0)
       p(X=5) = (alpha**5*(beta**5+10*beta**3+15*beta)/5!)*p(X=0)
              
    A general recuurence relation is:

       p(x=x+1) = (1/(x+1))*alpha*beta*p(X=x) + alpha**2*p(X=x-1)

    For x <= 10, Dataplot uses the above recurrence relation to
    compute the probabilities.  For x > 10, Dataplot uses an
    asymptotic formula due to Patel (see Reference section below)
    to compute the probabilities.
 
Syntax:
    LET <y> = HERPDF(<x>,<alpha>,<beta>)
               <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative integer variable, number, or
              parameter (a warning message is printed if it is not);
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed Hermite pdf value is stored;
          <alpha> is a number or parameter that specifies the
               first shape parameter of the Hermite distribution;
          <beta> is a number or parameter that specifies the
               second shape parameter of the Hermite distribution;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = HERPDF(3,0.5,2)
    LET X2 = HERPDF(X1,ALPHA,BETA)
    PLOT HERPDF(X,0.8,1.4) FOR X = 0 1 20
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Note:
    The following commands are available for the Hermite
    distribution:

        LET ALPHA = <value>
        LET BETA = <value>
        LET Y = HERMITE RANDOM NUMBERS FOR I = 1 1 N
        HERMITE PROBABILITY PLOT Y
        HERMITE CHI-SQUARE GOODNESS OF FIT Y

        HERMITE PPCC PLOT Y

        HERMITE MAXIMUM LIKELIHOOD Y

     The HERMITE MAXIMUM LIKELIHOOD command estimates the
     parameters of the Hermite distribution using the following
     methods:

        1) method of moments:

              ahat = (2*xbar - s**2)
              bhat = (s**2 - xbar)/2

              alphahat = SQRT(s**2 - xbar)
              betahat  = (s**2/alphahat - 2*alphahat

           with xbar and s**2 denoting the sample mean and
           sample variance, respectively.

           Note that this method produces an admissable estimator
           if s**2 > xbar.

        2) method of even points:

              ahat = -0.5*LOG(2*SE/N - 1)
              bhat = 0.5*(xbar - ahat)

              alphahat = SQRT(2*bhat)
              betahat  = alphahat/SQRT(2*bhat)

           where SE is the sum of observed frequencies at
           X = 0, 2, ...

           This method generates an admissable estimator only
           if the sum of the obserbed frequencies at even values
           of x is greater than the sum of the observed frequencies
           of the odd values of x.

        3) The method of zero frequency and sample mean:

              ahat = -(xbar + 2*LOG(N0/N))
              bhat = xbar + LOG(N0/N)
 
              alphahat = SQRT(2*(xbar + LOG(N0/N))
              betahat = -(xbar + 2*LOG(N0/N))/
                        SQRT(2*(xbar + LOG(N0/N))

           with N0 denoting the zeroth frequency (i.e., the number
           of frequencies at X = 0).

           This method generates an admissable estimator only if

                -LOG(N0/N) <= xbar <= -2*LOG(N0/N)
            
        4) The method of maximum likelihood:

           The maximum likelihood estimation procedure is
           described in detail in Kemp and Kemp (see Reference
           below).

           Note that the maximum likelihood estimates can
           sometimes fail to converge or converge to obviously
           incorrect values.

       Patel discusses the various estimators for the Hermite
       distribution and gives some guidance on when the various
       estimators are most appropriate.  He also gives formulas
       for the variances and covariances of the estimators.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    HERCDF = Compute the Hermite cumulative distribution function.
    HERPPF = Compute the Hermite percent point function.
    POIPDF = Compute the Poisson cumulative distribution function.
    BINPDF = Compute the binomial probability density function.
    NBPDF  = Compute the negative binomial probability density
             function.
    GEOPDF = Compute the geometric probability density function.
 
Reference:
    "Discrete Univariate Distributions" Second Edition, Johnson,
    and Kotz, and Kemp, Wiley, 1992, pp. 357-364.

    "An Asymptotic Expression for Cumulative Sum of Probabilities
    of the Hermite Distribution", Y. C. Patel, Communications in
    Statistics--Theory and Methods, 14, pp. 2233-2241.

    "Some Properties of the Hermite Distribution", Kemp and Kemp,
    Biometrika (1965), 52, 3 and 4, P. 381.

    "Even Point Estimation and Moment Estimation in Hermite
    Distributions", Y. C. Patel, Biometrics, 32, December, 1976,
    pp. 865-873.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2004/4
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    XTIC OFFSET 0.5 0.5
    LINE BLANK
    SPIKE ON
    TITLE AUTOMATIC
    X1LABEL X
    Y1LABEL PROBABILITY
    TITLE SIZE 3
    PLOT HERPDF(X,0.5,2) FOR X = 0 1 50
    PLOT HERPDF(X,2,0.5) FOR X = 0 1 50
    PLOT HERPDF(X,0.5,0.5) FOR X = 0 1 50
    PLOT HERPDF(X,2,2) FOR X = 0 1 50
    END OF MULTIPLOT
 
-----HERPPF (LET)--------------------------------
 
HERPPF
 
Name:
    HERPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Hermite percent point function.
 
Description:
    If X1 and X2 are independent Poisson random variables
    with shape parameters alpha*beta and (1/2)*alpha**2,
    respectively, then X1 + 2*X2 follows a Hermite distribution 
    with shape parameters alpha and beta.

    Some sources in the literature use the parameterization

       a = a1 = alpha*beta
       b = a2 = 0.5*alpha**2

    The shape parameters alpha and beta can be expressed in
    terms of a1 and a2 as

       alpha = SQRT(2*b)
       beta = a/SQRT(2*b)

    The probability mass function for the Hermite distribution is:

       p(x,alpha,beta) = (alpha**x*H(x)(beta)/x!)*p(x=0,alpha,beta)

    with H(x) denoting the modified Hermite polynomial:

       H(x)(beta) = SUM[j=0 to INT(N/2)]
                    [N!*X**(N-2*j)/((N-2(j)!j!2**j)]

    The first few terms are:

       p(x=0) = EXP[-alpha*beta - alpha**2/2]
       p(X=1) = alpha*beta*p(X=0)
       p(X=2) = (alpha**2*(beta**2+1)/2!)*p(X=0)
       p(X=3) = (alpha**3*(beta**3+3*beta)/3!)*p(X=0)
       p(X=4) = (alpha**4*(beta**4+6*beta**2+3)/4!)*p(X=0)
       p(X=5) = (alpha**5*(beta**5+10*beta**3+15*beta)/5!)*p(X=0)
              
    A general recuurence relation is:

       p(x=x+1) = (1/(x+1))*alpha*beta*p(X=x) + alpha**2*p(X=x-1)

    Dataplot computes the Hermite percent point function by
    numerically inverting the Hermite cumulative distribution
    function.  For x <= 25, Dataplot uses the above recurrence
    relation to compute the probabilities.  For x > 25, Dataplot
    uses an asymptotic formula due to Patel (see Reference section
    below) to compute the probabilities.
 
Syntax:
    LET <y> = HERPPF(<p>,<alpha>,<beta>)
               <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, number, or parameter in the range
              (0,1];
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed Hermite ppf value is stored;
          <alpha> is a number or parameter that specifies the
               first shape parameter of the Hermite distribution;
          <beta> is a number or parameter that specifies the
               second shape parameter of the Hermite distribution;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = HERPPF(0.95,0.5,2)
    LET X2 = HERPPF(P,ALPHA,BETA)
    PLOT HERPPF(P,0.8,1.4) FOR P = 0 0.01 0.99
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    HERCDF = Compute the Hermite cumulative distribution function.
    HERPDF = Compute the Hermite probability density function.
    POIPDF = Compute the Poisson cumulative distribution function.
    BINPDF = Compute the binomial probability density function.
    NBPDF  = Compute the negative binomial probability density
             function.
    GEOPDF = Compute the geometric probability density function.
 
Reference:
    "Discrete Univariate Distributions" Second Edition, Johnson,
    and Kotz, and Kemp, Wiley, 1992, pp. 357-364.

    "An Asymptotic Expression for Cumulative Sum of Probabilities
    of the Hermite Distribution", Y. C. Patel, Communications in
    Statistics--Theory and Methods, 14, pp. 2233-2241.

Applications:
    Distributional Modeling
 
Implementation Date:
    2004/4
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    XTIC OFFSET 0.5 0.5
    LINE BLANK
    SPIKE ON
    TITLE AUTOMATIC
    X1LABEL X
    Y1LABEL PROBABILITY
    TITLE SIZE 3
    PLOT HERPPF(P,0.5,2) FOR P = 0 0.01 0.99
    PLOT HERPPF(P,2,0.5) FOR P = 0 0.01 0.99
    PLOT HERPPF(P,0.5,0.5) FOR P = 0 0,01 0.99
    PLOT HERPPF(P,2,2) FOR P = 0 0.01 0.99
    END OF MULTIPLOT
 
-----HEXAGON-------------------------------------------------------
 
HEXAGON
 
Name:
    HEXAGON
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Draws a hexagon.
 
Description:
    The 2 pairs of coordinates define the (x,y) values for a vertex and
    the diametrically opposite vertex (respectively) of the hexagon.
 
Syntax:
    HEXAGON   <x1>   <y1>   <x2>   <y2>
    where <x1> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for one vertex of the
               hexagon;
          <y1> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for one vertex of the
               hexagon;
          <x2> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for the diametrically
               opposite vertex of the hexagon;
    and   <y2> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for the diametrically
               opposite vertex of the hexagon.
 
Examples:
    HEXAGON 50 50 60 60
    HEXAGON 50 50 60 50
    HEXAGON 30 70 40 70
 
Note:
    The line style (i.e., solid, dash), color, and thickness are
    controlled by the LINE, LINE COLOR, and LINE THICKNESS commands.
    The REGION FILL command can be used to generate solid filled
    hexagons (hexagons can not currently be filled with hatch
    patterns).
 
Note:
    The keywords DATA and RELATIVE were added to the TRIANGLE
    command 7/1997.  These keywords are independent and can
    be used separately or together.  For example, 
    TRIANGLE DATA, TRIANGLE RELATIVE, or TRIANGLE DATA RELATIVE.
    The word DATA should come before the word RELATIVE if both
    appear.

    DATA means that the coordinates are specified in terms of
    the data units of the most recent plot rather than Dataplot
    0 to 100 screen units.

    RELATIVE means that the coordinates of the first point
    are drawn in absolute coordinates an all subsequent points
    in the figure are relative to that first point.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    POINT            = Draws a point.
    ARROW            = Draws an arrow.
    TRIANGLE         = Draws a triangle.
    BOX              = Draws a box.
    HEXAGON          = Draws a hexagon.
    CIRCLE           = Draws a circle.
    SEMI-CIRCLE      = Draws a semi-circle.
    ARC              = Draws an arc.
    ELLIPSE          = Draws an ellipse.
    OVAL             = Draws an oval.
    DIAMOND          = Draws a diamond.
    DRAW             = Draws a line.
    MOVE             = Moves to a point.
    LINES            = Sets the line type for figures and plot lines.
    LINE THICKNESSES = Sets the line thickness for figures and  plot
                       lines.
    LINE COLOR       = Sets the line colors for figures and plot lines.
    CROSS-HAIR       = Activates and reads the cross-hair.
    TEXT             = Writes a text string.
 
Applications:
    Presentation Graphis
 
Implementation Date:
    Pre-1987
 
Program:
    HEXAGON 10 10 20 20
    HEXAGON 60 10 80 30
    .
    THICKNESS 0.7
    HEXAGON 10 30 20 40
    THICKNESS 0.3
    .
    LINE DASH
    HEXAGON 10 50 20 60
    LINE SOLID
    .
    LINE COLOR G50
    HEXAGON 10 80 20 90
    LINE COLOR BLACK
    .
    THICKNESS 0.1
    REGION FILL ON
    HEXAGON 30 30 35 35
    REGION FILL COLOR G50
    HEXAGON 40 40 60 60
 
-----HFCCDF (LET)--------------------------------
 
HFCCDF
 
Name:
    HFCCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard half-Cauchy cumulative distribution
    function.
 
Description:
    The standard half-Cauchy distribution has the following
    cumulative distribution function:
       F(x) = 2*CAUCDF(x) - 1      x >= 0
    where CAUCDF is the cumulative distribution function of
    the Cauchy distribution.
 
Syntax:
    LET <y> = HFCCDF(<x>)      <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed half-Cauchy cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = HFCCDF(3)
    LET X2 = HFCCDF(X1)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    HCAPDF = Compute the half Cauchy probability density
             function.
    HCAPPF = Compute the half Cauchy percent point function.
    FNRPDF = Compute the half-Cauchy probability density
             function.
    FCAPDF = Compute the folded Cauchy probability density
             function.
    CAUPDF = Compute the Cauchy probability density function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994, (page 328).
 
Applications:
    Data Analysis
 
Implementation Date:
    1995/10
 
Program:
    TITLE AUTOMATIC
    PLOT HFCCDF(X)  FOR X = 0  0.01  10

-----HFCPDF (LET)--------------------------------
 
HFCPDF
 
Name:
    HFCPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard half-Cauchy probability density
    function.
 
Description:
    The standard half-Cauchy distribution has the following
    probability density function:
       f(x) = 2/[PI*(1 + x**2)]    x >= 0
 
Syntax:
    LET <y> = HFCPDF(<x>)      <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed half-Cauchy pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = HFCPDF(3)
    LET X2 = HFCPDF(X1)
 
Note:
    The general half-Cauchy distribution has the following
    probability density function:
       f(x,t,s) = 2*(1/s)/[PI*(1 + ((x-t)s)**2)]    x >= t
    where t is a location parameter and s is a scale parameter.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    HCACDF = Compute the half Cauchy cumulative distribution
             function.
    HCAPPF = Compute the half Cauchy percent point function.
    FNRPDF = Compute the half-Cauchy probability density
             function.
    FCAPDF = Compute the folded Cauchy probability density
             function.
    CAUPDF = Compute the Cauchy probability density function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994, (page 328).
 
Applications:
    Data Analysis
 
Implementation Date:
    1995/10
 
Program:
    TITLE AUTOMATIC
    PLOT HFCPDF(X)  FOR X = 0  0.01  10

-----HFCPPF (LET)--------------------------------
 
HFCPPF
 
Name:
    HFCPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard half-Cauchy percent point function.
 
Description:
    The standard half-Cauchy distribution has the following
    percent point function:
       G(p) = CAUPPF((1+p)/2)    0 <= p < 1
    where CAUPPF is the percent point function of the Cauchy
    distribution.
 
Syntax:
    LET <y> = HFCPPF(<p>)      <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <p> is)
               where the computed half-Cauchy pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = HFCPPF(0.99)
    LET X2 = HFCPPF(P)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    HCACDF = Compute the half Cauchy cumulative distribution
             function.
    HCAPDF = Compute the half Cauchy probability density function.
    FNRPDF = Compute the half-Cauchy probability density
             function.
    FCAPDF = Compute the folded Cauchy probability density
             function.
    CAUPDF = Compute the Cauchy probability density function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994, (page 328).
 
Applications:
    Data Analysis
 
Implementation Date:
    1995/10
 
Program:
    TITLE AUTOMATIC
    PLOT HFCPPF(P)  FOR P = 0  0.01  0.99

-----HFLCDF (LET)--------------------------------
 
HFLCDF
 
Name:
    HFLCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard half-logistic cumulative distribution
    function.
 
Description:
    The standard half-logistic distribution has the following
    cumulative distribution function:
       F(x) = [1 - EXP(-x)]/[1 + EXP(-x)]     x >= 0
    The generalized version of this distribution has the
    cumulative distribution function:
       F(x,k) = [1 - (1 - k*x**(1/k))]/[1 + (1 - k*x**(1/k))]
                0 <= x <= 1/k; k > 0

    The half-logistic distribution is formed by folding the
    standard logistic distribution (that is, the distribution of
    ABS(x) where x has a logistic distribution).
 
Syntax:
    LET <y> = HFLCDF(<x>,<k>)      <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed half-logistic cdf value is stored;
          <k> is an optional number, parameter, or variable that
               specifies the shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If the <k> parameter is omitted, the half-logistic cdf is
    computed.  If <k> is given, the generalized half-logistic
    cdf is computed.

Examples:
    LET A = HFLCDF(3)
    LET A = HFLCDF(0.8,0.4)
    LET X2 = HFLCDF(X1)
    LET X2 = HFLCDF(X1,K)
 
Note:
    Dataplot limits the value of the shape parameter to values
    less than or equal to 10.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    HFLPDF = Compute the half-logistic  probability density
             function.
    HFLPPF = Compute the half-logistic percent point function.
    HCAPDF = Compute the half-Cauchy probability density function.
    FCAPDF = Compute the half-Cauchy probability density
             function.
    FNRPDF = Compute the folded normal probability density
             function.
    LOGPDF = Compute the logistic probability density function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 2", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994,
    (page 150-151).
 
Applications:
    Data Analysis
 
Implementation Date:
    1995/10
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    X1LABEL HALF-LOGISTIC DISTRIBUTION
    PLOT HFLCDF(X)  FOR X = 0  0.01  5
    LET K = 0.5
    X1LABEL HALF-LOGISTIC DISTRIBUTION: K = ^K
    LET UL = 1/K
    PLOT HFLCDF(X,K) FOR X = 0  0.01  UL
    LET K = 1
    X1LABEL HALF-LOGISTIC DISTRIBUTION: K = ^K
    LET UL = 1/K
    PLOT HFLCDF(X,K) FOR X = 0  0.01  UL
    LET K = 2
    X1LABEL HALF-LOGISTIC DISTRIBUTION: K = ^K
    LET UL = 1/K
    PLOT HFLCDF(X,K) FOR X = 0  0.01  UL

-----HFLPDF (LET)--------------------------------
 
HFLPDF
 
Name:
    HFLPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard half-logistic probability density
    function.
 
Description:
    The standard half-logistic distribution has the following
    probability density function:
       f(x) = 2*EXP(-x)/[(1+EXP(-x))**2]      x >= 0
    The generalized version of this distribution has the
    probability density function:
       f(x,k) = 2*(1 - k*x**((1/k)-1))/[(1+(1-k*x**(1/k)))**2]
                0 <= x <= 1/k; k > 0

    The half-logistic distribution is formed by folding the
    standard logistic distribution (that is, the distribution of
    ABS(x) where x has a logistic distribution).
 
Syntax:
    LET <y> = HFLPDF(<x>,<k>)      <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed half-logistic pdf value is stored;
          <k> is an optional number, parameter, or variable that
               specifies the shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If the <k> parameter is omitted, the half-logistic pdf is
    computed.  If <k> is given, the generalized half-logistic
    pdf is computed.

Examples:
    LET A = HFLPDF(3)
    LET A = HFLPDF(0.8,0.4)
    LET X2 = HFLPDF(X1)
    LET X2 = HFLPDF(X1,K)
 
Note:
    Dataplot limits the value of the shape parameter to values
    less than or equal to 10.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    HFLCDF = Compute the half-logistic cumulative distribution
             function.
    HFLPPF = Compute the half-logistic percent point function.
    HCAPDF = Compute the half-Cauchy probability density function.
    FCAPDF = Compute the half-Cauchy probability density
             function.
    FNRPDF = Compute the folded normal probability density
             function.
    LOGPDF = Compute the logistic probability density function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 2", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994,
    (page 150-151).
 
Applications:
    Data Analysis
 
Implementation Date:
    1995/10
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    X1LABEL HALF-LOGISTIC DISTRIBUTION
    PLOT HFLPDF(X)  FOR X = 0  0.01  5
    LET K = 0.5
    X1LABEL HALF-LOGISTIC DISTRIBUTION: K = ^K
    LET UL = 1/K
    PLOT HFLPDF(X,K) FOR X = 0  0.01  UL
    LET K = 1
    X1LABEL HALF-LOGISTIC DISTRIBUTION: K = ^K
    LET UL = 1/K
    PLOT HFLPDF(X,K) FOR X = 0  0.01  UL
    LET K = 2
    X1LABEL HALF-LOGISTIC DISTRIBUTION: K = ^K
    LET UL = 1/K
    PLOT HFLPDF(X,K) FOR X = 0  0.01  UL

-----HFLPPF (LET)--------------------------------
 
HFLPPF
 
Name:
    HFLPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard half-logistic or generalized
    half-logistic percent point function.
 
Description:
    The standard half-logistic distribution is computed numerically
    using a bisection method.
 
    The half-logistic distribution is formed by folding the
    standard logistic distribution (that is, the distribution of
    ABS(x) where x has a logistic distribution).

Syntax:
    LET <y> = HFLPPF(<p>,<k>)      <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <p> is)
               where the computed half-logistic ppf value is stored;
          <k> is an optional number, parameter, or variable that
               specifies the shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If the <k> parameter is omitted, the half-logistic ppf is
    computed.  If <k> is given, the generalized half-logistic
    ppf is computed.

Examples:
    LET A = HFLPPF(0.95)
    LET A = HFLPPF(0.9,0.4)
    LET X2 = HFLPPF(P)
    LET X2 = HFLPPF(P,K)
 
Note:
    Dataplot limits the value of the shape parameter to values
    less than or equal to 10.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    HFLCDF = Compute the half-logistic cumulative distribution
             function.
    HFLPDF = Compute the half-logistic probability density function.
    HCAPDF = Compute the half-Cauchy probability density function.
    FCAPDF = Compute the half-Cauchy probability density
             function.
    FNRPDF = Compute the folded normal probability density
             function.
    LOGPDF = Compute the logistic probability density function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 2", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994,
    (page 150-151).
 
Applications:
    Data Analysis
 
Implementation Date:
    1995/10
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    X1LABEL HALF-LOGISTIC DISTRIBUTION
    PLOT HFLPPF(P)  FOR P = 0  0.01  0.99
    LET K = 0.5
    X1LABEL HALF-LOGISTIC DISTRIBUTION: K = ^K
    PLOT HFLPPF(P,K) FOR P = 0  0.01  0.99
    LET K = 1
    X1LABEL HALF-LOGISTIC DISTRIBUTION: K = ^K
    PLOT HFLPPF(P,K) FOR P = 0  0.01  0.99
    LET K = 2
    X1LABEL HALF-LOGISTIC DISTRIBUTION: K = ^K
    PLOT HFLPPF(P,K) FOR P = 0  0.01  0.99

-----HFNCDF (LET)--------------------------------
 
HFNCDF
 
Name:
    HFNCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard half-normal (i.e, mean=sqrt(2/PI), sd=1)
    cumulative distribution function.
 
Description:
    The standard half-normal distribution has the following
    probability density function:
       f(x)=(2/sqrt(2*PI))*exp(-x**2/2)      for x >= 0
    The cumulative distribution is the area from negative infinity to x
    (i.e., the integral of the above function).  The cdf of the
    half-normal distribution is calculated as 2*NORCDF(x) - 1 where
    NORCDF is standard normal cumulative distribution function.
 
Syntax:
    LET <y2> = HFNCDF(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a non-negative variable, a number, or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed half-normal cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = HFNCDF(3)
    LET X2 = HFNCDF(X1)
 
Note:
    The half-normal distribution is the distribution of the variable
    X=ABS(Z) where Z is a normally distributed variable.
 
Note:
    The general form of the half-normal distribution has the
    probability density function:
       f(x)=(2/(sqrt(2*PI)*sigma)*exp(-(x-u)/sigma)**2/2)   for x >= u
    where u is a location parameter and sigma is a scale parameter.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    HFNPDF = Compute the half-normal probability density function.
    HFNPPF = Compute the half-normal percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    LGNCDF = Compute the lognormal cumulative distribution function.
    LGNPDF = Compute the lognormal probability density function.
    LGNPPF = Compute the lognormal percent point function.
 
Reference:
    "Use of Half-Normal Plots in Interpreting Factorial Two-Level
    Experiments", Daniel, Technometrics, 1 (pp. 311-341).
 
    "Continuous Univariate Distributions - 1", Johnson and Kotz,
    Houghton Mifflin, 1970 (chapter 13).
 
Applications:
    XX
 
Implementation Date:
    94/4
 
Program:
    YLIMITS 0 1
    MAJOR YTIC NUMBER 6
    MINOR YTIC NUMBER 1
    YTIC DECIMAL 1
    XLIMITS 0 3
    XTIC OFFSET 0.2 0.6
    TITLE AUTOMATIC
    PLOT HFNCDF(X) FOR X = 0 0.01 3.5
 
-----HFNPDF (LET)--------------------------------
 
HFNPDF
 
Name:
    HFNPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard half-normal (i.e, mean=sqrt(2/PI), sd=1)
    probability density function.
 
Description:
    The standard half-normal distribution has the following
    probability density function:
       f(x)=(2/sqrt(2*PI))*exp(-x**2/2)      for x >= 0
 
Syntax:
    LET <y2> = HFNPDF(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a non-negative variable, a number, or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed half-normal pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = HFNPDF(3)
    LET X2 = HFNPDF(X1)
 
Note:
    The half-normal distribution is the distribution of the variable
    X=ABS(Z) where Z is a normally distributed variable.
 
Note:
    The general form of the half-normal distribution has the
    probability density function:
       f(x)=(2/(sqrt(2*PI)*sigma)*exp(-(x-u)/sigma)**2/2)   for x >= u
    where u is a location parameter and sigma is a scale parameter.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    HFNCDF = Compute the half-normal cumulative distribution function.
    HFNPPF = Compute the half-normal percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    LGNCDF = Compute the lognormal cumulative distribution function.
    LGNPDF = Compute the lognormal probability density function.
    LGNPPF = Compute the lognormal percent point function.
 
Reference:
    "Use of Half-Normal Plots in Interpreting Factorial Two-Level
    Experiments", Daniel, Technometrics, 1 (pp. 311-341).
 
    "Continuous Univariate Distributions - 1", Johnson and Kotz,
    Houghton Mifflin, 1970 (chapter 13).
 
Applications:
    XX
 
Implementation Date:
    94/4
 
Program:
    XLIMITS 0 3
    XTIC OFFSET 0.2 0.6
    TITLE AUTOMATIC
    PLOT HFNPDF(X) FOR X = 0 0.01 3.5
 
-----HFNPPF (LET)--------------------------------
 
HFNPPF
 
Name:
    HFNPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the half-normal (i.e, mean=sqrt(2/PI), sd=1) percent point
    function.
 
Description:
    The standard half-normal distribution has the following
    probability density function:
       f(x)=(2/sqrt(2*PI))*exp(-x**2/2)      for x >= 0
    The percent point function is the inverse of the cumulative
    distribution function.  The cumulative distribution sums the
    probability from 0 to the given x value (i.e., the integral of the
    above function).  The percent point function takes a cumulative
    probability value and computes the corresponding x value.  The
    formula for the half-normal percent point function is:
       G(p) = NORPPF((p+1)/2)
    where NORPPF is the percent point function of the standard normal
    distribution.
 
    The input value is a real number between 0 and 1 (since it
    corresponds to a probability).
 
Syntax:
    LET <y2> = HFNPPF(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter in the range 0 to 1;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed half-normal ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = HFNPPF(0.9)
    LET X2 = HFNPPF(X1)
 
Note:
    The half-normal distribution is the distribution of the variable
    X=ABS(Z) where Z is a normally distributed variable.
 
Note:
    The general form of the half-normal distribution has the
    probability density function:
       f(x)=(2/(sqrt(2*PI)*sigma)*exp(-(x-u)/sigma)**2/2)   for x >= u
    where u is a location parameter and sigma is a scale parameter.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    HFNCDF = Compute the half-normal cumulative distribution function.
    HFNPPF = Compute the half-normal percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    LGNCDF = Compute the lognormal cumulative distribution function.
    LGNPDF = Compute the lognormal probability density function.
    LGNPPF = Compute the lognormal percent point function.
 
Reference:
    "Use of Half-Normal Plots in Interpreting Factorial Two-Level
    Experiments", Daniel, Technometrics, 1 (pp. 311-341).
 
    "Continuous Univariate Distributions - 1", Johnson and Kotz,
    Houghton Mifflin, 1970 (chapter 13).
 
Applications:
    XX
 
Implementation Date:
    94/4
 
Program:
    XLIMITS 0 1
    MAJOR XTIC NUMBER 6
    MINOR XTIC NUMBER 1
    XTIC DECIMAL 1
    TITLE AUTOMATIC
    PLOT HFNPPF(X) FOR X = 0.01 .01 0.99
 
-----HINGE PLOT---------------------------------------------------
 
HINGE PLOT
 
Name:
    HINGE PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a lower or upper hinge plot.
 
Description:
    The lower hinge is a pseudo lower quartile and the upper hinge is a
    pseudo upper hinge.  A hinge plot is a plot consisting of subsample
    hinges versus subsample index.  The subsample hinge is the hinge of
    the data in the subsample.  The hinge plot is used to answer the
    question--"Does the subsample spread change over different
    subsamples?"  It consist of:
       Vertical   axis = subsample hinge;
       Horizontal axis = subsample index.
    The HINGE PLOT yields 2 traces:
       1. a subsample hinge trace; and
       2. a full-sample hinge reference line.
    Like usual, the appearance of these 2 traces is controlled by
    the first 2 settings of the LINES, CHARACTERS, SPIKES, BARS,
    and similar attributes.
 
Syntax:
    <LOWER/UPPER> HINGE PLOT <y> <x> <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response (= dependent) variable;
          <x> is the subsample identifier variable (this variable
              appears on the horizontal axis);
          LOWER specifies a lower hinge plot and UPPER specifies an
              upper hinge plot;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LOWER HINGE PLOT Y X
    UPPER HINGE PLOT Y X1
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHARACTERS         = Sets the type for plot characters.
    LINES              = Sets the type for plot lines.
    MEAN   PLOT        = Generates a mean plot.
    SD   PLOT          = Generates a standard deviation plot.
    BOX PLOT           = Generates a box plot.
    XBAR CHART         = Generates a xbar control chart.
    PLOT               = Generates a data or function plot.
 
Applications:
    Exploratory Data Analysis
 
Implementation Date:
    88/2
 
Program:
    LET Y = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET NU = 20
    LET Y = T RANDOM NUMBERS FOR I = 101 1 200
    LET NU = 5
    LET Y = CHI-SQUARE RANDOM NUMBERS FOR I = 201 1 300
    LET X = 1 FOR I = 1 1 100
    LET X = 2 FOR I = 101 1 200
    LET X = 3 FOR I = 201 1 300
    .
    TITLE DEMONSTRATE HINGE PLOT
    XTIC OFFSET 0.2 0.2
    XLIMITS 1 3
    MAJOR XTIC MARK NUMBER 3
    MINOR XTIC MARK NUMBER 0
    XTIC MARK LABEL FORMAT ALPHA
    XTIC MARK LABEL CONTENT NORMAL T CHI_SQUARE
    YLIMITS 0 7
    YTIC OFFSET 1 0
    MINOR YTIC MARK NUMBER 0
    CHARACTER U U
    LINE BLANK SOLID
    UPPER HINGE PLOT Y X
    PRE-ERASE OFF
    CHARACTER L L
    LOWER HINGE PLOT Y X

-----HISTOGRAM-------------------------------------------------------
 
HISTOGRAM
 
Name:
    ... HISTOGRAM
 
Type:
    Graphics Command
 
Purpose:
    Generates a histogram.
 
Description:
    A histogram is a graphical data analysis technique for summarizing
    the distributional information of a variable.  The response
    variable is divided into equal sized intervals (or bins).  The
    number of occurrences of the response variable is calculated for
    each bin.  The histogram consists of:

      Vertical   axis = frequencies or relative frequencies;
      Horizontal axis = response variable (i.e., the mid-point of each
                        interval).

    There are 4 types of histograms:

          1) histogram (absolute counts);
          2) relative histogram (converts counts to proportions);
          3) cumulative histogram;
          4) cumulative relative histogram.

    The histogram and the frequency plot have the same information
    except the histogram has bars at the frequency values, whereas the
    frequency plot has lines connecting the frequency values.
 
Syntax 1:
    <type>  <x>                  <SUBSET/EXCEPT/FOR qualification>
    where <type> is one of HISTOGRAM, RELATIVE HISTOGRAM,
              CUMULATIVE HISTOGRAM, or CUMULATIVE RELATIVE HISTOGRAM;
          <x> is a variable of raw data values;
    and where the <SUBSET/EXCEPT/FOR qualification is optional.
 
    This syntax is used when you have raw data.  Note that <x> can
    be either a variable or a matrix.  If <x> is a matrix, then
    a histogram will be generated for all values in that matrix.
 
Syntax 2:
    <type>  <y>  <x>              <SUBSET/EXCEPT/FOR qualification>
    where <type> is one of HISTOGRAM, RELATIVE HISTOGRAM,
              CUMULATIVE HISTOGRAM, or CUMULATIVE RELATIVE HISTOGRAM;
          <y> is a variable containing pre-computed frequencies;
          <x> is a variable containing the bin mid-points;
    and where the <SUBSET/EXCEPT/FOR qualification is optional.
 
    This syntax is used when you have grouped data with equi-sized
    bins.
 
Syntax 3:
    <type>  <y>  <xlow>  <xhigh>     <SUBSET/EXCEPT/FOR qualification>
    where <type> is one of HISTOGRAM, RELATIVE HISTOGRAM,
              CUMULATIVE HISTOGRAM, or CUMULATIVE RELATIVE HISTOGRAM;
          <y> is a variable containing pre-computed frequencies;
          <xlow> is a variable containing the lower limits for the bins;
          <xhigh> is a variable containing the upper limits for the bins;
    and where the <SUBSET/EXCEPT/FOR qualification is optional.
 
    This syntax is used when you have grouped data with unequal sized
    bins.
 
Syntax 4:
    SUBSET  <type>  <y>  <x>           <SUBSET/EXCEPT/FOR qualification>
    where <type> is one of HISTOGRAM, RELATIVE HISTOGRAM,
              CUMULATIVE HISTOGRAM, or CUMULATIVE RELATIVE HISTOGRAM;
          <y> is a variable of raw data values;
          <x> is a group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification is optional.
 
    This syntax can be used to highlight the contribution to the
    histogram for particular subsets of the data.  It is demonstrated
    in the program examples below.
 
Examples:
    HISTOGRAM TEMP
    RELATIVE HISTOGRAM TEMP
    CUMULATIVE HISTOGRAM TEMP
    CUMULATIVE RELATIVE HISTOGRAM TEMP
    HISTOGRAM COUNTS STATE
    RELATIVE HISTOGRAM COUNTS STATE
    CUMULATIVE HISTOGRAM COUNTS STATE
    CUMULATIVE RELATIVE HISTOGRAM COUNTS STATE
 
Note:
    There are two methods for relative histograms.

    The first method simply divides the count in the bin by the total
    count.  That is, the relative frequency of the i-th bin is
    n(i)/SUM[n(i)] where n(i) is the count of the i-th bin.  In this
    case, the sum of the relative frequencies is one.  To specify this
    method, enter the command

        SET RELATIVE HISTOGRAM PERCENT

    The second method normalizes the counts so that the area sums
    to one.  That is, the relative frequency of the i-th bin is
    n(i)/SUM[n(i)*c(i)] where c(i) is the width of the i-th bin.  To
    specify this method, enter the command

        SET RELATIVE HISTOGRAM AREA

    The advantage of the AREA method is that it makes the relative
    histogram an estimator of the underlying probability distribution.
    The histogram in this case is actually a simple kernel density
    estimator of the underlying distribution of the data.  This is
    not the case when the PERCENT option is used.

    The default is AREA.

Note:
    The appearance of the bars on the histogram (i.e., whether they are
    filled or not, the line width of the bar border, etc.) are
    controlled by the various bar attribute commands.  A few are listed
    in the RELATED COMMANDS section below.  See the documentation for
    the BAR command for a complete list of the bar attribute commands.
    This is demonstrated with the sample program below.
 
Note:
    You can extract a frequency table from the histogram with the
    following commands:

       HISTOGRAM Y
       LET YFREQ = YPLOT
       LET XVAL = XPLOT

    Then the variables YFREQ and XVAL contain a frequency table.  You
    can also use the

       LET Y2 X2 = BINNED Y

    command for this purpose.
 
Note:
    By default, DATAPLOT uses a class width of 0.3 X the standard
    deviation of the variable.  Use the CLASS WIDTH command to override
    this default.  DATAPLOT also tends to generate a large number of
    zero frequency classes at the lower and upper tails.  This tends to
    compress the histogram on the horizontal axis.  Use the XLIMITS
    command or the CLASS LOWER and CLASS UPPER commands to avoid
    plotting these zero frequency classes.
 
    A number of alternative choices for class width can be set
    with the command

        HISTOGRAM CLASS WIDTH

    Enter HELP HISTOGRAM CLASS WIDTH for details.

Note:
    By default, Dataplot sets the lower and upper class limits to
    xbar -/+ 6*s (with xbar and s denoting the sample mean and
    standard deviation, respectively).  This can occassionally result
    in a few outlying points being excluded from the histogram.  To
    adjust the lower and upper class limits so that these outlying
    points are included, enter the command

        SET HISTOGRAM OUTLIERS ON

    To revert to the default, enter

       SET HISTOGRAM OUTLIERS OFF

Note:
    By default, the histogram draws all cells, even those with zero
    frequency.  To suppress these zero frequency cells, enter

        SET HISTOGRAM EMPTY BINS OFF

    To restore the default, enter

        SET HISTOGRAM EMPTY BINS ON

Note:
    Previously, Dataplot only generated histograms for the case where
    the bin widths were equal.  This has been extended to the case with
    unequal bin widths.  The syntax is

        HISTOGRAM Y XLOW XHIGH

    with XLOW containing the values for the lower bin limit and XHIGH
    containing the values for the upper bin limit.

Note:
    Added the following option

        SUBSET HISTOGRAM Y X

    In this case, X is a group-id variable.  This syntax can be used
    to highlight the contribution to the histogram for particular
    subsets of the data.

Note:
    When dealing with pathological data sets (e.g., Cauchy distributed
    data), there is an issue with generating a class size that is
    appropriate for central bulk of the data while still being able
    to generate the histogram in an efficient fashion.  The following
    commands provide some methods for addressing this.

    When you have data where there are a small percentage of points
    that are quite far from the bulk of the data, you might want to
    use the command (this already existed, enter HELP HISTOGRAM CLASS
    WIDTH for details).

         SET HISTOGRAM CLASS WIDTH IQ RANGE

    This bases the bin width for the histogram on the interquartile
    range rather than the standard deviation as the other class width
    algorithms do.  This can result in more reasonable class widths
    for the center of the data when there are extreme outliers in the
    data.  Also, these commands are typically used when the

         SET HISTOGRAM OUTLIERS ON

    command is also given (this command extends the bins to cover all
    outliers).

       1) The following command can be used to specify the maximum
          number of classes for the histogram.

              SET HISTOGRAM MAXIMUM CLASSES <value>

          If this command is entered, then the class width is initially
          computed in the standard way.  If the number of bins needed to
          cover the outliers is greater than the value given here, then
          the class width is recomputed so that the number of bins is
          equal to the value given here.

       2) The following command can be used to specify that outliers be
          drawn as individual points rather than extending the bins to
          cover them.

              SET HISTOGRAM OUTLIER POINTS ON

          To turn this option off, enter

              SET HISTOGRAM OUTLIER POINTS OFF

Default:
    None
 
Synonyms:
    A synonym for CUMULATIVE RELATIVE HISTOGRAM is RELATIVE CUMULATIVE
    HISTOGRAM.  HIGHLIGHT is a synonym for SUBSET in syntax 4.
 
Related Commands:
    FREQUENCY PLOT        = Generate a frequency plot.
    KERNEL DENSITY PLOT   = Generate a kernel density plot.
    PERCENT POINT PLOT    = Generate a percent point plot.
    PROBABILITY PLOT      = Generate a probability plot.
    PPCC PLOT             = Generates probability plot correlation
                            coefficient plot.
    PLOT                  = Generate a data or function plot.
    CLASS LOWER           = Set the lower class minimum for histograms,
                            frequency plots, and pie charts.
    CLASS UPPER           = Set the upper class maximum for histograms,
                            frequency plots, and pie charts.
    CLASS WIDTH           = Set the class width for histograms, frequency
                            plots, and pie charts.
    HISTOGRAM CLASS WIDTH = Specify alternative default class wdith
                            algorithms for histograms.
    MINIMUM               = Set the frame minima for all plots.
    MAXIMUM               = Set the frame maxima for all plots.
    LIMITS                = Set the frame limits for all plots.
    BARS                  = Set the on/off switches for plot bars.
    BAR WIDTH             = Set the widths for plot bars.
    BAR FILL              = Set the on/off switches for plot bar fills.
    BAR PATTERN           = Set the types for bar fill patterns.
    BAR BORDER LINE       = Set the types for bar border lines.
 
Reference:
    NIST/SEMATECH e-Handbook of Statistical Methods,
    http://www.itl.nist.gov/div898/handbook/eda/section3/histogra.htm,
    6/2003.
 
    David Scott (1992), "Multivariate Density Estimation",
    John Wiley, (chapter 3).  This book discusses histograms as "density
    estimators" and gives optimal criterion for  selecting the class
    width.
 
Applications:
    Data Analysis
 
Implementation Date:
    Pre-1987
    2004/09: Support alternative class width algorithms 
    2007/03: Option to compute histogram of a matrix
    2010/01: Support for HIGHLIGHT/SUBSET option
    2010/01: Support for non-equispaced histograms
    2010/01: Option to suppress empty bins
    2010/01: Option to include outliers
    2016/06: Support for SET HISTOGRAM MAXIMUM CLASSES
    2016/06: Support for SET HISTOGRAM OUTLIER POINTS
 
Program 1:
    LET Y = NORMAL RANDOM NUMBERS FOR I = 1 1 1000
    MULTIPLOT 2 2
    MULTIPLOT SCALE FACTOR 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    XLIMITS -5 5
    TITLE CASE ASIS
    TITLE OFFSET 2
    TITLE Counts Histogram
    HISTOGRAM Y
    BAR FILL ON
    TITLE Relative Histogram
    RELATIVE HISTOGRAM Y
    BAR FILL OFF
    BAR BORDER THICKNESS 0.3
    TITLE Cumulative Counts Histogram
    CUMULATIVE HISTOGRAM Y
    BAR FILL ON
    BAR PATTERN D1
    BAR PATTERN SPACING 3
    TITLE Cumulative Relative Histogram
    CUMULATIVE RELATIVE HISTOGRAM Y
    END OF MULTIPLOT

Program 2:
    skip 25
    read rehm.dat y1 y2 x1 x2
    .
    bar on on on
    bar fill on on on
    bar fill color lblue red
    line blank blank
    xlimits 350 650
    multiplot 2 2
    multiplot corner coordinates 5 5 95 95
    multiplot scale factor 2
    let tag = x2
    let tag = 1 subset x2 = 1
    let tag = 2 subset x2 <> 1
    title Red = Patient 1
    highlighted hist y1 tag
    let tag = 1 subset x2 = 2
    let tag = 2 subset x2 <> 2
    title Red = Patient 2
    highlighted hist y1 tag
    let tag = 1 subset x2 = 3
    let tag = 2 subset x2 <> 3
    title Red = Patient 3
    highlighted hist y1 tag
    bar fill color lblu blue red
    title Red = Patient 1, Blue = Patient 2
    highlighted hist y1 x2
    end of multiplot
    .
    xlimits
    move 50 97
    just center
    case asis
    text Highlighted Histograms for REHM.DAT (Y1 = High Air Flow and X2 = Patient ID)

-----HISTOGRAM CLASS WIDTH (SET)-----------------------------------
 
HISTOGRAM CLASS WIDTH
 
Name:
    HISTOGRAM CLASS WIDTH (SET)
 
Type:
    Set Command
 
Purpose:
    Specifies the default class width algorithm to use in
    subsequent histogram and average shifted histograms.

Description:
    One use for the histogram is to suggest an appropriate
    distributional model for a data set.  However, the optimal
    class width (optimal in this sense is defined as the integrated
    mean square error between the histogram and an overlaid
    probability density function for the given distribution) for
    a histogram depends on what the underlying distribution of
    the data is.  For this reason, there is no one single
    algorithm that will generate an optimal class width for a
    histogram.

    A number of researchers, David Scott in particular, have
    investigated the issue of optimal class widths for histograms.
    This command allows you to select among several different
    default algorithms for the class width of the histogram.

    The available choices are:

        DEFAULT  - uses the Dataplot default of 0.3 times the
                   sample standard deviation
        NORMAL   - David Scott's optimal class width for the
                   case when the data are in fact normal.  The
                   class width is

                     3.5*s/(n**(1/3))

                   where s and n are the sample standard deviation
                   and sample size, respectively.
        NORMAL CORRECTED - David Scott's recommendation for
                   adjusting the "NORMAL" class width to account
                   for sample skewness and sample kurtosis.  The
                   adjusted formula is

                     3.5*s/(n**(1/3))*SF*KF

                   where SF and KF are the skewness and kurtosis
                   factors, respectively

                      SF = 1/(1 - 0.0060*skew + 0.27*skew**2 -
                           0.0069*skew**3)

                      KF = 1 - 0.2*(1 - EXP(-0.7*kurt))

                   with skew and kurt denoting the sample skewness
                   and sample kurtosis - 3 (the -3 adjusts the
                   kurtosis so that a normal distribution has a
                   kurtosis of 0).

                   The SF factor is only applied if the sample
                   skewness is between 0 and 3.  The KF factor
                   is only applied if the sample kurtosis -3 is
                   between 0 and 6.

        IQ RANGE - David Scott's recommendation for a relatively
                   robust class width algorithm based on the
                   sample interquartile range (robust in this
                   sense means relatively good performance across
                   a wide range of underlying distributions).
                   The class width in this case is

                       2.603*IQ/(n**(1/3))

                   with IQ and n denoting the sample interquartile
                   range and sample size, respectively.

    Note that you can also use the CLASS WIDTH command to set an
    explicit width (a CLASS WIDTH command will override a
    SET HISTOGRAM CLASS WIDTH command).

Syntax:
    SET HISTOGRAM CLASS WIDTH   <type>
    where <type> is one of DEFAULT, NORMAL, NORMAL CORRECTED,
                 or IQ RANGE.
 
Examples:
    SET HISTOGRAM CLASS WIDTH DEFAULT
    SET HISTOGRAM CLASS WIDTH NORMAL
    SET HISTOGRAM CLASS WIDTH IQ RANGE
 
Default:
    The default histogram class width is 0.3 times the sample
    standard deviation.
 
Synonyms:
    None
 
Related Commands:
    CLASS LOWER     = Sets the lower class maximum for histograms,
                      frequency plots, and pie charts.
    CLASS UPPER     = Sets the upper class maximum for histograms,
                      frequency plots, and pie charts.
    CLASS WIDTH     = Sets the class width for histograms,
                      frequency plots, and pie charts.
    HISTOGRAM       = Generate a histogram.
    ASH             = Generate an average shifted histogram.
 
Reference:
    David Scott (1992), "Multivariate Density Estimation", John Wiley.

Applications:
    Distributional Plots
 
Implementation Date:
    2004/9
    2006/3: This command was extended to work with the
            LET ... = BINNED, LET ... = MATRIX BIN,
            NORMAL MIXTURE MAXIMUM LIKELIHOOD, 
            CHI-SQUARE GOODNESS OF FIT, and
            2 SAMPLE CHI-SQUARE GOODNESS OF FIT commands
 
Program 1:
    TITLE OFFSET 2
    YLIMITS 0 0.5
    XLIMITS -5 5
    XTIC OFFSET 2 2
    LET Y = DOUBLE EXPONENTIAL RANDOM NUMBERS FOR I = 1 1 1000
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT 2 2
    TITLE DEFAULT (0.3*S)
    RELATIVE HISTOGRAM Y
    MULTIPLOT 2 2 1
    PLOT DEXPDF(X) FOR X = -5  0.01  5
    SET HISTOGRAM CLASS WIDTH NORMAL
    TITLE NORMAL
    MULTIPLOT 2 2 2
    RELATIVE HISTOGRAM Y
    MULTIPLOT 2 2 2
    PLOT DEXPDF(X) FOR X = -5  0.01  5
    SET HISTOGRAM CLASS WIDTH NORMAL CORRECTED
    TITLE NORMAL CORRECTED
    MULTIPLOT 2 2 3
    RELATIVE HISTOGRAM Y
    MULTIPLOT 2 2 3
    PLOT DEXPDF(X) FOR X = -5  0.01  5
    SET HISTOGRAM CLASS WIDTH IQ RANGE
    TITLE IQ RANGE
    MULTIPLOT 2 2 4
    RELATIVE HISTOGRAM Y
    MULTIPLOT 2 2 4
    PLOT DEXPDF(X) FOR X = -5  0.01  5
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT DIFFERENT HISTOGRAM CLASS WIDTHS - DOUBLE EXPONENTIAL DATA
 
Program 2:
    TITLE OFFSET 2
    YLIMITS 0 1
    XLIMITS 0 4
    XTIC OFFSET 0.2 0
    LET GAMMA = 1.5
    LET Y = WEIBULL RANDOM NUMBERS FOR I = 1 1 100
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT 2 2
    TITLE DEFAULT (0.3*S)
    RELATIVE HISTOGRAM Y
    MULTIPLOT 2 2 1
    PLOT WEIPDF(X,GAMMA) FOR X = 0  0.01  5
    SET HISTOGRAM CLASS WIDTH NORMAL
    TITLE NORMAL
    MULTIPLOT 2 2 2
    RELATIVE HISTOGRAM Y
    MULTIPLOT 2 2 2
    PLOT WEIPDF(X,GAMMA) FOR X = 0  0.01  5
    SET HISTOGRAM CLASS WIDTH NORMAL CORRECTED
    TITLE NORMAL CORRECTED
    MULTIPLOT 2 2 3
    RELATIVE HISTOGRAM Y
    MULTIPLOT 2 2 3
    PLOT WEIPDF(X,GAMMA) FOR X = 0  0.01  5
    SET HISTOGRAM CLASS WIDTH IQ RANGE
    TITLE IQ RANGE
    MULTIPLOT 2 2 4
    RELATIVE HISTOGRAM Y
    MULTIPLOT 2 2 4
    PLOT WEIPDF(X,GAMMA) FOR X = 0  0.01  5
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT DIFFERENT HISTOGRAM CLASS WIDTHS - WEIBULL DATA

-----HODGES LEHMANN (LET)-------------------------------
 
HODGES LEHMANN
 
Name:
    HODGES LEHMANN (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the Hodges-Lehmann location estimate for a variable.
 
Description:
    The mean is the sum of the observations divided by the number of
    observations.  The mean can be heavily influenced by extreme values
    in the tails of a variable.

    Mosteller and Tukey (see Reference section below) define
    two types of robustness:

      1) resistance means that changing a small part, even by a
         large amount, of the data does not cause a large change
         in the estimate

      2) robustness of efficiency means that the statistic has
         high efficiency in a variety of situations rather than
         in any one situation.  Efficiency means that the estimate
         is close to optimal estimate given that we know what
         distribution that the data comes from.  A useful measure
         of efficiency is:

              Efficiency = (lowest variance feasible)/
                           (actual variance)
   
    For location estimaors, the mean is the optimal estimator for
    Gaussian data.  However, it is not resistant and it does not
    have robustness of efficiency.

    The Hodge-Lehmann location estimate is based on ranks.  This
    makes it more resistant, as defined above, than the mean.
    This estimator also has high efficiency for symmetric
    disributions.  It may be less successful with some skewed
    distributions.

    Specifically, the Hodges-Lehmann estimate for location is
    defined as

        muhat = median {(X(i) + X(j))/2,   1 <= i <= j <= n}

    Dataplot uses ACM algorithm 616 (HLQEST written by John
    Monohan) to compute the estimate.  This is a fast, exact
    algoirthm.  One modification is that for n <= 25 Dataplot
    computes the estimate directly from the definition.

Syntax:
    LET <par> = HODGES LEHMANN <y1>  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the response variable;
          <par> is a parameter where the computed Hodges-Lehmann
               location estimate is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = HODGES LEHMANN Y1
    LET A = HODGES LEHMANN Y1 SUBSET TAG > 2
 
Note:
    Support for the Hodges-Lehmann has been added to the
    following plots and commands:

       HODGES LEHMANN PLOT
       CROSS TABULATE HODGES LEHMANN PLOT
       BOOTSTRAP HODGES LEHMANN PLOT
       JACKNIFE HODGES LEHMANN PLOT
       DEX HODGES LEHMANN PLOT
       HODGES LEHMANN INFLUENCE CURVE
       HODGES LEHMANN INTERACTION STATISTIC PLOT

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    MEAN                  = Compute the mean.
    MEDIAN                = Compute the median.
    TRIMMED MEAN          = Compute the trimmed mean.
    WINSORIZED MEAN       = Compute the Winsorized mean.
    RANK CORRELATION      = Compute the rank correlation between
                            two variables.
    STATISTIC PLOT        = Generate a statistic versus group
                            plot for a given statistic.
    CROSS TABULATE PLOT   = Generate a statistic versus group
                            plot for a given statistic and two
                            group variables.
    BOOTSTRAP PLOT        = Generate a bootstrap plot for a
                            given statistic.
    DEX PLOT              = Generate various types of design
                            of experiment plots.
    INFLUENCE CURVE       = Generate an influence curve for a
                            given statistic.
    INTERACTION STAT PLOT = Generate an interaction plot for a
                            given statistic.
 
Reference:
    "Introduction to Robust Estimation and Hypothesis Testing",
    Rand Wilcox, Academic Press, 1997.

    "Algorithm 616: Fast Computation of the Hodges-Lehmann Location
    Estimator", John Monahan, ACM Transactions on Mathematical
    Software, Vol. 10, No. 3, September 1984, pp. 265-270.

Applications:
    Robust Data Analysis
 
Implementation Date:
    2002/7
 
Program 1:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET Y2 = LOGISTIC RANDOM NUMBERS FOR I = 1 1 100
    LET Y3 = CAUCHY RANDOM NUMBERS FOR I = 1 1 100
    LET Y4 = DOUBLE EXPONENTIAL RANDOM NUMBERS FOR I = 1 1 100
    LET A1 = HODGES LEHMANN Y1
    LET A2 = HODGES LEHMANN Y2
    LET A3 = HODGES LEHMANN Y3
    LET A4 = HODGES LEHMANN Y4
 
Program 2:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    MULTIPLOT SCALE FACTOR 2
    X1LABEL DISPLACEMENT 12
    .
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 200
    LET Y2 = CAUCHY RANDOM NUMBERS FOR I = 1 1 200
    .
    BOOTSTRAP SAMPLES 500
    BOOTSTRAP HODGES LEHMANN PLOT Y1
    X1LABEL B025 = ^B025, B975=^B975
    HISTOGRAM YPLOT
    .
    BOOTSTRAP BIWEIGHT MIDVARIANCE PLOT Y1
    X1LABEL B025 = ^B025, B975=^B975
    HISTOGRAM YPLOT
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 46
    TEXT HODGES LEHMANN BOOTSTRAP: CAUCHY
    MOVE 50 96
    TEXT HODGES LEHMANN BOOTSTRAP: NORMAL
 
-----HOME PATH (SET)--------------------------------------------
 
HOME PATH
 
Name:
    HOME PATH (SET)
 
Type:
    Set Subcommand
 
Purpose:
    Specify whether the user's home directory will be included in the
    Dataplot search path for file names.
 
Description:
    When Dataplot encounters a file name (on the LIST, READ, WRITE, or CALL
    commands), it will do the following:

       1. It will first look for the file in the current directory (you
          can enter the PWD command if you are not sure what that is).

       2. If it does not find the file, it will look for the file in
          the Dataplot auxiliary directory.  By default, this will be
          "C:\Program Files (x86)\NIST\DATAPLOT" under Windows systems
          and "/usr/local/lib/dataplot" under Unix/Linux/Mac OS X
          systems.  However, this may be different on your platform.

          Dataplot first searches this directory and then the following
          sub-directories "help", "data", "dex", "macros", "programs",
          "text", "menu", "ps", and "tex" are searched (in the order
          given).

    This command can be used to specify that your home directory will
    also be searched for the file name.  If so, it will be searched after
    the current directory but before the Dataplot auxiliary directories.

    Note that under Unix/Linux/Mac OS X systems, which are case sensitive,
    Datatplot will first try to open the file name as given.  If the file
    is not found, then Dataplot will convert the file name to all upper
    case and try to open the file.  If the file is not found, then Dataplot
    will convert the file name to all lower case and try to open the
    file.  Note that this file name conversion is performed in each
    directory before moving to the next directory.

    To see what your home directory is, enter

        PROBE HOME

Syntax:
    SET HOME PATH <ON/OFF>
    where ON specifies that the user's home directory will be searched
          and OFF specifies that it will not be searched.
 
Examples:
    SET HOME PATH ON
    SET HOME PATH OFF
 
Default:
    OFF
 
Synonyms:
    None
 
Related Commands:
    SET SEARCH DIRECTORY = Specify a directory to be added to Dataplot's
                           search path.
    SET PATH             = Define the location for Dataplot's auxiliary
                           files.
    LIST                 = List the contents of a file.
    READ                 = Read data from a file.
    WRITE                = Write data to a file.
    CALL                 = Execute commands stored in a file.
 
Applications:
    Interactive Usage
 
Implementation Date:
    2019/12
 
Program:
    . Assume "sample.dp" is in your home directory
    .
    SET HOME PATH ON
    CALL sample.dp

-----HOMOSCEDASTICITY PLOT--------------------------------------
 
HOMOSCEDASTICITY PLOT
 
Name:
    HOMOSCEDASTICITY PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a homoscedasticity plot.
 
Description:
    A homoscedasticity plot is a graphical data analysis technique for
    assessing the assumption of constant variance across subsets of the
    data.  The first variable is a response variable and the second
    variable identifies subsets of the data.  The mean and standard
    deviation are calculated for each of these subsets.  The following
    plot is generated:

       Vertical   axis = subset standard deviations;
       Horizontal axis = subset means.

    The interpretation of this plot is that the greater the spread on
    the vertical axis, the less valid is the assumption of constant
    variance.
 
    By default, this command assumes that you have raw data.  In some
    cases, you may only have summary data (i.e., means and standard
    deviations or some other location/scale statistics).  See Syntax 4
    and Syntax 5 for how to use this command with summary data.

    You can also use this command when you have more than one group-id
    variable.

Syntax 1:
    HOMOSCEDASTICITY PLOT  <y>  <x1> ... <xk>
                           <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <x1> ... <xk> is a list of one to six group-id variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    From one to six group-id variables can be specified (most
    commonly there is a single group-id variable).

    Note that with this syntax, all plot points are drawn with the same
    characteristics (i.e., the first setting of the CHARACTER and LINE
    commands and their associated attribute setting commands).

Syntax 2:
    SUBSET HOMOSCEDASTICITY PLOT  <y>  <x1> ... <xk>
                                  <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <x1> ... <xk> is a list of one to six group-id variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    From one to six group-id variables can be specified (most
    commonly there is a single group-id variable).

    Note that with this syntax, the plot points corresponding to each
    subset are drawn with different attributes (i.e., the first subset
    uses the first setting for the CHARACTER and LINE and related
    attribute setting commands, the second subset uses the second
    setting, and so on).  For example, this syntax can be used to label
    the plot points with the lab-id.

    If there is more than one group-id variable, the attribute settings
    work from right to left.  That is, if X1 has 2 levels and X2 has
    2 levels, then

      trace 1  = Level 1 of X1 and Level 1 of X2
      trace 2  = Level 1 of X1 and Level 2 of X2
      trace 3  = Level 2 of X1 and Level 1 of X2
      trace 4  = Level 2 of X1 and Level 1 of X2

Syntax 3:
    MULTIPLE HOMOSCEDASTICITY PLOT  <y1>  ...  <yk>
                                    <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of one to 30 response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    With this syntax, the different subsets are represented with
    different response variables.  As with Syntax 2, each subset is
    drawn with different attributes.

Syntax 4:
    SUMMARY HOMOSCEDASTICITY PLOT  <ymean>  <ysd>  <nrepl>
                                   <SUBSET/EXCEPT/FOR qualification>
    where <ymean> is a variable containing subset means;
          <ysd> is a variable containing subset standard deviations;
          <nrepl> is an optional variable containing the number of
              replications in each subset;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used when you only have summary data.  The
    <ymean> variable contains the means (or some other location
    statistic) and <ysd> contains the standard deviations (or some
    other scale statistic) for the different subsets.
    
    The <nrepl> variable is only used when the CIRCLE TECHNIQUE
    is used to generate lines of "similar homogeneity".  See the
    Note section below for a description of the CIRCLE TECHNQUE.

    As with Syntax 1, all plot points are drawn with the same
    attributes.

Syntax 5:
    SUMMARY SUBSET HOMOSCEDASTICITY PLOT  <ymean>  <ysd>  <nrepl>
                                    <SUBSET/EXCEPT/FOR qualification>
    where <ymean> is a variable containing subset means;
          <ysd> is a variable containing subset standard deviations;
          <nrepl> is an optional variable containing the number of
              replications in each subset;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used when you only have summary data.  The
    <ymean> variable contains the means (or some other location
    statistic) and <ysd> contains the standard deviations (or some
    other scale statistic) for the different subsets.
    
    The <nrepl> variable is only used when the CIRCLE TECHNIQUE
    is used to generate lines of "similar homogeneity".  See the
    Note section below for a description of the CIRCLE TECHNQUE.

    As with Syntax 2, the different subsets are plotted with
    different attributes.

Examples:
    HOMOSCEDASTICITY PLOT Y1 TAG
    HOMOSCEDASTICITY PLOT Y1 TAG  SUBSET TAG > 2
    MULTIPLE HOMOSCEDASTICITY PLOT Y1 Y2 Y3 Y4 Y5
    MULTIPLE HOMOSCEDASTICITY PLOT Y1 TO Y5
    SUBSET HOMOSCEDASTICITY PLOT Y1 TAG
    SUMMARY SUBSET HOMOSCEDASTICITY PLOT YMEAN YSD
    SUBSET HOMOSCEDASTICITY PLOT Y1 X1 X2
 
Note:
    The CHARACTER and LINE commands and their associated attribute
    setting commands can be used to control the appearance of the plot.
    See the program examples below for a demonstration of setting the
    character and line attributes for the various syntaxes described
    above.

Note:
    Although the default form of this command plots the standard
    deviation versus the mean, a number of alternate location and
    scale statistics can be used.

    You can set the location statistic with the commands

        SET HOMOSCEDASTICITY LOCATION MEAN
        SET HOMOSCEDASTICITY LOCATION BIWEIGHT LOCATION
        SET HOMOSCEDASTICITY LOCATION H10
        SET HOMOSCEDASTICITY LOCATION H12
        SET HOMOSCEDASTICITY LOCATION H15
        SET HOMOSCEDASTICITY LOCATION H17
        SET HOMOSCEDASTICITY LOCATION H20
        SET HOMOSCEDASTICITY LOCATION HODGES LEHMAN
        SET HOMOSCEDASTICITY LOCATION LP LOCATION
        SET HOMOSCEDASTICITY LOCATION MEDIAN
        SET HOMOSCEDASTICITY LOCATION MIDMEAN
        SET HOMOSCEDASTICITY LOCATION MIDRANGE
        SET HOMOSCEDASTICITY LOCATION TRIMMED MEAN
        SET HOMOSCEDASTICITY LOCATION WINSORIZED MEAN
 
    You can set the scale statistic with the commands

        SET HOMOSCEDASTICITY SCALE SD (or STANDARD DEVIATION)
        SET HOMOSCEDASTICITY SCALE BIWEIGHT SCALE
        SET HOMOSCEDASTICITY SCALE H10
        SET HOMOSCEDASTICITY SCALE H12
        SET HOMOSCEDASTICITY SCALE H15
        SET HOMOSCEDASTICITY SCALE H17
        SET HOMOSCEDASTICITY SCALE H20
        SET HOMOSCEDASTICITY SCALE AVERAGE ABSOLUTE DEVIATION (or AAD)
        SET HOMOSCEDASTICITY SCALE MEDIAN ABSOLUTE DEVIATION  (or MAD)
        SET HOMOSCEDASTICITY SCALE INTERQUARTILE RANGE        (or IQ)
        SET HOMOSCEDASTICITY SCALE RANGE
        SET HOMOSCEDASTICITY SCALE TRIMMED SD
        SET HOMOSCEDASTICITY SCALE WINSORIZED SD
        SET HOMOSCEDASTICITY SCALE SN
        SET HOMOSCEDASTICITY SCALE QN

Note:
    The ISO 13528 Standard describes a method for generating
    confidence contours for homogeneity.  That is, for a given
    level of alpha, labs outside the confidence contour are not
    homogeneous with the other labs.

    The method used is referred to as the "circle technique".  To
    generate these confidence contours, enter the command

         SET CIRCLE TECHNIQUE ON

    Confidence contours are drawn at alpha = 0.95, 0.99, and 0.999.
    The first three settings of the LINE and CHARACTER commands
    (and related attribute setting commands) are used to generate
    these confidence contours.  The LINE and CHARACTER settings
    for the plot points start with trace 4.

    Dataplot uses the method as given in ISO 13528.  This is a
    slight variation of the method originally given by van Nuland.

    This method is typically applied in the context of proficiency
    testing.  It assumes that there are p labs with each lab having n
    replicate measurements.  The mean and standard deviation are
    computed for each lab.  We then compute a pooled mean, XBAR, and
    a pooled standard deviation, SBAR, for the p labs.

    The pooled mean is computed from the p means using the H15
    location estimate.  This is referred to as Algorithm A in the
    13528 standard.  The pooled standard deviation is computed using
    Algorithm S as defined in the 13528 standard.  For details on
    these pooled statistics, enter

       HELP H15 LOCATION
       HELP ROBUST POOLED STANDARD DEVIATION

    The (x,y) values for a critical region with significance level
    alpha can be computed from

    x = XBAR - SBAR*SQRT(CHSPPF(2,alpha)/n)  to
        XBAR + SBAR*SQRT(CHSPPF(2,alpha)/n)

    and

    y = SBAR*EXP[+/-SQRT(CHSPPF(2,alpha)-(SQRT(n)*(x-XBAR)/SBAR)**2/
        SQRT(2*(n-1))]

    where CHSPPF(nu,alpha) is the chi-square percent point function
    with nu degrees of freedom and n is the number of replicated
    measurements per lab.  If the number of replications is not
    equal for the labs, Dataplot will use an average number of
    replications.

    Dataplot follows the ISO-13528 standard in computing these
    curves for alpha = 95%, 99%, and 99.9%.

Note:
    Bartlett's test and Levene's test are analytic tests for the
    assumption of constant variance.  Enter

        HELP BARTLETT TEST
        HELP LEVENE TEST

    for details.
 
Default:
    None
 
Synonyms:
    HOMOGENITY PLOT is a synonym for HOMSCEDASTICITY PLOT

    HIGHLIGHT HOMOSCEDASTICITY is a synonym for SUBSET HOMOSCEDASTICITY

    The terms SUMMARY, SUBSET, MULTIPLE and HOMOSCEDASTICITY can
    be entered in arbitrary order on the command.
 
Related Commands:
    LINES          = Sets the type for plot lines.
    CHARACTER      = Sets the type for plot characters.
    HISTOGRAM      = Generates a histogram.
    BOX PLOT       = Generates a box plot
    PLOT           = Generates a data or function plot.
    YOUDEN PLOT    = Generate a Youden plot.
 
Applications:
    Exploratory Data Analysis, Proficiency Studies
 
Reference:
    ISO 13528 (2005), "Statistical Methods for use in proficiency
    testing by interlaboratory comparisons."

    van Nuland (1992), "ISO 9002 and the circle technique,"
    Qual. Eng., 5, pp. 269-291.

Implementation Date:
    Pre-1987
    2010/12: Support for MULTIPLE and SUBSET/HIGHLIGHT option
    2010/12: Support for SUMMARY option
    2010/12: Support for alternate location and scale statistics
    2010/12: Support for "circle technique" for identifying labs that
             are statistically significantly different
    2010/12: Support for more than one group-id variable.
 
Program 1:
    skip 25
    read gear.dat  y x
    .
    title case asis
    title offset 2
    label case asis
    x1label Mean
    y1label Standard Deviation
    xlimits 0.990  1.005
    ylimits 0  0.01
    ytic mark offset 0  0.002
    major ytic mark number 6
    minor ytic mark number 1
    y1label displacement 12
    .
    line blank all
    char x all
    title Standard Form of Homoscedasticity Plot for GEAR.DAT
    homoscedasticity plot y x
    pause
    .
    char 1 2 3 4 5 6 7 8 9 10
    title Highlight Form of Homoscedasticity Plot for GEAR.DAT
    highlight homoscedasticity plot y x
    pause
    .
    .  Different Statistics
    .
    title Different Location/Scale Statistics for GEAR.DAT
    label
    yminimum 0
    subset homoscedasticity plot y x
    limits freeze
    pre-erase off
    set homo plot location h15
    set homo plot scale    h15
    x1label H15 Location
    y1label H15 Scale
    char color red all
    subset homoscedasticity plot y x
    pause
    limits
    pre-erase on

Program 2:
    skip 25
    read ripken.dat  y x1 to x4
    .
    title case asis
    label case asis
    x1label Mean
    y1label Standard Deviation
    line blank all
    .
    char 1 2 3 1 2 3 1 2 3
    char color red red red blue blue blue green green green
    x3label Color = X1, Number = X2
    title Two Replication Variables for Homoscedasticity Plotcr() ...
    for RIPKEN.DAT
    homoscedasticity plot y x1 to x2

Program 3:
    SKIP 25
    READ MONTGOME.DAT Y1 Y2 Y3
    .
    title case asis
    label case asis
    x1label Mean
    y1label Standard Deviation
    line blank all
    .
    char 1 2 3
    title Multiple Form of Homoscedasticity Plot for MONTEOME.DAT
    multiple homoscedasticity plot y1 y2 y3

Program 4:
    skip 25
    read gear.dat  y x
    .
    title case asis
    label case asis
    x1label Mean
    y1label Standard Deviation
    line blank all
    .
    char blank blank blank 1 2 3 4 5 6 7 8 9 10
    line solid dash dotted
    title Highlight Form of Homoscedasticity Plot with Contour Linescr() ...
    for GEAR.DAT
    .
    xlimits 0.99  1.005
    ylimits 0  0.015
    set homo plot circle technique on
    pre-sort off
    highlight homoscedasticity plot y x
    pre-sort on

Program 5:
    skip 25
    read antibody.dat lab  ymean  ysd  nrepl
    .
    title case asis
    label case asis
    x1label Mean
    y1label Standard Deviation
    .
    char 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ...
         19 20 21 22 23 24 25
    line blank all
    .
    title Highlight/Summary Form of Homoscedasticity Plot with Contour Linescr() ...
    for ANTIBODY.DAT
    highlight summary homoscedasticity plot ymean ysd
    pause
    .
    char blank blank blank 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ...
         19 20 21 22 23 24 25
    line blank all
    line solid dash dotted
    xlimits 0.8  2.4
    ylimits 0    1.6
    .
    title Highlight/Summary Form of Homoscedasticity Plot with Contour Linescr() ...
    for ANTIBODY.DAT
    set homo plot circle technique on
    highlight summary homoscedasticity plot ymean ysd nrepl

-----HORIZONTAL SPACING-----------------------------------------------
 
HORIZONTAL SPACING
 
Name:
    HORIZONTAL SPACING
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Specifies the horizontal spacing between characters on a line for
    subsequent TEXT commands.
 
Description:
    The horizontal spacing between characters is from the visible
    bottom right of a character on a line to the visible bottom left of
    the succeeding character on the same line.  The width of the
    characters themselves is not counted (that is controlled by the
    WIDTH command).  The horizontal spacing is in decimal units of 0 to
    100.  A horizontal spacing of 0 would be negligibly small while a
    horizontal spacing of 100 would be full screen horizontal distance.
 
Syntax:
    HORIZONTAL SPACING   <n>
    where <n> is a decimal number or parameter in the range 0 to 100
             that specifies the desired horizontal spacing.
 
Examples:
    HORIZONTAL SPACING 10
    HORIZONTAL SPACING 3
    HORIZONTAL SPACING 2.55
    HORIZONTAL SPACING H
 
Note:
    The HORIZONTAL SPACING command with no arguments reverts the
    horizontal spacing to the default.
 
Default:
    The default horizontal spacing is 0.5.
 
Synonyms:
    None.
 
Related Commands:
    VERTICAL SPACING   = Sets the vertical spacing between text lines.
    TEXT               = Writes a text string.
    TITLE SIZE         = Sets the height of the plot title.
    LABEL SIZE         = Sets the height of the plot labels.
    LEGEND SIZE        = Sets the height of the plot legends.
    TIC LABEL SIZE     = Sets the height of the plot tic mark labels.
    HEIGHT             = Sets the height for TEXT characters.
    WIDTH              = Sets the width for TEXT characters.
    HW                 = Sets the height and width for TEXT characters.
    FONT               = Sets the font for TEXT characters.
    CASE               = Sets the case for TEXT characters.
    THICKNESS          = Sets the thickness of TEXT characters.
    COLOR              = Sets the color for TEXT characters.
    JUSTIFICATION      = Sets the justification for TEXT characters.
    CR                 = Sets the carriage return position after text.
    LF                 = Sets the line feed position after text.
    CRLF               = Sets the carriage return/line feed position
                         after text.
    MARGIN             = Sets the carriage return column after text.
    ()                 = Allows math and Greek characters in text.
    MOVE               = Moves to a point.
    CROSS-HAIR (or CH) = Activates and reads the cross-hair.
    ERASE              = Erases the screen (immediately).
    COPY               = Copies the screen (immediately).
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    VERTICAL SPACING 6
    CRLF ON
    MARGIN 10
    FONT DUPLEX
    .
    HEIGHT 4
    HORIZONTAL SPACING 0.6
    MOVE 5 95
    TEXT JAPAN's 6-POINT PROGRAM FOR QUALITY MANUFACTURING
    MOVE 10 80
    HEIGHT 2.6
    HORIZONTAL SPACING 0.4
    TEXT CIRC() QUALITY AUDITS
    TEXT CIRC() COMPANY-WIDE QUALITY CONTROL (CWQC)
    TEXT CIRC() QUALITY TRAINING AND EDUCATION
    TEXT CIRC() APPLICATION OF STATISTICAL METHODS
    TEXT CIRC() QUALITY CIRCLE ACTIVITIES
    TEXT CIRC() NATION-WIDE QUALITY CONTROL PROMOTIONAL ACTIVITIES
    HEIGHT 2
    HORIZONTAL SPACING 0.5
    MOVE 5 10
    TEXT SOURCE: Q.C. TRENDS WINTER 1985, PAGES 22-23.
 
-----HORIZONTAL SWITCH------------------------------------------------
 
HORIZONTAL SWITCH
 
Name:
    HORIZONTAL SWITCH
 
Type:
    Plot Control Command
 
Purpose:
    Specifies whether subsequent plots are drawn in a vertical
    (the normal direction) or horizontal direction.
 
Description:
    This command is typically used to draw bars, spikes, and box plots
    down rather than across the page.  Many analysts find that it is
    easier to make visual comparisons down the page rather across it.
    For this reason, the horizontal format is sometimes preferred,
    especially when used in conjunction with a portrait page
    orientation.
 
Syntax:
    HORIZONTAL SWITCH   <ON/OFF>
    where ON specifies that subsequent plots are drawn horizontally
    while OFF specifies that they are drawn vertically.
 
Examples:
    HORIZONTAL SWITCH ON
    HORIZONTAL SWITCH OFF
 
Note:
    The HORIZONTAL SPACING command with no arguments sets the
    horizontal spacing to the default.
 
Note:
    The BAR DIRECTION and SPIKE DIRECTION commands perform a similar
    function specifically for bars and spikes.  The HORIZONTAL SWITCH
    command works for all plot types (although the plot characters may
    need to be set to more appropriate choices).  This command
    automatically reverses the x and y coordinates for the plot (the
    BAR DIRECTION and SPIKE DIRECTION commands do not).
 
Default:
    The default is off (vertical direction).
 
Synonyms:
    None
 
Related Commands:
    BAR DIRECTION    = Specify the direction of plot bars.
    SPIKE DIRECTION  = Specify the direction of plot spikes.
    BAR              = Sets the on/off switches for plot bars.
    SPIKE            = Sets the on/off switches for plot spikes.
    BOX PLOT         = Generate a box plot.
    ORIENTATION      = Sets the page orientation.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    XX
 
Program:
    LET Y = DATA 2 5 9 15 28
    LET X = DATA 81 82 83 84 85
    X1LIMITS 81 85
    XTIC OFFSET 1 1
    X1LABEL YEAR
    MINOR X1TIC MARK NUMBER 0
    Y1LABEL SALES (IN MILLIONS OF DOLLARS)
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    .
    TITLE VERTICAL BAR CHART
    BAR ON
    LINE BLANK
    BAR WIDTH 0.5
    PLOT Y VS X
    .
    HORIZONTAL SWITCH ON
    TITLE HORIZONTAL BAR CHART
    YLIMITS 81 85
    YTIC OFFSET 1 1
    MINOR YTIC MARK NUMBER 0
    Y1LABEL YEAR
    X1LABEL SALES
    XLIMITS
    XTIC OFFSET 0 0
    MINOR XTIC MARK NUMBER DEFAULT
    PLOT Y VS X
    .
    TITLE HORIZONTAL SPIKE CHART
    SPIKE ON
    BAR OFF
    PLOT Y VS X
    .
    TITLE HORIZONTAL BOX PLOT
    SPIKE OFF
    YLIMITS
    X1LABEL
    Y1LABEL
    YTIC OFFSET 0 0
    FENCES ON
    LET X = SEQUENCE 0 1 999
    LET X = X/100
    LET X = INT(X) + 1
    LET Y = NORMAL RANDOM NUMBERS FOR I = 1 1 1000
    LINES BOX PLOT
    CHARACTER BOX PLOT
    CHARACTER SIZE 0.9 0.9 0.9 0.9 0.9 0.9 0.9
    CHARACTER VBAR BLANK BLANK VBAR BLANK BLANK VBAR
    BOX PLOT Y X
    END OF MULTIPLOT
 
-----HOST-------------------------------------------------------
 
HOST
 
Name:
    HOST
 
Type:
    Support Command
 
Purpose:
    Specifies the host manufacturer and model.
 
Description:
    This command receives almost nil usage.  The implementors of
    DATAPLOT on your computer should have adjusted the host
    specification to the correct setting.
 
Syntax:
    HOST   <manufacturer>   <model>
    where <manufacturer> identifies the host;
    and   <model> identifies the specific model number.
 
Examples:
    HOST IBM 3033
    HOST VAX 11/780
    HOST UNIVAC 1100/80
    HOST PERKIN-ELMER 3240
 
Note:
    The HOST command with no arguments reverts the host to default.
 
Default:
    The default host is Vax 11/780.
 
Synonyms:
    None
 
Related Commands:
    HOST LINK   = Sets the manufacturer and model for the
                  communications link.
    BAUD        = Sets the baud rate.
    ERASE DELAY = Sets the delay for screen erasure.
    COPY DELAY  = Sets the delay for screen hardcopying.
 
Applications:
    XX
 
Implementation Date:
    Pre-1987
 
Program:
    XX
 
-----HOST LINK-------------------------------------------------------
 
HOST LINK
 
Name:
    HOST LINK
 
Type:
    Support Command
 
Purpose:
    Specifies the communications link to the host.
 
Description:
    This command receives almost nil usage.  The implementors of
    DATAPLOT on your computer should have adjusted the link
    specification to the correct setting.  An incorrect setting has no
    consequence (at this time) for any of DATAPLOT's other commands.
 
Syntax:
    HOST LINK   <type>
    where <type> specifies the communications link.
 
Examples:
    HOST LINK PHONE
    HOST LINK NETWORK
 
Default:
    The default host link is phone.
 
Synonyms:
    None
 
Related Commands:
    HOST        = Sets the manufacturer and model for the host
                  computer.
    BAUD        = Sets the baud rate.
    ERASE DELAY = Sets the delay for screen erasure.
    COPY DELAY  = Sets the delay for screen hardcopying.
 
Applications:
    None
 
Implementation Date:
    Pre-1987
 
Program:
    XX
 
-----HOTELLING CONTROL CHART----------------------------------------
 
HOTELLING CONTROL CHART
 
Name:
    HOTELLING CONTROL CHART
 
Type:
    Graphics Command
 
Purpose:
    Generates a multivariate Hotelling control chart.
 
Description:
    A mean control chart is a data analysis analysis technique for
    determining if a measurement process has gone out of statistical
    control.

    The standard mean control chart is limited to a single
    response variable.  The Hotelling control chart is an extension
    of the mean control chart to the case where there are multiple
    response variables.  Given p response variables, the Hotelling
    control chart computes the following for each response
    variable:

        T-Square = N*(XBAR - U0)'SINV(XBAR - U0)

    N is the size of the group, XBAR is the vector of the p sample
    means for the subgroup, and U0 is the vector of the p sample
    means for the entire data set.  That is, a 1-sample Hotelling
    test is computed to test whether the means for a given group
    are equal to the overall sample means.

    The Hotelling control chart then plots the sample T-square
    test statistic on the vertical axis and the sub-group
    identifier on the horizontal axis.

    An upper control limit (there is no lower control limit) is
    drawn at the appropriate F statistic for the Hotelling test.
    The value of alpha for the F test is chosen so that
    alpha/(2*p) = 0.00135.  This corresponds to the 3-sigma value
    for the univariate control chart.  You can set your own control
    limit by entering the command:

        LET USL = <value>

    You can control the appearance of this chart by setting the
    switches for the LINE, CHARACTER, SPIKE, and BAR commands
    appropriately.  Specifically,

       Trace 1 = T-square values
       Trace 2 = Zero reference line
       Trace 3 = Dataplot calculated control limit
       Trace 4 = User specified control limit

    For example, to draw the T-square values as a solid line and
    an X, no zero reference line, the Dataplot calculated control
    limit as a dotted line, and no user specified control limit, 
    enter the commands:

        LINE SOLID BLANK DOTTED BLANK
        CHARACTER X BLANK BLANK BLANK
 
Syntax:
    HOTELLING CONTROL CHART <y1> <y2> ... <yk>  <group>
                              <SUBSET/EXCEPT/FOR qualification>
    where <y1> <y2> ... <yk> is a list of response variables;
          <group> is an independent variable containing the
              sub-group identifications;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    HOTELLING CONTROL CHART Y1 Y2 Y3 X
    HOTELLING CONTROL CHART Y1 Y2 Y3 X SUBSET X > 1
 
Default:
    None
 
Synonyms:
    MULTIVARIATE CONTROL CHART is a synonym for HOTELLING CONTROL
    CHART.
 
Related Commands:
    XBAR CONTROL CHART      = Generates a mean control chart.
    RANGE CONTROL CHART     = Generates a mean control chart.
    S CONTROL CHART         = Generates a sd control chart.
    CUSUM CONTROL CHART     = Generates a mean cusum control chart.
    EWMA CONTROL CHART      = Generates a ewma control chart.
    MOVING AVERAGE CHART    = Generates a moving average control
                              chart.
    MOVING RANGE CHART      = Generates a moving range control chart.
    MOVING SD CHART         = Generates a moving sd control chart.
    C CHART                 = Generates a C control chart.
    U CHART                 = Generates a U control chart.
    P CHART                 = Generates a P control chart.
    NP CHART                = Generates an Np control chart.
 
Reference
    "Statistical Methods For Quality Improvement", Thomas Ryan,
    John Wiley and Sons, 1989, Chapter 9.

Applications:
    Quality Control
 
Implementation Date:
    1998/9
 
Program:
    SKIP 25
    READ T2CC.DAT Y1 Y2 X
    .
    LINE SOLID DOT DOT
    TITLE AUTOMATIC
    X1LABEL GROUP-ID
    Y1LABEL T-SQUARE VALUE
    HOTELLING CONTROL CHART Y1 Y2 X
 
-----HOTELLING ONE SAMPLE TSQUARE (LET)------------------------------
 
HOTELLING ONE SAMPLE TSQUARE
 
Name:
    HOTELLING ONE SAMPLE TSQUARE (LET
 
Type:
    Let Subcommand
 
Purpose:
    Compute the 1-sample Hotelling t-square test.
 
Description:
    The 1-sample Hotelling t-square tests the following hypothesis:

         H0: U=U0

    Here, U0 is a vector of population means, that is, the
    hypothesized means for each column of the matrix.

    The 1-sample t-square test statistic is defined as:

         T-square = n(XBAR - U0)'SINV(XBAR - U0)

    where U0 is the vector of hypothesized means, XBAR contains
    the sample means for each of the columns, and (1/N)SINV is the
    sample variance-covariance matrix of XBAR.

    T-square is distributed as ((n-1)p/(n-p))F(p,n-p) where
    n is the number of obserations, p is the number of columns,
    and F is the F distribution.  We reject the null hypothesis
    if the t-square test statistic is greater than the critical
    value from the F distribution.

    This command returns a parameter that contains the value
    of the Hotelling T-square test statistic.  The critical values
    corresponding to alpha = .10, .05, .01, and .005 are saved in
    the internal parameters B90, B95, B99, and B995 respectively.
 
Syntax:
    LET <par> = HOTELLING ONE SAMPLE TSQUARE <mat1>  <x>
    where <mat1> is a matrix containing the data for the 1-sample
              Hotelling t-square test;
          <x> is a vector containing the hypothesized means;
    and where <par> is a parameter where the value of the
             1-sample Hotelling t-square test statistic is saved.
 
Examples:
    LET A = 1-SAMPLE HOTELLING T-SQUARE M X
 
Note:
    Matrices are created with either the READ MATRIX command or the
    MATRIX DEFINITION command.  Enter HELP MATRIX DEFINITION and HELP
    READ MATRIX for details.
 
Default:
    None
 
Synonyms:
    The following are synonyms for HOTELLING ONE SAMPLE TSQUARE:
       HOTELLING ONE SAMPLE T2
       HOTELLING 1 SAMPLE TSQUARE
       HOTELLING 1 SAMPLE T2
 
Related Commands:
    READ MATRIX                      = Read a matrix.
    MATRIX COLUMN DIMENSION          = Dimension maximum number of
                                       columns for Dataplot matrices.

    HOTELLING TWO SAMPLE TSQUARE     = Compute the 2-sample Hotelling
                                       t-square test.
    QUADRATIC FORM                   = Compute the quadratic form
                                       of a matrix and a vector.
    LINEAR COMBINATION               = Compute a linear combination
                                       of a matrix and a vector.
 
Reference:
    "Applied Multivariate Statistical Analysis", Third Edition,
    Johnson and Wichern, Prentice-Hall, 1992.
 
Applications:
    Multivariate Analysis
 
Implementation Date:
    1998/8
 
Program:
    DIMENSION 200 COLUMNS
    SKIP 25
    READ IRIS.DAT SEPLENG SEPWIDTH PETLENG PETWIDTH TAG
    SKIP 0
    LET NTOT = SIZE SEPLENG
    LET M = MATRIX DEFINITION SEPLENG NTOT 4
    LET X = DATA 0 0 0 0
    LET A = HOTELLING ONE SAMPLE TSQUARE M X
    PRINT "1-SAMPLE HOTELLING T-SQUARE TEST STATISTIC = ^A"
    PRINT "90% CRITICAL VALUE                         = ^B90"
    PRINT "95% CRITICAL VALUE                         = ^B95"
    PRINT "99% CRITICAL VALUE                         = ^B99"

-----HOTELLING TWO SAMPLE TSQUARE (LET)------------------------------
 
HOTELLING TWO SAMPLE TSQUARE
 
Name:
    HOTELLING TWO SAMPLE TSQUARE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the 2-sample Hotelling t-square test.
 
Description:
    The 2-sample Hotelling t-square tests the following hypothesis:

         H0: U1=U2

    Here, U1 is a vector of population means from sample 1, that
    is, the hypothesized means for each column of matrix 1.
    Likewise, U2 is a vector of population means from sample 2,
    that is, the hypothesized means for each column of matrix 2.

    The 2-sample t-square test statistic is defined as:

         T-square = N1*N2*(XBAR1-XBAR2)'*SINV*(XBAR1-XBAR2)/(N1+N2)

    where XBAR1 contains the sample means for each of the columns
    of matrix 1, XBAR2 contains the sample means for each of the
    columns of matrix 2, N1 is the sample size for matrix 1, N2
    is the sample size for matrix 2, and SINV is the inverse of
    the pooled variance-covariance matrices of XBAR1 and XBAR2.

    T-square is distributed as F(p,n1+n2-p-1) where n1 is the
    number of obserations for matrix 1, n2 is the number of
    observations for matrix 2, p is the number of columns
    (variables), and F is the F distribution.  We reject the
    null hypothesis if the t-square test statistic is greater
    than the critical value from the F distribution.

    This command returns a parameter that contains the value
    of the Hotelling T-square test statistic.  The critical values
    corresponding to alpha = .10, .05, .01, and .005 are saved in
    the internal parameters B90, B95, B99, and B995 respectively.
 
Syntax:
    LET <par> = HOTELLING TWO SAMPLE TSQUARE <mat1>  <mat2>
    where <mat1> is a matrix containing the data for the first
              sample of the 2-sample Hotelling t-square test;
    where <mat2> is a matrix containing the data for the second
              sample of the 2-sample Hotelling t-square test;
    and where <par> is a parameter where the value of the
             2-sample Hotelling t-square test statistic is saved.
 
Examples:
    LET A = 2-SAMPLE HOTELLING T-SQUARE M Z
 
Note:
    Matrices are created with either the READ MATRIX command or the
    MATRIX DEFINITION command.  Enter HELP MATRIX DEFINITION and HELP
    READ MATRIX for details.
 
Default:
    None
 
Synonyms:
    The following are synonyms for HOTELLING TWO SAMPLE TSQUARE:
       HOTELLING TWO SAMPLE T2
       HOTELLING 2 SAMPLE TSQUARE
       HOTELLING 2 SAMPLE T2
 
Related Commands:
    READ MATRIX                      = Read a matrix.
    MATRIX COLUMN DIMENSION          = Dimension maximum number of
                                       columns for Dataplot matrices.

    HOTELLING ONE SAMPLE T-SQUARE T  = Compute the 1-sample Hotelling
                                       t-square test.
    QUADRATIC FORM                   = Compute the quadratic form
                                       of a matrix and a vector.
    LINEAR COMBINATION               = Compute a linear combination
                                       of a matrix and a vector.
 
Reference:
    "Applied Multivariate Statistical Analysis", Third Edition,
    Johnson and Wichern, Prentice-Hall, 1992.
 
Applications:
    Multivariate Analysis
 
Implementation Date:
    1998/8
 
Program:
    DIMENSION 200 COLUMNS
    SKIP 25
    READ IRIS.DAT X1 X2 X3 X4 TAG
    SKIP 0
    LET Z1 = X1
    LET Z2 = X2
    LET Z3 = X3
    LET Z4 = X4
    RETAIN X1 X2 X3 X4 SUBSET TAG = 1
    RETAIN Z1 Z2 Z3 Z4 SUBSET TAG = 2
    LET N1 = SIZE X1
    LET N2 = SIZE Z1
    LET M = MATRIX DEFINITION X1 N1 4
    LET N = MATRIX DEFINITION Z1 N2 4
    LET A = HOTELLING 2 SAMPLE TSQUARE M N
    PRINT "2-SAMPLE HOTELLING T-SQUARE TEST STATISTIC = ^A"
    PRINT "90% CRITICAL VALUE                         = ^B90"
    PRINT "95% CRITICAL VALUE                         = ^B95"
    PRINT "99% CRITICAL VALUE                         = ^B99"

-----HOUSEKEEPING SWITCHES (SET)--------------------------------------------
 
HOUSEKEEPING SWITCHES
 
Name:
    HOUSEKEEPING SWITCHES (SET)
 
Type:
    Set Subcommand
 
Purpose:
    Probe for values pertaining to certain Dataplot housekeeping
    settings.
 
Description:
    Certain values pertaining to Dataplot's housekeeping parameters can be
    extracted using the PROBE command.  Note that these settings cannot be
    modified with the SET command.

    These setting are typically of interest to the Dataplot developers for
    debugging purposes.  However, they can be used by any Dataplot user.

    The list of available housekeeping switches is

        ICOM           - The current command (characters 1-4).
        ICOM2          - The current command (characters 5-8).
        MAXARG         - The maximum number of arguments on a command
                         line.
        NUMARG         - The number of arguments on the current command
                         line.
        IARG           - The command arguments in interger format.
        ARG            - The command arguments in real format.
        IHARG          - The command arguments in character format.
        IHNAME         - The currently defined names for variables,
                         parameters, strings, functions, and matrices
                         (characters 1-4).
        IHNAM2         - The currently defined names for variables,
                         parameters, strings, functions, and matrices
                         (characters 1-8).
        IUSE <elem>    - The type for the <elem> entry in the Dataplot
                         name table.  V means variable, P means parameter,
                         F means function or string, and M means matrix.
        IVALUE <elem>  - The column in the internal data storage area
                         where the <elem> entry in the Dataplot name table
                         is stored.
        VALUE <elem>  - The parameter value for the <elem> entry in the
                        Dataplot name table.  This value is only relevant
                        if the type is a parameter.
        IN <elem>     - The number of observations for the <elem> entry
                        in the Dataplot name table.  This value is only
                        relevant for variables.
        IVSTAR <elem> - The starting position in the internal data storage
                        area for the <elem> entry in the Dataplot name
                        table.
        IVSTOP <elem> - The stopping position in the internal data storage
                        area for the <elem> entry in the Dataplot name
                        table.

Syntax:
    PROBE <HOUSEKEEPING SWITCH>
    where <HOUSEKEEPING SWITCH> is one of the names listed above.
 
Examples:
    PROBE ICOM
    PROBE IHARG
    PROBE IUSE 10

Default:
    The defaults for maximum values are defined when the Dataplot source
    is compiled.  The other settings are automatically updated as
    Dataplot commands are processed.
 
Synonyms:
    None
 
Related Commands:
    NAME TABLE        = Probe the current settings for the Dataplot name
                        table.
    IFEEDB            = Probe the current setting of the FEEDBACK switch.
    IPRINT            = Probe the current setting of the PRINT switch.
    IECHO             = Probe the current setting of the ECHO switch.
    BUG SWITCHES      = Set debug switches.
    SYSTEM LIMITS     = Parameters defining certain Dataplot limits.
    MACHINE CONSTANTS = Return the values for certain machine constants.

Applications:
    Debugging
 
Implementation Date:
    Pre-1987
 
Program:
    SKIP 25
    READ BERGER1.DAT Y X BAT
    .
    PROBE NAME TABLE
    PROBE IUSE 11
    PROBE VALUE 11
    PROBE IN 11
 
-----HP-------------------------------------------------------
 
HP
 
Name:
    HP
 
Type:
    Output Device Command
 
Purpose:
    Direct graphical output to an HP device.  Several different HP
    models are supported.
 
Description:
    DATAPLOT supports 3 basic types of HP devices.  These are the
    HP 2622 and related terminals, HP-GL for plotters and printers,
    and the HP 7221 plotter.  Each of these are described in more
    detail in the NOTE section below.
 
Syntax:
    HP   <model> <model2> <model3>
    where <model> is the first model identifier;
          <model2> is the optional second model identifier;
    and   <model3> is the optional third model identifier.
 
Examples:
    HP-GL
    HP-GL 7475
    HP-GL LJET
    HP 2622
    HP 2647
    HP 7221
 
Note:
    DATAPLOT supports the following HP-2622 type terminals.
 
        MODEL                   RESOLUTION       COLORS
        =====                   ==========       ======
        2622, 2623, 2393, 9816, 512 x 390          0
           9836, 216x, 236x
        2647, 2648              720 x 360          0
        2627, 2397, 2390        512 x 390          8
 
    All the above models use the same device driver.  They differ only
    in the number of picture points used and in whether or not they
    support color.  If you have an HP terminal not listed above, try
    using the HP 2622 (DEVICE 1 HP 2622) for a monochrome terminal or
    the HP 2627 (DEVICE 1 HP 2627) for a color terminal.  You may need
    to specify the picture points as well (PICTURE POINTS
    <x resolution> <y resolution>).
 
Note:
    Most HP plotters and printers use the HP-GL protocol.  In
    addition, some non-HP plotter vendors support an HP-GL emulation
    mode.  This protocol can vary somewhat among plotter models.
    Fortunately, this variation is typically in what commands are
    supported, not in how they work.  DATAPLOT uses a subset of the
    HP-GL language that should be available on all HP-GL plotters.
    HP-GL plotters can also vary in the number of pens available, paper
    sizes available, and in the resolution (i.e., the number of picture
    points).  DATAPLOT can handle some of this by entering the device
    command as follows:
 
        DEVICE <id> HPGL <model> <paper size>
 
    where <paper size> is one of the following:
 
        A - 8 1/2 x 11 inches
        B - 11 x 17 inches
        C - 17 x 22 inches
        D - 22 x 34 inches
        E - 34 x 44 inches
 
    and <model> is one of the following:
 
        7475, 7550  (A and B sizes supported, 8 pens)
        7580        (A, B, C, and D sizes supported, 8 pens)
        7585, 7586  (A, B, C, D, and E sizes supported, 8 pens)
        9872        (A size only, 4 pens)
        LJET, LASER (A size only, black and white)
 
    Specifying the model number and paper size changes the number of
    picture points DATAPLOT assumes.  Previously, it was hardcoded to
    the model 9872 units.  This caused plots to be centered incorrectly
    on other models (although this could be alleviated via a PICTURE
    POINTS command).  Also, the number of pen slots is based on the
    model number.  The 9872 has 4 slots while the other models assume 8
    slots.   The mapping of a color to a pen number can be user
    modified with the PEN MAP command.
 
    If your model is not listed above, simply use one of the above
    models (the 7475 is probably the best choice for most models).  The
    default is model 9872 (with 4 pens and using A size paper).
 
    The LJET model is used to support the HP LaserJet III printer (in
    HP-GL emulation mode).  It adds commands to put the LaserJet in
    HP-GL mode and to handle page advances correctly.  HP-GL files from
    other models will not work correctly on the LaserJet III.
 
    The LaserJet II is not supported.  The only solution at this time
    is to purchase a Postscript cartridge for the printer or an HP-GL
    emulation software package.
 
Note:
    DATAPLOT supports the HP 7221 pen plotter (enter DEVICE 1 HP 7221).
    This is now an essentially obsolete plotter (although it still
    works).
 
Default:
    Off
 
Synonyms:
    None
DEVICE NOTES (HP 2622)
    1) HARDWARE TEXT - There are 7 hardware character sizes.
           DATAPLOT  SIZE          Hardware size
           ==============          =============
            0.0 <= size <   3.0           1
            3.0 <= size <   6.0           2
            6.0 <= size <   9.0           3
            9.0 <= size <  11.0           4
           11.0 <= size <  14.0           5
           14.0 <= size <  17.0           6
           17.0 <= size < 100.0           7
    2) COLOR - Those HP 2622 related terminals that support color
       provide the following colors:
           BLACK, WHITE, RED, BLUE, GREEN, MAGENTA, CYAN, YELLOW
       Enter the command SHOW COLORS HP 2622 for the DATAPLOT color to
       HP 2622 color mapping.  The background color can be set to one
       of these supported colors.
    3) HARDWARE FILL - All area fills are done in software.
    4) DASH PATTERNS - The HP 2622 provides unique dash patterns for
       each DATAPLOT dash type (SOLID, DASH, DOTTED, DASH1, DASH2,
       DASH3, and DASH4).
    5) LINE WIDTH - Wide lines are drawn in software.
    6) GRAPHICS INPUT - The CROSS HAIR command is supported on the
       HP 2622.
DEVICE NOTES (HP-GL)
    1) HARDWARE TEXT - HP-GL hardware characters can be scaled to any
       size.  Vertical strings are rotated 90 degrees.  The appearance
       of hardware text may vary depending on the specific model used.
    2) COLOR - The LASERJET model is monochrome, the 9872 model assumes
       4 slots, and all other models assume 8 slots.  If you have more
       than 8 colors, use the HPGL PEN MAP command (enter HELP PEN MAP
       for details) to define the color to slot number mapping for
       slots greater than 8.  This command can also be used to override
       the defaults for slots 1 through 8.  Enter SHOW COLORS CALCOMP
       for the default DATAPLOT color to pen slot mapping.
    3) HARDWARE FILL - All area fills are done in software.
    4) DASH PATTERNS - The HP-GL device provides unique dash patterns
       for each DATAPLOT dash type (SOLID, DASH, DOTTED, DASH1, DASH2,
       DASH3, and DASH4).
    5) LINE WIDTH - Wide lines are drawn in software.
    6) GRAPHICS INPUT - The CROSS HAIR command is ignored for HP-GL
       devices.
DEVICE NOTES (7221)
    1) HARDWARE TEXT - HP 7221 hardware characters can be scaled to any
       size.  Vertical strings are not rotated 90 degrees.
    2) COLOR - The HP 7221 plotter assumes 8 pen slots.  Enter SHOW
       COLORS CALCOMP for the default DATAPLOT color to pen slot
       mapping.
    3) HARDWARE FILL - All area fills are done in software.
    4) DASH PATTERNS - The HP 7221 device provides unique dash patterns
       for each DATAPLOT dash type (SOLID, DASH, DOTTED, DASH1, DASH2,
       DASH3, and DASH4).
    5) LINE WIDTH - Wide lines are drawn in software.
    6) GRAPHICS INPUT - The CROSS HAIR command is ignored for HP 7221
       device.
 
Related Commands:
    SHOW CALCOMP COLORS = Show the available colors for 8 slot pen
                          plotters.
    ZETA                = Direct graphical output to a ZETA device.
    CALCOMP             = Direct graphical output to a Calcomp device.
    POSTSCRIPT          = Direct graphical output to a Postscript
                          device.
    TEKTRONIX           = Direct graphical output to a Tektronix
                          device.
 
Applications:
    Graphics Output
 
Implementation Date:
    Pre-1987
 
Program:
    XX
 
-----HSECDF (LET)--------------------------------
 
HSECDF
 
Name:
    HSECDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the hyperbolic secant cumulative distribution function.
 
Description:
    The hyperbolic secant distribution has the following
    cumulative distribution function:

       F(x) = 0.5 + ARCTAN(SINH(x))/PI
 
    where ARCTAN is the arctangent function and SINH is the
    hyperbolic sin function. 

Syntax:
    LET <y> = HSECDF(<x>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed hyperbolic secant cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = HSECDF(3)
    LET A = HSECDF(A1)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    HSEPDF = Compute the hyperbolic secant probability density
             function.
    HSEPPF = Compute the hyperbolic secant percent point function.
    LOGPDF = Compute the logistic probability density function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 2", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994,
    (page 147).
 
Applications:
    Lifetime Analysis
 
Implementation Date:
    1995/10
 
Program:
    TITLE AUTOMATIC
    X1LABEL X
    Y1LABEL PROBABILITY
    PLOT HSECDF(X) FOR X = -5  0.01  5

-----HSEPDF (LET)--------------------------------
 
HSEPDF
 
Name:
    HSEPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the hyperbolic secant probability density function.
 
Description:
    The hyperbolic secant distribution has the following
    probability density function:

       f(x) = SECH(x)/PI
 
    where SECH is the hyperbolic secant funciton.

Syntax:
    LET <y> = HSEPDF(<x>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed hyperbolic secant pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = HSEPDF(3)
    LET A = HSEPDF(A1)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    HSECDF = Compute the hyperbolic secant cumulative distribution
             function.
    HSEPPF = Compute the hyperbolic secant percent point function.
    LOGPDF = Compute the logistic probability density function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 2", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994,
    (page 147).
 
Applications:
    Lifetime Analysis
 
Implementation Date:
    1995/10
 
Program:
    TITLE AUTOMATIC
    X1LABEL X
    Y1LABEL PROBABILITY
    PLOT HSEPDF(X) FOR X = -5  0.01  5

-----HSEPPF (LET)--------------------------------
 
HSEPPF
 
Name:
    HSEPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the hyperbolic secant percent point function.
 
Description:
    The hyperbolic secant distribution has the following
    percent point function:

       G(p) = LOG(1 + TAN(PI*(p - 0.5)/2))/(1 - TAN(PI*(p - 0.5)/2))
 
Syntax:
    LET <y> = HSEPPF(<p>)    <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what <p> is)
              where the computed hyperbolic secant pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = HSEPPF(0.95)
    LET A = HSEPPF(P1)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    HSECDF = Compute the hyperbolic secant cumulative distribution
             function.
    HSEPDF = Compute the hyperbolic secant probability density
             function.
    LOGPDF = Compute the logistic probability density function.
    NORPDF = Compute the normal probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 2", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994,
    (page 147).
 
Applications:
    Lifetime Analysis
 
Implementation Date:
    1995/10
 
Program:
    TITLE AUTOMATIC
    Y1LABEL X
    X1LABEL PROBABILITY
    PLOT HSEPPF(P) FOR P = 0.01  0.01  0.99

-----HTML HEADER FILE (SET)---------------------------------------
 
HTML HEADER FILE
 
Name:
    HTML <HEADER/FOOTER> FILE (SET)
 
Type:
    Set Subcommand
 
Purpose:
    Specify a header (or footer) file to use with the CAPTURE HTML
    command.
 
Description:
    The CAPTURE HTML is used to generate the Dataplot output in
    HTML format.  By default, Dataplot generates rather plain
    vanilla headers and footers for the html file.  In many cases, it
    is desirable to have more elaborate headers and footers for the
    HTML output.  For example, many sites have specific standards for
    the appearance of web pages.

    Most desired features can be implemented at either the beginning
    or the end of the HTML file.  Dataplot's approach is to allow
    the user the specify a file that contains the header (or footer)
    information.

    If no header file is given, Dataplot will generate the default
    plain vanilla header.  If a header file is given, Dataplot
    will use that file instead.  You can also specify a footer file
    to appear at the end of the HTML file.

    If a header file is specified, Dataplot does no syntax checking
    of the file.  It is assumed that your header file contains all
    the header information (i.e., everything between the <HEAD> and
    </HEAD> tags) and that it includes a <BODY> tag.  Likewise, if
    a footer file is specified, Dataplot does no syntax checking and
    it assumes that this file contains the </BODY> and </HTML> tags.

    The header and footer files are handled independently.  That is,
    you can specify one or both (or neither).

Syntax 1:
    SET HTML HEADER FILE <file>
    where <file> is the name of the file containing the HTML header
          information.
 
Syntax 2:
    SET HTML FOOTER FILE <file>
    where <file> is the name of the file containing the HTML footer
          information.
 
Examples:
    SET HTML HEADER FILE SED_HEADER.HTML
    SET HTML FOOTEE FILE SED_FOOTER.HTML
 
Note:
    The HELP directory in the Dataplot auxillary files contains the
    files "sedheader.htm" and "sedfooter.htm".  These are intended as
    examples of header and footer files, respectively.  As these
    generate headers and footers that are specific to our NIST pages,
    you won't typically use these directly.  However, they are useful
    as a guide for developing your own header and footer files.

Note:
    Dataplot will read a maximum line length of 240 characters in the
    header and footer files.  If you have lines longer than this, then
    edit the file using an ASCII editor to break the long lines into
    several shorter lines.

Default:
    The default is to use the default plain vanilla headers and footers.
 
Synonyms:
    None
 
Related Commands:
    CAPTURE       = Direct Dataplot output to an ASCII file.
 
Applications:
    Web Output
 
Implementation Date:
    2003/1
 
Program:
    SET HTML HEADER FILE SED_HEADER.HTM
    SET HTML FoOTER FILE SED_HEADER.HTM
    LINE BLANK
    CHARACTER X
    TITLE AUTOMATIC
    DEVICE 2 POSTSCRIPT
    ORIIENTATION LANDSCAPE WORDPERFECT
    CAPTURE HTML PLOT.HTM
    PLOT SIN(X) FOR X = -6 0.1 6
    DEVICE 2 CLOSE
    END OF CAPTURE
 
-----HV (LET)--------------------------------
 
HV
 
Name:
    HV (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Struve function.
 
Description:
    The Struve function can be expressed as:

        H(x,v) = SUM[(-1)**k*(x/2)**(2*k+v+1)/
                     (GAMMA(k+3/2)*GAMMA(v+k+3/2)]

    where v is the order of the Struve function, GAMMA is the
    gamma function, and the summation is over k from 0 to
    positive infinity.

    Dataplot computes this function using the STVH0, STVH1, and
    STVHV routines from "Computation of Special Functions" (see
    the Reference section below).
 
Syntax 1:
    LET <y> = HV(<x>,<v>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, variable or parameter;
          <v> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what <x> 
               and <v> are) where the computed Struve function
               values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    Dataplot supports the Struve function for non-negative real
    x and for orders between -8.5 and 12.5.  This syntax is used
    for arbitrary order.

Syntax 2:
    LET <y> = H0(<x>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, variable or parameter;
          <y> is a variable or a parameter (depending on what <x> 
               is) where the computed Struve function
               values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    Dataplot supports the Struve function for non-negative real
    x.  This syntax is used for the Struve function of order 0.

Syntax 3:
    LET <y> = H1(<x>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, variable or parameter;
          <y> is a variable or a parameter (depending on what <x> 
               is) where the computed Struve function
               values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    Dataplot supports the Struve function for non-negative real
    x.  This syntax is used for the Struve function of order 1.

Examples:
    LET A = HV(2.3,1)
    LET A = HV(X,A1)
    LET X2 = HV(X1,4) FOR X1 = 0.1 0.1 3.0
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LV         = Compute the modified Struve function.
    BESSJN     = Compute the Bessel function of the first kind.
    BESSYN     = Compute the Bessel function of the second kind.
    BESSIN     = Compute the modified Bessel function.
    BESSKN     = Compute the modified Bessel function of the third
                 kind.
 
Reference:
    "Computation of Special Functions", Shanjie Zhang and Jianming
    Jin, John Wiley and Sons, 1996, chapter 11.
 
    "AMS 55: Handbook of Mathematical Functions", Abramowitz and
    Stegun, Eds., Washington, DC, National Bureau of Standards,
    1964.

Applications:
    Special Functions
 
Implementation Date:
    1997/12
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    TITLE ORDER 0
    PLOT HV(X,0) FOR X = 0 0.01 10
    TITLE ORDER 1
    PLOT HV(X,1) FOR X = 0 0.01 10
    TITLE ORDER 2
    PLOT HV(X,2) FOR X = 0 0.01 10
    TITLE ORDER 3
    PLOT HV(X,3) FOR X = 0 0.01 10
    END OF MULTIPLOT
    MOVE 50 97
    CENTER JUSTIFICATION
    TEXT STRUVE FUNCTIONS
 
-----HW-------------------------------------------------------
 
HW
 
Name:
    HW
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Specifies the height and width of various diagrammatic graphics
    components:
        1) letters (from the TEXT command);
        2) numerals (from the TEXT command);
        3) mathematics symbols (from the TEXT command);
        4) arrow head length (from the ARROW command);
        5) capacitor bar height (from the CAPACITOR command);
        6) resistor wrinkle height (from the RESISTOR command);
        7) inductor loop height (from the INDUCTOR COMMAND).
 
Description:
    The height of the character is from the visible bottom of the
    character to the visible top of the character.  The vertical
    spacing between characters is not counted (that is controlled by
    the VERTICAL SPACING command).  The height is in decimal units of 0
    to 100.  A height of 0 would be negligibly small while a height of
    100 would be full screen vertical distance.  The width of the
    character is from the visible left of the character to the visible
    right of the character.  The horizontal spacing between characters
    is not counted (that is controlled by the HORIZONTAL SPACING
    command).  The width is in decimal units of 0 to 100.  A width of 0
    would be negligibly narrow while  a width of 100 would be full
    screen horizontal distance.
 
Syntax:
    HW   <h>   <w>
    where <h> is a number or parameter in decimal units 0 to 100 that
              specifies the desired height;
    and   <w> is a number or parameter in decimal units 0 to 100 that
              specifies the desired width.
 
Examples:
    HW 10 8
    HW 3 2
    HW 2.55 2
    HW H W
 
Note:
    The HW command with no arguments reverts the height and
    width to the defaults.
 
Note:
    If hardware characters are used (FONT TEKTRONIX), DATAPLOT uses the
    closest size available on that device.  Note that some devices have
    only 1 hardware character size and most have only a few discrete
    sizes.
 
Note:
    There are also commands to control the heights and widths of
    individual plot elements (see the RELATED COMMANDS section).
 
Note:
    If the HEIGHT command is used to specify the size, the width is
    set to one half the height.  The HW command overrides this default
    width.
 
Default:
    The default height and width is 2.0 and 1.0, respectively.
 
Synonyms:
    HW   <h>   <w>   is identical to the 2 commands--
    HEIGHT   <h>
    WIDTH   <w>
 
Related Commands:
    TEXT               = Writes a text string.
    TITLE SIZE         = Sets the height of the plot title.
    LABEL SIZE         = Sets the height of the plot labels.
    LEGEND SIZE        = Sets the height of the plot legends.
    TIC LABEL SIZE     = Sets the height of the plot tic mark labels.
    LEGEND HW          = Sets the height and width of the plot legends.
    TIC LABEL HW       = Sets the height and width of the plot tic
                         mark labels.
    HEIGHT             = Sets the height for TEXT characters.
    WIDTH              = Sets the width for TEXT characters.
    HW                 = Sets the height and width for TEXT characters.
    VERTICAL SPACING   = Sets the vertical spacing between text lines.
    HORIZONTAL SPACING = Sets the horizontal spacing between text
                         characters.
    FONT               = Sets the font for TEXT characters.
    CASE               = Sets the case for TEXT characters.
    THICKNESS          = Sets the thickness of TEXT characters.
    COLOR              = Sets the color for TEXT characters.
    JUSTIFICATION      = Sets the justification for TEXT characters.
    CR                 = Sets the carriage return position after text.
    LF                 = Sets the line feed position after text.
    CRLF               = Sets the carriage return/line feed position
                         after text.
    MARGIN             = Sets the carriage return column after text.
    ()                 = Allows math and Greek characters in text.
    MOVE               = Moves to a point.
    CROSS-HAIR (or CH) = Activates and reads the cross-hair.
    ERASE              = Erases the screen (immediately).
    COPY               = Copies the screen (immediately).
 
Applications:
    XX
 
Implementation Date:
    Pre-1987
 
Program:
    VERTICAL SPACING 6
    CRLF ON
    MARGIN 10
    FONT DUPLEX
    .
    HW 4 1.2
    MOVE 5 95
    TEXT JAPAN's 6-POINT PROGRAM FOR QUALITY MANUFACTURING
    MOVE 10 80
    HW 2.6 1.1
    TEXT CIRC() QUALITY AUDITS
    TEXT CIRC() COMPANY-WIDE QUALITY CONTROL (CWQC)
    TEXT CIRC() QUALITY TRAINING AND EDUCATION
    TEXT CIRC() APPLICATION OF STATISTICAL METHODS
    TEXT CIRC() QUALITY CIRCLE ACTIVITIES
    TEXT CIRC() NATION-WIDE QUALITY CONTROL PROMOTIONAL ACTIVITIES
    HW 2 1
    MOVE 5 10
    TEXT SOURCE: Q.C. TRENDS WINTER 1985, PAGES 22-23.
 
-----HYPHEN WORD SEPARATOR (SET)-----------------------------------
 
HYPHEN WORD SEPARATOR
 
Name:
    HYPHEN WORD SEPARATOR (SET)
 
Type:
    Set Subcommand
 
Purpose:
    Specify whether the hyphen ("-") will be treated as a word separator
    when parsing a command.
 
Description:
    By default, Dataplot treats the hyphen as a word separator when
    parsing a command line.  This command can be used to specify
    that hyphens will not be treated as word separators.

    This command was added internally to support the INSERT COMMAND
    LINE ARGUMENTS command.  However, it can be used explicitly by
    users.  It would primarily be used before commands that have
    file names as arguments (READ, WRITE, CALL, LIST).  This allows
    file names that contains hyphens to be entered without enclosing
    the file name in quotes (although the quotes are still required
    if the file name contains spaces).

Syntax:
    SET HYPHEN WORD SEPARATOR <ON/OFF>
    where ON specifies that hyphens will be treated as word separators
             while OFF specifies that they will not.
 
Examples:
    SET HYPHEN WORD SEPARATOR ON
    SET HYPHEN WORD SEPARATOR OFF

Default:
    ON
 
Synonyms:
    None
 
Related Commands:
    INSERT COMMAND LINE ARGUMENTS  = Define the command line arguments.
 
Applications:
    Utility command for parsing file names
 
Implementation Date:
    2017/01
 
Program:
    SET HYPHEN WORD SEPARATOR OFF
    READ SAMPLE-DATA.TXT Y X
    SET HYPHEN WORD SEPARATOR ON
 
-----HYPCDF (LET)--------------------------------
 
HYPCDF
 
Name:
    HYPCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the hypergeometric cumulative distribution function.
 
Description:
    The hypergeometric distribution is the probability of selecting
    LL marked items when a random sample of size KK is taken without
    replacement from a population a population of MM items, NN of
    which are marked. Marked and unmarked items can also be thought of
    as successes and failures.  It has probability function:
        P(x=LL) = (NN LL)*((MM-NN) (KK-LL)) / (MM KK)
    where (a b) is the combinatorial function a things taken b at a
    time and has the formula:
        (a b) = a!/(b!*(a-b)!)
    The ! symbol is the factorial function.

    The cumulative distribution is the probability of obtaining x or
    fewer successes in n trials.  It is the sum of the hypergeometric
    probabilities of 0 to x.
 
Syntax:
    LET <y> = HYPCDF(<x>,<kk>,<nn>,<mm>) 
                           <SUBSET/EXCEPT/FOR qualification>
    where <x> is an integer variable, number, or parameter;
          <kk> is a positive integer number, parameter, or variable
               that is the size of the sample;
          <nn> is a positive integer number, parameter, or variable
               that is number of marked items;
          <mm> is a positive integer number, parameter, or variable
               that is number of items in the population;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed hypergeometric cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = HYPCDF(7,100,300,2000)
    LET X2 = HYPCDF(X1,300,100,1000)
 
Note:
    DATAPLOT uses the algorithm AS R77 (which is a refinement of
    AS 152) from the Applied Statistics series (see the REFERENCE
    section below).  DATAPLOT uses the version of this algorithm from
    the statlib archive.  For small to moderate values of the input
    parameters, an exact algorithm is used (essentially by taking
    the log of the factorial function).  For large values of the
    input parameters, a normal approximation is used.  One change
    that DATAPLOT makes in this algorithm is that a binomial 
    approximation rather than a normal approximation is used.  The
    binomial approximation is taken from the Ling and Pratt article
    (see the REFERENCE section below).

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    HYPPDF = Compute the hypergeometric probability mass function.
    HYPPPF = Compute the hypergeometric percent point function.
    BINCDF = Compute the binomial cumulative distribution function.
    BINPDF = Compute the binomial probability mass function.
    BINPPF = Compute the binomial percent point function.
    POIPDF = Compute the Poisson probability mass function.
    POICDF = Compute the Poisson cumulative distribution function.
    POIPPF = Compute the Poisson percent point function.
    NBCDF  = Compute the negative binomial cumulative distribution
             function.
    NBPDF  = Compute the negative binomial probability mass function.
    NBPPF  = Compute the negative binomial percent point function.
    GEOCDF = Compute the geometric cumulative distribution function.
    GEOPDF = Compute the geometric probability mass function.
    GEOPPF = Compute the geometric percent point function.
 
Reference:
    "A Remark on Algorithm AS 152: Cumulative Hypergeometric 
    Probabilities", Shea, Applied Statistics Journal, Vol. 38, No. 1,
    1989.

    "Algorithm AS 152: Cumulative Hypergeometric Probabilities",
    Lund, Applied Statistics, Vol. 31 (pp. 221-223).

    "The Accuracy of Piezer Approximations to the Hypergeometric
    Distribution, with Comparisons to Some Other Approximations",
    Ling and Pratt, Journal of the American Statistical Association,
    March, 1984.

    "Statistical Distributions", 2nd Edition, Evans, Hastings, and
    Peacock, Wiley and Sons, 1993, (chapter 20).

    "Discrete Univariate Distributions", Johnson and Kotz, Wiley and
    Sons, 1970.
 
Applications:
    XX
 
Implementation Date:
    94/9
 
Program:
    YLIMITS 0 1
    MAJOR YTIC NUMBER 6
    MINOR YTIC NUMBER 1
    YTIC DECIMAL 1
    XTIC OFFSET 0.5 0.5
    LINE BLANK
    SPIKE ON
    SPIKE LINE DASH
    CHARACTER CIRCLE
    CHARACTER FILL ON
    CHARACTER SIZE 1.2
    TITLE AUTOMATIC
    Y1LABEL PROBABILITY
    PLOT HYPCDF(X,100,300,1000) FOR X = 0 1 100
 
-----HYPERGEO (LET)----------------------------------------------
 
HYPERGEO
 
Name:
    HYPERGEO (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the hypergeometric function with shape parameters
    A, B, and C for the convergent case (case where x < 1).
 
Description:
    The Handbook of Mathematical Functions (see the REFERENCE section
    below) gives the definition the hypergeometric functions.

    This function only tries to compute the hypergeometric
    function for the convergent case (ABS(x) < 1).  Although
    many common functions can be defined as a special case of this
    function, it is typically better to use functions that take
    advantage of features of the specific function for more
    efficient and accurate evaluation.

    The input value must be have an absolute value less than 1.
    The C shape parameter should not be 0 or a negative integer.
    Also, if C <= A + B, the hypergeometric function is
    divergent and Dataplot will not attempt to conpute the
    function for this case either.

    Dataplot computes this function using the HYGFX routine from
    "Computation of Special Functions" (see the References section
    below).
 
Syntax:
    LET <y> = HYPERGEO(<x>,<a>,<b>,<c>)
                            <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, variable, or parameter;
          <a> is a number, variable, or parameter;
          <b> is a number, variable, or parameter;
          <b> is a number, variable, or parameter;
          <c> is a number, variable, or parameter;
          <y> is a variable or a parameter (depending on what <a>,
              <b>, and <c> are) where the computed values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Z = HYPERGEO(0.01,0.1,0.2,2)
    LET Z = HYPERGEO(1,0.1,0.2,2)
    LET Z = HYPERGEO(0.1,-1.3,0.1,4)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHU        = Compute the confluent hypergeometric U function.
    CHM        = Compute the confluent hypergeometric M function.
    BETA       = Compute the complete Beta function.
    BETAI      = Compute the incomplete Beta function.
    GAMMA      = Compute the gamma function.
    LOGGAMMA   = Compute the log gamma function.
 
Reference:
    "Computation of Special Functions", Shanjie Zhang and Jianming
    Jin, John Wiley and Sons, 1996, chapter 12.
 
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964.
 
Applications:
    Special Functions
 
Implementation Date:
    1997/12
 
Program:
    TITLE AUTOMATIC
    PLOT HYPERGEO(X,0.1,0.2,0.4) FOR X = -0.9 0.01 0.9
 
-----HYPPDF (LET)--------------------------------
 
HYPPDF
 
Name:
    HYPPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the hypergeometric probability mass function.
 
Description:
    The hypergeometric distribution is the probability of selecting
    LL marked items when a random sample of size KK is taken without
    replacement from a population a population of MM items, NN of
    which are marked. Marked and unmarked items can also be thought of
    as successes and failures.  It has the probability mass
    function:

        P(x=LL) = (NN LL)*((MM-NN) (KK-LL)) / (MM KK)

    where (a b) is the combinatorial function a things taken b at a
    time and has the formula:

        (a b) = a!/(b!*(a-b)!)

    The ! symbol is the factorial function.

Syntax:
    LET <y> = HYPPDF(<x>,<kk>,<nn>,<mm>) 
                           <SUBSET/EXCEPT/FOR qualification>
    where <x> is an integer variable, number, or parameter;
          <kk> is a positive integer number, parameter, or variable
               that is the size of the sample;
          <nn> is a positive integer number, parameter, or variable
               that is number of marked items;
          <mm> is a positive integer number, parameter, or variable
               that is number of items in the population;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed hypergeometric cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = HYPPDF(7,100,300,2000)
    LET X2 = HYPPDF(X1,300,100,1000)
 
Note:
    DATAPLOT uses the algorithm AS R77 (which is a refinement of
    AS 152) from the Applied Statistics series (see the REFERENCE
    section below).  DATAPLOT uses the version of this algorithm from
    the statlib archive.  For small to moderate values of the input
    parameters, an exact algorithm is used (essentially by taking
    the log of the factorial function).  For large values of the
    input parameters, a normal approximation is used.  One change
    that DATAPLOT makes in this algorithm is that a binomial 
    approximation rather than a normal approximation is used.  The
    binomial approximation is taken from the Ling and Pratt article
    (see the REFERENCE section below).

Note:
    For a number of commands utilizing the hypergeometric
    distribution, it is convenient to bin the data.  There are
    two basic ways of binning the data.

      1) For some commands (histograms, maximum likelihood
         estimation), bins with equal size widths are
         required.  This can be accomplished with the
         following commands:

            LET AMIN = MINIMUM Y
            LET AMAX = MAXIMUM Y
            LET AMIN2 = AMIN - 0.5
            LET AMAX2 = AMAX + 0.5
            CLASS MINIMUM AMIN2
            CLASS MAXIMUM AMAX2
            CLASS WIDTH 1
            LET Y2 X2 = BINNED

      2) For some commands, unequal width bins may be
         helpful.  In particular, for the chi-square goodness
         of fit, it is typically recommended that the minimum
         class frequency be at least 5.  In this case, it may
         be helpful to combine small frequencies in the tails.
         Unequal class width bins can be created with the
         commands

            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = INTEGER FREQUENCY TABLE Y

         If you already have equal width bins data, you can
         use the commands
         
            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = COMBINE FREQUENCY TABLE Y2 X2

         The MINSIZE parameter defines the minimum class
         frequency.  The default value is 5.

Note:
    You can generate hypergeometric random numbers, probability
    plots, and chi-square goodness of fit tests with the
    following commands:

       LET KK = VALUE
       LET NN = <value>
       LET MM = <value>
       LET Y = HYPERGEOMETRIC RANDOM NUMBERS FOR I = 1 1 N

       HYPERGEOMETRIC PROBABILITY PLOT Y
       HYPERGEOMETRIC PROBABILITY PLOT Y2 X2
       HYPERGEOMETRIC PROBABILITY PLOT Y3 XLOW XHIGH

       HYPERGEOMETRIC CHI-SQUARE GOODNESS OF FIT Y
       HYPERGEOMETRIC CHI-SQUARE GOODNESS OF FIT Y2 X2
       HYPERGEOMETRIC CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    In computing maximum likelihood estimates for the
    hypergeometric distribution, there are four quantities of
    interest:

       1) N  = total number of items in population
       2) n  = number of items sampled
       3) K  = number of defective items (or successes)
               in population
       4) x  = number of defectives in sample
 
     There are two distinct cases:
 
     Given that N (the population size) is known, we want to
     estimate the number of defectives in the population given a
     sample of size n with x defectives.  An example is acceptance
     sampling where the lot size is known and a subsample is choosen
     for inspection.  In this case, the maximum likelihood estimate
     of K is:
 
        K = MAX INTEGER <= x*(N+1)/n

     For this case, the data should consist of two sets of
     non-negative integers.  The first set contains the number
     of defectives in each sample.  The second set contains the
     corresponding sample size for each sample.  If the sample
     size is constant, then you may simply enter a single number.

     Note that a separate maximum likelihood estimate is returned
     for each pair of number of defectives and sample size.

     The Dataplot command for generating the maximum likelihood
     estimates for this acceptance/rejection case is

        HYPERGEOMETRIC MAXIMUM LIKELIHOOD NDEF NSAMP

     In capture/recapture problems, a sample is taken and marked.
     That is, K is known.  Then a second sample (of size n) is taken
     and the number of marked items (x) are counted.  In this case,
     the maximum likelihood estimates are:
 
         N = MAX INTEGER <= n*K/x
 
     We implement the refinement of Chapman (see page 263 of
     Johnson, Kotz, and Kemp):
 
         N* = (n+1)*(K+1)/(x+1) - 1
 
     Formulas for the variance are also given in Johnson, Kotz,
     and Kemp.
     
     For this case, the data should consist of two sets of
     non-negative integers.  The first set contains the number
     of defectives in the sample.  The second set contains the
     corresponding sample size for each sample.  If the sample
     size is constant, then you may simply enter a single number.

     Note that a separate maximum likelihood estimate is returned
     for each pair of number of defectives and sample size.

     The Dataplot command for generating the maximum likelihood
     estimates for this acceptance/rejection case is

        HYPERGEOMETRIC MAXIMUM LIKELIHOOD NDEF NSAMP

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    HYPCDF = Compute the hypergeometric cumulative distribution
             function.
    HYPPPF = Compute the hypergeometric percent point function.
    BINCDF = Compute the binomial cumulative distribution function.
    BINPDF = Compute the binomial probability mass function.
    BINPPF = Compute the binomial percent point function.
    POIPDF = Compute the Poisson probability mass function.
    POICDF = Compute the Poisson cumulative distribution function.
    POIPPF = Compute the Poisson percent point function.
    NBCDF  = Compute the negative binomial cumulative distribution
             function.
    NBPDF  = Compute the negative binomial probability mass function.
    NBPPF  = Compute the negative binomial percent point function.
    GEOCDF = Compute the geometric cumulative distribution function.
    GEOPDF = Compute the geometric probability mass function.
    GEOPPF = Compute the geometric percent point function.
 
Reference:
    "A Remark on Algorithm AS 152: Cumulative Hypergeometric 
    Probabilities", Shea, Applied Statistics Journal, Vol. 38, No. 1,
    1989.

    "Algorithm AS 152: Cumulative Hypergeometric Probabilities",
    Lund, Applied Statistics, Vol. 31 (pp. 221-223).

    "The Accuracy of Piezer Approximations to the Hypergeometric
    Distribution, with Comparisons to Some Other Approximations",
    Ling and Pratt, Journal of the American Statistical Association,
    March, 1984.

    "Statistical Distributions", 2nd Edition, Evans, Hastings, and
    Peacock, Wiley and Sons, 1993, (chapter 20).

    "Discrete Univariate Distributions", Johnson and Kotz, Wiley and
    Sons, 1970.
 
Applications:
    XX
 
Implementation Date:
    94/9
 
Program:
    XTIC OFFSET 0.5 0.5
    LINE BLANK
    SPIKE ON
    SPIKE LINE DASH
    CHARACTER CIRCLE
    CHARACTER FILL ON
    CHARACTER SIZE 1.2
    TITLE AUTOMATIC
    Y1LABEL PROBABILITY
    PLOT HYPPDF(X,100,300,1000) FOR X = 0 1 100
 
-----HYPPPF (LET)--------------------------------
 
HYPPPF
 
Name:
    HYPPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the hypergeometric percent point function.
 
Description:
    The hypergeometric distribution is the probability of selecting
    LL marked items when a random sample of size KK is taken without
    replacement from a population a population of MM items, NN of
    which are marked. Marked and unmarked items can also be thought of
    as successes and failures.  It has the probability function:
        P(x=LL) = (NN LL)*((MM-NN) (KK-LL)) / (MM KK)
    where (a b) is the combinatorial function a things taken b at a
    time and has the formula:
        (a b) = a!/(b!*(a-b)!)
    The ! symbol is the factorial function.

    The percent point function is the inverse of the cumulative
    distribution function.  The cumulative distribution sums the
    probability from 0 to the given x value.  The percent point
    function takes a cumulative probability value and computes the
    corresponding x value.
 
    The input value is a real number between 0 and 1 (since it
    corresponds to a probability).
 
Syntax:
    LET <y> = HYPPPF(<p>,<kk>,<nn>,<mm>) 
                           <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or variable in the interval
               (0,1) that specifies the desired probability;
          <kk> is a positive integer number, parameter, or variable
               that is the size of the sample;
          <nn> is a positive integer number, parameter, or variable
               that is number of marked items;
          <mm> is a positive integer number, parameter, or variable
               that is number of items in the population;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed hypergeometric cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = HYPPPF(0.9,100,300,1500)
    LET X2 = HYPPPF(P,300,100,1000)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    HYPCDF = Compute the hypergeometric cumulative distribution
             function.
    HYPPDF = Compute the hypergeometric probability mass function.
    BINCDF = Compute the binomial cumulative distribution function.
    BINPDF = Compute the binomial probability mass function.
    BINPPF = Compute the binomial percent point function.
    POIPDF = Compute the Poisson probability mass function.
    POICDF = Compute the Poisson cumulative distribution function.
    POIPPF = Compute the Poisson percent point function.
    NBCDF  = Compute the negative binomial cumulative distribution
             function.
    NBPDF  = Compute the negative binomial probability mass function.
    NBPPF  = Compute the negative binomial percent point function.
    GEOCDF = Compute the geometric cumulative distribution function.
    GEOPDF = Compute the geometric probability mass function.
    GEOPPF = Compute the geometric percent point function.
 
Reference:
    "A Remark on Algorithm AS 152: Cumulative Hypergeometric 
    Probabilities", Shea, Applied Statistics Journal, Vol. 38, No. 1,
    1989.

    "Algorithm AS 152: Cumulative Hypergeometric Probabilities",
    Lund, Applied Statistics, Vol. 31 (pp. 221-223).

    "The Accuracy of Piezer Approximations to the Hypergeometric
    Distribution, with Comparisons to Some Other Approximations",
    Ling and Pratt, Journal of the American Statistical Association,
    March, 1984.

    "Statistical Distributions", 2nd Edition, Evans, Hastings, and
    Peacock, Wiley and Sons, 1993, (chapter 20).

    "Discrete Univariate Distributions", Johnson and Kotz, Wiley and
    Sons, 1970.
 
Applications:
    XX
 
Implementation Date:
    94/9
 
Program:
    XLIMITS 0 1
    MAJOR XTIC NUMBER 6
    MINOR XTIC NUMBER 1
    XTIC DECIMAL 1
    TITLE AUTOMATIC
    X1LABEL PROBABILITY
    PLOT HYPPPF(P,100,300,1000) FOR P = 0 0.01 1
 
-------------------------------------------------------------


































































































-------------------------  *I*  ZZZZZ--------------------
 
-----I-------------------------------------------------------
 
I
 
Name:
    I
 
Type:
    Keyword
 
Purpose:
    An internal DATAPLOT variable which stands for the "dummy index"
    which is the element (row number) of a variable.
 
Description:
    The use of I arises in the FOR qualification which can be appended
    to any of the commands in the graphics or analysis categories and
    in certain support category commands.  The FOR qualification
    specifies the elements (i.e., rows) of a variable to be operated
    on.  For example, PRINT X FOR I = 1 10 1000 prints the variable X
    starting with element 1, at increments of 10 elements, and stopping
    at element 1000.  That is, it prints X(1), X(11), X(21), ...,
    X(981), X(991).  Using a variable name other than I with FOR (e.g.,
    FOR J =) can cause unpredictable results.
 
Syntax: (For all graphics/analysis commands and some support commands)
    <Command>   FOR   I    =    <i1>   <inc>   <i2>
    where <Command> is any graphics or analysis command or certain
              support commands;
          <i1> is a number or parameter that is the element/row
              designation of the first element to be operated on;
          <inc> is a number or parameter that is the increment for the
              element/row;
    and   <i2> is a number or parameter that is the element/row
              designation of the last element to be operated on.
 
Examples:
    HISTOGRAM Y FOR I = 20 1 50
    FIT (A+B*X)/(C+D*X) FOR I = 101 1 200
    SMOOTH Y FOR I = 200 1 500
    RETAIN Y FOR I = 10 10 200
    PLOT Y X FOR I = 1 1 20
    FIT Y = A+B*X SUBSET I = 100 10 500
    LET A = MEAN X FOR I = 30 1 40
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FOR     = Allows row-specification of a subset.
    SUBSET  = Allows specification of a subset.
    EXCEPT  = Allows exclusion-specification of a subset.
 
Applications:
    Data Transformation
 
Implementation Date:
    Pre-1987
 
Program:
    LET Y = NORMAL RANDOM NUMBERS FOR I = 1 1 1000
 
-----I0INT (LET)--------------------------------

I0INT

Name:
   I0INT (LET)
 
Type:
    Library Function

Purpose:
    This program computes the integral of the modified Bessel
    function I0(x).

Description:
    The I0INT function is defined as:

        I0INT(x) = {integral 0 to x} I0(t) dt    x >= 0

    with I0 denoting the modified Bessel function of the first
    kind of order 0.

    Dataplot computes this function using ACM Algorithm 757 (see
    Reference: below).  The function is computed using Chebyshev
    expansions, the coefficients of which are given to 20 decimal
    places.

Syntax:
    LET <y> = I0INT(<x>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative number, variable or parameter;
          <y> is a variable or a parameter (depending on what <x> 
               is) where the computed I0INT function values are
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = I0INT(2.3)
    PLOT I0INT(X) FOR  X = 0 .01 10
    LET X2 = I0INT(X1) FOR X1 = 0.1 0.1 3.0
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BESSI0     = Compute the modified Bessel function of the first
                 kind and order 0.
    BESSI1     = Compute the modified Bessel function of the first
                 kind and order 1.
    BESSIN     = Compute the modified Bessel function of the first
                 kind and order N.
    BESSJN     = Compute the Bessel function of the first kind and
                 order N.
    BESSKN     = Compute the modified Bessel function of the third
                 kind and order N.
    BESSYN     = Compute the Bessel function of the second kind and
    J0INT      = Compute the integral of the Bessel function of
                 the first kind and order 0.
    K0INT      = Compute the integral of the modified Bessel
                 function of the third kind and order 0.
    Y0INT      = Compute the integral of the Bessel function of
                 the second kind and order 0.
    I0ML0      = Compute the difference of the modified Bessel
                 function of the first kind of order 0 and the
                 modified Struve function of order 0.
    I1ML1      = Compute the difference of the modified Bessel
                 function of the first kind of order 1 and the
                 modified Struve function of order 1.

Reference:
    "ACM Transactions of Mathematical Software", Allan MacLead,
    Vol. 22, No. 3, September, 1996, pp. 288-301.
 
Applications:
    Special Functions
 
Implementation Date:
    2005/11
 
Program:
    TITLE I0INT FUNCTION
    PLOT I0INT(X) FOR X = 0 0.01 10
 
-----I0ML0 (LET)--------------------------------

I0ML0

Name:
   I0ML0 (LET)
 
Type:
    Library Function

Purpose:
    This program computes the difference of the modified Bessel
    function of the first kind of order 0 and the modified Struve
    function of order 0.

Description:
    The I0ML0 function is defined as:

        I0(x) - L0(x)

    with I0 and L0 denoting the modified Bessel function of the
    first kind of order 0 and the modified Struve function of
    order 0, respectively.

    Dataplot computes this function using ACM Algorithm 757 (see
    Reference: below).  The function is computed using Chebyshev
    expansions, the coefficients of which are given to 20 decimal
    places.

Syntax:
    LET <y> = I0ML0(<x>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative number, variable or parameter;
          <y> is a variable or a parameter (depending on what <x> 
               is) where the computed I0ML0 function values are
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = I0ML0(2.3)
    PLOT I0ML0(X) FOR  X = 0 .01 10
    LET X2 = I0ML0(X1) FOR X1 = 0.1 0.1 3.0
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    I1ML1      = Compute the difference of the modified Bessel
                 function of the first kind of order 1 and the
                 modified Struve function of order 1.
    J0INT      = Compute the integral of the Bessel function of
                 the first kind and order 0.
    K0INT      = Compute the integral of the modified Bessel
                 function of the third kind and order 0.
    Y0INT      = Compute the integral of the Bessel function of
                 the second kind and order 0.
    BESSIN     = Compute the modified Bessel function of the first
                 kind and order N.
    BESSJN     = Compute the Bessel function of the first kind and
                 order N.
    BESSKN     = Compute the modified Bessel function of the third
                 kind and order N.
    BESSYN     = Compute the Bessel function of the second kind and
                 order N.
    LV         = Compute the modified Struve function of order V.
    HV         = Compute the Struve function of order V.

Reference:
    "ACM Transactions of Mathematical Software", Allan MacLead,
    Vol. 22, No. 3, September, 1996, pp. 288-301.
 
Applications:
    Special Functions
 
Implementation Date:
    2005/11
 
Program:
    TITLE I0ML0 FUNCTION
    PLOT I0ML0(X) FOR X = 0 0.01 10
 
-----I1ML1 (LET)--------------------------------

I1ML1

Name:
   I1ML1 (LET)
 
Type:
    Library Function

Purpose:
    This program computes the difference of the modified Bessel
    function of the first kind of order 1 and the modified Struve
    function of order 1.

Description:
    The I1ML1 function is defined as:

        I1(x) - L1(x)

    with I1 and L1 denoting the modified Bessel function of the
    first kind of order 1 and the modified Struve function of
    order 1, respectively.

    Dataplot computes this function using ACM Algorithm 757 (see
    Reference: below).  The function is computed using Chebyshev
    expansions, the coefficients of which are given to 20 decimal
    places.

Syntax:
    LET <y> = I1ML1(<x>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative number, variable or parameter;
          <y> is a variable or a parameter (depending on what <x> 
              is) where the computed I1ML1 function values are
              stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = I1ML1(2.3)
    PLOT I1ML1(X) FOR  X = 0 .01 10
    LET X2 = I1ML1(X1) FOR X1 = 0.1 0.1 3.0
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    I0ML0      = Compute the difference of the modified Bessel
                 function of the first kind of order 0 and the
                 modified Struve function of order 0.
    J0INT      = Compute the integral of the Bessel function of
                 the first kind and order 0.
    K0INT      = Compute the integral of the modified Bessel
                 function of the third kind and order 0.
    Y0INT      = Compute the integral of the Bessel function of
                 the second kind and order 0.
    BESSIN     = Compute the modified Bessel function of the first
                 kind and order N.
    BESSJN     = Compute the Bessel function of the first kind and
                 order N.
    BESSKN     = Compute the modified Bessel function of the third
                 kind and order N.
    BESSYN     = Compute the Bessel function of the second kind and
                 order N.
    LV         = Compute the modified Struve function of order V.
    HV         = Compute the Struve function of order V.

Reference:
    "ACM Transactions of Mathematical Software", Allan MacLead,
    Vol. 22, No. 3, September, 1996, pp. 288-301.
 
Applications:
    Special Functions
 
Implementation Date:
    2005/11
 
Program:
    TITLE I1ML1 FUNCTION
    PLOT I1ML1(X) FOR X = 0 0.01 10
 
-----IBCDF (LET)--------------------------------
 
IBCDF
 
Name:
    IBCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the inverted beta cumulative distribution
    function.  This is also referred to as the beta distribution
    of the second kind or the beta prime distribution.
 
Description:
    The inverted beta distribution has the following probability
    density function:

       f(x,alpha,beta) = x**(alpha-1)/
                         [B(alpha,beta)*(1+x)**(alpha+beta)]
                         x, alpha, beta > 0

    with B denoting the beta function (HELP BETA for details).

    The inverted beta cumulative distribution function is computed
    by numerically integrating the inverted beta probability
    density function.

Syntax:
    LET <y> = IBCDF(<x>,<alpha>,<beta>)
                                <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <alpha> is a number or parameter specifying the first
               shape parameter;
          <beta> is a number or parameter specifying the second
               shape parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed inverted beta cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = IBCDF(3,2,1.5)
    LET X2 = IBCDF(X1,A,B)
    PLOT IBCDF(X,0.5,2)  FOR X = 0.01  0.01  10

Note:
    Dataplot uses the DQAGI routine from the Quadpack library
    to perform the numerical integration.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    IBPDF           = Compute the inverted beta probability density
                      function.
    IBPPF           = Compute the inverted beta percent point
                      function.
    BETPDF          = Compute the beta probability density function.
    NORPDF          = Compute the normal probability density function.
    RANDOM NUMBERS  = Generate random numbers from 60+ univariate
                      distributions.

Reference:
    "Continuous Univariate Distributions, Volume 2", Second Edition,
    Johnson, Kotz, and Balakrishnan, Wiley, 1994, p. 248.

    "Statistical Distributions", Third Edition, Evans, Hastings, and
    Peacock, Wiley, 2000.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2004/1
 
Program:
    LET ALPHA = DATA 0.5 0.5 0.5 1 1 1 2 2 2
    LET BETA = DATA 0.5 1 2 0.5 1 2 0.5 1 2
    .
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    MULTIPLOT SCALE FACTOR 3
    Y1LIMITS 0 1
    MAJOR YTIC MARK NUMBER 6
    LOOP FOR K = 1 1 9
        LET A1 = ALPHA(K)
        LET B1 = BETA(K)
        TITLE ALPHA = ^A1, BETA = ^B1
        PLOT IBCDF(X,A1,B1)  FOR X = 0.1  0.1 10
    END OF LOOP

-----IBPDF (LET)--------------------------------
 
IBPDF
 
Name:
    IBPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the inverted beta probability density function.
    This is also referred to as the beta distribution of the second
    kind or the beta prime distribution.
 
Description:
    The inverted beta distribution has the following probability
    density function:

       f(x,alpha,beta) = x**(alpha-1)/
                         [B(alpha,beta)*(1+x)**(alpha+beta)]
                         x, alpha, beta > 0

    with B denoting the beta function (HELP BETA for details).

Syntax:
    LET <y> = IBPDF(<x>,<alpha>,<beta>)
                                <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <alpha> is a number or parameter specifying the first
               shape parameter;
          <beta> is a number or parameter specifying the second
               shape parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed inverted beta pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = IBPDF(3,2,1.5)
    LET X2 = IBPDF(X1,A,B)
    PLOT IBPDF(X,0.5,2)  FOR X = 0.01  0.01  10

Note:
    You can generate random numbers from an inverted beta
    distribution with the following command:

        LET ALPHA = <value>
        LET BETA = <value>
        LET Y = INVERTED BETA RANDOM NUMBERS FOR I = 1 1 N

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    IBCDF           = Compute the inverted beta cumulative
                      distribution function.
    IBPPF           = Compute the inverted beta percent point
                      function.
    BETPDF          = Compute the beta probability density function.
    NORPDF          = Compute the normal probability density function.
    RANDOM NUMBERS  = Generate random numbers from 60+ univariate
                      distributions.

Reference:
    "Continuous Univariate Distributions, Volume 2", Second Edition,
    Johnson, Kotz, and Balakrishnan, Wiley, 1994, p. 248.

    "Statistical Distributions", Third Edition, Evans, Hastings, and
    Peacock, Wiley, 2000.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2003/5
 
Program:
    LET ALPHA = DATA 0.5 0.5 0.5 1 1 1 2 2 2
    LET BETA = DATA 0.5 1 2 0.5 1 2 0.5 1 2
    .
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    MULTIPLOT SCALE FACTOR 3
    LOOP FOR K = 1 1 9
        LET A1 = ALPHA(K)
        LET B1 = BETA(K)
        TITLE ALPHA = ^A1, BETA = ^B1
        PLOT IBPDF(X,A1,B1)  FOR X = 0.01  0.01 10
    END OF LOOP

-----IBPPF (LET)--------------------------------
 
IBPPF
 
Name:
    IBPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard inverted beta cumulative distribution
    function.  This is also referred to as the beta distribution
    of the second kind or the beta prime distribution.
 
Description:
    The standard inverted beta distribution has the following
    probability density function:

       f(x,alpha,beta) = x**(alpha-1)/
                         [B(alpha,beta)*(1+x)**(alpha+beta)]
                         x, alpha, beta > 0

    with B denoting the beta function (HELP BETA for details).

    The inverted beta cumulative distribution function is computed
    by numerically integrating the inverted beta probability
    density function.  The percent point function is computed
    by numerically inverting the cumulative distribution function.

Syntax:
    LET <y> = IBPPF(<p>,<alpha>,<beta>)
                                <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, a number, or a parameter in the
               range [0,1];
          <alpha> is a number or parameter specifying the first
               shape parameter;
          <beta> is a number or parameter specifying the second
               shape parameter;
          <y> is a variable or a parameter (depending on what <p> is)
               where the computed inverted beta ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = IBPPF(0.95,2,1.5)
    LET X2 = IBPPF(P1,A,B)
    PLOT IBPPF(P,0.5,2)  FOR P = 0.01  0.01  0.99

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    IBPPF           = Compute the inverted beta cumulative
                      distribution function.
    IBPDF           = Compute the inverted beta probability density
                      function.
    BETPDF          = Compute the beta probability density function.
    NORPDF          = Compute the normal probability density function.
    RANDOM NUMBERS  = Generate random numbers from 60+ univariate
                      distributions.

Reference:
    "Continuous Univariate Distributions, Volume 2", Second Edition,
    Johnson, Kotz, and Balakrishnan, Wiley, 1994, p. 248.

    "Statistical Distributions", Third Edition, Evans, Hastings, and
    Peacock, Wiley, 2000.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2004/1
 
Program:
    LET ALPHA = DATA 0.5 0.5 0.5 1 1 1 2 2 2
    LET BETA = DATA 0.5 1 2 0.5 1 2 0.5 1 2
    .
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    MULTIPLOT SCALE FACTOR 3
    TITLE AUTOMATIC
    LOOP FOR K = 1 1 9
        LET A = ALPHA(K)
        LET B = BETA(K)
        PLOT IBPPF(P,^A,^B)  FOR P = 0.01 0.01 0.99
    END OF LOOP
    END OF MULTIPLOT

-----ICHAR-----------------------------------------------------
 
ICHAR
 
Name:
    ICHAR
 
Type:
    Let Subcommand
 
Purpose:
    Return the ASCII collating sequence index of the characters in a
    previously defined string.
 
Description:
    Most modern computer platforms use the ASCII collating sequence
    to code characters.  In the ASCII collating sequence, the
    integers 0 to 255 are used to represent specific characters.
    Specifically

        1) 48 - 57  denote the digits 0 to 9
        2) 65 - 90  denote the upper case characters A to Z
        3) 97 - 122 denote the lower case characters a to z

    The other values represent special characters such as quotes
    and ampersands or non-printing characters such as tabs, 
    carriage returns, or line feeds.

    This command allows you to generate the integer index
    corresponding to each character in a previously defined
    string.

Syntax:
    LET <ival> = ICHAR  <sorg>
    where <ival> is a parameter or variable containing the ASCII
             collating sequence index values;
    and   <sorg> is a previously defined string.
 
    If <ival> was previously defined as a parameter, only the
    value corresponding to the first character in <sorg> is
    returned.  If <ival> was previously defined as a variable,
    then values corresponding to all characters in <sorg> are
    returned.  If <ival> was previously defined as something
    other than a parameter or a variable, then an error is
    printed.

    If <ival> was not previously defined, then it will saved as
    a parameter if <sorg> has only one character and it will be
    saved as a variable if <sorg> has more than one character.

Examples:
    LET IVAL = ICHAR S1
 
Note:
    The string on the right hand side of the equal sign must be a
    previously defined string.  String expressions are not allowed.
    So

        LET IVAL = ICHAR ".dat"

    should be coded as

        LET STRING S1 = .dat
        LET IVAL = ICHAR S1

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHARACTER (LET)     = Convert numeric values to strings based on
                          the ASCII collating sequence.
    LET FUNCTION        = Defines a function.
    LET STRING          = Defines a string.
    READ STRING         = Reads a string from a file.
    SUBSTITUTE CHARACTE = Substitute the value of a string or parameter.
    &                   = Concatenate two strings.
    SUBTRING            = Extract a substring from an existing string.
    STRING LENGTH       = Return the length of a string.
    STRING INDEX        = Return the start and stop positions of a 
                          substring within a string.
    STRING CONCATENATE  = Concatenate one or more previously defined
                          strings.
    STRING EDIT         = Edit a string.
    STRING MERGE        = Insert a string into another string without
                          overwrite.
    STRING REPLACE      = Insert a string into another string with
                          overwrite.
    LOWER CASE          = Convert a string to lower case.
    UPPER CASE          = Convert a string to upper case.
    GROUP LABEL         = Define the text for group labels.
 
Applications:
    Data Management
 
Implementation Date:
    2008/11
 
Program:
    LET STRING S1 = file23.dat
    LET IVAL = ICHAR S1

    The resulting values of IVAL are 102, 105, 108, 101, 50, 51,
    46, 100, 97, and 116.

-----IF----------------------------------------------------------
 
IF
 
Name:
    IF
 
Type:
    Support Command
 
Purpose:
    Define the start of a conditional block.
 
Description:
    The IF command tests a condition, if the condition is true, execute
    the following commands until an END OF IF is reached.  If the
    condition is false, skip the following commands.
 
    The following logical operators are used to compare two parameters

        =           - equal to
        >           - greater than
        <           - less than
        <>          - not equal to
        >=          - greater than or equal to
        <=          - less than or equal to

    The following can be used to test for the existence (or
    non-existence) of a parameter

        EXISTS      - check if the parameter exists
        NOT EXIST   - check if the parameter does not exist

    In addition, you can use AND, OR, and XOR to combine testing for two
    or more (up to 10) conditions.  With AND, the result is true if both
    conditions are true and false otherwise.  With OR, the result is true
    if either, or both, conditions are true and false if both conditions
    are false.  With XOR, the result is true if either, but not both, of
    the conditions are true and false otherwise.

    Note that the AND, OR, and XOR clause are evaluated pairwise left to
    right.  Currently, the use of parenthesis to group clauses is not
    supported.  For example,

        IF A = 2 AND B = 5 OR C > 10

    is evaluated as follows

       1. The A = 2 part is evaluated and set to either true or false.

       2. The B = 5 part is evalueated and set to either true or false.

       3. The AND operator is applied to these two pieces.  So the
          A = 2 AND B = 5 is set to true if both are true and false
          otherwise.

       4. The C > 10 part is evaluated and set to either true or false.

       5. The OR operator is then applied to "A = 2 AND B = 5" and
          "C > 10".  If either of these is true, the final result is true.
          Otherwise the final result is false.

    However, you cannot use

       IF A = 2 AND (B = 5 OR C > 10)

    This would need to be coded as

       IF B = 5 OR C > 10 AND A = 2

    The NOT clause can be used to negate the result.  That is, if
    the condition is true, the NOT will result in a false condition.
    Likewise, if the condition is false, the NOT will result in a
    true condition.

Syntax 1:
    IF  <par1>  <log> <par2>
    where <par1> is a number or parameter;
          <log> is a logical operator (=, <>, <, >, <=, >=) that defines
              the comparison between the two parameters;
    and   <par2> is a number or parameter.

    That is, this syntax is used to compare two parameters (or numbers)
    and determine whether the expression is true or false.

    Strings can be used with the "=" and "<>" operators, but not the
    others.

    This is most basic and most common use of the IF command.

Syntax 2:
    IF  NOT <par1>  <log> <par2>
    where <par1> is a number or parameter;
          <log> is a logical operator (=, <>, <, >, <=, >=) that defines
              the comparison between the two parameters;
    and   <par2> is a number or parameter.

    This is similar to Syntax 1.  The distinction is that it reverses the
    result.  That is, if the <par1> <log> <par2> condition is evaluated
    as true, the final result is false.  Likewise, if the <par1> <log>
    <par2> condition is evaluated as false, the final result is true.

    Strings can be used with the "=" and "<>" operators, but not the
    others.

Syntax 3:
    IF  <name>  EXISTS
    where <name> is the name being tested.

    This syntax is used to determine whether <name> exists in the Dataplot
    name table.  It returns true if <name> is found in the name table and
    false if it is not.
 
Syntax 4:
    IF  <name>  NOT EXISTS
    where <name> is the name being tested.

    This syntax is used to determine whether <name> exists in the Dataplot
    name table.  It returns true if <name> is not found in the name table and
    false if it is found in the name table.
 
Syntax 5:
    IF  <par1>  <log1> <par2>  <AND/OR/XOR> <par3> <log2> <par4>
    where <par1> is a number or parameter;
          <log1> is a logical operator (=, <>, <, >, <=, >=) that defines
              the comparison between the two parameters;
          <par2> is a number or parameter.
          <par3> is a number or parameter;
          <log2> is a logical operator (=, <>, <, >, <=, >=) that defines
              the comparison between the two parameters;
    and   <par4> is a number or parameter.

    The two conditions <par1> <log1> <par2> and <par3> <log2> <par4> are
    evaluated separately.  The two results are then combined based on
    the AND, OR, or XOR clause.

    If the AND clause is used, then the final result is true if both
    conditions are true and false otherwise.

    If the OR clause is used, then the final result is true if either
    condition, or both, are true and false otherwise.

    If the XOR clause is used, then the final result is true if one of
    the conditions is true and the other is false.  If both conditions
    are true or both conditions are false, the final result is false.

    Strings can be used with the "=" and "<>" operators, but not the
    others.

    The AND, OR, and XOR can also be used with Syntax 2, Syntax 3, and
    Syntax 4.

    The capability to have more than one AND, OR or XOR clause was added
    for the 2018/02 version.  Up to 10 clauses may be entered.

Syntax 6:
    IF  COMMAND LINE ARGUMENT <name>  EXISTS
    where <name> is the name being tested.

    Dataplot supports named arguments with the CALL command (see HELP
    MACRO SUBSTITUTION CHARACTER for details).  This syntax is used to
    determine whether <name> is a currently defined argument on the CALL
    command.  If <name> exists, the IF status is set to true.  Otherwise
    it is set to false.
 
Syntax 7:
    IF  COMMAND LINE ARGUMENT <name>  NOT EXISTS
    where <name> is the name being tested.

    Dataplot supports named arguments with the CALL command (see HELP
    MACRO SUBSTITUTION CHARACTER for details).  This syntax is used to
    determine whether <name> is a currently defined argument on the CALL
    command.  If <name> does not exist, the IF status is set to true.
    Otherwise it is set to false.
 
Syntax 8:
    LET  <par1> = <expr> IF <par2> <log> <par3>
    where <expr> is an arithmetic expression;
          <par2> is a number or parameter;
          <log> is a logical operator (=, <>, <, >, <=, >=) that defines
              the comparison between the two parameters;
          <par3> is a number or parameter;
    and where <par1> is a paremeter where the result of <expr> is stored.

    This syntax allows conditional execution of an arithmetic expression.
    For example,

        LET A = B/A  IF A > 0

    Note that this is limited to arithmetic expressions, so commands like
    the following are not supported

        LET A = MEAN Y  IF IFLAG = 1
        LET Y2 = CODE Y  IF IFLAG = 1

Examples:
    IF A = B
    IF A > 2
    IF A < 2
    IF A <> 2
    IF A NOT EXIST
    IF A >= 2
    IF A <= 2

    IF A > 2 AND B < 5
    IF A = 2 AND B < 5
    IF A = 2 OR B = 6
    IF A EXISTS AND A > 1
 
    LET A = B IF B > 0

Note:
    The following

        IF A B

    is equivalent to

        IF A = B

    Although this syntax is allowed, it is recommended that the "=" be
    included.

Note:
    IF commands can be nested to a level of 10 deep (this capability
    was added November, 1992 so earlier versions do not work properly).
 
Note:
    IF blocks can be embedded within LOOP blocks and LOOP blocks can be
    embedded within IF blocks.
 
Note:
    The IF command has the following limitations.

    1) There is no ELSE clause with this IF command.
  
    
       Note: Support for ELSE and ELSE IF clauses was implemented 7/2002.
       For example,

          IF A = 0
             LET B = 0
          ELSE IF A > 0
             LET B = C/A
          ELSE
             LET B = 0
             PRINT "A < 0"
          END OF IF

    2) Expressions are not allowed on the IF.  The following code

          IF A+B < 10

       should be written as

          LET C = A+B
          IF C < 10

    3) There is no way to branch out of an IF block from within the
       block.  This is typically only an issue when IF and LOOP blocks
       are nested.
 
Note:
    If there is an error on the IF command (e.g., one of the
    parameters is undefined), the IF command returns a status
    of FALSE.

    This was implemented 7/1999.  Previous versions left the
    status undefined.

Note:
    You can now test for strings with the IF command.  That is,

      LET STRING S = TEST
      IF S = TEST
         PRINT S
      END OF IF

      LET STRING S = TEST
      IF S <> "NOT TEST"
         PRINT S
      ENDS OF IF

    Note that "=" and "<>" are the only comparisons allowed (i.e.,
    no "<" or ">").

    Note: The 2018/10 version added the following

             IF S1 <  S2
             IF S1 <= S2
             IF S1 >  S2
             IF S1 >= S2

          where S1 and S2 are pre-defined strings.  The comparison is
          based on the ASCII coding sequence (so "A" is less than "a"
          and "C" is less than  "b").  The comparison is performed left
          to right.  If one string is shorter than the other, the shorter
          string will return 0 for the ASCII code when its length has been
          exceeded.  This syntax does not currently work with literal
          strings.

    The argument on the left of the "=" must be the name of a
    previously defined string.  The argument to the right of the
    "=" is a literal string.  The string can be enclosed in
    dooble quotes if it contains spaces.  If there are no
    double quotes, the string is assumed to end once the first
    space is encountered.

    The 2014/11 version modified this so that the right hand side
    can now be the name of a previously defined string as well as
    a literal string.

    The 2018/05 version modified this so that the left hand side
    can supported literal strings.  Note that literal strings on
    the left hand side must be enclosed in quotes.  For example,
    the following are now all supported (S and T are assumed to be
    pre-defined strings)

        IF S = T
        IF "xxxx" = T
        IF S = "xxxx"
        IF "xxxx" = "xxxx"

    However, be aware that the following may not be interpeted
    as expected

        IF U = U

    This is not doing a string comparison.  It is checking to see
    if U is the name of a parameter or string.  If U does not exist,
    the IF status is set to false.  If U does exist as a parameter
    or string, the IF status will be set to true.  So effectively,
    this is equilavent to

       IF U EXISTS

    Also, when testing strings, a string containing a single blank
    character is considered equal to a string with zero characters.
    That is,

         IF " " = ""

    will evaluate to true.

Note:
    The 2018/05 version added support for

        IF 3 > 2
        IF 3 > A

    That is, the left hand side can now be a number as well as a
    parameter (previous versions already supported numbers on the
    right hand side).  An example of where this can be useful is

        IF $0 > 0

    The $0 returns the number of command line arguments for a macro.  The
    $0 is evaluated before the IF command is processed, so the IF command
    would in fact see something like

       IF 2 > 0

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    END OF IF      = Terminate an IF block.
    LOOP           = Initiate a loop.
 
Applications:
    Program Control
 
Implementation Date:
    Pre-1987
    2002/07: Support for ELSE clause
    2002/07: Support for testing strings
    2014/11: When comparing strings, allow right hand side to
             be a previously defined string
    2016/10: Support for IF COMMAND LINE ARGUMENT ... EXISTS
    2016/10: Support for NOT
    2016/10: Support for AND, OR, and XOR
    2018/02: AND, OR, and XOR extended to up to 10 clauses
    2018/02: For IF A = ..., when A does not exist set IF status to
             false but do not treat as an error
    2018/05: Support numeric value for left hand side (e.g., IF A > 2)
    2018/05: Support quoted literal string for left hand side
             (e.g., IF "xxxx" = xxxxx)
    2018/05: Support for IF COMMAND LINE ARGUMENT ... NOT EXIST
    2018/05: Better feedback for special cases
    2018/10: "<", "<=", ">", ">=" support for strings
 
Program 1:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET A = Y1(10)
    IF A < 0
      LET Y1(10)=ABS(A)
    END OF IF
 
Program 2:
    let a = 3
    let b = 5
    .
    if a = 3 and b = 5
       print "AND Syntax Both True: True"
    else
       print "AND Syntax Both True: False"
    end of if
    pause
    .
    if a = 3 and b = 2
       print "AND Syntax A True, B False: True"
    else
       print "AND Syntax A True, B False: False"
    end of if
    pause
    .
    if a = 3 or b = 5
       print "OR Syntax Both True: True"
    else
       print "OR Syntax Both True: False"
    end of if
    pause
    .
    if a = 3 or b = 2
       print "OR Syntax A True, B False: True"
    else
       print "OR Syntax A True, B False: False"
    end of if
    pause
    .
    if a = 1 or b = 5
       print "OR Syntax A False, B True: True"
    else
       print "OR Syntax A False, B True: False"
    end of if
    pause
    .
    if a = 1 or b = 2
       print "OR Syntax A False, B False: True"
    else
       print "OR Syntax A False, B False: False"
    end of if
    pause
    .
    if a = 3 xor b = 5
       print "XOR Syntax Both True: True"
    else
       print "XOR Syntax Both True: False"
    end of if
    pause
    .
    if a = 3 xor b = 2
       print "XOR Syntax A True, B False: True"
    else
       print "XOR Syntax A True, B False: False"
    end of if
    pause
    .
    if a = 1 xor b = 5
       print "XOR Syntax A False, B True: True"
    else
       print "XOR Syntax A False, B True: False"
    end of if
    pause
    .
    if a = 1 xor b = 2
       print "XOR Syntax A False, B False: True"
    else
       print "XOR Syntax A False, B False: False"
    end of if

-----IGACDF (LET)--------------------------------
 
IGACDF
 
Name:
    IGACDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the the inverted gamma cumulative distribution
    function.
 
Description:
    The standard form of the generalized gamma distribution
    has the following cumulative disribution function:
       F(x,k,c) = GAMMAI(x**c,k)/GAMMA(k)   x > 0, k > 0, c <> 0
    where GAMMA is the complete gamma function and GAMMAI is the
    incomplete gamma function. 
 
    The inverted gamma is the special case where the second
    shape parameter, c, is equal to -1.

Syntax:
    LET <y2> = IGACDF(<y1>,<k>,<loc>,<scale>)
                               <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a positive number, parameter, or a variable;
          <y2> is a variable or a parameter (depending on what <y1>
               is) where the computed inverted gamma cdf value is
               saved;
          <k> is a positive number, parameter, or variable that
               specifies the first shape parameter;
          <loc> is a number, parameter, or variable that defines
               the location parameter;
          <scale> is a number, parameter, or variable that defines
               the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    The location and scale parameters are optional.

Examples:
    LET A = IGACDF(3,1.5)
    LET Y = IGACDF(X,1.5)
    LET Y = IGACDF(X,1.5,10,2)
    PLOT IGACDF(X,1.5,10,2) FOR X = 5 0.1 15

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    IGAPDF = Compute the inverted gamma probability density
             function.
    IGAPPF = Compute the inverted gamma percent point function.
    GGDCDF = Compute the generalized gamma cumulative distribution
             function.
    GGDPDF = Compute the generalized gamma probability density
             function.
    GGDPPF = Compute the generalized gamma percent point function.
    GAMCDF = Compute the gamma cumulative distribution function.
    GAMPDF = Compute the gamma probability density function.
    GAMPPF = Compute the gamma percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    EXPCDF = Compute the exponential cumulative distribution
             function.
    EXPPDF = Compute the exponential probability density function.
    EXPPPF = Compute the exponential percent point function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
 
Reference:
    "Continuous Univariate Distributions", 2nd. ed., Johnson, Kotz, 
    and Balakrishnan, John Wiley and Sons, 1994 (chapter 17).
 
    "Statistical Distributions", 2nd. Edition, Evans, Hastings, and
    Peacock, Wiley and Sons, 1993 (chapter 18).

Applications:
    Reliability
 
Implementation Date:
    1998/5
 
Program:
    LET G = DATA 0.5 1 2 5
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LOOP FOR K = 1 1 4
       LET G1 = G(K)
       X1LABEL GAMMA = ^G1
       PLOT IGACDF(X,G1) FOR X = 0.1 0.1 10
    END OF LOOP
    END OF MULTIPLOT
 
-----IGACHAZ (LET)--------------------------------
 
IGACHAZ
 
Name:
    IGACHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the inverted gamma cumulative
    hazard function.
 
Description:
    The standard form of the inverted gamma cumulative hazard
    function is:
       H(x,gamma) = -LOG[1 - IGACDF(x,gamma)]   x, gamma > 0
    where gamma is the shape parameter and IGACDF is the cumulative
    distribution functions of the inverted gamma distribution.
 
    The inverted gamma is a special case of the generalized gamma
    distribution where the second shape parameter is equal to -1.

Syntax:
    LET <y> = IGACHAZ(<x>,<gamma>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a positive number, parameter, or a variable;
          <y> is a variable or a parameter (depending on what <x>
               is) where the computed inverted gamma cumulative
               hazard value is saved;
          <gamma> is a positive number, parameter, or variable that
               specifies the shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = IGACHAZ(3,1.5)
    LET Y = IGACHAZ(X,1.5)
    PLOT IGACHAZ(X,1.5) FOR X = 5 0.1 15
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    IGACDF  = Compute the inverted gamma cumulative distribution
              function.
    IGAPDF  = Compute the inverted gamma probability density function.
    IGAPPF  = Compute the inverted gamma percent point function.
    GGDPDF  = Compute the generalized gamma probability density
              function.
    GAMPDF  = Compute the gamma probability density function.
    WEIPDF  = Compute the Weibull probability density function.
    EXPPDF  = Compute the exponential probability density function.
    CHSPDF  = Compute the chi-square probability density function.
 
Reference:
    "Continuous Univariate Distributions", 2nd. ed., Johnson, Kotz, 
    and Balakrishnan, John Wiley and Sons, 1994 (chapter 17).
 
    "Statistical Distributions", 2nd. Edition, Evans, Hastings, and
    Peacock, Wiley and Sons, 1993 (chapter 18).

Applications:
    Reliability
 
Implementation Date:
    1998/5
 
Program:
    LET G = DATA 0.5 1 2 5
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LOOP FOR K = 1 1 4
       LET G1 = G(K)
       X1LABEL GAMMA = ^G1
       PLOT IGACHAZ(X,G1) FOR X = 0.1 0.1 10
    END OF LOOP
    END OF MULTIPLOT
 
-----IGAHAZ (LET)--------------------------------
 
IGAHAZ
 
Name:
    IGAHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the inverted gamma hazard
    function.
 
Description:
    The standard form of the inverted gamma hazard function is:
       h(x,gamma) = IGAPDF(x,gamma)/(1-IGACDF(x,gamma))   x, gamma > 0
    where gamma is the shape parameter and IGAPDF and IGACDF are the
    probability density and cumulative distribution functions of the
    inverted gamma distribution.
 
    The inverted gamma is a special case of the generalized gamma
    distribution where the second shape parameter is equal to -1.

Syntax:
    LET <y> = IGAHAZ(<x>,<gamma>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a positive number, parameter, or a variable;
          <y> is a variable or a parameter (depending on what <x>
               is) where the computed inverted gamma hazard value is
               saved;
          <gamma> is a positive number, parameter, or variable that
               specifies the shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = IGAHAZ(3,1.5)
    LET Y = IGAHAZ(X,1.5)
    PLOT IGAHAZ(X,1.5) FOR X = 5 0.1 15
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    IGACDF  = Compute the inverted gamma cumulative distribution
              function.
    IGAPDF  = Compute the inverted gamma probability density function.
    IGAPPF  = Compute the inverted gamma percent point function.
    GGDPDF  = Compute the generalized gamma probability density
              function.
    GAMPDF  = Compute the gamma probability density function.
    WEIPDF  = Compute the Weibull probability density function.
    EXPPDF  = Compute the exponential probability density function.
    CHSPDF  = Compute the chi-square probability density function.
 
Reference:
    "Continuous Univariate Distributions", 2nd. ed., Johnson, Kotz, 
    and Balakrishnan, John Wiley and Sons, 1994 (chapter 17).
 
    "Statistical Distributions", 2nd. Edition, Evans, Hastings, and
    Peacock, Wiley and Sons, 1993 (chapter 18).

Applications:
    Reliability
 
Implementation Date:
    1998/5
 
Program:
    LET G = DATA 0.5 1 2 5
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LOOP FOR K = 1 1 4
       LET G1 = G(K)
       X1LABEL GAMMA = ^G1
       PLOT IGAHAZ(X,G1) FOR X = 0.1 0.1 10
    END OF LOOP
    END OF MULTIPLOT
 
-----IGAPDF (LET)--------------------------------
 
IGAPDF
 
Name:
    IGAPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the inverted gamma probability
    density function.
 
Description:
    The standard form of the generalized gamma distribution
    has the following probability density function:
       f(x,k,c) = c*x**(kc-1)*EXP(-x**c)/GAMMA(k)  x>0, k>0, c<>0
    where k and c are shape parameters and GAMMA is the complete
    gamma function.
 
    The inverted gamma is the special case where the second
    shape parameter, c, is equal to -1.

Syntax:
    LET <y2> = IGAPDF(<y1>,<k>,<loc>,<scale>)
                               <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a positive number, parameter, or a variable;
          <y2> is a variable or a parameter (depending on what <y1>
               is) where the computed inverted gamma pdf value is
               saved;
          <k> is a positive number, parameter, or variable that
               specifies the first shape parameter;
          <loc> is a number, parameter, or variable that defines
               the location parameter;
          <scale> is a number, parameter, or variable that defines
               the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The location and scale parameters are optional.

Examples:
    LET A = IGAPDF(3,1.5)
    LET Y = IGAPDF(X,1.5)
    LET Y = IGAPDF(X,1.5,10,2)
    PLOT IGAPDF(X,1.5,10,2) FOR X = 5 0.1 15
 
Note:
    The general form of the generalized gamma distribution is:
       f(x,k,c,a,b) = c*(x-a)**(kc-1)*EXP(-((x-a)/b)**c)/[b**(k*c)*
                      GAMMA(k)]     x > 0, k > 0, c <>0, a > 0, b > 0
    The parameter a is a location parameter and the parameter b is a
    scale parameter.  For the inverted gamma distribution,
    c = -1.  The IGAPDF function allows the location and scale
    parameters to optionally be specified.
 
Note:
    To generate an inverted gamma probability plot, enter
    the following commands.

        LET GAMMA = &lt;value&gt; <br>
        INVERTED GAMMA PROBABILITY PLOT <br>

    To generate an inverted gamma ppcc plot, enter
    the following commands.

        LET GAMMA = &lt;value&gt; <br>
        INVERTED GAMMA PPCC PLOT <br>

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    IGACDF = Compute the inverted gamma cumulative distribution
             function.
    IGAPPF = Compute the inverted gamma percent point function.
    GGDCDF = Compute the generalized gamma cumulative distribution
             function.
    GGDPDF = Compute the generalized gamma probability density
             function.
    GGDPPF = Compute the generalized gamma percent point function.
    GAMCDF = Compute the gamma cumulative distribution function.
    GAMPDF = Compute the gamma probability density function.
    GAMPPF = Compute the gamma percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    EXPCDF = Compute the exponential cumulative distribution
             function.
    EXPPDF = Compute the exponential probability density function.
    EXPPPF = Compute the exponential percent point function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
 
Reference:
    "Continuous Univariate Distributions", 2nd. ed., Johnson, Kotz, 
    and Balakrishnan, John Wiley and Sons, 1994 (chapter 17).
 
    "Statistical Distributions", 2nd. Edition, Evans, Hastings, and
    Peacock, Wiley and Sons, 1993 (chapter 18).

Applications:
    Reliability
 
Implementation Date:
    1998/5
 
Program:
    LET G = DATA 0.5 1 2 5
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LOOP FOR K = 1 1 4
       LET G1 = G(K)
       X1LABEL GAMMA = ^G1
       PLOT IGAPDF(X,G1) FOR X = 0.1 0.1 10
    END OF LOOP
    END OF MULTIPLOT
 
-----IGAPPF (LET)--------------------------------
 
IGAPPF
 
Name:
    IGAPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the the inverted gamma percent point function.
 
Description:
    The standard form of the generalized gamma distribution
    has the following cumulative disribution function:
       F(x,k,c) = GAMMAI(x**c,k)/GAMMA(k)   x > 0, k > 0, c <> 0
    where GAMMA is the complete gamma function and GAMMAI is the
    incomplete gamma function. 
 
    The percent point function is the inverse of the cumulative
    distribution function.  The cumulative distribution sums the
    probability from 0 to the given x value (i.e., the integral
    of the above function).  The percent point function takes
    a cumulative probability value and computes the corresponding
    x value.
 
    The inverted gamma is the special case where the second
    shape parameter, c, is equal to -1.

Syntax:
    LET <y> = IGAPPF(<p>,<k>,<loc>,<scale>)
                               <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or a variable in the range
               0 to 1;
          <y> is a variable or a parameter (depending on what <p>
               is) where the computed inverted gamma ppf value is
               saved;
          <k> is a positive number, parameter, or variable that
               specifies the first shape parameter;
          <loc> is a number, parameter, or variable that defines
               the location parameter;
          <scale> is a number, parameter, or variable that defines
               the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    The location and scale parameters are optional.

Examples:
    LET A = IGAPPF(0.95,1.5)
    LET Y = IGAPPF(X,1.5)
    LET Y = IGAPPF(X,1.5,10,2)
    PLOT IGAPPF(P,1.5,10,2) FOR P = 0.01 0.01 0.99

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    IGACDF = Compute the inverted gamma cumulative distribution
             function.
    IGAPDF = Compute the inverted gamma probability density
             function.
    GGDCDF = Compute the generalized gamma cumulative distribution
             function.
    GGDPDF = Compute the generalized gamma probability density
             function.
    GGDPPF = Compute the generalized gamma percent point function.
    GAMCDF = Compute the gamma cumulative distribution function.
    GAMPDF = Compute the gamma probability density function.
    GAMPPF = Compute the gamma percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    EXPCDF = Compute the exponential cumulative distribution
             function.
    EXPPDF = Compute the exponential probability density function.
    EXPPPF = Compute the exponential percent point function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
 
Reference:
    "Continuous Univariate Distributions", 2nd. ed., Johnson, Kotz, 
    and Balakrishnan, John Wiley and Sons, 1994 (chapter 17).
 
    "Statistical Distributions", 2nd. Edition, Evans, Hastings, and
    Peacock, Wiley and Sons, 1993 (chapter 18).

Applications:
    Reliability
 
Implementation Date:
    1998/5
 
Program:
    LET G = DATA 1 2 5 10
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LOOP FOR K = 1 1 4
       LET G1 = G(K)
       X1LABEL GAMMA = ^G1
       PLOT IGAPPF(P,G1) FOR P = 0.05 0.01 0.95
    END OF LOOP
    END OF MULTIPLOT
 
-----IGCDF (LET)--------------------------------
 
IGCDF
 
Name:
    IGCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the inverse Gaussian cumulative distribution function
    with shape parameters gamma and mu.
 
Description:
    The  inverse Gaussian distribution has the following cumulative
    distribution function:

       F(x;gamma,mu) = NORCDF[SQRT(gamma/x)*((x/mu) - 1)] +
                       EXP(2*gamma/mu)*NORCDF[-SQRT(gamma/x)*((x/mu) + 1)]
                       x >= 0; gamma, mu > 0

    with gamma and mu denoting the shape parameters and NORCDF
    denoting the cumulative distribution function of the standard
    normal distribution.

    The inverse Gaussian distribution can be generalized with
    location and scale parameters in the usual way.

Syntax:
    LET <y> = IGCDF(<x>,<gamma>,<mu>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable or a parameter;
          <gamma> is number or parameter that specifies the first
              shape parameter;
          <mu> is number or parameter that specifies the second
              shape parameter;
          <loc> is number or parameter that specifies the location
              parameter;
          <scale> is number or parameter that specifies the scale
              parameter;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed inverse Gaussian cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    Note that the location and scale parameters are optional.

Examples:
    LET A = IGCDF(3,2,1)
    LET A = IGCDF(A1,2,1)
    LET X2 = IGCDF(X1,2,3)
    PLOT IGCDF(X,2,1.5) FOR X = 0.1  0.1  5
 
Note:
    The case where mu = 1 is referred to as the Wald distribution.
    Enter HELP WALPDF for details.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    IGCHAZ = Compute the inverse Gaussian cumulative hazard
             function.
    IGHAZ  = Compute the inverse Gaussian hazard function.
    IGPDF  = Compute the inverse Gaussian probability density
             function.
    IGPPF  = Compute the inverse Gaussian percent point function.
    CHSPDF = Compute the chi-square probability density function.
    FPDF   = Compute the F probability density function.
    NORPDF = Compute the normal probability density function.
    TPDF   = Compute the t probability density function.
    WEIPDF = Compute the Weibull probability density function.
    WALPDF = Compute the Wald probability density function.
    FLPDF  = Compute the fatigue life probability density function.
    RIGPDF = Compute the reciprocal inverse Gaussian probability
             density function.

Reference:
    "Continuous Univariate Distributions--Volume 1", Second Edition,
    Johnson, Kotz, and Balakrishnan, Wiley, 1994, chapter 15.

    "Statistical Distributions", Third Edition, Evans, Hastings,
    and Peacock, Wiley, 2000, pp. 114-116.

Applications:
    Distributional Modeling
 
Implementation Date:
    1990/5: Original implementation
    2003/12: Modified to treat mu as a shape parameter instead of
             a location parameter
 
Program:
    Y1LABEL Probability
    X1LABEL X
    LABEL CASE ASIS
    X1LABEL DISPLACEMENT 12
    Y1LABEL DISPLACEMENT 12
    MULTIPLOT SCALE FACTOR 2
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    TITLE GAMMA = 2, MU = 1
    PLOT IGCDF(X,2,1) FOR X = 0.01  0.01  5
    TITLE GAMMA = 5, MU = 1
    PLOT IGCDF(X,5,1) FOR X = 0.01  0.01  5
    TITLE GAMMA = 2, MU = 2
    PLOT IGCDF(X,2,2) FOR X = 0.01  0.01  5
    TITLE GAMMA = 5, MU = 2
    PLOT IGCDF(X,5,2) FOR X = 0.01  0.01  5
    END OF MULTIPLOT
    JUSTIFICATION CENTER
    MOVE 50 97
    CASE ASIS
    TEXT Inverse Gaussian CDF

-----IGCHAZ (LET)--------------------------------
 
IGCHAZ
 
Name:
    IGCHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the inverse Gaussian cumulative hazard function
    with shape parameters gamma and mu.
 
Description:
    The  inverse Gaussian distribution has the following cumulative
    hazard function:

       H(x;gamma,mu) = -LOG[1 - IGCDF(x;gamma,mu)]
                       x >= 0; gamma, mu > 0

    with gamma and mu denoting the shape parameters and IGCDF
    denoting the cumulative distribution function of the inverse
    Gaussian distribution.

    The inverse Gaussian distribution can be generalized with
    location and scale parameters in the usual way.

Syntax:
    LET <y> = IGCHAZ(<x>,<gamma>,<mu>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable or a parameter;
          <gamma> is number or parameter that specifies the first
              shape parameter;
          <mu> is number or parameter that specifies the second
              shape parameter;
          <loc> is number or parameter that specifies the location
              parameter;
          <scale> is number or parameter that specifies the scale
              parameter;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed inverse Gaussian cumulative hazard
              value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    Note that the location and scale parameters are optional.

Examples:
    LET A = IGCHAZ(3,2,1)
    LET A = IGCHAZ(A1,2,1)
    LET X2 = IGCHAZ(X1,2,3)
    PLOT IGCHAZ(X,2,1.5) FOR X = 0.1  0.1  5
 
Note:
    The case where mu = 1 is referred to as the Wald distribution.
    Enter HELP WALPDF for details.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    IGCAZ  = Compute the inverse Gaussian cumulative distribution
             function.
    IGHAZ  = Compute the inverse Gaussian hazard function.
    IGPDF  = Compute the inverse Gaussian probability density
             function.
    IGPPF  = Compute the inverse Gaussian percent point function.
    CHSPDF = Compute the chi-square probability density function.
    FPDF   = Compute the F probability density function.
    NORPDF = Compute the normal probability density function.
    TPDF   = Compute the t probability density function.
    WEIPDF = Compute the Weibull probability density function.
    WALPDF = Compute the Wald probability density function.
    FLPDF  = Compute the fatigue life probability density function.
    RIGPDF = Compute the reciprocal inverse Gaussian probability
             density function.

Reference:
    "Continuous Univariate Distributions--Volume 1", Second Edition,
    Johnson, Kotz, and Balakrishnan, Wiley, 1994, chapter 15.

    "Statistical Distributions", Third Edition, Evans, Hastings,
    and Peacock, Wiley, 2000, pp. 114-116.

Applications:
    Distributional Modeling
 
Implementation Date:
    1990/5: Original implementation
    2003/12: Modified to treat mu as a shape parameter instead of
             a location parameter
 
Program:
    Y1LABEL Cumulative Hazard
    X1LABEL X
    LABEL CASE ASIS
    X1LABEL DISPLACEMENT 12
    Y1LABEL DISPLACEMENT 12
    MULTIPLOT SCALE FACTOR 2
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    TITLE GAMMA = 2, MU = 1
    PLOT IGCHAZ(X,2,1) FOR X = 0.01  0.01  5
    TITLE GAMMA = 5, MU = 1
    PLOT IGCHAZ(X,5,1) FOR X = 0.01  0.01  5
    TITLE GAMMA = 2, MU = 2
    PLOT IGCHAZ(X,2,2) FOR X = 0.01  0.01  5
    TITLE GAMMA = 5, MU = 2
    PLOT IGCHAZ(X,5,2) FOR X = 0.01  0.01  5
    END OF MULTIPLOT
    JUSTIFICATION CENTER
    MOVE 50 97
    CASE ASIS
    TEXT Inverse Gaussian Cumulative Hazard

-----IGHAZ (LET)--------------------------------
 
IGHAZ
 
Name:
    IGHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the inverse Gaussian hazard function with shape
    parameters gamma and mu.
 
Description:
    The  inverse Gaussian distribution has the following hazard
    function:

       h(x;gamma,mu) = IGPDF(x;gamma,mu)/[1 - IGCDF(x;gamma,mu)]
                       x >= 0; gamma, mu > 0

    with gamma and mu denoting the shape parameters and IGCDF
    and IGPDF denoting the cumulative distribution function and
    probability density function, respectively, of the inverse
    Gaussian distribution.

    The inverse Gaussian distribution can be generalized with
    location and scale parameters in the usual way.

Syntax:
    LET <y> = IGHAZ(<x>,<gamma>,<mu>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable or a parameter;
          <gamma> is number or parameter that specifies the first
              shape parameter;
          <mu> is number or parameter that specifies the second
              shape parameter;
          <loc> is number or parameter that specifies the location
              parameter;
          <scale> is number or parameter that specifies the scale
              parameter;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed inverse Gaussian hazard value is
              stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    Note that the location and scale parameters are optional.

Examples:
    LET A = IGHAZ(3,2,1)
    LET A = IGHAZ(A1,2,1)
    LET X2 = IGHAZ(X1,2,3)
    PLOT IGHAZ(X,2,1.5) FOR X = 0.1  0.1  5
 
Note:
    The case where mu = 1 is referred to as the Wald distribution.
    Enter HELP WALPDF for details.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    IGCDF  = Compute the inverse Gaussian cumulative distribution
             function.
    IGCHAZ = Compute the inverse Gaussian cumulative hazard
             function.
    IGPDF  = Compute the inverse Gaussian probability density
             function.
    IGPPF  = Compute the inverse Gaussian percent point function.
    CHSPDF = Compute the chi-square probability density function.
    FPDF   = Compute the F probability density function.
    NORPDF = Compute the normal probability density function.
    TPDF   = Compute the t probability density function.
    WEIPDF = Compute the Weibull probability density function.
    WALPDF = Compute the Wald probability density function.
    FLPDF  = Compute the fatigue life probability density function.
    RIGPDF = Compute the reciprocal inverse Gaussian probability
             density function.

Reference:
    "Continuous Univariate Distributions--Volume 1", Second Edition,
    Johnson, Kotz, and Balakrishnan, Wiley, 1994, chapter 15.

    "Statistical Distributions", Third Edition, Evans, Hastings,
    and Peacock, Wiley, 2000, pp. 114-116.

Applications:
    Distributional Modeling
 
Implementation Date:
    1990/5: Original implementation
    2003/12: Modified to treat mu as a shape parameter instead of
             a location parameter
 
Program:
    Y1LABEL Hazard
    X1LABEL X
    LABEL CASE ASIS
    X1LABEL DISPLACEMENT 12
    Y1LABEL DISPLACEMENT 12
    MULTIPLOT SCALE FACTOR 2
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    TITLE GAMMA = 2, MU = 1
    PLOT IGHAZ(X,2,1) FOR X = 0.01  0.01  5
    TITLE GAMMA = 5, MU = 1
    PLOT IGHAZ(X,5,1) FOR X = 0.01  0.01  5
    TITLE GAMMA = 2, MU = 2
    PLOT IGHAZ(X,2,2) FOR X = 0.01  0.01  5
    TITLE GAMMA = 5, MU = 2
    PLOT IGHAZ(X,5,2) FOR X = 0.01  0.01  5
    END OF MULTIPLOT
    JUSTIFICATION CENTER
    MOVE 50 97
    CASE ASIS
    TEXT Inverse Gaussian Hazard

-----IGPDF (LET)--------------------------------
 
IGPDF
 
Name:
    IGPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the inverse Gaussian probability density function with
    shape parameters gamma and mu.
 
Description:
    The  inverse Gaussian distribution has the following probability
    density function:

       f(x;gamma,mu) = (1/sqrt(2*PI))*(sqrt(mu)/gamma)*(x**(-1.5))*
                       (exp(-1/(2*mu*X))*(((X-mu)/gamma)**2)
                       x >= 0; gamma, mu > 0

    with gamma and mu denoting the shape parameters.

    The inverse Gaussian distribution has mean mu and standard
    deviation mu*gamma.
 
    The inverse Gaussian distribution can be generalized with
    location and scale parameters in the usual way.

Syntax:
    LET <y> = IGPDF(<x>,<gamma>,<mu>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable or a parameter;
          <gamma> is number or parameter that specifies the first
              shape parameter;
          <mu> is number or parameter that specifies the second
              shape parameter;
          <loc> is number or parameter that specifies the location
              parameter;
          <scale> is number or parameter that specifies the scale
              parameter;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed inverse Gaussian pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    Note that the location and scale parameters are optional.

Examples:
    LET A = IGPDF(3,2,1)
    LET A = IGPDF(A1,2,1)
    LET X2 = IGPDF(X1,2,3)
    PLOT IGPDF(X,2,1.5) FOR X = 0.1  0.1  5
 
Note:
    Random numbers, probability plots, and Kolmogorov-Smirnov and
    chi-square goodness of fit tests can be generated with the
    commands:

       LET GAMMA = <value>
       LET MU = <value>
       LET Y = INVERSE GAUSSIAN RANDOM NUMBERS FOR I = 1 1 N
       INVERSE GAUSSIAN PROBABILITY PLOT Y
       INVERSE GAUSSIAN KOLMOGOROV-SMIRNOV GOODNESS OF FIT Y
       INVERSE GAUSSIAN CHI-SQUARE FIT Y

    The following commands can be used to generate estimates
    for the shape parameters of the inverse Gaussian distribution:

       LET GAMMA1 = <value>
       LET GAMMA2 = <value>
       LET MU1 = <value>
       LET MU2 = <value>
       INVERSE GAUSSIAN PPCC PLOT Y
       INVERSE GAUSSIAN KS PLOT Y

    The default values for GAMMA1 and GAMMA2 are 0.5 and 25.  The
    default values for MU1 and MU2 are 0.5 and 25.

    Maximum likelihood estimates can be obtained by entering the
    command

       INVERSE GAUSSIAN MAXIMUM LIKELIHOOD Y

    The maximum likelihood estimates are

       muhat = xbar
       gammahat = n/(SUM[i=1 to n][(1/x(i) - (1/xbar)]

    with xbar and n denoting the sample mean and sample size,
    respectively.

Note:
    The inverse Gaussian distribution is symmetric and moderate tailed
    for small gamma.  It is highly skewed and long tailed for large
    gamma.  It approaches normality as gamma approaches zero.
 
Note:
    The case where mu = 1 is referred to as the Wald distribution.
    Enter HELP WALPDF for details.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    IGCDF  = Compute the inverse Gaussian cumulative distribution
             function.
    IGCHAZ = Compute the inverse Gaussian cumulative hazard
             function.
    IGHAZ  = Compute the inverse Gaussian hazard function.
    IGPPF  = Compute the inverse Gaussian percent point function.
    CHSPDF = Compute the chi-square probability density function.
    FPDF   = Compute the F probability density function.
    NORPDF = Compute the normal probability density function.
    TPDF   = Compute the t probability density function.
    WEIPDF = Compute the Weibull probability density function.
    WALPDF = Compute the Wald probability density function.
    FLPDF  = Compute the fatigue life probability density function.
    RIGPDF = Compute the reciprocal inverse Gaussian probability
             density function.

Reference:
    "Continuous Univariate Distributions--Volume 1", Second Edition,
    Johnson, Kotz, and Balakrishnan, Wiley, 1994, chapter 15.

    "Statistical Distributions", Third Edition, Evans, Hastings,
    and Peacock, Wiley, 2000, pp. 114-116.

Applications:
    Distributional Modeling
 
Implementation Date:
    1990/5: Original implementation
    2003/12: Modified to treat mu as a shape parameter instead of
             a location parameter
 
Program:
    Y1LABEL Probability
    X1LABEL X
    LABEL CASE ASIS
    X1LABEL DISPLACEMENT 12
    Y1LABEL DISPLACEMENT 12
    MULTIPLOT SCALE FACTOR 2
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    YLIMITS 0 1.5
    TITLE GAMMA = 2, MU = 1
    PLOT IGPDF(X,2,1) FOR X = 0.01  0.01  5
    TITLE GAMMA = 5, MU = 1
    PLOT IGPDF(X,5,1) FOR X = 0.01  0.01  5
    TITLE GAMMA = 2, MU = 2
    PLOT IGPDF(X,2,2) FOR X = 0.01  0.01  5
    TITLE GAMMA = 5, MU = 2
    PLOT IGPDF(X,5,2) FOR X = 0.01  0.01  5
    END OF MULTIPLOT
    JUSTIFICATION CENTER
    MOVE 50 97
    CASE ASIS
    TEXT Inverse Gaussian PDF

-----IGPPF (LET)--------------------------------
 
IGPPF
 
Name:
    IGPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the inverse Gaussian percent point function with shape
    parameters gamma and mu.
 
Description:
    The  inverse Gaussian distribution has the following cumulative
    distribution function:

       F(x;gamma,mu) = NORCDF[SQRT(gamma/x)*((x/mu) - 1)] +
                       EXP(2*gamma/mu)*NORCDF[-SQRT(gamma/x)*((x/mu) + 1)]
                       x >= 0; gamma, mu > 0

    with gamma and mu denoting the shape parameters and NORCDF
    denoting the cumulative distribution function of the standard
    normal distribution.

    The percent point function is the inverse of the cumulative
    distribution function.  The percent point function for the
    inverse Gaussian distribution does not exist in simple,
    closed form.  It is computed by numerically inverting the
    inverse Gaussian cumulative distribution function using a
    bisection method.

    The inverse Gaussian distribution can be generalized with
    location and scale parameters in the usual way.

Syntax:
    LET <y> = IGPPF(<p>,<gamma>,<mu>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable or a parameter in the interval (0,1);
          <gamma> is number or parameter that specifies the first
              shape parameter;
          <mu> is number or parameter that specifies the second
              shape parameter;
          <loc> is number or parameter that specifies the location
              parameter;
          <scale> is number or parameter that specifies the scale
              parameter;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed inverse Gaussian ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    Note that the location and scale parameters are optional.

Examples:
    LET A = IGPPF(0.95,2,1)
    LET A = IGPPF(P1,2,1)
    PLOT IGPPF(P,2,1.5) FOR P = 0  0.01  0.99
 
Note:
    The case where mu = 1 is referred to as the Wald distribution.
    Enter HELP WALPDF for details.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    IGCDF  = Compute the inverse Gaussian cumulative distribution
             function.
    IGCHAZ = Compute the inverse Gaussian cumulative hazard
             function.
    IGHAZ  = Compute the inverse Gaussian hazard function.
    IGPDF  = Compute the inverse Gaussian probability density
             function.
    CHSPDF = Compute the chi-square probability density function.
    FPDF   = Compute the F probability density function.
    NORPDF = Compute the normal probability density function.
    TPDF   = Compute the t probability density function.
    WEIPDF = Compute the Weibull probability density function.
    WALPDF = Compute the Wald probability density function.
    FLPDF  = Compute the fatigue life probability density function.
    RIGPDF = Compute the reciprocal inverse Gaussian probability
             density function.

Reference:
    "Continuous Univariate Distributions--Volume 1", Second Edition,
    Johnson, Kotz, and Balakrishnan, Wiley, 1994, chapter 15.

    "Statistical Distributions", Third Edition, Evans, Hastings,
    and Peacock, Wiley, 2000, pp. 114-116.

Applications:
    Distributional Modeling
 
Implementation Date:
    1990/5: Original implementation
    2003/12: Modified to treat mu as a shape parameter instead of
             a location parameter
 
Program:
    X1LABEL Probability
    Y1LABEL X
    LABEL CASE ASIS
    X1LABEL DISPLACEMENT 12
    Y1LABEL DISPLACEMENT 12
    MULTIPLOT SCALE FACTOR 2
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    TITLE GAMMA = 2, MU = 1
    PLOT IGPPF(P,2,1) FOR P = 0  0.01  0.99
    TITLE GAMMA = 5, MU = 1
    PLOT IGPPF(P,5,1) FOR P = 0  0.01  0.99
    TITLE GAMMA = 2, MU = 2
    PLOT IGPPF(P,2,2) FOR P = 0  0.01  0.99
    TITLE GAMMA = 5, MU = 2
    PLOT IGPPF(P,5,2) FOR P = 0  0.01  0.99
    END OF MULTIPLOT
    JUSTIFICATION CENTER
    MOVE 50 97
    CASE ASIS
    TEXT Inverse Gaussian Percent Point

-----IO (SET)--------------------------------------------
 
IO
 
Name:
    IO (SET)
 
Type:
    Set Subcommand
 
Purpose:
    Allows DATAPLOT macros to prompt for parameters interactively.
 
Syntax:
    SET IO <TERMINAL/    >
    where <TERMINAL> means that subsequent READ commands will read from
            the terminal rather than the macro file while no argument
            means subsequent READ commands will read from the macro
            file.  This command allows DATAPLOT macros to prompt users
            for information.
 
Examples:
    SET IO TERMINAL
    SET IO
 
Default:
    Read from macro file.
 
Synonyms:
    None
 
Related Commands:
    READ               = Read data, parameters, strings.
    CALL               = Execute commands from a file.
 
Applications:
    Menu Macros
 
Implementation Date:
    Pre-1987
 
Program:
    SET IO TERMINAL
    WRITE "ENTER VALUE FOR PARAMETER A:"
    READ PARAMETER A
    SET IO
 
-----I PLOT-------------------------------------------------------
 
I PLOT
 
Name:
    I PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates an I plot.
 
Description:
    Given a response variable and a group-id variable, the I plot
    is used to plot a location value, a lower extreme value, and an
    upper extreme value for each group.  The default is to use the
    median for the location and the minimum and maximum values as
    the extreme points (alternatives will be discussed below).

    An I plot is used in two ways:

    1) As a graphical data analysis technique (similar to the box plot,
       but simpler) for determining if differences exist between the
       various levels of a 1-factor model.  It is a graphical
       alternative to 1-factor ANOVA.

    2) As an uncertainty chart in which the analyst wishes to plot
       estimated values of a certain quantity and to also illustrate
       the uncertainty bars associated with each estimate.  In such
       case, a given value of the horizontal axis variable is typically
       accompanied by exactly 3 values for the vertical axis variable:

          1) the estimate - the uncertainty;
          2) the estimate;
          3) the estimate + the uncertainty.
 
    For both applications, the resulting plot is similar in appearance.
    Namely, a target value which typically appears as an X, a vertical
    bar with small horizontal bars at the extremes (hence the name
    "I plot").
 
    The I plot has five components (characters and lines) which can be
    individually controlled.  These components are:

        1) the maximum (or upper extreme value)
        2) the median (or other location value)
        3) the minimum (or lower extreme value)
        4) the line between the median (location value) and the
           maximum (upper extreme)
        5) the line between the median (location value) and the
           minimum (lower extreme)

    For the default I plot, the I PLOT command can be preceded by the
    following two commands:

       CHARACTERS I PLOT
       LINES I PLOT

    With these commands, the first three lines are set to blank and
    lines four and five are set blank.  The second character is set to
    "X", characters one and three are set to "-", and characters
    four and five are set to blank.  After the I plot is formed, the
    analyst should redefine plot characters and lines via the usual
    CHARACTERS and LINES commands.
 
    As mentioned above, the I plot can use location statistics other
    than the median.  Specifically, you can use the MEAN I PLOT,
    MIDMEAN I PLOT, MIDRANGE I PLOT, TRIMMED MEAN I PLOT, and
    BIWEIGHT I PLOT to specify the mean, midmean, midrange, trimmed
    mean, and biweight location, respectively.

    This plot is also useful for displaying confidence intervals as well
    as other types of intervals.  The following are currently supported:

        1) mean confidence limits
        2) trimmed mean confidence limits
        3) median confidence limits
        4) quantile confidence limits
        5) biweight confidence limits
        6) one standard error (mean +/- s/sqrt(n))
        7) two standard error (mean +/- 2*s/sqrt(n))
        8) one standard deviation (mean +/- s)
        9) two standard deviation (mean +/- 2*s)
       10) standard deviation confidence limits
       11) coefficient of variation confidence limits
       12) coefficient of dispersion confidence limits
       13) normal tolerance limits
       14) normal prediction limits
       15) Agresti Coull limits (for binomial proportions)
       16) difference of means confidence limits
       17) difference of proportions confidence limits (for binomial proportions)
       18) correlation confidence limits
       19) ratio of means confidence limits

Syntax 1:
    <stat> I PLOT  <y>  <x>   <SUBSET/EXCEPT/FOR qualification>
    where <stat> is MEDIAN, MEAN, MIDMEAN, MIDRANGE, BIWEIGHT, or
              TRIMMED MEAN;
          <y> is the response (= dependent) variable;
          <x> is the horizontal axis (= independent) variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    For this syntax, the extreme values will be the minimum and maximum
    values.  If <stat> is omitted, the location statistic will be the
    median.

Syntax 2:
    <stat> PLOT  <y>  <x>   <SUBSET/EXCEPT/FOR qualification>
    where <stat> is one of:
               MEAN CONFIDENCE LIMIT
               TRIMMED MEAN CONFIDENCE LIMIT
               MEDIAN CONFIDENCE LIMIT
               QUANTILE CONFIDENCE LIMIT
               BIWEIGHT CONFIDENCE LIMIT
               STANDARD DEVIATION CONFIDENCE LIMIT
               NORMAL TOLERANCE LIMIT
               NORMAL PREDICTION LIMIT
               AGRESTI COULL LIMIT
               ONE STANDARD ERROR
               TWO STANDARD ERROR
               ONE STANDARD DEVIATION
               TWO STANDARD DEVIATIONS
               STANDARD DEVIATION CONFIDENCE LIMIT
               COEFFICIENT OF VARIATION CONFIDENCE LIMIT
               COEFFICIENT OF DISPERSION CONFIDENCE LIMIT
          <y> is the response (= dependent) variable;
          <x> is the horizontal axis (= independent) variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    For this syntax, the extreme values will be the lower and
    upper bounds of the appropriate limits.

Syntax 3:
    <stat> PLOT  <y1>  <y2>  <x>   <SUBSET/EXCEPT/FOR qualification>
    where <stat> is one of:
               DIFFERENCE OF MEANS CONFIDENCE LIMIT
               DIFFERENCE OF PROPORTION CONFIDENCE LIMIT
               CORRELATION CONFIDENCE LIMIT
               RATIO OF MEANS CONFIDENCE LIMIT
          <y1> is the first response variable;
          <y2> is the second response variable;
          <x> is the group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This is similar to Syntax 2 except that there are two response
    variables instead of one.

Syntax 4:
    MULTIPLE <stat> PLOT <y1> ... <yk>   
                         <SUBSET/EXCEPT/FOR qualification>
    where <stat> is one of:
               MEDIAN I
               MEAN I
               MIDMEAN I
               MIDRANGE I
               BIWEIGHT I
               TRIMMED MEAN I
               MEAN CONFIDENCE LIMIT
               TRIMMED MEAN CONFIDENCE LIMIT
               MEDIAN CONFIDENCE LIMIT
               QUANTILE CONFIDENCE LIMIT
               BIWEIGHT CONFIDENCE LIMIT
               STANDARD DEVIATION CONFIDENCE LIMIT
               COEFFICIENT OF VARIATION CONFIDENCE LIMIT
               COEFFICIENT OF DISPERSION CONFIDENCE LIMIT
               NORMAL TOLERANCE LIMIT
               NORMAL PREDICTION LIMIT
               ONE STANDARD ERROR
               TWO STANDARD ERROR
               ONE STANDARD DEVIATION
               TWO STANDARD DEVIATION
               AGRESTI COULL LIMIT
          <y1> ... <yk> is a list of up to k response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is useful when the data for each group is stored
    in separate response variables.  Up to 30 response variables
    may be specified.

    Note that the syntax

         MULTIPLE I PLOT Y1 TO Y4

    is supported.  This is equivalent to

         MULTIPLE I PLOT Y1 Y2 Y3 Y4

Syntax 5:
    REPLICATED <stat> PLOT <y> <x1> ... <xk>   
                           <SUBSET/EXCEPT/FOR qualification>
    where <stat> is one of the variants listed for Syntax 4;
          <y> is the response variable;
          <x1> ... <xk> is a list of up to k group-id variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax performs a cross-tabulation of <x1> ... <xk> and
    generates an i plot (on the same graph) for each unique combination
    of cross-tabulated values.  For example, if X1 has 3 levels and X2
    has 2 levels, there will be a total of 6 i plots generated.  Up to
    six group-id variables can be specified.

    Note that the syntax

         REPLICATED I PLOT Y X1 TO X4

    is supported.  This is equivalent to

         REPLICATED I PLOT Y X1 X2 X3 X4

    In this syntax, all i plots are drawn with the sampe plot
    attributes.

    As an example of how the x-coordinates are determined,
    assume we have 3 levels for X1 and 2 levels for X2.  The
    x-coordinates will be

        X1      X2    X-COORDINATE
        --------------------------
         1       1         1
         1       2         2
         2       1         3
         2       2         4
         3       1         5
         3       2         6

Syntax 6:
    <stat> PLOT <y> <x1> <x2>   <SUBSET/EXCEPT/FOR qualification>
    where <stat> is one of the variants listed for Syntax 4;
          <y> is the response variable;
          <x1> is the first group-id variable;
          <x2> is the second group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is similar to syntax 5.  However, it has the following
    distinctions:

       1. There must be exactly two group-id variables and the
          word REPLICATION is omitted from the command.

       2. The groups in the second group-id variable are drawn with
          different attributes.

       3. The x-coordinates are generated to emphasize the comparisons
          between the <x2> groups for each level of the <x1> group.
          Using the same example as Syntax 5, we have

        X1      X2    X-COORDINATE
        --------------------------
         1       1         0.8
         1       2         1.2
         2       1         1.8
         2       2         2.2
         3       1         2.8
         3       2         3.2

    Program 2 demonstrates the difference between Syntax 5 and Syntax 6.

Examples:
    I PLOT Y X
    I PLOT Y X  SUBSET X > 2
    ONE STANDARD ERROR PLOT Y X
    MEAN CONFIDENCE LIMIT PLOT Y X
 
Note:
    The ERROR BAR PLOT provides a more general method for error
    bars in that it can support asymmetric limits and errors in
    both the horizontal and vertical directions.  However, the
    I PLOT syntax can be easier for some basic cases (i.e., for
    confidence limits or for one or two standard errors from the
    mean).

Note:
    For some cases, you can specify optional parameters.

    To specify the alpha level for the confidence limit cases,
    enter the command (0.05 will be used if this command is not
    given)

        LET ALPHA = <value>

    For the QUANTILE CONFIDENCE LIMIT case, specify the desired quantile
    with the command (0.50 will be used if this command is not given)

        LET XQ = <value>

    For the TRIMMED MEAN CONFIDENCE LIMIT case, specify the trimming
    parameters with the commands (0.25 and 0.75 will be used if these
    commands are not given)

        LET P1 = <value>
        LET P2 = <value>

Note:
    The Agresti Coull confidence limits for a binomial proportion support
    several different methods for deteriming the confidence limits.  To
    specify the method to use, enter the command

       SET BINOMIAL METHOD <WILSON/ADJUSTED WALD/JEFFREYS/NORMAL/EXACT>

    The default is the Wilson method.  For details on the various
    methods, enter HELP PORPORTION CONFIDENCE LIMITS.

    The difference of proportion confidence limits also support several
    different methods for deteriming the confidence limits.  To specify
    the method to use, enter the command

    To specify the method to use, enter the command

        SET DIFFERENCE OF BINOMIAL METHOD <WALD/ADJUSTED WALD/BAYESIAN>

    The default is the adjusted Wald (Agresti-Caffo) interval.  For
    details on the various methods, enter HELP DIFFERENCE OF PORPORTION
    CONFIDENCE LIMITS.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHARACTERS      = Sets the type for plot characters.
    LINES           = Sets the type for plot lines.
    BOX PLOT        = Generates a box plot.
    ANOVA           = Carries out an ANOVA.
    MEDIAN POLISH   = Carries out a median polish.
    CONTROL CHART   = Generates a control chart.
    ERROR BAR PLOT  = Generates a plot with error bars.
    PLOT            = Generates a data or function plot.
 
Applications:
    One Factor Analysis, Data Analysis
 
Implementation Date:
    Pre-1987
    2011/02: Support for MULTIPLE and REPLICATION options
    2013/10: Support for MEAN, MIDMEAN, MIDRANGE I plots
    2013/10: Support for various confidence interval cases (Syntax 2)
    2013/10: Support for special 3 variable case (Syntax 5)
    2017/11: Support for DIFFERENCE OF MEANS CONFIDENCE LIMIT
    2017/11: Support for DIFFERENCE OF PROPORTIONS CONFIDENCE LIMIT
    2017/11: Support for COEFFICIENT OF VARIATION CONFIDENCE LIMIT
    2017/11: Support for COEFFICIENT OF DISPERSION CONFIDENCE LIMIT
    2017/12: Support for CORRELATION CONFIDENCE LIMIT
    2019/10: Support for RATIO OF MEANS CONFIDENCE LIMIT
 
Program 1:
    . Step 1:   Read the data
    .
    skip 25
    read gear.dat y x
    .
    . Step 2:   Basic i-plot
    .
    title case asis
    title offset 2
    label case asis
    character case asis
    line i plot
    character blank circle blank blank blank
    character fill off on
    character hw 0.5 0.375 all
    xlimits 1 10
    major xtic mark number 10
    minor xtic mark number 0
    x1tic mark offset 0.5 0.5
    title automatic
    .
    multiplot corner coordinates 5 5 95 95
    multiplot scale factor 2
    multiplot 2 2
    i plot y x
    mean i plot y x
    midrange i plot y x
    midmean i plot y x
    end of multiplot
    .
    multiplot 2 2
    one standard error plot y x
    two standard error plot y x
    mean confidence limit plot y x
    median confidence limit plot y x
    end of multiplot
    .
    multiplot 2 2
    mean confidence limit plot y x
    median confidence limit plot y x
    biweight confidence limit plot y x
    trimmed mean confidence limit plot y x
    end of multiplot

Program 2:
    . Step 1:   Read the data
    .
    .           y = voltage drop
    .           x1  = elapsed days (1, 8, 15, 29, 43, 57, 71, 107)
    .           x2  = type of connector
    .                 1 = brass
    .                 2 = steel
    .                 3 = innovative
    skip 25
    read clark0.dat  y days x2
    let days = 8 subset days = 9
    let days = 15 subset days = 16
    let days = 29 subset days = 30
    let days = 43 subset days = 44
    let days = 57 subset days = 58
    let days = 71 subset days = 72
    let days = 107 subset days = 108
    let x1 = coded days
    let nx1 = unique x1
    let nx2 = unique x2
    let ntot = nx1*nx2
    .
    . Step 2:   I Plot with standard replication option
    .
    title case asis
    title offset 2
    label case asis
    character case asis
    line i plot
    character blank circle blank blank blank
    character fill off on
    character hw 0.5 0.375 all
    .
    y1label Voltage Drop
    x3label Elapsed Days/Connector Type
    xlimits 1 ntot
    major xtic mark number ntot
    minor xtic mark number 0
    x1tic mark offset 0.5 0.5
    x1tic mark label format alpha
    x1tic mark label content 1 8 15 29 43 57 71 107 1 8 15 29 43 57 71 107 ...
          1 8 15 29 43 57 71 107 
    x1tic mark label size 1.6
    title automatic
    replicated i plot y x2 x1
    .
    justification center
    let xcoor = (nx1/2) + 0.5
    let ycoor = 10
    moveds xcoor ycoor
    text Brass
    let xcoor = xcoor + nx1
    moveds xcoor ycoor
    text Steel
    let xcoor = xcoor + nx1
    moveds xcoor ycoor
    text Innovative
    .
    . Step 3:   I Plot with alternative replication option
    .
    line i plot bl bl bl so so bl bl bl so so bl bl bl so so
    character bl circ bl bl bl bl circ bl bl bl bl circ bl bl bl
    character fill on all
    character hw 0.5 0.375 all
    character color blue blue blue blue blue red red red red red ...
                    green green green green green
    line color blue blue blue blue blue red red red red red ...
               green green green green green
    .
    x1label Elapsed Days/Connector Type
    x3label
    xlimits 1 nx1
    major xtic mark number nx1
    minor xtic mark number 0
    x1tic mark offset 0.5 0.5
    x1tic mark label format alpha
    x1tic mark label content 1 8 15 29 43 57 71 107
    title automatic
    i plot y x1 x2

Program 3:
    . Step 1:   Read the data
    .
    .           x1  = instrument
    .           x2  = source
    .           y1  = expected alarm
    .           y2  = observed alarm
    .           y   = 1 if y1 and y2 agree, 0 otherwise
    skip 25
    read alarm.dat  x1 x2 y1 y2
    skip 0
    let n = size y1
    let y = 0 for i = 1 1 n
    let y = 1 subset y1 = 0 subset y2 = 0
    let y = 1 subset y1 = 1 subset y2 = 1
    let ninst = unique x1
    let nsrc  = unique x2
    .
    .
    . Step 2:   I Plot with standard replication option
    .
    line i plot
    character blank circle blank blank blank
    character fill off on
    character hw 0.5 0.375 all
    .
    label case asis
    title case asis
    y1label Binomial Proportion
    x1label Instrument
    xlimits 1 ninst
    major xtic mark number ninst
    minor xtic mark number 0
    x1tic mark offset 0.5 0.5
    title automatic
    agresti coull confidence limit plot y x1
    .
    difference of proportion confidence limit plot y1 y2 x1

-----IMAGE PLOT-----------------------------------------
 
IMAGE PLOT
 
Name:
    IMAGE PLOT
 
Type:
    Graphics Command
 
Purpose:
    Render an image.
 
Description:
    Much data is now collected as images.  You can read
    image data in one of two ways:

       1) You can convert the data into columns of integer or
          real numbers and then save these columns into an ASCII
          file using some external program (e.g., Perl or Python).
          You can then read this ASCII file in the usual way.

       2) On some platforms, Dataplot can read image data
          in PNG, GIF, or JPEG format directly.  Enter
          HELP READ IMAGE TO VARIABLES for details).  Note
          that Dataplot will convert the image data to columns
          of numbers.

    Dataplot does not currently support an "image" data
    type.  Image plots are generated from columns of data.
    There are two types of images supported:

       1) If there is a single column of data, these values
          are assumed to represent grey scale values.

       2) If there are three columns of data, these are
          assumed to represent red-green-blue (RGB) values.

          Although there are other color models, Dataplot
          currently only supports the RGB model.
    
    Support for image plots is dependent on the capabilities
    of the given device.  Currently, image plots are supported
    for the following output devices.

       1) QUICKWIN  - the command line version of Dataplot
                      for Microsoft Windows

       2) X11       - current support is limited to
                      grey scale images

       3) GD        - the GD device is used to generate
                      PNG, JPEG, or GIF output.

       4) Postscript

Syntax 1:
    IMAGE PLOT  <grey>  <rowid>  <colid>
                <SUBSET/EXCEPT/FOR qualification>
    where <grey> is a variable that specifies the grey scale
                 values;
          <rowid> is a variable that specifies the row of the
                 image;
          <colid> is a variable that specifies the column of the
                 image;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    IMAGE PLOT  <red>  <blue>   <green>  <rowid>  <colid>
                <SUBSET/EXCEPT/FOR qualification>
    where <red> is a variable that specifies the values of the
                 red component;
          <blue> is a variable that specifies the values of the
                 blue component;
          <green> is a variable that specifies the values of the
                 green component;
          <rowid> is a variable that specifies the row of the
                 image;
          <colid> is a variable that specifies the column of the
                 image;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 3:
    IMAGE PLOT  <grey>    <SUBSET/EXCEPT/FOR qualification>
    where <grey> is a matrix that specifies the grey scale
                 values;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 4:
    IMAGE PLOT  <red>  <blue>  <green>
                <SUBSET/EXCEPT/FOR qualification>
    where <red> is a matrix that specifies the values of the
                 red component;
          <blue> is a matrix that specifies the values of the
                 blue component;
          <green> is a matrix that specifies the values of the
                 green component;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    IMAGE PLOT GREY ROWID COLID
    IMAGE PLOT RED BLUE GREEN ROWID COLID
 
Note:
    Dataplot will convert the grey scale and RGB values to a
    (0,1) scale.  Image data often, but not always, has the
    range (0,255).

    Dataplot takes the absolute value of the numbers.  By
    default, Dataplot assumes a (0,255) range.  If the maximum
    absolute value is greater than 255, then the range is
    assumed to be 0 to that maximum value.

    Alternatively, you can specify the maximum value by
    entering the command

         SET COLOR MAXIMUM <value>

    The minimum is always assumed to be 0.

    When the image is rendered on a specific device, the
    (0,1) scale is translated to whatever range is supported
    on the specific device.  For the Quickwin, GD, and
    Postscript devices, this is (0,255) for each of the
    red-blue-green-greyscale components.  For X11, greyscale
    is converted to a (0,100) scale and full color is not
    currently supported.

Note:
    Each row of the image variables is drawn as a single
    pixel.  You can expand the size by entering the command

        CHARACTER SIZE <n>

    where <n> will be rounded to the nearest integer.  So if
    <n> = 2, each row of the image variables will be drawn
    as a 2x2 square.

    Other than this, Dataplot does not expand or contract 
    the image.  If the number of rows or columns in the
    image exceeds the available number of pixels on the
    device, the extra rows/columns will simply not be
    plotted.  Likewise, the image will not automatically
    be explanded to fill a pre-specified size.

    The one exception to this is the Postscript device.
    More is said about this in the note below.
    
Note:
    The Quickwin, X11, and GD devices handle images at the
    pixel level. 

    The Postscript device uses image operators that are
    supported in Postscript.  This means that Postscript
    may perform some scaling/smoothong of the image.

Note:
    Dataplot renders the image in the frame corner
    coordinates area.  To modify the area available
    for rendering the image, enter the command

       FRAME CORNER COORDINATES  <xmin> <ymin> <xmax> <ymax>

    These values are in 0 to 100 units and default to
    15, 20, 85, and 90, respectively.  To use the full
    area of the device, enter

       FRAME CORNER COORDINATES 0 0 100 100

    Titles, tic marks, tic mark labels, and axis labels
    are controlled with the usual commands.

Note:
    Dataplot is primarily a graphical data analysis/statistical
    analysis program rather than an image manipuilation program.
    So the primary purpose of reading images is to perform data
    analysis on the image.

    Once you read an image into Dataplot (into columns of
    data), you can perform many desired image manipulation
    functions (e.g., rotation, cropping) using the LET
    command.  Alternatively, you can use freely downloadable
    image manipulation software such as Image Magick or NetPBM
    to perform basic image manipulation functions.  If this
    software is installed on your system, you can use the Dataplot
    SYSTEM command to invoke this software from within Dataplot.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    READ IMAGE TO VARIABLES  = Read image data into variables.
    DISCRETE CONTOUR PLOT    = Generates a discrete contour plot.
    CONTOUR PLOT             = Generates a contour plot.
    PLOT                     = Generates a data or function plot.
    CHARACTER SIZE           = Specify the size of plot characters.
 
Applications:
    Image Analysis
 
Implementation Date:
    2008/3
 
Program:
    .  Step 1: Define output device
    set postscript ppi 100
    set ipl1na elliott.ps
    device 2 postscript
    .  Step 2: Read image
    dimensions 10 columns
    skip 25
    set read format 3f7.0
    read elliottr.dat y row col
    skip 0
    set read format
    .
    title Elliott Data
    title case asis
    title offset 2
    .  Step 3: Generate the image
    frame corner coordinates 2 2 98 95
    frame off
    character size 1
    image plot y row col
    .
    device 2 close

-----IMPLEMENT-------------------------------------------------------
 
IMPLEMENT
 
Name:
    IMPLEMENT
 
Type:
    Support Command
 
Purpose:
    Executes certain pre-defined DATAPLOT programs (which were written
    by the local DATAPLOT implementation group) which allow the the
    analyst to easily change to alternative sign-on default conditions.
 
Description:
    One common form for the IMPLEMENT command is IMPLEMENT TICS (or
    IMPLEMENT 1) which overrides the default of no tics and no tic
    labels on the top and right frame lines and cause such tics and tic
    labels to appear on all subsequent plots.  A second common form is
    IMPLEMENT SQUARE (or IMPLEMENT 2) which changes the default
    rectangular frame corner coordinates and replaces them with square
    frame corner coordinates.
 
Syntax:
    IMPLEMENT   <type>
    where <type> identifies which implementation settings to apply.  It
             can be a name (TICS or SQUARE) or an integer number or
             parameter.
 
Examples:
    IMPLEMENT TICS
    IMPLEMENT SQUARE
 
Note:
    This command is now obsolete.  The file DPSYSF.TEX (in the DATAPLOT
    support directory) can be used to implement system wide defaults
    while the file DPLOGF.TEX (in the current directory) can be used to
    implement a given user's defaults.  These files provide a more
    flexible format than the IMPLEMENT command since no DATAPLOT source
    code changes are required.  The file names for the 2 login files
    can vary on some operating systems.
 
Note:
    Currently only 2 implementation switches are defined (TICS and
    SQUARE).  DATAPLOT provides for up to 10 switches to be defined.
    However, any than these two must be explicitly coded by the local
    DATAPLOT installer.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CALL             = Executes the commands in a "macro" file.
 
Applications:
    XX
 
Implementation Date:
    Pre-1987
 
Program:
    XX
 
-----INSERT (LET)-----------------------------------------
 
INSERT
 
Name:
    INSERT (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Insert the contents of one variable into another variable at a
    specified row location.

Description:
    The motivation for this command is the following.  Suppose we have

        LET U1 = UNIFORM RANDOM NUMBERS FOR I = 1 1 10
        LET U2 = UNIFORM RANDOM NUMBERS FOR I = 1 1 5

    and we want to replace rows 6 to 10 of U1 with the values in U2.
    The INSERT command can be used do this.

    There are two cases for INSERT.  In the above example, the values of
    U2 overwrite the current contents of U1.  Alternatively, you can
    request that the values of U2 be added at the specified location but
    that the values of U1 are not overwritten.  That is, the output
    variable will have rows 1 to 5 of U1, then rows 6 to 10 will have the
    U2 values, and then rows 11 to 16 will be rows 6 to 10 of U1.

    To specify that values of the first variable will be overwritten (the
    default), enter

         SET INSERT OVERWRITE ON

    To specify that the values of the second variable will be inserted
    and the values of the first variable will be shifted rather than
    overwritten, enter

         SET INSERT OVERWRITE OFF

    When the two variables are the same length and we are replacing
    corresponding rows of the first variable with the second variable,
    an appropriate SUBSET or FOR clause can typically be used.  When the
    values of the second variable are added to either the beginning or
    end of the first variable, then the APPEND, EXTEND or COMBINE
    commands can be used.  The INSERT command is useful when the contents
    of the second variable are inserted at an arbitrary location of the
    first variable.

Syntax:
    LET <y3> = INSERT <y1> <y2> <nloc>
    where <y1> is the first response variable;
          <y2> is the second reponse variable;
          <nloc> is a parameter that defines the starting row in <y1>
               where the <y2> values will be inserted;
    and   <y3> is the output variable.

    The <y1> and <y2> variables do not need to be the same length.  The
    <y3> variable will be at least the same length as <y1> (it can be
    longer).

    If the value of <nloc> is non-positive or greater than the length of
    <y1>, an error will be returned and <y3> will not be created.

    The <y3> variable can be the same as <y1>.

Examples:
    LET NLOC = 50
    LET Y1 = INSERT Y1 Y2 NLOC

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    APPEND     = Append a variable to the end of another variable.
    EXTEND     = Extend a variable by another variable.
    COMBINE    = Combine one or more variables and parameters into a
                 single variable.

Applications:
    Data Management
 
Implementation Date:
    2020/02

Program 1:
    let u1 = uniform random numbers for i = 1 1 10
    let u2 = uniform random numbers for i = 1 1 10
    let nloc = 6
    let u1 = insert u1 u2 nloc
    set write decimals 4
    print u1

Program 2:
    let u1 = uniform random numbers for i = 1 1 10
    let u2 = uniform random numbers for i = 1 1 10
    set insert overwrite off
    let nloc = 6
    let u1 = insert u1 u2 nloc
    set write decimals 4
    print u1

-----INSERT COMMAND LINE ARGUMENTS--------------------------------------
 
INSERT COMMAND LINE ARGUMENTS
 
Name:
    INSERT COMMAND LINE ARGUMENTS
 
Type:
    Support Command
 
Purpose:
    Define the current settings of the command line arguments.
 
Description:
    Dataplot supports arguments when calling macros (HELP MACRO
    SUBSTITUTION CHARACTER for details).

    One deficiency with command line arguments occurs when the CALL
    command is entered within a LOOP.  The LOOP command saves the
    contents of the CALL file but does not store the CALL command
    itself.  This command was added to address this issue.  It is
    used behind the scenes to save any command line arguments when
    the CALL is issued from within a LOOP command.

    Although you can enter this command explicitly, there is typically
    no reason to do so.
 
Syntax:
    INSERT COMMAND LINE ARGUMENTS <string>
    where <string> contains the command line arguments.
 
Examples:
    This command is intended for internal use.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LOOP  = Define a set of commands that will be executed multiple times.
 
Applications:
    Macros within loops
 
Implementation Date:
    2017/07
 
Program:
    XX
 
-----IPL1NA (SET)--------------------------------------------
 
IPL1NA
 
Name:
    IPL1NA (SET)
 
Type:
    Set Subcommand
 
Purpose:
    Define the name of the plot file created by the DEVICE 2 command.
 
Description:
    By default, Dataplot names the plot file created by the DEVICE 2
    command "dppl1f.dat".  This is the name used regardless of the type
    of device.

    There are times when it is convenient to use a different name for
    the plot file.  For example, if you are creating multiplot plots and
    you would like each of these to go into a separate file (i.e., there
    will be a sequence of DEVICE 2 ... and DEVICE 2 CLOSE commands).  Other
    reasons are to identify the type of output file (e.g., you want a
    ".ps" extension for Postscript files) or you want to save the file with
    a unique name for subsequent use after the Dataplot session.

    To set the name of the plot file, do the following

       SET IPL1NA <file-name>
       DEVICE 2 POSTSCRIPT

    Note that the SET IPL1NA command must come before the DEVICE 2
    command since the plot file is opened when the DEVICE 2 command
    is entered.

Syntax:
    SET IPL1NA <string>
    where <string> contains the desired name for the plot file.
 
Examples:
    SET IPL1NA PLOT.PS
    SET IPL1NA PLOT1.JPG

Note:
    File names have the following restrictions:

        1. The file name should be a valid file name for the local
           operating system.

        2. Most Dataplot commands that utilize a file name expect that the
           file name should contain a period "." in the file name itself
           or as a trailing character.  However, this is not required by
           the SET IPL1NA command.

        3. If the file name contains spaces or hyphens, then it needs to be
           enclosed in quotes.

        4. File names are currently limited to 80 characters.  This can
           in particular be a problem if the file name is contained within
           a long path name.

           You can use the CD command to make the path where the file
           is stored the current directory.  This is most useful for
           data files.  For example,

               pwd
               cd  <path where plot file will be saved>
               set ipl1na plot.ps
               device 2 postscript
               cd ^CURDIR

           The pwd command is used to save the current directory.  The
           cd command is then used to set the current directory to the
           path where the data resides, the read is performed, and then
           the cd command is used to restore the original working
           directory (the cd command saves the current path in the
           string CURDIR).

Note:
    File names are case sensitive on Unix/Linux/Mac OS X systems.  For
    these systems, the case of the file name will be as it is entered
    on the SET IPL1NA command.
 
    As a further caution for Unix/Linux hosts, certain expansion characters
    (specifically ~ to refer to your home directory) are interpreted
    by the shell and are not recognized by the Fortran compiler.  These
    expansion characters are interpreted as literal characters and do
    not yield the intended file name.

Default:
    The default name is dppl1f.dat.
 
Synonyms:
    None
 
Related Commands:
    SET FILE SWITCHES  = Probe the values for certain file names and the
                         associated unit numbers and file status.
    DEVICE             = Specify a graphics device.
    SET IPL1NA         = Specify the file name for the DEVICE 2 output.
 
Applications:
    Plotting
 
Implementation Date:
    Pre-1987
 
Program:
    SET IPL1NA plot1.ps
    DEVICE 2 POSTSCRIPT
    PLOT X**2 FOR X = 1 1 9
    DEVICE 2 CLOSE
    .
    SET IPL1NA plot2.ps
    DEVICE 2 POSTSCRIPT
    PLOT X**3 FOR X = 1 1 9
    DEVICE 2 CLOSE
 
-----IPL2NA (SET)--------------------------------------------
 
IPL2NA
 
Name:
    IPL2NA (SET)
 
Type:
    Set Subcommand
 
Purpose:
    Define the name of the plot file created by the DEVICE 3 command.
 
Description:
    By default, Dataplot names the plot file created by the DEVICE 3
    command "dppl2f.dat".  This is the name used regardless of the type
    of device.

    There are times when it is convenient to use a different name for
    the plot file.  For example, you may want to identify the type of
    output file (e.g., you want a ".ps" extension for Postscript files)
    or you want to save the file with a unique name for subsequent use
    after the Dataplot session.

    To set the name of the plot file, do the following

       DEVICE 3 CLOSE
       SET IPL2NA <file-name>
       DEVICE 3 POSTSCRIPT

    Dataplot typically controls the opening and closing of the
    DEVICE 3 output.  For that reason, you may want to enter a
    DEVICE 3 CLOSE command before the SET IPL2NA command.

Syntax:
    SET IPL2NA <string>
    where <string> contains the desired name for the plot file.
 
Examples:
    SET IPL2NA PLOT.PS
    SET IPL2NA PLOT1.JPG

Note:
    File names have the following restrictions:

        1. The file name should be a valid file name for the local
           operating system.

        2. Most Dataplot commands that utilize a file name expect that the
           file name should contain a period "." in the file name itself
           or as a trailing character.  However, this is not required by
           the SET IPL1NA command.

        3. If the file name contains spaces or hyphens, then it needs to be
           enclosed in quotes.

        4. File names are currently limited to 80 characters.

Note:
    File names are case sensitive on Unix/Linux/Mac OS X systems.  For
    these systems, the case of the file name will be as it is entered
    on the SET IPL2NA command.
 
    As a further caution for Unix/Linux hosts, certain expansion characters
    (specifically ~ to refer to your home directory) are interpreted
    by the shell and are not recognized by the Fortran compiler.  These
    expansion characters are interpreted as literal characters and do
    not yield the intended file name.

Default:
    The default name is dppl2f.dat.
 
Synonyms:
    None
 
Related Commands:
    SET FILE SWITCHES         = Probe the values for certain file names
                                and the associated unit numbers and file
                                status.
    DEVICE                    = Specify a graphics device.
    SET IPL1NA                = Specify the file name for the DEVICE 2
                                output.
    SET DEVICE 3              = Specify whether DEVICE 3 output will be
                                controlled by Dataplot or by the user.
    SET DEVICE 3 NAME COUNTER = Specify whether DEVICE 3 ouput will
                                generate each plot in a separate file.
 
Applications:
    Plotting
 
Implementation Date:
    Pre-1987
 
Program:
    DEVICE 3 CLOSE
    SET IPL2NA plot1.ps
    DEVICE 3 POSTSCRIPT
    PLOT X**2 FOR X = 1 1 9
    DEVICE 3 CLOSE
    .
    SET IPL2NA plot2.ps
    DEVICE 3 POSTSCRIPT
    PLOT X**3 FOR X = 1 1 9
    DEVICE 3 CLOSE
 
-----IPR (SET)--------------------------------------------
 
IPR
 
Name:
    IPR (SET)
 
Type:
    Set Subcommand
 
Purpose:
    Define the unit used for alphanumeric output.
 
Description:
    This unit is generally set by the local installer to be the
    terminal screen by default, so the analyst typically does not need
    to modify its value.  Although changing this value can be used to
    redirect the alphanumeric output to a file rather than the screen,
    the CAPTURE command is the recommended way to do this.
 
Syntax:
    SET IPR <unit number>
    where <unit number> is an integer number or parameter in the range
             1 to 99 that identifies the Fortran unit number where
             alphanumeric output will be printed.
 
Examples:
    SET IPR 10
    SET IPR 6
 
Default:
    The terminal screen (6 on most implementations).
 
Synonyms:
    None
 
Related Commands:
    SET IRD       = Set the unit for alphanumeric input.
    CAPTURE       = Redirect alphanumeric output to a file.
 
Applications:
    XX
 
Implementation Date:
    XX.X
 
Program:
    XX
 
-----IND (LET)--------------------------------
 
IND
 
Name:
    IND (LET)
 
Type:
    Library Function
 
Purpose:
    Compute an indicator function.
 
Description:
    Each element of a variable equal to some target value is set to 1
    while all other elements are set to 0.
 
Syntax:
    LET <y2> = IND(<y1>,<tag>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <tag> is a number or parameter which <y1> is compared to;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed indicator function is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = IND(14,4)
    LET A = IND(A1,4)
    LET X2 = IND(X1,4)
    LET X2 = IND(X1-4,A2)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ABS     = Compute the absolute value of a number.
    SQRT    = Compute the square root of a number.
    EXP     = Compute the exponential of a number.
    MOD     = Compute the modulo (i.e., the remainder of x/y) of two
              numbers.
    MIN     = Compute the minimum of two numbers.
    MAX     = Compute the maximum of two numbers.
    DIM     = Compute the positive difference of two numbers.
 
Applications:
    Elementary function
 
Implementation Date:
    Pre-1987
 
Program:
    LET Y1 = DATA 1 4 9 16 25 4 22 7
    LET TAG = 4
    LET Y2 = IND(Y1,TAG)
    The variable Y2 is set to 0 1 0 0 0 1 0 0.
 
-----INDEPENDENT UNIFORM RANDOM NUMBERS------------------------------
 
INDEPENDENT UNIFORM RANDOM NUMBERS
 
Name:
    INDEPENDENT UNIFORM RANDOM NUMBER 
 
Type:
    Let Subcommand
 
Purpose:
    Generate random numbers from independent uniform distributions.
 
Description:
    For univariate distributions, Dataplot generates random
    numbers using the common syntax

       LET <shape-parameter>  = <value>
       LET Y = <dist> RANDOM NUMBERS FOR I = 1 1 N
       LET Y = LOC + SCALE*Y

    Multivariate distributions, however, generally require matrix
    operations.  For this reason, random numbers for multivariate
    distributions each have their own unique syntax.  Although
    you can generate P columns of normal random numbers, this does
    take into account any correlation between the variables (i.e.,
    they are independent).

    Currently, this command assumes that independent uniform
    random numbers are being generated.  That is, there is
    no correlation between the variables.   This command requires
    that you specify the lower and upper limits of each variable.

Syntax:
    LET <mat> = INDEPENDENT UNIFORM RANDOM NUMBERS
                <lowlim> <upplim> <n>
    where <lowlim> is a variable containing the desired lower limits
               of the uniform distributions;
          <upplim> is a variable containing the desired upper limits
               of the uniform distributions;
          <n> is a number or parameter specifying the desired number
               of rows;
    and where <mat> is a matrix where the resulting multivariate
               independent uniform random numbers are stored.
 
    Dataplot determines the number of columns to generate from
    the number of rows in the <lowlim> vector.  Note that the number
    of rows in <lowlim> must equal the number of rows in <upplim>.

Examples:
    LET LOWLIM = DATA -2 -2 -2 -2 -2
    LET UPPLIM = DATA  2  2  2  2  2
    LET N = 25
    LET M = INDEPENDENT UNIFORM RANDOM NUMBERS LOWLIM UPPLIM N
 
Note:
    Dataplot supports a number of different uniform random number
    generators.  For details, enter

       HELP SET RANDOM NUMBER GENERATOR

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    RANDOM NUMBERS                = Generate random numbers for 60+
                                    univariate distributions.
    SET RANDOM NUMBER GENERATOR   = Specify which univariate generator
                                    to use.
    MULTIVARIATE NORM RAND NUMB   = Generate multivariate normal random
                                    numbers.
    MULTIVARIATE T RANDOM NUMBERS = Generate multivariate t random
                                    numbers.
    WISHART RANDOM NUMBERS        = Generate random numbers for a
                                    Wishart distribution.
    DIRICHLET RANDOM NUMBERS      = Generate random numbers for a
                                    Dirichlet distribution.
 
Reference:
    "Multivariate Distributions",
    Johnson, Kotz, and Balakrishnan, Wiley, 199x.
 
Applications:
    Simulation, Bayesian Analysis
 
Implementation Date:
    2003/3
 
Program:
    dimension 100 columns
    .
    LET LOWLIM = DATA -1 -1
    LET UPPLIM = DATA +1 +1
    LET N = 1000
    .
    CHARACTER .
    CHARACTER JUSTIFICATION LEBO
    LINE BLANK
    .
    LET M = INDEPENDENT UNIFORM RANDOM NUMBERS LOWLIM UPPLIM N
    .
    PLOT M1 VS M2

-----INDUCTOR-------------------------------------------------------
 
INDUCTOR
 
Name:
    INDUCTOR
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Draws a (fixed value) inductor (a component used in electronic
    circuit diagrams).
 
Description:
    The 2 pairs of coordinates define the (x,y) values for the start
    point and the end point (respectively) of the inductor.
 
Syntax:
    INDUCTOR   <x1>   <y1>   <x2>   <y2>
    where <x1> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for the start point of
               the inductor;
          <y1> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for the start point of
               the inductor;
          <x2> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for the stop point of
               the inductor;
    and   <y2> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for the stop point of
               the inductor.
 
Examples:
    INDUCTOR 50 50 60 60
    INDUCTOR 50 50 60 50
    INDUCTOR 20 40 20 60
    INDUCTOR 30 30 35 25
    INDUCTOR X1 Y1 X2 Y2
 
Note:
    The line style (i.e., solid, dash), color, and thickness are
    controlled by the LINE, LINE COLOR, and LINE THICKNESS commands.
 
Note:
    The keywords DATA and RELATIVE were added to the TRIANGLE
    command 7/1997.  These keywords are independent and can
    be used separately or together.  For example, 
    TRIANGLE DATA, TRIANGLE RELATIVE, or TRIANGLE DATA RELATIVE.
    The word DATA should come before the word RELATIVE if both
    appear.

    DATA means that the coordinates are specified in terms of
    the data units of the most recent plot rather than Dataplot
    0 to 100 screen units.

    RELATIVE means that the coordinates of the first point
    are drawn in absolute coordinates an all subsequent points
    in the figure are relative to that first point.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    AMPLIFIER        = Draws an amplifier.
    CAPACITOR        = Draws a capacitor.
    GROUND           = Draws a ground.
    RESISTOR         = Draws a resistor.
    MOVE             = Moves to a point.
    DRAW             = Draws a line.
    LINES            = Sets the line type for figures and plot lines.
    LINE THICKNESSES = Sets the line thickness for figures and  plot
                       lines.
    LINE COLOR       = Sets the line colors for figures and plot lines.
    CROSS-HAIR       = Activates and reads the cross-hair.
    TEXT             = Writes a text string.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    Pre-1987
 
Program:
    LINE SOLID
    LINE COLOR BLACK
    LINE THICKNESS 0.2
    INDUCTOR 20 70 50 70
    MOVE 20 90
    TEXT INDUCTOR COORDINATES (20,70), (50,70)
 
-----INDEX EXTREME-------------------------------------------------
 
INDEX EXTREME

Name:
    INDEX EXTREME (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the index of the extreme value (i.e., the value with the
    largest absolute value) in a variable.
 
Syntax:
    LET <par> = INDEX EXTREME <resp>   <SUBSET/EXCEPT/FOR qualification>
    where <resp> is the variable for which the index extreme value is to
                 be computed;
          <par> is a parameter where the index extreme value value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET K1 = INDEX EXTREME Y1

Note:
    The following additional commands are supported

        TABULATE INDEX EXTREME Y X
        CROSS TABULATE INDEX EXTREME Y X1 ... XK
        LET Y2 = CROSS TABULATE INDEX EXTREME Y X1 ... XK
        LET Y2 = MATRIX ROW INDEX EXTREME M
        LET Y2 = MATRIX COLUMN INDEX EXTREME M
        LET Y2 = MATRIX GRAND INDEX EXTREME M
        LET Y2 = MATRIX PARTITION INDEX EXTREME M NROW NCOL
        LET Y2 = SORT BY INDEX EXTREME Y

        INDEX MININUM PLOT Y X
        CROSS TABULATE INDEX MININUM PLOT Y X1 X2

        INDEX EXTREME BLOCK PLOT Y X1 ... XK

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    INDEX MAXIMUM   = Compute the index for the maximum value of a
                      variable.
    INDEX MINIMUM   = Compute the index for the minimum value of a
                      variable.
    EXTREME         = Compute the extreme value value of a variable.
    MAXIMUM         = Compute the maximum value of a variable.
    MEAN            = Compute the mean of a variable.
    MAX             = Library function to compute the maximum of 2
                      numbers.
    MIN             = Library function to compute the extreme value of 2
                      numbers.
 
Applications:
    Data Analysis
 
Implementation Date:
    2009/2
 
Program 1:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET A = INDEX EXTREME Y1
 
Program 2:
    .  Generate a "table" plot that contains
    .
    .    1) Subset flow category = 1
    .    2) Row denotes flow value
    .       Column denotes cond value
    .    3) Plot symbol denotes algorithm corresponding
    .       to "extreme value"
    .  Step 1: Read the data
    .
    dimension 400 variables
    read mills96.dat flow alg cond flowcat y1 to y14
    retain flow alg cond y1  subset flowcat = 1
    .
    .  Step 2: Perform the relevant cross-tabulations
    .
    let 
    set let cross tabulate collapse
    let ytemp  = cross tabulate group two flow cond
    let xtemp  = cross tabulate group one flow cond
    let extind = cross tabulate index extreme value y1 flow cond
    let ntemp  = size ytemp
    let vsize = 1 for i = 1 1 ntemp
    .
    .  Step 3: Generate the table plot using the symbol plot command
    .
    char 1 2 3 4 5 6 7
    y1label Condition Value
    x1label Flow Value
    xlimits 1 24
    major xtic mark number 24
    minor xtic mark number 0
    ylimits 1 32
    major ytic mark number 32
    minor ytic mark number 0
    tic offset units data
    tic offset 1 1
    .
    symbol plot ytemp xtemp vsize extind

-----INDEX FIRST MATCH (LET)--------------------------------------------
 
INDEX FIRST MATCH
 
Name:
    INDEX FIRST MATCH (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Return the index (i.e., the row number) of either the first or last
    matching (or non-matching) entries for two arrays.
 
Description:
    It may sometimes be convenient to determine the index of the
    first row where two distinct arrays have the same value.
    Likewise, it may be convenient to determine the index of the
    last row where they have the same value.  If no match is
    found, an index of 0 is returned.

    You can also return the index of the first or last row where
    the two arrays have different values.  If all rows have the
    same value, then an index of 0 is returned.

    The two arrays do not need to be same size.  For the case where
    the two arrays are of different sizes and we are looking for the
    first row where they do not have the same value, the index returned
    is MIN(N1,N2) + 1 where N1 and N2 are number of rows for the two
    arrays.  For the case where the two arrays are of different sizes and
    we are looking for the last row where they do not have the same value,
    the index returned is MAX(N1,N2) where N1 and N2 are number of rows
    for the two arrays.

Syntax 1:
    LET <par> = INDEX FIRST MATCH <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter containing the returned index;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This is for the case where we are looking for the index where
    the two arrays first have the same value.

Syntax 2:
    LET <par> = INDEX LAST MATCH <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter containing the returned index;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This is for the case where we are looking for the index where
    the two arrays last have the same value.

Syntax 3:
    LET <par> = INDEX FIRST NOT MATCH <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter containing the returned index;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This is for the case where we are looking for the index where
    the two arrays first have different values.

Syntax 4:
    LET <par> = INDEX LAST NOT MATCH <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter containing the returned index;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This is for the case where we are looking for the index where
    the two arrays last have different values.

Examples:
    LET A = INDEX FIRST MATCH Y1 Y2
    LET A = INDEX FIRST MATCH Y1 Y2  SUBSET TAG > 1
    LET A = INDEX LAST MATCH Y1 Y2
 
Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    PERCENT AGREE      = Compute the percentage of values that agree
                         in two response variables.
    PERCENT DISAGREE   = Compute the percentage of values that disagree
                         in two response variables.
 
Applications:
    Data Manipulation
 
Implementation Date:
    2011/11
 
Program:
    read y1 y2
     23 19
     31 31
     18 42
     22 10
     26 26
     11 14
    end of data
    .
    let n = size y1
    let indx = sequence 1 1 n
    set write decimals 0
    .
    let a1 = index first match y1 y2
    let a2 = index last  match y1 y2
    let a3 = index first not match y1 y2
    let a4 = index last  not match y1 y2
    .
    set write decimals 0
    print indx y1 y2
    print a1 a2 a3 a4
 
-----INDEX MAXIMUM-------------------------------------------------
 
INDEX MAXIMUM

Name:
    INDEX MAXIMUM (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the index of the maximum value in a variable.
 
Syntax:
    LET <par> = INDEX MAXIMUM <resp>   <SUBSET/EXCEPT/FOR qualification>
    where <resp> is the variable for which the index maximum is to be
                 computed;
          <par> is a parameter where the index maximum value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET K1 = INDEX MAXIMUM Y1

Note:
    The following additional commands are supported

        TABULATE INDEX MAXIMUM Y X
        CROSS TABULATE INDEX MAXIMUM Y X1 ... XK
        LET Y2 = CROSS TABULATE INDEX MAXIMUM Y X1 ... XK
        LET Y2 = MATRIX ROW INDEX MAXIMUM M
        LET Y2 = MATRIX COLUMN INDEX MAXIMUM M
        LET Y2 = MATRIX GRAND INDEX MAXIMUM M
        LET Y2 = MATRIX PARTITION INDEX MAXIMUM M NROW NCOL
        LET Y2 = SORT BY INDEX MAXIMUM Y

        INDEX MININUM PLOT Y X
        CROSS TABULATE INDEX MININUM PLOT Y X1 X2

        INDEX MAXIMUM BLOCK PLOT Y X1 ... XK

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    INDEX MINIMUM   = Compute the index for the minimum value of a
                      variable.
    INDEX EXTREME   = Compute the index for the most extreme value of a
                      variable.
    MAXIMUM         = Compute the maximum value of a variable.
    MAXIMUM         = Compute the maximum value of a variable.
    MEAN            = Compute the mean of a variable.
    MAX             = Library function to compute the maximum of 2
                      numbers.
    MIN             = Library function to compute the maximum of 2
                      numbers.
 
Applications:
    Data Analysis
 
Implementation Date:
    2009/2
 
Program 1:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET A = INDEX MAXIMUM Y1
 
Program 2:
    .  Generate a "table" plot that contains
    .
    .    1) Subset flow category = 1
    .    2) Row denotes flow value
    .       Column denotes cond value
    .    3) Plot symbol denotes algorithm corresponding
    .       to "maximum value"
    .  Step 1: Read the data
    .
    dimension 400 variables
    read mills96.dat flow alg cond flowcat y1 to y14
    retain flow alg cond y1  subset flowcat = 1
    .
    .  Step 2: Perform the relevant cross-tabulations
    .
    let 
    set let cross tabulate collapse
    let ytemp  = cross tabulate group two flow cond
    let xtemp  = cross tabulate group one flow cond
    let maxind = cross tabulate index maximum y1 flow cond
    let ntemp  = size ytemp
    let vsize = 1 for i = 1 1 ntemp
    .
    .  Step 3: Generate the table plot using the symbol plot command
    .
    char 1 2 3 4 5 6 7
    y1label Condition Value
    x1label Flow Value
    xlimits 1 24
    major xtic mark number 24
    minor xtic mark number 0
    ylimits 1 32
    major ytic mark number 32
    minor ytic mark number 0
    tic offset units data
    tic offset 1 1
    .
    symbol plot ytemp xtemp vsize maxind

-----INDEX MINIMUM-------------------------------------------------
 
INDEX MINIMUM

Name:
    INDEX MINIMUM (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the index of the minimum value in a variable.
 
Syntax:
    LET <par> = INDEX MINIMUM <resp>   <SUBSET/EXCEPT/FOR qualification>
    where <resp> is the variable for which the index minimum is to be
                 computed;
          <par> is a parameter where the index minimum value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET K1 = INDEX MINIMUM Y1

Note:
    The following additional commands are supported

        TABULATE INDEX MINIMUM Y X
        CROSS TABULATE INDEX MINIMUM Y X1 ... XK
        LET Y2 = CROSS TABULATE INDEX MINIMUM Y X1 ... XK
        LET Y2 = MATRIX ROW INDEX MINIMUM M
        LET Y2 = MATRIX COLUMN INDEX MINIMUM M
        LET Y2 = MATRIX GRAND INDEX MINIMUM M
        LET Y2 = MATRIX PARTITION INDEX MINIMUM M NROW NCOL
        LET Y2 = SORT BY INDEX MINIMUM Y

        INDEX MININUM PLOT Y X
        CROSS TABULATE INDEX MININUM PLOT Y X1 X2

        INDEX MINIMUM BLOCK PLOT Y X1 ... XK

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    INDEX MAXIMUM   = Compute the index for the maximum value of a
                      variable.
    INDEX EXTREME   = Compute the index for the most extreme value of a
                      variable.
    MINIMUM         = Compute the minimum value of a variable.
    MAXIMUM         = Compute the maximum value of a variable.
    MEAN            = Compute the mean of a variable.
    MAX             = Library function to compute the maximum of 2
                      numbers.
    MIN             = Library function to compute the minimum of 2
                      numbers.
 
Applications:
    Data Analysis
 
Implementation Date:
    2009/2
 
Program 1:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET A = INDEX MINIMUM Y1
 
Program 2:
    .  Generate a "table" plot that contains
    .
    .    1) Subset flow category = 1
    .    2) Row denotes flow value
    .       Column denotes cond value
    .    3) Plot symbol denotes algorithm corresponding
    .       to "minimum value"
    .  Step 1: Read the data
    .
    dimension 400 variables
    read mills96.dat flow alg cond flowcat y1 to y14
    retain flow alg cond y1  subset flowcat = 1
    .
    .  Step 2: Perform the relevant cross-tabulations
    .
    let 
    set let cross tabulate collapse
    let ytemp  = cross tabulate group two flow cond
    let xtemp  = cross tabulate group one flow cond
    let minind = cross tabulate index minimum y1 flow cond
    let ntemp  = size ytemp
    let vsize = 1 for i = 1 1 ntemp
    .
    .  Step 3: Generate the table plot using the symbol plot command
    .
    char 1 2 3 4 5 6 7
    y1label Condition Value
    x1label Flow Value
    xlimits 1 24
    major xtic mark number 24
    minor xtic mark number 0
    ylimits 1 32
    major ytic mark number 32
    minor ytic mark number 0
    tic offset units data
    tic offset 1 1
    .
    symbol plot ytemp xtemp vsize minind

-----INDEX OF DISPERSION (LET)------------------------------
 
INDEX OF DISPERSION
 
Name:
    INDEX OF DISPERSION (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the index of dispersion of a variable.
 
Description:
    The sample index of dispersion is defined as the ratio of
    the variance to the mean:

         d = s**2/xbar

    where s**2 is the sample variance and xbar is the sample mean.
    That is, it shows the variability, as defined by the variance,
    relative to the mean.

    The index of dispersion is related to the coefficient of variation
    (the ratio of the standard deviation to the mean) and the coefficient
    of dispersion (the ratio of the mean absolute deviation to the
    median).  The index of dispersion is also referred to the
    coefficient of dispersion.  However, Dataplot reserves this term
    for the ratio of the median absolute deviation to the mean.

    The index of dispersion should typically only be used for data
    measured on a ratio scale.  That is, the data should be have a
    meaningful zero.  The index of dispersion is sometimes used for count
    data.  If the count data follows a Poisson distribution, then the
    mean and variance should be equal and the index of dispersion is 1.
    If the counts follow a geometric or negative binomial, then the index
    of dispersion should be greater than 1.  If the counts follow a
    binomial distribution, the index of dispersion should be less than 1.

Syntax 1:
    LET <par> = INDEX OF DISPERSION <y>
                <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <par> is a parameter where the index of dispersion
              value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Syntax 2:
    LET <par> = DIFFERENCE OF INDEX OF DISPERSION <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter where the difference of the index
              of dispersion values is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Examples:
    LET D = INDEX OF DISPERSION Y1
    LET D = INDEX OF DISPERSION Y1  SUBSET TAG > 2

    LET DDIFF = DIFFERENCE OF INDEX OF DISPERSION Y1

Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COEFFICIENT OF VARIATION   = Compute the coefficient of variation.
    COEFFICIENT OF DISPERSION  = Compute the coefficient of dispersion
                                 of a variable.
    QUARTILE COEF OF DISP      = Compute the quartile coefficient of
                                 dispersion of a variable.
    RELATIVE STAND DEVI        = Compute the relative standard
                                 deviation of a variable.
    MEAN                       = Compute the mean of a variable.
    VARIANCE                   = Compute the variance of a variable.
 
Applications:
    Data Analysis
 
Implementation Date:
    2017/01
    2017/06: Added DIFFERENCE OF INDEX OF DISPERSION
 
Program 1:
    LET LAMBDA = 2.9
    LET Y1 = POISSON RANDOM NUMBERS FOR I = 1 1 100
    LET D = INDEX OF DISPERSION Y1
 
Program 2:
    . Step 1:   Create the data
    .
    skip 25
    read gear.dat y x
    skip 0
    set write decimals 6
    .
    . Step 2:   Define plot control
    .
    title case asis
    title offset 2
    label case asis
    .
    y1label Index of Dispersion
    x1label Group
    title Index of Dispersion for GEAR.DAT
    let ngroup = unique x
    xlimits 1 ngroup
    major x1tic mark number ngroup
    minor x1tic mark number 0
    tic mark offset units data
    x1tic mark offset 0.5 0.5
    y1tic mark label decimals 5
    y1label displacement 12
    .
    character X
    line blank
    .
    set statistic plot reference line average
    index of dispersion plot y x
    .
    tabulate index of dispersion y x

Program 3:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF INDEX OF DISPERSION Y1 Y2
    SET WRITE DECIMALS 4
    TABULATE DIFFERENCE OF INDEX OF DISPERSION Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF INDEX OF DISPERSION
    CHAR X
    LINE BLANK
    DIFFERENCE OF INDEX OF DISPERSION PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF INDEX OF DISPERSION PLOT Y1 Y2 X 
 
-----INFINITY-------------------------------------------------------
 
INFINITY
 
Name:
    INFINITY
 
Type:
    Keyword
 
Purpose:
    An internal DATAPLOT parameter which has the value of the largest
    floating point number that your computer can hold.
 
Description:
    This value is sometimes referred to as "machine infinity".  This
    parameter is automatically provided at sign-on.  The INFINITY
    parameter is only used in connection with one form of the SUBSET
    and EXCEPT qualifications.   These can be appended to any of the
    graphics or analysis category commands and certain support category
    commands.  The SUBSET/EXCEPT qualification at the end of these
    commands specifies the subset of observations in the variable to be
    operated on.  For example, PRINT X prints all elements of the
    variable X while PRINT X SUBSET X 1000 TO INFINITY prints only
    those values of the variable X which are equal to or greater than
    1000.  The use of the INFINITY parameter is relatively light due to
    the existence of an alternate form of the SUBSET/EXCEPT
    qualification.  For example,  PRINT X SUBSET X 1000 TO INFINITY can
    be written more succinctly as PRINT X SUBSET X >= 1000   .
 
Syntax: (For all graphics/analysis commands and some support commands)
    <Command>   <SUBSET  or EXCEPT>   <x>   <x1>   TO   INFINITY
    where <Command> is any graphics or analysis command or certain
               support commands;
          <x> is a variable for which the analyst wishes to define the
               subset;
    and   <x1> is a number or parameter that is the desired lower bound
               of the subset.
 
    Infinity will be the upper bound of the subset according to this
    restricted form (there exists much more general forms) of the
    SUBSET/EXCEPT qualification.
 
Examples:
    PLOT Y1 Y2 Y3 VS X SUBSET X 500 TO INFINITY
    FIT (A+B*X)/(C+D*X) SUBSET X 101 TO INFINITY
    FIT (A+B*X)/(C+D*X) EXCEPT X 101 TO INFINITY
    FIT (A+B*X)/(C+D*X) SUBSET LAB 5 TO INFINITY
    FIT (A+B*X)/(C+D*X) EXCEPT LAB 5 TO INFINITY
    SMOOTH Y EXCEPT X 201 TO INFINITY
    PRINT Y X TEMP EXCEPT TEMP 100 TO INFINITY
    RETAIN Y X TEMP EXCEPT TEMP 100 TO INFINITY
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    PI      = Built-in parameter with value 3.1415926.
    SUBSET  = Allows specification of a subset.
    EXCEPT  = Allows exclusion-specification of a subset.
    FOR     = Allows row-specification of a subset.
 
Applications:
    XX
 
Implementation Date:
    Pre-1987
 
Program:
    XX
 
-----INFORMATIVE QUANTILE FUNCTION (LET)-------------------------------------
 
INFORMATIVE QUANTILE FUNCTION
TRUNCATED INFORMATIVE QUANTILE FUNCTION
 
Name:
    INFORMATIVE QUANTILE FUNCTION (LET)
    TRUNCATED INFORMATIVE QUANTILE FUNCTION (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the informative quantile function or the truncated
    informative quantile function.
 
Description:
    The quantile function is the inverse of the cumulative distribution
    function, F,

          Q(u) = F**(-1)(u)    0 < u < 1

    Given a set of ordered data, x(1) <= x(2) ... <= x(n), an empirical
    estimate of the quantile function can be obtained from the following
    piecewise linear function

          Qhat(u) = (N*u - j + (1/2))*X(j+1) +
                    (j + (1/2) - N*u)*X(j)

                    (2-j-1)/(2*N) <= u < (2*j+1)/(2*n)
                    j = 1, 2, ... n-1

    Qhat will be computed for a specified number of equi-spaced points
    between the lower and upper limits.  Dataplot will use the number of
    points in the sample if this is greater than 1,000.  Otherwise 1,000
    points will be used.

    The estimated informative quantile (IQ) function is defined by

        IQhat(u) = (Qhat(u) - Qhat(0.5))/(2*(Qhat(0.75) - Qhat(0.25)))

    where Q(u) is the estimated quantile function desribed above.  The
    corresponding exact function, denoted by IQ(u), replaces Qhat with Q
    in the above formula.  The estimated IQhat values are determined from
    the data while the exact IQ values are determined from a theoretical
    location-scale distribution (e.g., the normal, uniform, or Gumbel).

    The estimated truncated IQ function is defined by

        TIQhat(u) = -1         if IQhat(u) <= -1
                  = IQhat(u)   if -1 < IQhat(u) <= 1
                  = 1          if IQhat(u) > 1

    The TRUNCATED INFORMATIVE QUANTILE PLOT command is used to plot the
    truncated informative quantiles of the data along with the truncated
    informative quantiles of a specific location/scale distribution.

Syntax 1:
    LET <y> <u> = INFORMATIVE QUANTILE FUNCTION <x>
                  <SUBSET/EXCEPT/FOR qualification>
    where <x> is the response variable;
          <y> is a variable containing the informative quantile
              function values;
          <u> is a variable containing the values where the informative
              quantile function is computed;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    LET <y> = TRUNCATED INFORMATIVE QUANTILE FUNCTION <x>
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is the response variable;
          <y> is a variable containing the truncated informative quantile
              function values;
          <u> is a variable containing the values where the truncated
              informative quantile function is computed;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y U = INFORMATIVE QUANTILE FUNCTION X
    LET Y U = INFORMATIVE QUANTILE FUNCTION X  SUBSET X > 0
    LET Y U = TRUNCATED INFORMATIVE QUANTILE FUNCTION X
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TRUNCATED INFORMATIVE QUANTILE PLOT = Generate a truncated informative
                                          quantile plot.
    EMPIRICAL QUANTILE PLOT             = Generate an empirical quantile plot.
    EMPIRICAL CDF PLOT                  = Generate an empirical CDF plot.
    KAPLAN MEIER PLOT                   = Generate a Kaplan Meier plot.
    PROBABILITY PLOT                    = Generate a probability plot.
    EMPIRICAL QUANTILE FUNCTION         = Compute the empirical quantile
                                          function.

References:
    "MIL-HDBK-17-1F Volume 1: Guidelines for Characterization of
    Structural Materials", Depeartment of Defense, pp. 8-36 - 8-39, 2002.
 
    Parzen (1983), "Informative Quantile Functions and Identification of
    Probability Distribution Types", Technical Report No. A-26, Texas A&M
    University.

Applications:
    Distributional Analysis
 
Implementation Date:
    2017/02
 
Program:
    . Step 1:   Define some default plot control features
    .
    title offset 2
    title case asis
    case asis
    label case asis
    line color blue red
    multiplot scale factor 2
    multiplot corner coordinates 5 5 95 95
    .
    . Step 2:   Create 50, 100, 200, and 1000 normal random numbers and
    .           compute the informative quantile funciton
    .
    let nv = data 50 100 200 1000
    let p = sequence 0.01 0.01 .99
    let y2 = norppf(p)
    set write decimals 3
    .
    . Step 3:   Loop through the four case and compute and plot the
    .           informative quantile funciton with overlaid NORPPF
    .
    multiplot 2 2
    loop for k = 1 1 4
        let n = nv(k)
        let x = norm rand numb for i = 1 1 n
        let y u   = informative quantile function x
        let y2 u2 = truncated informative quantile function x
        title N: ^n
        plot y  u and
        plot y2 u2
    end of loop
    end of multiplot
    .
    justification center
    move 50 97
    text Informative Quantile Functions (blue) and Truncated Informative ...
    Quantile Functions (red) for Normal Random Numbers
    move 50 5
    text u
    direction vertical
    move 5 50
    text IQ(u)

-----INFLUENCE CURVE---------------------------------------------------
 
INFLUENCE CURVE
 
Name:
    ... INFLUENCE CURVE
 
Type:
    Graphics Command
 
Purpose:
    Generate an influence curve for a given statistic.
 
Description:
    Influence functions are an important concept in studying
    robust statistics.  The influence curve attempts to
    provide empirical insight into the "influence".

    Given a set of univariate data points, Y, and a specified
    statistic, the influence is studied by determining how the
    value of the statistic changes as a single point is added to Y.
    Specifically, we define a set of X values (typically over
    a fairly broad range relative to the original Y values).
    The influence curve is generated by plotting the value
    of the computed statistic with a single point of X added to
    Y against that X value.

    Several features are of interest in the influence curve:

    1) Is the curve "bounded" as the X values become extreme?
       Robust statistics should be bounded.  That is, a robust
       statistic should not be unduly influenced by a single
       extreme point.

    2) What is the general behaviour as the X point becomes
       extreme?  For example, does it becomes smoothly down-weighted
       as the values become extreme?

    3) What is the influence if the X point is in the "center"
       of the Y points?
 
Syntax:
    <stat> INFLUENCE CURVE <y> <x> <SUBSET/EXCEPT/FOR qualification>
    where <stat> is one of the following statistics:
              MEAN, MIDMEAN, MEDIAN, TRIMMED MEAN, WINDSORIZED MEAN,
              BIWEIGHT LOCATION, HODGES-LEHMAN,
              GEOMETRIC MEAN, HARMONIC MEAN,
              STANDARD DEVIATION, RELATIVE STANDARD DEVIATION,
              STANDARD DEVIATION OF MEAN,
              TRIMMED MEAN STANDARD ERROR,
              RELATIVE VARIANCE (or COEFFICIENT OF VARIATION),
              VARIANCE, VARIANCE OF THE MEAN,
              RANGE, GEOMETRIC STANDARD DEVIATION,
              AVERAGE ABSOLUTE DEVIATION (or AAD),
              MEDIAN ABSOLUTE DEVIATION (or MAD),
              INTERQUARTILE RANGE, PERCENTAGE BEND MIDVARIANCE,
              BIWEIGHT SCALE, BIWEIGHT MIDVARIANCE,
              WINSORIZED VARIANCE, WINSORIZED STANDARD DEVIATION,
              SN SCALE, QN SCALE,
              MIDRANGE,
              MAXIMUM, MINIMUM, EXTREME,
              SKEWNESS, KURTOSIS,
              AUTOCORRELATION, AUTOCOVARIANCE,
              LOWER HINGE, UPPER HINGE, LOWER QUARTILE, UPPER QUARTILE,
              <FIRST/SECOND/THIRD/FOURTH/FIFTH/SIXTH/SEVENTH/EIGHTH/
                  NINTH/TENTH> DECILE,
              PERCENTILE, QUANTILE, QUANTILE STANDARD ERROR,
              NORMAL PPCC,
              SINE FREQUENCY, SINE AMPLITUDE,
              CP, CPK, CNPK, CPM, CC, CPL, CPU,
              EXPECTED LOSS, PERCENT DEFECTIVE,
              TAGUCHI SN0 (or SN), TAGUCHI SN+ (or SNL),
              TAGUCHI SN- (or SNS), TAGUCHI SN00 (or SN2);
          <y> is the response (= dependent) variable;
          <x> is a variable containing a sequence of X values;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    MEAN INFLUENCE CURVE Y X
    BIWEIGHT LOCATION INFLUENCE CURVE Y X1
 
Note:
    Although DATAPLOT supports this command for a large number of
    statistics, there may be cases where you want it for an
    unsupported statistic.  The following example shows how to
    compute the mean influence curve (this is a supported
    statistic, the example is meant simply to demonstrate the
    method):

        LET Y = NORMAL RANDOM NUMBERS FOR I = 1 1 30
        LET XSEQ = SEQUENCE -10  0.1  10
        LET N = SIZE XSEQ
        LET NY = SIZE Y
        LET NTEMP = NY1 + 1
        LOOP FOR K = 1 1 N
            LET XTEMP = XSEQ(K)
            LET Y(NTEMP) = XTEMP
            LET A = MEAN Y
            LET YNEW(K) = A
        END OF LOOP
        PLOT YNEW XTEMP
 
    This basic idea can be easily adapted to unsupported statistics.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHARACTERS         = Sets the type for plot characters.
    LINES              = Sets the type for plot lines.
    STATISTIC PLOT     = Plot a statistic for grouped data.
    BBOTSTRAP PLOT     = Generate a bootstrap plot for a statistic.
 
References:
    Tukey and Mosteller (1977).  "Data Analysis and Regression",
    Duxbury Press.

    Rand Wilcox (1997).  "Introduction to Robust Estimation and
    Hypothesis Testing", Academic Press.

Applications:
    Robust Data Analysis
 
Implementation Date:
    2002/7
 
Program:
    LET Y = NORMAL RANDOM NUMBERS FOR I = 1 1 50
    LET XSEQ = SEQUENCE -20 0.1 20
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    MULTIPLOT SCALE FACTOR 2
    .
    TITLE MEAN INFLUENCE CURVE
    MEAN INFLUENCE CURVE Y XSEQ
    LET P1 = 10
    LET P2 = 10
    TITLE TRIMMED MEAN INFLUENCE CURVE
    TRIMMED MEAN INFLUENCE CURVE Y XSEQ
    TITLE WINSORIZED MEAN INFLUENCE CURVE
    WINSORIZED MEAN INFLUENCE CURVE Y XSEQ
    TITLE BIWEIGHT LOCATION INFLUENCE CURVE
    BIWEIGHT LOCATION INFLUENCE CURVE Y XSEQ
    .
    END OF MULTIPLOT
 
-----INQUIRE (LET)---------------------------------------------------
 
INQUIRE
 
Name:
    INQUIRE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Determine if a file exists.
 
Description:
    Dataplot commamnds that access pre-existing files (e.g., READ, CALL,
    LIST) have several specific restrictions.

       1. A "." is required in the name to identify the string as a file.

          This restriction does not apply to the INQUIRE command.

       2. File names that contain spaces or hyphens should be enclosed in
          quotes (").

          For the INQUIRE command, the quotes are optional.

       3. Dataplot will first check for the file in the current directory
          as given.  For operating systems where file names are case
          sensitive (Linux/Unix, Mac OS X), Dataplot will then check the
          name with all characters converted to lower case and with all
          characters converted to upper case.  If the file is not found in
          the current directory, Dataplot will then check in the Dataplot
          auxillary directory (e.g., "/usr/local/lib/dataplot" under Linux
          or "C:\Program Files (x86)\NIST\DATAPLOT under Windows) for the
          file.

          The INQUIRE command does not do this.  It checks the file name
          as given in the current directory only.

Syntax 1:
    LET <iflag> = INQUIRE <file>
    where <file> is the name of the desired file;
    and   <iflag> is a parameter that contains the file status.

    If the file exists, the <iflag> parameter will be set to 1.  If the
    file does not exist, the <iflag> parameter will be set to 0.
 
Syntax 2:
    LET <iflag> = INQUIRE <unit>
    where <unit> is an integer value between 1 and 99;
    and   <iflag> is a parameter that contains the file status.

    If the unit number is associated with a currently open file, the
    <iflag> parameter will be set to 1.  If the unit number is not
    associated with a currently open file, the <iflag> parameter will be
    set to 0.

    This syntax is typically used by the Dataplot developers for
    debugging purposes.
 
Examples:
    LET IFLAG = INQUIRE BERGER1.DAT
    LET IFLAG = INQUIRE "MY FILES\SAMPLE.DAT"
    LET IFLAG = INQUIRE 44
 
Note:
    The specified file name should be given as a literal string.  If the file
    name is stored in a string, you can use the "^" character as in

        LET IFLAG = INQUIRE ^FNAME

    Likewise, if a unit number is given it should be entered as a literal
    number.  If you have the unit number stored as a parameter, you can use
    the "^" character as in

        LET IFLAG = INQUIRE ^IVAL

Note:
    File names are currently limited to 80 characters.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    READ           = Read data from file or terminal.
    SERIAL READ    = Read data serially from file or terminal.
    CALL           = Execute the commands stored in a file.
    LIST           = List the contents of a file.
 
Applications:
    Data Input
 
Implementation Date:
    2016/02
    2016/06: Added support for unit numbers (Syntax 2)
 
Program 1:
    LET IFLAG = INQUIRE BERGER1.DAT
    IF IFLAG = 1
       READ BERGER1.DAT Y X BATCH
    ELSE
       PRINT "FILE BERGER1.DAT NOT FOUND"
    END OF IF
 
Program 2:
    PROBE IPL1NU
    LET UNIT = PROBEVAL
    LET IFLAG = INQUIRE ^IPL1NU
 
-----INT (LET)--------------------------------
 
INT
 
Name:
    INT (LET)
 
Type:
    Library Function
 
Purpose:
    Return the integer portion of a number or variable.
 
Syntax:
    LET <y2> = INT(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1>
               is) where the computed integer values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = INT(2.83)
    LET A = INT(A1)
    LET X2 = INT(X1)
    LET X2 = INT(X1-4.2)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FLOOR  = Compute the integer value rounded to negative infinity.
    CEIL   = Compute the integer value rounded to positive infinity.
    SIGN   = Compute the sign of a number.
    FRACT  = Compute the fractional portion of number.
    MSD    = Compute the most significant digit of a number.
    ROUND  = Round to the closest integer of a number.
 
Applications:
    Elementary function
 
Implementation Date:
    Pre-1987
 
Program:
    LET Y1 = SEQUENCE 0 0.1 10
    LET Y2 = INT(Y1)
    PRINT Y1 Y2
 
-----INTEGER FREQUENCY TABLE (LET)---------------------------------
 
INTEGER FREQUENCY TABLE
 
Name:
    INTEGER FREQUENCY TABLE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Create a frequency table for integer values.
 
Description:
    This command is intended for binning data for discrete
    distributions.  In partiucular, this command is typically
    used before performing a chi-square goodness of fit.

    There are two primary features for the binning:

       1) Discrete distributions typically expect the data
          to occur at integer values.  This command will
          bin the data at the integer values in the data.

       2) The usual recommendation for the chi-square goodness
          of fit test is that the minimum class frequency
          should be at least five.  This command will
          automatically combine bins with small frequencies.
          The default minimum class frequency is five, although
          this can be set to a different value.

Syntax:
    LET <y2> <xlow> <xhigh> = INTEGER FREQUENCY TABLE <y>
                              <SUBSET/EXCEPT/FOR qualification>
    where <y> is a variable containing the raw data;
          <y2> is a variable where the class frequencies are
              stored;
          <xlow> is a variable where the lower limits for the
              class bins are stored;
          <xhigh> is a variable where the upper limits for the
              combined bins are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y2 XLOW XHIGH = INTEGER FREQUENCY TABLE Y
 
Note:
    You can specify the minimum frequency for a bin by entering
    the command

        LET MINSIZE = <value>

    before the INTEGER FREQUENCY TABLE command.

Note:
    The following commands currently accept grouped data with
    either equal size bins or unequal size bins:

       PROBABILITY PLOT
       PPCC PLOT
       KS PLOT (plots minimum chi-square statistic for discrete
               distributions)
       CHI-SQUARE GOODNESS OF FIT

Default:
    The minimum frequency for a bin defaults to 5.
 
Synonyms:
    None
 
Related Commands:
    BINNED                      = Convert raw data to grouped data.
    COMBINE FREQUENCY TABLE     = Convert raw data to grouped data.
    CHI SQUARE GOODNESS OF FIT  = Perform a chi-square goodness
                                  of fit test.
    PROBABILITY PLOT            = Generate a probability plot.
    PPCC PLOT                   = Generate a ppcc plot.
    KS PLOT                     = Generate a Kolmogorov-Smirnov (or
                                  chi-square) goodness of fit plot.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2006/5
 
Program:
    LET K = 3
    LET LAMBDA = 0.9
    LET Y = BOREL TANNER RANDOM NUMBERS FOR I = 1 1 500
    LET Y2 XLOW XHIGH = INTEGER FREQUENCY TABLE Y
    LET LAMBDA1 = 0.5
    LET LAMBDA2 = 0.95
    Y1LABEL CHI-SQUARE
    X1LABEL LAMBDA
    BOREL TANNER KS PLOT Y2 XLOW XHIGH
    JUSTIFICATION CENTER
    MOVE 50 5
    TEXT LAMBDAHAT = ^shape, Minimum Chi-Square = ^minks
 
-----INTEGRAL (LET)-------------------------------------------------
 
INTEGRAL
 
Name:
    INTEGRAL (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute a definite integral for a function or for the elements
    in a variable.
 
Description:
    The definite integral is the area underneath the curve (i.e., from
    the curve to the x axis) between 2 points.
 
Syntax 1: (for a function)
    LET <resp> = INTEGRAL <function>  WRT <var>
                          FOR <var> = <lower> <upper>
    where <function> is the name of a previously defined function or a
             functional expression;
          <var> is the variable for which the integral is being
             computed;
          <lower> is a number or parameter defining the lower limit
             for the definite integral;
          <upper> is a number or parameter defining the upper limit
             for the definite integral;
          <resp> is a parameter where the evaluated integral is stored.
 
Syntax 2: (for the elements in a variable)
    LET <par> = INTEGRAL <resp> <x> <SUBSET/EXCEPT/FOR qualification>
    where <resp> is the name of a variable for which the integral is
             to be computed;
          <x> is an optional horizontal axis variable (if not
              specified, equi-spaced values are used);
          <par> is a parameter where the evaluated integral is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = INTEGRAL X**2+2*X**2-4*X+5 WRT X FOR X = 1 3
    LET A = INTEGRAL F1 WRT X FOR X = 0 B
 
Note:
    DATAPLOT calculates integrals numerically.  The INTEGRAL command
    uses Gaussian quadrature for functions and the trapezoid rule for
    variables.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CUMULATIVE INTEGRAL  = Compute the cumulative integrals of elements
                           in a variable.
    DERIVATIVE           = Compute the derivative of a function.
    ROOTS                = Compute the roots of a function.
    RUNGE KUTTA          = Compute the Runge-Kutta solution to a
                           differential equation.
    INTERPOLATE          = Interpolate a function.
 
Reference:
    For a mathematical description of integration, consult any
    introductory calculus text.  For a description of Gaussian
    quadrature and the trapezoid rule, consult any standard numerical
    analysis textbook.
 
Applications:
    Mathematics
 
Implementation Date:
    XX.X
 
Program:
    LET FUNCTION F1 = X**3+2*X**2-4*X+5
    LET A1 = INTEGRAL F1 WRT X FOR X = 0 10
    LET X = SEQUENCE 0 0.1 10
    LET Y1 = F1
    LET A2 = INTEGRAL Y1
 
-----INTERACTION PLOT---------------------------------------------------
 
INTERACTION PLOT
 
Name:
    ... INTERACTION PLOT
 
Type:
    Graphics Command
 
Purpose:
    Given a response variable, Y, and k factor variables, X1
    through Xk, it generates a plot of 

      Y versus X1*X2* ... *Xk
 
Description:
    The primary application of this plot is in the design of
    experiments.  Specifically, for 2-level designs where each
    factor variable is assigned a value of either -1 or +1.
    A plot of Y versus X1*X2 can then show the 2-term interaction
    effect.

    When there are more than two factor variables, then all
    the pairwise combinations of the factor variables can be
    used with the INTERACTION PLOT.  This shows all the 2-term
    interaction effects.  This type of plot is referred to as
    a DEX INTERACTION PLOT.  This is in fact the most common
    use of this command (i.e., the INTERACTGION PLOT command
    is used to generate a DEX INTERACTION PLOT).  This can be
    done in DATAPLOT using the SCATTER PLOT MATRIX command.
    Enter HELP SCATTER PLOT MATRIX for the details.
 
    There are two variations of this command.  In the first,
    the raw data for Y is plotted.  In the second, a statistic
    for the distinct values of X1*X2*...*Xk is plotted.

Syntax 1:
    INTERACTION PLOT <y> <x1 ... xk> <SUBSET/EXCEPT/FOR qualification>
          <y> is the response (= dependent) variable;
          <x1 ... xk> is a list of from 1 to k factor (=independent
              variables);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax is used to plot the raw data for <y>.

Syntax 2:

    <stat> INTERACTION PLOT <y> <x1 ... xk> 
                               <SUBSET/EXCEPT/FOR qualification>
    where <stat> is one of the following statistics:
              MEAN, MIDMEAN, MEDIAN, TRIMMED MEAN, WINDSORIZED MEAN,
              BIWEIGHT LOCATION, HODGES-LEHMAN,
              GEOMETRIC MEAN, HARMONIC MEAN,
              STANDARD DEVIATION, RELATIVE STANDARD DEVIATION,
              STANDARD DEVIATION OF MEAN,
              TRIMMED MEAN STANDARD ERROR,
              RELATIVE VARIANCE (or COEFFICIENT OF VARIATION),
              VARIANCE, VARIANCE OF THE MEAN,
              RANGE, GEOMETRIC STANDARD DEVIATION,
              AVERAGE ABSOLUTE DEVIATION (or AAD),
              MEDIAN ABSOLUTE DEVIATION (or MAD),
              INTERQUARTILE RANGE, PERCENTAGE BEND MIDVARIANCE,
              BIWEIGHT SCALE, BIWEIGHT MIDVARIANCE,
              WINSORIZED VARIANCE, WINSORIZED STANDARD DEVIATION,
              SN SCALE, QN SCALE,
              MIDRANGE,
              MAXIMUM, MINIMUM, EXTREME,
              SKEWNESS, KURTOSIS,
              AUTOCORRELATION, AUTOCOVARIANCE,
              LOWER HINGE, UPPER HINGE, LOWER QUARTILE, UPPER QUARTILE,
              <FIRST/SECOND/THIRD/FOURTH/FIFTH/SIXTH/SEVENTH/EIGHTH/
                  NINTH/TENTH> DECILE,
              PERCENTILE, QUANTILE, QUANTILE STANDARD ERROR,
              NORMAL PPCC,
              SINE FREQUENCY, SINE AMPLITUDE,
              CP, CPK, CNPK, CPM, CC, CPL, CPU,
              EXPECTED LOSS, PERCENT DEFECTIVE,
              TAGUCHI SN0 (or SN), TAGUCHI SN+ (or SNL),
              TAGUCHI SN- (or SNS), TAGUCHI SN00 (or SN2);
          <y> is the response (= dependent) variable;
          <x1 ... xk> is a list of from 1 to k factor (=independent
              variables);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for statistics that require a single variable
    to compute.
 
Syntax 3:
    <stat> INTERACTION PLOT <y1> <y2> <x1 ... xk>
               <SUBSET/EXCEPT/FOR qualification>
    where <stat> is one of the following statistics:
              LINEAR INTERCEPT, LINEAR SLOPE, LINEAR RESSD,
              LINEAR CORRELATION,
              CORRELATION, RANK CORRELATION, COVARIANCE,
              RANK COVARIANCE,
          <y1> is the first response (= dependent) variable;
          <y2> is the second response (= dependent) variable;
          <x1 ... xk> is a list of from 1 to k factor (=independent
              variables);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for variables that require two statistics to
    compute.  If a linear fit is performed, the first variable is the
    dependent variable while the second variable is the independent
    variable.
 
Examples:
    MEAN PLOT Y X
    STANDARD DEVIATION PLOT Y X1
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHARACTERS              = Sets the type for plot characters.
    LINES                   = Sets the type for plot lines.
    STATISTIC PLOT          = Generates a statistic versus subsample
                              plot.
    SCATTER PLOT MATRIX     = Generates a scatter plot matrix
                              (including a DEX INTERACTION PLOT).
    PLOT                    = Generates a data or function plot.
 
Applications:
    Design of Experiments
 
Implementation Date:
    2000/1
 
Program:
    skip 25
    read boxbike2.dat y x1 to x7
    .
    xtic offset 0.2 0.2
    char x
    line blank
    .
    interaction plot y x1 x2
    mean interaction plot y x1 x2
    .
    set scatter plot matrix plot type dex interaction
    matrix plot y x1 x2 x3 x4 x5 x6 x7
 
-----INTERARRIVAL TIME (LET)-------------------------------------
 
INTERARRIVAL TIME
 
Name:
    INTERARRIVAL TIME (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the interarrival times for a set of failure times.
 
Description:
    The interarrival times, T, for a set of N failure times X
    are computed by sorting the data, setting T(1) = X(1), and
    the setting T(I) = X(I) - X(I-1) for I = 2 through N.

Syntax:
    LET <resp> = INTERARRIVAL TIME <x1>
                              <SUBSET/EXCEPT/FOR qualification>
    where <x1> is the variable for which the interarrival times are
               to be computed;
          <resp> is a variable where the interarrival times
               are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET IA = INTERARRIVAL TIME X
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SEQUENTIAL DIFF    = Compute the sequential difference of a
                         variable.
    HAZARD             = Compute the hazard for a variable.
    CUMULATIVE HAZARD  = Compute the cumulative hazard for a
                         variable.
 
Applications:
    Reliability
 
Implementation Date:
    1998/5
 
Program:
    SKIP 25
    READ HAHN.DAT Y
    LET IATIMES = INTERARRIVAL TIMES Y
 
-----INTERDECILE RATIO (LET)-------------------------------------------
 
INTERDECILE RATIO
 
Name:
    INTERDECILE RATIO (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the interdecile ratio of a variable.
 
Description:
    Given a univariate data set and two quantiles of the data, Q1 and Q2
    (where Q1 < Q2), the interdecile ratio computes the ratio of the
    sum of the data that is greater than or equal to the Q2 quantile of
    the data to the sum of the data is less than or equal to the Q1
    quantile.  That is,

        IDR = SUM[i=N(q2) to N][Y(i)]/SUM[i=1 to N(q1)][Y(I)]

    with N(q1) and N(q2) denoting the points corresponding to the Q1 and
    Q2 quantiles, respectively.

    This statistic has been proposed as measure of income inequality.  For
    example, if Q1 = 0.2 and Q2 = 0.8, then this ratio compares the income
    of the bottom 20% relative to the income of the upper 20% percent.

    The economist Palma has specifically suggested the Palma index which
    is based on Q1 = 0.4 and Q2 = 0.9.  That is, the income of the bottom
    40% is compared to the income of the top 10%.  This is based on
    empirical studies which indicate the stability of incomes of the
    middle 50% (from roughly the 40th to the 90th decile) across
    countries.  This measure has been proposed as an alternative to the
    Gini index.  The Gini index indicates difference in income inequality,
    but is not particularly informative about where those differences
    occur.  The Palma index is sensitive to the differences in the tails
    (i.e., the bottom 40% and the top 10%).  The Cobham and Sumner article
    gives a number of arguments for preferring the Palma index to the
    Gini index.

    The desired quantiles can be set with the commands

        LET XQNUM = <value>
        LET XQDENOM = <value>

    Note that Dataplot will take the larger value for the numerator and
    the smaller value for the denominator.  If these values are not given,
    Dataplot will use 0.9 for the numerator and 0.4 for the denominator
    (i.e., the Palma index).

    Currently this command is restricted to non-negative data.  If any
    negative numbers are encountered in the data, an error will be
    reported and the statistic will not be computed.

Syntax:
    LET <par> = INTERDECILE RATIO <var>   <SUBSET/EXCEPT/FOR qualification>
    where <par> is a parameter where the computed interdecile ratio is
                stored;
          <var> is a response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Examples:
    LET A = INTERDECILE RATIO Y

    LET XQNUM = 0.8
    LET XQDENOM = 0.2
    LET A = INTERDECILE RATIO Y

Note:
    There are various methods for computing quantiles of a data set.  The
    algorithm used for this command is based on the interpolation of order
    statistics.  Specifically, if q is the desired quantile, N is the sample
    size, and Y is the sorted data set

     1. ANI=q*(N+1)
     2. NI = integer part of ANI
     3. R = ANI - NI
     4. NIP1 = NI + 1
     5. If NI is less than 1, set it to 1.  If NIP1 is greater than N,
        set it to N.
     6. The q-th quantile is then (1 -R)*Y(NI) + R*Y(NI1P)

     In the context of this command, we are actually interested in the NI
     and the NI1P.  For the denominator, we sum the points from 1 to NI and
     add REM*Y*N(NI1P).  For the numerator, we sum the points from NI to N
     and subtract REM*Y(NI1P).

     If a different algorithm is used to computed the desired quantiles, a
     slightly different result could be returned for the interdecile ratio
     statistic.

Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    DECILE RATIO is an synonym for INTERDECILE RATIO
 
Related Commands:
    QUANTILE             = Compute a specified quantile of a variable.
    INTERQUARTILE RANGE  = Compute the interquartile range of a variable.
    Q QUANTILE RANGE     = Compute the q quantile range of a variable.
 
Reference:
    Cobham and Sumner (2014), "Is Ineqaulity All About the Tails",
    Significance, Vol. 11, No. 1, pp. 10-13.

    Palma (2011), "Homogeneous Middles vs. Hererogeneous Tails, and
    the End of the 'Inverted-U': It's All About the Share of the Rich",
    Development and Change, 42(1), pp. 87-153.

Applications:
    Data Analysis
 
Implementation Date:
    2015/02
 
Program:
    . Step 1:   Read the Data
    .
    .           The first data set follows a normal distribution
    .           while the second follows a lognormal distribution
    .
    skip 25
    read zarr13.dat y1
    read lgn.dat    y2
    .
    . Step 2:   Compute the statistic for both data sets
    .
    let xqnum = 0.9
    let xqdenom = 0.4
    let decrat1 = interdecile ratio y1
    let decrat2 = interdecile ratio y2
    .
    let xqnum = 0.8
    let xqdenom = 0.2
    let decrat3 = interdecile ratio y1
    let decrat4 = interdecile ratio y2
    .
    . Step 3:   Print the results
    .
    let decrat1 = round(decrat1,2)
    let decrat2 = round(decrat2,2)
    let decrat3 = round(decrat3,2)
    let decrat4 = round(decrat4,2)
    print "num: 0.9, den: 0.4"
    print "decrat1:  ^decrat1"
    print "decrat2:  ^decrat2"
    print "num: 0.8, den: 0.2"
    print "decrat3:  ^decrat3"
    print "decrat4:  ^decrat4"
 
-----INTERPOLATION (LET)----------------------------------------------
 
INTERPOLATION
 
Name:
    INTERPOLATION (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Perform a cubic spline interpolation of a series of data points.
 
Description:
    Interpolation takes a series of (x,y) points and generates
    estimated values for y's at new x points.  Interpolation is used
    when the function that generated the original (x,y) points is
    unknown.
 
    Interpolation is related to, but distinct from, fitting a function
    to a series of points.  In particular, an interpolated function
    goes through all the original points while a fitted function does
    not.
 
    There are various methods for performing interpolation.  Chapter 3
    of the Numerical Recipes book (see REFERENCE below) contains a nice
    discussion of various types of commonly used interpolation schemes
    (polynomial interpolation, rational function interpolation, cubic
    spline interpolation).  Dataplot uses the cubic spline algorithm.
    Cubic splines have the advantage of being efficient to compute and
    being more stable than polynomials.

    Cubic spline interpolation is intended for the case when your data
    are "smooth".  Specifically, it should be monotonically increasing
    (or decreasing) and not be "noisy".  If your data is sufficiently
    noisy, cubic spline interpolation may not generate desirable 
    interpolated values (e.g., it may not preserve the monotonicity).

    Hermite interpolation is an alternative to cubic spline interpolation
    that may work better when there is some noise in the data (although
    it still assumes monotonicity).  Chapter 4 of Kahaner, Moler, and
    Nash gives a discussion of Hermite interpolation.

    Hermite interpolation also returns the derivative at the interpolated
    points.  You can also compute a definite integral based on the Hermite
    interpolation.

Syntax 1:
    LET <y2> = INTERPOLATION <y1> <x1> <x2>
               <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable containing the vertical axis data points;
          <x1> is a variable containing the horizontal axis data
               points;
          <x2> is a variable containing the horizontal points where the
               interpolation is to be performed;
          <y2> is a variable (same length as <x2>) where the
               interpolated values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the cubic spline interpolation.

Syntax 2:
    LET <y2> = HERMITE INTERPOLATION <y1> <x1> <x2>
               <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable containing the vertical axis data points;
          <x1> is a variable containing the horizontal axis data
               points;
          <x2> is a variable containing the horizontal points where the
               interpolation is to be performed;
          <y2> is a variable (same length as <x2>) where the
               interpolated values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the Hermite interpolation.

Syntax 3:
    LET <y2> = HERMITE DERIVATIVE <y1> <x1> <x2>
               <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable containing the vertical axis data points;
          <x1> is a variable containing the horizontal axis data
               points;
          <x2> is a variable containing the horizontal points where the
               interpolation is to be performed;
          <y2> is a variable (same length as <x2>) where the
               derivative of the interpolated values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the derivative at the <x2> points based on the
    Hermite interpolation.

Syntax 4:
    LET <a> = HERMITE INTEGRATION <y1> <x1> <lowlim> <upplim>
              <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable containing the vertical axis data points;
          <x1> is a variable containing the horizontal axis data
               points;
          <lowlim> is a number or parameter containing the lower limit
               of the integration;
          <upplim> is a number or parameter containing the upper limit
               of the integration;
          <a> is a parameter where the integral value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the definite integral based on the Hermite
    interpolation.

Examples:
    LET Y2 = INTERPOLATION Y1 X1 X2
    LET Y2 = HERMITE INTERPOLATION Y1 X1 X2

    LET Y2 = HERMITE DERIVATIVE Y1 X1 X2

    LET A  = HERMITE INTEGRATION Y1 X1 0  1
 
Note:
    The interpolation points (i.e., <x2>) must be within the range of
    the original data points (i.e., <x1>).  An error message is
    generated if this is not the case.
 
Note:
    The original data do not have to be in sorted order.  DATAPLOT
    sorts the original data (on <x1>) automatically.

Note:
    Dataplot implements Hermite interpolation and integration using
    the PCHEV routinge from Kahaner, Moler, and Nash.  PCHEV is a
    calling routine for the PCHIP package developed by Fritsch and
    Carlson.

Default:
    None
 
Synonyms:
    HERMITE INTEGRAL is a synonym for HERMITE INTEGRATION.
 
Related Commands:
    LINEAR INTERPOLATION  = Compute a linear interpolation of a series
                            of points.
    BILINEAR INTERPOLAT   = Compute a bi-linear interpolation of a 
                            gridded 2d series of points.
    BIVARIATE INTERPOLAT  = Compute an interpolation of a gridded 2d
                            series of points.
    2D INTERPOLATION      = Compute an interpolation of a irregular 2d
                            series of points to a grid.
    FIT                   = Perform a least squares fit.
    ROOTS                 = Compute the roots of a function.
    INTEGRAL              = Compute the integral of a function.
    DERIVATIVE            = Compute the derivative of a function.
    SEQUENCE              = Generate a sequence of numbers.
    PATTERN               = Generate numbers with a specific pattern.
 
Reference:
    Ralston and Rubinowitz (1978), "A First Course in Numerical Analysis",
    McGraw-Hill.
 
    Press, Flannery, Teukolsky, and Vetterling (1989), "Numerical Recipes:
    The Art of Scientific Computing (FORTRAN Version)", Cambridge
    University Press, (chapter 3).
 
    Kahaner, Moler, and Nash (1989), "Numerical Methods and Software",
    Prentice-Hall, chapter 4.

    Fritsch and Carlson (1980), "Monotone Piecewise Cubic Interpolation",
    SIAM Journal of Numerical Analysis, Vol. 17, No. 2, pp. 238-246).

    Fritsch and Carlson (1982), "Piecewise Cubic Hermite Interpolation
    Package, Final Specifications", Lawrence Livermore National
    Laboratory, Computer Documentation UCID-30194.

Applications:
    Mathematics
 
Implementation Date:
    Pre-1987
    2017/09: Support for Hermite interpolation and integration
    2017/11: Support for Hermite derivative
 
Program:
    LET FUNCTION F1 = SIN(X1)*COS(X1)
    LET START = -PI/2
    LET STOP = PI/2
    LET X1 = SEQUENCE START 0.1 STOP
    LET Y1 = F1
    LET X2 = DATA 0 0.05 0.15 0.25 0.35 0.45
    .
    LET Y2 = INTERPOLATION Y1 X1 X2
    .
    TITLE CASE ASIS
    LINES SOLID BLANK
    CHARACTER BLANK CIRCLE
    CHARACTER SIZE 1.5 ALL
    CHARACTER FILL OFF ON
    TITLE Cubic Spline Interpolation
    PLOT Y1 X1 AND
    PLOT Y2 X2
    .
    LET Y3 = HERMITE INTERPOLATION Y1 X1 X2
    .
    TITLE Hermite Cubic Interpolation
    PLOT Y1 X1 AND
    PLOT Y3 X2
 
-----INTERQUARTILE RANGE (LET)-------------------------------
 
INTERQUARTILE RANGE
 
Name:
    INTERQUARTILE RANGE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the interquartile range for a variable.
 
Description:
    The interquartile range is:

        IQ = UPPER QUARTILE - LOWER QUARTILE

    That is, it is the difference betweeen the 75th and 25th
    percentiles of a variable.
 
    The interquartile range is used as a robust measure of scale.
    That is, it is an alternative to the standard deviation.
    The interquartile range is less effected by extremes than
    the standard deviation.  It is the measure of scale used
    by the box plot.

    The normalized interquartile range is

        NIQ = 0.7413*IQ

    This normalization is based on the fact that for a normal
    distribution, the interquartile range is approximately
    1.349 times the standard deviation.  The NORMALIZED INTERQUARTILE
    RANGE command returns the normalized interquartile range.

Syntax 1:
    LET <par> = INTERQUARTILE RANGE <y>
                      <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the computed interquartile range
               is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    LET <par> = NORMALIZED INTERQUARTILE RANGE <y>
                      <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the computed normlaized
               interquartile range is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = INTERQUARTILE RANGE Y1
    LET A = INTERQUARTILE RANGE Y1 SUBSET TAG > 2
    LET A = NORMALIZED INTERQUARTILE RANGE Y1
 
Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

        HELP STATISTICS

Default:
    None
 
Synonyms:
    IQ RANGE is a synonym for INTERQUARTILE RANGE.
    IQR is a synonym for INTERQUARTILE RANGE.
    NORMALIZED IQ RANGE is a synonym for NORMALIZED INTERQUARTILE RANGE.
    NORMALIZED IQR is a synonym for NORMALIZED INTERQUARTILE RANGE.
    SCALED IQ RANGE is a synonym for NORMALIZED INTERQUARTILE RANGE.
    SCALED IQR is a synonym for NORMALIZED INTERQUARTILE RANGE.
    SCALED INTERQUARTILE RANGE is a synonym for NORMALIZED INTERQUARTILE
           RANGE.
    SCALED INTER QUARTILE RANGE is a synonym for NORMALIZED INTERQUARTILE
           RANGE.
 
Related Commands:
    AVERAGE ABSOLUTE DEVIATION = Compute the average absolute
                                 deviation of a variable.
    MEDIAN ABSOLUTE DEVIATION  = Compute the median absolute
                                 deviation of a variable.
    STANDARD DEVIATION         = Compute the standard deviation of a
                                 variable.
    VARIANCE                   = Compute the variance of a variable.
    RANGE                      = Compute the range of a variable.
 
Applications:
    Robust Data Analysis
 
Implementation Date:
    2001/10
 
Program 1:
    LET Y1 = LOGISTIC RANDOM NUMBERS FOR I = 1 1 100
    LET A1 = INTERQUARTILE RANGE Y1
 
Program 2:
    SKIP 25
    READ GEAR.DAT DIAMETER BATCH
    TITLE AUTOMATIC
    XLIMITS 1 10
    MAJOR XTIC MARK NUMBER 10
    MINOR XTIC MARK NUMBER 0
    XTIC OFFSET 1 1
    X1LABEL BATCH
    Y1LABEL INTERQUARTILE RANGE OF DIAMETER
    IQ RANGE PLOT DIAMETER BATCH
 
-----INTERVAL COUNT (LET)---------------------------------------------------
 
INTERVAL COUNT
 
Name:
    INTERVAL COUNT (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the number of elements in a variable that lie within a
    user-specified interval.
 
Syntax:
    LET <par> = INTERVAL COUNT <y>    <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the interval count is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The interval is specified with the commands

        LET LOWLIMIT = <value>
        LET UPPLIMIT = <value>

Examples:
    LET LOWLIMIT = 0
    LET LOWLIMIT = 10
    LET N = INTERVAL COUNT Y1
 
Note:
    If LOWLIMIT is not defined, then the smallest number (PROBE CPUMIN)
    is used.  Likewise, if UPPLIMIT is not defined, then the largest
    number (PROBE CPUMAX) is used.

Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SIZE           = Return the number of elements in a variable.
 
Applications:
    Data Management
 
Implementation Date:
    2018/08
 
Program:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 10000
    LET Y2 = CAUCHY RANDOM NUMBERS FOR I = 1 1 10000
    LET LOWLIMIT = 3
    LET C1 = INTERVAL COUNT Y1
    LET C2 = INTERVAL COUNT Y2
    PRINT "NUMBER OF NORMAL RANDOM NUMBERS > 3 (OUT OF 10,000) = ^C1"
    PRINT "NUMBER OF CAUCHY RANDOM NUMBERS > 3 (OUT OF 10,000) = ^C2"

-----INTRACLASS CORRELATION (LET)--------------------------
 
INTRACLASS CORRELATION
CORRELATION RATIO
 
Name:
    INTRACLASS CORRELATION (LET)
    CORRELATION RATIO (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Given a response variable and a group-id variable, compute the
    correlation ratio or the intraclass correlation coefficient.
 
Description:
    The formula for the intraclass correlation coefficient is

        eta**2 = SUM[i=1 to p][N(i)*(YBAR(i) - YBAR)**2/
                 SUM[i=1 to p][SUM[j=1 to N(i)][Y(ij) - YBAR)**2]
               = sigma(ybar)**2/sigma(y)**2

    The intraclass correlation is the ratio of the weighted
    variance of the group means divided by the variance of all
    samples.

    The intraclass correlation coefficient can have values between
    0 and 1.  A value of 0 indicates no variance between the means
    of the different groups while a value of 1 indicates that the
    sample variance is due to the variance between groups rather
    than the variance within groups.  So the intraclass correlation
    indicates the relative importance of the "between group variance"
    (values closer to 1) and "within group variance" (values closer
    to 0).

    The correlation ratio is the square root of the intraclass
    correlation coefficient.

Syntax 1:
    LET <par> = INTRACLASS CORRELATION <y> <x>
                           <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <x> is the group-id variable;
          <par> is a parameter where the intraclass correlation value
              is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    LET <par> = CORRELATION RATIO <y> <x>
                                  <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <x> is the group-id variable;
          <par> is a parameter where the correlation ratio value
              is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET ICC = INTRACLASS CORRELATION Y X
    LET CR  = CORRELATION RATIO Y X
    LET CR  = CORRELATION RATIO Y X  SUBSET X > 2
 
Note:
    Dataplot's built-in statistics can be used with a number of
    commands.  For details, enter HELP STATISTIC.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CORRELATION         = Compute the correlation coefficient.
    REPEATABILITY SD    = Compute the repeatability standard deviation.
    REPRODUCABILITY SD  = Compute the reproducability standard deviation.
    ANOVA               = Perform a fixed effects analysis of variance.
    LINEAR CORRELATION  = Compute the correlation from a linear least
                          squares fit.
 
Applications:
    One Factor Analysis
 
Implementation Date:
    2019/08
 
Program:
    . Step 1:   Create some data (from Wikipedia page on Correlation Ratio)
    .
    read x y
     1   45
     1   70
     1   29
     1   15
     1   21
     2   40
     2   20
     2   30
     2   42
     3   65
     3   95
     3   80
     3   70
     3   85
     3   73
    end of data
    .
    . Step 2:   Compute the statistics
    .
    let cr  = correlation ratio y x
    let icc = intraclass correlation y x
    set write decimals 4
    print cr icc

-----INVERSE FFT (LET)------------------------------------------------
 
INVERSE FFT
 
Name:
    INVERSE FFT (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the inverse fast Fourier transform of a variable.
 
Description:
    The Fourier transform converts a time domain function into a
    frequency domain function while the inverse Fourier transform
    converts a frequency domain function into a time domain function.
 
    If h(t) represents the function in the time domain while H(f)
    represents the function in the frequency domain, then the
    definitions of the Fourier transform and the inverse Fourier
    transformation respectively are:
        H(f) = integral[h(t)exp(2*PI*i*f*t)]dt
        h(t) = integral[H(f)exp(-2*PI*i*f*t)]df
    where the integral goes from minus infinity to plus infinity.  An
    alternate (mathematically equivalent) formulation specifies these
    transformations in terms of the angular frequency(radians per
    second) w, where w = 2*PI*f.  The equations then become:
        H(w) = integral[h(t)exp(i*w*t)]dt
        h(t) = (1/(2*PI))*integral[H(w)exp(-i*w*t)]dw
 
    In practice, functions are sampled at equally spaced discrete
    points.  The discrete Fourier transform and the discrete inverse
    Fourier transforms respectively are:
        H(n) = SUM(k=0 to N-1) [h(k)exp(2*PI*i*k*n/N)]
        h(k) = (1/N)*SUM(n=0 to N-1) [H(n)*exp(-2*PI*i*k*n/N]
    where k represents the sampled points in the time domain, lower
    case n represents the sampled points in the frequency domain, and
    N is the number of sampled points.
 
    DATAPLOT calculates the discrete Fourier and inverse Fourier
    transforms.  If you wish to calculate these transforms for a
    function, then evaluate this function at a series of points.  This
    can be accomplished with something like the following:
       LET FUNCTION F = <define the function in terms of X1>
       LET X1 = SEQUENCE 0 0.5 40
       LET Y1 = F
       LET R2 C2 = FOURIER TRANSFORM Y1
 
    See the REFERENCE section below for references which give a more
    detailed explanation of Fourier transforms.
 
    The fast Fourier and the inverse fast Fourier transforms are more
    efficient ways to compute the Fourier and the inverse Fourier
    transforms.
 
Syntax:
    LET <r2> <c2> = INVERSE FFT <r1> <c1>
             <SUBSET/EXCEPT/FOR qualification>
    where <r1> is the real component of a response variable for which
              the inverse FFT is to be computed;
          <c1> is the real component of a response variable for which
              the inverse FFT is to be computed;
          <r2> is the real component of a variable where the computed
              inverse FFT is saved;
          <c2> is the complex component of a variable where the
              computed inverse FFT is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET UNEW VNEW = INVERSE FFT U V
 
Note:
    DATAPLOT uses the FOUR1 routine from the Numerical Recipes book to
    calculate the inverse FFT.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    INVERSE FOUR TRANS = Compute the inverse Fourier transform.
    FFT                = Compute the fast Fourier transform.
    FOURIER TRANSFORM  = Compute the Fourier transform.
    COSINE TRANS       = Compute the cosine transformation.
    SINE TRANS         = Compute the sine transformation.
    SPECTRAL PLOT      = Generate a spectral plot.
 
Reference:
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", Press, Flannery, Teukolsky, and Vetterling.  Cambridge
    University Press, 1989 (chapter 12).
 
    "Fourier Analysis of Time Series: An Introduction", Peter
    Bloomfield, John Wiley and Sons, 1976.
 
Applications:
    Frequency Analysis of Time Series, Signal Processing
 
Implementation Date:
    87/5
 
Program:
    . PURPOSE--REMOVE HIGH FREQUENCY CONTAMINATION FROM A SIGNAL
    . ANALYSIS TECHNIQUE--FOURIER (AND INVERSE) TRANSFORMS
    DIMENSION 20 VARIABLES
    .      STEP 1--
    .      DEFINE THE PURE SIGNAL AND THE CONTAIMINATION.
    .      COMBINE PURE + CONTAMINATION TO YIELD THE OBSERVED
    .      RESPONSE PLOT.
    LET X = SEQUENCE 0 .1 25.55
    LET YS = SIN(X)
    LET YN = NORMAL RANDOM NUMBERS FOR I = 1 1 256
    LET YN = YN/10
    LET Y = YS+YN
    MULTIPLOT CORNER COORDINATES 0 0 100 100; MULTIPLOT 2 2
    YLIMITS -2 2; Y1LABEL AUTOMATIC
    PLOT YS; PLOT YN; PLOT Y; YLIMITS
    END OF MULTIPLOT; BOX 0 0 100 100
    .
    .      STEP 2--
    .      FFT THE RESPONSE.  PLOT THE REAL AND IMAGINARY PARTS.
    .
    LET U V = FFT Y
    MULTIPLOT 2 2
    PLOT U; PLOT V
    END OF MULTIPLOT; BOX 0 0 100 100
    .
    .      STEP 3--
    .      IDENTIFY AND ZERO-OUT THE HIGH FREQUENCY
    .      IN THE REAL AND IMAGINARY PARTS
    .
    LET TAG = 0 FOR I = 1 1 256
    LET TAG = 1 FOR I = 108 1 148
    LET U = 0 SUBSET TAG = 0
    LET V = 0 SUBSET TAG = 0
    .
    .      STEP 4--
    .      TRANSFORM BACK. PLOT AND COMPARE.
    .
    LET XPRIME YPRIME = INVERSE FFT U V
    MULTIPLOT 2 2; YLIMITS -2 2
    PLOT Y; PLOT YS; PLOT XPRIME; PLOT YPRIME
    END OF MULTIPLOT
 
-----INVERSE FOURIER TRANSFORM (LET)----------------------------------
 
INVERSE FOURIER TRANSFORM
 
Name:
    INVERSE FOURIER TRANSFORM (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the inverse Fourier transform of a variable.
 
Description:
    The Fourier transform converts a time domain function into a
    frequency domain function while the inverse Fourier transform
    converts a frequency domain function into a time domain function.
 
    If h(t) represents the function in the time domain while H(f)
    represents the function in the frequency domain, then the
    definitions of the Fourier transform and the inverse Fourier
    transformation respectively are:
        H(f) = integral[h(t)exp(2*PI*i*f*t)]dt
        h(t) = integral[H(f)exp(-2*PI*i*f*t)]df
    where the integral goes from minus infinity to plus infinity.  An
    alternate (mathematically equivalent) formulation specifies these
    transformations in terms of the angular frequency(radians per
    second) w, where w = 2*PI*f.  The equations then become:
        H(w) = integral[h(t)exp(i*w*t)]dt
        h(t) = (1/(2*PI))*integral[H(w)exp(-i*w*t)]dw
 
    In practice, functions are sampled at equally spaced discrete
    points.  The discrete Fourier transform and the discrete inverse
    Fourier transforms respectively are:
        H(n) = SUM(k=0 to N-1) [h(k)exp(2*PI*i*k*n/N)]
        h(k) = (1/N)*SUM(n=0 to N-1) [H(n)*exp(-2*PI*i*k*n/N]
    where k represents the sampled points in the time domain, lower
    case n represents the sampled points in the frequency domain, and
    N is the number of sampled points.
 
    DATAPLOT calculates the discrete Fourier and inverse Fourier
    transforms.  If you wish to calculate these transforms for a
    function, then evaluate this function at a series of points.
 
    See the REFERENCE section below for references which give a more
    detailed explanation of Fourier transforms.
 
Syntax:
    LET <r2> <c2> = INVERSE FOURIER TRANSFORM <r1> <c1>
              <SUBSET/EXCEPT/FOR qualification>
    where <r1> is the real component of a response variable for which
               the inverse Fourier transform is to be computed;
          <c1> is the complex component of a response variable for
               which the inverse Fourier transform is to be computed;
          <r2> is the real component of a variable where the computed
               inverse Fourier transform is saved;
          <c2> is the complex component of a variable where the
               computed inverse Fourier transform is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET UNEW VNEW = INVERSE FOURIER TRANSFORM U V
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FOURIER TRANSFORM  = Compute the Fourier transform.
    FFT                = Compute the fast Fourier transform.
    INVERSE FFT        = Compute the inverse FFT.
    COSINE TRANS       = Compute the cosine transformation.
    SINE TRANS         = Compute the sine transformation.
    SPECTRAL PLOT      = Generate a spectral plot.
 
Reference:
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", Press, Flannery, Teukolsky, and Vetterling.  Cambridge
    University Press, 1989 (chapter 12).
 
    "Fourier Analysis of Time Series: An Introduction", Peter
    Bloomfield, John Wiley and Sons, 1976.
 
Applications:
    Frequency analysis of time series, signal processing
 
Implementation Date:
    87/5
 
Program:
    . PURPOSE--REMOVE HIGH FREQUENCY CONTAMINATION FROM A SIGNAL
    . ANALYSIS TECHNIQUE--FOURIER (AND INVERSE) TRANSFORMS
    DIMENSION 20 VARIABLES
    .      STEP 1--
    .      DEFINE THE PURE SIGNAL AND THE CONTAIMINATION.
    .      COMBINE PURE + CONTAMINATION TO YIELD THE OBSERVED
    .      RESPONSE PLOT.
    LET X = SEQUENCE 0 .1 25.55
    LET YS = SIN(X)
    LET YN = NORMAL RANDOM NUMBERS FOR I = 1 1 256
    LET YN = YN/10
    LET Y = YS+YN
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    MULTIPLOT 2 2
    YLIMITS -2 2
    Y1LABEL AUTOMATIC
    PLOT YS; PLOT YN; PLOT Y; YLIMITS
    .
    .      STEP 2--
    .      FFT THE RESPONSE.  PLOT THE REAL AND IMAGINARY PARTS.
    .
    LET U V = FAST FOURIER TRANSFORM Y
    MULTIPLOT 2 2
    PLOT U; PLOT V
    .
    .      STEP 3--
    .      IDENTIFY AND ZERO-OUT THE HIGH FREQUENCY
    .      IN THE REAL AND IMAGINARY PARTS
    .
    LET TAG = 0 FOR I = 1 1 256
    LET TAG = 1 FOR I = 108 1 148
    LET U = 0 SUBSET TAG = 0
    LET V = 0 SUBSET TAG = 0
    .
    .      STEP 4--
    .      TRANSFORM BACK. PLOT AND COMPARE.
    .
    LET XPRIME YPRIME = INVERSE FAST FOURIER TRANSFORM U V
    MULTIPLOT 2 2
    YLIMITS -2 2
    PLOT Y; PLOT YS; PLOT XPRIME; PLOT YPRIME
 
-----INVERSE GAUSSIAN MOMENT ESTIMATES (LET)-------------------------------------
 
INVERSE GAUSSIAN MOMENT ESTIMATES
 
Name:
    INVERSE GAUSSIAN MOMENT ESTIMATES (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Estimate the parameters of the 3-parameter inverse gaussian
    distribution based on summary statistics.
 
Description:
    In most cases, we prefer to estimate the parameters of the 3-parameter
    inverse gaussian distribution using the
    3-PARAMETER INVERSE GAUSSIAN MLE Y command.  However, this assumes that
    we have the full data set.  In some cases, we may only have summary
    statistics available.

    Note that Dataplot supports two parameterizations of the inverse
    Gaussian distribution.  The original parameterization of Tweedie has
    shape parameters mu and gamma (some references use lambda for this
    parameter).  The Chan parameterization has shape parameters mu and
    sigma where

         sigma = sqrt(mu**3/gamma)

    This command returns estimates for mu, sigma, and gamma so that
    estimates based on either parameterization can be obtained.

    The input array, say X, should contain the following values:

        X(1) = the sample mean
        X(2) = the sample standard deviation
        X(3) = the sample skewness
        X(4) = the sample minimum
        X(5) = the sample size

    If one of the values is not available, then you can enter either
    CPUMIN or the statistic missing value.  For example, if the skewness
    is not available, you can do one of the following:

        PROBE CPUMIN
        LET CPUMIN = PROBVAL
        LET X(3) = CPUMIN

    or

        SET STATISTIC MISSING VALUE -9999
        LET X(3) = -9999

    The following output vector, say Y, is returned:

        Y(1) = 3-parameter moment estimate for location
        Y(2) = 3-parameter moment estimate for mu
        Y(3) = 3-parameter moment estimate for sigma
        Y(4) = 3-parameter moment estimate for gamma
        Y(5) = 3-parameter modified moment estimate for location
        Y(6) = 3-parameter modified moment estimate for mu
        Y(7) = 3-parameter modified moment estimate for sigma
        Y(8) = 3-parameter modified moment estimate for gamma

    Any of these moment estimates that cannot be computed will be set to
    CPUMIN.  This can happen if certain summary statistics are not provided
    or if the equation solvers are not able to find a solution.

    The 3-parameter moment and modified moment estimates are computed using
    the codes provided on pages 360-361 of Cohen and Whitten.

Syntax:
    LET <y> = INVERSE GAUSSIAN MOMENT ESTIMATES  <x>
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is the variable containing the summary statistics;
          <y> is a variable containing the inverse gaussian moment estimates;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional and rarely
          used for this command.
 
Examples:
    LET Y = INVERSE GAUSSIAN MOMENT ESTIMATES X
 
Default:
    None
 
Synonyms:
    None
 
Reference:
    Cohen and Whitten (1988), "Parameter Estimation in Reliability and Life
    Span Models", Marcel Dekker, chapter 5 and pp. 361-362.

Related Commands:
    GAMMA MOMEMENT ESTIMATE      = Generate moment estimates for the
                                   gamma distribution.
    LOGNORMAL MOMEMENT ESTIMATE  = Generate moment estimates for the
                                   lognormal distribution.
    WEIBULL MOMENT ESTIMATE      = Generate moment estimates for the
                                   inverse gaussian distribution.
    MAXIMUM LIKELIHOOD           = Perform maximum likelihood estimation
                                   for various distributions.
    BEST DISTRIBUTIONAL FIT      = Perform a best distributional fit
                                   analysis.
    PPCC PLOT                    = Generate a probability plot
                                   correlation coefficient plot.
    PROBABILITY PLOT             = Generate a probability plot.
 
Applications:
    Reliability
 
Implementation Date:
    2014/4
 
Program:
    . Purpose:  Test INVERSE GAUSSIAN MOMENT ESTIMATES command
    .
    . Step 1:   Read data
    .
    .           Data from
    .
    .           Cohen and Whitten (1988), "Parameter Estimation in
    .           Reliability  and Life Span Models", Dekker, p. 54.
    .
    serial read x
    0.654  0.613  0.315  0.449  0.297
    0.402  0.379  0.423  0.379  0.3235
    0.269  0.740  0.418  0.412  0.494
    0.416  0.338  0.392  0.484  0.265
    end of data
    .
    let xmean = mean x
    let xsd   = sd   x
    let xmin  = mini x
    let xskew = skew x
    let n = size x
    let z = data xmean xsd xskew xmin n
    .
    let y = inverse gaussian moment estimates z
    .
    let numdec = 5
    .
    let locmom   = y(1); let locmom   = round(locmom,numdec)
    let mumom    = y(2); let mumom    = round(mumom,numdec)
    let sigmamom = y(3); let sigmamom = round(sigmamom,numdec)
    let gammamom = y(4); let gammamom = round(gammamom,numdec)
    let locmmom  = y(5); let locmmom  = round(locmmom,numdec)
    let mummom   = y(6); let mummom   = round(mummom,numdec)
    let sigmmmom = y(7); let sigmmmom = round(sigmmmom,numdec)
    let gammmmom = y(8); let gammmmom = round(gammmmom,numdec)
    .
    let xmean = round(xmean,numdec)
    let xsd   = round(xsd,numdec)
    let xskew = round(xskew,numdec)
    let xmin  = round(xmin,numdec)
    .
    print "Inverse Gaussian Parameter Estimates From Summary Data"
    print " "
    print " "
    print "Sample Mean:      ^xmean"
    print "Sample SD:        ^xsd"
    print "Sample Skewness:  ^xskew"
    print "Sample Minimum:   ^xmin"
    print "Sample Size:      ^n"
    print " "
    print " "
    print "3-Parameter Inverse Gaussian Moment Estimates:"
    print "Location:         ^locmom"
    print "Mu:               ^mumom"
    print "Sigma:            ^sigmamom"
    print "Gamma:            ^gammamom"
    print " "
    print " "
    print "3-Parameter Inverse Gaussian Modified Moment Estimates:"
    print "Location:         ^locmmom"
    print "Mu:               ^mummom"
    print "Sigma:            ^sigmmmom"
    print "Gamma:            ^gammmmom"

-----IRD (SET)--------------------------------------------
 
IRD
 
Name:
    IRD (SET)
 
Type:
    Set Subcommand
 
Purpose:
    Define the unit used for alphanumeric input.
 
Description:
    This unit is generally set by the local installer to be the
    terminal by default, so the analyst typically does not need to
    modify its value.  Although changing this value can be used to read
    commands from a file, the CALL command is the recommended way to do
    this.
 
Syntax:
    SET IRD <unit number>
    where <unit number> identifies the Fortran unit number where
              commands will be read.
 
Examples:
    SET IRD 10
    SET IRD 5
 
Default:
    The terminal (5 on most implementations).
 
Synonyms:
    None
 
Related Commands:
    SET IPR       = Set the unit for alphanumeric output.
    CAPTURE       = Redirect alphanumeric output to a file.
    CALL          = Execute commands stored in a file.
 
Applications:
    Interactive Usage
 
Implementation Date:
    Pre-1987
 
Program:
    XX
 
-----IS NUMBER-------------------------------------------------
 
IS NUMBER
 
Name:
    IS NUMBER
 
Type:
    Let Subcommand
 
Purpose:
    Determine whether a previously defined string defines a
    valid numerical value.
 
Description:
    There are times where it may be useful to determine if a
    previously defined string defines a valid numeric value
    or not.  The primary motivation for this command is to
    distinguish if a string is a parameter name or a number
    (e.g., when using command line arguments).

    Dataplot determines this by attempting an internal Fortran
    read.  That is (where STR is the string being tested),

        READ(STR,*,IOSTAT=IE)AVAL

    If IOSTAT does not indicate an error, then STR is assumed to be a
    number.  If IOSTAT does indicate an error, then STR is assumed to
    not be a number.

    Note that there are some strings that are ambiguous in that
    they can be interpreted as either a valid number or a parameter
    name.  For example, 1D0 will be read successfully as a number, but
    it is also a valid parameter name in Dataplot.  Determining
    whether this should be considered a number or a parameter will
    be dependent on the specific application.  The basic rule for
    this command is that if it can be successfully read as a number
    it will be considered a number.

Syntax:
    LET <ival> = IS NUMBER  <sorg>
    where <sorg> is a previously defined string;
    and   <ival> is a parameter.
 
    The <ival> will be set to 1 if <sorg> is determined to be a
    number and set to 0 if <sorg> is determined to not be a number.

Examples:
    LET STRING S1 = PARNAME
    LET IFLAG = IS NUMBER S1
    LET STRING S2 = 34.56
    LET IFLAG = IS NUMBER S2
 
Note:
    The string on the right hand side of the equal sign must be a
    previously defined string.  String expressions are not allowed.
    So

        LET IFLAG = IS NUMBER "45.6"

    should be coded as

        LET STRING S1 = 45.6
        LET IFLAG = IS NUMBER S1

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHARACTER (LET)     = Convert numeric values to strings based on
                          the ASCII collating sequence.
    LET FUNCTION        = Defines a function.
    LET STRING          = Defines a string.
    READ STRING         = Reads a string from a file.
    SUBSTITUTE CHARACTE = Substitute the value of a string or parameter.
    &                   = Concatenate two strings.
    SUBTRING            = Extract a substring from an existing string.
    STRING LENGTH       = Return the length of a string.
    STRING INDEX        = Return the start and stop positions of a 
                          substring within a string.
    STRING CONCATENATE  = Concatenate one or more previously defined
                          strings.
    STRING EDIT         = Edit a string.
    STRING MERGE        = Insert a string into another string without
                          overwrite.
    STRING REPLACE      = Insert a string into another string with
                          overwrite.
    LOWER CASE          = Convert a string to lower case.
    UPPER CASE          = Convert a string to upper case.
    GROUP LABEL         = Define the text for group labels.
 
Applications:
    Data Management
 
Implementation Date:
    2020/11
 
Program:
    CALL MACRO.DP  K=3.56

    where MACRO.DP contains

    LET STRING SORG = $k
    LET IFLAG = IS NUMBER SORG
    IF IFLAG = 1; . ARGUMENT IS A NUMBER
       LET AVAL = ^SORG
    ELSE IF IFLAG = 0; . ARGUMENT IS A STRING
       IF SORG EXISTS
          LET AVAL = ^SORG
       ELSE
          LET AVAL = -9999
       END OF IF
     END OF IF

-----ISO 13528 DIPERCENTAGE SCORE (LET)----------------------------------
 
ISO 13528 DIPERCENTAGE SCORE
 
Name:
    ISO 13528 DIPERCENTAGE SCORE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Generate a percentage difference score based on the ISO 13528
    standard.

Description:
    The ISO 13528 standard for proficiency testing defines the difference
    between measurement and a reference value as

       Di = X(i) - Xref

    The percentage difference score is then defined as

        Di%(i) = ((X(i) - Xref)/Xref)*100

    with Xref denoting the "assigned value".  The multiplication by 100
    is to express the score as a percentage.

    The Di and Di% statistics are performance scores discussed in the
    ISO 13528 standard (2015 second edition page 25).
  
    The difference score is typically compared to a DELTAe value
    such that

          Di < -DELTAe or Di > DELTAe

    indicates an action signal (i.e., unacceptable performance).  In
    terms of the Di% score, this translates to

          Di% < -100*DELTAe/Xref  or  Di% > 100*DELTAe/Xref

    Note that Xref and DELTAe are not computed from the current data.
    The Xref is considered the "true" value (or the best guess for
    the true value).  The ISO 13528 standard discusses numerous ways
    of determining this value.  The DELTAe is an "acceptable" error.

    Although the ISO 13258 standard does not define a specific method
    for determing DELTAe, if estimates for the repeatability and
    reproducibility are available, then ISO 13528 suggests the
    following (p. 22)

        sigma(pt) = SQRT(sigma(R)**2 - sigma(r)**2*(1 - 1/m))

    where

        sigma(pt)   = standard deviation for proficiency assessment
        sigma(R)    = repeatability standard deviation
        sigma(r)    = reproducibility standard deviation
        m           = number of replicate measurements for each
                      participant

    Then 

        DELTAe = 3*sigma(pt)

    The justification for this is that this corresponds to an action
    signal of +/-3 for z-scores.

    In some cases, sigma(pt) may be based on fitness for purpose or
    data from prior rounds.

    The Di% score is only one of several possible performance scores
    discussed in the ISO 13528 standard.

Syntax:
    LET <y> = ISO 13528 DIPERCENTAGE SCORE <x> <xref>
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is the response variable;
          <xref> is a parameter that defines the assigned value;
          <y> is a variable where the Di% score values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Examples:
    LET DIPERC = ISO 13528 DIPERCENTAGE SCORE X XREF DELTAE

Default:
    None
 
Synonyms:
    ISO 13528 DIPERCENTAGE is a synonym for ISO 13528 DIPERCENTAGE SCORE
    DIPERCENTAGE is a synonym for ISO 13528 PA SCORE
    DI PERCENTAGE is a synonym for DIPERCENTAGE
 
Related Commands:
    ISO 13528 PA SCORE      = Compute the percentage of allowed
                              deviation-score as defined by the
                              ISO 13528 standard.
    ISO 13528 EN SCORE      = Compute the En-score as defined by the
    ISO 13528 EN SCORE      = Compute the En-score as defined by the
                              ISO 13528 standard.
    ISO 13528 ZETA SCORE    = Compute the zeta-score as defined by the
                              ISO 13528 standard.
    ISO 13528 ZSCORE        = Compute the z-score as defined by the
                              ISO 13528 standard.
    ISO 13528 ZPRIME SCORE  = Compute the z'-score as defined by the
                              ISO 13528 standard.
    ISO 13528 EZMINUS SCORE = Compute the Ez- score as defined by the
                              ISO 13528 standard.
    ISO 13528 EZPLUS SCORE  = Compute the Ez+ score as defined by the
                              ISO 13528 standard.

Reference:
    ISO 13528, Second Edition, Statistical Methods for Use
    in Proficiency Testing by Interlaboratory Comparisons,
    2015, pp. 22, 25.

Applications:
    Proficiency Testing
 
Implementation Date:
    2016/2

Program:
    . Step 1:   Read the Data
    .
    skip 25
    read e2489a.dat labid y
    .
    . Step 2:   Compute and print the Di percentage values
    .
    let xref   = median y
    .
    let diperc= iso 13528 diperc  y xref
    .
    set write decimals 3
    print y diperc
    .
    . Step 3:   Plot the Di percentage values
    .
    tic mark offset units screen
    tic mark offset 3 3
    case asis
    label case ais
    title case asis
    title offset 2
    .
    y1label D(i) %
    x1label Laboratory
    x2label Assigned Value: ^xref
    title D(i) %  for E2489A.DAT
    line blank solid dash dash
    spike on
    line color black black red red
    .
    let sd = sd y
    let deltae = 3*sd
    let deltae = round(deltae,2)
    let ul = 100*deltae/xref
    let ll = -ul
    .
    let xmax = maximum labid
    let xtemp = data 1 xmax
    let ymax  = data ul ul
    let ymin  = data -ll -ll
    let yzero = data 0 0
    plot diperc labid and
    plot yzero xtemp and
    plot ymax xtemp and
    plot ymin xtemp

-----ISO 13528 EN SCORE (LET)-----------------------------------------
 
ISO 13528 EN SCORE
 
Name:
    ISO 13528 EN SCORE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Generate an En score based on the ISO 13528 standard.

Description:
    The ISO 13528 standard for proficiency testing defines the following
    En score

        En(i) = (X(i) - Xref)/SQRT(u(X)**2 + u(ref)**2)

    with Xref, u(ref), and u(x) denoting the "assigned value", the
    expanded uncertainty of the assigned value, and the laboratory's
    estimate of the expanded uncertainty of its result, respectively.

    Determing an assigned value and its associated uncertainty is
    discussed on pages 5-10 of the standard.

    Since there are a mumber of different methods for determining
    Xref, u(ref), and u(X), these values will be defined by the user
    rather than being determined from the data.

    This command is similar to the ISO 13528 ZETA SCORE command.  The
    difference is that the En scores use expanded uncertainties while
    the zeta-scores use a standard uncertainty.

    When the coverage factor is 2 (i.e., 2 times the standard
    uncertainty), a critical value of 1 for the En score is
    equivalent to a critical value of 2 for a z-score (i.e., this
    generates a "warning signal").

Syntax:
    LET <y> = ISO 13528 EN SCORE <x> <ulab> <xref> <uref>
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is the response variable;
          <ulab> is a variable containing the lab standard uncertainties;
          <xref> is a parameter that defines the assigned value;
          <uref> is a parameter that defines the standard uncertainty
              of the assigned value;
          <y> is a variable where the En score values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    The <x> vector and the <ulab> vector should be of the same length.

Examples:
    LET Z = ISO 13528 EN SCORE X ULAB XREF UREF

Default:
    None
 
Synonyms:
    EN is a synonym for ISO 13528 EN SCORE
 
Related Commands:
    ISO 13528 ZETA SCORE    = Compute the zeta-score as defined by the
                              ISO 13528 standard.
    ISO 13528 ZSCORE        = Compute the z-score as defined by the
                              ISO 13528 standard.
    ISO 13528 ZPRIME SCORE  = Compute the z'-score as defined by the
                              ISO 13528 standard.
    ISO 13528 EZMINUS SCORE = Compute the Ez- score as defined by the
                              ISO 13528 standard.
    ISO 13528 EZPLUS SCORE  = Compute the Ez+ score as defined by the
                              ISO 13528 standard.

Reference:
    ISO 13528, First Edition, Statistical Methods for Use
    in Proficiency Testing by Interlaboratory Comparisons,
    2005, pp. 27-28.

Applications:
    Proficiency Testing
 
Implementation Date:
    2012/1

Program:
    .  Note: this example is just meant to demostrate the
    .        mechanics of the command.  This is not in fact
    .        proficiency data, but it can be used to demonstrate
    .        how to use the command.
    .
    skip 25
    read gear.dat y x
    .
    let xref  = 1.
    let sd    = sd y
    let uref  = 2*sd
    let ulab  = cross tabulate sd y x
    let ulab  = 2*ulab
    .
    let en    = iso 13528 en score y ulab xref uref
    .
    set write decimals 3
    print x y ulab en

-----ISO 13528 EZ SCORE (LET)-----------------------------------------
 
ISO 13528 EZ SCORE
 
Name:
    ISO 13528 EZ SCORE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Generate an Ez- or an Ez+ score based on the ISO 13528 standard.

Description:
    The ISO 13528 standard for proficiency testing defines the following
    Ez scores

        Ez-(i) = (X(i) - (Xref - u(ref))/u(X)

        Ez+(i) = (X(i) - (Xref + u(ref))/u(X)

    with Xref, u(ref), and u(x) denoting the "assigned value", the
    expanded uncertainty of the assigned value, and the laboratory's
    estimate of the expanded uncertainty of its result, respectively.

    Determing an assigned value and its associated uncertainty is
    discussed on pages 5-10 of the standard.

    Since there are a mumber of different methods for determining
    Xref, u(ref), and u(X), these values will be defined by the user
    rather than being determined from the data.

    The ISO 13528 standard recommends comparing these scores to a
    critical value of 1.0.  Specifically,

       1. If both Ez- and Ez+ are within the -1 to 1 range, the
          laboratory's performance is satisfactory.

       2. If one of Ez- and Ez+ falls outside the -1 to 1 range, the
          laboratory's performance is questionable.

       3. If both Ez- and Ez+ are outside the -1 to 1 range, the
          laboratory's performance is unsatisfactory.

Syntax 1:
    LET <y> = ISO 13528 EZMINUS SCORE <x> <ulab> <xref> <uref>
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is the response variable;
          <ulab> is a variable containing the lab standard uncertainties;
          <xref> is a parameter that defines the assigned value;
          <uref> is a parameter that defines the standard uncertainty
              of the assigned value;
          <y> is a variable where the Ez- score values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    The <x> vector and the <ulab> vector should be of the same length.

Syntax 2:
    LET <y> = ISO 13528 EZPLUS SCORE <x> <ulab> <xref> <uref>
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is the response variable;
          <ulab> is a variable containing the lab standard uncertainties;
          <xref> is a parameter that defines the assigned value;
          <uref> is a parameter that defines the standard uncertainty
              of the assigned value;
          <y> is a variable where the Ez+ score values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    The <x> vector and the <ulab> vector should be of the same length.

Examples:
    LET Z = ISO 13528 EZMINUS SCORE X ULAB XREF UREF
    LET Z = ISO 13528 EZPLUS  SCORE X ULAB XREF UREF

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ISO 13528 EN SCORE      = Compute the En score as defined by the
                              ISO 13528 standard.
    ISO 13528 ZETA SCORE    = Compute the zeta-score as defined by the
                              ISO 13528 standard.
    ISO 13528 ZSCORE        = Compute the z-score as defined by the
                              ISO 13528 standard.
    ISO 13528 ZPRIME SCORE  = Compute the z'-score as defined by the
                              ISO 13528 standard.

Reference:
    ISO 13528, First Edition, Statistical Methods for Use
    in Proficiency Testing by Interlaboratory Comparisons,
    2005, pp. 30.

Applications:
    Proficiency Testing
 
Implementation Date:
    2012/1

Program:
    .  Note: this example is just meant to demostrate the
    .        mechanics of the command.  This is not in fact
    .        proficiency data, but it can be used to demonstrate
    .        how to use the command.
    .
    skip 25
    read gear.dat y x
    .
    let xref  = 1.
    let sd    = sd y
    let uref  = 2*sd
    let ulab  = cross tabulate sd y x
    let ulab  = 2*ulab
    .
    let ezm = iso 13528 ezminus score y ulab xref uref
    let ezp = iso 13528 ezplus score y ulab xref uref
    .
    set write decimals 3
    print x y ulab ezm ezp

-----ISO 13528 PA SCORE (LET)-----------------------------------------
 
ISO 13528 PA SCORE
 
Name:
    ISO 13528 PA SCORE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Generate a percentage of allowed deviation (PA) score based on the
    ISO 13528 standard.

Description:
    The ISO 13528 standard for proficiency testing defines the following
    PA score

        Pa(i) = ((X(i) - Xref)/DELTAe)*100

    with Xref and DELTAe denoting the "assigned value" and the
    pre-defined allowance for measurement error, respectively.
    The multiplication by 100 is to express the score as a
    percentage.

    The Pa statistic is a performance score discussed in the
    ISO 13528 standard (2015 second edition pp. 25-26).  Values of
    Pa <= -100 and Pa >= 100 indicate an action signal (i.e.,
    unacceptable performance).

    Note that Xref and DELTAe are not computed from the current data.
    The Xref is considered the "true" value (or the best guess for
    the true value).  The ISO 13528 standard discusses numerous ways
    of determining this value.  The DELTAe is an "acceptable" error.

    Although the ISO 13258 standard does not define a specific method
    for determing DELTAe, if estimates for the repeatability and
    reproducibility are available, then ISO 13528 suggests the
    following (p. 22)

        sigma(pt) = SQRT(sigma(R)**2 - sigma(r)**2*(1 - 1/m))

    where

        sigma(pt)   = standard deviation for proficiency assessment
        sigma(R)    = repeatability standard deviation
        sigma(r)    = reproducibility standard deviation
        m           = number of replicate measurements for each
                      participant

    Then 

        DELTAe = 3*sigma(pt)

    The justification for this is that this corresponds to an action
    signal of +/-3 for z-scores.

    In some cases, sigma(pt) may be based on fitness for purpose or
    data from prior rounds.

    The Pa score is only one of several possible performance scores
    discussed in the ISO 13528 standard.

Syntax:
    LET <y> = ISO 13528 PA SCORE <x> <xref> <deltae>
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is the response variable;
          <xref> is a parameter that defines the assigned value;
          <deltae> is a parameter that defines the DELTAe value;
          <y> is a variable where the Pa score values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Examples:
    LET PA = ISO 13528 PA SCORE X XREF DELTAE

Default:
    None
 
Synonyms:
    ISO 13528 PA is a synonym for ISO 13528 PA SCORE
    PA is a synonym for ISO 13528 PA SCORE
 
Related Commands:
    ISO 13528 DIPERC SCORE  = Compute the percentage difference-score as
                              defined by the ISO 13528 standard.
    ISO 13528 EN SCORE      = Compute the En-score as defined by the
                              ISO 13528 standard.
    ISO 13528 ZETA SCORE    = Compute the zeta-score as defined by the
                              ISO 13528 standard.
    ISO 13528 ZSCORE        = Compute the z-score as defined by the
                              ISO 13528 standard.
    ISO 13528 ZPRIME SCORE  = Compute the z'-score as defined by the
                              ISO 13528 standard.
    ISO 13528 EZMINUS SCORE = Compute the Ez- score as defined by the
                              ISO 13528 standard.
    ISO 13528 EZPLUS SCORE  = Compute the Ez+ score as defined by the
                              ISO 13528 standard.

Reference:
    ISO 13528, Second Edition, Statistical Methods for Use
    in Proficiency Testing by Interlaboratory Comparisons,
    2015, pp. 22, 25-26.

Applications:
    Proficiency Testing
 
Implementation Date:
    2016/2

Program:
    . Step 1:   Read the Data
    .
    skip 25
    read e2489a.dat labid y
    .
    . Step 2:   Compute and print the Pa values
    .
    let xref   = median y
    let sd     = sd y
    let deltae = 3*sd
    let deltae = round(deltae,2)
    .
    let pa    = iso 13528 pa  y xref deltae
    .
    set write decimals 3
    print y pa
    .
    . Step 3:   Plot the Pa values
    .
    tic mark offset units screen
    tic mark offset 3 3
    case asis
    label case ais
    title case asis
    title offset 2
    .
    y1label Percentage of Allowed Deviation (Pa)
    x1label Laboratory
    x2label Assigned Value: ^xref
    x3label DeltaE: ^deltae
    title Pa for E2489A.DAT
    line blank solid dash dash
    spike on
    line color black black red red
    .
    let xmax = maximum labid
    let xtemp = data 1 xmax
    let ymax  = data 100 100
    let ymin  = data -100 -100
    let yzero = data 0 0
    plot pa labid and
    plot yzero xtemp and
    plot ymax xtemp and
    plot ymin xtemp

-----ISO 13528 PLOT--------------------------------------
 
ISO 13528 PLOT
 
Name:
    ISO 13528 PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generate a z-score versus lab average plot as given in the ISO 13528
    standard.
 
Description:
    One scenario for proficiency testing described in the ISO 13528
    standard is for the case where there are multiple rounds of testing.
    That is, we have the following data:

         Y        - a variable containing either the response data in the
                    orignal units or the laboratory averages
         Z        - a variable containing the response data in z-score
                    units
         ROUNDID  - a variable containing the round-id
         LABID    - a variable containing the lab-id
         LAB2     - a variable containing a list of one or more
                    laboratories for which the plot is generated
 
    Although the proficiency test may have multiple materials, this plot is
    restricted to a single material.

    Then for the labs identified in LAB2, the plot is formed as:

          Vertical Axis:   z(i) = the z-score for round i for the
                           specified lab.

          Horizontal Axis: ybar(i) = the average value over all laboratories
                           (in the original units).

    Although this plot is most typically generated for a single laboratory,
    it can also be used to plot the z-scores for multiple laboratories.
  
    In addition, a line is fit to the plot points.  The primary question
    for the fitted line is whether there is any trend (i.e., is the slope
    parameter for the fitted line statistically significant).  A separate
    line is fit for each laboratory specified by the <lab2> variable.

    What is used for the Y variable is dependent on what data is available
    to you.  If you have the original raw data (i.e., before z-scores
    were computed), then this is typically what you would use (i.e., let
    Dataplot compute the laboratory averages).  However, in some cases
    you may not have the original data.  There are two cases:

        1. Even if you do not have the response data in the original
           units, you may have the laboratory averages in the original
           units.  If Y contains the laboratory averages, it should be
           equal to the number of distinct values in the ROUNDID variable.

        2. If you do not have either the original data or the laboratory
           averages in the original units, then just use the z-scores for
           the Y variable.  If Y contains either the original response
           data or the z-scores, then the Y variable should be the same
           length as the Z variable.  If the z-scores are used for the
           Y variable, then the horizontal axis is in z-score units
           rather than the original units of the data.

    See the Note section below for details on how to specify which case
    is being used.

    You can optionally specify a material-id variable.  This is
    essentially a highlighting variable.  That is, different materials
    can be drawn with different plot characters (this is demonstrated in
    the Program example below).

Syntax 1:
    ISO 13528 PLOT  <y>  <z>  <roundid>  <labid>  <lab2>
                    <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable in the original units;
          <z> is the z-scores of the response variable;
          <roundid> is a variable that specifies the round-id;
          <labid> is a variable that specifies the lab-id;
          <lab2> is a variable that specifies the laboratories for which
              the plot will be generated;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    ISO 13528 PLOT  <y>  <z>  <roundid>  <labid>  <matid> <lab2>
                    <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable in the original units;
          <z> is the z-scores of the response variable;
          <roundid> is a variable that specifies the round-id;
          <labid> is a variable that specifies the lab-id;
          <matid> is a variable that specifies the mat-id;
          <lab2> is a variable that specifies the laboratories for which
              the plot will be generated;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET LAB2 = DATA 3
    ISO 13528 PLOT Y Z ROUNDID LABID LAB2
    ISO 13528 PLOT Y Z ROUNDID LABID LAB2  SUBSET MATID = 2

Note:
    The coefficients, standard deviations of the coefficients, and the
    t-values for the fitted lines are written to the file "dpst1f.dat".
    See the Program example below to see how these values can be read
    from the file to annotate the plot.
 
Note:
    If the <lab2> variable identifies more than one laboratory, the plot
    points for each laboratory are drawn as separate curves.  The appearance
    of the plot can be controlled by approriate settings for the LINE and
    CHARACTER commands and their associated attribute setting commands.
    For example,

       LET LAB2 = DATA 3 5
       LINE BLANK SOLID BLANK SOLID BLANK SOLID
       CHARACTER 3 BLANK 5 BLANK
       ISO 13528 PLOT Y Z ROUNDID LABID LAB2

    Note that these settings come in pairs.  The second setting in the pair
    is for the fitted line.  This is demonstrated in the program example
    below.
 
Note:
    If you want the Y variable to contain the laboratory averages rather than
    the original data or z-scores, enter the command

       SET ISO 13528 PLOT LAB AVERAGES

    If you want the Y variable to contain either the original data or the
    z-scores, enter the command

       SET ISO 13528 PLOT RESPONSE

Note:
    If Dataplot computes the laboratory averages, it will compute the mean
    by default.  However, you can alternatively specify the median or the
    H15 location statistic with the commands

        SET ISO 13528 PLOT STATISTIC MEDIAN
        SET ISO 13528 PLOT STATISTIC H15

    To reset the default of using the mean, enter

        SET ISO 13528 PLOT STATISTIC MEAN

Note:
    The ISO 13528 standard defines a number of methods for computing the
    z-scores (enter HELP ISO 13528 ZSCORE, HELP ISO 13528 ZPRIME SCORE,
    and HELP ISO 13528 ZETA SCORE for details).  For this reason, the
    ISO 13528 PLOT command does not automatically compute the z-scores
    from the original response data.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ISO 13528 ZSCORE PLOT    = Generate an ISO 13528 z-score or j-score
                               plot.
    ISO 13528 ZSCORE         = Compute z-scores as defined in the
                               ISO 13528 standard.
    ISO 13528 ZPRIME SCORE   = Compute z-prime scores as defined in the
                               ISO 13528 standard.
    ISO 13528 ZETA SCORE     = Compute zeta scores as defined in the
                               ISO 13528 standard.
    CHARACTER                = Sets the type for plot characters.
    LINE                     = Sets the type for plot lines.
 
Reference:
    ISO 13528 (2005), "Statistical Methods for use in proficiency
    testing by interlaboratory comparisons," First Edition,
    2005-09-01, pp. 56-57.
 
Applications:
    Proficiency Testing
 
Implementation Date:
    2012/2
 
Program:
    . Step 1: Read the data (note that this sample data set only
    .         has z-scores)
    .
    dimension 40 columns
    skip 25
    read turner.dat labid z year quarter matid matave
    let roundid = year
    skip 0
    .
    . Step 2: Some plot control settings
    .
    label case asis
    y1label Z-Score
    x1label Laboratory Averages
    tic mark offset units screen
    tic mark offset 3 3
    .
    case asis
    title case asis
    title offset 2
    title ISO 13528 Plot
    .
    line blank solid
    character circle blank
    character hw 1 0.75
    character fill on
    .
    . Step 3: Generate the plot for lab 3
    .
    set iso 13528 plot response
    let lab2 = data 3
    iso 13528 plot z z roundid labid lab2
    .
    . Step 4: Annotate the plot with the fit parameters
    .
    skip 1
    read parameter dpst1f.dat ppa0 ppa1 ppa0sd ppa1sd a0tval a1tval
    skip 0
    let ppa0 = round(ppa0,2)
    let ppa1 = round(ppa1,2)
    let ppa0sd = round(ppa0sd,2)
    let ppa1sd = round(ppa1sd,2)
    let a0tval = round(a0tval,2)
    let a1tval = round(a1tval,2)
    just center
    move 50 6
    text Intercept = ^ppa0, SD = ^ppa0sd, t-Value = ^a0tval
    move 50 3
    text Slope = ^ppa1, SD = ^ppa1sd, t-Value = ^a1tval
    .
    . Step 5: Use the material-id
    .
    line blank all
    character 1 2 3 4 5 6 7 8 9 10
    character fill off
    character hw
    iso 13528 plot z z roundid labid matid lab2

-----ISO 13528 RLP PLOT--------------------------------------
 
ISO 13528 RLP PLOT
 
Name:
    ISO 13528 RLP PLOT
 
Type:
    Graphics Command
 
Purpose:
    Given a response variable containing z-scores and associated variables
    containing laboratory id's and material id's, generate a plot of
    relative laboratory performance versus the rescaled sum.
 
Description:
    One scenario for proficiency testing described in the ISO 13528
    standard is for the case where there are multiple rounds of testing.
    Given the proficiency data

         Z        - a variable containing the response data in z-score
                    units
         MATID    - a variable containing the material-id
         ROUNDID  - a variable containing the round-id
         LABID    - a variable containing the lab-id

    For ISO 13528 multi-round proficiency studies, the relative
    laboratory performance (RLP) for a given laboratory with N z-scores
    (Z(i)) is defined as

         RLP = SQRT{SUM[i=1 to N][Z(I)**2]/NMAT}

    where NMAT is the number of materials.  An RLP near 1 indicates
    average performance and an RLP greater than 1.5 indicates that
    the laboratory may be problematic.  An advantage of this
    statistic is that z-scores of opposite sign do not cancel each
    other out.  A disadvantage is that this statistic is suspectible
    to outliers in the z-scores.

    The rescaled sum (RSZ) is defined as

         RSZ = SUM[i=1 to N][Z(i)]/SQRT(N)

    So if there are k laboratories, the plot will consist of k points.
    For each laboratory, the RLP and RSZ are computed over all rounds
    and all materials.  Note that the material id variable enters only
    in computing the number of distinct materials in the above formulas.

    A value of RSZ greater than 2 or less than -2 flags a warning
    signal with regard to the laboratory.  A value of RSZ greater than
    3 or less than -3 flags an "action" signal (i.e., similar to an
    out-of-control signal from a control chart) with regard to the
    laboratory.  An advantage of this statistic is that it has the
    same interpretation as a z-score.  The disadvantage is that
    z-scores of opposite sign can cancel each other.

    Laboratories where the RLP is greater than 1.5 and the |RSZ| > 2
    are flagged as problematic.  This command automatically defines a
    sub-region area based on this area.  This is demonstrated in the
    Program example below.

    The RSZ statistic is discussed in Thompson, Ellison, and
    Wood (2006).  The RLP statistic is discussed in Uhlig and
    Lischer (1998).

    The RLP and RSZ statistics are examples of combination
    scores (i.e., the statistic is a combination of many
    individual z-scores).  Although the ISO 13528 standard
    recommends against using combination scores, these can
    be helpful in judging the overall performance of a
    laboratory.  A useful way to use this plot is to identify
    laboratories that are potentially problematic.  These
    laboratories can then be examined more carefully.  For
    example: is the poor performance due to one or a few outliers?
    is the lab consistently high or consistently low?  does the
    laboratory need to carefully examine their procedures?

Syntax:
    ISO 13528 RLP PLOT  <z>  <labid>  <matid>
                        <SUBSET/EXCEPT/FOR qualification>
    where <z> is a response variable containing z-scores;
          <labid> is a variable that specifies the lab-id;
          <matid> is a variable that specifies the material-id;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Examples:
    ISO 13528 RLP PLOT Z LABID MATID

Note:
    It can be helpful to identify individual laboratories on this
    plot. You can optionally specify that certain points be labelled
    with their lab-id.  You can use the following command to specify
    which points are labelled.

        SET RLP PLOT LABELS <NONE/ALL/WARNING/ACTION>

    where

       NONE     => no points are labelled
       ALL      => all points are labelled
       WARNING  => any point where the RLP > 1.5 or the
                   |RSZ| > 2 are labelled
       ACTION   => any point where the RLP > 1.5 or the
                   |RSZ| > 3 are labelled

    The default is none.  The Program example below demonstrates the
    ACTION option.  Note that you do not have to make any changes to
    the CHARACTER settings as Dataplot does this automatically.  The
    CHARACTER OFFSET command can be helpful in this context (it is
    the CHARACTER OFFSET for the second trace that controls the
    positioning of the lables).

Note:
    Some sources recommend capping the maximum value for the
    z-score when computing the RLP statistic.

    To specify this value, enter the command

        LET CAPVALUE = <value>

    where <value> is typically 3 or 4.  Note that the value represents
    an absolute value.  For example, if CAPVALUE is 4, values greater
    than 4 will be set to 4 and values less than -4 will be set to -4.

Note:
    The ISO 13528 standard defines a number of methods for computing the
    z-scores (enter HELP ISO 13528 ZSCORE, HELP ISO 13528 ZPRIME SCORE,
    and HELP ISO 13528 ZETA SCORE for details).  For this reason, the
    ISO 13528 RLP PLOT command does not automatically compute the
    z-scores from the original response data.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ISO 13528 PLOT           = Generate an ISO 13528 plot.
    ISO 13528 ZSCORE PLOT    = Generate an ISO 13528 zscore plot.
    ISO 13528 CONTROL CHART  = Generate an ISO 13528 control chart.
    ISO 13528 ZSCORE         = Compute z-scores as defined in the
                               ISO 13528 standard.
    ISO 13528 ZPRIME SCORE   = Compute z-prime scores as defined in the
                               ISO 13528 standard.
    ISO 13528 ZETA SCORE     = Compute zeta scores as defined in the
                               ISO 13528 standard.
    CHARACTER                = Sets the type for plot characters.
    LINE                     = Sets the type for plot lines.
 
References:
    Uhlig and Lischer (1998), "Statistically-based Performance
    Characteristics in Laboratory Performance Studies", Analyst,
    123, pp. 167-172.

    ISO 13528 (2005), "Statistical Methods for use in proficiency
    testing by interlaboratory comparisons," First Edition,
    2005-09-01.
 
Applications:
    Multi-Round Proficiency Testing
 
Implementation Date:
    2012/2
 
Program:
    . Step 1:   Read the data
    .
    dimension 40 columns
    skip 25
    read turner.dat labid z year quarter matid matave
    let roundid = year
    skip 0
    .
    . Step 2:   Set plot control setting
    .
    case asis
    title case asis
    title offset 2
    label case asis
    y1label Relative Laboratory Performance
    x1label Rescaled Sum
    title ISO 13528 RLP Plot for TURNER.DAT
    y1tic mark label decimal 1
    xlimits -8  8
    major xtic mark number 9
    minor xtic mark number 1
    x1tic mark offset 0 0
    .
    set rlp plot labels action
    region fill on
    region fill color g90
    line blank
    character circle
    character hw 0.5 0.375
    character fill on
    character offset 0 0 2 0
    .
    . Step 3:   Generate plot
    .
    iso 13528 rlp plot z labid matid

-----ISO 13528 ZETA SCORE (LET)-----------------------------------------
 
ISO 13528 ZETA SCORE
 
Name:
    ISO 13528 ZETA SCORE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Generate a zeta-score based on the ISO 13528 standard.

Description:
    The ISO 13528 standard for proficiency testing defines the following
    zeta-score

        Zeta(i) = (X(i) - Xref)/SQRT(u(X)**2 + u(ref)**2)

    with Xref, u(ref), and u(x) denoting the "assigned value", the
    standard uncertainty of the assigned value, and the laboratory's
    estimate of the standard uncertainty of its result, respectively.

    Determing an assigned value and its associated uncertainty is
    discussed on pages 5-10 of the standard.

    Since there are a mumber of different methods for determining
    Xref, u(ref), and u(X), these values will be defined by the user
    rather than being determined from the data.

    According to the ISO 13528 standard, it is not currently common
    practice to incorporate the u(X) information provided by the
    laboratories in the scores used in the proficiency testing.
    However, when there is an effective system for validating the
    laboratories estimates of their uncertainties, zeta-scores may
    be used instead of z-scores.   The zeta-scores have a similar
    interpretation, i.e., zeta-scores with an absolute value greater
    than 3 should be considered an "action signal" and those with an
    absolute value greater than 2 should be considered a "warning
    signal".

Syntax:
    LET <y> = ISO 13528 ZETA SCORE <x> <ulab> <xref> <uref>
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is the response variable;
          <ulab> is a variable containing the lab standard uncertainties;
          <xref> is a parameter that defines the assigned value;
          <uref> is a parameter that defines the standard uncertainty
              of the assigned value;
          <y> is a variable where the z-score values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    The <x> vector and the <ulab> vector should be of the same length.

Examples:
    LET Z = ISO 13528 ZETA SCORE X ULAB XREF UREF

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ISO 13528 ZSCORE        = Compute the z-score as defined by the
                              ISO 13528 standard.
    ISO 13528 ZPRIME SCORE  = Compute the z'-score as defined by the
                              ISO 13528 standard.
    ISO 13528 EN SCORE      = Compute the En performance values as defined
                              by the ISO 13528 standard.
    ISO 13528 EZMINUS SCORE = Compute the Ez- score as defined by the
                              ISO 13528 standard.
    ISO 13528 EZPLUS SCORE  = Compute the Ez+ score as defined by the
                              ISO 13528 standard.

Reference:
    ISO 13528, First Edition, Statistical Methods for Use
    in Proficiency Testing by Interlaboratory Comparisons,
    2005, pp. 29-30.

Applications:
    Proficiency Testing
 
Implementation Date:
    2012/1

Program:
    skip 25
    read gear.dat y x
    .
    let xref  = 1.
    let uref  = sd y
    let ulab  = cross tabulate sd y x
    .
    let yzeta = iso 13528 zeta score y ulab xref uref
    .
    set write decimals 3
    print x y ulab yzeta

-----ISO 13528 ZPRIME SCORE (LET)-----------------------------------------
 
ISO 13528 ZPRIME SCORE
 
Name:
    ISO 13528 ZPRIME SCORE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Generate a z'-score based on the ISO 13528 standard.

Description:
    The ISO 13528 standard for proficiency testing defines the following
    z'-score

        Z'(i) = (X(i) - Xref)/SQRT(sigma**2 + u(Xref)**2)

    with Xref, sigma, and u(Xref) denoting the "assigned value", the
    standard deviation of the proficiency assessment, and the
    standard uncertainty of the assigned value, respectively.

    Determing an assigned value and its associated uncertainty is
    discussed on pages 5-10 of the standard.  Determining a value
    for sigma is discussed on pages 15-18 of the standard.

    Since there are a mumber of different methods for determining
    Xref, u(Xref), and sigma, these values will be defined by the user
    rather than being determined from the data.

    The ISO 13528 standard recommends that z'-scores with an absolute
    value greater than 3 should be considered an "action signal" and
    those with an absolute value greater than 2 should be considered
    a "warning signal".

Syntax:
    LET <y> = ISO 13528 ZPRIME SCORE <x> <xref> <sigma> <uref>
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is the response variable;
          <xref> is a parameter that defines the assigned value;
          <sigma> is a parameter that defines the assigned value;
          <uref> is a parameter that defines the standard uncertainty
              of the assigned value;
          <y> is a variable where the z-score values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Examples:
    LET Z = ISO 13528 ZPRIME SCORE X XREF SIGMA UREF

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ISO 13528 EN SCORE      = Compute the En performance values as defined
                              by the ISO 13528 standard.
    ISO 13528 ZSCORE        = Compute the z-score as defined by the
                              ISO 13528 standard.
    ISO 13528 ZETA SCORE    = Compute the zeta-score as defined by the
                              ISO 13528 standard.
    ISO 13528 EZMINUS SCORE = Compute the Ez- score as defined by the
                              ISO 13528 standard.
    ISO 13528 EZPLUS SCORE  = Compute the Ez+ score as defined by the
                              ISO 13528 standard.

Reference:
    ISO 13528, First Edition, Statistical Methods for Use
    in Proficiency Testing by Interlaboratory Comparisons,
    2005, pp. 28-29.

Applications:
    Proficiency Testing
 
Implementation Date:
    2012/1

Program:
    .  Note: this example is just meant to demostrate the
    .        mechanics of the command.  This is not in fact
    .        proficiency data, but it can be used to demonstrate
    .        how to use the command.
    .
    skip 25
    read gear.dat y x
    .
    let xref  = 1.
    let sigma = sd y
    let uref = 0.001
    .
    let yz = iso 13528 zprime score y xref sigma uref
    .
    set write decimals 3
    print x y yz

-----ISO 13528 ZSCORE (LET)-----------------------------------------
 
ISO 13528 ZSCORE
 
Name:
    ISO 13528 ZSCORE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Generate a z-score based on the ISO 13528 standard.

Description:
    The standard definition of a z-score is 

        Z(i) = (X(i) - xbar)/s

    with xbar and s denoting the sample mean and standard deviation,
    respectively.

    The ISO 13528 standard for proficiency testing defines the following
    z-score

        Z(i) = (X(i) - Xref)/sigma

    with Xref and sigma denoting the "assigned value" and the standard
    deviation of the proficiency assessment, respectively.

    Determing an assigned value is discussed on pages 5-10 of the
    standard.  Determining a value for sigma is discussed on
    pages 15-18 of the standard.

    Since there are a mumber of different methods for determining
    Xref and sigma, these values will be defined by the user rather
    than being determined from the data.

    The ISO 13528 standard recommends that z-scores with an absolute
    value greater than 3 should be considered an "action signal" and
    those with an absolute value greater than 2 should be considered
    a "warning signal".

Syntax:
    LET <y> = ISO 13528 ZSCORE <x> <xref> <sigma>
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is the response variable;
          <xref> is a parameter that defines the assigned value;
          <sigma> is a parameter that defines the assigned value;
          <y> is a variable where the z-score values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Examples:
    LET Z = ISO 13528 ZSCORE X XREF SIGMA

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ISO 13528 EN SCORE      = Compute the En performance values as defined
                              by the ISO 13528 standard.
    ISO 13528 ZPRIME SCORE  = Compute the z'-score as defined by the
                              ISO 13528 standard.
    ISO 13528 ZETA SCORE    = Compute the zeta-score as defined by the
                              ISO 13528 standard.
    ISO 13528 EZMINUS SCORE = Compute the Ez- score as defined by the
                              ISO 13528 standard.
    ISO 13528 EZPLUS SCORE  = Compute the Ez+ score as defined by the
                              ISO 13528 standard.

Reference:
    ISO 13528, First Edition, Statistical Methods for Use
    in Proficiency Testing by Interlaboratory Comparisons,
    2005, pp. 25-26.

Applications:
    Proficiency Testing
 
Implementation Date:
    2012/1

Program:
    .  Note: this example is just meant to demostrate the
    .        mechanics of the command.  This is not in fact
    .        proficiency data, but it can be used to demonstrate
    .        how to use the command.
    .
    skip 25
    read gear.dat y x
    .
    let xref  = 1.
    let sigma = sd y
    .
    let yz = iso 13528 zscore y xref sigma
    .
    set write decimals 3
    print x y yz

-----ISO 13528 ZSCORE PLOT--------------------------------------
 
ISO 13528 ZSCORE PLOT
 
Name:
    ISO 13528 ZSCORE PLOT
 
Type:
    Graphics Command
 
Purpose:
    Plot the average z-score (or j-score) for each material/round
    combination.  These are also referred to as zone plots.
 
Description:
    One scenario for proficiency testing described in the ISO 13528
    standard is for the case where there are multiple rounds of testing.
    Given the proficiency data

         Z        - a variable containing the response data in z-score
                    units
         MATID    - a variable containing the material-id
         ROUNDID  - a variable containing the round-id
         LABID    - a variable containing the lab-id

    For a given laboratory, define a grid using the MATID variable for the
    vertical axis and the ROUNDID variable for the horizontal axis.  Then
    for each material/round cell compute the z-score for the given
    laboratory.  If the laboratory has replicated values, compute the
    average z-score for the cell.

    Based on the z-score, define the plot symbol for the cell based on

       trace 1:    -2 <  Z <  +2
       trace 2:    +2 <  Z <  +3
       trace 3:    -3 <  Z <  -2
       trace 4:    +3 <= Z
       trace 5:          Z <= -3

    The +/-2 limits typically define a "warning" signal while the +/-3
    limits typically define an "action" signal.
   
    Alternatively, j-scores can be used.  The j-score is computed
    as follows:

      1. If there is replication in the cell, the averages of the
         z-scores will be used as the z-score for that cell.

         Alternatively, you can request that the most extreme
         z-score in that cell be used rather than the average.

      2. An initial j-score for the cell is assigned as follows:

            z-score          j-score
            ========================
            +3 <= z            8
            +2 <= z <  +3      4
            +1 <= z <  +2      2
            -1 <= z <  +1      0
            -2 <  z <= -1     -2
            -3 <  z <= -2     -4
            -3 <= z           -8

      3. We will compute a final j-score for the cell and a
         cumulative j-score.  The cumulative j-score will be used
         with the initial j-score of the next round to compute
         the final j-score for the next round.

         To compute the final and cumulative j-scores for the round,
         do the following:

         a.  If the initial j-score for the round is 8, then set the final
             j-score for the round to 8 (if the cumulative j-score from the
             previous round is positive, then this is added to 8) and
             reset the cumulative j-score for the next round to 0.
 
             Likewise, if the j-score for the round is -8, then set the
             final j-score for the round to -8 (if the cumulative j-score
             from the previous round is negative, then this is added to
             -8) and reset the cumulative j-score for the next round to 0.

          b. If the j-score for the round is inside the (-8,+8) interval,
             then compare the signs of the cumulative j-score from the
             previous round to the j-score for the current round.

             If the signs are the same, then add the cumulative j-score
             from the previous round to the initial j-score for the
             round to obtain the final j-score for the round.  This
             will also be the cumulative j-score for the next round.

             If the signs are different, then set the final j-score for
             the round to initial j-score value.  However, set the
             cumulative j-score for the next round to 0.

    Based on the final j-score, define the plot symbol for the cell
    based on

       trace 1:    -2 <= J <=  2
       trace 2:    +2 <  J <  +4
       trace 3:    -4 <  J <  -2
       trace 4:    +4 <  J <  +6
       trace 5:    -6 <  J <  -4
       trace 6:    +6 <  J <  +8
       trace 7:    -8 <  J <  -6
       trace 8:    +8 <= J
       trace 9:          J <= -8

    The Program example below demonstrates how to set the plot
    symbols.

    The j-score combines properties of both the mean control chart and
    the cusum control charts.  Specifically, it can detect both abrupt
    changes (i.e., j-scores for a given round > 8 or < -8) and drift
    in the result (i.e., several successive positive j-scores or
    several successive negative j-scores).

    The plots described here are not part of the ISO 13528
    standard.  However, they are described in Thompson, Ellison,
    and Wood (see References below) and are used in the context of
    ISO 13528 multi-round proficiency studies.  These plots are
    alternatives to the control charts given in the ISO 13528
    standard.  Thompson, Ellison, and Wood refer to the z-score and
    j-score plots described here as zone plots.

Syntax 1:
    ISO 13528 ZSCORE PLOT  <z>  <matid> <roundid>
                           <SUBSET/EXCEPT/FOR qualification>
    where <z> is a response variable containing z-scores;
          <matid> is a variable that specifies the material-id;
          <roundid> is a variable that specifies the round-id;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax is used to generate the z-score version of the
    plot.

    The SUBSET clause is typically used to specify a single
    laboratory (see the Examples below).  If no laboratory is
    specified on the SUBSET clause, then the different
    laboratories are treated like replications from a single
    laboratory.

Syntax 2:
    ISO 13528 JSCORE PLOT  <z>  <matid> <roundid>
                           <SUBSET/EXCEPT/FOR qualification>
    where <z> is a response variable containing z-scores;
          <matid> is a variable that specifies the material-id;
          <roundid> is a variable that specifies the round-id;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax is used to generate the j-score version of the
    plot.

    The SUBSET clause is typically used to specify a single
    laboratory.  If no laboratory is specified on the SUBSET clause,
    then the different laboratories are treated like replications from
    a single laboratory.

Examples:
    ISO 13528 ZSCORE PLOT Z MATID ROUNDID  SUBSET LABID = 32
    ISO 13528 JSCORE PLOT Z MATID ROUNDID  SUBSET LABID = 32

Note:
    The ISO 13528 standard defines a number of methods for computing the
    z-scores (enter HELP ISO 13528 ZSCORE, HELP ISO 13528 ZPRIME SCORE,
    and HELP ISO 13528 ZETA SCORE for details).  For this reason, the
    ISO 13528 ZSCORE PLOT command does not automatically compute the
    z-scores from the original response data.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ISO 13528 PLOT           = Generate an ISO 13528 plot.
    ISO 13528 CONTROL CHART  = Generate an ISO 13528 control chart.
    ISO 13528 ZSCORE         = Compute z-scores as defined in the
                               ISO 13528 standard.
    ISO 13528 ZPRIME SCORE   = Compute z-prime scores as defined in the
                               ISO 13528 standard.
    ISO 13528 ZETA SCORE     = Compute zeta scores as defined in the
                               ISO 13528 standard.
    CHARACTER                = Sets the type for plot characters.
    LINE                     = Sets the type for plot lines.
 
References:
    Michael Thompson, Stephen Ellison, Roger Wood (2006), The
    International Harmonized Protocol for the Proficiency Testing of
    Analytical Chemistry Laboratories, Pure Applied Chemistry, Vol. 78,
    No. 1, pp. 145-196.

    Jaehn (1991), "The Zone Control Chart", Quality Progress,
    24, pp. 65-68.

    ISO 13528 (2005), "Statistical Methods for use in proficiency
    testing by interlaboratory comparisons," First Edition,
    2005-09-01.
 
    Howarth, Richard J. (2003), "The J-chart: a simple plot that
    combines the capabilities of Shewart and cusum charts, for use
    in analytical quality control," AMC Technical Brief,
    Royal Society of Chemistry, No. 12.

Applications:
    Multi-Round Proficiency Testing
 
Implementation Date:
    2012/2
    2015/10: Corrected the computation of the j-scores
 
Program 1:
    . Step 1:   Read the data
    .
    dimension 40 columns
    skip 25
    read allergen.dat z labid matid year quarter
    let roundid = year + (quarter-1)/4
    skip 0
    .
    . Step 2:   Set plot control setting
    .
    case asis
    title case asis
    title offset 2
    .
    line blank all
    character circle tria revtri tria revtri
    character hw 0.5 0.375 2.0 1.50 2.0 1.50 4 3 4 3
    character fill on all
    .
    tic mark offset units data
    tic mark offset 0.5 0.5
    .
    . Step 3:   Generate plot
    .
    y1label Material
    x1label Round
    title Z-Score Zone Plot for ALLERGEN.DAT
    iso 13528 zscore plot z matid roundid
    .
    line solid all
    character blank all
    justification center
    fill on
    font simplex
    hw 4 3
    move 87.5 86
    text tria()
    hw 2 1.5
    move 87.5 83
    text tria()
    hw 0.5 0.375
    move 87.5 80
    text circ()
    hw 2 1.5
    move 87.5 76
    text revt()
    hw 4 3
    move 87.5 71
    text revt()
    justification left
    fill off
    font tektronix
    .
    hw 2 1
    move 91 88
    text z > 3
    move 91 83.5
    text 2 < z < 3
    move 91 79.5
    text -2 < z < 2
    move 91 76
    text -2 < z < -3
    move 91 71.5
    text z < -3
 
Program 2:
    . Step 1:   Read the data
    .
    dimension 40 columns
    skip 25
    read allergen.dat z labid matid year quarter
    let roundid = year + (quarter-1)/4
    skip 0
    .
    . Step 2:   Set plot control setting
    .
    case asis
    title case asis
    title offset 2
    .
    line blank all
    character circle tria revtri tria revtri tria revtri tria revtri
    character hw 0.5 0.375 1.0 0.75 1.0 0.75 2.0 1.50 2.0 1.50 ...
                 3.0 2.25 3.0 2.25 4 3 4 3
    character fill on all
    .
    tic mark offset units data
    tic mark offset 0.5 0.5
    .
    y1label Material
    x1label Round
    title J-Score Zone Plot for ALLERGEN.DAT
    iso 13528 jscore plot z matid roundid
    .
    line solid all
    character blank all
    justification center
    fill on
    font simplex
    .
    hw 4 3
    move 87.5 86
    text tria()
    .
    hw 3 2.25
    move 87.5 82
    text tria()
    .
    hw 2 1.5
    move 87.5 78
    text tria()
    .
    hw 1 0.75
    move 87.5 74
    text tria()
    .
    hw 0.5 0.375
    move 87.5 70
    text circ()
    .
    hw 1 0.75
    move 87.5 66
    text revt()
    .
    hw 2 1.5
    move 87.5 62
    text revt()
    .
    hw 3 2.25
    move 87.5 58
    text revt()
    .
    hw 4 3
    move 87.5 54
    text revt()
    .
    justification left
    fill off
    font tektronix
    .
    hw 2 1
    move 91 88
    text j > 8
    move 91 83
    text 6 < j < 8
    move 91 78.5
    text 4 < j < 6
    move 91 74
    text 2 < j < 4
    move 91 69.5
    text -2 < j < 2
    move 91 65.5
    text -4 < j < -2
    move 91 62
    text -6 < j < -4
    move 91 59
    text -8 < j < -2
    move 91 54.5
    text j < -8

-----ISUBRO (SET)--------------------------------------------
 
ISUBRO
 
Name:
    ISUBRO (SET)
 
Type:
    Set Subcommand
 
Purpose:
    Turn on debugging switches for a specific subroutine.
 
Description:
    Dataplot contains a number of commands for turning on debug switches.
    When a debugging switch is turned on, certain print statements will
    be activated to aid in debugging.

    The SET ISUBRO command can be used to turn on debugging for a
    specific subroutine.  Although this command is primarily of interest
    to the Dataplot developers, it can be used by any Dataplot user.

Syntax:
    SET ISUBRO <string>
    where <string> contains the last four characters of the desired
             subroutine.
 
Examples:
    SET ISUBRO HIS2
    SET ISUBRO HIST
    SET ISUBRO FIT2

Note:
    Not all Dataplot subroutines support the ISUBRO switch.  Although
    most new commands support the use of ISUBRO, many older commands
    do not.

Note:
    The debug switches can result in a large amount of output being
    generated.  For that reason, you may want to use the CAPTURE command
    to save the output to a file.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SET BUG SWITCHES = Turn on debugging switches.
    SET FATAL ERROR  = Specify what action to take when an error is
                       detected.
    CAPTURE          = Redirect terminal output to a file.
 
Applications:
    Debugging
 
Implementation Date:
    Pre-1987
 
Program:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    CAPTURE JUNK.OUT
    SET ISUBRO HIST
    HISTOGRAM Y
    SET ISUBRO HIS2
    HISTOGRAM Y
    END OF CAPTURE
 
-----IWECDF (LET)--------------------------------
 
IWECDF
 
Name:
    IWECDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the inverted Weibull cumulative
    distribution function with tail length parameter GAMMA.
 
Description:
    The standard form of the inverted Weibull cumulative distribution
    function is:
       F(x) = EXP{-(x)**(-gamma)}               x, gamma > 0
 
Syntax:
    LET <y2> = IWECDF(<y1>,GAMMA)   <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, number, or parameter;
          <y2> is a variable or a parameter (depending on what <y1>
               is) where the computed inverted Weibull cdf value is
               stored;
          <GAMMA> is a positive number or parameter that specifies the
               tail length parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = IWECDF(3,2)
    LET A = IWECDF(A1,4)
    LET X2 = IWECDF(X1,8)
 
Note:
    The general form of the inverted Weibull cumulative distribution
    function is:
       F(x) =EXP{-[(x-u)/beta]**(-gamma)}           x > mu
    where u is the location parameter and beta is the scale
    parameter.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    IWEPDF     = Compute the inverted Weibull probability density
                 function.
    IWEPPF     = Compute the inverted Weibull percent point function.
    WEIPDF     = Compute the Weibull probability density function.
    GAMPDF     = Compute the gamma probability density function.
    CHSPDF     = Compute the chi-square probability density function.
    NORPDF     = Compute the normal probability density function.
    LOGPDF     = Compute the lognormal probability density function.
    PPCC PLOT  = Generate a PPCC plot.
    PROB PLOT  = Generate a probability plot.
    RAND NUMB  = Generate random numbers.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, 1994, John Wiley, pp. 693.
 
Applications:
    Reliability Analysis
 
Implementation Date:
    2001/10
 
Program:
    MULTIPOT 2 2
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT SCALE FACTOR 2
    Y1LABEL Probability
    Y1LABEL DISPLACEMENT 12
    X1LABEL X
    TITLE IWECDF (GAMMA = 0.5)
    PLOT IWECDF(X,0.5) FOR X = 0.01 0.01 5
    TITLE IWECDF (GAMMA = 1)
    PLOT IWECDF(X,1) FOR X = 0.01 0.01 5
    TITLE IWECDF (GAMMA = 2)
    PLOT IWECDF(X,2) FOR X = 0.01 0.01 5
    TITLE IWECDF (GAMMA = 5)
    PLOT IWECDF(X,5) FOR X = 0.01 0.01 5
    END OF MULTIPLOT
 
-----IWECHAZ (LET)--------------------------------
 
IWECHAZ
 
Name:
    IWECHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the inverted Weibull cumulative
    hazard function with tail length parameter GAMMA.
 
Description:
    The standard form of the inverted Weibull cumulative hazard
    function is:
       H(x) = -LOG{1-exp(-(x)**(-gamma))}    x, gamma > 0
 
Syntax:
    LET <y2> = IWECHAZ(<y1>,GAMMA)   <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, number, or parameter;
          <y2> is a variable or a parameter (depending on what <y1>
               is) where the computed inverted Weibull cumulative
               hazard value is stored;
          <GAMMA> is a positive number or parameter that specifies the
               tail length parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = IWECHAZ(3,2)
    LET A = IWECHAZ(A1,4)
    LET X2 = IWECHAZ(X1,8)
 
Note:
    The general form of the inverted Weibull cumulative hazard
    function is:
       H(x) = -LOG{1-EXP{-[(x-u)/beta]**(-gamma)}}  x > mu; gamma > 0
    where u is the location parameter and beta is the scale
    parameter.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    IWECDF     = Compute the inverted Weibull cumulative distribution
                 function.
    IWEHAZ     = Compute the inverted Weibull hazard function.
    IWEPDF     = Compute the inverted Weibull probability density
                 function.
    IWEPPF     = Compute the inverted Weibull percent point function.
    WEIPDF     = Compute the Weibull probability density function.
    GAMPDF     = Compute the gamma probability density function.
    CHSPDF     = Compute the chi-square probability density function.
    NORPDF     = Compute the normal probability density function.
    LOGPDF     = Compute the lognormal probability density function.
    PPCC PLOT  = Generate a PPCC plot.
    PROB PLOT  = Generate a probability plot.
    RAND NUMB  = Generate random numbers.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, 1994, John Wiley, pp. 693.
 
Applications:
    Reliability Analysis
 
Implementation Date:
    2001/10
 
Program:
    MULTIPOT 2 2
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT SCALE FACTOR 2
    Y1LABEL Hazard
    Y1LABEL DISPLACEMENT 12
    X1LABEL X
    TITLE IWECHAZ (GAMMA = 0.5)
    PLOT IWECHAZ(X,0.5) FOR X = 0.01 0.01 5
    TITLE IWECHAZ (GAMMA = 1)
    PLOT IWECHAZ(X,1) FOR X = 0.01 0.01 5
    TITLE IWECHAZ (GAMMA = 2)
    PLOT IWECHAZ(X,2) FOR X = 0.01 0.01 5
    TITLE IWECHAZ (GAMMA = 5)
    PLOT IWECHAZ(X,5) FOR X = 0.01 0.01 5
    END OF MULTIPLOT
 
-----IWEHAZ (LET)--------------------------------
 
IWEHAZ
 
Name:
    IWEHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the inverted Weibull hazard
    function with tail length parameter GAMMA.
 
Description:
    The standard form of the inverted Weibull hazard function is:
       h(x) = {gamma*x**(-gamma-1)*exp(-(x**(-gamma)))}/
              {1-exp(-(x)**(-gamma))}    x, gamma > 0
 
Syntax:
    LET <y2> = IWEHAZ(<y1>,GAMMA)   <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, number, or parameter;
          <y2> is a variable or a parameter (depending on what <y1>
               is) where the computed inverted Weibull hazard value is
               stored;
          <GAMMA> is a positive number or parameter that specifies the
               tail length parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = IWEHAZ(3,2)
    LET A = IWEHAZ(A1,4)
    LET X2 = IWEHAZ(X1,8)
 
Note:
    The general form of the inverted Weibull hazard function is:
       h(x) = {gamma*beta**gamma*(x-u)**(-gamma-1)*
              exp(-((x-u)/beta)**(-gamma)))}/
              {1 - EXP{-[(x-u)/beta]**(-gamma)}}      x > mu; gamma > 0
    where u is the location parameter and beta is the scale
    parameter.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    IWECDF     = Compute the inverted Weibull cumulative distribution
                 function.
    IWECHAZ    = Compute the inverted Weibull cumulative hazard
                 function.
    IWEPDF     = Compute the inverted Weibull probability density
                 function.
    IWEPPF     = Compute the inverted Weibull percent point function.
    WEIPDF     = Compute the Weibull probability density function.
    GAMPDF     = Compute the gamma probability density function.
    CHSPDF     = Compute the chi-square probability density function.
    NORPDF     = Compute the normal probability density function.
    LOGPDF     = Compute the lognormal probability density function.
    PPCC PLOT  = Generate a PPCC plot.
    PROB PLOT  = Generate a probability plot.
    RAND NUMB  = Generate random numbers.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, 1994, John Wiley, pp. 693.
 
Applications:
    Reliability Analysis
 
Implementation Date:
    2001/10
 
Program:
    MULTIPOT 2 2
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT SCALE FACTOR 2
    Y1LABEL Hazard
    Y1LABEL DISPLACEMENT 12
    X1LABEL X
    TITLE IWEHAZ (GAMMA = 0.5)
    PLOT IWEHAZ(X,0.5) FOR X = 0.01 0.01 5
    TITLE IWEHAZ (GAMMA = 1)
    PLOT IWEHAZ(X,1) FOR X = 0.01 0.01 5
    TITLE IWEHAZ (GAMMA = 2)
    PLOT IWEHAZ(X,2) FOR X = 0.01 0.01 5
    TITLE IWEHAZ (GAMMA = 5)
    PLOT IWEHAZ(X,5) FOR X = 0.01 0.01 5
    END OF MULTIPLOT
 
-----IWEPDF (LET)--------------------------------
 
IWEPDF
 
Name:
    IWEPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the inverted Weibull probability
    density function with tail length parameter GAMMA.
 
Description:
    The standard form of the inverted Weibull probability density
    function is:
       f(x) = gamma*x**(-gamma-1)*exp(-(x**(-gamma)))    x, gamma > 0
 
Syntax:
    LET <y2> = IWEPDF(<y1>,GAMMA)   <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, number, or parameter;
          <y2> is a variable or a parameter (depending on what <y1>
               is) where the computed inverted Weibull pdf value is
               stored;
          <GAMMA> is a positive number or parameter that specifies the
               tail length parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = IWEPDF(3,2)
    LET A = IWEPDF(A1,4)
    LET X2 = IWEPDF(X1,8)
 
Note:
    The general form of the inverted Weibull probability density
    function is:
       f(x) = gamma*beta**gamma*(x-u)**(-gamma-1)*
                 exp(-((x-u)/beta)**(-gamma)))    x > u
    where u is the location parameter and beta is the scale
    parameter.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    IWECDF     = Compute the inverted Weibull cumulative distribution
                 function.
    IWEPPF     = Compute the inverted Weibull percent point function.
    WEIPDF     = Compute the Weibull probability density function.
    GAMPDF     = Compute the gamma probability density function.
    CHSPDF     = Compute the chi-square probability density function.
    NORPDF     = Compute the normal probability density function.
    LOGPDF     = Compute the lognormal probability density function.
    PPCC PLOT  = Generate a PPCC plot.
    PROB PLOT  = Generate a probability plot.
    RAND NUMB  = Generate random numbers.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, 1994, John Wiley, pp. 693.
 
Applications:
    Reliability Analysis
 
Implementation Date:
    2001/10
 
Program:
    MULTIPOT 2 2
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT SCALE FACTOR 2
    Y1LABEL Probability
    Y1LABEL DISPLACEMENT 12
    X1LABEL X
    TITLE IWEPDF (GAMMA = 0.5)
    PLOT IWEPDF(X,0.5) FOR X = 0.01 0.01 5
    TITLE IWEPDF (GAMMA = 1)
    PLOT IWEPDF(X,1) FOR X = 0.01 0.01 5
    TITLE IWEPDF (GAMMA = 2)
    PLOT IWEPDF(X,2) FOR X = 0.01 0.01 5
    TITLE IWEPDF (GAMMA = 5)
    PLOT IWEPDF(X,5) FOR X = 0.01 0.01 5
    END OF MULTIPLOT
 
-----IWEPPF (LET)--------------------------------
 
IWEPPF
 
Name:
    IWEPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard form of the inverted Weibull percent
    point function with tail length parameter GAMMA.
 
Description:
    The standard form of the inverted Weibull percent point
    function is:
       G(P) =-[LOG(P)]**(-1/GAMMA)             0 <= P < 1, gamma > 0
 
Syntax:
    LET <y> = IWEPPF(<p>,GAMMA)   <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, number, or parameter;
          <y> is a variable or a parameter (depending on what <p>
              is) where the computed inverted Weibull ppf value is
              stored;
          <GAMMA> is a positive number or parameter that specifies the
               tail length parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = IWEPPF(0.9,2)
    LET A = IWEPPF(A1,4)
    LET X2 = IWEPPF(P,8)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    IWECDF     = Compute the inverted Weibull cumulative distribution
                 function.
    IWEPDF     = Compute the inverted Weibull probability density
                 function.
    WEIPDF     = Compute the Weibull probability density function.
    GAMPDF     = Compute the gamma probability density function.
    CHSPDF     = Compute the chi-square probability density function.
    NORPDF     = Compute the normal probability density function.
    LOGPDF     = Compute the lognormal probability density function.
    PPCC PLOT  = Generate a PPCC plot.
    PROB PLOT  = Generate a probability plot.
    RAND NUMB  = Generate random numbers.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, 1994, John Wiley, pp. 693.
 
Applications:
    Reliability Analysis
 
Implementation Date:
    2001/10
 
Program:
    MULTIPOT 2 2
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT SCALE FACTOR 2
    Y1LABEL Probability
    Y1LABEL DISPLACEMENT 12
    X1LABEL P
    TITLE IWEPPF (GAMMA = 0.5)
    PLOT IWEPPF(P,0.5) FOR P = 0.01 0.01 0.99
    TITLE IWEPPF (GAMMA = 1)
    PLOT IWEPPF(P,1) FOR P = 0.01 0.01 0.99
    TITLE IWEPPF (GAMMA = 2)
    PLOT IWEPPF(P,2) FOR P = 0.01 0.01 0.99
    TITLE IWEPPF (GAMMA = 5)
    PLOT IWEPPF(P,5) FOR P = 0.01 0.01 0.99
    END OF MULTIPLOT
 
-------------------------------------------------------------





























































-------------------------  *J*  ZZZZZ--------------------

-----J0INT (LET)--------------------------------

J0INT

Name:
   J0INT (LET)
 
Type:
    Library Function

Purpose:
    This program computes the integral of the Bessel function J0(x).

Description:
    The J0INT function is defined as:

        J0INT(x) = {integral 0 to x} J0(t) dt    x >= 0

    with J0 denoting the Bessel function of the first kind of
    order 0.

    Dataplot computes this function using ACM Algorithm 757 (see
    Reference: below).  The function is computed using Chebyshev
    expansions, the coefficients of which are given to 20 decimal
    places.

Syntax:
    LET <y> = J0INT(<x>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative number, variable or parameter;
          <y> is a variable or a parameter (depending on what <x> 
               is) where the computed J0INT function values are
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = J0INT(2.3)
    PLOT J0INT(X) FOR  X = 0 .01 10
    LET X2 = J0INT(X1) FOR X1 = 0.1 0.1 3.0
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BESSJ0     = Compute the Bessel function of the first kind and
                 order 0.
    BESSJ1     = Compute the Bessel function of the first kind and
                 order 1.
    BESSJN     = Compute the Bessel function of the first kind and
                 order N.
    BESSIN     = Compute the modified Bessel function of the first
                 kind and order N.
    BESSKN     = Compute the modified Bessel function of the third
                 kind and order N.
    BESSYN     = Compute the Bessel function of the second kind and
                 order N.
    I0INT      = Compute the integral of the modified Bessel
                 function of the first kind and order 0.
    K0INT      = Compute the integral of the modified Bessel
                 function of the third kind and order 0.
    Y0INT      = Compute the integral of the Bessel function of
                 the second kind and order 0.

Reference:
    "ACM Transactions of Mathematical Software", Allan MacLead,
    Vol. 22, No. 3, September, 1996, pp. 288-301.
 
Applications:
    Special Functions
 
Implementation Date:
    2005/11
 
Program:
    TITLE J0INT FUNCTION
    PLOT J0INT(X) FOR X = 0 0.01 10
 
-----JACKNIFE INDEX (LET)--------------------------------
 
JACKNIFE INDEX
 
Name:
    JACKNIFE INDEX (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Generate a sequence from 1 to N and set one of the elements to
    zero.
 
Description:
    The jacknife is a non-parametric method for estimating the sampling
    distribution of a statistic.  Given a sample data set and a desired
    statistic (e.g., the mean), the jacknife works by computing the
    desired statistic with an element (or a group of elements) deleted.
    This is done for each element of the data set.  The collection of
    these statistics is used as an estimate of the sampling
    distribution.  A histogram or some other type of distributional
    plot is usually performed on the computed values of the statistic.
    The JACKNIFE PLOT command can be used to generate a jacknife
    analysis for about 25 statistics.  The JACKNIFE INDEX command can
    be used in conjunction with the LOOP and SUBSAMPLE commands to
    perform a jacknife analysis for an unsupported statistic.
 
Syntax:
    LET <ind> = JACKNIFE INDEX <i> <max>
    where <ind> is a variable that contains the computed index numbers;
          <i> is the element to delete;
    and   <max> is the size of the sample.
                analysis is being performed.
 
Examples:
    LET IND = JACKNIFE INDEX 3 100
    LET IND2 = JACKNIFE INDEX 8 1000
 
Note:
    The bootstrap is a similar technique.  However, it uses a different
    resampling scheme.  See the BOOTSTRAP PLOT command for details.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    JACKNIFE PLOT       = Generate a jacknife plot.
    BOOTSTRAP SAMPLE    = Generate a jacknife or bootstrap sample.
    BOOTSTRAP INDEX     = Generate a bootstrap index.
    BOOTSTRAP PLOT      = Generate a bootstrap plot.
    LOOP                = Initiate a loop.
 
Reference:
    "A Leisurely Look at the Bootstrap, the Jacknife, and
    Cross-Validation", Efron and Gong, The American Statistician,
    February, 1983.
 
Applications:
    Sample Distribution of a Statistic
 
Implementation Date:
    89.2
 
Program 1: (USE JACKNIFE INDEX, RANDOMLY SELECT ELEMENT TO DELETE)
    LET Y = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LOOP FOR K = 1 1 100
        LET IND = JACKNIFE INDEX K 100
        LET YMEAN = MEAN Y SUBSET IND > 0
        LET Y0(K) = YMEAN
    END OF LOOP
    HISTOGRAM Y0
 
-----JACKNIFE PLOT---------------------------------
 
JACKNIFE PLOT
 
Name:
    JACKNIFE PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a jacknife plot for a given statistic.
 
Description:
    The jacknife is a non-parametric method for calculating a sampling
    distribution for a statistic.  If there are N observations, the
    jacknife calculates the statistic N times where subsample i
    omits X(i) from the sample.

    For the jacknife plot, the vertical axis contains the computed
    value of the statistic and the horizontal axis contains the
    sample number (for k = 1, 2,  ..., N).  The number of response
    variables depends on the number of variables required to compute the
    statistic (e.g., the MEAN uses one while the LINEAR INTERCEPT uses
    two). The jacknife plot is typically followed by some type of
    distributional plot such as a histogram.
 
Syntax 1:
    JACKNIFE <stat> PLOT <y1> ... <yk>
                          <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of 1 to 3 response variables
              (depending on what <stat> is);
          <stat> is one of Dataplot's supported statistics
              (enter HELP STATISTICS for a list);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for the no group-id's case.

Syntax 2:
    JACKNIFE <stat> PLOT <y1> ... <yk> <x>
                          <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of 1 to 3 response variables
              (depending on what <stat> is);
          <x> is a group id variable;
          <stat> is one of Dataplot's supported statistics
              (enter HELP STATISTICS for a list);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for the case when there is one group-id
    variable.

Syntax 3:
    JACKNIFE <stat> PLOT <y1> ... <yk> <x1> <x2>
                          <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of 1 to 3 response variables
              (depending on what <stat> is);
          <x1> is the first group id variable;
          <x2> is the second group id variable;
          <stat> is one of Dataplot's supported statistics
              (enter HELP STATISTICS for a list);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for the case when there are two group-id
    variables.

Examples:
    JACKNIFE MEAN PLOT Y
    JACKNIFE LINEAR SLOPE PLOT Y1 X1
 
Note:
    When there are two or more response variables, the jacknife is
    only supported when the response variables are paired.

Note:
    In addition to the supported statistics, the following
    additional statistics are supported

        LINEAR CALIBRATION
        QUADRATIC CALIBRATION

 
Note:
    A number of these statistics require one or more parameters
    to be defined before entering the JACKNIFE PLOT command.
    Specifically,

       1. The trimmed and Winsorized statistics, the percentage
          of data in each tail to be trimmed/Winsorized needs to
          be specified.  For example, to trim/Winsorize 10% of the
          data in each tail, enter the commands:

             LET P1 = 10%
             LET P2 = 10%

       2. For the QUANTILE and QUANTILE STANDARD ERROR, the
          quantile being estimated needs to be specified by
          entering the command

             LET XQ = <value>

          where <value> is a number in the range 0 to 1.

          Likewise, for the PERCENTILE, the desired percentile
          needs to be specified by entering the command

             LET P100 = <value>

          where <value> is a number in the range 0 to 100.

       3. For the PERCENTAGE BEND MIDVARIANCE and PERCENTAGE
          BEND CORRELATION, the value of beta needs to be
          specified by entering the command:

              LET BETA = <value>

          where <value> is a number between 0 and 0.5.  A
          default value of 0.1 is used if beta is not defined.

       4. For the LINEAR CALIBRATION and QUADRATIC CALIBRATION
          statistics, the value of Y for which the calibration
          is to be computed is specified by entering the command

              LET Y0 = <value>

Note:
    The bootstrap is similar to the jacknife.  Enter HELP BOOTSTRAP
    PLOT for details.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BOOTSTRAP PLOT   = Generates a bootstrap plot.
    BOOTSTRAP SAMPLE = Set the sample size for the jacknife.
    LINES            = Sets the type for plot lines.
    HISTOGRAM        = Generates a histogram.
    PLOT             = Generates a data or function plot.
 
Reference:
    Efron and Gong, "A Leisurely Look at the Bootstrap, the Jacknife,
    and Cross-Validation", The American Statistician, February, 1983.
 
 
Applications:
    Sample Distribution of a Statistic
 
Implementation Date:
    89/2
    98/5 added the saving of the parameters (BMEAN, BSD, etc.)
    2001/3 added GEOMETRIC MEAN, GEOMETRIC STANDARD DEVIATION,
           HARMONIC MEAN
    2001/9 added IQ RANGE
    2001/11 added BIWEIGHT LOCATION, BIWEIGHT SCALE
    2002/7 activated CORRELATION, COVARIANCE, RANK CORRELATION,
           RANK COVARIANCE
    2002/7 added LINEAR CALIBRTION, QUADRATIC CALIBRATION,
           WINSORIZED VARIANCE, WINSORIZED CORRELATION,
           WINSORIZED COVARIANCE, BIWEIGHT MIDVARIANCE,
           BIWEIGHT MIDCOVARIANCE, PERCENTAGE BEND MIDVARIANCE,
           PERCENTAGE BEND CORRELATION, HODGE LEHMAN,
           TRIMMED MEAN STANDARD ERROR,
           QUANTILE, QUANTILE STANDARD ERROR
    2010/3 Added support for tabular report in addition to the plot
 
Program:
    TITLE AUTOMATIC
    MULTIPLOT 2 1
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 1000
    JACKNIFE MEAN PLOT Y1
    LET YPLOT2 = YPLOT
    HISTOGRAM YPLOT2
    END OF MULTIPLOT
 
-----JACOBIP (LET)--------------------------------
 
JACOBIP
 
Name:
    JACOBIP (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Jacobi polynomial of order N.
 
Description:
    From Abramowitz and Stegum (see Reference below), a system of
    nth degree polynomials f(x,n) is called orthogonal on the
    interval a<=x<=b with respect to a weight function w(x) if it
    satisfies the equation:
        INTEGRAL[w(x)*f(x,n)*f(x,m)]dx = 0   m<>n, (m,n = 0, 1, 2, ...

    Jacobi polynomials use the weight function
          (1-x)**alpha*(1+x)**beta
    and are orthogonal for -1 <= x <= 1.

    DATAPLOT uses ACM algorithm 332 (see Reference section below) to
    calculate the Jacobi polynomials.  It incorporates the suggestions
    given in the Remark on Algorithm 332.

Syntax 1:
    LET <y> = JACOBIP(<x>,<n>,<a>,<b>) 
                               <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable in the range (-1,1);
          <n> is a non-negative integer number, parameter, or variable
              that specifies the order of the JACOBIP polynomial;
          <a> is a number, parameter, or variable that specifies the
              first shape parameter;
          <b> is a number, parameter, or variable that specifies the
              second shape parameter;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed Jacobi polynomial value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = JACOBIP(-0.5,4,2.5,3)
    LET X2 = JACOBIP(X1,10,0.5,B)
    LET X2 = JACOBIP(X1,N,A,B)
 
Note:
    The algorithm used computes Jacobi polynomials for orders 0 to 25.
    An error message is printed if the requested degree exceeds 25.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHEBT    = Compute the Chebychev polynomial first kind, order N.
    CHEBU    = Compute the Chebychev polynomial second kind, order N.
    HERMITE  = Compute the Hermite polynomial of order N.
    LAGUERRE = Compute the Laguerre polynomial of order N.
    ULTRASPH = Compute the ultrasperical polynomial of order N.
    LEGENDRE = Compute the Legendre polynomial of order N.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 22).
 
    "Algorithm 332: Jacobi Polynomials", Witte, Communication of the
    ACM, Vol. 11, June, 1968 (page 436).

    "Remark on Algorithm 332", Skivgaard, Communication of the
    ACM, Vol. 18, February, 1975 (pp. 116-117).

Applications:
    Mathematics
 
Implementation Date:
    95/7
 
Program:
    TITLE CASE ASIS; LABEL CASE ASIS
    LINE SOLID DASH DOT DASH2
    .
    TITLE Jacobi polynomials (order 1 thru 5)
    Y1LABEL Jn(X,a,b)
    X1LABEL X
    .
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    LET ALPHA = 1.5
    LET BETA = -0.5
    X2LABEL ALPHA = ^ALPHA, BETA = ^BETA
    PLOT JACOBIP(X,1,ALPHA,BETA) FOR X = -0.9 .01 0.9 AND
    PLOT JACOBIP(X,2,ALPHA,BETA) FOR X = -0.9 .01 0.9 AND
    PLOT JACOBIP(X,3,ALPHA,BETA) FOR X = -0.9 .01 0.9 AND
    PLOT JACOBIP(X,4,ALPHA,BETA) FOR X = -0.9 .01 0.9 AND
    PLOT JACOBIP(X,5,ALPHA,BETA) FOR X = -0.9 .01 0.9
    LET ALPHA = 0.5
    LET BETA = 0.5
    X2LABEL ALPHA = ^ALPHA, BETA = ^BETA
    PLOT JACOBIP(X,1,ALPHA,BETA) FOR X = -0.9 .01 0.9 AND
    PLOT JACOBIP(X,2,ALPHA,BETA) FOR X = -0.9 .01 0.9 AND
    PLOT JACOBIP(X,3,ALPHA,BETA) FOR X = -0.9 .01 0.9 AND
    PLOT JACOBIP(X,4,ALPHA,BETA) FOR X = -0.9 .01 0.9 AND
    PLOT JACOBIP(X,5,ALPHA,BETA) FOR X = -0.9 .01 0.9
    LET ALPHA = 2
    LET BETA = 3
    X2LABEL ALPHA = ^ALPHA, BETA = ^BETA
    PLOT JACOBIP(X,1,ALPHA,BETA) FOR X = -0.9 .01 0.9 AND
    PLOT JACOBIP(X,2,ALPHA,BETA) FOR X = -0.9 .01 0.9 AND
    PLOT JACOBIP(X,3,ALPHA,BETA) FOR X = -0.9 .01 0.9 AND
    PLOT JACOBIP(X,4,ALPHA,BETA) FOR X = -0.9 .01 0.9 AND
    PLOT JACOBIP(X,5,ALPHA,BETA) FOR X = -0.9 .01 0.9
    LET ALPHA = 10
    LET BETA = 0.5
    X2LABEL ALPHA = ^ALPHA, BETA = ^BETA
    PLOT JACOBIP(X,1,ALPHA,BETA) FOR X = -0.9 .01 0.9 AND
    PLOT JACOBIP(X,2,ALPHA,BETA) FOR X = -0.9 .01 0.9 AND
    PLOT JACOBIP(X,3,ALPHA,BETA) FOR X = -0.9 .01 0.9 AND
    PLOT JACOBIP(X,4,ALPHA,BETA) FOR X = -0.9 .01 0.9 AND
    PLOT JACOBIP(X,5,ALPHA,BETA) FOR X = -0.9 .01 0.9
    END OF MULTIPLOT
 
-----JARQUE BERA TEST------------------------------------
 
JARQUE BERA TEST
 
Name:
    JARQUE BERA TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform a Jarque-Bera test for normality.
 
Description:
    Most tests for normality are based either on comparing the empirical
    cumulative distribution with the theoretical normal cumulative
    distribution (Kolmogorov-Smirnov, Anderson-Darling, Chi-Square) or
    empirical quantiles with the theoretical normal quantiles (PPCC,
    Wilk-Shapiro).  In contrast, the Jarque-Bera test is based on the
    sample skewness and sample kurtosis.

    The Jarque-Bera test statistic is defined as:

        JB = (N/6)*(S**2 + (1/4)*(K - 3)**2)

    with S, K, and N denoting the sample skewness, the sample kurtosis,
    and the sample size, respectively.

    For sample sizes of 2,000 or larger, this test statistic is compared
    to a chi-squared distribution with 2 degrees of freedom (normality is
    rejected if the test statistic is greater than the chi-squared value).

    The chi-square approximation requires fairly large sample sizes to be
    accurate.  For sample sizes less than 2,000, the critical value is
    determined via simulation.  Specifically, one hundred thousand
    normal samples with the same mean and standard deviation as the
    original data sample are generated and the Jarque-Bera test statistic
    computed to generate the reference distribution.

Syntax 1:
    JARQUE BERA TEST   <y>      <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    MULTIPLE JARQUE BERA TEST  <y1>  ...  <yk>
                         <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of 1 to 30 response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 3:
    REPLICATED JARQUE BERA TEST  <y>  <x1> ...  <xk>
                         <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <x1> ... <xk> is a list of 1 to 6 group-id variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    JARQUE BERA TEST Y1
    JARQUE BERA TEST Y1   SUBSET TAG > 2
    MULTIPLE JARQUE BERA TEST Y1 TO Y10
    REPLICATED JARQUE BERA TEST Y X
 
Note:
    Syntax 1 and Syntax 2 support matrix arguments.  Syntax 2 supports the
    TO syntax.

    For Syntax 3 (the REPLICATED form), the variables must all have the
    same number of observations.

Note:
    The following statistics are also supported:

        LET A = JARQUE BERA TEST          Y
        LET A = JARQUE BERA TEST CDF      Y
        LET A = JARQUE BERA TEST PVALUE   Y

Default:
    None
 
Synonyms:
    JARQUE BERA NORMALITY TEST
    JARQUE BERA
 
Related Commands:
    GOODNESS OF FIT       = Perform Anderson-Darling, Kolmogorov-Smirnov,
                            Chi-Square, and PPCC goodness of fit tests.
    WILK SHAPIRO TEST     = Perform a Wilk Shapiro test for normality.
    PROBABILITY PLOT      = Generate a probability plot.
 
Reference:
    Brani Vidakovic (2011), "Statistics for Bioengineering Sciences: with
    MATLAB and WINBUGS Support," Springer, pp. 521-522.
 
Applications:
    Distributional Fitting, Assumption Testing
 
Implementation Date:
    2012/6
 
Program:
    SKIP 25
    READ ZARR13.DAT Y1
    READ ZARR15.DAT Y2
    SET WRITE DECIMALS 4
    MULTIPLE JARQUE BERA TEST Y1 Y2

-----JITTER (LET)-------------------------------------
 
JITTER
 
Name:
    JITTER (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Add a small bit of random noise to a variable.
 
Description:
    For certain types of plots, it can be useful to add a
    small bit of random noise to a variable to avoid
    overplotting.  This is commonly referred to as jittering.

    The sample program below shows an example of using the
    JITTER command to help generate a dot plot.

    To simplify this, the following commands can be entered:

           LET DELTA <value>
           LET Y = JITTER X DELTA

    The value of DELTA is used to control the magnitude of
    the jittering.  That is, the value of x(i) will be
    changed to a value x(i) + noise where noise is in the
    range (-DELTA/2,DELTA/2).

Syntax:
    LET <y> = JITTER <x>  <delta>
    where <x> is a response variable;
          <value> is a number or parameter that specifies the
              magnitude of the jittering;
    and   <y> is a variable where the jittered values are stored.
 
    If <delta> is omitted, a default value of 1 is used.

Examples:
    LET Y = JITTER X 0.1
    LET Y = JITTER X DELTA
 
Default:
    The default value of <delta> is 1.
 
Synonyms:
    None
 
Related Commands:
    LET         = Compute the cumulative hazard for a
                         variable.
    PLOT        = Generate a plot.
 
Applications:
    Data Analysis
 
Implementation Date:
    2007/2
 
Program:
    skip 25
    read tob50.dat x
    .
    let delta = 1.0
    let n = size x
    let y = 0 for i = 1 1 n
    let y = jitter y delta
    .
    yframe off
    x2frame off
    ylimits -0.5 0.5
    frame corner coordinates 15 40 85 60
    title offset 2
    title case asis
    title Dot Plot of Lifetime of Light Bulbs
    .
    char circle
    char fill on
    line blank
    .
    plot y x
 
-----JSBCDF (LET)--------------------------------
 
JSBCDF
 
Name:
    JSBCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Johnson SB cumulative distribution function with
    shape parameters alpha1 and alpha2.
 
Description:
    The Johnson SB distribution has the following cumulative
    distribution function:
       F(x) = NORCDF(ALPHA1 + ALPHA2*LOG(X/(1-X))
              0 < x < 1; alpha2 > 0
    where NORCDF is the cumulative distribution function of the
    standard normal distribution and alpha1 and alpha2 are
    shape parameters.
 
Syntax:
    LET <y> = JSBCDF(<x>,<alpha1>,<alpha2>)
                                  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable containing values
              between 0 and 1;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed Johnson SB cdf values are stored;
          <alpha1> is a number, parameter, or variable that specifies
              the first shape parameter;
          <alpha2> is a number, parameter, or variable that specifies
              the second shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = JSBCDF(2,0.3,2)
    LET A = JSBCDF(A1,1.5,3)
    LET Y = JSBCDF(X,2,6)
    PLOT JSBCDF(X,0.8,2) FOR X = -5 0.1 20
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    JSBPDF = Compute the Johnson SB probability density function.
    JSBPPF = Compute the Johnson SB percent point function.
    JSUPDF = Compute the Johnson SU probability density function.
    BETPDF = Compute the beta probability density function.
    NORPDF = Compute the normal probability density function.
    UNIPDF = Compute the uniform probability density function.
    LAMPDF = Compute the Tukey-Lambda probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, Wiley, 1994, pp. 33-39.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2001/11
 
Program:
    LET ALPHA1 = DATA 0.5 0.5 0.5 1 1 1 2 2 2
    LET ALPHA2 = DATA 0.5 1 2 0.5 1 2 0.5 1 2
    .
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LOOP FOR K = 1 1 9
       LET A1 = ALPHA1(K)
       LET A2 = ALPHA2(K)
       X1LABEL ALPHA1 = ^A1
       X2LABEL ALPHA2 = ^A2
       PLOT JSBCDF(X,A1,A2) FOR X = 0.01  0.01  0.99
    END OF LOOP
    END OF MULTIPLOT
 
-----JSBPDF (LET)--------------------------------
 
JSBPDF
 
Name:
    JSBPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Johnson SB probability density function with
    shape parameters alpha1 and alpha2.
 
Description:
    The Johnson SB distribution has the following probability
    density function:
       f(x) = [alpha2/(X*(1-X)]*NORPDF(ALPHA1 + ALPHA2*LOG(X/(1-X))
              0 < x < 1; alpha2 > 0
    where NORPDF is the probability density function of the
    standard normal distribution and alpha1 and alpha2 are
    shape parameters.
 
Syntax:
    LET <y> = JSBPDF(<x>,<alpha1>,<alpha2>)
                                  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable containing values
              between 0 and 1;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed Johnson SB pdf values are stored;
          <alpha1> is a number, parameter, or variable that specifies
              the first shape parameter;
          <alpha2> is a number, parameter, or variable that specifies
              the second shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = JSBPDF(2,0.3,2)
    LET A = JSBPDF(A1,1.5,3)
    LET Y = JSBPDF(X,2,6)
    PLOT JSBPDF(X,0.8,2) FOR X = -5 0.1 20
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    JSBCDF = Compute the Johnson SB cumulative distribution
             function.
    JSBPPF = Compute the Johnson SB percent point function.
    JSUPDF = Compute the Johnson SU probability density function.
    BETPDF = Compute the beta probability density function.
    NORPDF = Compute the normal probability density function.
    UNIPDF = Compute the uniform probability density function.
    LAMPDF = Compute the Tukey-Lambda probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, Wiley, 1994, pp. 33-39.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2001/11
 
Program:
    LET ALPHA1 = DATA 0.5 0.5 0.5 1 1 1 2 2 2
    LET ALPHA2 = DATA 0.5 1 2 0.5 1 2 0.5 1 2
    .
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LOOP FOR K = 1 1 9
       LET A1 = ALPHA1(K)
       LET A2 = ALPHA2(K)
       X1LABEL ALPHA1 = ^A1
       X2LABEL ALPHA2 = ^A2
       PLOT JSBPDF(X,A1,A2) FOR X = 0.01  0.01  0.99
    END OF LOOP
    END OF MULTIPLOT
 
-----JSBPPF (LET)--------------------------------
 
JSBPPF
 
Name:
    JSBPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Johnson SB percent point function with
    shape parameters alpha1 and alpha2.
 
Description:
    The Johnson SB distribution has the following probability
    density function:
       f(x) = [alpha2/(X*(1-X)]*NORPDF(ALPHA1 + ALPHA2*LOG(X/(1-X))
              0 < x < 1; alpha2 > 0
    where NORPDF is the percent point function of the
    standard normal distribution and alpha1 and alpha2 are
    shape parameters.
 
    The Johnson SB percent point function does not exist in
    simple closed form.  It is computed numerically using a
    bisection method.

Syntax:
    LET <y> = JSBPPF(<p>,<alpha1>,<alpha2>)
                                  <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or variable containing values
              between 0 and 1;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed Johnson SB ppf values are stored;
          <alpha1> is a number, parameter, or variable that specifies
              the first shape parameter;
          <alpha2> is a number, parameter, or variable that specifies
              the second shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = JSBPPF(0.95,0.5,2)
    LET A = JSBPPF(P1,1.5,3)
    LET Y = JSBPPF(P,2,6)
    PLOT JSBPPF(P,0.8,2) FOR P = 0.01 0.01 0.99
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    JSBCDF = Compute the Johnson SB cumulative distribution
             function.
    JSBPDF = Compute the Johnson SB probability density function.
    JSUPDF = Compute the Johnson SU probability density function.
    BETPDF = Compute the beta probability density function.
    NORPDF = Compute the normal probability density function.
    UNIPDF = Compute the uniform probability density function.
    LAMPDF = Compute the Tukey-Lambda probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, Wiley, 1994, pp. 33-39.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2001/11
 
Program:
    LET ALPHA1 = DATA 0.5 0.5 0.5 1 1 1 2 2 2
    LET ALPHA2 = DATA 0.5 1 2 0.5 1 2 0.5 1 2
    .
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LOOP FOR K = 1 1 9
       LET A1 = ALPHA1(K)
       LET A2 = ALPHA2(K)
       X1LABEL ALPHA1 = ^A1
       X2LABEL ALPHA2 = ^A2
       PLOT JSBPPF(P,A1,A2) FOR P = 0.01  0.01  0.99
    END OF LOOP
    END OF MULTIPLOT
 
-----JSCORE (LET)-----------------------------------------
 
JSCORE
 
Name:
    JSCORE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute a j-score from the z-score's for multiple rounds of data.
 
Description:
    The j-score is used in ISO 13528 proficiency studies.  One scenario for
    proficiency testing described in the ISO 13528 standard is for the case
    where there are multiple rounds of testing.  Given the proficiency data

         Z        - a variable containing the response data in z-score
                    units
         MATID    - a variable containing the material-id
         ROUNDID  - a variable containing the round-id
         LABID    - a variable containing the lab-id

    This command takes as input a response variable containing the z-score
    and a corresponding variable that identifies the round-id for each
    z-score.  Since the ISO 13528 standard contains several different
    options for computing z-scores from raw data, it is assumed that
    the response variable has already been converted to z-scores.

    There are two versions of this command.  One is used when there
    is a single material and the other is used for the case where
    there are multiple materials.  Each combination of material and
    round will be referred to as a cell.

    One j-score is computed for each cell.  For a given material,
    the j-score will be cumulative over the rounds.

    The j-score is computed as follows:

      1. If there is replication in the cell, the averages of the
         z-scores will be used as the z-score for that cell.

         Alternatively, you can request that the most extreme
         z-score in that cell be used rather than the average.

      2. An initial j-score for the cell is assigned as follows:

            z-score          j-score
            ========================
            +3 <= z            8
            +2 <= z <  +3      4
            +1 <= z <  +2      2
            -1 <= z <  +1      0
            -2 <  z <= -1     -2
            -3 <  z <= -2     -4
            -3 <= z           -8

      3. We will compute a final j-score for the cell and a
         cumulative j-score.  The cumulative j-score will be used
         with the initial j-score of the next round to compute
         the final j-score for the next round.

         To compute the final and cumulative j-scores for the round,
         do the following:

         a.  If the initial j-score for the round is 8, then set the final
             j-score for the round to 8 (if the cumulative j-score from the
             previous round is positive, then this is added to 8) and
             reset the cumulative j-score for the next round to 0.
 
             Likewise, if the j-score for the round is -8, then set the
             final j-score for the round to -8 (if the cumulative j-score
             from the previous round is negative, then this is added to
             -8) and reset the cumulative j-score for the next round to 0.

          b. If the j-score for the round is inside the (-8,+8) interval,
             then compare the signs of the cumulative j-score from the
             previous round to the j-score for the current round.

             If the signs are the same, then add the cumulative j-score
             from the previous round to the initial j-score for the
             round to obtain the final j-score for the round.  This
             will also be the cumulative j-score for the next round.

             If the signs are different, then set the final j-score for
             the round to initial j-score value.  However, set the
             cumulative j-score for the next round to 0.

    Although the j-score is not part of the 13528 standard, it has been
    recommended in analyzing 13528-based proficiency studies (see the
    Thompson and Jaehn references below).

    The j-score combines properties of both the mean control chart and
    the cusum control charts.  Specifically, it can detect both abrupt
    changes (i.e., j-scores for a given round > 8 or < -8) and drift
    in the result (i.e., several successive positive j-scores or
    several successive negative j-scores).

    The j-scores are typically used as a diagnostic to determine when a
    laboratory is producing results inconsistent with other laboratories
    in the proficiency study.  It is an alternative to the ISO 13528
    control charts.

Syntax 1:
    LET <y> = JSCORE <z> <roundid>    <SUBSET/EXCEPT/FOR qualification>
    where <z> is a response variable containing z-scores;
          <roundid> is a variable containing the round-id;
          <y> is a variable that contains the computed j-scores;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    The <z> and <roundid> variables should have the same length.  The
    length of the <y> variable is equal to the number of distinct values
    in the <roundid> variable.

    This syntax is used for the case of a single material and a single
    laboratory.  If the data has multiple materials and/or laboratories,
    the SUBSET command can be used to specify the specific material and
    laboratory.

    Since this syntax generates a vector of numbers rather than a
    parameter, it cannot be used in the 20+ commands that can use
    Dataplot's built-in statistics.

Syntax 2:
    LET <y> <rndout> <matout> = JSCORE <z> <roundid> <matid>
                                <SUBSET/EXCEPT/FOR qualification>
    where <z> is a response variable containing z-scores;
          <roundid> is a variable containing the round-id;
          <matid> is a variable containing the material-id;
          <y> is a variable that contains the computed j-scores;
          <rndout> is a variable that contains the round-id for the
              computed j-scores;
          <matout> is a variable that contains the material-id for the
              computed j-scores;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    The <z>, <roundid> and <matid> variables should have the same length.
    The length of the <y>, <rndout>, and <matout> variables is equal to
    the number of distinct values in the <roundid> variable times the
    number of distinct values in the <matid> variable minus the number
    of empty cells.

    This syntax is used for the case of multiple materials and a single
    laboratory.  If the data has multiple laboratories, the SUBSET command
    can be used to specify the specific laboratory.

    Since this syntax generates a vector of numbers rather than a
    parameter, it cannot be used in the 20+ commands that can use
    Dataplot's built-in statistics.

Syntax 3:
    LET <a> = JSCORE STATISTIC <z>    <SUBSET/EXCEPT/FOR qualification>
    where <z> is a response variable containing z-scores;
          <a> is a parameter that contains the computed j-score is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax assumes a single round, a single material, and a
    single laboratory.  It returns a single j-score as a parameter
    and can be used in the 20+ commands that can use Dataplot's built-in
    statistics.

    The word STATISTIC is required to distinguish this from Syntax 1.

    NOTE: Since the j-score is cumulative over rounds, this syntax is
          not particuarly useful.  It returns the initial j-score for
          the material/round cell.

Examples:
    LET Y = JSCORE  Z  ROUND
    LET Y = JSCORE  Z  ROUND  SUBSET LAB = 23 SUBSET MATERIAL = 3

    LET A = JSCORE  Z  SUBSET ROUND = 2 SUBSET LAB = 23 SUBSET MATERIAL = 3

Note:
    The ISO 13528 standard defines a number of methods for computing the
    z-scores (enter HELP ISO 13528 ZSCORE, HELP ISO 13528 ZPRIME SCORE,
    and HELP ISO 13528 ZETA SCORE for details).  For this reason, the
    JSCORE command does not automatically compute the z-scores from the
    original response data.

Note:
    The ISO 13528 JSCORE PLOT command can be used to plot j-scores.

Note:
    If there is replication within a cell, the default is to compute
    the average of the <i>z</i>-scores for that cell.  Alternatively,
    you can request that the most extreme <i>z</i>-score be used.

    To specify that the extreme value should be used, enter

         SET JSCORE REPLICATION EXTREME

    To specify that the average value should be used, enter

         SET JSCORE REPLICATION AVERAGE

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    STANDARDIZE              = Compute z-scores from raw data.
    ISO 13528 JSCORE PLOT    = Generate an ISO 13528 j-scores plot.
    ISO 13528 PLOT           = Generate an ISO 13528 plot.
    ISO 13528 CONTROL CHART  = Generate an ISO 13528 control chart.
    ISO 13528 ZSCORE         = Compute z-scores as defined in the
                               ISO 13528 standard.
    ISO 13528 ZPRIME SCORE   = Compute z-prime scores as defined in the
                               ISO 13528 standard.
    ISO 13528 ZETA SCORE     = Compute zeta scores as defined in the
                               ISO 13528 standard.
 
References:
    ISO 13528, First Edition, Statistical Methods for Use
    in Proficiency Testing by Interlaboratory Comparisons,
    2005, pp. 25-26.

    Thompson, M., Ellison, S.L.R. and R. Wood (2006), "The International
    Harmonized Protocol for the Proficiency Testing of Analytical Chemistry
    Laboratories (IUPAC Technical Report)," Pure and Applied Chemistry,
    Vol. 78, 145-196.

    Jaehn, A.H. (1991), "The Zone Conrol Chart," Quality Progess, 24,
    65-68.

    Howarth, Richard J. (2003), "The J-chart: a simple plot that
    combines the capabilities of Shewart and cusum charts, for use
    in analytical quality control," AMC Technical Brief,
    Royal Society of Chemistry, No. 12.

Applications:
    ISO 13528 Multiple Round Proficiency Standards
 
Implementation Date:
    2015/01:

Program:
    . Step 1:   Read the data.  Note that this data set only has the
    .           data for a single year.  Plot in the format shown in
    .           the Howarth paper.
    .
    dimension 40 columns
    skip 25
    read allergen.dat z labid matid year quarter
    skip 0
    let denom = 4
    let tempid = (quarter-1)/denom
    let roundid = year + tempid
    set write decimals 3
    .
    . Step 2:   Demonstrate Syntax 2
    .
    let jscore rndout matout = jscore table z roundid  matid
    capture screen on
    capture JSCORE2.OUT
    print rndout matout z jscore
    end of capture
    .
    . Step 3:   Plot jscore statistic - set plot control setting
    .
    case asis
    label case asis
    title case asis
    title offset 2
    .
    line blank all
    .
    y1label Material
    ylimits -8 8
    major ytic mark number 9
    minor ytic mark number 0
    tic mark offset units data
    y1tic mark offset 2 2
    ygrid on
    grid pattern dotted
    x1label Round
    x1label displacement 12
    .
    multiplot scale factor 2
    multiplot corner coordinates 5 5 95 95
    multiplot 2 2
    .
    let jscore = 8  subset jscore > 8
    let jscore = -8 subset jscore < -8
    .
    let nmat = unique matid
    loop for k = 1 1 nmat
        title Material ^k
        let j2 = jscore
        let r2 = rndout
        let j2b = j2 + 0.8  subset z >= 0
        let j2b = j2 - 0.8  subset z <  0
        retain j2 j2b r2    subset matid = ^k
        let tag = code j2
        let jtemp = distinct j2
        let jtemp = sort jtemp
        character automatic jtemp
        plot j2b r2 tag
    end of loop
    end of multiplot
    .
    justification center
    move 50 97
    text Plot of J-Scores for ALLERGREN.DAT
 
-----JSUCDF (LET)--------------------------------
 
JSUCDF
 
Name:
    JSUCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Johnson SU cumulative distribution function with
    shape parameters alpha1 and alpha2.
 
Description:
    The Johnson SU distribution has the following cumulative
    distribution function:
       F(x) = NORCDF(ALPHA1 + ALPHA2*LOG(X + SQRT(X**2 + 1)))
              -infinity < x < infinity; alpha2 > 0
    where NORCDF is the cumulative distribution function of the
    standard normal distribution and alpha1 and alpha2 are
    shape parameters.
 
Syntax:
    LET <y> = JSUCDF(<x>,<alpha1>,<alpha2>)
                                  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed Johnson SU cdf values are stored;
          <alpha1> is a number, parameter, or variable that specifies
              the first shape parameter;
          <alpha2> is a number, parameter, or variable that specifies
              the second shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = JSUCDF(0.3,2)
    LET A = JSUCDF(A1,1.5,3)
    LET Y = JSUCDF(X,2,6)
    PLOT JSUCDF(X,0.8,2) FOR X = -5 0.1 20
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    JSUPDF = Compute the Johnson SU probability density function.
    JSUPPF = Compute the Johnson SU percent point function.
    JSBPDF = Compute the Johnson SB probability density function.
    BETPDF = Compute the beta probability density function.
    NORPDF = Compute the normal probability density function.
    UNIPDF = Compute the uniform probability density function.
    LAMPDF = Compute the Tukey-Lambda probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, Wiley, 1994, pp. 33-39.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2001/11
 
Program:
    LET ALPHA1 = DATA 0.5 0.5 0.5 1 1 1 2 2 2
    LET ALPHA2 = DATA 0.5 1 2 0.5 1 2 0.5 1 2
    .
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LOOP FOR K = 1 1 9
       LET A1 = ALPHA1(K)
       LET A2 = ALPHA2(K)
       X1LABEL ALPHA1 = ^A1
       X2LABEL ALPHA2 = ^A2
       PLOT JSUCDF(X,A1,A2) FOR X = -10  0.1  10
    END OF LOOP
    END OF MULTIPLOT
 
-----JSUPDF (LET)--------------------------------
 
JSUPDF
 
Name:
    JSUPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Johnson SU probability density function with
    shape parameters alpha1 and alpha2.
 
Description:
    The Johnson SU distribution has the following probability
    density function:
       f(x) = [alpha2/SQRT(X**2+1)]*NORPDF(ALPHA1 +
              ALPHA2*LOG(X + SQRT(X**2 + 1)))
              -infinity < x < infinity; alpha2 > 0
    where NORPDF is the probability density function of the
    standard normal distribution and alpha1 and alpha2 are
    shape parameters.
 
Syntax:
    LET <y> = JSUPDF(<x>,<alpha1>,<alpha2>)
                                  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed Johnson SU pdf values are stored;
          <alpha1> is a number, parameter, or variable that specifies
              the first shape parameter;
          <alpha2> is a number, parameter, or variable that specifies
              the second shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = JSUPDF(2,0.3,2)
    LET A = JSUPDF(A1,1.5,3)
    LET Y = JSUPDF(X,2,6)
    PLOT JSUPDF(X,0.8,2) FOR X = -5 0.1 20
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    JSUCDF = Compute the Johnson SU cumulative distribution
             function.
    JSUPPF = Compute the Johnson SU percent point function.
    JSBPDF = Compute the Johnson SB probability density function.
    BETPDF = Compute the beta probability density function.
    NORPDF = Compute the normal probability density function.
    UNIPDF = Compute the uniform probability density function.
    LAMPDF = Compute the Tukey-Lambda probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, Wiley, 1994, pp. 33-39.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2001/11
 
Program:
    LET ALPHA1 = DATA 0.5 0.5 0.5 1 1 1 2 2 2
    LET ALPHA2 = DATA 0.5 1 2 0.5 1 2 0.5 1 2
    .
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LOOP FOR K = 1 1 9
       LET A1 = ALPHA1(K)
       LET A2 = ALPHA2(K)
       X1LABEL ALPHA1 = ^A1
       X2LABEL ALPHA2 = ^A2
       PLOT JSUPDF(X,A1,A2) FOR X = -10  0.1  10
    END OF LOOP
    END OF MULTIPLOT
 
-----JSUPPF (LET)--------------------------------
 
JSUPPF
 
Name:
    JSUPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Johnson SU percent point function with
    shape parameters alpha1 and alpha2.
 
Description:
    The Johnson SU distribution has the following percent point
    function:

       G(p;alpha1,alpha2) = SINH[(NORPPF(p) - alpha1)/alpha2]
              0 < p < 1; alpha2 > 0

    with SINH, NORPPF, alpha1, and alpha2 denoting the hyperbolic
    sine function, the percent point function of the standard
    normal distribution, and the two shape parameters, respectively.

Syntax:
    LET <y> = JSUPPF(<p>,<alpha1>,<alpha2>)
                                  <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or variable containing values
              between 0 and 1;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed Johnson SU ppf values are stored;
          <alpha1> is a number, parameter, or variable that specifies
              the first shape parameter;
          <alpha2> is a number, parameter, or variable that specifies
              the second shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = JSUPPF(0.95,0.3,2)
    LET A = JSUPPF(P1,1.5,3)
    LET Y = JSUPPF(P,2,6)
    PLOT JSUPPF(P,0.8,2) FOR P = 0.01 0.01 0.99
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    JSUCDF = Compute the Johnson SU cumulative distribution
             function.
    JSUPDF = Compute the Johnson SU probability density function.
    JSBPDF = Compute the Johnson SB probability density function.
    BETPDF = Compute the beta probability density function.
    NORPDF = Compute the normal probability density function.
    UNIPDF = Compute the uniform probability density function.
    LAMPDF = Compute the Tukey-Lambda probability density function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, Wiley, 1994, pp. 33-39.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2001/11
 
Program:
    LET ALPHA1 = DATA 0.5 0.5 0.5 1 1 1 2 2 2
    LET ALPHA2 = DATA 0.5 1 2 0.5 1 2 0.5 1 2
    .
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LOOP FOR K = 1 1 9
       LET A1 = ALPHA1(K)
       LET A2 = ALPHA2(K)
       X1LABEL ALPHA1 = ^A1
       X2LABEL ALPHA2 = ^A2
       PLOT JSUPPF(P,A1,A2) FOR P = 0.01  0.01  0.99
    END OF LOOP
    END OF MULTIPLOT
 
-----JULIA (LET)---------------------------------------------------
 
JULIA
 
Name:
    JULIA (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Determine whether a series of one or more points in the complex
    plane belong to a given Julia set.
 
Description:
    Julia sets are derived from the following quadratic function:
         Qc(z) = z**2 + c
    where both z and c are complex numbers (z = x + iy and c =c1 +
    ic2).  For a given point z, this function reduces to:
         Qc(Z) = (x**2 - y**2 + c1) + (2xy + c2)i
    For a given point z, this function is iterated repeatedly (i.e.,
    Qc(z) is calculated and the new complex point is feed into Qc(z)
    again).  For a given value of c and an initial starting point, this
    iteration either escapes to infinity (in which case the point is
    said to belong to the escape set of c) or becomes bounded (the
    point belongs to the prisoner set).  The Julia set is defined to be
    the points on the boundary of the escape and prisoner sets.
 
    DATAPLOT returns the number of iterations it takes the point to
    escape to infinity (defined as value with an absolute value >
    10**6).  DATAPLOT terminates the iterations at 100 if the point has
    not escaped.  A plot can be made of the Julia set from these counts
    (i.e., plot the point if the count is less than 100).  This in fact
    plots the prisoner set (the Julia set is the boundary of this
    plot).
 
Syntax:
    LET <count> = JULIA(<x0>,<y0>,<c1>,<c2>)
                    <SUBSET/EXCEPT/FOR qualification>
    where <count> is a parameter or variable where the number of
               iterations calculated for the given point (terminates at
               100) is saved;
          <x0> is a parameter or variable which contains the real
               component of the point;
          <y0> is a parameter or variable which contains the complex
               component of the point;
          <c1> is a parameter or variable which contains the real
               component of the c parameter;
          <c2> is a parameter or variable which contains the complex
               component of the c parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y1 = JULIA (Z1,Z2,C1,C2)
 
Note:
    The program example shows how to generate a plot for a given Julia
    set.  Different sets can be plotted by entering different values
    for the c parameter (i.e., change CREAL and CCOMPLEX in the
    program).  Also, you can zoom-in on the plot by generating the
    plot over a restricted range (and using a finer increment between
    successive points).
 
Note:
    Julia plots can be generated with non-quadratic functions.  This is
    an area for future enhancement in DATAPLOT.  However, the current
    implementation is limited to quadratic functions.  Also, there are
    alternate algorithms that plot the border points (i.e., the actual
    Julia set) rather than the prisoner set.  This is another area for
    future enhancement.
 
Note:
    The appearance of the Julia plot can be controlled by the settings
    for the CHARACTER command.  For example, you can set the size and
    specify whether the character is filled.  Also, you can change
    the characteristics based on the count.  The mechanism for doing
    this is demonstrated in the program example (the creation of the
    TAG variable).  The most common option is to plot points with the
    same tag value in the same color.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CANTOR NUMBERS = Generate a sequence of Cantor numbers.
    FRACTAL PLOT   = Generate a fractal plot.
    PLOT           = Generates a data or function plot.
 
Reference:
    "Chaos, Fractals, and Dynamics", Robert Devanney, Addison-Wesley,
    1990 (chapters 5 and 6).
 
Applications:
    Chaos, fractals
 
Implementation Date:
    93/7 (earlier versions have a bug in the algorithm)
 
Program:
    .  NOTE: FOR GREATER RESOLUTION, SPLIT THE PLOT INTO 4 PORTIONS.
    LET CREAL = -1
    LET CCOMPLEX = 0
    .
    LET XFIRST = DATA -2 0 -2 0
    LET YFIRST = DATA 0 0 -2 -2
    ERASE
    PRE-ERASE OFF
    XLIMITS -2 2
    YLIMITS -2 2
    .
    LET INC = .02
    LET C1 = CREAL FOR I = 1 1 10000
    LET C2 = CCOMPLEX FOR I = 1 1 10000
    CHARACTER CIRCLE BL BL BL BL BL BL BL BL BL
    CHARACTER SIZE 0.1
    . CHARACTER JUSTIFICATION LEBO ALL
    LINE BLANK ALL
    X1LABEL REAL COMPONENT
    Y1LABEL COMPLEX COMPONENT
    TITLE JULIA SET OF Z**2 - 1
    .
    FEEDBACK OFF
    LOOP FOR K = 1 1 4
        LET TEMP1 = XFIRST(K)
        LET TEMP2 = TEMP1 + 2 - INC
        LET X0 = SEQUENCE TEMP1 INC TEMP2 FOR I = 1 1 10000
        LET TEMP1 = YFIRST(K)
        LET TEMP2 = TEMP1 + 2 - INC
        LET Y0 = SEQUENCE TEMP1 100 INC TEMP2
        LET COUNT = JULIA(X0,Y0,C1,C2)
        LET TAG = INT(COUNT/10) + 1
        LET TAG = 0 SUBSET TAG >= 11
        PLOT Y0 X0 TAG SUBSET TAG = 0
    END OF LOOP
 
-----JUSTIFICATION-----------------------------------------------------
 
JUSTIFICATION
 
Name:
    JUSTIFICATION
 
Type:
    Diagrammatic Justification Command
 
Purpose:
    Specifies the justification of script (resulting from the TEXT
    command) to appear on diagrams.
 
Description:
    The following justifications are allowed:
      LEFT   = left horizontally, bottom vertically
      CENTER = center horizontally, bottom vertically
      RIGHT  = right horizontally, bottom vertically
      LECE   = left horizontally, center vertically
      CECE   = center horizontally, center vertically
      RICE   = right horizontally, center vertically
      LETO   = left horizontally, top vertically
      CETO   = center horizontally, top vertically
      RITO   = right horizontally, top vertically
 
Syntax:
    JUSTIFICATION   <just>
    where <just> is one of the 9 values given above.
 
Examples:
    JUSTIFICATION LEFT
    JUSTIFICATION CENTER
    JUSTIFICATION RIGHT
 
Note:
    The JUSTIFICATION command with no arguments reverts the
    justification to default.
 
Default:
    The default justification is left.
 
Synonyms:
    LJUS and LEBO for LEFT.
    CJUS and CEBO for CENTER.
    RJUS and RIBO for RIGHT.
 
Related Commands:
    TEXT               = Writes a text string.
    TITLE SIZE         = Sets the height of the plot title.
    LABEL SIZE         = Sets the height of the plot labels.
    LEGEND SIZE        = Sets the height of the plot legends.
    TIC LABEL SIZE     = Sets the height of the plot tic mark labels.
    HEIGHT             = Sets the height for TEXT characters.
    WIDTH              = Sets the width for TEXT characters.
    HW                 = Sets the height and width for TEXT characters.
    VERTICAL SPACING   = Sets the vertical spacing between text lines.
    HORIZONTAL SPACING = Sets the horizontal spacing between text
                         characters.
    FONT               = Sets the font for TEXT characters.
    CASE               = Sets the case for TEXT characters.
    THICKNESS          = Sets the thickness of TEXT characters.
    COLOR              = Sets the color for TEXT characters.
    JUSTIFICATION      = Sets the justification for TEXT characters.
    CR                 = Sets the carriage return position after text.
    LF                 = Sets the line feed position after text.
    CRLF               = Sets the carriage return/line feed position
                         after text.
    MARGIN             = Sets the carriage return column after text.
    ()                 = Allows math and Greek characters in text.
    MOVE               = Moves to a point.
    CROSS-HAIR (or CH) = Activates and reads the cross-hair.
    ERASE              = Erases the screen (immediately).
    COPY               = Copies the screen (immediately).
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    VERTICAL SPACING 6
    CRLF ON
    MARGIN 50
    FONT DUPLEX
    .
    JUSTIFICATION LEFT
    HW 4 2
    MOVE 5 95
    TEXT JAPAN's 6-POINT PROGRAM FOR
    MOVE 5 89
    TEXT QUALITY MANUFACTURING
    MOVE 10 80
    HW 2.2 1.1
    JUSTIFICATION CENTER
    TEXT QUALITY AUDITS
    TEXT COMPANY-WIDE QUALITY CONTROL (CWQC)
    TEXT QUALITY TRAINING AND EDUCATION
    TEXT APPLICATION OF STATISTICAL METHODS
    TEXT QUALITY CIRCLE ACTIVITIES
    TEXT NATION-WIDE QUALITY CONTROL PROMOTIONAL ACTIVITIES
    JUSTIFICATION RIGHT
    HW 2 1
    MOVE 95 10
    TEXT SOURCE: Q.C. TRENDS WINTER 1985, PAGES 22-23.
 
-------------------------------------------------------------
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 




















































































-------------------------  *K*  ZZZZZ--------------------

-----K0INT (LET)--------------------------------

K0INT

Name:
   K0INT (LET)
 
Type:
    Library Function

Purpose:
    This program computes the integral of the modified Bessel
    function of the third kind K0(x).

Description:
    The K0INT function is defined as:

        K0INT(x) = {integral 0 to x} K0(t) dt    x >= 0

    with K0 denoting the modified Bessel function of the third
    kind of order 0.

    Dataplot computes this function using ACM Algorithm 757 (see
    Reference: below).  The function is computed using Chebyshev
    expansions, the coefficients of which are given to 20 decimal
    places.

Syntax:
    LET <y> = K0INT(<x>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative number, variable or parameter;
          <y> is a variable or a parameter (depending on what <x> 
               is) where the computed K0INT function values are
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = K0INT(2.3)
    PLOT K0INT(X) FOR  X = 0 .01 10
    LET X2 = K0INT(X1) FOR X1 = 0.1 0.1 3.0
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BESSKN     = Compute the modified Bessel function of the third
                 kind and order N.
    BESSIN     = Compute the modified Bessel function of the first
                 kind and order N.
    BESSJN     = Compute the Bessel function of the first kind and
                 order N.
    BESSYN     = Compute the Bessel function of the second kind and
                 order N.
    I0INT      = Compute the integral of the modified Bessel
                 function of the first kind and order 0.
    J0INT      = Compute the integral of the Bessel function of
                 the first kind and order 0.
    Y0INT      = Compute the integral of the Bessel function of
                 the second kind and order 0.

Reference:
    "ACM Transactions of Mathematical Software", Allan MacLead,
    Vol. 22, No. 3, September, 1996, pp. 288-301.
 
Applications:
    Special Functions
 
Implementation Date:
    2005/11
 
Program:
    TITLE K0INT FUNCTION
    PLOT K0INT(X) FOR X = 0 0.01 10
 
-----KAPCDF (LET)--------------------------------
 
KAPCDF
 
Name:
    KAPCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the kappa cumulative distribution function with shape
    parameters h and k.
 
Description:
    The general form of the kappa distribution has the
    following probability density function:

       F(x;k,h,xi,alpha) = [1-h*[1-k*(x-xi)/alpha]**(1/k)]**(1/h)
                           alpha > 0

    with k and h denoting the shape parameters and xi and
    alpha denoting the location and scale parameters,
    respectively.

    The upper bound of x is

       x < xi + alpha*(1 - h**(-k)       if k >  0
       x < infinity                      if k <= 0

    The lower bound of x is

       x > xi + alpha*(1 - h**(-k))/k    if h >  0
       x > xi alpha/k                    if h <= 0, k <  0
       x > -infinity                     if h <= 0, k >= 0

    The standard form of the distribution is defined as
    xi = 0 and alpha = 1.

Syntax:
    LET <y> = KAPCDF(<x>,<k>,<h>,<xi>,<alpha>)
                             <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <k> is a number, parameter, or variable that specifies the
              first shape parameter;
          <h> is a number, parameter, or variable that specifies
              the second shape parameter;
          <xi> is a number, parameter, or variable that specifies the
              location parameter;
          <alpha> is a number, parameter, or variable that specifies
              the scale parameter;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed kappa cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The <xi> and <alpha> parameters are optional.

Examples:
    LET A = KAPCDF(3,0.5,2,0,1.5)
    LET X2 = KAPCDF(X1,K,H)

Note:
    Dataplot uses Hoskings CDFKAP routine to compute the kappa
    cumulative distribution function.  Hoskings report and
    associated Fortran code can be downloaded from the Statlib
    archive at

        http://lib.stat.cmu.edu/

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    KAPPDF = Compute the kappa probability density function.
    KAPPPF = Compute the kappa percent point function.
    MIEPDF = Compute Miekle's beta-kappa probability density
             function.
    GEVPDF = Compute the generalized extreme value probability
             density function.
    GEPPDF = Compute the generalized Pareto probability density
             function.
    GL5PDF = Compute the Hosking's generalized logistic probability
             density function.
 
Reference:
    Hosking and Wallis (1997), "Regional Frequency Analysis",
    Cambridge University Press, Appendix A10.

    J. R. M. Hosking (2000), "Research Report: Fortran Routines for
    use with the Method of L-Moments", IBM Research Division, T. J.
    Watson Research Center, Yorktown Heights, NY 10598.

    Hoskings (1990), "L-moments: Analysis and Estimation of
    Distribution using Linear Combinations of Order Statistics",
    Journal of the Royal Statistical Society, Series B, 52,
    pp. 105-124.

Applications:
    Distributional Modeling
 
Implementation Date:
    2008/5
 
Program 1:
    LET KP = DATA -0.5  0.1  0.5  1.0
    LET H1 = -0.5
    LET H2 = 0.1
    LET H3 = 1
    LET H4 = 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 95 95
    MULTIPLOT SCALE FACTOR 2
    TITLE CASE ASIS
    TITLE OFFSET 2
    X3LABEL
    LINE COLOR BLACK RED BLUE GREEN
    .
    LOOP FOR KK = 1 1 4
       LET K = KP(KK)
       LET LL1 = KAPPPF(0.05,K,H1)
       LET UL1 = KAPPPF(0.95,K,H1)
       LET LL2 = KAPPPF(0.05,K,H2)
       LET UL2 = KAPPPF(0.95,K,H2)
       LET LL3 = KAPPPF(0.05,K,H3)
       LET UL3 = KAPPPF(0.95,K,H3)
       LET LL4 = KAPPPF(0.05,K,H4)
       LET UL4 = KAPPPF(0.95,K,H4)
       TITLE K = ^K, H = -0.5, 0.1, 1, 2
       PLOT KAPCDF(X,K,H1) FOR X = LL1  0.01  UL1  AND
       PLOT KAPCDF(X,K,H2) FOR X = LL3  0.01  UL2  AND
       PLOT KAPCDF(X,K,H3) FOR X = LL3  0.01  UL3  AND
       PLOT KAPCDF(X,K,H4) FOR X = LL4  0.01  UL4
    END OF LOOP
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Kappa CDF Functions
 
-----KAPLAN MEIER PLOT--------------------------------------
 
KAPLAN MEIER PLOT
 
Name:
    KAPLAN MEIER PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a Kaplan Meier plot.
 
Description:
    In reliability analysis, many data sets consists of a set of
    failure times, which may be truncated at some limit value. 
    The cumulative distribution function (CDF) is defined
    as:
       F(t) = prob(T < t)
    where T is the lifetime of a randomly selected unit.
 
    Given n units, which are ordered from smallest to largest,
    t(1), t(2), ... ,t(n) where t(i) can represent either a 
    failure time or a censoring time (i.e., the unit was removed
    from the test before failing), then the Kaplan Meier estimates
    are given by:

                       i
       Rhat(t(i)) = PRODUCT[(n-j)/(n-j+1)]
                      j=1
                    j element of S

    where S is the set of all subscripts j such that t(j) is a
    failure time (i.e., S excludes the censoring times).  That is,
    for index i, the product is for all indices less than or equal
    to i that represent actual failure times.

    The Kaplan-Meier plot is a plot of Rhat(t(i)) versus the
    failure time.

    Once Rhat is computed, then the CDF estimates are

       F(t(i)) = 1 - R(t(i))

    That is, the Kaplan-Meier estimates are a way to estimate
    the CDF function when you have censored data.

    The Kaplan-Meier estimate of the last failure time is zero,
    which results in a CDF value of 1.  Since the reliability
    (= 1 - CDF) for standard reliability models asymptotically
    approaches 1 as time approaches infinity, a modified
    Kaplan-Meier estimate has been developed:

                                         i
       Rhat(t(i)) = [(n+0.7)/(n+0.4)] PRODUCT[(n-j)/(n-j+1)]
                                        j=1
                                   j element of S

    Generally, the modified form of the Kaplan-Meier plot is
    preferred.

    The Kaplan-Meier plot can be thought of as an alternative
    to the empirical CDF plot that can handle data with both
    failure and censoring times.

    In Dataplot, a tag variable identifies whether the
    corresponding points in the response variable represent
    failure times or censoring times.  A value of 1 indicates a
    failure time and a value of 0 indicates a censoring time.

Syntax 1:
    KAPLAN MEIER PLOT <y> <tag>    <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable containing failure times;
          <tag> is a tag variable indicating whether the times
              in <y> are failure times or censoring times;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax plots the unmodified Kaplan-Meier estimates.

Syntax 2:
    MODIFIED KAPLAN MEIER PLOT <y> <tag>
                                   <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable containing failure times;
          <tag> is a tag variable indicating whether the times
              in <y> are failure times or censoring times;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax plots the modified Kaplan-Meier estimates.

Examples:
    KAPLAN MEIER PLOT Y1 CENSOR
    MODIFIED KAPLAN MEIER PLOT Y1 CENSOR
 
Note:
    By default, the vertical axis of the Kaplan-Meier plot
    represents reliability (or survival).  Some analysts prefer
    to plot the CDF on the vertical axis (i.e., 1 - Rhat).

    Enter the following command to plot 1 - Rhat:

        SET KAPLAN MEIER CDF

    Enter the following command to reset the default (plot Rhat):

        SET KAPLAN MEIER RELIABILITY

Note:
    If you want the numeric values of the Kaplan-Meier estimates,
    do the following:

       MODIFIED KAPLAN-MEIER PLOT Y CENSOR
       LET RELI = YPLOT
       LET FAILTIME = XPLOT

    The variables RELI and FAILTIME can then be used in subsequent
    analysis and output.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LINES              = Sets the type for plot lines.
    CHARACTERS         = Sets the type for plot characters.
    EMPIRICAL CDF PLOT = Generates an empirical cdf plot.
    TAIL AREA PLOT     = Generates a tail area plot.
    ... HAZARD PLOT    = Generates a hazard plot.
    PROBABILITY PLOT   = Generates a probability plot.
    PLOT               = Generates a data or function plot.
 
Applications:
    Reliability
 
Implementation Date:
    1998/8
 
Program:
    SKIP 25
    READ HAHN.DAT MILES TAG
    TITLE MODIFIED KAPLAN MEIER PLOT OF HAHN.DAT
    Y1LABEL SURVIVAL
    X1LABEL FAILURE TIME
    XLIMITS 0 150000
    MODIFIED KAPLAN MEIER PLOT MILES TAG
 
-----KAPPENMAN R (LET)-----------------------------------------
 
KAPPENMAN R
 
Name:
    KAPPENMAN R (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute Kappenman's R statistic for distinguishing between a lognormal
    and a Weibull distribution.
 
Description:
    The lognormal and Weibull distributions are frequently used in
    reliability applications.  In many cases, both distributions may
    provide a reasonable distributional model.  However, these
    distributions exhibit different behaviour for the percentiles in both
    the lower and upper tails of the distribution.  For this reason, it
    is useful to be able to distinguish between these models.  In some
    cases, particularly for smaller samples, this can be difficult.

    The Kappenman's R statistic provides a test for distinguishing the
    lognormal model from the Weibull model.  The test statistic is
    defined as

        r = (A3 - A2)/(A2 - A1)

    where

        A1 = the average of the lower 5% of the ordered logarithms
             of the data
        A3 = the average of the upper 5% of the ordered logarithms
             of the data
        A2 = the average of the ordered logarithms of the data after
             trimming the lower 20% and upper 20% of the data

    This test statistic is compared to the value 0.7477.  If the test
    statistic is greater than this value, we choose the lognormal
    distribution.  Otherwise we choose the Weibull distribution.

    The references listed below provide the justification for this
    statistic.

Syntax 1:
    LET <a> = KAPPENMAN R <y>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <a> is a parameter where the computed statistic is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    LET <a> = KAPPENMAN R CUTOFF <y>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <a> is a parameter where the computed statistic is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This command returns the cutoff value for Kappenman's statistic.
    Currently, this always returns 0.7477.
 
Examples:
    LET A = KAPPENMAN R Y1
    LET CV = KAPPENMAN R CUTOFF Y1
 
Note:
    This statistic currently requires a minimum sample size of 20.

Note:
    The DISTRIBUTIONAL LIKELIHOOD RATIO TEST provides an alternative test
    for the lognormal and Weibull distributions.

    Kappenman's R is formulated as a selection problem with no preference
    for either the lognormal or the Weibull.  On the other hand, the
    likelihood ratio test is formulated as a hypothesis test and tends
    to favor the distribution that is given as the null hypothesis.

    Neither test says anything about whether the lognormal or Weibull
    provides an adequate distributional model.  They just answer the
    question about which of the two models is better.  For that reason,
    whichever model is selected should still be examined for model
    adequacy (e.g., goodness of fit tests and probability plots).

Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DIST LIKE RATIO TEST     = Perform a distributional likelihood ratio
                               test.
    MAXIMUM LIKELIHOOD       = Computes maximum likelihood estimates for
                               distributional fits.
    GOODNESS OF FIT          = Performs Kolmogorov-Smirnov,
                               Anderson-Darling, chi-square, and PPCC
                               goodness of fit tests.
    BEST DISTRIBUTIONAL FIT  = Ranks distributional fits for many common
                               distributions.
    PROBABILITY PLOT         = Generates a probability plot.
 
Reference:
    Kappenman (1988), "A Simple Method for Choosing Between the Lognormal
    and Weibull Models", Statistics & Probability Letters", Vol. 7,
    No. 2, pp. 123-126.

    McCool (2012), "Using the Weibull Distribution: Reliability, Modeling,
    and Inference", Wiley, pp. 207-210.

    Dumonceaux and Antle (1973), "Discrimination Between the Log-Normal
    and Weibull Distributions", Technometrics, Vol. 15, No. 4,
    pp. 923-926.

Applications:
    Distributional Modeling
 
Implementation Date:
    2014/05
 
Program 1:
    . Step 1:   Create the data for the example on page 925 of the
    .           Dumonceaux and Antle Technometrics paper
    .
    serial read y
     17.88  28.92  33.00  41.52  42.12  45.60
     48.48  51.84  51.96  54.12  55.56  67.80
     68.64  68.64  68.88  84.12  93.12  98.64
    105.12 105.84 127.92 128.04 173.40
    end of data
    .
    . Step 2:   Perform Test
    .
    set write decimals 4
    let r = kappenman r y
    let r = round(r,4)
    print "Kappenman R = ^r (cutoff = 0.7477)"
 
Program 2:
    . Step 1:   Read data from p. 209 of McCool.
    .
    serial read y
    1.4171126 2.8473605 3.1387760 3.6917256 3.9947116 4.5138741
    2.4294320 2.8856396 3.1792441 3.7922064 4.2446643 4.615145
    2.5617789 3.0469363 3.3558955 3.8552721 4.2881964 4.9614991
    2.6524817 3.0654405 3.5946731 3.8881352 4.2953750 5.5373569
    2.8297682 3.1045878 3.6295689 3.9605876 4.4814342 5.7385071
    end of data
    .
    let y = exp(y)
    .
    let kappr = kappenman r y
    let kapcv = kappenman r cutoff y
    .
    let kappr = round(kappr,4)
    print "Kappenman R = ^kappr (cutoff = ^kapcv)"
 
-----KAPPDF (LET)--------------------------------
 
KAPPDF
 
Name:
    KAPPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the kappa probability density function with shape
    parameters h and k.
 
Description:
    The general form of the kappa distribution has the
    following probability density function:

       f(x;k,h,xi,alpha) =
              (1/alpha)*[1 - k*(x-xi)/alpha]**((1/k)-1)*
              [F(x;k,h,xi,alpha)]**(1-h)
              alpha > 0

    with k and h denoting the shape parameters and xi and
    alpha denoting the location and scale parameters,
    respectively, and where F is the kappa cumulative distribution
    function (enter HELP KAPCDF for details).

    The upper bound of x is

       x < xi + alpha*(1 - h**(-k)       if k >  0
       x < infinity                      if k <= 0

    The lower bound of x is

       x > xi + alpha*(1 - h**(-k))/k    if h >  0
       x > xi alpha/k                    if h <= 0, k <  0
       x > -infinity                     if h <= 0, k >= 0

    The standard form of the distribution is defined as
    xi = 0 and alpha = 1.

    The cases h = -1, h = 0, and h = 1 reduce to the Hosking
    generalized logistic distribution, the generalized extreme
    value distribution, and the generalized Pareto distribution,
    respectively.  According to Hosking and Wallis, the most
    useful values of the shape parameters are when h >= -1.

Syntax:
    LET <y> = KAPPDF(<x>,<k>,<h>,<xi>,<alpha>)
                             <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <k> is a number, parameter, or variable that specifies the
              first shape parameter;
          <h> is a number, parameter, or variable that specifies
              the second shape parameter;
          <xi> is a number, parameter, or variable that specifies the
              location parameter;
          <alpha> is a number, parameter, or variable that specifies
              the scale parameter;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed kappa pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The <xi> and <alpha> parameters are optional.

Examples:
    LET A = KAPPDF(3,0.5,2,0,1.5)
    LET X2 = KAPPDF(X1,K,H)

Note:
    Kappa random numbers, probability plots, and goodness of fit
    tests can be generated with the commands:

       LET K = <value>
       LET H = <value>
       LET Y =  KAPPA RANDOM NUMBERS FOR I = 1 1 N
       KAPPA PROBABILITY PLOT Y
       KAPPA PROBABILITY PLOT Y2 X2
       KAPPA PROBABILITY PLOT Y3 XLOW XHIGH
       KAPPA KOLMOGOROV SMIRNOV GOODNESS OF FIT Y
       KAPPA CHI-SQUARE GOODNESS OF FIT Y2 X2
       KAPPA CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    The following commands can be used to estimate the k and h
    shape parameter for the kappa distribution:

       LET K1 = <value>
       LET K2 = <value>
       LET H1 = <value>
       LET H2 = <value>
       KAPPA PPCC PLOT Y
       KAPPA PPCC PLOT Y2 X2
       KAPPA PPCC PLOT Y3 XLOW XHIGH
       KAPPA KS PLOT Y
       KAPPA KS PLOT Y2 X2
       KAPPA KS PLOT Y3 XLOW XHIGH

    The default values for K1 and K2 are -5 and 5, respectively.
    The default values for THETA1 and THETA2 are -2 and 5,
    respectively.

    The probability plot can then be used to estimate the
    location and scale (location = PPA0, scale = PPA1).

    The BOOTSTRAP DISTRIBUTION command can be used to find
    uncertainty intervals for the ppcc plot and the ks plot.
       
    The parameters of the kappa distribution can be estimated
    by the method of L-moments using the command

       KAPPA MAXIMUM LIKELIHOOD Y

    Dataplot uses Hoskings code for computing the L-moments
    parameter estimates.  Hoskings report and associated Fortran
    code can be downloaded from the Statlib archive at

        http://lib.stat.cmu.edu/

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    KAPCDF = Compute the kappa cumulative distribution function.
    KAPPPF = Compute the kappa percent point function.
    MIEPDF = Compute Miekle's beta-kappa probability density
             function.
    GEVPDF = Compute the generalized extreme value probability
             density function.
    GEPPDF = Compute the generalized Pareto probability density
             function.
    GL5PDF = Compute the Hosking's generalized logistic probability
             density function.
 
Reference:
    Hosking and Wallis (1997), "Regional Frequency Analysis",
    Cambridge University Press, Appendix A10.

    J. R. M. Hosking (2000), "Research Report: Fortran Routines for
    use with the Method of L-Moments", IBM Research Division, T. J.
    Watson Research Center, Yorktown Heights, NY 10598.

    Hoskings (1990), "L-moments: Analysis and Estimation of
    Distribution using Linear Combinations of Order Statistics",
    Journal of the Royal Statistical Society, Series B, 52,
    pp. 105-124.

Applications:
    Distributional Modeling
 
Implementation Date:
    2008/5
 
Program 1:
    LET KP = DATA -0.5  0.1  0.5  1.0
    LET H1 = -0.5
    LET H2 = 0.1
    LET H3 = 1
    LET H4 = 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 95 95
    MULTIPLOT SCALE FACTOR 2
    TITLE CASE ASIS
    TITLE OFFSET 2
    X3LABEL
    LINE COLOR BLACK RED BLUE GREEN
    .
    LOOP FOR KK = 1 1 4
       LET K = KP(KK)
       LET LL1 = KAPPPF(0.05,K,H1)
       LET UL1 = KAPPPF(0.95,K,H1)
       LET LL2 = KAPPPF(0.05,K,H2)
       LET UL2 = KAPPPF(0.95,K,H2)
       LET LL3 = KAPPPF(0.05,K,H3)
       LET UL3 = KAPPPF(0.95,K,H3)
       LET LL4 = KAPPPF(0.05,K,H4)
       LET UL4 = KAPPPF(0.95,K,H4)
       TITLE K = ^K, H = -0.5, 0.1, 1, 2
       PLOT KAPPDF(X,K,H1) FOR X = LL1  0.01  UL1  AND
       PLOT KAPPDF(X,K,H2) FOR X = LL3  0.01  UL2  AND
       PLOT KAPPDF(X,K,H3) FOR X = LL3  0.01  UL3  AND
       PLOT KAPPDF(X,K,H4) FOR X = LL4  0.01  UL4
    END OF LOOP
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Kappa PDF Functions
 
Program 2:
    let k = 0.3
    let h = 0.8
    let ksav = k
    let hsav = h
    .
    let xlow  = kapppf(0.001,k,h)
    let xhigh = kapppf(0.999,k,h)
    .
    x3label
    .
    let y = kappa rand numb for i = 1 1 200
    let y = 5*y
    .
    x3label
    title automatic
    title case asis
    .
    kappa ppcc plot y
    let k = shape1
    let h = shape2
    just center
    move 50 6
    text k = ^k, h = ^h
    move 50 2
    text ksav = ^ksav, hsav = ^hsav
    pause
    .
    char x
    line blank
    kappa prob plot y
    move 50 6
    text ppa0 = ^ppa0, ppa1 = ^ppa1
    move 50 2
    text ppcc = ^ppcc
    char blank
    line solid
    pause
    .
    relative hist y
    limits  freeze
    pre-erase off
    title
    let a1 = minimum y
    let a2 = maximum y
    line color blue red
    let ll = kapppf(0.01,k,h,ppa0,ppa1)
    let ul = kapppf(0.99,k,h,ppa0,ppa1)
    plot kappdf(x,k,h,ppa0,ppa1) for x = ll 0.01 ul
    line color black
    limits
    pre-erase on
    title automatic
    pause
    .
    let ksloc = ppa0
    let ksscale = ppa1
    kappa kolm smir goodness of fit y
    pause
    .
    kappa mle y
    .
    let k = kml
    let h = hml
    let ksloc = ximl
    let ksscale = alphaml
    relative hist y
    limits  freeze
    pre-erase off
    let a1 = minimum y
    let a2 = maximum y
    line color blue red
    plot kappdf(x,k,h,ksloc,ksscale) for x = a1 0.01 a2
    line color black
    limits
    pre-erase on
    pause
    .
    kappa kolm smir goodness of fit y

-----KAPPPF (LET)--------------------------------
 
KAPPPF
 
Name:
    KAPPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the kappa percent point function with shape parameters
    h and k.
 
Description:
    The general form of the kappa distribution has the
    following percent point function:

       G(p;k,h,xi,alpha) = xi + (alpha/k)*{1 - ((1-p**h)/h)**k}
                           0 < p < 1; alpha > 0

    with k and h denoting the shape parameters and xi and
    alpha denoting the location and scale parameters,
    respectively.

    The standard form of the distribution is defined as
    xi = 0 and alpha = 1.

Syntax:
    LET <y> = KAPPPF(<p>,<k>,<h>,<xi>,<alpha>)
                             <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or variable in the range [0,1];
          <k> is a number, parameter, or variable that specifies the
              first shape parameter;
          <h> is a number, parameter, or variable that specifies
              the second shape parameter;
          <xi> is a number, parameter, or variable that specifies the
              location parameter;
          <alpha> is a number, parameter, or variable that specifies
              the scale parameter;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed kappa ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The <xi> and <alpha> parameters are optional.

Examples:
    LET A = KAPPPF(0.95,0.5,2,0,1.5)
    LET X2 = KAPPPF(P1,K,H)

Note:
    Dataplot uses Hoskings QUAKAP routine to compute the kappa
    percent point function.  Hoskings report and associated Fortran
    code can be downloaded from the Statlib archive at

        http://lib.stat.cmu.edu/

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    KAPCDF = Compute the kappa cumulative distribution function.
    KAPPDF = Compute the kappa probability density function.
    MIEPDF = Compute Miekle's beta-kappa probability density
             function.
    GEVPDF = Compute the generalized extreme value probability
             density function.
    GEPPDF = Compute the generalized Pareto probability density
             function.
    GL5PDF = Compute the Hosking's generalized logistic probability
             density function.
 
Reference:
    Hosking and Wallis (1997), "Regional Frequency Analysis",
    Cambridge University Press, Appendix A10.

    J. R. M. Hosking (2000), "Research Report: Fortran Routines for
    use with the Method of L-Moments", IBM Research Division, T. J.
    Watson Research Center, Yorktown Heights, NY 10598.

    Hoskings (1990), "L-moments: Analysis and Estimation of
    Distribution using Linear Combinations of Order Statistics",
    Journal of the Royal Statistical Society, Series B, 52,
    pp. 105-124.

Applications:
    Distributional Modeling
 
Implementation Date:
    2008/5
 
Program:
    LET KP = DATA -0.5  0.1  0.5  1.0
    LET H1 = -0.5
    LET H2 = 0.1
    LET H3 = 1
    LET H4 = 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 95 95
    MULTIPLOT SCALE FACTOR 2
    TITLE CASE ASIS
    TITLE OFFSET 2
    X3LABEL
    LINE COLOR BLACK RED BLUE GREEN
    .
    LOOP FOR KK = 1 1 4
       LET K = KP(KK)
       TITLE K = ^K, H = -0.5, 0.1, 1, 2
       PLOT KAPPPF(P,K,H1) FOR P = 0.02  0.01  0.98  AND
       PLOT KAPPPF(P,K,H2) FOR P = 0.02  0.01  0.98  AND
       PLOT KAPPPF(P,K,H3) FOR P = 0.02  0.01  0.98  AND
       PLOT KAPPPF(P,K,H4) FOR P = 0.02  0.01  0.98
    END OF LOOP
    END OF MULTIPLOT
    .
    CASE ASIS
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Kappa PPF Functions
 
-----KATCDF (LET)--------------------------------
 
KATCDF
 
Name:
    KATCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Katz cumulative distribution function.
 
Description:
    The Katz distribution is defined by the relationship

        p(x+1;alpha,beta)/p(x;alpha,beta) =
            (alpha + beta*x)/(1 + x)
            x = 0, 1, 2, 3, ,...; alpha > 0, beta < 1

    From this, the cumulative probabilities are computed
    using the recurrence relation

        p(x+1;alpha,beta) = {(alpha + beta*x)/(1 + x)}*
                            p(x;alpha,beta)
 
    where

        p(0;alpha,beta) = (1-beta)**(alpha/beta)

Syntax:
    LET <y> = KATCDF(<x>,<alpha>,<beta>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative integer variable, number, or
              parameter;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed Katz cdf value is stored;
          <alpha> is a number or parameter that specifies the
               first shape parameter;
          <beta> is a number or parameter that specifies the
               second shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = KATCDF(3,2,0.5)
    LET X2 = KATCDF(X1,ALPHA,BETA)
    PLOT KATCDF(X,1.4,0.3) FOR X = 0 1 20
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    KATPDF                   = Compute the Katz probability mass
                               function.
    KATPPF                   = Compute the Katz percent point
                               function.
    POIPDF                   = Compute the Poisson probability mass
                               function.
    BINPDF                   = Compute the binomial probability
                               mass function.
    NBPDF                    = Compute the negative binomial
                               probability mass function.
    GNBCDF                   = Compute the generalized negative
                               binomial cumulative distribution
                               function.
    GNBPPF                   = Compute the generalized negative
                               binomial percent point function.
    GLSPDF                   = Compute the generalized logarithmic
                               series probability density function.
    NBPDF                    = Compute the negative binomial
                               probability mass function.
    LPOPDF                   = Compute the Lagrange Poisson
                               probability mass function.
    GETPDF                   = Compute the Geeeta probability
                               mass function.
    CONPDF                   = Compute the Consul probability
                               mass function.
    INTEGER FREQUENCY TABLE  = Generate a frequency table at
                               integer values with unequal bins.
    COMBINE FREQUENCY TABLE  = Convert an equal width frequency
                               table to an unequal width frequency
                               table.
    PROBABILITY PLOT         = Generate a probability plot.
    PPCC PLOT                = Generate a ppcc plot.
    KS PLOT                  = Generate a ks plot.
 
Reference:
    Johnson, Kotz, and Kemp (2005), "Discrete Univariate
    Distributions" Third Edition, Wiley, pp. 82-83.

    Consul and Famoye (2006), "Lagrangian Probability
    Distribution", Birkhauser, chapter 10.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/2
 
Program:
    label case asis
    title case asis
    case asis
    tic offset units screen
    tic offset 3 3
    title displacement 2
    x1label displacement 12
    y1label displacement 15
    y1label Probability
    x1label X
    .
    ylimits 0 1
    major ytic mark number 6
    minor ytic mark number 4
    xlimits 0 20
    line blank
    spike on
    .
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    multiplot 2 2
    .
    let alpha = 5
    let beta = 0.5
    title Alpha = ^alpha, Beta = ^beta
    plot katcdf(x,alpha,beta) for x = 0 1 20
    .
    let beta = 0
    title Alpha = ^alpha, Beta = ^beta
    plot katcdf(x,alpha,beta) for x = 0 1 20
    .
    let beta = -0.5
    title Alpha = ^alpha, Beta = ^beta
    plot katcdf(x,alpha,beta) for x = 0 1 20
    .
    let beta = -1
    title Alpha = ^alpha, Beta = ^beta
    plot katcdf(x,alpha,beta) for x = 0 1 20
    .
    end of multiplot
    .
    justification center
    move 50 97
    text Katz Cumulative Distribution Functions

-----KATPDF (LET)--------------------------------
 
KATPDF
 
Name:
    KATPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Katz probability mass function.
 
Description:
    The Katz distribution is defined by the relationship

        p(x+1;alpha,beta)/p(x;alpha,beta) =
            (alpha + beta*x)/(1 + x)
            x = 0, 1, 2, 3, ,...; alpha > 0, beta < 1

    From this, the probabilities are computed using the
    recurrence relation

        p(x+1;alpha,beta) = {(alpha + beta*x)/(1 + x)}*
                            p(x;alpha,beta)
 
    where

        p(0;alpha,beta) = (1-beta)**(alpha/beta)

Syntax:
    LET <y> = KATPDF(<x>,<alpha>,<beta>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative integer variable, number, or
              parameter;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed Katz pdf value is stored;
          <alpha> is a number or parameter that specifies the
               first shape parameter;
          <beta> is a number or parameter that specifies the
               second shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = KATPDF(3,2,0.5)
    LET X2 = KATPDF(X1,ALPHA,BETA)
    PLOT KATPDF(X,1.4,0.3) FOR X = 0 1 20
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Note:
    For a number of commands utilizing the Katz distribution,
    it is convenient to bin the data.  There are two basic ways
    of binning the data.

      1) For some commands (histograms, maximum likelihood
         estimation), bins with equal size widths are
         required.  This can be accomplished with the
         following commands:

            LET AMIN = MINIMUM Y
            LET AMAX = MAXIMUM Y
            LET AMIN2 = AMIN - 0.5
            LET AMAX2 = AMAX + 0.5
            CLASS MINIMUM AMIN2
            CLASS MAXIMUM AMAX2
            CLASS WIDTH 1
            LET Y2 X2 = BINNED

      2) For some commands, unequal width bins may be
         helpful.  In particular, for the chi-square goodness
         of fit, it is typically recommended that the minimum
         class frequency be at least 5.  In this case, it may
         be helpful to combine small frequencies in the tails.
         Unequal class width bins can be created with the
         commands

            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = INTEGER FREQUENCY TABLE Y

         If you already have equal width bins data, you can
         use the commands
         
            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = COMBINE FREQUENCY TABLE Y2 X2

         The MINSIZE parameter defines the minimum class
         frequency.  The default value is 5.

Note:
    You can generate Katz random numbers, probability plots,
    and chi-square goodness of fit tests with the following
    commands:

        LET ALPHA = <value>
        LET BETA = <value>
        LET Y = KATZ RANDOM NUMBERS FOR I = 1 1 N

        KATZ PROBABILITY PLOT Y
        KATZ PROBABILITY PLOT Y2 X2
        KATZ PROBABILITY PLOT Y XXLOW XHIGH

        KATZ CHI-SQUARE GOODNESS OF FIT Y
        KATZ CHI-SQUARE GOODNESS OF FIT Y2 X2
        KATZ CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    You can generate estimates of alpha and beta based
    on the maximum ppcc value or the minimum chi-square goodness
    of fit with the commands

        LET ALPHA1 = <value>
        LET ALPHA2 = <value>
        LET BETA1 = <value>
        LET BETA2 = <value>
        KATZ KS PLOT Y
        KATZ KS PLOT Y2 X2
        KATZ KS PLOT Y3 XLOW XHIGH
        KATZ PPCC PLOT Y
        KATZ PPCC PLOT Y2 X2
        KATZ PPCC PLOT Y3 XLOW XHIGH

    The default values of alpha1 and alpha2 are 0.1 and 10,
    respectively.  The default values of beta1 and beta2 are
    -3 and 0.95.  Due to the discrete nature of the percent
    point function for discrete distributions, the ppcc plot will
    not be smooth.  For that reason, if there is sufficient sample
    size the KS PLOT (i.e., the minimum chi-square value) is
    typically preferred.  Also, since the data is integer values,
    one of the binned forms is preferred for these commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    KATCDF                   = Compute the Katz cumulative
                               distribution function.
    KATPPF                   = Compute the Katz percent point
                               function.
    POIPDF                   = Compute the Poisson probability mass
                               function.
    BINPDF                   = Compute the binomial probability
                               mass function.
    NBPDF                    = Compute the negative binomial
                               probability mass function.
    GNBCDF                   = Compute the generalized negative
                               binomial cumulative distribution
                               function.
    GNBPPF                   = Compute the generalized negative
                               binomial percent point function.
    GLSPDF                   = Compute the generalized logarithmic
                               series probability density function.
    NBPDF                    = Compute the negative binomial
                               probability mass function.
    LPOPDF                   = Compute the Lagrange Poisson
                               probability mass function.
    GETPDF                   = Compute the Geeeta probability
                               mass function.
    CONPDF                   = Compute the Consul probability
                               mass function.
    INTEGER FREQUENCY TABLE  = Generate a frequency table at
                               integer values with unequal bins.
    COMBINE FREQUENCY TABLE  = Convert an equal width frequency
                               table to an unequal width frequency
                               table.
    PROBABILITY PLOT         = Generate a probability plot.
    PPCC PLOT                = Generate a ppcc plot.
    KS PLOT                  = Generate a ks plot.
 
Reference:
    Johnson, Kotz, and Kemp (2005), "Discrete Univariate
    Distributions" Third Edition, Wiley, pp. 82-83.

    Consul and Famoye (2006), "Lagrangian Probability
    Distribution", Birkhauser, chapter 10.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/2
 
Program 1:
    label case asis
    title case asis
    case asis
    tic offset units screen
    tic offset 3 3
    title displacement 2
    x1label displacement 12
    y1label displacement 15
    y1label Probability Mass
    x1label X
    .
    ylimits 0 0.4
    major ytic mark number 5
    minor ytic mark number 1
    xlimits 0 20
    line blank
    spike on
    .
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    multiplot 2 2
    .
    let alpha = 5
    let beta = 0.5
    title Alpha = ^alpha, Beta = ^beta
    plot katpdf(x,alpha,beta) for x = 0 1 20
    .
    let beta = 0
    title Alpha = ^alpha, Beta = ^beta
    plot katpdf(x,alpha,beta) for x = 0 1 20
    .
    let beta = -0.5
    title Alpha = ^alpha, Beta = ^beta
    plot katpdf(x,alpha,beta) for x = 0 1 20
    .
    let beta = -1
    title Alpha = ^alpha, Beta = ^beta
    plot katpdf(x,alpha,beta) for x = 0 1 20
    .
    end of multiplot
    .
    justification center
    move 50 97
    text Katz Probability Mass Functions

Program 2:
    title case asis
    title offset 2
    label case asis
    .
    let alpha = 1.4
    let beta = 0.7
    .
    let y = katz rand numb for i = 1 1 200
    class lower -0.5
    class width 1
    let a = maximum y
    let a = a + 0.5
    y1label Relative Frequency
    relative histogram y
    limits freeze
    pre-erase off
    line color blue
    plot katpdf(x,alpha,beta) for x = 0 1 a
    line color black
    limits
    pre-erase on
    .
    let y2 x2 = binned y
    let y3 xlow xhigh = combine frequency table y2 x2
    let alpha1 = 0.5
    let alpha2 = 5
    let beta1 = -1
    let beta2 = 0.95
    line solid
    char bl
    katz ks plot y2 x2
    let alphasav = alpha
    let betasv = beta
    let alpha = shape1
    let beta = shape2
    justification center
    move 50 5
    text Alpha = ^alpha, Beta = ^beta
    .
    katz chi-square goodness of fit y3 xlow xhigh
    .
    char x
    line bl
    y1label Theoretical
    x1label Data
    title Katz Probability Plot
    katz prob plot y2 x2

-----KATPPF (LET)--------------------------------
 
KATPPF
 
Name:
    KATPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Katz percent point function.
 
Description:
    The Katz distribution is defined by the relationship

        p(x+1;alpha,beta)/p(x;alpha,beta) =
            (alpha + beta*x)/(1 + x)
            x = 0, 1, 2, 3, ,...; alpha > 0, beta < 1

    From this, the cumulative probabilities are computed
    using the recurrence relation

        p(x+1;alpha,beta) = {(alpha + beta*x)/(1 + x)}*
                            p(x;alpha,beta)
 
    where

        p(0;alpha,beta) = (1-beta)**(alpha/beta)

    The percent point function is computed by generating
    the cumulative distribution function until the
    appropriate probability is obtained.

Syntax:
    LET <y> = KATPPF(<p>,<alpha>,<beta>)
              <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, number, or parameter in the
              interval (0,1];
          <y> is a variable or a parameter (depending on what
              <p> is) where the computed Katz ppf value is stored;
          <alpha> is a number or parameter that specifies the
               first shape parameter;
          <beta> is a number or parameter that specifies the
               second shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = KATPPF(0.95,2,0.5)
    LET X2 = KATPPF(P,ALPHA,BETA)
    PLOT KATPPF(P,1.4,0.3) FOR P = 0  0.01  0.99
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    KATCDF                   = Compute the Katz cumulative
                               distribution function.
    KATPDF                   = Compute the Katz probability mass
                               function.
    POIPDF                   = Compute the Poisson probability mass
                               function.
    BINPDF                   = Compute the binomial probability
                               mass function.
    NBPDF                    = Compute the negative binomial
                               probability mass function.
    GNBCDF                   = Compute the generalized negative
                               binomial cumulative distribution
                               function.
    GNBPPF                   = Compute the generalized negative
                               binomial percent point function.
    GLSPDF                   = Compute the generalized logarithmic
                               series probability density function.
    NBPDF                    = Compute the negative binomial
                               probability mass function.
    LPOPDF                   = Compute the Lagrange Poisson
                               probability mass function.
    GETPDF                   = Compute the Geeeta probability
                               mass function.
    CONPDF                   = Compute the Consul probability
                               mass function.
    INTEGER FREQUENCY TABLE  = Generate a frequency table at
                               integer values with unequal bins.
    COMBINE FREQUENCY TABLE  = Convert an equal width frequency
                               table to an unequal width frequency
                               table.
    PROBABILITY PLOT         = Generate a probability plot.
    PPCC PLOT                = Generate a ppcc plot.
    KS PLOT                  = Generate a ks plot.
 
Reference:
    Johnson, Kotz, and Kemp (2005), "Discrete Univariate
    Distributions" Third Edition, Wiley, pp. 82-83.

    Consul and Famoye (2006), "Lagrangian Probability
    Distribution", Birkhauser, chapter 10.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/2
 
Program:
    label case asis
    title case asis
    case asis
    tic offset units screen
    tic offset 3 3
    title displacement 2
    x1label displacement 12
    y1label displacement 15
    x1label Probability
    y1label X
    .
    xlimits 0 1
    major xtic mark number 6
    minor xtic mark number 4
    line blank
    spike on
    .
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    multiplot 2 2
    .
    let alpha = 5
    let beta = 0.5
    title Alpha = ^alpha, Beta = ^beta
    plot katppf(p,alpha,beta) for p = 0  0.01  0.99
    .
    let beta = 0
    title Alpha = ^alpha, Beta = ^beta
    plot katppf(p,alpha,beta) for p = 0  0.01  0.99
    .
    let beta = -0.5
    title Alpha = ^alpha, Beta = ^beta
    plot katppf(p,alpha,beta) for p = 0  0.01  0.99
    .
    let beta = -1
    title Alpha = ^alpha, Beta = ^beta
    plot katppf(p,alpha,beta) for p = 0  0.01  0.99
    .
    end of multiplot
    .
    justification center
    move 50 97
    text Katz Percent Point Functions

-----K CONSISTENCY STATISTIC (LET)--------------------------
 
K CONSISTENCY STATISTIC
 
Name:
    K CONSISTENCY STATISTIC (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the k-consistency statistic of a variable as defined
    by the ASTM E 691 - 99 standard.
 
Description:
    The k-consistency statistic is defined in the
    ASTM E 691 - 99 standard as

       k    = s/s(r) (within-laboratory consistency statistic)
 
    with

       s      = cell standard deviation
       s(r)   = repeatability standard deviation

Syntax 1:
    LET <k> = K CONSISTENCY STATISTIC <y> <labid>
               <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <labid> is a lab-id variable;
          <k> is a variable where the k-consistency statistic
              values are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used to compute the k-consistency statistic
    for a single material.  The number of k-values is equal to
    the number of laboratories.

Syntax 2:
    LET <k> = K CONSISTENCY STATISTIC <y> <labid> <matid>
               <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <labid> is a lab-id variable;
          <matid> is a material-id variable;
          <k> is a variable where the k-consistency statistic
              values are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used to compute the k-consistency statistic
    for multiple materials.  The number of k-values is equal to
    the number of materials times the number of laboratories.

Examples:
    LET A = K CONSISTENCY STATISTIC Y LAB
    LET HVAL = K CONSISTENCY STATISTIC Y LAB MAT
    LET HVAL = K CONSISTENCY STATISTIC Y LAB MAT SUBSET MAT > 2
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    E691 INTERLAB             = Perform an E691 interlab analysis.
    H CONSISTENCY STATISTIC   = Compute the h-consistency statistic.
 
Reference:
    "Standard Practice for Conducting an Interlaboratory Study
    to Determine the Precision of a Test Method", ASTM
    International, 100 Barr Harbor Drive, PO BOX C700,
    West Conshohoceken, PA 19428-2959, USA.

Applications:
    Interlaboratory Analysis
 
Implementation Date:
    2005/4
 
Program:
    SKIP 25
    READ GLUCOSE.DAT Y MATID LABID
    .
    LET KVAL = K CONSISTENCY STATISTIC Y LABID MATID
 
-----KEEP (LET)---------------------------------------------------
 
KEEP
 
Name:
    KEEP (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Given a group-id variable, create a tag variable based on a list
    of groups to keep.
 
Description:
    For some analyses, it may be necessary to omit some laboratories
    from the analysis.  Although you can create an appropriate tag
    variable manually, the KEEP command can simplify that process.

    For example, if you have labs 1 to 10 and you want to perform your
    analysis on labs 3 and 8 only, you can do something like the following

        LET XKEEP = DATA 3 8
        LET TAG = KEEP X XKEEP

    That is, this command will return a tag variable (TAG) based on
    the values of X.  Values of X that match any value in XKEEP will
    be set to 1 and values of X that do not match any values in XKEEP
    will be set to 0.

Syntax:
    LET <tag> = KEEP <x> <xkeep>    <SUBSET/EXCEPT/FOR qualification>
    where <x> is the group-id variable;
          <xkeep> is a list of values to match against <x>;
          <tag> is a variable of the same length as <x> that will contain
               1 where a match is found and 0 otherwise;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET TAG = KEEP X XKEEP
 
Note:
    The OMIT command is similar.  However, with the OMIT command you
    specify a list of lab id's to omit rather than to keep.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    OMIT       = Create a tag variable based on a list of labs to omit.
    CODE       = Generate a coded variable.
    COCODE     = Generate a coded variable based on another variable.
    COCOPY     = Generate a coded variable based on another variable.
 
Applications:
    Data Transformations
 
Implementation Date:
    2011/4
 
Program:
    skip 25
    read gear.dat y x
    set write decimals 4
    .
    let xkeep = data 1 3 5 7 8 9
    let tag = keep x xkeep
    print x tag y
 
-----KENDALLS TAU (LET)--------------------------------
 
KENDALLS TAU
 
Name:
    KENDALLS TAU (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute Kendall's tau coefficient between two paired variables.
 
Description:
    Kendall's tau coefficient is a measure of concordance
    between two paired variables.  Given the pairs (X(i),Y(i)) and
    (X(j),Y(j)), then

     (Y(j) - Y(i))/(X(j) - X(i)) > 0   - pair is concordant
     (Y(j) - Y(i))/(X(j) - X(i)) < 0   - pair is discordant
     (Y(j) - Y(i))/(X(j) - X(i)) = 0   - pair is considered a tie
     X(i) = X(j)                       - pair is not compared

    Kendall's tau is computed as

        tau = (Nc - Nd)/(Nc + Nd)

    with Nc and Nd denoting the number of concordant pairs and
    the number of discordant pairs, respectively, in the sample.
    Ties add 0.5 to both the concordant and discordant counts.
    There are (n 2) possible pairs in the bivariate sample.

    The above definition of Kendall's tau is from Conover.  This is
    equivalent to the Goodman and Kruskal gamma coefficient. There are
    several alternative definitions of Kendall's tau in the literature.
    In particular, Kendall's original definition, referred to as tau-a, is

       tau-a = (Nc - Nd)/(N*(N-1)/2)

    where the Nc and Nd do not add 0.5 for tied values.

    The Conover formulation accounts for ties while the Kendall tau-a
    statistic does not.
    <P>
    Kendall's tau-b is defined as

       tau-b = (N_c - N_d)/SQRT{(Nc + Nd + Tx)*(Nc + Nd + Ty)}

    with Tx denoting the number of pairs tied for the first response
    variable only and Ty denoting the number of pairs tied for the second
    variable only.  As with Kendall's tau-a, the Nc and Nd do not add 0.5
    for tied values.  Kendall's tau-b is equal to Kendall's tau-a when
    there are no ties but is preferred to Kendall's tau-a when there are
    ties.

    Kendall's tau-c is used when the two response variables can only take
    a discrete number of values, but the scales for the response variables
    are different.  For example, X can take integer values from 1 to 10
    while Y can take integer values from 1 to 20.  The formula for Kendall's
    tau-c is

       tau-c = (2*(N_c - N_d)/(N**2*(m - 1)/m)

    where m is the minimun of Xd and Yd where X_d is the number of
    distinct values of X and Yd is the number of distinct values for Y.

    Kendall's tau is an alternative to the Spearman's rho
    rank correlation.

    Rank correlation may be preferred to the standard correlation
    coefficient in the following cases:

      1) When the underlying data does not have a meaningful numerical
         measure, but it can be ranked;

      2) When the relationship between the two variables is not
         linear;

      3) When the normality assumption for two variables is not
         valid.

Syntax 1:
    LET <par> = KENDALLS TAU <y1> <y2>
               <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Kendall's tau is
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax computes Kendall's tau as formulated by Conover.
 
Syntax 2:
    LET <par> = KENDALLS TAU A <y1> <y2>
               <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Kendall's tau is
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax computes Kendall's tau-a.
 
Syntax 3:
    LET <par> = KENDALLS TAU B <y1> <y2>
               <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Kendall's tau is
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax computes Kendall's tau-b.
 
Syntax 4:
    LET <par> = KENDALLS TAU C <y1> <y2>
               <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Kendall's tau is
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax computes Kendall's tau-c.
 
Examples:
    LET A = KENDALLS TAU Y1  Y2
    LET A = KENDALLS TAU Y1 Y2 SUBSET TAG > 2
 
Note:
    The two variables must have the same number of elements.
 
Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CORRELATION (LET)      = Compute the Pearson correlation
                             coefficient between two variables.
    RANK CORRELATION (LET) = Compute the Spearman's rho correlation
                             coefficient between two variables.
    STATISTIC PLOT         = Generate a statistic versus index plot.
    BOOTSTRAP PLOT         = Generate a bootstrap plot for a
                             statistic.
    TABULATE               = Compute a statistic for one group
                             variable.
    CROSS TABULATE         = Compute a statistic for two group
                             variables.
 
Applications:
    Exploratory Data Analysis
 
Implementation Date:
    2004/10
    2019/08: Added KENDALL TAU A
    2019/08: Added KENDALL TAU B
    2019/08: Added KENDALL TAU C
 
Program:
    . Following data from page 320 of Conover, "Practical
    . Nonparametric Statistics", Third Edition, 1999, Wiley.
    LET Y1 = DATA 7 8 4 5.5 4.5 4 5 3 2 0.5 1
    LET Y2 = DATA 4 2 5 0.5 1.5 2 0 1 0 1.5 0
    LET A1 = KENDALLS TAU Y1 Y2

    The computed value of Kendall's tau is 0.4355.
 
-----KENDALL TAU DISSIMILARITY (LET)--------------------------------
 
KENDALL TAU DISSIMILARITY
 
Name:
    KENDALL TAU DISSIMILARITY (LET)
    KENDALL TAU SIMILARITY (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the Kendall's tau correlation coefficient transformed to a
    dissimilarity measure between two variables.
 
Description:
    Kendall's tau coefficient is a measure of concordance
    between two paired variables.  Given the pairs (X(i),Y(i)) and
    (X(j),Y(j)), then

     (Y(j) - Y(i))/(X(j) - X(i)) > 0   - pair is concordant
     (Y(j) - Y(i))/(X(j) - X(i)) < 0   - pair is discordant
     (Y(j) - Y(i))/(X(j) - X(i)) = 0   - pair is considered a tie
     X(i) = X(j)                       - pair is not compared

    Kendall's tau is computed as

        tau = (Nc - Nd)/(Nc + Nd)

    with Nc and Nd denoting the number of concordant pairs and
    the number of discordant pairs, respectively, in the sample.
    Ties add 0.5 to both the concordant and discordant counts.
    There are (n 2) possible pairs in the bivariate sample.

    Kendall's tau is an alternative to the Spearman's rho
    rank correlation.

    A perfect linear relationship yields a correlation coefficient of
    +1 (or -1 for a negative relationship) and no linear relationship
    yields a correlation coefficient of 0.
 
    In some applications, such as clustering, it can be useful to
    transform Kendall's tau coefficient to a dissimilarity measure.
    The transformation used here is

        d = (1 - R)/2

    This converts Kendall's tau coefficient with values between -1 and
    1 to a score between 0 and 1.  High positive correlation (i.e., very
    similar) results in a dissimilarity near 0 and high negative
    correlation (i.e., very dissimilar) results in a dissimilarity near 1.

    If a similarity score is preferred, you can use

        s = 1 - d

    where d is defined as above.

Syntax 1:
    LET <par> = KENDALL TAU DISSIMILARITY <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Kendall's tau
               dissimilarity is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Syntax 2:
    LET <par> = KENDALL TAU SIMILARITY <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Kendall's tau
               similarity is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Examples:
    LET A = KENDALL TAU DISSIMILARITY Y1 Y2
    LET A = KENDALL TAU DISSIMILARITY Y1 Y2 SUBSET TAG > 2
    LET A = KENDALL TAU SIMILARITY Y1 Y2
 
Note:
    The two variables must have the same number of elements.
 
Default:
    None
 
Synonyms:
    KENDALL TAU DISTANCE is a synonym for KENDALL TAU DISSIMILARITY
 
Related Commands:
    KENDALLS TAU              = Compute the Kendall's tau correlation of two
                                variables.
    CORRELATION               = Compute the Pearson correlation of two
                                variables.
    SPEARMAN DISSIMILARITY    = Compute the dissimilarity of two variables
                                based on Spearman's rank correlation.
    PEARSON DISSIMILARITY     = Compute the dissimilarity of two variables
                                based on Pearson's correlation.
    COSINE DISTANCE           = Compute the cosine distance.
    MANHATTAN DISTANCE        = Compute the Euclidean distance.
    EUCLIDEAN DISTANCE        = Compute the Euclidean distance.
    MATRIX DISTANCE           = Compute various distance metrics for a
                                matrix.
    GENERATE MATRIX <stat>    = Compute a matrix of pairwise statistic
                                values.
    CLUSTER                   = Perform a cluster analysis.
 
Reference:
    Kaufman and Rousseeuw (1990), "Finding Groups in Data: An
    Introduction To Cluster Analysis", Wiley.

Applications:
    Clustering
 
Implementation Date:
    2017/08:
    2018/10: Added KENDALL TAU SIMILARITY
    2018/10: Added KENDALL TAU DISTANCE as a synonym for
             KENDALL TAU DISSIMILARITY
 
Program 1:
    SKIP 25
    READ BERGER1.DAT Y X
    LET CORR = KENDALL TAU Y X
    LET D    = KENDALL TAU DISSIMILARITY Y X
    SET WRITE DECIMALS 3
    PRINT CORR D
 
Program 2:
    SKIP 25
    READ IRIS.DAT Y1 Y2 Y3 Y4
    SET WRITE DECIMALS 3
    .
    LET M = GENERATE MATRIX KENDALL TAU DISSIMILARITY Y1 Y2 Y3 Y4
    PRINT M
 
Program 3:
    SKIP 25
    READ IRIS.DAT Y1 Y2 Y3 Y4 TAG
    .
    TITLE CASE ASIS
    TITLE OFFSET 2
    LABEL CASE ASIS
    TIC MARK OFFSET UNITS DATA
    YLIMITS 0 1
    MAJOR YTIC MARK NUMBER 6
    MINOR YTIC MARK NUMBER 1
    Y1TIC MARK LABEL DECIMAL 1
    XLIMITS 1 3
    MAJOR XTIC MARK NUMBER 3
    MINOR XTIC MARK NUMBER 0
    XTIC MARK OFFSET 0.3 0.3
    CHARACTER X BLANK
    LINES BLANK SOLID
    .
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT SCALE FACTOR 2
    MULTIPLOT 2 3
    .
    TITLE Sepal Length vs Sepal Width
    KENDALL TAU DISSIMILARITY PLOT Y1 Y2 TAG
    .
    TITLE Sepal Length vs Petal Length
    KENDALL TAU DISSIMILARITY PLOT Y1 Y3 TAG
    .
    TITLE Sepal Length vs Petal Width
    KENDALL TAU DISSIMILARITY PLOT Y1 Y4 TAG
    .
    TITLE Sepal Width vs Petal Length
    KENDALL TAU DISSIMILARITY PLOT Y2 Y3 TAG
    .
    TITLE Sepal Width vs Petal Width
    KENDALL TAU DISSIMILARITY PLOT Y2 Y4 TAG
    .
    TITLE Petal Length vs Petal Width
    KENDALL TAU DISSIMILARITY PLOT Y3 Y4 TAG
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 5
    TEXT Species
    DIRECTION VERTICAL
    MOVE 5 50
    TEXT Kendall Tau Dissimilarity Coefficient
    DIRECTION HORIZONTAL
 
-----KENDALL TAU INDEPENDENCE TEST--------------------------------------
 
KENDALL TAU INDEPENDENCE TEST
 
Name:
    KENDALL TAU INDEPENDENCE TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform a Kendall tau test for whether two samples are independent
    (i.e., not correlated).
 
Description:
    Kendall's tau coefficient is a measure of concordance
    between two paired variables.  Given the pairs (X(i),Y(i)) and
    (X(j),Y(j)), then

     (Y(j) - Y(i))/(X(j) - X(i)) > 0   - pair is concordant
     (Y(j) - Y(i))/(X(j) - X(i)) < 0   - pair is discordant
     (Y(j) - Y(i))/(X(j) - X(i)) = 0   - pair is considered a tie
     X(i) = X(j)                       - pair is not compared

    Kendall's tau is computed as

        tau = (Nc - Nd)/(Nc + Nd)

    with Nc and Nd denoting the number of concordant pairs and
    the number of discordant pairs, respectively, in the sample.
    Ties add 0.5 to both the concordant and discordant counts.
    There are (n 2) possible pairs in the bivariate sample.

    A value of +1 indicates that all pairs are concordant, a
    value of -1 indicates that all pairs are discordant, and
    a value of 0 indicates no relation (i.e., independence).

    The Kendall tau independence test is a test of whether the 
    Kendall tau coefficient is equal to zero.

    For larger n (e.g., n > 60) or the case where there are
    many ties, the p-th upper quantile of the Kendall tau statistic
    can be approximated by

        w(p) = z(p)*SQRT(2*(2*n+5))/(3*SQRT(n*(n-1)))

    with z(p) and n denoting the p-th quantile of the standard
    normal distribution and the sample size, respectively.  The
    lower quantile is the negative of the upper quantile.

    For a two-sided test, the p-value is computed as twice the
    minimum of the lower tailed and upper tailed quantiles.

    For n <= 60, tabulated quantiles (from Table A11 on pp. 543-544
    of Conover) are used.  These quantiles are exact when there are
    no ties in the data.

Syntax 1:
    <LOWER TAILED/UPPER TAILED> KENDALL TAU INDEPENDENCE TEST  <y1>  <y2>
                                <SUBSET/EXCEPT/FOR qualification>
    where <LOWER TAILED/UPPER TAILED> is an optional keyword that
               specifies either a lower tailed or an upper tailed
               test;
          <y1> is the first response variable;
          <y2> is the second response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    If neither LOWER TAILED or UPPER TAILED is specified, a two-tailed
    test is performed.

    Lower tailed tests are used to test for discordance (i.e., negative
    correlation) and upper tailed tests are used to test for
    concordance (i.e., positive correlation).

Syntax 2:
    <LOWER TAILED/UPPER TAILED> KENDALL TAU INDEPENDENCE TEST  <y1>  ... <yk>
                                <SUBSET/EXCEPT/FOR qualification>
    where <LOWER TAILED/UPPER TAILED> is an optional keyword that
               specifies either a lower tailed or an upper tailed
               test;
          <y1> ... <yk> is a list of 1 to 30 response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax will perform all the pair-wise tests for the <y1> ...
    <yk> response variables.  For example,

         KENDALL TAU INDEPENDENCE TEST Y1 TO Y4

    is equivalent to

         KENDALL TAU INDEPENDENCE TEST Y1 Y2
         KENDALL TAU INDEPENDENCE TEST Y1 Y3
         KENDALL TAU INDEPENDENCE TEST Y1 Y4
         KENDALL TAU INDEPENDENCE TEST Y2 Y3
         KENDALL TAU INDEPENDENCE TEST Y2 Y4
         KENDALL TAU INDEPENDENCE TEST Y3 Y4

Examples:
    KENDALL TAU INDEPENDENCE TEST Y1 Y2
    KENDALL TAU INDEPENDENCE TEST Y1 TO Y5
    LOWER TAILED KENDALL TAU INDEPENDENCE TEST Y1 Y2
    UPPER TAILED KENDALL TAU INDEPENDENCE TEST Y1 Y2
 
Note:
    This command can be used to test for trend in a univariate
    variable.  For example

       LET N = SIZE Y
       LET X = SEQUENCE 1 1 N
       KENDALL TAU INDEPENDENCE TEST Y X

    According to Conover, this test is more powerful than the
    Cox and Stuart test.  However, it is not as widely applicable
    as the Cox and Stuart test.

Note:
    This test can be used to perform the Jonckheere-Terpstra test.
    Given two or more independent samples, the Jonckheere-Terpstra is
    used to test the null hypothesis that all the samples came from the
    same distribution against the ordered alternative that the
    distributions differ in a specified direction.  That is

        H0: F1(x) = F2(x) = .... = Fk(x)

     versus

        Ha: F1(x) <= F2(x) <= .... <= Fk(x)

     or

        Ha: F1(x) >= F2(x) >= .... >= Fk(x)

    Although the Jonckheere-Terpstra test is based only on the number
    of concordant pairs (Nc above), applying the Kendall tau independence
    test gives an equivalent result.

    For Dataplot, if Y is a response variable and X is a group-id
    variable, then to test for "less than" (positive concordance), use

        UPPER TAILED KENDALL TAU INDEPENDENCE TEST Y X

    and to test for "greater than" (negative concordance), use

        LOWER TAILED KENDALL TAU INDEPENDENCE TEST Y X

Note:
    The RANK CORRELATION INDEPENDENCE TEST can be used to perform
    a test for independence based on the Spearman rho rank correlation.

    The CORRELATION CONFIDENCE LIMITS command can be used to generate
    a confidence interval for the Pearson correlation coefficient.
    This can be used for a parametric test for independence (i.e.,
    does the confidence interval contain zero?).

Note:
    By default, critical values are based on tabulated values for
    n <= 60.  The command 

        SET KENDALL TAU CRITICAL VALUES NORMAL APPROXIMATION

    can be used to specify that they should be based on the normal
    approximation given above.  This may be preferred if there are
    ties in the data.  To reset the default, enter the command

        SET KENDALL TAU CRITICAL VALUES TABLE

Note:
    The KENDALL TAU INDEPENDENCE TEST will accept matrix arguments.  If
    a matrix is given, the data elements in the matrix will be collected in
    column order to form a vector before performing the test.
 
Note:
    Dataplot saves the following internal parameters after a
    sign test:

        STATVAL   = the value of the test statistic
        STATCDF   = the CDF of the test statistic
        PVALUE    = the p-value for the two-sided test
        PVALUELT  = the p-value for the lower tailed test
        PVALUEUT  = the p-value for the upper tailed test
        CUTLOW90  = the 90% lower tailed critical value
        CUTUPP90  = the 90% upper tailed critical value
        CUTLOW95  = the 95% lower tailed critical value
        CUTUPP95  = the 95% upper tailed critical value
        CTLOW975  = the 97.5% lower tailed critical value
        CTUPP975  = the 97.5% upper tailed critical value
        CUTLOW99  = the 99% lower tailed critical value
        CUTUPP99  = the 99% upper tailed critical value
        CTLOW995  = the 99.5% lower tailed critical value
        CTUPP995  = the 99.5% upper tailed critical value

Note:
    The following statistics can also be computed

        LET A = KENDALL TAU Y1 Y2
        LET A = KENDALL TAU CDF Y1 Y2
        LET A = KENDALL TAU PVALUE Y1 Y2
        LET A = KENDALL TAU LOWER TAILED PVALUE Y1 Y2
        LET A = KENDALL TAU UPPER TAILED PVALUE Y1 Y2

    The cdf and p-values are based on the normal approximation
    given above.

    To see a list of commands in which these statistics can be
    used, enter

        HELP STATISTICS

Note:
    The run sequence plot can be used to graphically assess
    whether or not there is trend in the data.  The 4-plot can
    be used to assess the more general assumption of
    "independent, identically distributed" data.

    The paired data can also be analyzed using other techniques for
    comparing two response variables (e.g., t-test, bihistogram,
    quantile-quantile plot).

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    RANK CORRELATION INDEPENDENCE TEST  = Compute an independence test
                                          based on the Spearman rho rank
                                          correlation statistic.
    CORRELATION CONFIDENCE LIMITS       = Generate confidence limits for
                                          the Pearson correlation
                                          coefficient.
    COX AND STUART TEST                 = Compute a Cox and Stuart trend
                                          test.
    T-TEST                              = Compute a t-test.
    4-PLOT                              = Generate a 4-plot.
    RUN SEQUENCE PLOT                   = Generate a run sequence plot.
    BIHISTOGRAM                         = Generates a bihistogram.
    QUANTILE-QUANTILE PLOT              = Generate a quantile-quantile plot.
 
Reference:
    Conover (1999), "Practical Nonparametric Statistics",
    Third Edition, Wiley, pp. 319-327.
 
Applications:
    Confirmatory Data Analysis
 
Implementation Date:
    2013/4
 
Program:
    read kendall.dat y1 y2
    set write decimals 5
    .
    let statval  = kendall tau y1 y2
    let statcdf  = kendall tau cdf y1 y2
    let pvalue   = kendall tau pvalue y1 y2
    let pvallt   = kendall tau lower tailed pvalue y1 y2
    let pvalut   = kendall tau upper tailed pvalue y1 y2
    print statval statcdf pvalue pvallt pvalut
    .
    kendall tau independence test y1 y2
    upper tailed kendall tau independence test y1 y2
    .
    set kendall tau critical values normal approximation
    upper tailed kendall tau independence test y1 y2

-----KER (LET)--------------------------------
 
KER
 
Name:
    KER (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the ker Kelvin function or the derivative of the
    ker Kelvin function.
 
Description:
    The modified Bessel function of the third kind with order v
    can be defined as:

        K(v)(z) = (PI/2)*(I(-v)(z) - I(v)(z))/SIN(PI*v)

    where I(v) is the modified Bessel function of the first kind.
    See the documentation for BESSIN (HELP BESSIN) for details on
    the I(v) function.

    The ker Kelvin functions can then be computed in terms of the
    Bessel function of the third kind:
  
       ker(v)(x) + i*kei(v)(x) = EXP(-PI*i/2)*K(v)(x*EXP(PI*i/4))
    
    The functions described here compute these functions
    for the case when there is a real, non-negative input
    argument and order zero (i.e., v = 0).
 
    Dataplot computes these function using the KLVNA routines from
    "Computation of Special Functions" (see the References section
    below).
 

Syntax 1:
    LET <yr> = KER(<x>)      <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative number, variable or parameter;
          <yr> is a variable or a parameter (depending on what
              <x> is) where the computed Kelvin value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the real component of the ker Kelvin
    function.

Syntax 2:
    LET <yc> = KERI(<x>)      <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative number, variable or parameter;
          <yc> is a variable or a parameter (depending on what
              <x> is) where the computed Kelvin value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the complex component of the ker Kelvin
    function.

Syntax 3:
    LET <yr> = KER1(<x>)      <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative number, variable or parameter;
          <yr> is a variable or a parameter (depending on what
              <x> is) where the computed Kelvin value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the real component of the derivative of
    the ker Kelvin function.

Syntax 4:
    LET <yc> = KERI1(<x>)      <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative number, variable or parameter;
          <yc> is a variable or a parameter (depending on what
              <x> is) where the computed Kelvin value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the complex component of the derivative
    of the ker Kelvin function.

Examples:
    LET A = KER(2)
    LET A = KERI(2)
    LET A = KER1(2)
    LET A = KERI1(2)

    LET YR = KER(X)
    LET YC = KERI(X)

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BER     = Compute the BER Kelvin functions.
    CBESSJR = Compute the real component of the Bessel function of
              the first kind, order N, and complex argument.
    CBESSJI = Compute the complex component of the Bessel function of
              the first kind, order N, and complex argument.
    CBESSYR = Compute the real component of the Bessel function of
              the second kind, order N, and complex argument.
    CBESSYI = Compute the complex component of the Bessel function of
              the second kind, order N, and complex argument.
    CBESSIR = Compute the real component of the modified Bessel
              function of order N and complex argument.
    CBESSII = Compute the complex component of the modified Bessel
              function of order N and complex argument.
    CBESSKR = Compute the real component of the modified Bessel
              function of the third kind, order N, and complex
              argument.
    CBESSKI = Compute the complex component of the modified Bessel
              function of the third kind, order N, and complex
              argument.
    BESSKN  = Compute the Bessel function of the third kind, order N,
              and real argument.
    BESSIN  = Compute the modified Bessel function, order N,
              and real argument.
    BESSJN  = Compute the Bessel function of the first kind, order N,
              and real argument.
 
Reference:
    "Computation of Special Functions", Shanjie Zhang and Jianming
    Jin, John Wiley and Sons, 1996, chapter 9.
 
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (pages 379-385).
 
Applications:
    Special Functions
 
Implementation Date:
    1997/12
 
Program:
    LINE SOLID DASH
    TITLE KER KELVIN FUNCTION
    PLOT KER(X) FOR X = 0.1 0.1 10 AND
    PLOT KERI(X) FOR X = 0.1 0.1 10
 
-----KERNEL DENSITY POINTS----------------------------------------------
 
KERNEL DENSITY POINTS
 
Name:
    KERNEL DENSITY POINTS
 
Type:
    Support Command
 
Purpose:
    Specify the number of points for the density curve for the
    KERNEL DENSITY PLOT command.
 
Description:
    The kernel density estimate, f(n), of a set of n points from
    a density f is defined as:

         f(n)(x) = (1/(n*h))*SUM[j=1 to n]K{(x - X(j)/h}

    where K is the kernel function h is the smoothing parameter
    or window width.

    This command sets the number of points at which the kernel
    density estimate is computed.
 
    In particular, the horizontal points for the kernel density
    plot are computed at:

       DLO + (I - 0.5)*(DHI - DLO)/NKD

    where 

       NKD     = the number of points at which the kernel density
                 is estimated
       DLO     = YMINIMUM - 3*H where YMINIMUM is the minimum of
                 the raw data and H is the window width
       DHI     = YMAXIMUM + 3*H where YMAXIMUM is the maximum of
                 the raw data and H is the window width
       I       = ith point in the density estimate

    By default, the density curve is generated with 256 points.
    The underlying FFT computation expects this number to be a
    power of 2 (i.e., 2**K).  Currently, Dataplot limits this
    value to 2**K where K is an integer between 5 (= 32 points)
    and 11 (2,048) points.  Values below 32 are set to 32, values
    greater than 2,048 are set to 2,048 and values between
    32 and 2,048 are rounded up to the next value of 2**K
    (i.e., 32, 64, 128, 256, 512, 1024, or 2048).

Syntax:
    KERNEL DENSITY POINTS  <value>
    where <value> is a number or parameter that specifies the
          desired number of points.
 
Examples:
    KERNEL DENSITY POINTS 1024
    KERNEL DENSITY POINTS 512
    KERNEL DENSITY POINTS 2048
 
Default:
    The default number of points is 256.
 
Synonyms:
    The following are synonyms for the KERNEL DENSITY POINTS command:
    
        KERNEL POINTS
        KERNEL NUMBER OF POINTS
        KERNEL NUMBER POINTS
        KERNEL DENSITY NUMBER OF POINTS
        KERNEL DENSITY NUMBER POINTS
 
Related Commands:
    KERNEL DENSITY PLOT   = Generate a kernel density plot command.
    KERNEL DENSITY WIDTH  = Sets the window width for the kernel
                            density plot.
 
Reference:
    "Kernel Density Estimation using the Fast Fourier Transform",
    B. W. Silverman, Applied Statistics, Royal Statistical Society,
    (1982), Vol. 33.

Applications:
    Density Estimation
 
Implementation Date:
    2001/8
 
Program:
    LET Y = NORMAL RANDOM NUMBERS FOR I = 1 1 10000
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 2 2
    MULTIPLOT SCALE FACTOR 2
    .
    KERNEL DENSITY POINTS 64
    X3LABEL DENSITY WITH 64 POINTS
    KERNEL DENSITY PLOT Y
    .
    KERNEL DENSITY POINTS 256
    X3LABEL DENSITY WITH 256 POINTS
    KERNEL DENSITY PLOT Y
    .
    KERNEL DENSITY POINTS 512
    X3LABEL DENSITY WITH 512 POINTS
    KERNEL DENSITY PLOT Y
    .
    KERNEL DENSITY POINTS 1024
    X3LABEL DENSITY WITH 1,024 POINTS
    KERNEL DENSITY PLOT Y
    .
    END OF MULTIPLOT
 
-----KERNEL DENSITY PLOT----------------------------------------------
 
KERNEL DENSITY PLOT
 
Name:
    KERNEL DENSITY PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a kernel density plot.
 
Description:
    The kernel density estimate, f(n), of a set of n points from
    a density f is defined as:

         f(n)(x) = (1/(n*h))*SUM[j=1 to n]K{(x - X(j)/h}

    where K is the kernel function h is the smoothing parameter
    or window width.

    Currently, Dataplot uses a Gaussion kernel function.  This
    downweights points smoothly as the distance from x increases.
    The width parameter can be set by the user (see Note: below),
    although Dataplot will provide a default width that should
    produce reasonable results for most data sets.
 
    A kernel density plot can be considered a refinement of
    a histogram or frequency plot.

Syntax 1:
    KERNEL DENSITY PLOT  <y>  <SUBSET/EXCEPT/FOR qualification>
    where <y> is the variable of raw data values;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    Note that <y> can be either a variable or a matrix.  If <y>
    is a matrix, a kernel density plot will be generated for all
    values in the matrix.

Syntax 2:
    MULTIPLE KERNEL DENSITY PLOT  <y1> ... <yk>
                                  <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax will overlay multiple kernel density plots on the
    same plot.

    Note that the response variables (<y1> ... <yk>) can be either
    variables or matrices (or a mix of variables and matrices).  For
    matrices, a kernel density plot will be generated for all
    values in the matrix.

Syntax 3:
    REPLICATED KERNEL DENSITY PLOT  <y>  <x1>
                                  <SUBSET/EXCEPT/FOR qualification>
    where <y>  is the response variable;
          <x1> is a group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax will generate a kernel density plot for each
    distinct value in the group-id variable.  The kernel density
    plots will be generated on the same page.

Syntax 4:
    REPLICATED KERNEL DENSITY PLOT  <y>  <x1> <x2>
                                  <SUBSET/EXCEPT/FOR qualification>
    where <y>  is the response variable;
          <x1> is the first group-id variable;
          <x2> is the second group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax will cross tabulate the group-id variables and
    generate a kernel density plot for each unique combination
    of values for the <x1> and <x2> group-id variables.  The
    kernel density plots will be generated on the same page.

Examples:
    KERNEL DENSITY PLOT Y
    KERNEL DENSITY PLOT Y  SUBSET TAG = 2
    KERNEL DENSITY PLOT Y  FOR I = 1 1 800
    MULTIPLE KERNEL DENSITY PLOT Y1 Y2 Y3
    REPLICATED KERNEL DENSITY PLOT Y X1 X2
 
Note:
    Dataplot computes the kernel density estimate using Algorithm 176
    from Applied Statistics (see Reference below).  This code was
    contributed by B. W. Silverman.

    This algorithm is based on the Fast Fourier Transform (FFT).
    The use of the FFT results in much greater computational
    efficiency.  The article that accompanies this algorithm
    provides the details of how the FFT is used and provides
    timing estimates of this implemenation relative to an
    algorithm based on the definition of the kernel function.

Note:
    By default, the density curve is generated with 256 points.
    Note that this is the number of points on the density curve,
    not the number of points in the raw data.
 
    You can set the number of points for the density curve
    using the following command:

         KERNEL DENSITY POINTS  <value>

    where <value> defines the number of points.

Note:
    Following the recommendation of Silverman (1986), Dataplot uses
    a default width of

        0.9*min(s,IQ/1.34)*n**(-1/5)

    where s is the sample standard deviation and IQ is the sample
    interquartile range.  Silverman provides justification for this
    choice.  Basically, it should perform reasonably for a wide
    variety of distributions.  Note that the optimal width depends
    on the underlying function, which is what we are trying to
    estimate.

    If the underlying data is in fact normally distributed, then
    Silverman (1986) shows that the optimal width is

        1.06*s*n**(-1/5)

    where n is the number of points in the raw data and s is
    the sample standard deviation of the raw data.  

    It may be worthwhile to generate the density curve using
    several different values for the width.   Silverman also
    recommends trying to transform skewed data sets to be
    symmetric.

    The width can be set with the following command:

        KERNEL DENSITY WIDTH  <value>

Note:
    Dataplot will not generate the density curve unless the
    input data set contains at least 20 data points.  In fact,
    the sample size should be larger than this for density
    plots to be an appropriate method.

Note:
    The KERNEL DENSITY PLOT estimates the underlying probability density
    function.  However, it can also be used to estimate the cumulative
    distribution function (cdf) or the percent point function (ppf).  To
    estimate the cdf, the cumulative integral of the kernel density plot
    is computed.  The ppf is inverse of the cdf, so the role of the x and
    y values from the estimated cdf are switched to obtain an estimate of
    the ppf function.

    To plot the estimated cdf, enter
 
       SET KERNEL DENSITY PROBABILITY FUNCTION CDF

    To plot the estimated ppf, enter
 
       SET KERNEL DENSITY PROBABILITY FUNCTION PPF

    To reset the plotting of the pdf, enter

       SET KERNEL DENSITY PROBABILITY FUNCTION PDF

    Given that we can estimate the ppf function, we can use this to
    generate random numbers based on the kernel density plot.  If you
    would like to generate random numbers, enter the command

       SET KERNEL DENSITY RANDOM NUMBERS <value>

    where <value> is a number between 1 and the maximum number of rows.
    If <value> is set to 0 or a negative number, no random numbers are
    generated.

    Specifically, the following procedure is used:

        i) Generate uniform random numbers (the uniform random numbers
           correspond to x-axis values on the ppf version of the kernel
           density plot).

       ii) From the ppf version of the kernel density plot, determine
           the y-axis value on the kernel density curve that corresponds
           to the x-axis value.  Cubic spline interpolation is used to
           estimate the y-axis value.  That is, at the points defined
           by the uniform random numbers, we find interpolated values
           based on the (x,y) coordinates of the kernel density curve.

      iii) The random numbers are written to the file dpst1f.dat using
           an E15.7 format.

Note:
    Dataplot computes the density curve from 

        (YMINIMUM - 3*H, YMAXIMUM + 3*H)

    where YMINIMUM and YMAXIMUM are the minimum and maximum
    values of the raw data and H is the window width.

Note:
    The KERNEL DENSITY PLOT supports the TO syntax for the list
    of variable names.  This is most useful for the MULTIPLE
    case.

Default:
    The default window width is 1.06*s*n**(-1/5) where n is the
    number of points in the raw data and s is the sample standard
    deviation.  The density trace is generated with 256 points.
 
Synonyms:
    The following are synonyms for the KERNEL DENSITY PLOT command.
    
        KERNEL PLOT
        DENSITY PLOT
        DENSITY TRACE
 
    The word MULTIPLE is optional for the MULTIPLE KERNEL DENSITY PLOT
    syntax.

Related Commands:
    HISTOGRAM             = Generates a histogram.
    FREQUENCY PLOT        = Generates a frequency plot.
    KERNEL DENSITY WIDTH  = Sets the width factor, h, for the kernel
                            density plot.
    KERNEL DENSITY POINTS = Sets the number of points generated for
                            the kernel density plot.
 
Reference:
    "Kernel Density Estimation using the Fast Fourier Transform",
    B. W. Silverman, Applied Statistics, Royal Statistical Society,
    (1982), Vol. 33.

    "Density Estimation for Statistics and Data Analysis",
    B. W. Silverman, Chapman & Hall, 1986.

    "Multivariate Density Estimation", David Scott, John Wiley, 1992.
 
Applications:
    Density Estimation
 
Implementation Date:
    2001/08
    2010/02: Support for the MULTIPLE and REPLICATION syntax
    2010/02: Support for matrix arguments and the TO syntax
    2018/07: Support for SET KERNEL DENSITY PROBABILITY FUNCTION
    2018/07: Support for SET KERNEL DENSITY RANDOM NUMBERS
 
Program 1:
    LET Y = NORMAL RANDOM NUMBERS FOR I = 1 1 1000
    KERNEL DENSITY PLOT Y
 
Program 2:
    title case asis
    title offset 2
    title automatic
    label case asis
    tic mark offset units screen
    y1tic mark offset 2 2
    line color blue red green
    xlimits -10 10
    set write decimals 3
    .
    let y1 = norm rand numb for i = 1 1 500
    let y2 = logistic rand numb for i = 1 1 500
    let y3 = double exponential rand numb for i = 1 1 500
    kernel density plot y1 y2 y3
    move 50 97
    just center
    text Normal,Logistic, and Laplace Random Numbers
    .
    title automatic
    let y x = stack y1 y2 y3
    replicated kernel density plot y x
 
Program 3:
    . Step 1:   Read the data
    .
    skip 25
    read zarr13.dat y
    skip 0
    .
    . Step 2:   Plot control features
    .
    multiplot corner coordinates 5 5 95 95
    multiplot scale factor 2
    title offset 2
    title case asis
    label case asis
    case asis
    .
    . Step 3:   Generate the kernel density plot
    .
    multiplot 2 2
    .
    set isubro kde2
    echo on
    title PDF
    kernel density plot y
    .
    title CDF
    set kernel density probability function cdf
    kernel density plot y
    .
    title PPF
    set kernel density probability function ppf
    set kernel density random numbers 200
    kernel density plot y
    .
    read dpst1f.dat yrand
    line color blue red
    title Blue: Original Data, Red: 200 Random Numbers
    set kernel density probability function pdf
    multiple kernel density plot y yrand
    .
    end of multiplot

-----KERNEL DENSITY WIDTH----------------------------------------------
 
KERNEL DENSITY WIDTH
 
Name:
    KERNEL DENSITY WIDTH
 
Type:
    Support Command
 
Purpose:
    Specify the width parameter for a density plot.
 
Description:
    The kernel density estimate, f(n), of a set of n points from
    a density f is defined as:

         f(n)(x) = (1/(n*h))*SUM[j=1 to n]K{(x - X(j)/h}

    where K is the kernel function h is the smoothing parameter
    or window width.

    This command sets the value of the window width, h.
 
    Following the recommendation of Silverman (1986), DATAPLOT uses
    a default width of

        0.9*min(s,IQ/1.34)*n**(-1/5)

    where s is the sample standard deviation and IQ is the sample
    interquartile range.  Silverman provides justification for this
    choice.  Basically, it should perform reasonably for a wide
    variety of distributions.  Note that the optimal width depends
    on the underlying function, which is what we are trying to
    estimate.

    If the underlying data is in fact normally distributed, then
    Silverman (1986) shows that the optimal width is

        1.06*s*n**(-1/5)

    where n is the number of points in the raw data and s is
    the sample standard deviation of the raw data.  

    It may be worthwhile to generate the density curve using
    several different values for the width.   Silverman also
    recommends trying to transform skewed data sets to be
    symmetric.

Syntax:
    KERNEL DENSITY WIDTH  <value>
    where <value> is a number or parameter that specifies the
          desired width.
 
    The width should be strictly positive.  

Examples:
    KERNEL DENSITY WIDTH 0.3
    KERNEL DENSITY WIDTH 1.2
 
    LET S = STANDARD DEVIATION Y
    LET A = 0.3*S
    KERNEL DENSITY WIDTH A

Default:
    The default window width is 1.06*s*n**(-1/5) where n is the
    number of points in the raw data and s is the sample standard
    deviation.
 
Synonyms:
    KERNEL WIDTH is a synonym for the KERNEL DENSITY WIDTH command.
    
 
Related Commands:
    KERNEL DENSITY PLOT   = Generate a kernel density plot command.
    KERNEL DENSITY POINTS = Sets the number of points generated for
                            the kernel density plot.
 
Reference:
    "Kernel Density Estimation using the Fast Fourier Transform",
    B. W. Silverman, Applied Statistics, Royal Statistical Society,
    (1982), Vol. 33.

Applications:
    Density Estimation
 
Implementation Date:
    2001/8
 
Program:
    LET Y = NORMAL RANDOM NUMBERS FOR I = 1 1 1000
    KERNEL DENSITY WIDTH 0.3
    KERNEL DENSITY PLOT Y
 
-----KLOTZ SCORE (LET)-----------------------------------------------
 
KLOTZ SCORE
 
Name:
    KLOTZ SCORE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the Klotz scores of a variable.
 
Description:
    The Klotz scores are defined as

        s(R(j)) = (NORPPF(R(j)/(n+1)))**2

    where R(j) is the rank of the j-th observation, n is the number of
    observations and NORPPF is the percent point function of the normal
    distribution.

    Klotz scores are used in the KLOTZ TEST command to test whether k
    samples have equal variances.

Syntax:
    LET <s> = KLOTZ SCORE <y>  <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <s> is a variable where the computed Klotz scores are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET KSCORE = KLOTZ SCORE Y
 
Note:
    Ties are assigned an average rank.  For example, if the 2nd and 3rd
    highest values are equal, each is assigned a rank of 2.5.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    KLOTZ TEST              = Perform a Klotz test for equal variances.
    MEDIAN TEST             = Perform a median test.
    ANOVA                   = Perform a fixed effects analysis of variance.
    MOOD SCORES             = Generate Mood scores.
    MEDIAN SCORES           = Generate median scores.
    VAN DER WAERDEN SCORES  = Generate Van Der Waerden scores.
    SAVAGE SCORES           = Generate Savage scores.
    CONOVER SCORES          = Generate Conover scores.
    ANSARI BRADLEY SCORES   = Generate Ansari Bradley scores.
    PLACEMENT SCORES        = Generate placement scores.
    RANK                    = Generate the ranks of a variable. 
 
Reference:
    W. J. Conover, (1999).  "Practical Nonparameteric Statistics",
    Third Edition, Wiley, pp. 401-402.

Applications:
    Nonparametric statistics
 
Implementation Date:
    2023/06
 
Program:
    . Step 1:   Define the data
    .
    let y1 = data 16.55 15.36 15.94 16.43 16.01
    let y2 = data 16.05 15.98 16.10 15.88 15.91
    let n1 = size y1
    let n2 = size y2
    let n = n1 + n2
    .
    . Step 2:   Combine into single array
    .
    let y tag = stack y1 y2
    if n1 <= n2
       let tag = tag - 1
       let n1t = n1
    else
       let tag = 0 subset tag = 2
       let n1t = n2
    end of if
    .
    . Step 3:   Compute the Klotz scores
    .
    let kscore = klotz scores y
    .
    . Step 4:   Two-Sample Linear Rank Test
    .
    let temp = tag*kscore
    let s = sum temp
    .
    let aval = sum kscore
    let smean = (n1t/n)*aval
    let meanrank = mean kscore
    let temp = (kscore - meanrank)**2
    let aval = sum temp
    let svar = ((n1*n2)/(n*(n-1)))*aval
    let statval = (s - smean)/sqrt(svar)
    let statval = round(statval,3)
    let cv = norppf(0.975)
    let upplim = round(cv,2)
    let lowlim = -upplim
    feedback off
    print "Two Sample Linear Rank Sum Test Based on Klotz Scores"
    print "H0: Variances are Equal"
    print "Ha: Variances are Not Equal"
    print "alpha: 0.05"
    print "Test Statistic: ^statval"
    print "Lower Critical Value: ^lowlim"
    print "Upper Critical Value: ^upplim"
    if statval < cv
       print "Conclusion: Accept H0"
    else
       print "Conclusion: Reject H0"
    end of if
 
-----KLOTZ TEST-----------------------------------------
 
KLOTZ TEST
 
Name:
    KLOTZ TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform a Klotz test that 2 samples have equal variances.
 
Description:
    The F test is the standard parameteric test for testing the
    equality of variances for the two sample case.

    A Klotz test is a non-parametric alternative to the F test.  It is
    based on the squares of normal scores.  Normal scores are computed
    as

         A(i) = NORPPF(R(i)/(N+1))

    where R(i) is the rank of the i-th observation, N is the sample
    size, and NORPPF is the percent point function of the standard
    normal distribution.

    The advantage of many tests based on normal scores is that they
    perform well when the assumptions of the standard parametric
    test are satisfied while still providing protection when the
    assumptions are not satisfied.
           
    The Klotz test is defined as

        H0: The two populations have equal variances
        Ha: The two populations do not have equal variances
        Test       To compute the test statistic, for each sample first
        Statistic: subtract the mean from each observation.  Then compute
                   the normal scores (A(i)) for the combined sample.  The
                   test statistic is then

                      T1 = NUM/DEN

                   where

                      NUM = SUM=[i=1 to n1][A(i)**2] -
                            (n1/(n1+n2))*SUM[i=1 to n1+n2][A(i)**2]
                      DEN = SQRT{C*[SUM[i=1 to n1+n2][A(i)**4] -
                            (1/(n1+n2))*(SUM[i=1 to n1+n2][A(i)**2])**2]}

                      n1  = sample size 1
                      n2  = sample size 2
                      C   = (n1*n2)/((n1+n2)*(n1+n2-1))

        Significance Level: alpha
        Critical Region: For a two-tailed test:

                             T1 > NORPPF(1 - (ALPHA/2))
                             T1 < NORPPF(ALPHA)

                         For a lower-tailed test:

                             T1 < NORPPF(ALPHA)

                         For an upper-tailed test:

                             T1 > NORPPF(1 - ALPHA)

                         NORPPF is the percent point function of the
                         standard normal distribution

        Conclusion: Reject the null hypothesis if the test
                    statistic is in the critical region.

    The critical values based on the normal test are only approximate.
    Dataplot does not currently compute exact critical values.

Syntax 1:
    <LOWER TAILED/UPPER TAILED> KLOTZ  TEST <y1>  <y2>
                                <SUBSET/EXCEPT/FOR qualification>
    where <LOWER TAILED/UPPER TAILED> is an optional keyword for the
              two sample case;
          <y1> is the first response variable;
          <y2> is the second response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The LOWER TAILED and UPPER TAILED keywords are optional Only one
    can be specified and if neither is entered a two-tailed test will
    be performed.

Syntax 2:
    <LOWER TAILED/UPPER TAILED> KLOTZ  TEST <y1>  ... <yk>
                                <SUBSET/EXCEPT/FOR qualification>
    where <LOWER TAILED/UPPER TAILED> is an optional keyword for the
              two sample case;
          <y1> ... <yk> is a list of 2 to 30 response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The LOWER TAILED and UPPER TAILED keywords are optional Only one
    can be specified and if neither is entered a two-tailed test will
    be performed.

    This syntax will generate all the pairwise Klotz tests for the
    list of variables.

Examples:
    KLOTZ TEST Y1 Y2
    LOWER TAILED KLOTZ TEST Y1 Y2
    UPPER TAILED KLOTZ TEST Y1 Y2
    KLOTZ TEST Y1 TO Y10
 
Note:
    The Klotz test accepts matrix arguments.  A matrix will act
    like a variable in that all the values in the matrix will be
    converted to a single variable.  That is, it does not act on
    the rows or colums independently.

    The TO syntax is supported for this command.
 
Note:
    The squared ranks test is an alternative non-parametric test for
    comparing the variances of k populations.

Note:
    The following statistics are also supported:

        LET A = KLOTZ TEST                     Y1 Y2
        LET A = KLOTZ TEST CDF                 Y1 Y2
        LET A = KLOTZ TEST PVALUE              Y1 Y2
        LET A = KLOTZ TEST LOWER TAILED PVALUE Y1 Y2
        LET A = KLOTZ TEST UPPER TAILED PVALUE Y1 Y2

    Enter HELP STATISTICS to see what commands can use these
    statistics.

Default:
    None
 
Synonyms:
    None

Related Commands:
    SQUARED RANKS TEST    = Perform k sample squared ranks test for
                            equal variances.
    F TEST                = Perform k sample F-test for equal variances.
    KRUSKAL WALLIS TEST   = Perform Kruskal Wallis test for equal
                            locations.
    VAN DER WAERDEN TEST  = Perform Van Der Waerden test for equal
                            locations.
 
Reference:
    W. J. Conover, (1999).  "Practical Nonparameteric Statistics",
    Third Edition, Wiley, pp. 401-402.

Applications:
    Nonparametric Analysis
 
Implementation Date:
    2011/5
 
Program:
    . Step 1: Read Data (from p. 402 of Conover)
    .
    let y1 = data 10.8 11.1 10.4 10.1 11.3
    let y2 = data 10.8 10.5 11.0 10.9 10.8 10.7 10.8
    set write decimals 4
    .
    .  Step 2: Check the statistic
    .
    let stat  = klotz test y1 y2
    let cdf   = klotz test cdf y1 y2
    let pval  = klotz test pvalue y1 y2
    print stat pval cdf
    .
    .  Step 3: Perform Klotz test
    .
    klotz test y1 y2

-----KNOTS-------------------------------------------------------
 
KNOTS
 
Name:
    KNOTS
 
Type:
    Support Command
 
Purpose:
    Specifies the knot positions for subsequent SPLINE FIT commands.
 
Description:
    The knot positions are those values along the horizontal axis
    variable which define the endpoints of each sub-domain.  Individual
    curves are "splined together" at these points to form a smooth
    curve over the entire domain.  The desired knot values must
    be placed in a variable by the analyst.  This is most commonly done
    via the SERIAL READ, the READ, or the LET commands.  For example,
    to specify knot values of 25, 75, and 109.3, one could enter
       SERIAL READ X2
       25 75 109.3
       END OF DATA
    or
       READ X2
       25
       75
       109.3
       END OF DATA
    or
       LET X2 = DATA 25 75 109.3
    To specify that X2 is the variable with the knots, enter
       KNOTS X2
    To actually carry out the cubic spline fit on the raw data in the
    variables X and Y, enter
       CUBIC SPLINE FIT Y X
    The KNOTS command receives only light usage due since the knots
    variable can be embedded directly in the command itself as the
    third argument.  Thus the above sequence can be shortened to
       CUBIC SPLINE FIT Y X X2
 
Syntax:
    KNOTS   <x>
    where <x> is a variable that contains the desired knot points.
 
Examples:
    KNOTS X2
    KNOTS Z
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SPLINE FIT  = Carries out a spline fit.
    READ        = Reads data (column-wise) into variables.
    SERIAL READ = Reads data (row-wise) into variables.
    END OF DATA = Defines the end of data for READ and SERIAL READ.
    LET         = Creates variables (and many other operations).
    WRITE       = Writes variables, parameters, and functions to the
                  screen or to file.
    STATUS      = Displays current variables, parameters, and
                  functions.
 
Applications:
    Spline Fitting
 
Implementation Date:
    Pre-1987
 
Program:
    XX
 
-----KOLMOGOROV SMIRNOV GOODNESS OF FIT TEST --------------------
 
KOLMOGOR SMIRNOV GOODNESS FIT
 
Name:
    ... KOLMOGOROV SMIRNOV GOODNESS OF FIT TEST
 
    NOTE: This command has been replaced with the unified
          GOODNESS OF FIT command (enter HELP GOODNESS OF FIT
          for details).

Type:
    Analysis Command
 
Purpose:
    Perform a Kolmogorov-Smirnov goodness of fit test that a set of
    data come from a hypothesized continuouis distributuion.  Dataplot
    currently supports the chi-square goodness of fit test
    for 60+ distributions.
 
Description:
    The Kolmogorov-Smirnov (K-S) test is based on the empirical
    distribution function (ECDF).  Given N data points
    Y(1), Y(2), ..., Y(n), the ECDF is defined as

        E(n) = n(i)/N

    where n(i) is the number of points less than Y(i).  This is a
    step function that increases by 1/N at the value of each data point.

    We can graph a plot of the empirical distribution function with
    a cumulative distribution function for a given distribution.  The
    K-S test is based on the maximum distance between these two curves.

    An attractive feature of this test is that
    the distribution of the K-S test statistic itself does not
    depend on the underlying cumulative distribution function being
    tested.  Another advantage is that it is an exact test (the
    chi-square goodness of fit depends on an adequate sample size
    for the approximations to be valid). Despite these advantages,
    the K-S test has several important limitations:

    1) It only applies to continuous distributions.
    2) It tends to be more sensitive near the center of the
       distribution than it is at the tails.
    3) Perhaps the most serious limitation is that the
       distribution must be fully specified.  That is, if
       location, scale, and shape parameters are estimated
       from the data, the critical region of the K-S test
       is no longer valid.  It typically must be determined by
       simulation.
    4) The K-S test is only valid for continuous distributions.

    Due to limitations 2 and 3 above, many analysts prefer to
    use the Anderson-Darling goodness of fit test.  However, the
    Anderson-Darling test is only available for a few specific
    distributions.  In addition, the Anderson-Darling test is
    more powerful than the K-S test since it makes specific use
    of the underlying cumulative distribution.

    More formally, the Kolmogorov-Smirnov goodness of fit
    test statistic can be defined as follows.

        H0:          The data follow a specified distribution.
        Ha:          The data do not follow the specified distribution.

        Test         The Kolmogorov-Smirnov goodness of fit test
        Statistic:   statistic is defined as

                       D = max |F(Y(i)) - i/N|

                     where F is the theoretical cumulative
                     distribution of the distribution being tested.

        Significance alpha
        Level:

        Critical     The hypothesis regarding the distributional form is
        Region:      rejected if the test statistic, D, is greater than
                     the critical value obtained from a table.  There
                     are several variations of these tables in the
                     literature that use somewhat different scalings
                     for the K-S test statistic and critical regions.
                     These alternative formulations should be equivalent,
                     but it is necessary to ensure that the test statistic
                     is calculated in a way that is consistent with how
                     the critical values were tabulated.

                     Dataplot uses the critical values from
                     Chakravart, Laha, and Roy (see Reference: below).

    In order to apply the K-S goodness of fit test, any shape
    parameters must be specified.  For example,

       LET GAMMA = 5.3
       WEIBULL KOLMOGOROV-SMIRNOV GOODNESS OF FIT TEST Y

    The name of the distributional parameter for families is given in
    the list below.
 
    Location and scale parameters can be specified generically with
    the following commands:

        LET KSLOC = <value>
        LET KSSCALE = <value>

    The location and scale parameters default to 0 and 1 if not
    specified.

Syntax:
    <dist>  KOLMOGOROV SMIRNOV GOODNESS OF FIT TEST  <y> 
                                <SUBSET/EXCEPT/FOR/qualification>
    where <y> is a response variable;
          <dist> is one of the following distributions:

          Distributions with only location and scale parameters
            1) NORMAL
            2) HALFNORMAL
            3) SLASH
            4) COSINE
            5) LOGISTIC
            6) HALF LOGISTIC
            7) HYPERBOLIC SECANT
            8) CAUCHY
            9) HALF CAUCHY
           10) DOUBLE EXPONENTIAL
           11) EXPONENTIAL
           12) EXTREME VALUE TYPE 1  (or GUMBEL)
           13) UNIFORM
           14) SEMI-CIRCULAR
           15) ANGLIT
           16) ARCSIN

          Distributions with one shape parameter
            1) WEIBULL                     (GAMMA)
            2) DOUBLE WEIBULL              (GAMMA)
            3) INVERTED WEIBULL            (GAMMA)
            4) GAMMA                       (GAMMA)
            5) LOG GAMMA                   (GAMMA)
            6) DOUBLE GAMMA                (GAMMA)
            7) INVERTED GAMMA              (GAMMA)
            8) WALD                        (GAMMA)
            9) FATIGUE LIFE                (GAMMA)
           10) EXTREME VALUE TYPE 2        (GAMMA)
           11) GENERALIZED EXTREME VALUE   (GAMMA)
           12) PARETO                      (GAMMA)
           13) PARETO SECOND KIND          (GAMMA)
           14) GENERALIZED PARETO          (GAMMA)
           15) GENERALIZED HALF LOGISTIC   (GAMMA)
           16) TUKEY LAMBDA                (LAMBDA)
           17) SKEWED NORMAL               (LAMBDA)
           18) SKEW DOUBLE EXPONENTIAL     (LAMBDA)
           19) T                           (NU)
           20) FOLDED T                    (NU)
           21) CHI-SQUARED                 (NU)
           22) CHI                         (NU)
           23) LOGNORMAL                   (SD)
           24) LOG DOUBLE EXPONENTIAL      (ALPHA)
           25) ERROR                       (ALPHA)
           26) GENERALIZED LOGISTIC        (ALPHA)
           27) GENERALIZED LOGISTIC TYPE 2 (ALPHA)
           28) GENERALIZED LOGISTIC TYPE 3 (ALPHA)
           29) GENERALIZED LOGISTIC TYPE 5 (ALPHA)
           30) MCLEISH                     (ALPHA)
           31) WRAPPED CAUCHY              (C)
           32) POWER FUNCTION              (C)
           33) TRIANGULAR                  (C)
           34) LOG LOGISTIC                (DELTA)
           35) VON-MISES                   (B)
           36) RECIPROCAL                  (B)
           37) BRADFORD                    (BETA)
           38) ASYMMETRIC DOUBLE EXPO      (K)
           39) TOPP AND LEONE              (K)

          Distributions with two shape parameters
            1) POWER-NORMAL                (P, SD)
            2) POWER-LOGNORMAL             (P, SD)
            3) FOLDED NORMAL               (M, SD)
            4) FOLDED CAUCHY               (M, SD)
            5) SKEWED T                    (LAMBDA, NU)
            6) NONCENTRAL T                (NU, LAMBDA)
            7) NONCENTRAL CHISQUARE        (NU, LAMBDA)
            8) LOG SKEWED NORMAL           (LAMBDA, SD)
            9) BETA                        (ALPHA, BETA)
           10) INVERTED BETA               (ALPHA, BETA)
           11) EXPONENTIAL POWER           (ALPHA, BETA)
           12) ALPHA                       (ALPHA, BETA)
           13) BETA NORMAL                 (ALPHA, BETA)
           14) ASYMMETRIC LOG DOUBLE EXPO  (ALPHA, BETA)
           15) GENERALZIED TOPP AND LEONE  (ALPHA, BETA)
           16) REFLECTED GENE TOPP LEONE   (ALPHA, BETA)
           17) G AND H                     (G, H)
           18) JOHNSON SB                  (ALPHA1, ALPHA2)
           19) JOHNSON SU                  (ALPHA1, ALPHA2)
           20) EXPONENTIATED WEIBULL       (GAMMA, THETA)
           21) GENERALIZED GAMMA           (GAMMA, C)
           22) INVERSE GAUSSIAN            (GAMMA, MU)
           23) RECIPROCAL INVERSE GAUSSIAN (GAMMA, MU)
           24) F                           (NU1, NU2)
           25) TWO-SIDED POWER             (THETA, N)
           26) GOMPERTZ                    (C, B)
           27) GENERALIZED MCLEISH         (ALPHA, A)
           28) GENERALIZED LOGISTC TYPE 4  (P, Q)

          Distributions with three or more shape parameters
            1) LOG SKEWED T                (LAMBDA, NU, SD)
            2) DOUBLY NONCENTRAL T         (NU, LAMBDA1, LAMBDA2)
            3) NONCENTRAL F                (NU1, NU2, LAMBDA)
            4) NONCENTRAL BETA             (ALPHA, BETA, LAMBDA)
            5) TRUNCATED EXPONENTIAL       (X0, M, SD)
            6) GENERALIZED EXPONENTIAL     (LAMBDA1, LAMBDA2, S)
            7) GOMPERTZ-MAKEHAM            (XI, LAMBDA, THETA)
            8) MIELKE BETA-KAPPA           (BETA, THETA, K)
            9) WAKEBY                      (GAMMA, BETA, DELTA)

           10) DOUBLY NONCENTRAL F         (NU1, NU2, LAMBDA1, LAMBDA2)
           11) TRUNCATED NORMAL            (A, B, M, SD)
           12) TRAPEZOID                   (A, B, C, D)
           13) LOG BETA                    (ALPHA, BETA, C, D)

           14) NORMAL MIXTURE              (MU1, SD1, MU2, SD2, P)
           15) BI-WEIBULL                  (SCALE1, GAMMA1, LOC2, SCALE2,
                                           GAMMA2)

           16) GENERALIZED TRAPEZOID       (A, B, C, D, NU1, NU3, ALPHA)
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    NORMAL KOLMOGOROV-SMIRNOV GOODNESS OF FIT TEST Y
    NORMAL KOLMOGOROV-SMIRNOV GOODNESS OF FIT TEST Y  SUBSET GROUP > 1
    CAUCHY KOLMOGOROV-SMIRNOV GOODNESS OF FIT TEST Y
    LOGNORMAL KOLMOGOROV-SMIRNOV GOODNESS OF FIT TEST X
    EXTREME VALUE TYPE 1 KOLMOGOROV-SMIRNOV GOODNESS OF FIT TEST X

    LET LAMBDA = 0.2
    TUKEY LAMBDA KOLMOGOROV-SMIRNOV GOODNESS OF FIT TEST X

    SET MINMAX = 1
    LET GAMMA = 2.0
    WEIBULL KOLMOGOROV-SMIRNOV GOODNESS OF FIT TEST X

    LET LAMBDA = 3
    POISSON KOLMOGOROV-SMIRNOV GOODNESS OF FIT TEST X

    NORMAL KOLMOGOROV-SMIRNOV GOODNESS OF FIT TEST Y X
    NORMAL KOLMOGOROV-SMIRNOV GOODNESS OF FIT TEST Y X1 X2

Note:
    There are several approaches for estimating the parameters of a
    distribution before applying the goodness of fit test.  PPCC plots
    combined with probability plots are an effective graphical approach
    if there are zero or one shape parameters.  Maximum likelihood 
    estimation is available for several distributions.  Least squares
    estimation can be applied for distributions for which maximum
    likelihood estimation is not available.
 
Note:
    The KOLMOGOROV-SMIRNOV GOODNESS OF FIT command automatically saves
    the following parameters.
 
        STATVAL   - value of the K-S goodness of fit statistic
        CUTUPP90  - 90% critical value (alpha = 0.10) for the K-S
                    goodness of fit test statistic
        CUTUPP95  - 95% critical value (alpha = 0.05) for the K-S
                    goodness of fit test statistic
        CUTUPP99  - 99% critical value (alpha = 0.01) for the K-S
                    goodness of fit test statistic

    These parameters can be used in subsequent analysis.

Default:
    Location and scale parameters default to zero and one.  Shape
    parameters must be explicitly specified.  There is no default
    distribution.
 
Synonyms:
    EV2 and FRECHET are synonyms for EXTREME VALUE TYPE 2.
    EV1 and GUMBEL are synonyms for EXTREME VALUE TYPE 1.
    FATIGUE LIFE is a synonym for FL.
    RECIPROCAL INVERSE GAUSSIAN is a synonym for RIG.
    IG is a synonym for INVERSE GAUSSIAN.
    SKEW LAPLACE is a synonym for SKEW DOUBLE EXPONENTIAL
    ASYMMETRIC LAPLACE is a synonym for ASYMMETRIC DOUBLE EXPONENTIAL

Related Commands:
    ANDERSON-DARLING TEST   = Perform Anderson-Darling test for goodness
                              of fit.
    CHI-SQUARE TEST         = Perform chi-square test for goodness of
                              fit.
    WILK-SHAPIRO TEST       = Perform Wilk-Shapiro test for normality.
    MAXIMUM LIKELIHOOD      = Perform maximum likelihood estimation for
                              several distributions.
    FIT                     = Perform least squares fitting.

    PROBABILITY PLOT        = Generates a probability plot.
    HISTOGRAM               = Generates a histogram.
    PPCC PLOT               = Generates probability plot correlation
                              coefficient plot.

Reference:
    "Handbook of Methods of Applied Statistics, Volume I",
    Chakravart, Laha, and Roy, John Wiley, 1967, pp. 392-394.

Applications:
    Distributional Analysis
 
Implementation Date:
    1998/12
    2001/10: GENERALIZED LAMBDA, JOHNSON SU,
             JOHNSON SB, INVERTED WEIBULL,
             LOG DOUBLE EXPONENTIAL
    2002/5:  TWO-SIDED POWER, BI-WEIBULL
    2003/5:  ERROR
    2004/1:  TRAPEZOID, GENERALIZED TRAPEZOID, FOLDED T,
             SKEWED T, SKEWED NORMAL, SLASH, INVERTED BETA,
             G AND H
    2004/5:  LOG SKEW NORMAL, LOG SKEW T, HERMITE, YULE
    2004/5:  Fixed a number of bugs for various distributions
    2004/6:  SKEW DOUBLE EXPONENTIAL, ASYMMETRIC DOUBLE EXPONENTIAL

Program:
    skip 25
    read zarr13.dat y
    .
    let m = mean y
    let s = standard deviation y
    let ksloc = m
    let ksscale = s
    normal kolmogorov smirnov goodness of fit test y
 
    The following output is generated.

           ********************************************************
           **  normal kolmogorov-smirnov goodness of fit test y  **
           ********************************************************
      
      
                       KOLMOGOROV-SMIRNOV GOODNESS OF FIT TEST
      
     NULL HYPOTHESIS H0:      DISTRIBUTION FITS THE DATA
     ALTERNATE HYPOTHESIS HA: DISTRIBUTION DOES NOT FIT THE DATA
     DISTRIBUTION:            NORMAL
        NUMBER OF OBSERVATIONS      =      195
      
     TEST:
     KOLMOGOROV-SMIRNOV TEST STATISTIC     =   0.3249392E-01
      
        ALPHA LEVEL         CUTOFF              CONCLUSION
                10%        0.08737               ACCEPT H0
                 5%        0.09739               ACCEPT H0
                 1%        0.11673               ACCEPT H0
  
-----KOLMOGOROV SMIRNOV TWO SAMPLE TEST ---------------------------
 
KOLMOGOROV SMIRNOV TWO SAMPLE
 
Name:
    ... KOLMOGOROV SMIRNOV TWO SAMPLE TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform a Kolmogorov-Smirnov two sample test that two data samples
    come from the same distribution.  Note that we are not specifying
    what that common distribution is.
 
Description:
    The one sample Kolmogorov-Smirnov (K-S) test is based on the
    empirical distribution function (ECDF).  Given N data points
    Y(1), Y(2), ..., Y(n), the ECDF is defined as

        E(i) = n(i)/N

    where n(i) is the number of points less than Y(i).  This is a
    step function that increases by 1/N at the value of each data
    point.  We can graph a plot of the empirical distribution
    function with a cumulative distribution function for a given
    distribution.  The one sample K-S test is based on the maximum
    distance between these two curves.  That is,

        D = max |F(Y(i)) - E(i)|

    where F is the theoretical cumulative distribution function.

    The two sample K-S test is a variation of this.  However, instead
    of comparing an empirical distribution function to a theoretical
    distribution function, we compare the two empirical distribution
    functions.  That is,

        D = max |E1(i) - E2(i)|

    where E1 and E2 are the empirical distribution functions for the
    two samples.  Note that we compute E1 and E2 at each point in
    both samples (that is both E1 and E2 are computed at each point
    in each sample).

    More formally, the Kolmogorov-Smirnov two sample
    test statistic can be defined as follows.

        H0:          The two samples come from a common distribution.
        Ha:          The two samples do not come from a common
                     distribution.

        Test         The Kolmogorov-Smirnov two sample test
        Statistic:   statistic is defined as

                       D = max |E1(i) - E2(i)|

                     where E1 and E2 are the empirical distribution
                     functions for the two samples.

        Significance alpha
        Level:

        Critical     The hypothesis regarding the distributional form is
        Region:      rejected if the test statistic, D, is greater than
                     the critical value obtained from a table.  There
                     are several variations of these tables in the
                     literature that use somewhat different scalings
                     for the K-S test statistic and critical regions.
                     These alternative formulations should be equivalent,
                     but it is necessary to ensure that the test statistic
                     is calculated in a way that is consistent with how
                     the critical values were tabulated.

                     Dataplot uses the critical values from
                     Chakravart, Laha, and Roy (see Reference: below).

    The quantile-quantile plot, bihistogram, and Tukey mean-difference
    plot are graphical alternatives.

Syntax 1:
    KOLMOGOROV SMIRNOV TWO SAMPLE TEST  <y1>  <y2>
                                <SUBSET/EXCEPT/FOR/qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Syntax 2:
    KOLMOGOROV SMIRNOV TWO SAMPLE TEST  <y1>  ... <yk>
                                <SUBSET/EXCEPT/FOR/qualification>
    where <y1> ... <yk> is a list of 2 to 30 response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax performs all the pairwise two sample Kolmogorov
    Smirnov tests.

Examples:
    KOLMOGOROV-SMIRNOV TWO SAMPLE TEST Y1 Y2
    KOLMOGOROV-SMIRNOV TWO SAMPLE TEST Y1 Y2  SUBSET Y2 > 0

Note:
    The KOLMOGOROV-SMIRNOV TWO SAMPLE TEST command automatically saves
    the following parameters.
 
        STATVAL   - value of the K-S two sample statistic
        CUTUPP90  - 90% critical value (alpha = 0.10) for the K-S
                    two sample test statistic
        CUTUPP95  - 95% critical value (alpha = 0.05) for the K-S
                    two sample test statistic
        CUTUPP99  - 99% critical value (alpha = 0.01) for the K-S
                    two sample test statistic

    These parameters can be used in subsequent analysis.

Note:
    The KOLMOGOROV SMIRNOV TWO SAMPLE TEST was updated to use the
    following command

        SET TWO SAMPLE TEST NUMBER OF PERCENTILES <value>

    By default, the Kolmogorov-Smirnov test is generated using all
    the points.  When the number of points gets large, this can result
    in this command taking a very long time.  Computing this test for
    a specified number of percentiles of the data allows this command
    to be executed quickly without sacrificing too much information.

Default:
    None
 
Synonyms:
    KS is a synonym for KOLMOGOROV SMIRNOV.
    The word test in the command is optional.
    TWO can be entered as 2.

    Some examples,

        KOLMOGOROV SMIRNOV 2 SAMPLE Y1 Y2
        KS 2 SAMPLE Y1 Y2
        KS TWO SAMPLE TEST Y1 Y2

Related Commands:
    KOMOGOROV SMIRNOV GOODNESS = Perform Kolmogorov-Snirnov goodness of
        OF FIT TEST              fit test.
    CHI-SQUARE TWO SAMPLE TEST = Perform chi-square two sample test.

    BIHISTOGRAM                = Generates a bihistogram.
    QUANTILE-QUANTILE PLOT     = Generates a quantile-quantile plot.
    TUKEY MEAN DIFFERENCE PLOT = Generates a Tukey mean difference plot.

Reference:
    Chakravart, Laha, and Roy (1967), "Handbook of Methods of Applied
    Statistics, Volume I", John Wiley, pp. 392-394.

    Press, Teukolsky, Vetterlling, and Flannery (1992), "Numerical
    Recipes in Fortan: The Art of Scientific Computing", Second Edition,
    Cambridge University Press, pp. 614-622.

Applications:
    Distributional Analysis
 
Implementation Date:
    1998/12
    2011/03: If more than two variables given, perform all pairwise tests
    2016/06: Added support for SET TWO SAMPLE TEST NUMBER OF PERCENTILES
    2016/06: Added KS as synonym for KOLMOGOROV SMIRNOV
 
Program 1:
    SKIP 25
    READ AUTO83B.DAT Y1 Y2
    .
    DELETE Y2 SUBSET Y2 < 0
    KOLMOGOROV-SMIRNOPV TWO SAMPLE TEST Y1 Y2
 
Program 2:
    let y1 = norm rand numb for i = 1 1 50
    let y2 = norm rand numb for i = 1 1 62
    let y3 = norm rand numb for i = 1 1 45
    .
    let y2 = 1.7*y2
    let y3 = 0.7*y3
    .
    set write decimals 5
    .
    two sample kolmogorov smirnov test  y1 y2 y3
    .
    let stat  = two sample kolm smir test y1 y2
    let cv95  = two sample kolm smir test critical value y1 y2
    let alpha = 0.9
    let cv90  = two sample kolm smir test critical value y1 y2
    let alpha = 0.99
    let cv99  = two sample kolm smir test critical value y1 y2
 
-----KRUSKAL WALLIS TEST-----------------------------------------
 
KRUSKAL WALLIS
 
Name:
    KRUSKAL WALLIS
 
Type:
    Analysis Command
 
Purpose:
    Perform a Kruskal Wallis test that k samples come from 
    identical populations.
 
Description:
    Analysis of Variance (ANOVA) is a data analysis technique
    for examining the significance of the factors (= independent
    variables) in a multi-factor model.  The one factor model can
    be thought of as a generalization of the two sample t-test.
    That is, the two sample t-test is a test of the hypothesis
    that two population means are equal.  The one factor ANOVA
    tests the hypothesis that k population means are equal.

    The Kruskal Wallis test can be applied in the one factor
    ANOVA case.  It is a non-parametric test for the situation
    where the ANOVA normality assumptions may not apply.  Although
    this test is for identical populations, it is designed to be
    sensitive to unequal means.

    Let N(i) (i = 1, 2, ..., k) represent the sample sizes for
    each of the k groups (i.e., samples) in the data.  Let N
    denote the sample size for all groups.  Next, rank the
    combined sample.  Then compute R(i) = the sum of the ranks
    for group i.  Then the Kruskal Wallis test statistic is:

         H = (1/S**2)*{SUM[i=1 to k][R(i)**2/N(i) - N*(N+1)**2/4}

    where

         S**2 = (1/(N-1))*(SUM[all ranks][R(X(ij)**2] - N*(N+1)**2/4)

    This statistic approximates a chi-square distribution with
    k-1 degrees of freedom if the null hypothesis of equal
    populations is true.  Each of the Ni should be at least 5
    for the approximation to be valid. 

    We reject the null hypothesis of equal population
    means if the test statistic H is greater than 
    CHIPPF(ALPHA,K-1) where CHIPPF is the chi-square percent
    point function 
 
    More formally,

        H0: All of the k population distribution functions are
            identical
        HA: At least one of the populations tends to yield larger
            observations than at least one of the other populations
        Test Statistic: H = (1/S**2)*{SUM[i=1 to k]
                            [R(i)**2/N(i) - N*(N+1)**2/4}
        Significance Level: ALPHA
        Critical Region: H > CHIPPF(ALPHA,K-1) where CHIPPF
                         is the chi-square percent point
                         function.
        Conclusion: Reject the null hypothesis if the test
                    statistic is in the critical region.

Syntax 1:
    KRUSKAL WALLIS  <y>  <x>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response (= dependent) variable;
          <x> is the factor (= independent) variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    MULTIPLE KRUSKAL WALLIS  <y1> ... <yk>
                             <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of 1 to 30 response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for the case when the data for each group is
    stored in a separate variable.  This syntax accepts matrix arguments.

Examples:
    KRUSKAL WALLIS Y X
    KRUSKAL WALLIS Y X  SUBSET X = 1 TO 4
    MULTIPLE KRUSKAL WALLIS Y1 Y2 Y3 Y4
    MULTIPLE KRUSKAL WALLIS Y1 TO Y4
 
Note:
    Conover lists the following assumptions for the Kruskal Wallis test:

       1) All samples are random samples from their respective populations.

       2) In addition to independence within each sample, there is mutual
          independence among the various samples.

       3) The measurement scale is at least ordinal (i.e., the data can
          be ranked).

       4) Either the k population distribution functions are identical or
          else some of the populations tend to yield larger values than
          other populations do.

Note:
    If the hypothesis of identical distributions is rejected,
    you can perform a multiple comparisons procedure to
    determine which pairs of populations tend to differ.

    The populations i and j seem to be different if the
    following inequality is satisfied:

       |R(i)/N(i) - R(j)/n(j)| > TPPF(1-(alpha/2))*
                                 SQRT(S**2*(N-1-T)/(N-k))*
                                 SQRT((1/N(i)) + (1/N(j)))

    with TPPF and T denoting the t percent point function with N - k
    degrees of freedom and the Kruskal-Wallis test statistic, respectively.

Note:
    Prior to 10/2004, Dataplot used the formulation of the
    Kruskal-Wallis test as given in the Walpole and Meyers
    reference.  We switched to the Conover formulation because
    this reference is more readily available, it provides for
    ties, and it provides a multiple comparisons procedure.

    For the case of no ties, the Conover formulation is
    equivlent to the Walpole and Meyers formulation.  The
    Dataplot code now uses the formula that accomodates ties.

    For earlier versions of Dataplot, the formulation of the
    Kruskal-Wallis test is given here.

    Let Ni (i = 1, 2, ..., k) represent the sample sizes for
    each of the k groups (i.e., samples) in the data.  Next,
    rank the combined sample.  Then compute Ri = the sum of
    the ranks for group i.  Then the Kruskal Wallis test
    statistic is:

         H = [12/(N(N+1)] SUM[Ri**2/Ni] - 3(N+1)

    This statistic approximates a chi-square distribution with
    k-1 degrees of freedom if the null hypothesis of equal
    populations is true.  Each of the Ni should be at least 5
    for the approximation to be valid. 

    We reject the null hypothesis of equal population
    means if the test statistic H is greater than 
    CHIPPF(ALPHA,K-1) where CHIPPF is the chi-square percent
    point function 

Note:
    The output was reformatted for the 2011/6 version.  The
    SET WRITE DECIMALS command can now be used to specify the number
    of digits to include in the output.

Note:
    The following statistics are also supported:

        LET A = KRUSKAL WALLIS TEST         Y X
        LET A = KRUSKAL WALLIS TEST CDF     Y X
        LET A = KRUSKAL WALLIS TEST PVALUE  Y X

    with Y denoting the response variable, X denoting the group-id
    variable, and ALPHA denoting the significance level for the
    critical value.

    In addition to the above LET command, built-in statistics are
    supported for about 20+ different commands (enter HELP STATISTICS
    for details).

Default:
    None
 
Synonyms:
    The following are synonyms for KRUSKAL WALLIS:

        KRUSKAL WALLIS TEST
        KRUSKAL TEST
 
Related Commands:
    ANOVA                 = Perform an analysis of variance.
    MEDIAN POLISH         = Carries out a robust ANOVA.
    YATES ANALYSIS        = Analyze a Yate's design.
    BLOCK PLOT            = Generate a block plot.
    DEX SCATTER PLOT      = Generates a dex scatter plot.
    DEX ... PLOT          = Generates a dex plot for a statistic.
    DEX ... EFFECTS PLOT  = Generates a dex effects plot for a
                            statistic.
    T TEST                = Carries out a t test.
    RANK SUM TEST         = Perform a rank sum test.
    SIGNED RANK TEST      = Perform a signed rank test.
    PLOT                  = Plots (e.g., residuals and GANOVA ).
 
Reference:
    W. J. Conover, (1999).  "Practical Nonparameteric Statistics",
    Third Edition, Wiley, pp. 288-297.

    "Probability and Statistics for Engineers and Scientists",
    2nd ed., Walpole and Myers, MacMillian, 1978.
 
Applications:
    Analysis of Variance
 
Implementation Date:
    1999/8
    2004/10: Modified test to use formulation in Conover.
    2011/06: Reformatted the output, support for SET WRITE DECIMALS
    2011/06: Support for MULTIPLE option
 
Program:
    SKIP 25
    READ SPLETT2.DAT Y MACHINE
    SET WRITE DECIMALS 5
    KRUSKAL WALLIS Y MACHINE

-----K SAMPLE PERMUATION TEST---------------------------------
 
K SAMPLE PERMUATION TEST
 
Name:
    K SAMPLE <STATISTIC> PERMUATION TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform a k-sample permutation test for a specified statistic.
 
Description:
    Given random variables Y and X, where Y is a response variable and X
    is a group-id variable, with sample size n, k-sample permutation tests
    are performed as follows

       1. Compute the desired statistic for the original data.

       2. Generate a permutation of the response data.  Then compute the
          desired statistic for the permutation.

       3. Repeat step 3 NITER number of times.

    The NITER computed statistics represent the reference distribution.
    The statistic for the original data is compared to this reference
    distribution.  For example, the cut-offs for a two-sided 95% test are
    obtained from the 2.5% and 97.5% percentiles of the reference
    distribution.

    The permutation test is based on all possible permutations of the
    data.  However, the number of permutations grows rapidly as the sample
    size increases.  sampling a subset of all possible permutations
    provides a reasonable approximation for the permutation test.  By
    default, Dataplot generates 4,000 iterations.  To change this, enter
    the command

          SET PERMUTATION TEST SAMPLE SIZE <value>

    If <value> is less than 100, it will be set to 100.  If <value>
    is greater than 100,000, it will be set to 100,000.

    The specified statistic should be one that can be computed from a
    single response variable with a corresponding group-id variable.

    This test is most commonly used with F-statistic obtained from a
    one way analysis of variance.

    Permutation tests assume the observations are independent.  However,
    no distributional assumptions are made about the response variable.

Syntax:
    <LOWER TAILED/UPPER TAILED> K SAMPLE PERMUATION TEST <y> <x>
                                <SUBSET/EXCEPT/FOR qualification>
    where <stat> is the desired statistic;
          <y> is the response variable;
          <x> is the group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If LOWER TAILED is specified, a lower tailed test is performed.  If
    UPPER TAILED is specified, an upper tailed test is performed.  If
    neither LOWER TAILED or UPPER TAILED is specified, a two-tailed test
    is performed.

Examples:
    K SAMPLE ONE WAY ANOVA F STATISTIC PERMUATION TEST Y X
    UPPER TAILED K SAMPLE ONE WAY ANOVA F STATISTIC PERMUATION TEST Y X
    UPPER TAILED K SAMPLE KRUSKAL WALLIS TEST PERMUATION TEST Y X

Note:
    This test only works for statistics based on a single response
    variable and a group-id variable.  Currently, the following
    statistics are supported

         ONE WAY ANOVA F STATISTIC
         ONE WAY ANOVA SUM OF SQUARES TOTAL
         ONE WAY ANOVA SUM OF SQUARES TREATEMENT
         ONE WAY ANOVA SUM OF SQUARES ERROR
         ONE WAY ANOVA MEAN SQUARE ERROR
         ONE WAY ANOVA MEAN SQUARE TREATMENT
         KRUSKAL WALLIS TEST
         REPEATABILITY STANDARD DEVIATION
         REPRODUCIBILITY STANDARD DEVIATION
         ANDERSON DARLING K SAMPLE TEST
         COCHRAN VARIANCE OUTLIER TEST
         COCHRAN MINIMUM VARIANCE OUTLIER TEST
         SQUARED RANKS TEST
         MEDIAN TEST

    Of these, the ONE WAY ANOVA F STATISTIC and KRUSKAL WALLIS TEST
    statisics are probably the ones of most interest.

Note:
    This routine uses a random permutation algorithm suggested by Knuth.
    Specifically, it adapts the RANDPERM routine of Knoble. 

Note:
    The following parameters are saved after the k sample
    permutation test is performed.

         STATVAL   - value of the test statistic
         STATCDF   - CDF of the test statistic
         PVALUE    - p-value of the two tailed test statistic
         PVALUELT  - p-value of the lower tailed test statistic
         PVALUEUT  - p-value of the upper tailed test statistic

         P80       - 80%   upper critical value
         P90       - 90%   upper critical value
         P95       - 95%   upper critical value
         P975      - 97.5% upper critical value
         P99       - 99%   upper critical value
         P995      - 99.5% upper critical value
         P999      - 99.9% upper critical value

         P20       - 20%   lower critical value
         P10       - 10%   lower critical value
         P05       - 5%    lower critical value
         P025      - 2.5%  lower critical value
         P01       - 1%    lower critical value
         P005      - 0.5%  lower critical value
         P001      - 0.1%  lower critical value

Note:
    To generate multiple comparisons for the ONE WAY F STATISTIC case,
    you can perform a two sample permutation test for the pairwise factor
    levels.  This is demonstrated in the program example below.

    Note that although this example compares differences of means,
    you could use other location statistics such as the MEDIAN or
    BIWEIGHT LOCATION.

Default:
    The number of permutations defaults to 4,000.
 
Synonyms:
    None
 
Related Commands:
    TWO SAMPLE PERMUTATION TEST = Perform a 2-sample permutation test.
    LINEAR RANK SUM TEST        = Perform a 2-sample linear rank sum test.
    ONE WAY ANOVA               = Perform a one-way analysis of variance.
    KRUSKAL WALLIS TEST         = Perform a k-sample Kruskal-Wallis test.
    MEDIAN TEST                 = Perform a k-sample medians test.
    SQUARED RANKS TEST          = Perform a k-sample squared ranks test
                                  for homogeneous variances.

References:
    Higgins (2004), "Introduction to Modern Nonparametric Statistics,"
    Duxbury Press, Chapter 3.

    Knuth (1998), "The Art of Computer Programming: Volume 2 Seminumerical
    Algorithms, Third Edition", Section 3.4.2, Addison-Wesley.

    Knoble RANDPERM algorithm downloaded from:
    "http://coding.derkeiler.com/Archive/Fortran/comp.lang.fortran/
    2006-03/msg00748.html"

Applications:
    K Sample Analysis
 
Implementation Date:
    2023/09:
 
Program 1:
    set permutation test sample size 5000
    set random number generator fibbonacci congruential
    seed 88807
    .
    . Step 1:   Create the data (from Higgins, p. 85)
    .
    read x y
     1    6.08
     1   22.29
     1    7.51
     1   34.36
     1   23.68
     2   30.45
     2   22.71
     2   44.52
     2   31.47
     2   36.81
     3   32.04
     3   28.03
     3   32.74
     3   23.84
     3   29.64
    end of data
    .
    . Step 2:   Perform the permutation test
    .
    upper tailed k sample one way anova f statistic permutation test y x
    .
    .           Step 3: Plot the results
    .
    title offset 7
    title case asis
    label case asis
    y1label Count
    x1label One Way Anova F-Statistic for Permutations
    
    let statval = round(statval,4)
    let p95  = round(p95,3)
    let p99  = round(p99,3)
    let pval = round(pvalueut,4)
    let statcdf = round(statcdf,4)
    .
    x2label color red
    x2label One Way Anova F-Statistic for Original Sample: ^statval
    x3label color blue
    x3label 95 Percentile: ^P95, 99 Percentile: ^P99
    xlimits -5.0 10.0
    let niter = 5000
    skip 1
    read dpst1f.dat z
    title Histogram of One Way Anova F Statistic for ^niter Permutationscr() ...
          (Pvalue: ^pval, CDF: ^statcdf)
    .
    histogram z
    .
    line color red
    line dash
    line thickness 0.3
    drawdsds statval 20 statval 90
    line thickness 0.1
    line color blue
    line dash
    drawdsds p95 20 p95 90
    drawdsds p99 20 p99 90
    .
    .           Step 4: Multiple comparisons
    .
    let xdist = distinct x
    let ndist = size xdist
    let icnt = 0
    if ndist >= 3
       loop for k = 1 1 ndist
           let xval1 = xdist(k)
           let jstrt = k + 1
           loop for j = jstrt 1 ndist
               let xval2 = xdist(j)
               let ytemp1 = y
               let ytemp2 = y
               retain ytemp1 subset x = xval1
               retain ytemp2 subset x = xval2
               two sample mean permutation test ytemp1 ytemp2
               let icnt = icnt + 1
               let group1(icnt) = xval1
               let group2(icnt) = xval2
               let pvalmc(icnt)   = pvalue2t
               delete ytemp1 ytemp2
           end of loop
       end of loop
    end of if
    write1 ksamp_mc.out "   Group-ID One   Group-ID Two         P-Value"
    write1 ksamp_mc.out "----------------------------------------------"
    write1 ksamp_mc.out group1 group2 pvalmc

Program 2:
    set permutation test sample size 5000
    set random number generator fibbonacci congruential
    seed 49217
    .
    . Step 1:   Create the data (from Higgins, p. 85)
    .
    read x y
     1    6.08
     1   22.29
     1    7.51
     1   34.36
     1   23.68
     2   30.45
     2   22.71
     2   44.52
     2   31.47
     2   36.81
     3   32.04
     3   28.03
     3   32.74
     3   23.84
     3   29.64
    end of data
    .
    . Step 2:   Perform the permutation test
    .
    echo on
    upper tailed k sample one way anova f statistic permutation test y x
    upper tailed k sample kruskal wallis test permutation test y x
    kruskal wallis y x
    upper tailed k sample squared ranks test permutation test y x
    squared ranks y x
    upper tailed k sample anderson darling k sample test permutation test y x
    anderson darling k sample test y x
    upper tailed k sample cochran variance outlier test permutation test y x
    cochran variance outlier test y x
    upper tailed k sample median test permutation test y x
    median test y x
    k sample common coefficient of variation permutation test y x
    common coefficient of variation test y x
    echo off

-----KS PLOT-------------------------------------------------------
 
KS PLOT
 
Name:
    ... KS PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a Kolmogorov-Smirnov plot.
 
Description:
    The Kolmogorov-Smirnov (or KS) plot is a variant of the ppcc plot.
    A ppcc plot is a graphical data analysis technique for determining
    that member of the specified distributional family which provides
    a "best" distributional fit to the data.  The ppcc plot is based on
    the following two ideas:

        1) The "straightness" of the probability plot is a good measure
           of distributional fit.  That is, the "best" distributional
           fit is the one with the most linear probability plot.

        2) The correlation coefficient of the points on the
           probabability plot is a good measure of the "straightness"
           (i.e., linearity) of the probability plot.

    The KS plot modifies the ppcc plot by using the value of the
    Kolmogorov-Smirnov goodness of fit statistic as the measure of
    distributional fit rather than the correlation coefficient of the
    probability plot.  For the KS plot, we are looking for the value
    of the shape parameter that minimizes the Kolmogorov-Smirnov
    statistic.

    The KS plot is formed by selecting a value of the shape parameter
    and computing the value of the Kolmogorov-Smirnov goodness of
    fit test.  The KS plot then consists of:

       Vertical   axis = Kolmogorov-Smirnov goodness of fit value
                         for the given value of the shape parameter;
       Horizontal axis = distributional family parameter value (i.e.,
                         the value of the shape parameter.

    The value of the distributional parameter (on the horizontal axis)
    which corresponds to the minimum of the KS plot curve (on the
    vertical axis) indicates the best-fit member of the family.

    One complication of the KS plot is that it is not invariant to
    the choice of location and scale parameters.  There are two
    possible solutions to this.

       1) By default, the KS plot will generate a probability plot
          for each value of the shape parameter.  It will then use
          the intercept and slope of the line fitted to the probability
          plot as the estimates of location and scale.

          For distributions that are bounded (e.g., X has to be
          positive), these intial estimates may be tweaked in order
          to obtain values of location and scale that result in
          the data being in acceptable domain of the distribution.

       2) You can specify the desired values of the location and scale
          parameters by entering the commands

              LET KSLOC = <value>
              LET KSSCALE = <value>

          In this case, the KS plot will execute significantly faster
          since it does not have to generate a probability plot for
          each value of the shape parameter.

    The KS plot can be used with distributions that have two shape
    parameters.  Dataplot supports two formats for the KS plot with
    two shape parameters:

        1) As in the one shape parameter case, the Y axis contains
           the value of the KS statistic.  The X axis contains the
           value of the second shape parameter.  Each value of the
           first shape parameter are represented by a separate trace
           (i.e., curve) on the plot.

        2) Alternatively, you can generate a 3D wireframe plot.

    You can specify which format to use with the command

        SET PPCC FORMAT <TRACE/3D>

    KS plots are available for the following continuous distributional
    families (with the distributional parameter in parentheses) with
    one shape parameter:

      1) Weibull                         (gamma)
      2) double weibull                  (gamma)
      3) inverted weibull                (gamma)
      4) gamma                           (gamma)
      5) double gamma                    (gamma)
      6) log gamma                       (gamma)
      7) inverted gamma                  (gamma)
      8) Wald                            (gamma)
      9) fatigue life                    (gamma)
     10) Pareto                          (gamma)
     11) Pareto second kind              (gamma)
     12) generalized Pareto              (gamma)
     13) generalized half logistic       (gamma)
     14) extreme value type 2            (gamma)
     15) generalized extreme value       (gamma)
     16) extreme value                   (gamma, combines Weibull,
                                         extreme value type 2)
     17) geometric extreme exponential   (gamma)
     18) Tukey lambda                    (lambda)
     19) skew normal                     (lambda)
     20) skew double exponential         (lambda)
     21) t                               (nu)
     22) folded t                        (nu)
     23) chi-squared                     (nu)
     24) chi                             (nu)
     25) generalized logistic            (alpha)
     26) generalized logistic type 2     (alpha)
     27) generalized logistic type 3     (alpha)
     28) generalized logistic type 5     (alpha)
     29) log double exponential          (alpha)
     30) error                           (alpha)
     31) McLeish                         (alpha)
     32) lognormal                       (sd)
     33) power-normal                    (p)
     34) Von Mises                       (b)
     35) reciprocal                      (b)
     36) log-logistic                    (delta)
     37) wrapped cauchy                  (c)
     38) power function                  (c)
     39) Bradford                        (beta)
     40) Topp and Leone                  (beta)
     41) asymmetric double exponential   (k)
 
    KS plots are available for the following continuous distributional
    families (with the distributional parameter in parentheses) with two
    shape parameters:

      1) inverse Gaussian                (gamma, mu)
      2) reciprocal inverse gaussian     (gamma, mu)
      3) generalized gamma               (gamma, c)
      4) exponentiated Weibull           (gamma, theta)
      5) exponential power               (alpha, beta)
      6) beta                            (alpha, beta)
      7) inverted beta                   (alpha, beta)
      8) beta-normal                     (alpha, beta)
      9) asymmetric log double expo      (alpha, beta)
     10) generalized Topp and Leone      (alpha, beta)
     11) reflected gene Topp and Leone   (alpha, beta)
     12) log beta                        (alpha, beta, assume
                                         c and d known)
     13) two-sided power                 (theta, n)
     14) Johnson SU                      (alpha1, alpha2)
     15) Johnson SB                      (alpha1, alpha2)
     16) alpha                           (alpha1, alpha2)
     17) Gompertz                        (c, b)
     18) g and h                         (g, h)
     19) F                               (nu1, nu2)
     20) log skew normal                 (lambda, sd)
     21) power lognormal                 (nu, sd)
     22) folded normal                   (mu, sd)
     23) folded Cauchy                   (loc, scale)
     24) skew t                          (nu, lambda)
     25) noncentral t                    (nu, lambda)
     26) noncentral chi-square           (nu, lambda)
     27) truncated exponential           (m, sd, assume truncation point,
                                         X0, is known)
     28) generalized Tukey-Lambda        (lambda3, lambda4)
     29) Gompertz-Makeham                (eta, zeta)
     30) generalized asymmetric Laplace  (k, tau or mu, tau)
     31) generalized McLeish             (alpha, a)
     32) trapezoid                       (b, c, assume a and d known)
     33) generalized logistic type 4     (p, q)

    KS plots are available for the following discrete distributional
    families (with the distributional parameter in parentheses):

      1) geometric               (p)
      2) Yule                    (p)
      3) Poisson                 (lambda)
      4) binomial                (p, assume n known)
      5) logarithmic series      (theta)
      6) Consul                  (theta or m)
      7) zeta                    (alpha)
      8) Hermite                 (alpha, beta)
      9) beta geometric          (alpha, beta)
     10) beta-binomial           (alpha, beta assume n known)
     11) Katz                    (alpha, beta)
     12) negative binomial       (k, p)
     13) zipf                    (alpha, n)
     14) discrete Weibull        (beta, q)
     15) Borel-Tanner            (lambda, k)
     16) Lagrange Poisson        (lambda, theta)
     17) Polya-Aeppli            (theta, p)
     18) lost games              (p, n)
     19) generalized loga series (theta, beta)
     20) geeta                   (theta, beta or mu, beta)
     21) generalized lost games  (p, a, assume j known)

    Note that the Kolmogorov-Smirnov goodness of fit test is
    undefined for discrete distribution.  So for discrete
    distributions, the chi-square goodness of fit statistic is
    used.

    At this point we have done limited testing of the KS plot
    relative to the ppcc plot.  However, some preliminary
    simulations suggest the following:

       1) For continuous distributions, the KS plot and ppcc
          plot both generate reasonable results for most supported
          distributions.  The KS plot does not seem to have any
          notable advantage over the PPCC plot.

       2) For continuous distributions with two shape parameters,
          the KS plot seems to work better than the ppcc plot.

       3) For discrete distributions, the KS plot generates
          smoother plots than the ppcc plot.
        
     In summary, we recommend staying with the ppcc plot for
     continuous distributions with one shape parameter.  However,
     for continuous distributions with two shape parameters or
     discrete distributions, the KS plot may provide better fits.

Syntax 1: (where have raw data only)
    <family>  KS  PLOT  <x>   <SUBSET/EXCEPT/FOR/qualification>
    where <x> is the variable of raw data values under analysis;
          <family> is one of the distributions listed above:
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2: (where have frequencies at each distinct data value)
    <family>  KS  PLOT  <y>  <x>   <SUBSET/EXCEPT/FOR/qualification>
    where <y> is the variable of pre-computed frequencies;
          <x> is the variable of distinct values for the variable
              under analysis;
          <family> is one of the families listed above;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    Note: Currently, the KS plot for the case of two shape
    parameters or discrete distributions is not implemented for the
    case where the data is given in frequency format.

Examples:
    LAMBDA KS PLOT X
    T KS PLOT X
    EXTREME VALUE TYPE 2 KS PLOT X
    POISSON KS PLOT X
    LAMBDA KS PLOT F X
 
Note:
    The KS and ppcc plot have several attractive features for
    fitting.

       1) These methods have general applicability.  Basically,
          if you can generate the percent point and cumulative
          distribution functions for a distribution, it is possible
          to generate KS and ppcc plots (the ppcc plot only requires
          the percent point function).

       2) When used with the probability plot, these methods
          provide a convenient method for obtaining estimates for
          location and scale.  Maximum likelihood methods can at
          times have numerical difficulties when estimates for
          location or scale parameters are needed.

       3) The graphical form of these plots can show itervals
          of the shape parameter that are likely to generate
          reasonable results.

    Some disadvantages of these methods are:

       1) If the percent point function (or cumulative distribution)
          is expensive or difficult to compute, these methods can
          become impractical.  If the functions have relatively
          simple closed forms, then these plots can be quite
          fast even for relatively large data files.

       2) These plots do generate explicit interval estimates for
          the estimated parameters.  The plots can show reasonable
          neighborhoods for the shape parameters, but they do not
          return explicit confidence interals.

       3) These plots work best for the case with one shape
          parameter.  They can be reasonably extended to the
          case with two shape parameters (although the amount
          of computing required is more likely to be an issue).
          However, they do not reasonably extend to more than
          two shape parameters. 

Note:
    The range of parameter is determined automatically.  However, if
    you wish to restrict the range, you can specify the lower and upper
    limits by appending a 1 or 2 to the parameter name and assigning
    a value.  For example, to restrict a Weibull KS plot to values
    0.5 and 20, do the following:

       LET GAMMA1 = 0.5
       LET GAMMA2 = 20
       WEIBULL KS PLOT Y

    A common use of this is to obtain a refinement of the estimate
    of the shape parameter.  That is, an initial iteration (typically
    just the default values of the parameter) is used to identify
    the appropriate neighborhood of the optimal value of the shape
    parameter.  Then a second iteration of the KS PLOT is generated
    with the parameter restricted to a much narrower range of values.
    Although this iteration can be repeated as many times as you
    like, for practical purposes a two iterations is typically
    sufficient.

Note:
    The KS PLOT automatically saves several parameters.  The MINKS
    parameter contains the minimum KS goodness of fit statistic that
    was computed and the SHAPE parameter contains the value of the
    estimated distributional parameter (e.g., GAMMA for the Weibull
    distribution) that corresponds to MAXPPCC.  The values of KSLOCS
    and KSSCALES will contain the estimates of location and scale for
    the optimal value of the shape parameter.

    In the case of two shape parameters, these are saved as SHAPE1 and
    SHAPE2.

Note:
    For the truncated exponential distribution, we assume that the
    truncation parameter, X0, is known.  To set this value, enter

        LET X0 = <value>

    before generating the ppcc plot.

    For the noncentral t and noncentral chi-square distributions,
    we can fix the value of the degrees of freedom parameter to a
    single value.  In this case, the ppcc plot reverts to a
    one shape parameter plot.  Enter the commands

        LET NU1 = <value>
        LET NU2 = <value>

    where <value> is the same for NU1 and NU2.
 
Note:
    The SET MINMAX command can be used to specify a minimum or maximum
    Weibull distribution.  A value of 1 specifies a maximum Weibull
    distribution and a value of 2 specifies a minimum Weibull
    distribution.
 
Note:
    For the PPCC PLOT and the KS PLOT, the location and scale
    parameters are estimated via the probability plot.  For
    long-tailed distributions, more accurate estimates may be
    obtained by applying a biweight fit of the probability plot.
    To specify this option, enter the command

         SET PPCC PLOT LOCATION SCALE BIWEIGHT

    To restore the use of the regular least squares estimates
    of location and scale, enter

         SET PPCC PLOT LOCATION SCALE DEFAULT

    This option is primarily for the KS PLOT.  Since the
    PPCC PLOT is invariant to location and scale, we can
    simply wait to compute the biweight location and scale
    on the final probability plot.  However, the KS PLOT is
    not invariant for location and scale and for long-tailed
    distributions this option can sometimes lead to improved
    estimates for the parameters.

Default:
    None
 
Synonyms:
    KOLMOGOROV SMIRNOV PLOT is a synonm for KS PLOT.

    FRECHET and EV2 are synonyms for EXTREME VALUE TYPE 2.

    LAMBDA KS PLOT and TUKEY KS PLOT are synonyms for TUKEY LAMBDA
    KS PLOT.

    STUDENT T KS PLOT is a synonym for T KS PLOT.

    The CHISQUARE term can be specified as CHISQUARE or CHI SQUARE.

    FL KS PLOT, BRIN SAUNDERS KS PLOT, and SAUNDERS BRIN are
    synonyms for FATIGUE LIFE KS PLOT.

    IG KS PLOT is a synonym for INVERSE GAUSSIAN KS PLOT.

    RIG KS PLOT is a synonym for RECIPROCAL INVERSE GAUSSIAN PPCC
    PLOT.

    GEP KS PLOT and GP KS PLOT are synonyums for GENERALIZED
    PARETO PLOT.
 
    LOGNORMAL KS PLOT and LOG-NORMAL KS PLOT are synonyms for
    LOG NORMAL KS PLOT.

    POWER LOG-NORMAL KS PLOT and POWER LOGNORMAL KS PLOT are
    synonyms for POWER LOG NORMAL KS PLOT.

    VONMISES KS PLOT and VON-MISES KS PLOT are synonyms for
    VON MISES KS PLOT.

    LOGLOGISTIC KS PLOT and LOG-LOGISTIC KS PLOT are synonyms for
    LOG LOGISTIC KS PLOT.

Related Commands:
    KOLM SMIR GOODNESS OF FIT   = Performs a Kolmogorov-Smirnov
                                  goodness of fit test.
    PPCC PLOT                   = Generates a ppcc plot.
    PROBABILITY PLOT            = Generates a probability plot.
    MAXIMUM LIKELIHOOD          = Generate maximum likelihood
                                  estimates for a number of
                                  distributions.
 
Reference:
    "The Probability Plot Correlation Coefficient Test for Normality",
    James J. Filliben.  Technometric, Vol. 17, No. 1, February 1975.
 
    "Practical Nonparametric Statistics", Third Edition, Conover,
    Wiley, 1999, chapter 6.

Applications:
    Distributional Modeling
 
Implementation Date:
    2004/5

Program 1:
    LET NU = 10
    LET LAMBDA = 1.4
    LET Y = NONCENTRAL T RAND NUMBERS FOR I = 1 1 100
    NONCENTRAL T KS PLOT Y
 
Program 2:
    LET THETA = 0.7
    LET Y = LOGARITHMIC SERIES RAND NUMBERS FOR I = 1 1 100
    LET THETA1 = 0.3
    LET THETA2 = 0.9
    LOGARITHMIC SERIES KS PLOT Y
 
-----KUMCDF (LET)--------------------------------
 
KUMCDF
 
Name:
    KUMCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Kumaraswamy cumulative distribution function
    with shape parameters alpha and beta.
 
Description:
    The standard Kumaraswamy distribution has the following
    cumulative distribution function:

       F(x;alpha,beta) = 1 - (1 - x**alpha)**beta
                         0 <= x <= 1; alpha, beta > 0
 
    with alpha and beta denoting the shape parameters.

    This distribution can be extended with lower and upper
    bound parameters.  If a and b denote the lower and upper
    bounds, respectively, then the location and scale 
    parameters are:

    The lower and upper limits are related to the location
    and scale parameters as follows:

        location = a
        scale    = b - a

    The general form of the distribution can then be found
    by using the relation

        F(x;alpha.beta,a,b) = F((x-a)/(b-a);alpha,beta,0,1)

    This distribution has been proposed as a more tractable
    alternative to the beta distribution.

Syntax:
    LET <y> = KUMCDF(<x>,<alpha>,<beta>,<a>,<b>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable containing
              values in the interval (a,b);
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed Kumaraswamy cdf value
              is stored;
          <alpha> is a positive number, parameter, or variable
              that specifies the first shape parameter;
          <beta> is a positive number, parameter, or variable that
              specifies the second shape parameter;
          <a> is a number, parameter, or variable that
              specifies the lower limit;
          <b> is a number, parameter, or variable that
              specifies the upper limit;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <a> and <b> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = KUMCDF(0.3,0.2,1.2)
    LET Y = KUMCDF(X,0.5,2)
    PLOT KUMCDF(X,2,3) FOR X = 0  0.01  1
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    KUMPDF = Compute the Kumaraswamy probability density
             function.
    KUMPPF = Compute the Kumaraswamy percent point function.
    RGTPDF = Compute the reflected generalized Topp and Leone
             probability density function.
    GTLPDF = Compute the generalized Topp and Leone probability
             density function.
    TOPPDF = Compute the Topp and Leone probability density
             function.
    TSPPDF = Compute the two-sided power probability density
             function.
    BETPDF = Compute the beta probability density function.
    TRIPDF = Compute the triangular probability density function.
    TRAPDF = Compute the trapezoid probability density function.
    UNIPDF = Compute the uniform probability density function.
    POWPDF = Compute the power probability density function.
    JSBPDF = Compute the Johnson SB probability density function.
 
Reference:
    Kumaraswamy (1980), "A Generalized Probability Density
    Function for Double-Bounded Random Processes", Journal of
    Hydrology, 46: 79-88.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/11
 
Program:
    CASE ASIS
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 3
    .
    LET ALPHA = 2
    LET BETA  = 3
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT KUMCDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 1.5
    LET BETA  = 6
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT KUMCDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 1.5
    LET BETA  = 2
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT KUMCDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 1.5
    LET BETA  = 1
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT KUMCDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 0.5
    LET BETA  = 2
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT KUMCDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 0.5
    LET BETA  = 1
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT KUMCDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 0.5
    LET BETA  = 0.75
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT KUMCDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 0.5
    LET BETA  = 0.25
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT KUMCDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 1
    LET BETA  = 1
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT KUMCDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Kumaraswamy Cumulative Distribution Functions
 
-----KUMPDF (LET)--------------------------------
 
KUMPDF
 
Name:
    KUMPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Kumaraswamy probability density function with
    shape parameters alpha and beta.
 
Description:
    The standard Kumaraswamy distribution has the following
    probability density function:

       f(x;alpha,beta) = alpha*beta*x**(alpha-1)*
                         (1-x**alpha)**(beta-1)
                         0 <= x <= 1; alpha, beta > 0
 
    with alpha and beta denoting the shape parameters.

    This distribution can be extended with lower and upper
    bound parameters.  If a and b denote the lower and upper
    bounds, respectively, then the location and scale 
    parameters are:

    The lower and upper limits are related to the location
    and scale parameters as follows:

        location = a
        scale    = b - a

    The general form of the distribution can then be found
    by using the relation

        f(x;alpha,beta,a,b) = f((x-a)/(b-a);alpha,beta,0,1)/(b-a)

    This distribution has been proposed as a more tractable
    alternative to the beta distribution.

Syntax:
    LET <y> = KUMPDF(<x>,<alpha>,<beta>,<a>,<b>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable containing
              values in the interval (a,b);
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed Kumaraswamy pdf value
              is stored;
          <alpha> is a positive number, parameter, or variable
              that specifies the first shape parameter;
          <beta> is a positive number, parameter, or variable that
              specifies the second shape parameter;
          <a> is a number, parameter, or variable that
              specifies the lower limit;
          <b> is a number, parameter, or variable that
              specifies the upper limit;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <a> and <b> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = KUMPDF(0.3,0.2,1.2)
    LET Y = KUMPDF(X,0.5,2)
    PLOT KUMPDF(X,2,3) FOR X = 0  0.01  1
 
Note:
    Kumaraswamy random numbers, probability plots, and goodness
    of fit tests can be generated with the commands:

       LET ALPHA = <value>
       LET BETA = <value>
       LET A = <value>
       LET B = <value>
       LET Y = KUMARASWAMY RANDOM NUMBERS FOR I = 1 1 N
       KUMARASWAMY PROBABILITY PLOT Y
       KUMARASWAMY PROBABILITY PLOT Y2 X2
       KUMARASWAMY PROBABILITY PLOT Y3 XLOW XHIGH
       KUMARASWAMY KOLMOGOROV SMIRNOV GOODNESS OF FIT Y
       KUMARASWAMY CHI-SQUARE GOODNESS OF FIT Y2 X2
       KUMARASWAMY CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    The following commands can be used to estimate the alpha
    and beta shape parameters for the Kumaraswamy distribution:

       LET ALPHA1 = <value>
       LET ALPHA2 = <value>
       LET BETA1 = <value>
       LET BETA2 = <value>
       KUMARASWAMY PPCC PLOT Y
       KUMARASWAMY PPCC PLOT Y2 X2
       KUMARASWAMY PPCC PLOT Y3 XLOW XHIGH
       KUMARASWAMY KS PLOT Y
       KUMARASWAMY KS PLOT Y2 X2
       KUMARASWAMY KS PLOT Y3 XLOW XHIGH

    The default values for ALPHA1 and ALPHA2 are 0.5 and 10.
    The default values for BETA1 and BETA2 are 0.5 and 10.

    The probability plot can then be used to estimate the
    lower and upper limits (lower limit = PPA0,
    upper limit = PPA0 + PPA1).

    The following options may be useful for these commands.

       1) Instead of generating the PPCC plot or KS plot on
          the original data, we can generate them on
          selected percentiles of the data.  For example,
          if we have 1,000 points, we can choose to generate
          the plots on 100 evenly spaced percentiles with
          the command

             SET PPCC PLOT DATA POINTS 100

          This can be used to speed up the generation of 
          the plot for larger data sets.

          Note that since the Kumaraswamy percent point
          function exists in closed form, this option is
          typically not needed.

       2) For the KS plot, we can fix the location and scale.
          This is equivalent to assuming that the lower and
          upper limits are known (e.g., we could use the
          data minimum and maximum as the lower and upper
          limit values).  Given that the lower and upper
          limits are LOWLIM and UPPLIM, enter the commands

             LET KSLOC   = LOWLIM
             LET KSSCALE = UPPLIM

          The PPCC plot is invariant to location and scale,
          so we cannot fix the lower and upper limits.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    KUMCDF = Compute the Kumaraswamy cumulative distribution
             function.
    KUMPPF = Compute the Kumaraswamy percent point function.
    RGTPDF = Compute the reflected generalized Topp and Leone
             probability density function.
    GTLPDF = Compute the generalized Topp and Leone probability
             density function.
    TOPPDF = Compute the Topp and Leone probability density
             function.
    TSPPDF = Compute the two-sided power probability density
             function.
    BETPDF = Compute the beta probability density function.
    TRIPDF = Compute the triangular probability density function.
    TRAPDF = Compute the trapezoid probability density function.
    UNIPDF = Compute the uniform probability density function.
    POWPDF = Compute the power probability density function.
    JSBPDF = Compute the Johnson SB probability density function.
 
Reference:
    Kumaraswamy (1980), "A Generalized Probability Density
    Function for Double-Bounded Random Processes", Journal of
    Hydrology, 46: 79-88.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/11
 
Program 1:
    CASE ASIS
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 3
    .
    LET ALPHA = 2
    LET BETA  = 3
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT KUMPDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 1.5
    LET BETA  = 6
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT KUMPDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 1.5
    LET BETA  = 2
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT KUMPDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 1.5
    LET BETA  = 1
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT KUMPDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 0.5
    LET BETA  = 2
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT KUMPDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 0.5
    LET BETA  = 1
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT KUMPDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 0.5
    LET BETA  = 0.75
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT KUMPDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 0.5
    LET BETA  = 0.25
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT KUMPDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    LET ALPHA = 1
    LET BETA  = 1
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT KUMPDF(X,ALPHA,BETA) FOR X = 0  0.01  1
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Kumaraswamy Probability Density Functions
 
Program 2:
    let alpha = 1.2
    let beta = 2.6
    let alphasv = alpha
    let betasv = beta
    .
    let y = kuaraswamy rand numb for i = 1 1 200
    .
    kumaraswamy ppcc plot y
    justification center
    move 50 6
    let alpha = shape1
    let beta = shape2
    text Alpha = ^alpha, Beta = ^beta
    move 50 3
    text Alphasav = ^alphsav, Betasav = ^betasav
    .
    char x
    line blank
    kumaraswamy probability plot y
    move 50 6
    let lowlim = ppa0
    let upplim = ppa0 + ppa1
    text Lower Limit = ^lowlim, Upper Limit = ^upplim
    move 50 3
    text PPCC = ^ppcc
    char blank
    line solid
    .
    let ksloc = ppa0
    let ksscale = upplim
    kumaraswamy kolm smir goodness of fit y
    .
    bootstrap kumaraswamy plot y

-----KUMPPF (LET)--------------------------------
 
KUMPPF
 
Name:
    KUMPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Kumaraswamy percent point function
    with shape parameters alpha and beta.
 
Description:
    The standard Kumaraswamy distribution has the following
    percent point function:

       G(p;alpha,beta) = [1 - (1-p)**((1/beta)]**(1/alpha)
                         0 <= p <= 1; alpha, beta > 0
 
    with alpha and beta denoting the shape parameters.

    This distribution can be extended with lower and upper
    bound parameters.  If a and b denote the lower and upper
    bounds, respectively, then the location and scale 
    parameters are:

    The lower and upper limits are related to the location
    and scale parameters as follows:

        location = a
        scale    = b - a

    The general form of the distribution can then be found
    by using the relation

        G(p;alpha.beta,a,b) = a + (b-a)*G(p;alpha,beta,0,1)

    This distribution has been proposed as a more tractable
    alternative to the beta distribution.

Syntax:
    LET <y> = KUMPPF(<p>,<alpha>,<beta>,<a>,<b>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or variable containing
              values in the interval (0,1);
          <y> is a variable or a parameter (depending on what
              <p> is) where the computed Kumaraswamy ppf value
              is stored;
          <alpha> is a positive number, parameter, or variable
              that specifies the first shape parameter;
          <beta> is a positive number, parameter, or variable that
              specifies the second shape parameter;
          <a> is a number, parameter, or variable that
              specifies the lower limit;
          <b> is a number, parameter, or variable that
              specifies the upper limit;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <a> and <b> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = KUMPPF(0.95,0.2,1.2)
    LET Y = KUMPPF(P,0.5,2)
    PLOT KUMPPF(P,2,3) FOR P = 0  0.01  1
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    KUMCDF = Compute the Kumaraswamy cumulative distribution
             function.
    KUMPDF = Compute the Kumaraswamy probability density
             function.
    RGTPDF = Compute the reflected generalized Topp and Leone
             probability density function.
    GTLPDF = Compute the generalized Topp and Leone probability
             density function.
    TOPPDF = Compute the Topp and Leone probability density
             function.
    TSPPDF = Compute the two-sided power probability density
             function.
    BETPDF = Compute the beta probability density function.
    TRIPDF = Compute the triangular probability density function.
    TRAPDF = Compute the trapezoid probability density function.
    UNIPDF = Compute the uniform probability density function.
    POWPDF = Compute the power probability density function.
    JSBPDF = Compute the Johnson SB probability density function.
 
Reference:
    Kumaraswamy (1980), "A Generalized Probability Density
    Function for Double-Bounded Random Processes", Journal of
    Hydrology, 46: 79-88.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/11
 
Program:
    CASE ASIS
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 3
    .
    LET ALPHA = 2
    LET BETA  = 3
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT KUMPPF(P,ALPHA,BETA) FOR P = 0  0.01  1
    .
    LET ALPHA = 1.5
    LET BETA  = 6
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT KUMPPF(P,ALPHA,BETA) FOR P = 0  0.01  1
    .
    LET ALPHA = 1.5
    LET BETA  = 2
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT KUMPPF(P,ALPHA,BETA) FOR P = 0  0.01  1
    .
    LET ALPHA = 1.5
    LET BETA  = 1
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT KUMPPF(P,ALPHA,BETA) FOR P = 0  0.01  1
    .
    LET ALPHA = 0.5
    LET BETA  = 2
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT KUMPPF(P,ALPHA,BETA) FOR P = 0  0.01  1
    .
    LET ALPHA = 0.5
    LET BETA  = 1
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT KUMPPF(P,ALPHA,BETA) FOR P = 0  0.01  1
    .
    LET ALPHA = 0.5
    LET BETA  = 0.75
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT KUMPPF(P,ALPHA,BETA) FOR P = 0  0.01  1
    .
    LET ALPHA = 0.5
    LET BETA  = 0.25
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT KUMPPF(P,ALPHA,BETA) FOR P = 0  0.01  1
    .
    LET ALPHA = 1
    LET BETA  = 1
    TITLE Alpha = ^alpha, Beta = ^beta
    PLOT KUMPPF(P,ALPHA,BETA) FOR P = 0  0.01  1
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Kumaraswamy Percent Point Functions
 
-----KURTOSIS OUTLIER TEST------------------------------------
 
KURTOSIS OUTLIER TEST
 
Name:
    KURTOSIS OUTLIER TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform the kurtosis test for univariate outliers from a normal
    distribution.
 
Description:
    The ASTM E178-16a standard for detecting outliers from a univariate
    normal distribution includes the kurtosis outlier test.

    The test statistic is the kurtosis coefficient

       g2 = n*(n+1)*SUM[i=1 to n][(x(i)-xbar)**4]/
            ((n-1)*(n-2)*(n-3)*s**2) -
            3*(n-1)**2/((n-2)*(n-3))

    with n, xbar and s denoting the sample size, the sample mean
    and the sample standard deviation, respectively.  Note that this
    definition is different than the one used by Dataplot's
    EXCESS KURTOSIS command.

    The critical values are obtained via simulation.  The ASTM standard
    provides table values for n = 3 to 50 and alpha levels of 0.10, 0.05
    and 0.01.  Linear interpolation is used for values of n not given in
    the table.  Alternatively, you can perform a dynamic simulation
    to obtain the critical values.

    To specify the method used to compute the critical value, enter
    one of the following commands (the default is ASTM)

        SET KURTOSIS OUTLIER TEST CRITICAL VALUES ASTM
        SET KURTOSIS OUTLIER TEST CRITICAL VALUES SIMULATION

    If n > 50, the simulation method will be used.

Syntax 1:
    KURTOSIS OUTLIER TEST  <y>  <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable being tested;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Syntax 2:
    MULTIPLE KURTOSIS OUTLIER TEST <y1> ... <yk>   
                                   <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of up to k response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax performs the kurtosis outlier test on <y1>, then on
    <y2>, and so on.  Up to 30 response variables can be specified.

    Note that the syntax

         MULTIPLE KURTOSIS OUTLIER TEST Y1 TO Y4

    is supported.  This is equivalent to

         MULTIPLE KURTOSIS OUTLIER TEST Y1 Y2 Y3 Y4

Syntax 3:
    REPLICATED KURTOSIS OUTLIER TEST <y> <x1> ... <xk>   
                                     <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <x1> ... <xk> is a list of up to k group-id variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax performs a cross-tabulation of <x1> ... <xk> and performs
    a kurtosis outlier test for each unique combination of cross-tabulated
    values.  For example, if X1 has 3 levels and X2 has 2 levels, there
    will be a total of 6 kurtosis outlier tests performed.

    Up to six group-id variables can be specified.

    Note that the syntax

         REPLICATED KURTOSIS OUTLIER TEST Y X1 TO X4

    is supported.  This is equivalent to

         REPLICATED KURTOSIS OUTLIER TEST Y X1 X2 X3 X4

Examples:
    KURTOSIS OUTLIER TEST Y1
    MULTIPLE KURTOSIS OUTLIER TEST Y1 Y2 Y3
    REPLICATED KURTOSIS OUTLIER TEST Y X1 X2
    SKEWNESS KURTOSIS TEST Y1   SUBSET TAG > 2

Note:
    Tests for outliers are dependent on knowing the distribution of the
    data.  The kurtosis outlier test assumes that the data come from an
    approximately normal distribution.  For this reason, it is strongly
    recommended that the kurtosis outlier test be complemented with a
    normal probability test.  If the data are not approximately normally
    distributed, then the kurtosis outlier test may be detecting the
    non-normality of the data rather than the presence of an outlier.

Note:
    You can specify the number of digits in the skewness outlier test
    output with the command

        SET WRITE DECIMALS <value>

Note:
    The KURTOSIS OUTLIER TEST command automatically saves the following
    parameters:

       STATVAL    = the value of the test statistic
       STATDCF    = the CDF value of the test statistic
       PVALUE     = the p-value of the test statistic
       CUTOFF80   = the 80 percent point of the reference distribution
       CUTOFF90   = the 90 percent point of the reference distribution
       CUTOFF95   = the 95 percent point of the reference distribution
       CUTOF975   = the 97.5 percent point of the reference distribution
       CUTOFF99   = the 99 percent point of the reference distribution

    The STATCDF and PVALUE are only saved when the simulation method
    is used to obtain critical values.  If the ASTM method is used to
    obtain critical values, the CUTOFF80 and CUTOF975 values are not
    saved.

    If the MULTIPLE or REPLICATED option is used, these values will
    be written to the file "dpst1f.dat" instead.

Note:
    In addition to the KURTOSIS OUTLIER TEST command, the following
    commands can also be used:

        LET A = KURTOSIS OUTLIER TEST Y
        LET A = KURTOSIS OUTLIER TEST CDF Y
        LET A = KURTOSIS OUTLIER TEST PVALUE Y
        LET A = KURTOSIS OUTLIER TEST INDEX Y

        LET ALPHA = <value>
        LET A = KURTOSIS OUTLIER TEST CRITICAL VALUE Y

    The KURTOSIS OUTLIER TEST, KURTOSIS OUTLIER TEST CDF, and
    KURTOSIS OUTLIER TEST PVALUE return the values of the test statistic,
    the cdf of the test statistic and the pvalue of the test statistic,
    respectively.  For the KURTOSIS OUTLIER TEST CDF and
    KURTOSIS OUTLIER TEST PVALUE commands, the simulation method will be
    used.  Otherwise, the method specified by the
    SET KURTOSIS OUTLIER TEST CRITICAL VALUE command will be used.

    The KURTOSIS OUTLIER TEST INDEX returns the row index of the most
    extreme value in the response variable.  The most extreme value is
    defined as the value furtherest from the mean.

    The KURTOSIS OUTLIER TEST CRITICAL VALUE returns the critical value
    for the specified value of ALPHA.  If ALPHA is not specified, it will
    be set to 0.05.  Note that if the ASTM method is specified for the
    critical values, only a few select values for alpha are supported
    (0.01, 0.05 and 0.10).

    In addition to the above LET command, built-in statistics are
    supported for 30+ different commands (enter HELP STATISTICS
    for details).

Default:
    The ASTM method is used to obtain critical values
 
Synonyms:
    None
 
Related Commands:
    SKEWNESS OUTLIER TEST       = Perform the skewness outlier test.
    GRUBBS TEST                 = Perform the Grubbs outlier test.
    DAVID TEST                  = Perform the David outlier test.
    TIETJEN-MOORE TEST          = Perform the Tietjen-Moore outlier
                                  test.
    EXTREME STUDENTIZED DEVIATE = Perform the generalized extreme
                                  studentized deviate outlier test.
    DIXON TEST                  = Perform the Dixon outlier test.
    SKEWNESS OUTLIER TEST       = Perform the skewness outlier test.
    KURTOSIS OUTLIER TEST       = Perform the kurtosis outlier test.
    ANDERSON DARLING TEST       = Perform the Anderson-Darling test for
                                  normality.
    WILK SHAPIRO TEST           = Perform the Wilk-Shapiro test for
                                  normality.
    PROBABILITY PLOT            = Generates a probability plot.
    HISTOGRAM                   = Generate a histogram.
    BOX PLOT                    = Generate a box plot.
 
Reference:
    E178 - 16A (2016), "Standard Practice for Dealing with Outlying
    Observations", ASTM International, 100 Barr Harbor Drive,
    PO Box C700, West Conshohocken, PA 19428-2959, USA.

    Ferguson, T.S. (1961), "On the Rejection of Outliers," Fourth
    Berkeley Symposium on Mathematical Statistics and Probability,
    edited by Jerzy Neyman, University of California Press, Berkeley
    and Los Angeles, CA.

    Ferguson, T.S. (1961), "Rules for Rejection of Outliers," Revue
    Inst. Int. de Stat., RINSA, Vol. 29, No. 3, pp. 29-43.

Applications:
    Outlier Detection
 
Implementation Date:
    2019/10
 
Program:
    . Step 1:   Read the data (from ASTM E-178 document)
    .
    read y
    -1.40
    -0.44
    -0.30
    -0.24
    -0.22
    -0.13
    -0.05
    0.06
    0.10
    0.18
    0.20
    0.39
    0.48
    0.63
    1.01
    end of data
    .
    . Step 2:   Compute the statistics
    .
    let stat = kurtosis outlier test y
    set kurtosis outlier test critical values astm
    let cv1 = kurtosis outlier test critical value y
    set kurtosis outlier test critical values simulation
    let cv2 = kurtosis outlier test critical value y
    .
    let pval = kurtosis outlier test pvalue y
    let statcdf = kurtosis outlier test cdf y
    let iindx = kurtosis outlier test index y
    .
    set write decimals 3
    print stat cv1 cv2 pval statcdf iindx
    .
    set kurtosis outlier test critical values astm
    kurtosis outlier test y
    set kurtosis outlier test critical values simulation
    kurtosis outlier test y

-----KURTOSIS (LET)-------------------------------------
 
KURTOSIS
 
Name:
    KURTOSIS (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the kurtosis statistic of a variable.
 
Description:
    The kurtosis is the standardized fourth central moment.  The
    formula is:

        Kurtosis = (SUM(X-XMEAN)**4/N)/XSD**4

    where XMEAN is the sample mean, XSD is the sample standard
    deviation, and N is the number of observations.  Note that in
    computing the standard deviation for the kurtosis, N is used in
    the denominator rather than N - 1.
 
    Kurtosis is a measure of how heavy tailed a distribution is.  A
    normal distribution has a kurtosis of 3.  A kurtosis greater than
    3 indicates that the data is heavy tailed (i.e., more spread
    out) relative to a normal distribution while a kurtosis value less
    than 3 indicates that the data is light tailed (i.e., more
    compressed) relative to a normal distribution. 

    Some sources subtract 3 from the kurtosis value in order to make the
    kurtosis 0 for a normal distribution.  We refer to this as the
    "excess kurtosis" statistic.
 
Syntax 1:
    LET <par> = KURTOSIS <y>    <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the calculated kurtosis is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax returns the conventional kurtosis statistic (i.e.,
    3 is not subtracted).
 
Syntax 2:
    LET <par> = EXCESS KURTOSIS <y>    <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the calculated kurtosis is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax returns the conventional kurtosis statistic (i.e.,
    3 is not subtracted).
 
Examples:
    LET A1 = KURTOSIS Y1
    LET A1 = KURTOSIS Y1 SUBSET Y1 > -2
    LET A1 = EXCESS KURTOSIS Y1
 
Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    STANDARDIZED FOURTH CENTRAL MOMENT
    STANDARDIZED 4TH CENTRAL MOMENT
 
Related Commands:
    MEAN                = Compute the mean of a variable.
    STANDARD DEVIATION  = Compute the standard deviation of a variable.
    SKEWNESS            = Compute the skewness of a variable.
    MEDIAN              = Compute the median of a variable.
    RANGE               = Compute the range of a variable.
 
Applications:
    Distributional Analysis
 
Implementation Date:
    Pre-1987
    2014/12: Added EXCESS KURTOSIS statistic
    2014/12: Changed from N-1 to N in the formula
 
Program:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET Y2 = DOUBLE EXPONENTIAL RANDOM NUMBERS FOR I = 1 1 100
    LET Y3 = SLASH RANDOM NUMBERS FOR I = 1 1 100
    LET Y4 = CAUCHY RANDOM NUMBERS FOR I = 1 1 100
    LET A1 = KURTOSIS Y1
    LET A2 = KURTOSIS Y2
    LET A3 = KURTOSIS Y3
    LET A4 = KURTOSIS Y4
    SET WRITE DECIMALS 3
    PRINT A1 A2 A3 A4
 
-----KURTOSIS PLOT-----------------------------------------------
 
KURTOSIS PLOT
 
Name:
    KURTOSIS PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a kurtosis plot.
 
Description:
    A kurtosis plot is a plot consisting of subsample kurtosis versus
    subsample index.  The kurtosis plot is used to answer the
    question--"Does the subsample distribution change over different
    subsamples?" It consists of:
       Vertical   axis = subsample kurtosis;
       Horizontal axis = subsample index.
    The KURTOSIS PLOT yields 2 traces:
       1. a subsample kurtosis trace; and
       2. a full-sample kurtosis reference line.
    Like usual, the appearance of these 2 traces is controlled by
    the first 2 settings of the LINES, CHARACTERS, SPIKES, BARS,
    and similar attributes.
 
Syntax:
    KURTOSIS PLOT   <y>   <x>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response (= dependent) variable;
          <x> is the subsample identifier variable (this variable
             appears on horizontal axis);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    KURTOSIS PLOT Y X
    KURTOSIS PLOT Y X1
 
Default:
    None
 
Synonyms:
    K PLOT
 
Related Commands:
    CHARACTERS              = Sets the type for plot characters.
    LINES                   = Sets the type for plot lines.
    SKEWNESS PLOT           = Generates a skewness plot
    VARIANCE PLOT           = Generates a variance plot
    STANDARD DEVIATION PLOT = Generates a standard deviation plot.
    RANGE PLOT              = Generates a range plot
    MEAN PLOT               = Generates a mean plot.
    MEDIAN PLOT             = Generates a median plot.
    BOX PLOT                = Generates a box plot.
    S CHART                 = Generates a standard deviation control
                              chart.
    PLOT                    = Generates a data or function plot.
 
Applications:
    Quality Control
 
Implementation Date:
    88/2
 
Program:
    LET Y = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET NU = 20
    LET Y = T RANDOM NUMBERS FOR I = 101 1 200
    LET NU = 5
    LET Y = CHI-SQUARE RANDOM NUMBERS FOR I = 201 1 300
    LET X = 1 FOR I = 1 1 100
    LET X = 2 FOR I = 101 1 200
    LET X = 3 FOR I = 201 1 300
    .
    XTIC OFFSET 0.2 0.2
    XLIMITS 1 3
    MAJOR XTIC MARK NUMBER 3
    MINOR XTIC MARK NUMBER 0
    XTIC MARK LABEL FORMAT ALPHA
    XTIC MARK LABEL CONTENT NORMAL T CHI-SQUARE
    CHARACTER X BLANK
    LINE BLANK SOLID
    KURTOSIS PLOT Y X
 
-------------------------------------------------------------
 





















































---ZZZZZ------
