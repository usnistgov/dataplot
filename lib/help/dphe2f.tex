 68700.   (VERSION 2023.07)  total number of lines in file (including this line)
 3.                          number of     sections below
  100.    A                  first line number of A section
 8400.    B                  first line number of B section
33300.    C                  first line number of C section
 
----------------------------------------------------------
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
-------------------------  *A*  ZZZZZ--------------------
 
-----ABRAM (LET)--------------------------------
 
ABRAM
 
Name:
    ABRAM (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Abramowitz function.
 
Description:
    The Abramowitz function is defined as:

        f(x,m) = INTEGRAL[t**m*EXP(-t**2 -x/t)dt],   x >= 0

    where the integral is defined from 0 to positive infinity and
    m, a non-negative integer, is the order of the Abramowitz
    function.  Dataplot supports values of m from 0 to 100.

    For m > 2, the following recurrence formula is used:

        2f(m)(x) = (m-1)*f(m-2)(x) + x*f(m-3)(x)
    
    Dataplot computes this function using ACM Algorithm 757 (see
    Reference: below).
 
Syntax:
    LET <y> = ABRAM(<x>,<ord>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative number, variable or parameter;
          <ord> is a non-negative integer number, parameter, or
               variable in the range 0 to 100; 
          <y> is a variable or a parameter (depending on what <x> 
               and <ord> are) where the computed Abramowitz function
               values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ABRAM(2.3,1)
    LET A = ABRAM(X,A1)
    LET X2 = ABRAM(X1,4) FOR X1 = 0.1 0.1 3.0
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CLAUSN     = Compute the Clausen integral.
    DEBYE      = Compute the Debye function.
    EXP3       = Compute the cubic exponential integral.
    GOODST     = Compute the Goodwin and Stanton integral.
    LOBACH     = Compute the Lobachevski integral.
    SYNCH1     = Compute the synchrotron radiation function.
    SYNCH2     = Compute the synchrotron radiation function.
    STROM      = Compute the Stromgren integral.
    TRAN       = Compute the transport integral.
 
Reference:
    "ACM Transactions of Mathematical Software", Allan MacLead,
    Vol. 22, No. 3, September, 1996, pp. 288-301.
 
Applications:
    Special Functions
 
Implementation Date:
    1999/6
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    TITLE ORDER 0
    PLOT ABRAM(X,0) FOR X = 0 0.01 10
    TITLE ORDER 1
    PLOT ABRAM(X,1) FOR X = 0 0.01 10
    TITLE ORDER 2
    PLOT ABRAM(X,2) FOR X = 0 0.01 10
    TITLE ORDER 3
    PLOT ABRAM(X,3) FOR X = 0 0.01 10
    END OF MULTIPLOT
    MOVE 50 97
    CENTER JUSTIFICATION
    TEXT ABRAMOWITZ FUNCTIONS
 
-----ABS (LET)--------------------------------
 
ABS
 
Name:
    ABS (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the absolute value for a variable or parameter.
 
Syntax:
    LET <y2> = ABS(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed absolute value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ABS(-2)
    LET A = ABS(A1)
    LET X2 = ABS(X1)
    LET X2 = ABS(X1-4)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CABS          = Compute the absolute value of a complex number.
 
Applications:
    Data Transformations
 
Implementation Date:
    Pre-1987
 
Program:
    TITLE AUTOMATIC
    PLOT ABS(X) FOR X = -5 .1 5
 
-----ADECDF (LET)--------------------------------
 
ADECDF
 
Name:
    ADECDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the asymmetric double exponential cumulative
    distribution function.
 
Description:
    The asymmetric double exponential distribution has the following
    cumulative distribution function:

       F(x,k) = 1 - (1/(1+k**2))*EXP[-SQRT(2)*k*ABS(x)]       x >= 0
              = (k**2/(1+k**2))*EXP[(-SQRT(2)/k)*ABS(x)]      x <  0
                k > 0
 
    The standard asymmetric double exponential distribution can be
    generalized with location and scale parameters.

    If k = 1 and the scale parameter = SQRT(2), the asymmetric
    double exponential distribution reduces to the symmetric
    double exponential distribution.

    The asymmetric double exponential distribution is also known as
    the asymmetric Laplace distribution.

Syntax:
    LET <y> = ADECDF(<x>,<k>,<loc>,<scale>)
                                <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable or a parameter;
          <k> is a positive number of parameter that specifies the
              value of the shape parameter;
          <loc> is an optional number or parameter that specifies the
              value of the location parameter;
          <scale> is an optional positive number or parameter that
              specifies the value of the scale parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed asymmetric double exponential cdf
               value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y = ADECDF(3,1)
    LET Y = ADECDF(X1,K)
    PLOT ADECDF(X,K) FOR X = -5 0.01 5
 
Note:
    Kotz, Kozubowski, and Podgorski define an alternate
    parameterization based on the parameter mu.  These
    parameterizations are related by:

       mu = (1/SQRT(2))*((1/k) - k)
       k  = SQRT(2)/(mu + SQRT(2 + mu**2))

    The mu parameter can be any real number.  A value of
    mu = 0 reduces to the symmetric double exponential (i.e.,
    k = 1).

    By default, Dataplot uses the k parameterization.  To use
    the mu parameterization, enter the command

        SET ASYMMETRIC DOUBLE EXPONENTIAL DEFINITION MU

    To reset the k parameterization, enter the command

        SET ASYMMETRIC DOUBLE EXPONENTIAL DEFINITION K
    
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ADEPDF = Compute the asymmetric double exponential probability
             density function.
    ADEPPF = Compute the asymmetric double exponential percent point
             function.
    SDECDF = Compute the skew double exponential probability density
             function.
    DEXCDF = Compute the double exponential probability density
             function.
    EXPCDF = Compute the exponential probability density function.
    SNCDF  = Compute the skew normal probability density function.
    STCDF  = Compute the skew t probability density function.
 
Reference:
    "The Laplace Distribution and Generalizations: A Revisit with
    Applications to Communications, Economics, Engineering, and
    Finance", Birkhauser, 2001, pp. 133-174.
 
    "A Class of Distributions Which Includes the Normal Ones",
    Azzalini, Scandinavian Journal of Statistics, 12, 171-178.

Applications:
    Distributional Modeling
 
Implementation Date:
    6/2004
 
Program:
    Y1LABEL Probability
    X1LABEL X
    LABEL CASE ASIS
    TITLE CASE ASIS
    CASE ASIS
    Y1LABEL DISPLACEMENT 12
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    TITLE Kappa = 0.5
    PLOT ADECDF(X,0.5) FOR X = -5 0.1 5
    TITLE Kappa = 1
    PLOT ADECDF(X,1) FOR X = -5 0.1 5
    TITLE Kappa = 2
    PLOT ADECDF(X,2) FOR X = -5 0.1 5
    TITLE Kappa = 5
    PLOT ADECDF(X,5) FOR X = -5 0.1 5
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATIONC CENTER
    TEXT Asymmetric Double Exponential Distribution
 
-----ADEPDF (LET)--------------------------------
 
ADEPDF
 
Name:
    ADEPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the asymmetric double exponential probability density
    function.
 
Description:
    The asymmetric double exponential distribution has the following
    probability density function:

       f(x,k) = (SQRT(2)*k/(1+k*k))*EXP[-SQRT(2)*k*ABS(x)]    x >= 0
              = (SQRT(2)*k/(1+k*k))*EXP[(-SQRT(2)/k)*ABS(x)]  x >= 0
                k > 0
 
    The standard asymmetric double exponential distribution can be
    generalized with location and scale parameters.

    If k = 1 and the scale parameter = SQRT(2), the asymmetric
    double exponential distribution reduces to the symmetric
    double exponential distribution.

    The asymmetric double exponential distribution is also known as
    the asymmetric Laplace distribution.

Syntax:
    LET <y> = ADEPDF(<x>,<k>,<loc>,<scale>)
                                <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable or a parameter;
          <k> is a positive number of parameter that specifies the
              value of the shape parameter;
          <loc> is an optional number or parameter that specifies the
              value of the location parameter;
          <scale> is an optional positive number or parameter that
              specifies the value of the scale parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed asymmetric double exponential pdf
               value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y = ADEPDF(3,1)
    LET Y = ADEPDF(X1,K)
    PLOT ADEPDF(X,K) FOR X = -5 0.01 5
 
Note:
    Kotz, Kozubowski, and Podgorski define an alternate
    parameterization based on the parameter mu.  These
    parameterizations are related by:

       mu = (1/SQRT(2))*((1/k) - k)
       k  = SQRT(2)/(mu + SQRT(2 + mu**2))

    The mu parameter can be any real number.  A value of
    mu = 0 reduces to the symmetric double exponential (i.e.,
    k = 1).

    By default, Dataplot uses the k parameterization.  To use
    the mu parameterization, enter the command

        SET ASYMMETRIC DOUBLE EXPONENTIAL DEFINITION MU

    To reset the k parameterization, enter the command

        SET ASYMMETRIC DOUBLE EXPONENTIAL DEFINITION K
    
Note:
    To generate asymmetric double exponential random numbers, enter
    the commands

        LET K = <value>
        LET Y = ASYMMETRIC DOUBLE EXPONENTIAL RANDOM NUMBERS ...
                FOR I = 1 1 N

    To generate an asymmetric double exponential probability plot
    or an asymmetric double exponential Kolmogorov-Smirnov or
    chi-square goodness of fit test, enter the following commands

        LET K = <value>
        ASYMMETRIC DOUBLE EXPONENTIAL PROBABILITY PLOT Y
        ASYMMETRIC DOUBLE EXPONENTIAL KOLMOGOROV SMIRNOV ...
                   GOODNESS OF FIT Y
        ASYMMETRIC DOUBLE EXPONENTIAL CHI-SQUARE GOODNESS OF FIT Y
       
    To generate a PPCC or Kolmogorov-Smirnov plot, enter the
    following commands

        LET K1 = <value>
        LET K2 = <value>
        ASYMMETRIC DOUBLE EXPONENTIAL PPCC PLOT Y
        ASYMMETRIC DOUBLE EXPONENTIAL KS PLOT Y

    The default values for K1 and K2 are 0.2 and 10.

    If you have requested the mu parameterization, then you
    you need to enter the command

        LET MU = <value>

    in place of

        LET K = <value>

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ADECDF = Compute the asymmetric double exponential cumulative
             distribution function.
    ADEPPF = Compute the asymmetric double exponential percent point
             function.
    SDEPDF = Compute the skew double exponential probability density
             function.
    DEXPDF = Compute the double exponential probability density
             function.
    EXPPDF = Compute the exponential probability density function.
    SNPDF  = Compute the skew normal probability density function.
    STPDF  = Compute the skew t probability density function.
 
Reference:
    "The Laplace Distribution and Generalizations: A Revisit with
    Applications to Communications, Economics, Engineering, and
    Finance", Birkhauser, 2001, pp. 133-174.
 
    "A Class of Distributions Which Includes the Normal Ones",
    Azzalini, Scandinavian Journal of Statistics, 12, 171-178.

Applications:
    Distributional Modeling
 
Implementation Date:
    6/2004
 
Program:
    Y1LABEL Probability
    X1LABEL X
    LABEL CASE ASIS
    TITLE CASE ASIS
    CASE ASIS
    Y1LABEL DISPLACEMENT 12
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    TITLE Kappa = 0.5
    PLOT ADEPDF(X,0.5) FOR X = -5 0.1 5
    TITLE Kappa = 1
    PLOT ADEPDF(X,1) FOR X = -5 0.1 5
    TITLE Kappa = 2
    PLOT ADEPDF(X,2) FOR X = -5 0.1 5
    TITLE Kappa = 5
    PLOT ADEPDF(X,5) FOR X = -5 0.1 5
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATIONC CENTER
    TEXT Asymmetric Double Exponential Distribution
 
-----ADEPPF (LET)--------------------------------
 
ADEPPF
 
Name:
    ADEPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the asymmetric double exponential percent point
    function.
 
Description:
    The asymmetric double exponential distribution has the following
    percent point function:

       G(p,k) = (k/SQRT(2))*LOG[((1+k**2)/k**2)*p] 
                                               0 < p < k**2/(1+k**2)
              = (-1/(k*SQRT(2)))*LOG[(1+k**2)*(1-p)] 
                                               k**2/(1+k**2) < p < 1
                k > 0
 
    The standard asymmetric double exponential distribution can be
    generalized with location and scale parameters.

    If k = 1 and the scale parameter = SQRT(2), the asymmetric
    double exponential distribution reduces to the symmetric
    double exponential distribution.

    The asymmetric double exponential distribution is also known as
    the asymmetric Laplace distribution.

Syntax:
    LET <y> = ADEPPF(<p>,<k>,<loc>,<scale>)
                                <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, number or a parameter in the range (0,1);
          <k> is a positive number of parameter that specifies the
              value of the shape parameter;
          <loc> is an optional number or parameter that specifies the
              value of the location parameter;
          <scale> is an optional positive number or parameter that
              specifies the value of the scale parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed asymmetric double exponential ppf
               value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y = ADEPPF(0.95,1)
    LET Y = ADEPPF(P1,K)
    PLOT ADEPPF(P,K) FOR L = 0.01  0.01  0.99
 
Note:
    Kotz, Kozubowski, and Podgorski define an alternate
    parameterization based on the parameter mu.  These
    parameterizations are related by:

       mu = (1/SQRT(2))*((1/k) - k)
       k  = SQRT(2)/(mu + SQRT(2 + mu**2))

    The mu parameter can be any real number.  A value of
    mu = 0 reduces to the symmetric double exponential (i.e.,
    k = 1).

    By default, Dataplot uses the k parameterization.  To use
    the mu parameterization, enter the command

        SET ASYMMETRIC DOUBLE EXPONENTIAL DEFINITION MU

    To reset the k parameterization, enter the command

        SET ASYMMETRIC DOUBLE EXPONENTIAL DEFINITION K
    
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ADECDF = Compute the asymmetric double exponential cumulative
             distribution function.
    ADEPDF = Compute the asymmetric double exponential probability
             density function.
    SDEPDF = Compute the skew double exponential probability density
             function.
    DEXPDF = Compute the double exponential probability density
             function.
    EXPPDF = Compute the exponential probability density function.
    SNPDF  = Compute the skew normal probability density function.
    STPDF  = Compute the skew t probability density function.
 
Reference:
    "The Laplace Distribution and Generalizations: A Revisit with
    Applications to Communications, Economics, Engineering, and
    Finance", Birkhauser, 2001, pp. 133-174.
 
    "A Class of Distributions Which Includes the Normal Ones",
    Azzalini, Scandinavian Journal of Statistics, 12, 171-178.

Applications:
    Distributional Modeling
 
Implementation Date:
    6/2004
 
Program:
    Y1LABEL Probability
    X1LABEL X
    LABEL CASE ASIS
    TITLE CASE ASIS
    CASE ASIS
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    TITLE Kappa = 0.5
    PLOT ADEPPF(P,0.5) FOR P = 0.01  0.01  0.99
    TITLE Kappa = 1
    PLOT ADEPPF(P,1) FOR P = 0.01  0.01  0.99
    TITLE Kappa = 2
    PLOT ADEPPF(P,2) FOR P = 0.01  0.01  0.99
    TITLE Kappa = 5
    PLOT ADEPPF(P,5) FOR P = 0.01  0.01  0.99
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATIONC CENTER
    TEXT Asymmetric Double Exponential Distribution

-----ADJACENCY MATRIX (LET)----------------------------------------
 
ADJACENCY MATRIX
 
Name:
    ADJACENCY MATRIX (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Create an adjacency matrix from a list of edges.
 
Description:
    In graph theory, given n vertices an nxn adjacency matrix
    defines the connections between the edges.  If there is
    an edge between vertex i and vertex j, then A(ij) = 1.
    Otherwise, A(ij) = 0.

    We make a distinction between undirected and directed
    adjacency matrices.  For the undirected case, the order of
    the edges does not matter.  So an edge between vertex i and
    vertex j means that both A(ij) and A(ji) will be set to 1.  In
    the directed case, the order is relevant.  So if A(ij) = 1, this
    does not imply that A(ji) = 1.

    Adjaency matrices are most useful when dealing with
    dense graphs with a relatively modest number of vertices.

Syntax 1:
    LET <mat> = ADJACENCY MATRIX <edge1> <edge2> <nvert>
    where <edge1> is a variable that identifies the first vertex
                  in the edge;
          <edge2> is a variable that identifies the second vertex
                  in the edge;
    and   <mat> is a matrix where the adjacency matrix is saved.
 
    This syntax is used for the undirected case.

Syntax 2:
    LET <mat> = DIRECTED ADJACENCY MATRIX <edge1> <edge2> <nvert>
    where <edge1> is a variable that identifies the first vertex
                  in the edge;
          <edge2> is a variable that identifies the second vertex
                  in the edge;
    and   <mat> is a matrix where the adjacency matrix is saved.
 
    This syntax is used for the directed case.

Examples:
    LET M = ADJACENCY MATRIX E1 E2 NVERT
 
Note:
    The maximum size matrix that DATAPLOT can handle is set when
    DATAPLOT is built on a particular site.  Enter HELP DIMENSION
    and HELP MATRIX DIMENSION for details.
 
Default:
    None
 
Synonyms:
    EDGES TO ADJACENCY MATRIX is a synonym for ADJACENCY MATRIX.
 
Related Commands:
    2D CONVEX HULL           = Compute the 2D convex hull of a
                               set of points.
    MINIMUM SPANNING TREE    = Compute the minimum spanning tree.
    SPANNING FOREST          = Compute the spanning forest.
    NEXT PERMUTATION         = Generate the next permutation of a
                               positive integer.
    RANDOM PERMUTATION       = Generate a random permutation of a
                               positive integer.
 
References:
    Skiena (1998), "The Algorithm Design Manual", Telos.

Applications:
    Graph Theory
 
Implementation Date:
    2009/1
 
Program:
    dimension 100 columns
    read edge1 edge2
    2 3
    4 7
    1 9
    7 11
    5 8
    2 5
    6 10
    2 8
    3 8
    4 11
    end of data
    .
    let nvert = 14
    let adj = adjacency matrix edge1 edge2 nvert
    .
    set write format 14F5.0
    print adj
 
-----AGREE------------------------------------------------------

Name:
    AGREE (LET)
 
Type:
    Library Function
 
Purpose:
    Return a 1 if the values agree and return a 0 if any of the
    values disagree.

    The DISAGREE function returns a 1 if any of the values disagree
    and a 0 if all the values agree.

Syntax 1:
    LET <yout> = AGREE(<y1> ... <yk>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> ..., <yk> is a list of one to eight variable or parameters;
          <yout> is a variable or a parameter (depending on what <y1> ...
              <yk> are) where the computed response values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    LET <yout> = DISAGREE(<y1> ... <yk>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> ..., <yk> is a list of one to eight variable or parameters;
          <yout> is a variable or a parameter (depending on what <y1> ...
              <yk> are) where the computed response values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = AGREE(1,0)
    LET YOUT = AGREE(Y1,Y2)
    LET YOUT = AGREE(Y1,Y2,Y3,Y4)
    LET YOUT = AGREE(Y1,Y2,Y3,Y4)  SUBSET TAG = 1
    LET YOUT = DISAGREE(Y1,Y2)
 
Default:
    None
 
Synonyms:
    EQ and EQUAL are synonyms for AGREE
    NE and NOTEQUAL are synonyms for DISAGREE
 
Related Commands:
    MAX     = Compute the maximum of two numbers.
    MIN     = Compute the minimum of two numbers.
 
Applications:
    Data Management
 
Implementation Date:
    2011/08
    2021/06: Add EQ and EQUAL as synonyms for AGREE
    2021/06: Add NE and NOTEQUAL as synonyms for DISAGREE
 
Program:
    LET Y1 = DATA 1 1 0 0 0 1
    LET Y2 = DATA 1 0 1 0 1 0
    LET YOUT1 = AGREE(Y1,Y2)
    LET YOUT2 = DISAGREE(Y1,Y2)
    SET WRITE DECIMALS 0
    PRINT Y1 Y2 YOUT1 YOUT2

-----AGRESTI COULL CONFIDENCE LIMITS (LET)-------------------------------
 
AGRESTI COULL CONFIDENCE LIMITS
 
Name:
    AGRESTI COULL CONFIDENCE LIMITS (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the two-sided Agresti-Coull confidence limits for a binomial
    proportion.
 
Description:
    The binomial proportion is defined as the number of successes
    divided by the number of trials.

    Confidence intervals for a binomial proportion can be computed using
    a method recommended by Agresti and Coull and also by Brown, Cai and
    DasGupta (the methodology was originally developed by Wilson
    in 1927).  This method solves for the two values of p0 (say,
    p(upper) and p(lower) that result from setting z = z(alpha/2)
    and solving for p(0) = p(upper), and then setting
    z = -z(alpha/2) and solving for p(0) = p(lower) where 
    z(alpha/2) denotes the variate value from the standard normal
    distribution such that the area to the right of the value is
    alpha/2.  The solution for the two values of p(0) results in
    the following confidence intervals:

       U. L. = {phat + z(alpha/2)**(2)/(2n) +
               z(alpha/2/(sqrt[(phat*(1-phat))/n +
               z(alpha/2)**(2)/(4n**2)]}/
               {1 + z(alpha/2)**(2)/n}

       L. L. = {phat + z(alpha/2)**(2)/(2n) -
               z(alpha/2/(sqrt[(phat*(1-phat))/n +
               z(alpha/2)**(2)/(4n**2)]}/
               {1 + z(alpha/2)**(2)/n}

    This approach can be substantiated on the grounds that it is the
    exact algebraic counterpart to the (large-sample) hypothesis test
    and is also supported by the research of Agresti and Coull.  One
    advantage of this procedure is that its worth does not strongly
    depend upon the value of n and/or p, and indeed was recommended
    by Agresti and Coull for virtually all combinations of n and p.

    Another advantage is that the limits are in the (0,1) interval.
    This is not true for the frequently used normal approximation:

        phat +/- z(alpha/2)*SQRT[(phat*(1-phat))/n]

Syntax:
    LET <lowlim> <upplim> = AGRESTI COULL CONFIDENCE LIMITS
                            <p> <n> <alpha>
                            <SUBSET/EXCEPT/FOR qualification>
    where <p> is constant, parameter, or variable that contains the
              proportion of successes;
          <n> is constant, parameter, or variable that contains the
              number of trials;
          <alpha> is constant or parameter that contains the significance
              level;
          <lowlim> is a variable that contains the computed lower
              Agresti-Coull confidence limit;
          <upplim> is a variable that contains the computed upper
              Agresti-Coull confidence limit;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The <p> and <n> arguments can be either parameters or variables.
    If they are both variables, then the variables must have the same
    number of elements.  The <alpha> argument is alwasys assumed to
    be either a constant or a parameter.

    If <p> and <n> are both parameters, then <lowlim> and <upplim> will
    be parameters.  Otherwise, they will be variables.

Examples:
    LET AL AU = AGRESTI COULL CONFIDENCE LIMITS P N ALPHA
    LET AL AU = AGRESTI COULL CONFIDENCE LIMITS P N ALPHA  SUBSET TAG > 2
 
Note:
    There are many methods that have proposed for the confidence limits for
    a binomial proportion.  In the statistical literature, what we refer to
    above as the Agresti-Coull method is now commonly referred to as the
    Wilson method (this method was originally described in a paper by
    Wilson).  What the Agresti-Coull paper referred to as the adjusted Wald
    method is now commonly referred to as the Agresti-Coull method.

    The Brown, Cai, and DasGupta paper studied the coverage properties of
    various methods.  They specifically recommend the Wilson, the adjusted
    Wald, and a Bayesion method based on a Jeffreys prior as having the
    best coverage properties.  Specifically, they recommend the Wilson and
    Jeffreys methods for n <= 40.  For n > 40, the methods have comparable
    performance.  Although they recommend the adjusted Wald in this case,
    this is primarily for simplicity in classroom presentation.

    In any event, the March, 2014 version of Dataplot added the following
    command:

         SET BINOMIAL METHOD <WILSON/ADJUSTED WALD/JEFFREYS>

    Whenever an Agresti-Coull interval is invoked in Dataplot, this command
    specifies which interval will be computed.

    The adjusted Wald interval is

         p' +/- NORPPF(1-alpha/2)*SQRT(p'*(1-p'))/SQRT(n')

    where

         X' = X + NORPPF(1-alpha/2)**2/2     (X is the number of success)
         n' = n + NORPPF(1-alpha/2)**2
         p' = X'/n'
         NORPPF is the percent point function of the normal distribution

    Note that the adjusted Wald method is never shorter than the Wilson
    interval.

    The Jeffreys interval (the derivation for this interval is given in
    the Brown, Cai, DasGupta paper) is

        LCL = BETPPF(alpha/2,X + 0.5)
        UCL = BETPPF(1 - alpha/2,n - X + 0.5)

    where BETPPF is the percent point function of the beta distribution
    and X is the number of successes.

    The default method is the Wilson interval.

Note:
    If you would like to use this command on raw data (i.e., you have
    a variable containing a sequence of 0's and 1's), do something like
    the following

        LET YSUM = SUM Y
        LET NTRIAL = SIZE Y
        LET P = YSUM/NTRIAL
        LET AL AU = AGRESTI COULL CONFIDENCE LIMITS P NTRIAL ALPHA

    If you have a group-id variable (X), you would do something like

        SET LET CROSS TABULATE COLLAPSE
        LET YSUM = CROSS TABULATE SUM Y X
        LET NTRIAL = CROSS TABULATE SIZE Y X
        LET P = YSUM/NTRIAL
        LET AL AU = AGRESTI COULL CONFIDENCE LIMITS P NTRIAL ALPHA

    In this case, P and NTRIAL are now variables rather than parameters.

Note:
    The following commands are also available:

       LET A = TWO SIDED LOWER AGRESTI COULL Y
       LET A = TWO SIDED UPPER AGRESTI COULL Y
       LET A = ONE SIDED LOWER AGRESTI COULL Y
       LET A = ONE SIDED UPPER AGRESTI COULL Y

    This command is a Statistics Let Subcommand rather than a Math
    LET Subcommand.  The distinctions are:

        1) The "Statistics" version of the command returns a single
           parameter value while the "Math" version of the command
           returns two variables.

        2) The "Statistics" version of the command can be used with
           a number of other commands (see the Note above) while the
           "Math" version of the command cannot.

           For example, the "Statistics" version of the command is
           most typically used with the FLUCTUATION PLOT, CROSS TABULATE,
           and STATISTIC PLOT commands.

        3) The "Statistics" version of the command expects a single
           variable (containing a sequence of 1's and 0's).  The
           "Math" version expects summary data (i.e., P and N).  The
           P and N can be either constants, parameters, or variables
           (or even a mix of these).

    Which form of the command to use is determined by the context of
    what you are trying to do.

    For details on the "Statistics" version of the command, enter

        HELP AGRESTI COULL

Default:
    None
 
Synonyms:
    AGRESTI COULL CONFIDENCE is a synonym for AGRESTI COULL CONFIDENCE
    LIMITS
 
Related Commands:
    AGRESTI-COULL                   = Compute Agresti-Coull confidence
                                      limits statistic for binomial
                                      proportions.
    EXACT BINOMIAL CONFIDENCE LIMIT = Compute the "exact" confidence
                                      limits for binomial proportions.
    BINOMIAL PROPORTION             = Compute the binomial proportion
                                      statistic.
    BINOMIAL PROPORTION TEST        = Perform a binomial proportions test.
    CROSS TABULATE (LET)            = Perform a cross tabulation for a
                                      specified statistic.
 
References:
    Agresti, A. and Coull, B. A. (1998), "Approximate is better than
    "exact" for interval estimation of binomial proportions",
    The American Statistician, 52(2), 119-126.

    Brown, L. D. Cai, T. T. and DasGupta, A. (2001), "Interval estimation
    for a binomial proportion," Statistical Science, 16(2), 101-133.

    Wilson (1927), "Probable inference, the law of succession, and
    statistical inference," Journal of the American Statistical
    Association, Vol. 22, pp. 209-212.

Applications:
    Statistics
 
Implementation Date:
    2007/2
    2014/3: Added SET BINOMIAL METHOD command
 
Program:
    LET N = 25
    LET P = 0.8
    LET ALPHA = 0.95
    LET AL AU = AGRESTI COULL CONFIDENCE LIMITS P N ALPHA
    SET BINOMIAL METHOD ADJUSTED WALD
    LET AL AU = AGRESTI COULL CONFIDENCE LIMITS P N ALPHA
    SET BINOMIAL METHOD JEFFREYS
    LET AL AU = AGRESTI COULL CONFIDENCE LIMITS P N ALPHA
 
-----AGRESTI COULL (LET)-----------------------------------------
 
AGRESTI COULL
 
Name:
    AGRESTI COULL (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute either the lower or upper Agresti-Coull confidence limit
    for either a one-sided or a two-sided binomial proportion of a
    variable.
 
Description:
    The binomial proportion is defined as the number of successes
    divided by the number of trials.

    In this context, we define success as "1" and failure as "0".
    Dataplot actually allows any two distinct values to be used.
    However, the larger value will always be considered "success" and
    the smaller value will always be considered "failure".  If the
    variable contains more than two distinct values, an error is
    reported.

    The BINOMIAL PROPORTION command is used to compute a point
    estimate of the probability of success.  Confidence intervals
    for the binomial proportion can be computed using a method
    recommended by Agresti and Coull and also by Brown, Cai and
    DasGupta (the methodology was originally developed by Wilson
    in 1927).  This method solves for the two values of p0 (say,
    p(upper) and p(lower) that result from setting z = z(alpha/2)
    and solving for p(0) = p(upper), and then setting
    z = -z(alpha/2) and solving for p(0) = p(lower) where 
    z(alpha/2) denotes the variate value from the standard normal
    distribution such that the area to the right of the value is
    alpha/2.  The solution for the two values of p(0) results in
    the following confidence intervals:

       U. L. = {phat + z(alpha/2)**(2)/(2n) +
               z(alpha/2/(sqrt[(phat*(1-phat))/n +
               z(alpha/2)**(2)/(4n**2)]}/
               {1 + z(alpha/2)**(2)/n}

       L. L. = {phat + z(alpha/2)**(2)/(2n) -
               z(alpha/2/(sqrt[(phat*(1-phat))/n +
               z(alpha/2)**(2)/(4n**2)]}/
               {1 + z(alpha/2)**(2)/n}

    This approach can be substantiated on the grounds that it is the
    exact algebraic counterpart to the (large-sample) hypothesis test
    and is also supported by the research of Agresti and Coull.  One
    advantage of this procedure is that its worth does not strongly
    depend upon the value of n and/or p, and indeed was recommended
    by Agresti and Coull for virtually all combinations of n and p.

    Another advantage is that the limits are in the (0,1) interval.
    This is not true for the frequently used normal approximation:

        phat +/- z(alpha/2)*SQRT[(phat*(1-phat))/n]

    A one-sided confidence interval can also be constructed simply by
    replacing each z(alpha/2) by z(alpha) in the expression for the
    lower or upper limit, whichever is desired.

Syntax 1:
    LET <par> = TWO-SIDED LOWER AGRESTI COULL <y>
                <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the computed value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This is for raw data case and <y> should contain a sequence of
    0's and 1's.  This returns the lower confidence limit for the
    two-sided Agresti-Coull interval.

Syntax 2:
    LET <par> = TWO-SIDED UPPER AGRESTI COULL <y>
                <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the computed value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This is for raw data case and <y> should contain a sequence of
    0's and 1's.  This returns the upper confidence limit for the
    two-sided Agresti-Coull interval.

Syntax 3:
    LET <par> = ONE-SIDED LOWER AGRESTI COULL <y>
                <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the computed value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This is for raw data case and <y> should contain a sequence of
    0's and 1's.  This returns the lower confidence limit for the
    one-sided lower tailed Agresti-Coull interval.

Syntax 4:
    LET <par> = ONE-SIDED UPPER AGRESTI COULL <y>
                <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the computed value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This is for raw data case and <y> should contain a sequence of
    0's and 1's.  This returns the upper confidence limit for the
    one-sided upper tailed Agresti-Coull interval.

Examples:
    LET A = TWO-SIDED LOWER AGRESTI COULL Y1
    LET A = TWO-SIDED UPPER AGRESTI COULL Y1
    LET A = ONE-SIDED LOWER AGRESTI COULL Y1
    LET A = ONE-SIDED UPPER AGRESTI COULL Y1
    LET A = TWO-SIDED LOWER AGRESTI COULL Y1  SUBSET TAG > 2
 
Note:
    There are many methods that have proposed for the confidence limits for
    a binomial proportion.  In the statistical literature, what we refer to
    above as the Agresti-Coull method is now commonly referred to as the
    Wilson method (this method was originally described in a paper by
    Wilson).  What the Agresti-Coull paper referred to as the adjusted Wald
    method is now commonly referred to as the Agresti-Coull method.

    The Brown, Cai, and DasGupta paper studied the coverage properties of
    various methods.  They specifically recommend the Wilson, the adjusted
    Wald, and a Bayesion method based on a Jeffreys prior as having the
    best coverage properties.  Specifically, they recommend the Wilson and
    Jeffreys methods for n <= 40.  For n > 40, the methods have comparable
    performance.  Although they recommend the adjusted Wald in this case,
    this is primarily for simplicity in classroom presentation.

    In any event, the March, 2014 version of Dataplot added the following
    command:

         SET BINOMIAL METHOD <WILSON/ADJUSTED WALD/JEFFREYS>

    Whenever an Agresti-Coull interval is invoked in Dataplot, this command
    specifies which interval will be computed.

    The adjusted Wald interval is

         p' +/- NORPPF(1-alpha/2)*SQRT(p'*(1-p'))/SQRT(n')

    where

         X' = X + NORPPF(1-alpha/2)**2/2     (X is the number of success)
         n' = n + NORPPF(1-alpha/2)**2
         p' = X'/n'
         NORPPF is the percent point function of the normal distribution

    Note that the adjusted Wald method is never shorter than the Wilson
    interval.

    The Jeffreys interval (the derivation for this interval is given in
    the Brown, Cai, DasGupta paper) is

        LCL = BETPPF(alpha/2,X + 0.5)
        UCL = BETPPF(1 - alpha/2,n - X + 0.5)

    where BETPPF is the percent point function of the beta distribution
    and X is the number of successes.

    The default method is the Wilson interval.

Note:
    To specify the signficance level to use for the Agresti-Coull
    limits, enter the command

        LET ALPHA = <value>

    The default value of alpha is 0.95.
 
Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

    These various commands are actually where the AGRESTI COULL
    statistics are most commonly used.

Note:
    In addition to the commands given here, the following command
    is also available:

       LET AL AU = AGRESTI COULL LIMITS P N ALPHA

    This command is a Math Let Subcommand rather than a Statistics
    LET Subcommand.  The distinctions are:

        1) The "Statistics" version of the command returns a single
           parameter value while the "Math" version of the command
           returns two variables.

        2) The "Statistics" version of the command can be used with
           a number of other commands (see the Note above) while the
           "Math" version of the command cannot.

           For example, the "Statistics" version of the command is
           most typically used with the FLUCTUATION PLOT, CROSS TABULATE,
           and STATISTIC PLOT commands.

        3) The "Statistics" version of the command expects a single
           variable (containing a sequence of 1's and 0's).  The
           "Math" version expects summary data (i.e., P and N).  The
           P and N can be either constants, parameters, or variables
           (or even a mix of these).

    Which form of the command to use is determined by the context of
    what you are trying to do.

    For details on the "Math" version of the command, enter

        HELP AGRESTI COULL CONFIDENCE LIMITS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    AGRESTI-COULL CONFIDENCE LIMITS = Compute Agresti-Coull confidence
                                      limits for binomial proportions.
    EXACT BINOMIAL                  = Compute the "exact" confidence
                                      limits statistic for binomial
                                      proportions.
    BINOMIAL PROPORTION             = Compute the binomial proportion
                                      statistic.
    BINOMIAL PROPORTION TEST        = Perform a binomial proportions test.
    CROSS TABULATE                  = Perform a cross-tabulation for a
                                      specified statistic.
    FLUCTUATION PLOT                = Generate a fluctuation plot.
    STATISTIC PLOT                  = Generate a statistic versus subset
                                      plot.
 
References:
    Agresti, A. and Coull, B. A. (1998), "Approximate is better than
    "exact" for interval estimation of binomial proportions",
    The American Statistician, 52(2), 119-126.

    Brown, L. D. Cai, T. T. and DasGupta, A. (2001), "Interval estimation
    for a binomial proportion," Statistical Science, 16(2), 101-133.

    Wilson (1927), "Probable inference, the law of succession, and
    statistical inference," Journal of the American Statistical
    Association, Vol. 22, pp. 209-212.

Applications:
    Statistics
 
Implementation Date:
    2010/3
    2014/3: Added SET BINOMIAL METHOD command
 
Program:
    LET N = 1
    LET P = 0.8
    LET ALPHA = 0.95
    LET Y = BINOMIAL RANDOM NUMBERS FOR I = 1 1 50
    LET AL = ONE SIDED LOWER AGRESTI COULL Y
    LET AU = ONE SIDED LOWER AGRESTI COULL Y
    LET BL = TWO SIDED LOWER AGRESTI COULL Y
    LET BU = TWO SIDED LOWER AGRESTI COULL Y
 
-----AIRINT (LET)--------------------------------

AIRINT

Name:
   AIRINT (LET)
 
Type:
    Library Function

Purpose:
    This program computes the integral of the Airy function Ai(x).

Description:
    The AIRINT function is defined as:

        AIRINT(x) = {integral 0 to x} Ai(t) dt

    with Ai denoting the Airy function.

    Dataplot computes this function using ACM Algorithm 757 (see
    Reference: below).  The function is computed using Chebyshev
    expansions, the coefficients of which are given to 20 decimal
    places.

Syntax:
    LET <y> = AIRINT(<x>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, variable or parameter;
          <y> is a variable or a parameter (depending on what <x> 
               is) where the computed AIRINT function values are
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = AIRINT(2.3)
    PLOT AIRINT(X) FOR  X = -5 0.01 5
    LET X2 = AIRINT(X1) FOR X1 = 0.1 0.1 3.0
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    AIRY       = Compute the Airy function.
    BAIRY      = Compute the Airy function of the second kind.
    BIRINT     = Compute the integral of the Airy function of the
                 second kind.
    BESSIN     = Compute the modified Bessel function of the first
                 kind and order N.
    BESSJN     = Compute the Bessel function of the first kind and
                 order N.
    BESSKN     = Compute the modified Bessel function of the third
                 kind and order N.
    BESSYN     = Compute the Bessel function of the second kind and
                 order N.
    J0INT      = Compute the integral of the Bessel function of
                 the first kind and order 0.
    K0INT      = Compute the integral of the modified Bessel
                 function of the third kind and order 0.
    Y0INT      = Compute the integral of the Bessel function of
                 the second kind and order 0.

Reference:
    "ACM Transactions of Mathematical Software", Allan MacLead,
    Vol. 22, No. 3, September, 1996, pp. 288-301.
 
Applications:
    Special Functions
 
Implementation Date:
    2005/11
 
Program:
    TITLE AIRINT FUNCTION
    PLOT AIRINT(X) FOR X = -10 0.01 10
 
-----AIRY (LET)--------------------------------
 
AIRY
 
Name:
    AIRY (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Airy function.
 
Description:
    The Airy function is defined as:

        Ai(x) = SQRT(x/(3*PI**2)) K(1/3)(2*x**1.5/3)    x real

    where K(1/3) is the modified Bessel function of the third kind
    of order (1/3).  See the documentation for BESSKN for 
    a desciption of the modified Bessel function of the third kind.
 
Syntax:
    LET <y2> = AIRY(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a decimal number, variable or a parameter;
          <y2> is a variable or a parameter (depending on what
               <y1> is) where the computed Airy value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = AIRY(-2)
    LET A = AIRY(A1)
    LET X2 = AIRY(0.2)
    LET X2 = AIRY(X1-4)
 
Note:
    The SLATEC function AI is used to compute this function.

Note:
    The derivative of the Airy function is:

        Ai'(x) = -(x/(SQRT(3)*PI)) K(2/3)(2*x**1.5/3)    x real

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BAIRY   = Compute the Airy function of the second kind.
    BESSKN  = Compute the modified Bessel function of the third kind
              (fractional orders allowed).
    BESSKNE = Compute the exponentially scaled modified Bessel function
              of the third kind (fractional orders allowed).
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 10).
 
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", 2nd Edition, Press, Flannery, Teukolsky, and
    Vetterling.  Cambridge University Press, 1992 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE AUTOMATIC
    PLOT AIRY(X) FOR X = -5 .1 5
 
-----AIRYGI (LET)--------------------------------

AIRYGI

Name:
   AIRYGI (LET)
 
Type:
    Library Function

Purpose:
    This program computes the modified Airy function Gi(x).

Description:
    The AIRYGI function is defined as:

        AIRYGI(x) = [Integral{0 to infinity} sin(x*t+t^3/3) dt]/pi

    Dataplot computes this function using ACM Algorithm 757 (see
    Reference: below).  The function is computed using Chebyshev
    expansions, the coefficients of which are given to 20 decimal
    places.

Syntax:
    LET <y> = AIRYGI(<x>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, variable or parameter;
          <y> is a variable or a parameter (depending on what <x> 
               is) where the computed AIRYGI function values are
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = AIRYGI(2.3)
    PLOT AIRYGI(X) FOR  X = -5 0.01 5
    LET X2 = AIRYGI(X1) FOR X1 = 0.1 0.1 3.0
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    AIRYHI     = Compute the modified Airy function Hi.
    AIRY       = Compute the Airy function.
    BAIRY      = Compute the Airy function of the second kind.
    AIRINT     = Compute the integral of the Airy function.
    BIRINT     = Compute the integral of the Airy function of the
                 second kind.
    BESSIN     = Compute the modified Bessel function of the first
                 kind and order N.
    BESSJN     = Compute the Bessel function of the first kind and
                 order N.
    BESSKN     = Compute the modified Bessel function of the third
                 kind and order N.
    BESSYN     = Compute the Bessel function of the second kind and
                 order N.

Reference:
    "ACM Transactions of Mathematical Software", Allan MacLead,
    Vol. 22, No. 3, September, 1996, pp. 288-301.
 
Applications:
    Special Functions
 
Implementation Date:
    2005/11
 
Program:
    TITLE AIRY GI FUNCTION
    PLOT AIRYGI(X) FOR X = -10 0.01 10
 
-----AIRYHI (LET)--------------------------------

AIRYHI

Name:
   AIRYHI (LET)
 
Type:
    Library Function

Purpose:
    This program computes the modified Airy function Hi(x).

Description:
    The AIRYHI function is defined as:

        AIRYHI(x) = [Integral{0 to infinity} exp(x*t-t^3/3)dt]/pi

    Dataplot computes this function using ACM Algorithm 757 (see
    Reference: below).  The function is computed using Chebyshev
    expansions, the coefficients of which are given to 20 decimal
    places.

Syntax:
    LET <y> = AIRYHI(<x>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, variable or parameter;
          <y> is a variable or a parameter (depending on what <x> 
               is) where the computed AIRYHI function values are
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = AIRYHI(2.3)
    PLOT AIRYHI(X) FOR  X = -5 0.01 5
    LET X2 = AIRYHI(X1) FOR X1 = 0.1 0.1 3.0
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    AIRYGI     = Compute the modified Airy function Gi.
    AIRY       = Compute the Airy function.
    BAIRY      = Compute the Airy function of the second kind.
    AIRINT     = Compute the integral of the Airy function.
    BIRINT     = Compute the integral of the Airy function of the
                 second kind.
    BESSIN     = Compute the modified Bessel function of the first
                 kind and order N.
    BESSJN     = Compute the Bessel function of the first kind and
                 order N.
    BESSKN     = Compute the modified Bessel function of the third
                 kind and order N.
    BESSYN     = Compute the Bessel function of the second kind and
                 order N.

Reference:
    "ACM Transactions of Mathematical Software", Allan MacLead,
    Vol. 22, No. 3, September, 1996, pp. 288-301.
 
Applications:
    Special Functions
 
Implementation Date:
    2005/11
 
Program:
    TITLE AIRYHI FUNCTION
    PLOT AIRGHI(X) FOR X = -3 0.01 3
 
-----ALIAS-------------------------------------------------

ALIAS

Name:
    ALIAS
 
Type:
    Support Command
 
Purpose:
    Create user-defined shortcuts for commands.
 
Description:
    Creating aliases is primarily intended to allow you to create
    shortcuts for frequently used commands.  For example, you
    do something like

       alias v psview  plot.ps

    If you subsequently enter

       v

    then what gets executed is

       psview  plot.ps

    That is, the first argument is the name of the alias and everything
    after the first argument is what gets executed when the alias name
    is entered.

    Up to 30 aliases can be defined.  These ALIAS commands can be added
    to your dplogf.tex so that they are immeditately available when
    you start a Dataplot session.

    Two restrictions should be noted.

       1. The ALIAS command is limited to a single command line.

       2. Aliases do not support arguments.  That is,

             alias v  psview
             v  plot.ps

          is not supported.

Syntax 1:
    ALIAS  <name>  <string>
    where <name> is a string of 1 to 8 characters that specifies
          the name of the alias;
    and   <string> are the characters that specify the command that
          will be executed when the alias name is entered.

Syntax 2:
    LIST ALIAS

    This command lists all currently defined aliases.

Syntax 3:
    ALIAS CLEAR ALL

    This command clears all currently defined aliases.

Syntax 4:
    ALIAS CLEAR <name>
    where <name> is the name of previously defined alias.

    This command clears the specified alias.  Currently, only
    a single alias can be cleared with this command.

Examples:
    ALIAS V PSVIEW DPPL1F.DAT
    ALIAS LIST
    ALIAS CLEAR ALL
    ALIAS CLEAR V
 
Note:
    You can define an alias for more than command.  For example,

        separator character @
        alias rx  reset data; call clipboard
        separator character ;

    It is important to temporarily redefine the separator character
    before the alias command.  In the above example, if the
    separator character command is omitted, the alias would be
    set to "reset data" and "call clipboard" would be executed as
    a separate command.

Default:
    No aliases are defined by default
 
Synonyms:
    None

Related Commands:
    SYSTEM      = Enter an operating system command within a
                  Dataplot session.
    CAT         = Display the contents of a file.
    CD          = Change the current working directory.
    PWD         = Retrieve the current working directory.
    MKDIR       = Create a new directory.
    RM          = Delete one or more files.
    DIR         = List the contents of a directory.
 
Applications:
    Interactive Usage
 
Implementation Date:
    2021/04
 
Program:
    alias v  psview dppl1f.dat
    device 2 postscript
    plot x**2 for x = 1 1 9
    device 2 close
    v

-----ALLAN VARIANCE PLOT------------------------------
 
ALLAN VARIANCE PLOT
 
Name:
    ALLAN VARIANCE PLOT
 
Type:
    Graphics Command
 
Purpose:
    Carry out an Allan variance analysis to examine the low-frequency
    component of a spectrum of an equi-spaced time series, and to
    estimate the exponent in a low-frequency power-law spectral model.
 
Description:
    An Allan variance plot is a graphical data analysis technique for
    examining the nature of the low-frequency component of a time
    series.  An Allan variance plot consists of:
       Vertical axis   = Allan variance for subsample size k (for k up
                         to N/2);
       Horizontal axis = subsample size k.
 
    The Allan variance AV(1) for subsample size k = 1 is defined as the
    variance of the following squared deltas:
       delta1 = x(1)-x(2)
       delta2 = x(3)-x(4)
       delta3 = x(5)-x(6)
          ...
       deltan =  x(n-1)-x(n)
    The Allan variance AV(2) for subsample size k = 2 is defined as the
    variance of the following squared deltas:
       delta1 = (x(1)+x(2))-(x(3)+x(4))
       delta2 = (x(5)+x(6))-(x(7)+x(8))
          ...
    The Allan variance AV(3) for subsample size k = 3 is defined as the
    variance of the following squared deltas:
       delta1 = (x(1)+x(2)+x(3))-(x(4)+x(5)+x(6))
       delta2 = (x(7)+x(8)+x(9))-(x(10)+x(11)+x(12))
          ...
 
    The Allan variance plot is usually viewed on a loglog scale.

    A common frequency domain model for the spectrum S(w) of a
    low-frequency time series is the power-law:
         S(w) = w**alpha
    There is a one-to-one correspondence between the slope of the
    loglog spectrum (the alpha) and the slope of the loglog Allan
    variance plot:

     Time Series      Slope of           Slope of
       Model      Loglog Spectrum      Loglog AV Plot
                      (alpha)           (-alpha-1)
    --------------------------------------------------
    Random Walk        -2                    1
    Flicker            -1                    0
    White Noise         0                   -1
    Super Flicker       1                   -2
    Super White         2                   -3

    If one has a time series with a dominant low-frequency component,
    then the Allan variance plot is a useful tool for assessing the
    nature of the low-frequency component and for estimating the
    power (alpha) of the power-law spectral power-law model.

    The slope of the Allan variance plot indicates the nature
    of the underlying time series model.

Syntax:
    ALLAN VARIANCE PLOT <y1> <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a response variable containing equi-spaced time
              series data;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    ALLAN VARIANCE PLOT Y
    AV PLOT Y
 
Note:
    The Allan variance plot and the Allan standard deviation plot have
    equivalent information content (and differ only by a factor of 2).
    The Allan variance plot is more heavily used than the Allan
    standard deviation plot.
 
Default:
    None
 
Synonyms:
    AV PLOT
 
Related Commands:
    SPECTRAL PLOT                = Generate a spectral plot.
    ALLAN STAND DEVIATION PLOT   = Generate an Allan standard deviation
                                   plot.
 
Reference:
    Dave Allan, NIST in Boulder
 
Applications:
    Frequency Time Series Analysis
 
Implementation Date:
    XX
 
Program 1:
    . THIS IS AN EXAMPLE OF AN ALLAN VARIANCE PLOT
    . FOR WHITE NOISE DATA  S(W) = W**0
    . (THUS THE LOGLOG SPECTRUM HAS SLOPE 0 AND
    . AND THE ALLAN VARIANCE PLOT HAS SLOPE -(0)-1 = -1
    LET Y = NORMAL RANDOM NUMBERS FOR I = 1 1 500
    TITLE WHITE NOISE
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    GRID ON; X3LABEL AUTOMATIC
    PLOT Y; SPECTRUM Y
    LOGLOG; SPECTRUM Y; ALLAN VARIANCE PLOT
    END OF MULTIPLOT
 
Program 2:
    . THIS IS AN EXAMPLE OF AN ALLAN VARIANCE PLOT
    . FOR RANDOM WALK DATA  S(W) = W**(-2)
    . (THUS THE LOGLOG SPECTRUM HAS SLOPE -2 AND
    . AND THE ALLAN VARIANCE PLOT HAS SLOPE -(-2)-1 = 1
    SKIP 25; READ RANDWALK.DAT Y
    TITLE RANDOM WALK
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    GRID ON; X3LABEL AUTOMATIC
    PLOT Y; SPECTRUM Y
    LOGLOG; SPECTRUM Y; ALLAN VARIANCE PLOT
    END OF MULTIPLOT
 
Program 3:
    . THIS IS AN EXAMPLE OF AN ALLAN VARIANCE PLOT
    . FOR FLICKER NOISE DATA  S(W) = W**(-1)
    . (THUS THE LOGLOG SPECTRUM HAS SLOPE -1 AND
    . AND THE ALLAN VARIANCE PLOT HAS SLOPE -(-1)-1 = 0
    SKIP 25; READ FLICKER.DAT Y
    TITLE FLICKER DATA
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    GRID ON; X3LABEL AUTOMATIC
    PLOT Y; SPECTRUM Y
    LOGLOG; SPECTRUM Y; ALLAN VARIANCE PLOT
    END OF MULTIPLOT
 
-----ALLAN STANDARD DEVIATION PLOT------------------------------
 
ALLAN STANDARD DEVIATION PLOT
 
Name:
    ALLAN STANDARD DEVIATION PLOT
 
Type:
    Graphics Command
 
Purpose:
    Carry out an Allan standard deviation analysis to examine the
    low-frequency component of a spectrum of an equi-spaced time
    series, and to estimate the exponent in a low-frequency power-law
    spectral model.
 
Description:
    An Allan standard deviation plot is a graphical data analysis
    technique for examining the nature of the low-frequency component
    of a time series.  An Allan standard deviation plot consists of:
       Vertical axis   = Allan standard deviation for subsample size k
                         (for k up to N/2);
       Horizontal axis = subsample size k.
 
    The Allan standard deviation is the standard deviation of the
    squared deltas as defined below.

    The Allan standard deviation ASD(1) for subsample size k = 1 is
    defined as the standard deviation of the following squared deltas:
       delta1 = x(1)-x(2)
       delta2 = x(3)-x(4)
       delta3 = x(5)-x(6)
          ...
       deltan =  x(n-1)-x(n)
    The Allan standard deviation ASD(2) for subsample size k = 2 is
    defined as the standard deviation of the following squared deltas:
       delta1 = (x(1)+x(2))-(x(3)+x(4))
       delta2 = (x(5)+x(6))-(x(7)+x(8))
          ...
    The Allan standard deviation ASD(3) for subsample size k = 2 is
    defined as the standard deviation of the following squared deltas:
       delta1 = (x(1)+x(2)+x(3))-(x(4)+x(5)+x(6))
       delta2 = (x(7)+x(8)+x(9))-(x(10)+x(11)+x(12))
          ...
 
    The Allan variance plot is usually viewed on a loglog scale.

    A common frequency domain model for the spectrum S(w) of a
    low-frequency time series is the power-law:
         S(w) = w**alpha
    There is a one-to-one correspondence between the slope of the
    loglog spectrum (the alpha) and the slope of the loglog Allan
    variance plot:

     Time Series      Slope of           Slope of
       Model      Loglog Spectrum      Loglog AV Plot
                      (alpha)           (-alpha-1)
    --------------------------------------------------
    Random Walk        -2                   0.5
    Flicker            -1                   0.0
    White Noise         0                  -0.5
    Super Flicker       1                  -1.0
    Super White         2                  -1.5

    If one has a time series with a dominant low-frequency component,
    then the Allan variance plot is a useful tool for assessing the
    nature of the low-frequency component and for estimating the
    power (alpha) of the power-law spectral power-law model.

    The slope of the Allan variance plot indicates the nature
    of the underlying time series model.
 
 
Syntax:
    ALLAN STANDARD DEVIATION PLOT <y> <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable containing equi-spaced time
              series data;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    ALLAN STANDARD DEVIATION PLOT Y
    ASD PLOT Y
 
Note:
    The Allan variance plot and the Allan standard deviation plot have
    equivalent information content (and differ only by a factor of 2).
    The Allan variance plot is more heavily used than the Allan
    standard deviation plot.
 
Default:
    None
 
Synonyms:
    ASD PLOT
 
Related Commands:
    SPECTRAL PLOT                = Generate a spectral plot.
    ALLAN VARIANCE PLOT          = Generate an Allan variance plot.
 
Reference:
    Dave Allan, NIST in Boulder
 
Applications:
    Frequency Time Series Analysis
 
Implementation Date:
    XX
 
Program 1:
    . THIS IS AN EXAMPLE OF AN ALLAN SD PLOT
    . FOR WHITE NOISE DATA  S(W) = W**0
    . (THUS THE LOGLOG SPECTRUM HAS SLOPE 0 AND
    . AND THE ALLAN SD PLOT HAS SLOPE (-(0)-1)/2 = -1/2
    LET Y = NORMAL RANDOM NUMBERS FOR I = 1 1 500
    TITLE WHITE NOISE
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    GRID ON; X3LABEL AUTOMATIC
    PLOT Y; SPECTRUM Y
    LOGLOG; SPECTRUM Y; ALLAN STANDARD DEVIATION PLOT Y
    END OF MULTIPLOT
 
Program 2:
    . THIS IS AN EXAMPLE OF AN ALLAN SD PLOT
    . FOR RANDOM WALK DATA  S(W) = W**(-2)
    . (THUS THE LOGLOG SPECTRUM HAS SLOPE -2 AND
    . AND THE ALLAN VARIANCE PLOT HAS SLOPE (-(-2)-1)/2 = 1/2
    SKIP 25; READ RANDWALK.DAT Y
    TITLE RANDOM WALK
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    GRID ON; X3LABEL AUTOMATIC
    PLOT Y; SPECTRUM Y
    LOGLOG; SPECTRUM Y; ALLAN STANDARD DEVIATION PLOT Y
    END OF MULTIPLOT
 
Program 3:
    . THIS IS AN EXAMPLE OF AN ALLAN SD PLOT
    . FOR FLICKER NOISE DATA  S(W) = W**(-1)
    . (THUS THE LOGLOG SPECTRUM HAS SLOPE -1 AND
    . AND THE ALLAN VARIANCE PLOT HAS SLOPE (-(-1)-1)/2 = 0
    SKIP 25; READ FLICKER.DAT Y
    TITLE FLICKER DATA
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    GRID ON; X3LABEL AUTOMATIC
    PLOT Y; SPECTRUM Y
    LOGLOG; SPECTRUM Y; ALLAN STANDARD DEVIATION PLOT Y
    END OF MULTIPLOT
 
-----ALPCDF (LET)--------------------------------
 
ALPCDF
 
Name:
    ALPCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the alpha cumulative distribution function with
    shape parameter alpha.
 
Description:
    The alpha distribution has the following cumulative
    distribution function:

        F(x;alpha) = NORCDF(alpha - (1/x))/NORCDF(alpha)
                     x > 0; alpha > 0

    with alpha denoting the shape parameter.

    This distribution can be generalized with location and
    scale parameters using the relation

       F(x;alpha,loc,scale) = F((x-loc)/scale;alpha,0,1)

    If Y has a normal distribution with location and scale
    parameters mu and sigma truncated to the left of 0,
    then X = 1/Y has an alpha distribution with shape parameter
    alpha = mu/sigma and scale parameter sigma.

    This distribution has application in reliability.

Syntax:
    LET <y> = ALPCDF(<x>,<alpha>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable containing positive
               values;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed alpha cdf value is stored;
          <alpha> is a positive number, parameter, or variable that
               specifies the shape parameter;
          <loc> is a number, parameter, or variable that specifies
               the location parameter;
          <scale> is a positive number, parameter, or variable that
               specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = ALPCDF(0.3,2.5)
    LET A = ALPCDF(X1,2.5,0,10)
    PLOT ALPCDF(X,2.5,0,3) FOR X = 0.1  0.1  10
 
Note:
    The 11/2007 version changed the syntax for this function
    from

        LET A = ALPCDF(X,ALPHA,BETA,LOC,SCALE)

    to

        LET A = ALPCDF(X,ALPHA,LOC,SCALE)

    This was done since BETA is in fact a scale parameter
    (in the articles listed in the References section, BETA
    is actually the reciprocal of the scale parameter).

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ALPCHAZ = Compute the alpha cumualtive hazard function.
    ALPHAZ  = Compute the alpha hazard function.
    ALPPDF  = Compute the alpha probability density function.
    ALPPPF  = Compute the alpha percent point function.
    PEXPDF  = Compute the exponential power probability density
              function.
    WEIPDF  = Compute the Weibull probability density function.
    LGNPDF  = Compute the log-normal probability density function.
    NORCDF  = Compute the normal cumulative distribution function.
    NORPDF  = Compute the normal probability density function.
 
Reference:
    Johnson, Kotz, and Balakrishnan (1994), "Continuous Univariate
    Distributions--Volume 1", Second Edition, John Wiley and Sons,
    p. 173.

    Salvia (1985), "Reliability applications of the Alpha
    Distribution", IEEE Transactions on Reliability, Vol. R-34,
    No. 3, pp. 251-252.

Applications:
    Reliability, accelerated life testing
 
Implementation Date:
    1998/4
    2007/11: Corrected the second shape parameter to be the
             scale parameter

Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    LET ALPHA  = 0.5
    TITLE ALPHA = ^alpha
    PLOT ALPCDF(X,ALPHA) FOR X = 0.01  0.01  5
    .
    LET ALPHA  = 1
    TITLE ALPHA = ^alpha
    PLOT ALPCDF(X,ALPHA) FOR X = 0.01  0.01  5
    .
    LET ALPHA  = 2
    TITLE ALPHA = ^alpha
    PLOT ALPCDF(X,ALPHA) FOR X = 0.01  0.01  5
    .
    LET ALPHA  = 5
    TITLE ALPHA = ^alpha
    PLOT ALPCDF(X,ALPHA) FOR X = 0.01  0.01  5
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Alpha Cumulative Distribution Functions

-----ALPCHAZ (LET)--------------------------------
 
ALPCHAZ
 
Name:
    ALPCHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the alpha cumulative hazard function with shape
    parameter alpha.
 
Description:
    The alpha distribution has the following cumulative
    hazard function:

       H(x;alpha) = -LOG(1 - NORCDF(alpha - 1/x)/NORCDF(alpha))
                     x > 0; alpha > 0

    with alpha denoting the shape parameter and where NORCDF is
    the cumulative distribution function of the standard normal
    distribution.

    This distribution can be generalized with location and
    scale parameters using the relation

       H(x;alpha,loc,scale) = H((x-loc)/scale;alpha,0,1)

    If Y has a normal distribution with location and scale
    parameters mu and sigma truncated to the left of 0,
    then X = 1/Y has an alpha distribution with shape parameter
    alpha = mu/sigma and scale parameter sigma.

    This distribution has application in reliability.

Syntax:
    LET <y> = ALPCHAZ(<x>,<alpha>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable containing positive
               values;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed alpha cumulative hazard value is
               stored;
          <alpha> is a positive number, parameter, or variable that
               specifies the shape parameter;
          <loc> is a number, parameter, or variable that specifies
               the location parameter;
          <scale> is a positive number, parameter, or variable that
               specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = ALPCHAZ(0.3,2.5)
    LET A = ALPCHAZ(X1,2.5,0,10)
    PLOT ALPCHAZ(X,2.5,0,3) FOR X = 0.1  0.1  10
 
Note:
    The 11/2007 version changed the syntax for this function
    from

        LET A = ALPCHAZ(X,ALPHA,BETA,LOC,SCALE)

    to

        LET A = ALPCHAZ(X,ALPHA,LOC,SCALE)

    This was done since BETA is in fact a scale parameter
    (in the articles listed in the References section, BETA
    is actually the reciprocal of the scale parameter).

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ALPCDF  = Compute the alpha cumualtive distribution function.
    ALPCAZ  = Compute the alpha hazard function.
    ALPPDF  = Compute the alpha probability density function.
    ALPPPF  = Compute the alpha percent point function.
    PEXPDF  = Compute the exponential power probability density
              function.
    WEIPDF  = Compute the Weibull probability density function.
    LGNPDF  = Compute the log-normal probability density function.
    NORCDF  = Compute the normal cumulative distribution function.
    NORPDF  = Compute the normal probability density function.
 
Reference:
    Johnson, Kotz, and Balakrishnan (1994), "Continuous Univariate
    Distributions--Volume 1", Second Edition, John Wiley and Sons,
    p. 173.

    Salvia (1985), "Reliability applications of the Alpha
    Distribution", IEEE Transactions on Reliability, Vol. R-34,
    No. 3, pp. 251-252.

Applications:
    Reliability, accelerated life testing
 
Implementation Date:
    1998/4
    2007/11: Corrected the second shape parameter to be the
             scale parameter

Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    LET ALPHA  = 0.5
    TITLE ALPHA = ^alpha
    PLOT ALPCHAZ(X,ALPHA) FOR X = 0.01  0.01  5
    .
    LET ALPHA  = 1
    TITLE ALPHA = ^alpha
    PLOT ALPCHAZ(X,ALPHA) FOR X = 0.01  0.01  5
    .
    LET ALPHA  = 2
    TITLE ALPHA = ^alpha
    PLOT ALPCHAZ(X,ALPHA) FOR X = 0.01  0.01  5
    .
    LET ALPHA  = 5
    TITLE ALPHA = ^alpha
    PLOT ALPCHAZ(X,ALPHA) FOR X = 0.01  0.01  5
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Alpha Cumulative Hazard Functions

-----ALPHAZ (LET)--------------------------------
 
ALPHAZ
 
Name:
    ALPHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the alpha hazard function with shape parameter
    alpha.
 
Description:
    The alpha distribution has the following hazard
    function:

       h(x;alpha) = NORPDF(t)/(x**2*(NORCDF(alpha)-NORCDF(t))
                     x > 0; alpha > 0

    with alpha denoting the shape parameter and where

       t       = alpha - 1/x
       NORCDF  = the cumulative distribution function of the
                 standard normal distribution
       NORPDF  = the probability density function of the
                 standard normal distribution


    This distribution can be generalized with location and
    scale parameters using the relation

       h(x;alpha,loc,scale) = (1/scale)*h((x-loc)/scale;alpha,0,1)

    If Y has a normal distribution with location and scale
    parameters mu and sigma truncated to the left of 0,
    then X = 1/Y has an alpha distribution with shape parameter
    alpha = mu/sigma and scale parameter sigma.

    This distribution has application in reliability.

Syntax:
    LET <y> = ALPHAZ(<x>,<alpha>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable containing positive
               values;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed alpha hazard value is stored;
          <alpha> is a positive number, parameter, or variable that
               specifies the shape parameter;
          <loc> is a number, parameter, or variable that specifies
               the location parameter;
          <scale> is a positive number, parameter, or variable that
               specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = ALPHAZ(0.3,2.5)
    LET A = ALPHAZ(X1,2.5,0,10)
    PLOT ALPHAZ(X,2.5,0,3) FOR X = 0.1  0.1  10
 
Note:
    The 11/2007 version changed the syntax for this function
    from

        LET A = ALPHAZ(X,ALPHA,BETA,LOC,SCALE)

    to

        LET A = ALPHAZ(X,ALPHA,LOC,SCALE)

    This was done since BETA is in fact a scale parameter
    (in the articles listed in the References section, BETA
    is actually the reciprocal of the scale parameter).

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ALPCDF  = Compute the alpha cumualtive distribution function.
    ALPCHAZ = Compute the alpha cumualtive hazard function.
    ALPPDF  = Compute the alpha probability density function.
    ALPPPF  = Compute the alpha percent point function.
    PEXPDF  = Compute the exponential power probability density
              function.
    WEIPDF  = Compute the Weibull probability density function.
    LGNPDF  = Compute the log-normal probability density function.
    NORCDF  = Compute the normal cumulative distribution function.
    NORPDF  = Compute the normal probability density function.
 
Reference:
    Johnson, Kotz, and Balakrishnan (1994), "Continuous Univariate
    Distributions--Volume 1", Second Edition, John Wiley and Sons,
    p. 173.

    Salvia (1985), "Reliability applications of the Alpha
    Distribution", IEEE Transactions on Reliability, Vol. R-34,
    No. 3, pp. 251-252.

Applications:
    Reliability, accelerated life testing
 
Implementation Date:
    1998/4
    2007/11: Corrected the second shape parameter to be the
             scale parameter

Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    LET ALPHA  = 0.5
    TITLE ALPHA = ^alpha
    PLOT ALPHAZ(X,ALPHA) FOR X = 0.01  0.01  5
    .
    LET ALPHA  = 1
    TITLE ALPHA = ^alpha
    PLOT ALPHAZ(X,ALPHA) FOR X = 0.01  0.01  5
    .
    LET ALPHA  = 2
    TITLE ALPHA = ^alpha
    PLOT ALPHAZ(X,ALPHA) FOR X = 0.01  0.01  5
    .
    LET ALPHA  = 5
    TITLE ALPHA = ^alpha
    PLOT ALPHAZ(X,ALPHA) FOR X = 0.01  0.01  5
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Alpha Hazard Functions

-----ALPPDF (LET)--------------------------------
 
ALPPDF
 
Name:
    ALPPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the alpha probability density function with
    shape parameter alpha.
 
Description:
    The alpha distribution has the following probability
    density function:

        f(x;alpha) = NORPDF(alpha - (1/x))/{x**2*NORCDF(alpha)}
                     x > 0; alpha > 0

    with alpha denoting the shape parameter and where

        NORCDF  = the standard normal cumulative distribution
                  function
        NORPDF  = the standard normal probability density
                  function

    This distribution can be generalized with location and
    scale parameters using the relation

       f(x;alpha,loc,scale) = (1/scale)*f((x-loc)/scale;alpha,0,1)

    If Y has a normal distribution with location and scale
    parameters mu and sigma truncated to the left of 0,
    then X = 1/Y has an alpha distribution with shape parameter
    alpha = mu/sigma and scale parameter sigma.

    This distribution has application in reliability.

Syntax:
    LET <y> = ALPPDF(<x>,<alpha>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable containing positive
               values;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed alpha pdf value is stored;
          <alpha> is a positive number, parameter, or variable that
               specifies the shape parameter;
          <loc> is a number, parameter, or variable that specifies
               the location parameter;
          <scale> is a positive number, parameter, or variable that
               specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = ALPPDF(0.3,2.5)
    LET A = ALPPDF(X1,2.5,0,10)
    PLOT ALPPDF(X,2.5,0,3) FOR X = 0.1  0.1  10
 
Note:
    The 11/2007 version changed the syntax for this function
    from

        LET A = ALPPDF(X,ALPHA,BETA,LOC,SCALE)

    to

        LET A = ALPPDF(X,ALPHA,LOC,SCALE)

    This was done since BETA is in fact a scale parameter
    (in the articles listed in the References section, BETA
    is actually the reciprocal of the scale parameter).

Note:
    Alpha random numbers, probability plots, and goodness of fit
    tests can be generated with the commands:

       LET ALPHA = <value>
       LET Y = ALPHA RANDOM NUMBERS FOR I = 1 1 N
       ALPHA PROBABILITY PLOT Y
       ALPHA PROBABILITY PLOT Y2 X2
       ALPHA PROBABILITY PLOT Y3 XLOW XHIGH
       ALPHA KOLMOGOROV SMIRNOV GOODNESS OF FIT Y
       ALPHA CHI-SQUARE GOODNESS OF FIT Y2 X2
       ALPHA CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    The following commands can be used to estimate the alpha
    shape parameter for the alpha distribution:

       LET ALPHA1 = <value>
       LET ALPHA2 = <value>
       ALPHA PPCC PLOT Y
       ALPHA PPCC PLOT Y2 X2
       ALPHA PPCC PLOT Y3 XLOW XHIGH
       ALPHA KS PLOT Y
       ALPHA KS PLOT Y2 X2
       ALPHA KS PLOT Y3 XLOW XHIGH

    The default values for ALPHA1 and ALPHA2 are 0.5 and 10.

    The probability plot can then be used to estimate the
    location and scale (location = PPA0, scale = PPA1).

    The BOOTSTRAP DISTRIBUTION command can be used to find
    uncertainty intervals for the parameter estimates obtained
    from the ppcc plot and the ks plot methods.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ALPCDF  = Compute the alpha cumualtive distribution function.
    ALPCHAZ = Compute the alpha cumualtive hazard function.
    ALPHAZ  = Compute the alpha hazard function.
    ALPPPF  = Compute the alpha percent point function.
    PEXPDF  = Compute the exponential power probability density
              function.
    WEIPDF  = Compute the Weibull probability density function.
    LGNPDF  = Compute the log-normal probability density function.
    NORCDF  = Compute the normal cumulative distribution function.
    NORPDF  = Compute the normal probability density function.
 
Reference:
    Johnson, Kotz, and Balakrishnan (1994), "Continuous Univariate
    Distributions--Volume 1", Second Edition, John Wiley and Sons,
    p. 173.

    Salvia (1985), "Reliability applications of the Alpha
    Distribution", IEEE Transactions on Reliability, Vol. R-34,
    No. 3, pp. 251-252.

Applications:
    Reliability, accelerated life testing
 
Implementation Date:
    1998/4
    2007/11: Corrected the second shape parameter to be the
             scale parameter

Program 1:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    LET ALPHA  = 0.5
    TITLE ALPHA = ^alpha
    PLOT ALPPDF(X,ALPHA) FOR X = 0.01  0.01  5
    .
    LET ALPHA  = 1
    TITLE ALPHA = ^alpha
    PLOT ALPPDF(X,ALPHA) FOR X = 0.01  0.01  5
    .
    LET ALPHA  = 2
    TITLE ALPHA = ^alpha
    PLOT ALPPDF(X,ALPHA) FOR X = 0.01  0.01  5
    .
    LET ALPHA  = 5
    TITLE ALPHA = ^alpha
    PLOT ALPPDF(X,ALPHA) FOR X = 0.01  0.01  5
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Alpha Probability Density Functions
 
Program 2:
    let alpha = 2.4
    let y = alpha random numbers for i = 1 1 200
    let y = 10*y
    let alphasav = alpha
    let amax = maximum y
    .
    alpha ppcc plot y
    let alpha1 = alpha - 1
    let alpha1 = max(alpha1,0.1)
    let alpha2 = alpha + 1
    y1label Correlation Coefficient
    x1label Alpha
    alpha ppcc plot y
    justification center
    move 50 6
    let alpha = shape
    text Alphahat = ^alpha (True Value: ^alphasav)
    .
    char x
    line bl
    y1label Data
    x1label Theoretical
    alpha prob plot y
    move 50 6
    text Location = ^ppa0, Scale = ^ppa1
    move 50 2
    text PPCC = ^ppcc
    char bl
    line so
    label
    .
    relative histogram y
    limits freeze
    pre-erase off
    plot alppdf(x,alpha,ppa0,ppa1) for x = 0.01 .01 amax
    limits 
    pre-erase on
    .
    let ksloc = ppa0
    let ksscale = ppa1
    alpha kolm smir goodness of fit y

-----ALPPPF (LET)--------------------------------
 
ALPPPF
 
Name:
    ALPPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the alpha percent point function with shape
    parameter alpha.
 
Description:
    The alpha distribution has the following percent point
    function:

       G(p;alpha) = 1/[alpha - NORPPF(p*NORCDF(alpha))]
                    0 < alpha < 1; alpha > 0

    with alpha denoting the shape parameter.

    This distribution can be generalized with location and
    scale parameters using the relation

       G(p;alpha,loc,scale) = loc + scale*G(p;alpha,0,1)

    If Y has a normal distribution with location and scale
    parameters mu and sigma truncated to the left of 0,
    then X = 1/Y has an alpha distribution with shape parameter
    alpha = mu/sigma and scale parameter sigma.

    This distribution has application in reliability.

Syntax:
    LET <y> = ALPPPF(<p>,<alpha>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable containing positive
               values;
          <y> is a variable or a parameter (depending on what <p> is)
               where the computed alpha ppf value is stored;
          <alpha> is a positive number, parameter, or variable that
               specifies the shape parameter;
          <loc> is a number, parameter, or variable that specifies
               the location parameter;
          <scale> is a positive number, parameter, or variable that
               specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = ALPPPF(0.95,2.5)
    LET A = ALPPPF(P1,2.5,0,10)
    PLOT ALPPPF(P,2.5,0,3) FOR P = 0.01  0.01  0.99
 
Note:
    The 11/2007 version changed the syntax for this function
    from

        LET A = ALPPPF(P,ALPHA,BETA,LOC,SCALE)

    to

        LET A = ALPPPF(P,ALPHA,LOC,SCALE)

    This was done since BETA is in fact a scale parameter
    (in the articles listed in the References section, BETA
    is actually the reciprocal of the scale parameter).

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ALPCDF  = Compute the alpha cumulative distribution function.
    ALPCHAZ = Compute the alpha cumualtive hazard function.
    ALPHAZ  = Compute the alpha hazard function.
    ALPPDF  = Compute the alpha probability density function.
    PEXPDF  = Compute the exponential power probability density
              function.
    WEIPDF  = Compute the Weibull probability density function.
    LGNPDF  = Compute the log-normal probability density function.
    NORCDF  = Compute the normal cumulative distribution function.
    NORPDF  = Compute the normal probability density function.
 
Reference:
    Johnson, Kotz, and Balakrishnan (1994), "Continuous Univariate
    Distributions--Volume 1", Second Edition, John Wiley and Sons,
    p. 173.

    Salvia (1985), "Reliability applications of the Alpha
    Distribution", IEEE Transactions on Reliability, Vol. R-34,
    No. 3, pp. 251-252.

Applications:
    Reliability, accelerated life testing
 
Implementation Date:
    1998/4
    2007/11: Corrected the second shape parameter to be the
             scale parameter

Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    LET ALPHA  = 0.5
    TITLE ALPHA = ^alpha
    PLOT ALPPPF(P,ALPHA) FOR P = 0.01  0.01  0.99
    .
    LET ALPHA  = 1
    TITLE ALPHA = ^alpha
    PLOT ALPPPF(P,ALPHA) FOR P = 0.01  0.01  0.99
    .
    LET ALPHA  = 2
    TITLE ALPHA = ^alpha
    PLOT ALPPPF(P,ALPHA) FOR P = 0.01  0.01  0.99
    .
    LET ALPHA  = 5
    TITLE ALPHA = ^alpha
    PLOT ALPPPF(P,ALPHA) FOR P = 0.01  0.01  0.99
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Alpha Percent Point Functions

-----AMPLIFIER-------------------------------------------------------
 
AMPLIFIER
 
Name:
    AMPLIFIER
 
Type:
    Plot Control Command
 
Purpose:
    Draws an amplifier (a component used in electronic circuit
    diagrams).
 
Description:
    The 2 pairs of coordinates define the (x,y) values for the start
    point and the end point (respectively) of the amplifier.
 
Syntax:
    AMPLIFIER   <x1>   <y1>   <x2>   <y2>
    where <x1> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for the start point of
               the amplifier;
          <y1> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for the start point of
               the amplifier;
          <x2> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for the stop point of
               the amplifier;
    and   <y2> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for the stop point of
               the amplifier.
 
Examples:
    AMPLIFIER 50 50 60 50
    AMPLIFIER 50 50 60 60
    AMPLIFIER 20 20 25 20
    AMPLIFIER 20 70 25 70
    AMPLIFIER 30 50 40 50
    AMPLIFIER X1 Y1 X2 Y2
 
Note:
    The line style (i.e., solid, dash), color, and thickness of the
    amplifier are controlled by the LINE, LINE COLOR, and LINE
    THICKNESS commands.
 
Note:
    The keywords DATA and RELATIVE were added to the TRIANGLE
    command 7/1997.  These keywords are independent and can
    be used separately or together.  For example, 
    TRIANGLE DATA, TRIANGLE RELATIVE, or TRIANGLE DATA RELATIVE.
    The word DATA should come before the word RELATIVE if both
    appear.

    DATA means that the coordinates are specified in terms of
    the data units of the most recent plot rather than Dataplot
    0 to 100 screen units.

    RELATIVE means that the coordinates of the first point
    are drawn in absolute coordinates an all subsequent points
    in the figure are relative to that first point.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CAPACITOR        = Draws a capacitor.
    GROUND           = Draws a ground.
    INDUCTOR         = Draws an inductor.
    RESISTOR         = Draws a resistor.
    MOVE             = Moves to a point.
    DRAW             = Draws a line.
    LINES            = Sets the line type for figures and plot lines.
    LINE THICKNESSES = Sets the line thickness for figures and plot
                       lines.
    LINE COLOR       = Sets the line colors for figures and plot lines.
    CROSS-HAIR       = Activates and reads the cross-hair.
    TEXT             = Writes a text string.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    Pre-1987
 
Program:
    LINE SOLID
    LINE COLOR BLACK
    LINE THICKNESS 0.2
    AMPLIFIER 20 70 50 70
 
-----AND-------------------------------------------------------
 
AND
 
Name:
    AND
 
Type:
    Keyword
 
Purpose:
    Allows multiple PLOT or 3D-PLOT command lines to be "strung
    together" to generate multi-trace or multi-surface plots,
    respectively.
 
Syntax:
    <any valid PLOT or 3D-PLOT statement> AND
    <any valid PLOT or 3D-PLOT statement> AND
    <any valid PLOT or 3D-PLOT statement> AND
    .
    .
    .
    <any valid PLOT or 3D-PLOT statement>
 
Examples:
    PLOT Y X AND
    PLOT SIN(X) FOR X = 0 .1 6
 
    PLOT Y1 Y2 Y3 VS X AND
    PLOT Y X D
 
    3D-PLOT Y X1 X2 AND
    3D-PLOT EXP(-X-Y) FOR X = 0 .1 1 FOR Y = 3 .5 7
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    PLOT      = Generates a data or function plot.
    VERSUS    = Allows several variables to be plotted.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    PLOT X**2 FOR X = 1 1 9 AND
    PLOT X**3 FOR X = 1 1 9
 
 
 
 
 
Name:
    AND
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Draws an And Gate (a logical device used in electronic circuit
    diagrams).
 
Description:
    The 2 pairs of coordinates define the (x,y) values for the middle
    back and the middle front (respectively) of the And Gate.
 
Syntax:
    AND   <x1>   <y1>   <x2>   <y2>
    where <x1> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for the middle back
               point of the And Gate;
          <y1> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for the middle back
               point of the And Gate;
          <x2> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for the middle front
               point of the And Gate;
    and   <y2> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for the middle front
               point of the And Gate.
 
Examples:
    AND 50 50 60 50
    AND 50 50 60 60
    AND 20 20 25 20
    AND X1 Y1 X2 Y2
 
Note:
    The line style (i.e., solid, dash), color, and thickness of the
    amplifier are controlled by the LINE, LINE COLOR, and LINE
    THICKNESS commands.
 
Note:
    The keywords DATA and RELATIVE were added to the TRIANGLE
    command 7/1997.  These keywords are independent and can
    be used separately or together.  For example, 
    TRIANGLE DATA, TRIANGLE RELATIVE, or TRIANGLE DATA RELATIVE.
    The word DATA should come before the word RELATIVE if both
    appear.

    DATA means that the coordinates are specified in terms of
    the data units of the most recent plot rather than Dataplot
    0 to 100 screen units.

    RELATIVE means that the coordinates of the first point
    are drawn in absolute coordinates an all subsequent points
    in the figure are relative to that first point.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    OR               = Draws an or gate.
    NAND             = Draws a nand gate.
    NOR              = Draws a nor gate.
    MOVE             = Moves to a point.
    DRAW             = Draws a line.
    LINES            = Sets the line type for figures and plot lines.
    LINE THICKNESSES = Sets the line thickness for figures and plot
                       lines.
    LINE COLOR       = Sets the line colors for figures and plot lines.
    CROSS-HAIR       = Activates and reads the cross-hair.
    TEXT             = Writes a text string.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    Pre-1987
 
Program:
    LINE SOLID
    LINE COLOR BLACK
    LINE THICKNESS 0.2
    AND 20 20 60 60
 
-----ANDERSON DARLING TEST---------------------------------
 
ANDERSON DARLING TEST
 
Name:
    ANDERSON DARLING TEST
 
    NOTE: This command has been replaced with the unified
          GOODNESS OF FIT command (enter HELP GOODNESS OF FIT
          for details).

Type:
    Analysis Command
 
Purpose:
    Perform an Anderson-Darling goodnes of fit test that a
    data set comes from a specified distribution.  Currently,
    Dataplot supports the Anderson-Darling goodness of fit
    test for the normal, lognormal, Weibull, exponential,
    extreme value type 1, logistic, double exponential, and
    generalized Pareto distributions.

Description:
    The Anderson-Darling test (Stephens, 1974) is used to test if a
    sample of data comes from a specific distribution.  It is a
    modification of the Kolmogorov-Smirnov (K-S) test and
    gives more weight to the tails than the K-S test.  The K-S
    test is distribution free in the sense that the critical values
    do not depend on the specific distribution being tested.  The
    Anderson-Darling test makes use of the specific distribution in
    calculating critical values.  This has the advantage of allowing
    a more sensitive test and the disadvantage that critical values
    must be calculated for each distribution.  Currently, Dataplot
    supports the Anderson-Darling test for the following distributions:

       1) normal,
       2) lognormal,
       3) exponential,
       4) Weibull, and
       5) extreme value type 1 (Gumbel)
       6) logistic
       7) double exponential
       8) uniform (0,1)
       9) generalized Pareto
      10) Cauchy
      11) Extreme Value Type 2 (Frechet)

    Note that the uniform (0,1) case can be used for fully
    specified distributions (i.e., the shape, location, and
    scale parameters are not estimated from the data).  Simply
    apply the appropriate CDF function to the data (this transforms
    it to a (0,1) interval) and apply the uniform (0,1) test to
    the transformed data.

    More formally, the test is defined as follows.

    H0:        The data follows a specified distribution.
    Ha:        The data do not follow the specified distribution

    Test       The Anderson-Darling test statistic is defined as:
    Statistic:
                   A**2 = -N - S

               where 

                   S = SUM((2*i-1)/N)[LOG(F(Y(i)+LOG(1-F(Y(N+1-i)))]

               where the summation is from 1 to N and F is the
               cumulative distribution function of interest.

    Significance  alpha
    Level:

    Critical   The critical values for the Anderson-Darling test are
    Region:    dependent on the specific distribution being tested.
               Tabulated values and formulas have been published
               by Stephens for a few specific distributions (normal,
               lognormal, exponential, Weibull, logistic, extreme value
               type 1, logistic, double exponential, uniform,
               generalized pareto).  The test is a one-sided test
               and the hypothesis that the distribution is of a
               specific form is rejected if the test statistic, A,
               is greater than the critical value.

    Note that relevant parameters for the distribution being tested
    are estimated from the data.

Syntax:
    ANDERSON DARLING <DIST> TEST <y>
                                 <SUBSET/EXCEPT/FOR qualification>
    where <DIST> is NORMAL, LOGNORMAL, WEIBULL, EXPONENTIAL, EV1,
              LOGISTIC, DOUBLE EXPONENTIAL, UNIFORM or
              GENERALIZED PARETO;
          <y> is the response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    ANDERSON DARLING NORMAL TEST Y
    ANDERSON DARLING TEST Y
    ANDERSON DARLING LOGNORMAL TEST Y
    ANDERSON DARLING EXPONENTIAL TEST Y
    ANDERSON DARLING WEIBULL TEST Y
    ANDERSON DARLING NORMAL TEST Y  SUBSET GROUP = 2 TO 4
 
Note:
    If the CAPTURE HTML or CAPTURE LATEX commands are used, the
    output from the Anderson-Darling test will be generated in
    HTML or Latex format, respectively.  Enter HELP CAPTURE HTML
    or CAPTURE LATEX for details.

Note:
    By default, the Anderson-Darling test will compute the
    maximum likelihood estimates of the data for the specified
    distribution.  It then uses these estimates in computing
    the Anderson-Darling test.

    For some of the distributions, you can specify your own
    estimates of the parameters.  Specifically,

        LET ALPHA = <value of location parameter>
        LET BETA = <value of scale parameter>
        ANDERSON DARLING LOGISTIC TEST Y

        LET GAMMA = <value of shape parameter>
        LET BETA = <value of scale parameter>
        ANDERSON DARLING WEIBULL TEST Y

        LET GAMMA = <value of shape parameter>
        LET A = <value of scale parameter>
        ANDERSON DARLING WEIBULL TEST Y

        LET GAMMA = <value of shape parameter>
        LET A = <value of scale parameter>
        ANDERSON DARLING FRECHET TEST Y

    The maximum likelihood estimation for the generalized Pareto
    distribution is still undergoing algorithmic development, so
    it is suggested that you estimate the parameters using some
    other method (e.g., PPCC PLOT) first and then apply the
    Anderson-Darling test.

Default:
    If no distribution is specified, then the data is tested for
    normality.
 
Synonyms:
    ANDERSON DARLING <DIST> is a synonym for ANDERSON DARLING <DIST>
    TEST.
 
Related Commands:
    KOLMOGOROV SMIRNOV GOODNESS     = Perform a Kolmogorov Smirnov
    OF FIT TEST                       goodness of fit test.
    CHI SQUARE GOODNESS OF FIT TEST = Perform a Chisquare goodness
                                      of fit test.
    WILK SHAPIRO TEST               = Perform a Wilks-Shapiro test for
                                      normality.
    PROBABILITY PLOT                = Generate a probability plot.
                             of fit test.
 
Reference:
    "EDF Statistics for Goodness of Fit and Some Comparisons",
    Stephens, M. A. (1974), Journal of the American Statistical
    Association, Vol. 69, pp. 730-737.

    "Asymptotic Results for Goodness-of-Fit Statistics with Unknown
    Parameters", Stephens, M. A. (1976), Annals of Statistics,
    Vol. 4, pp. 357-369.

    "Goodness of Fit for the Extreme Value Distribution",
    Stephens, M. A.  (1977), Biometrika, Vol. 64, pp. 583-588.

    "Goodness of Fit with Special Reference to Tests for
    Exponentiality", Stephens, M. A. (1977), Technical Report No. 262,
    Department of Statistics, Stanford University, Stanford, CA.

    "Tests of Fit for the Logistic Distribution Based on the
    Empirical Distribution Function", Stephens, M. A. (1979), 
    Biometrika, Vol. 66, pp. 591-595.

    "MIL-HDBK-17 Volume 1: Guidelines for Characterization of
    Structural Materials", Depeartment of Defense, chapter 8.
    The URL for MIL-HDBK-17 is http://mil-17.udel.edu/.

    "Goodness-of-Fit Tests for the Generalized Pareto Distribution",
    V. Choulakian and M. A. Stephens, Technometrics, November, 2001,
    Vol. 43, No. 4, pp. 478-484.

Applications:
    Reliability
 
Implementation Date:
    1998/5
    2000/10: Fix to estimate shape and scale parameters for Weibull
    2003/10: Support for CAPTURE HTML and CAPTURE LATEX
    2003/11: Support for logistic, double exponential, and uniform
             distributions
    2004/4:  Support for generalized Pareto
 
Program:
    SKIP 25
    READ VANGEL31.DAT Y
    ANDERSON DARLING EXPONENTIAL TEST Y
 
    The following output is generated:

      
           *******************************************
           **  anderson darling exponential test y  **
           *******************************************
      
      
                   ANDERSON DARLING 1-SAMPLE TEST
                   THAT THE DATA COME FROM A EXPONENTIAL          DISTRIBUTION
      
     1. STATISTICS:
           NUMBER OF OBSERVATIONS                =       38
           LOCATION PARAMETER                    =    185.7895
           SCALE PARAMETER                       =    18.59549
      
           ANDERSON DARLING TEST STATISTIC VALUE =    14.35715
      
     2. CRITICAL VALUES:
           90         % POINT    =    1.062000
           95         % POINT    =    1.321000
           97.5       % POINT    =    1.591000
           99         % POINT    =    1.959000
      
     3. CONCLUSION (AT THE 5% LEVEL):
           THE DATA DO NOT COME FROM A EXPONENTIAL         DISTRIBUTION.
  
-----ANDERSON DARLING K SAMPLE TEST---------------------------------
 
ANDERSON DARLING K SAMPLE TEST
 
Name:
    ANDERSON DARLING K SAMPLE TEST
 
Type:
    Analysis Command
 
Purpose:
    The k-sample Anderson-Darling test is a nonparametric
    statistical procedure that tests the hypothesis that
    the populations from which two or more groups of data
    were drawn are identical.  Each group should be an
    independent random sample from a population.
 
Description:
    This test is part of the MIL-HDBK-17 standard.  In the
    terminology of MIL-HDBK-17, data can be either "structured"
    (i. e., groups) or "unstructured" (i.e., ungrouped).
    Unstructured data can often be simpler to analyze.  Therefore
    the Anderson-Darling k-sample test is used to determine if
    a structured data set can in fact be treated as an
    unstructured data set.  Dataplot supports most of the techniques
    in chapter 8 of the MIL-HDBK-17 as support for the RECIPE
    analysis. 
  
    The k-sample Anderson-Darling statistic is

        ADK = (n-1)/(n**2*(k-1))*SUM[i=1][k][(1/n(i))*SUM1]

    where 

  
        SUM1  = SUM[j=1][L][h(j)*NUM/DEN]
        NUM   = (n*F(ij) - n(i)*H(j))**2
        DEM   = H(j)(n - H(j)) - n*h(j)/4
        h(j)  = the number of values in the combined samples
                equal to z(j)
        H(j)  = the number of values in the combined samples
                less than z(j) plus one half the number of
                of values in the combined samples equal to
                z(j)
        F(ij) = the number of values in the ith group which
                are less than z(j) plus one half the number
                of values in this group which are equal to
                z(j).
       
    where k is the number of samples (groups), n(i) is the
    n(i) is the number of observations in group i, x(ij) is the
    jth observation in the ith group, and z(1), z(2), ..., z(L)
    are the distinct values in the combined data set ordered
    from smallest to largest (L is less than n if there are
    tied observations).

    Chapter 8 of the MIL-HDBK-17 derives the formulas for the
    critical values of the Anderson-Darling test statistic.  These
    formulas are rather involved and not given here.

    Dataplot uses the ANDYK routine from the MIL-HDBK-17 to
    compute the Anderson-Darling k sample test.

Syntax:
    ANDERSON DARLING K SAMPLE TEST <y> <groupid> 
                                   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <groupid> is group (sample) identifier variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    ANDERSON DARLING K SAMPLE TEST Y1  GROUP
    ANDERSON DARLING K SAMPLE TEST Y1  GROUP  SUBSET GROUP > 2
 
Note:
    The following statistics are also supported:

        LET A = ANDERSON DARLING K SAMPLE TEST                Y X

        LET ALPHA = <value>
        LET A = ANDERSON DARLING K SAMPLE TEST CRITICAL VALUE Y X

    with Y denoting the response variable, X denoting the group-id
    variable, and ALPHA denoting the significance level for the
    critical value.

    In addition to the above LET command, built-in statistics are
    supported for about 20+ different commands (enter HELP STATISTICS
    for details).

Default:
    None
 
Synonyms:
    ANDERSON DARLING K SAMPLE is a synonym for ANDERSON DARLING
    K SAMPLE TEST.
 
Related Commands:
    LEVENE TEST            = Compute Levene's test.
    BOX PLOT               = Generate a box plot.
    RECIPE FIT             = Perform a RECIPE analysis.
    GRUBBS TEST            = Compute a Grubbs test for outliers.
    ANDERSON DARLING TEST  = Anderson-Darling one sample goodness
                             of fit test.
 
Reference:
    "MIL-HDBK-17 Volume 1: Guidelines for Characterization of
    Structural Materials", Depeartment of Defense, chapter 8.
    The URL for MIL-HDBK-17 is http://mil-17.udel.edu/.

Applications:
    Tolerance Studies in Reliability of Materials
 
Implementation Date:
    1998/6
 
Program:
    SKIP 25
    READ VANGEL32.DAT Y X B
    ANDERSON DARLING K SAMPLE TEST Y X
 
    The following output is generated:

  
           **********************************************
           **      ANDERSON DARLING K SAMPLE TEST Y X  **
           **********************************************
      
      
                   ANDERSON-DARLING K-SAMPLE TEST FOR COMMON GROUPS
      
     1. STATISTICS
           NUMBER OF OBSERVATIONS                     =       45
           NUMBER OF GROUPS                           =        3
           ANDERSON-DARLING K-SAMPLE TEST STATISTIC   =    155.3625
      
     2. FOR ANDERSON-DARLING K-SAMPLE TEST STATISTIC
           95         % POINT                         =    1.992743
      
     3. CONCLUSION (AT THE 5% LEVEL):
           THE GROUPS ARE SIGNIFICANTLY DIFFERENT.
           THUS: GROUPS SHOULD BE TREATED AS STRUCTURED.
  
-----ANDREWS INCREMENT-----------------------------------------------
 
ANDREWS INCREMENT
 
Name:
    ANDREWS INCREMENT
 
Type:
    Support Command
 
Purpose:
    Specifies the x axis increment for generating Andrews curves.
 
Description:
    An Andrews curve applies the following transformation to a
    set of data:
        Fi(t) = X1i/SQRT(2) + X2i*SIN(t) + X3i*COS(t) +
                   X4i*SIN(2t) + X5i*COS(2t) + ...
    where t goes from -PI to PI.  This command allows the analyst to
    specify the increment for t.  A smaller increment generates a
    higher resolution curve at the expense of more data points per
    curve.
 
Syntax:
    ANDREWS INCREMENT    <inc>
    where <inc> is a positive decimal number or parameter that
    specifies the incrememnt.
 
Examples:
    ANDREWS INCREMENT 0.1
    ANDREWS INCREMENT 0.05
 
Default:
    0.1
 
Synonyms:
    None
 
Related Commands:
    ANDREWS PLOT  = Generate an Andrews plot.
 
Reference:
    "Graphical Exploratory Data Analysis", du Toit, Steyn, and Stumpf,
    Springer-Verlang, 1986.
 
Applications:
    Multivariate Analysis
 
Implementation Date:
    92/12
 
Program:
    read x1 x2 x3 x4 x5 x6
    16 16 19 21 20 23
    14 17 15 22 18 22
    24 23 21 24 20 23
    18 17 16 15 20 19
    18 11  9 18  7 14
    end of data
    .
    line color red blue green orange cyan
    title automatic
    ylimits -50 100
    ytic offset 0 10
    .
    xlimits -3 3
    xtic offset 0.2 0.2
    major xtic mark number 7
    .
    andrews plot x1 x2 x3 x4 x5 x6
 
-----ANDREWS PLOT--------------------------------------
 
ANDREWS PLOT
 
Name:
    ANDREWS PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates an Andrews plot.
 
Description:
    An Andrews plot is a graphical data analysis technique for plotting
    multivariate data.  An Andrews curve applies the following
    transformation to a set of data:
        Fi(t) = X1i/SQRT(2) + X2i*SIN(t) + X3i*COS(t) +
                   X4i*SIN(2t) + X5i*COS(2t) + ...
    where t goes from -PI to PI and X1, X2, etc. are the columns (i.e.,
    variables) of data.  One Andrews curve is generated for each row of
    data.  As usual, the LINE, LINE COLOR, and LINE THICKNESS commands
    can be used to control the attributes of the curves.  Andrews
    curves are used to distinguish which observations (i.e., rows) are
    most alike.
 
Syntax:
    ANDREWS PLOT  <y1> <y2> ... <yk>  <SUBSET/EXCEPT/FOR qualification>
    where <y1> through <yk> are the response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    ANDREWS PLOT Y1 Y2 Y3 Y4 Y5
    ANDREWS PLOT Y1 Y2 Y3 Y4 Y5 SUBSET TAG > 2
 
Note:
    The increment for t in the transformation can be set with the
    ANDREWS INCREMENT command.  It defaults to 0.1.
 
Note:
    Andrews curves are order dependent.  The first few variables tend
    to dominate, so it is a good idea to put the most important
    variables first.  Some analysts recommend running a principle
    components analysis first and generating Andrews curves for the
    principle components.
 
Note:
    Up to 20 variables can be used.
 
Note:
    The TO syntax is allowed on this command.  For example
          ANDREWS PLOT Y1 TO Y10
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LINES              = Sets the types for plot lines.
    PLOT               = Generates a data or function plot.
    STAR PLOT          = Generate a star plot.
    PROFILE PLOT       = Generate a profile plot.
    PARALLEL COOR PLOT = Generate a parallel coordinates plot.
    ANDREWS INCREMENT  = Specify the x axis increment when generating
                         Andrews curves.
 
Reference:
    "Graphical Exploratory Data Analysis", du Toit, Steyn, and Stumpf,
    Springer-Verlang, 1986.
 
Applications:
    Multivariate Analysis
 
Implementation Date:
    92/12
 
Program:
    read x1 x2 x3 x4 x5 x6
    16 16 19 21 20 23
    14 17 15 22 18 22
    24 23 21 24 20 23
    18 17 16 15 20 19
    18 11  9 18  7 14
    end of data
    .
    line color red blue green orange cyan
    title automatic
    ylimits -50 100
    ytic offset 0 10
    .
    xlimits -3 3
    xtic offset 0.2 0.2
    major xtic mark number 7
    .
    andrews plot x1 x2 x3 x4 x5 x6
 
-----ANGCDF (LET)--------------------------------
 
ANGCDF
 
Name:
    ANGCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the anglit cumulative distribution function.
 
Description:
    The anglit distribution has the following cumulative
    distribution function:

       F(x) = [SIN(x + PI/4)]**2      -PI/4 <= X <= PI/4
 
Syntax:
    LET <y> = ANGCDF(<x>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed anglit cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ANGCDF(3)
    LET A = ANGCDF(A1)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ANGPDF = Compute the anglit probability density function.
    ANGPPF = Compute the anglit percent point function.
    COSPDF = Compute the cosine probability density function.
    NORPDF = Compute the normal probability density function.
    UNIPDF = Compute the uniform probability density function.
 
Reference:
    "The Percent Point Function", J. J. Filliben, unpublished
    manuscript, 1970.
 
Applications:
    Data Analysis
 
Implementation Date:
    1995/9
 
Program:
    TITLE AUTOMATIC
    LET START = -PI/4
    LET STOP = PI/4
    PLOT ANGCDF(X) FOR X = START 0.01 STOP

-----ANGLE-------------------------------------------------------
 
ANGLE
 
Name:
    ANGLE
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Specifies the angle at which text from subsequent TEXT commands
    will be rotated.
 
Syntax:
    ANGLE   <n>
    where <n> is a number or parameter that specifies the desired angle
              in the current angle units (radians, degrees, grads).
 
Examples:
    ANGLE 45
    ANGLE 3.14159
 
Note:
    You should use a software font to draw text at an angle.
 
Note:
    The ANGLE command applies to the TEXT command.  Various other
    commands are used to set angles for other plot elements (e.g.,
    LEGEND ANGLE).
 
Default:
    Text is drawn horizontally (0 radians).
 
Synonyms:
    None
 
Related Commands:
    TEXT        = Writes a text string.
    DEGREES     = Sets the angle units to degrees.
    ANGLE UNITS = Sets the angle units (to degrees/radians/grads).
    RADIANS     = Sets the angle units to radians.
    GRADS       = Sets the angle units to grads.
    FONT        = Sets the font for TEXT characters.
    HEIGHT      = Sets the height for TEXT characters.
    WIDTH       = Sets the width for TEXT characters.
    COLOR       = Sets the color of TEXT characters.
    THICKNESS   = Sets the thickness of TEXT characters.
 
Applications:
    Diagramatic Graphics
 
Implementation Date:
    Pre-1987
 
Program:
    XX
 
-----ANGLE UNITS-------------------------------------------------------
 
ANGLE UNITS
 
Name:
    ANGLE UNITS
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the units (radians, degrees, grads) to be used for all
    subsequent trigonometric calculations (e.g., LET Y = SIN(X) and
    ANGLE 45).
 
Syntax:
    ANGLE UNITS   <RADIANS, DEGREES, or GRADS>
    where RADIANS specifies radians, DEGREES specifies degrees, and
    GRADS specifies grads.
 
Examples:
    ANGLE DEGREES
    ANGLE RADIANS
    ANGLE GRADS
 
Default:
    Angle units are given in radian units.
 
Synonyms:
    DEGREES is a synonym for ANGLE UNITS DEGREES.
    RADIANS is a synonym for ANGLE UNITS RADIANS.
    GRADS   is a synonym for ANGLE UNITS GRADS.
 
Related Commands:
    TEXT        = Writes a text string.
    DEGREES     = Sets angle units to degrees.
    ANGLE UNITS = Sets angle units (to degrees/radians/grads).
    RADIANS     = Sets angle units to radians.
    GRADS       = Sets angle units to grads.
    FONT        = Sets the font for TEXT characters.
    HEIGHT      = Sets the height for TEXT characters.
    WIDTH       = Sets the width for TEXT characters.
    COLOR       = Sets the color of TEXT characters.
    THICKNESS   = Sets the thicknesses of TEXT characters.
 
Applications:
    Diagrammatic Graphics
 
Implementation Date:
    Pre-1987
 
Program:
    XX
 
-----ANGPDF (LET)--------------------------------
 
ANGPDF
 
Name:
    ANGPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the anglit probability density function.
 
Description:
    The anglit distribution has the following probability density
    function:

       f(x) = SIN(2*x + PI/2)   -PI/4 <= X <= PI/4
 
Syntax:
    LET <y> = ANGPDF(<x>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed anglit pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ANGPDF(3)
    LET A = ANGPDF(A1)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ANGCDF = Compute the anglit cumulative distribution function.
    ANGPPF = Compute the anglit percent point function.
    COSPDF = Compute the cosine probability density function.
    NORPDF = Compute the normal probability density function.
    UNIPDF = Compute the uniform probability density function.
 
Reference:
    "The Percent Point Function", J. J. Filliben, unpublished
    manuscript, 1970.
 
Applications:
    Data Analysis
 
Implementation Date:
    1995/9
 
Program:
    TITLE AUTOMATIC
    LET START = -PI/4
    LET STOP = PI/4
    PLOT ANGPDF(X) FOR X = START 0.01 STOP

-----ANGPPF (LET)--------------------------------
 
ANGPPF
 
Name:
    ANGPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the anglit percent point function.
 
Description:
    The anglit distribution has the following percent point
    function:

       G(p) = ARCSIN(SQRT(p)) - PI/4      0 <= p <= 1
 
Syntax:
    LET <y> = ANGPPF(<p>)    <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what <p> is)
              where the computed anglit ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ANGPPF(3)
    LET A = ANGPPF(A1)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ANGCDF = Compute the anglit cumulative distribution function.
    ANGPDF = Compute the anglit probability density function.
    COSPDF = Compute the cosine probability density function.
    NORPDF = Compute the normal probability density function.
    UNIPDF = Compute the uniform probability density function.
 
Reference:
    "The Percent Point Function", J. J. Filliben, unpublished
    manuscript, 1970.
 
Applications:
    Data Analysis
 
Implementation Date:
    1995/9
 
Program:
    TITLE AUTOMATIC
    PLOT ANGPPF(P) FOR P = 0  0.01  1

-----ANGRAD (LET)--------------------------------
 
ANGRAD
 
Name:
    ANGRAD (LET)
 
Type:
    Library Function
 
Purpose:
    Return the counter clockwise angle, in radians, of the the angle
    determined by three vertices (i.e., two rays).
 
Description:
    Given the 3 sets of vertices (X1,Y1), (X2,Y2), and (X3,Y3), an angle
    is defined by the two line segments:

       1. (X1,Y1)  - (X2,Y2)
       2. (X2,Y2)  - (X3,Y3)

    There are actually two angles defined by these two line segments.  One
    is defined by the counter clockwise direction and the other is defined
    by the clockwise direction.  For example, given the points (0,1), (0,0)
    and (1,0), the counter clockwise angle is 3*PI/2 (= 4.712389) and the
    clockwise angle is PI/2 (= 1.570796).

    This function returns the counter clockwise angle.  To return the
    clockwise angle, you can do something like

       LET A = 2*PI - ANGRAD(X1,Y1,X2,Y2,X3,Y3)

Syntax:
    LET <y> = ANGRAD(<x1>,<y1>,<x2>,<y2>,<x3>,<y3>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x1> is a variable or a parameter containing the x coordinates
               of the first vertex;
          <y1> is a variable or a parameter containing the y coordinates
               of the first vertex;
          <x2> is a variable or a parameter containing the x coordinates
               of the second vertex;
          <y2> is a variable or a parameter containing the y coordinates
               of the second vertex;
          <x3> is a variable or a parameter containing the x coordinates
               of the third vertex;
          <y3> is a variable or a parameter containing the y coordinates
               of the third vertex;
          <y> is a variable or a parameter (depending on what the input
               arguments are) where the computed angle values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ANGRAD(0,1,0,0,1,0)
    LET A = ANGRAD(X1,Y1,X2,Y2,X3,Y3)

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Reference:
    This code is adapted from John Burkhardt's  geometry.f90 library.

Related Commands:
    DPNTLINE           = Compute the perpindicular distance between a point
                         and a line defined by a point and a slope.
    POINTS IN POLYGON  = Determine whether points are in the interior
                         of a convex polygon.
    CONVEX HULL        = Determine the convex hull of a set of points.
    TRANSFORM POINTS   = Perform location, scale, and rotation
                         transformation for a set of points.
    EXTREME POINTS     = Determine the extreme points of a set of points.
    LINE INTERSECTIONS = Determine the intersection points for a set of
                         lines.
    PARALLEL LINE      = Determine the coordinates for a point that defines
                         a parallel line determined by a point and a line
                         defined by two points.
    PERPINDICULAR LINE = Determine the coordinates for a point that defines
                         a perpindicular line determined by a point and a line
                         defined by two points.
 
Applications:
    Computational Geometry
 
Implementation Date:
    2012/10
 
Program:
    LET X1 = DATA  0 -1  0  1
    LET Y1 = DATA  1  0 -1  0
    LET X2 = 0 FOR I = 1 1 4
    LET Y2 = 0 FOR I = 1 1 4
    LET X3 = 1 FOR I = 1 1 4
    LET Y3 = 0 FOR I = 1 1 4
    LET YANG = ANGRAD(X1,Y1,X2,Y2,X3,Y3)
    SET WRITE DECIMALS 4
    PRINT X1 Y1 YANG
 
-----ANOP LIMITS--------------------------------------
 
ANOP LIMITS
 
Name:
    ANOP LIMITS
 
Type:
    Support Command
 
Purpose:
    Define the upper and lower bounds for counting a response a success
    or failure in a subsequent analysis of proportions plot.
 
Syntax:
    ANOP LIMITS <lower>  <upper>
    where <lower> and <upper> are decimal numbers or parameters that
    define the lower and upper bound respectively for calculating
    proportions in the ANOP PLOT command. That is, values between
    these 2 points are counted as "successes" while values outside the
    2 points are counted as "failures".
 
Examples:
    ANOP LIMITS 0.2 0.7
    ANOP LIMITS YLOW YHIGH
 
    LET YLOW = Y(1) - 0.5
    LET YHIGH = Y(1) + 0.5
    ANOP LIMITS YLOW YHIGH
 
Default:
    None
 
Synonyms:
    PROPORTION LIMITS
 
Related Commands:
    ANOP PLOT      = Generate an analysis of proportions plot.
 
Applications:
    Analysis of Proportions
 
Implementation Date:
    XX
 
Program:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET TAG = PATTERN 1 2 3 4 5 FOR I = 1 1 100
    ANOP LIMITS 0.2 0.7
    CHARACTER CIRCLE BLANK
    LINE BLANK SOLID
    ANOP PLOT Y1 TAG
 
-----ANOP PLOT--------------------------------------
 
ANOP PLOT
 
Name:
    ANOP PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates an analysis of proportions plot.
 
Description:
    This plot is a graphical data analysis technique for doing an
    analysis of proportions.  In an analysis of proportions, the values
    that a response variable can have are divided into two mutually
    exclusive groups (commonly called "successes" and "failures").  The
    response variable is generated for various levels of another
    variable (called a factor).  The plot consist of:
      Horizontal axis = distinct values of the factor variable;
      Vertical axis   = for each distinct value of horizontal axis,
                        calculate the proportion of the first response
                        variable falling within some user defined
                        limits.
    In addition, a horizontal line is drawn representing the proportion
    for the entire vertical axis variable.
 
Syntax:
    ANOP PLOT <Y1>  <TAG>   <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a response variable;
          <tag> is the factor variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    ANOP PLOT Y1 TAG
    ANOP PLOT Y1 TAG SUBSET TAG > 3
 
Note:
    The ANOP LIMITS command is used to define the lower and upper
    limits for calculating the proportion.  The proportion is plotted
    as a percentage (i.e., 0 to 100 scale rather than 0 to 1 scale).
    By default, the proportions are drawn as a connected line segment.
    Some users may prefer to draw them as distinct points.  This is
    demonstrated in the PROGRAM section below.
 
Default:
    None
 
Synonyms:
    PROPORTION PLOT
 
Related Commands:
    ANOP LIMITS    = Sets the limits for calculating the proportion.
    LINE           = Sets the line types.
    CHARACTER      = Sets the plot characters.
 
Applications:
    Analysis of Proportions
 
Implementation Date:
    XX
 
Program:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET TAG = PATTERN 1 2 3 4 5 FOR I = 1 1 100
    ANOP LIMITS 0.2 0.7
    CHARACTER CIRCLE BLANK
    LINE BLANK SOLID
    ANOP PLOT Y1 TAG
 
-----ANOVA-------------------------------------------------------
 
ANOVA
 
Name:
    ANOVA
 
Type:
    Analysis Command
 
Purpose:
    Carry out an Analysis of Variance.
 
Description:
    Analysis of Variance is a data analysis technique for examining the
    significance of the factors (= independent variables) in a
    multi-factor model.  The number of factors must be between 1 and 5,
    inclusive.  Each factor then has a certain number of values it can
    have (these are referred to as the levels of a factor).  The number
    of levels can vary betweeen factors.  Each factor and level
    combination is a cell.  Balanced designs are those in which each
    cell has an equal number of observations and unbalanced designs are
    those in which the number of observations can vary among cells.
    The DATAPLOT ANOVA command only handles balanced designs (an error
    message is printed if an unbalanced design is detected).  The
    number of arguments specifies whether a 1-factor ANOVA, 2-factor
    ANOVA, or higher order ANOVA will be carried out.
 
Syntax:
    ANOVA   <y>  <x1 ... xn>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response (= dependent) variable;
          <x1 ... xn> is a sequence of 1 to 5 independent variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    ANOVA Y X1
    ANOVA Y X1 X2
    ANOVA Y X1 X2 X3
    ANOVA Y X1 X2 X3 X4
    ANOVA Y X1 X2 X3 X4 X5
    ANOVA Y X1 X2  SUBSET X2 > 3
 
Note:
    There are two main approaches to ANOVA.  The cell means model for
    2 factors is (it is similar for a different number of factors):
        Yijk = Uij + Eijk
    where i represents the level of factor 1, j represents the level of
    factor 2, and k represents the observation number in the ijth cell.
    This models the response variable as a cell mean plus an error term.
    The column labeled MEAN in the ANOVA output is an estimate of the
    cell mean.
 
    The factor effects model for 2 factors is (again, it is similar
    for additional factors):
        Yijk = UBAR + ALPHAi + BETAj + Eijk
    where i, j, and k have the same meanings as in the cell means model
    and UBAR is the overall mean of the response variable.  This models
    the response variable as an overall mean plus a factor 1 effect
    plus a factor 2 effect plus an error term.  The column labeled
    EFFECT are the estimates of the ALPHAi and BETAj terms.  More
    complicated models will also have interaction terms.  However, the
    DATAPLOT ANOVA command does not calculate interaction terms.
 
    These two models are mathematically equivalent.
 
Note:
    The ANOVA command saves the residuals in the variable RES and the
    predicted values in the variable PRED.  These can be used to
    generate various diagnostic plots.
 
    For the cell means model, the predicted values are the estimated
    cell means.  For the factor effects model, the predicted values
    are the estimated grand mean plus the estimated factor effects.
    Either model can be used since these in fact generate the same
    predicted values.  The residuals are the response variable minus
    the predicted values.
 
Note:
    ANOVA problems can be formulated as regression problems.  This
    is required for unbalanced designs, designed experiments where not
    all factor and level combinations are used, and models where
    interaction terms are required.  The books in the REFERENCE section
    provide detailed examples of setting up ANOVA problems as
    regression problems.  The DATAPLOT FIT command can be used to
    analyze the regression problem.
 
Note:
    The following enhancements were made 1998/5.

    1) The maximum number of factors was raised from 5 to 10.
    2) The output was modified to include an ANOVA table.  Some
       other output was rearranged.
    3) Some information from the ANOVA output is now written
       to the files DPST1F.DAT and DPST2F.DAT.  This simplifies
       using some of the ANOVA quantities in subsequent analyses.

    4) A warning is now printed if an unbalanced design is
       detected.  The ANOVA output will still be generated, but
       it will not be accurate.  

Note:
    The following enhancement was made 2002/7.

    The residual standard deviations computed for various models
    are now written to the file DPST3F.DAT.  These are the same
    values as in the printed output.  The purpose for writing
    them to file is to simplify their use in macros that may
    need to utilize these values.

Default:
    None
 
Synonyms:
    ANALYSIS OF VARIANCE is a synonym for ANOVA
 
Related Commands:
    MEDIAN POLISH         = Carries out a robust ANOVA.
    YATES ANALYSIS        = Analyze a Yate's design.
    BLOCK PLOT            = Generate a block plot.
    DEX SCATTER PLOT      = Generates a dex scatter plot.
    DEX ... PLOT          = Generates a dex plot for a statistic.
    DEX ... EFFECTS PLOT  = Generates a dex effects plot for a
                            statistic.
    T TEST                = Carries out a t test.
    PLOT                  = Plots (e.g., residuals and GANOVA ).
 
Reference:
    "Applied Linear Statistical Models", 3rd ed., Neter, Wasserman,
    and Kunter, 1990, Irwin.
 
    "Applied Regression Analysis", 2nd ed., Draper and Smith, John
    Wiley, 1981.
 
Applications:
    Analysis of Variance
 
Implementation Date:
    Pre-1987
 
Program:
    . READ FILE "SHEESLEY.DAT" IN DATAPLOT REFERENCE CATALOG
    . THIS IS DATAPLOT DATA FILE   SHEESLEY.DAT     (RAW DATA)
    . LIGHT BULB LEAD WIRE WELD PROCESS COMPARISON
    . JOHN SHEESLEY (GE) ARTICLE IN
    . EXPERIMENTS IN INDUSTRY  (ED. BY SNEE, HARE, TROUT)
    . PAGES 54-57
    . NUMBER OF OBSERVATIONS = 96
    . NUMBER OF VARIABLES PER LINE IMAGE = 5
    . ORDER OF VARIABLES ON A LINE IMAGE--
    .    RESPONSE = AVERAGE NUMBER OF WELDED LEAD WIRES MISSED PER HOUR
    .    FACTOR 1 = WELDING PROCESS (2 LEVELS) (PRIMARY)
    .    FACTOR 2 = SHIFT (3 LEVELS)
    .    FACTOR 3 = MACHINE (2 LEVELS)
    .    FACTOR 4 = PLANT (2 LEVELS)
    .    FACTOR 5 = REPLICATION (4 LEVELS) (A RANDOM FACTOR)
    SKIP 25
    READ SHEESLEY.DAT Y WELD SHIFT MACH PLANT REP
    ANOVA Y WELD SHIFT MACH PLANT
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    CHARACTER 1 2; LINES BLANK BLANK
    BLOCK PLOT Y SHIFT MACH PLANT WELD
    CHARACTER CIRCLE
    CHARACTER SIZE 1.0
    LINES BLANK
    PLOT RES
    PLOT RES VS PRED
    NORMAL PROBABILITY PLOT RES
    END OF MULTIPLOT
 
-----ANSARI BRADLEY SCORE (LET)---------------------------------------
 
ANSARI BRADLEY SCORE
 
Name:
    ANSARI BRADLEY SCORE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the Ansari-Bradley scores of a variable.
 
Description:
    The Ansari-Bradley scores are defined as follows

          a(1) = a(n) = 1
          a(2) = a(n-1) = 2
                .....

    Alternatively, they can be computed as

        s(R(j)) = (n+1)/2 - ABS(R(j) - (n+1)/2)

    where R(j) is the rank of the j-th observation and n is the number
    of observations.

    Ansari-Bradley scores are typically used to compare the variances
    of two samples.

Syntax:
    LET <s> = ANSARI BRADLEY SCORE <y>  <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <s> is a variable where the computed Ansari-Bradley scores are
             saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET ANSARI = ANSARI BRADLEY SCORES Y
 
Note:
    Ties are assigned an average rank.  For example, if the 2nd and 3rd
    highest values are equal, each is assigned a rank of 2.5.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SIEGEL TUKEY TEST       = Perform a Siegel-Tukey test.
    SQUARED RANKS TEST      = Perform a squared ranks test.
    ANOVA                   = Perform a fixed effects analysis of variance.
    KLOTZ SCORES            = Generate Klotz scores.
    CONOVER SCORES          = Generate Conover scores.
    MOOD SCORES             = Generate Mood scores.
    VAN DER WAERDEN SCORES  = Generate Van Der Waerden scores.
    MEDIAN SCORES           = Generate median scores.
    SAVAGE SCORES           = Generate Savage scores.
    PLACEMENT SCORES        = Generate placement scores.
    RANK                    = Generate the ranks of a variable. 
 
Reference:
    Higgins (2004), "Introduction to Modern Nonparametric Statisitcs,"
    Duxbury Advanced Series, p. 50.

Applications:
    Nonparametric statistics
 
Implementation Date:
    2023/06
 
Program:
    . Step 1:   Define the data
    .
    let y1 = data 16.55 15.36 15.94 16.43 16.01
    let y2 = data 16.05 15.98 16.10 15.88 15.91
    let n1 = size y1
    let n2 = size y2
    let n = n1 + n2
    .
    . Step 2:   Combine into single array
    .
    let y tag = stack y1 y2
    if n1 <= n2
       let tag = tag - 1
       let n1t = n1
    else
       let tag = 0 subset tag = 2
       let n1t = n2
    end of if
    .
    . Step 3:   Compute the Mood scores
    .
    let ascore = ansari bradley scores y
    .
    . Step 4:   Two-Sample Linear Rank Test
    .
    let temp = tag*ascore
    let s = sum temp
    .
    let aval = sum ascore
    let smean = (n1t/n)*aval
    let meanrank = mean ascore
    let temp = (ascore - meanrank)**2
    let aval = sum temp
    let svar = ((n1*n2)/(n*(n-1)))*aval
    let statval = (s - smean)/sqrt(svar)
    let statval = round(statval,3)
    let cv = norppf(0.975)
    let upplim = round(cv,2)
    let lowlim = -upplim
    feedback off
    print "Two Sample Linear Rank Sum Test Based on Ansari-Bradley Scores"
    print "H0: Variances are Equal"
    print "Ha: Variances are Not Equal"
    print "alpha: 0.05"
    print "Test Statistic: ^statval"
    print "Lower Critical Value: ^lowlim"
    print "Upper Critical Value: ^upplim"
    if statval < cv
       print "Conclusion: Accept H0"
    else
       print "Conclusion: Reject H0"
    end of if
 
-----APPEND-------------------------------------------------------
 
APPEND
 
Name:
    APPEND
 
Type:
    Support Command
 
Purpose:
    Append a variable to the end of another variable.
 
Syntax:
    APPEND   <Variable 1>   <Variable 2>
    where <Variable 1> and <Variable 2> are variables.  <Variable 1> is
    attached to the end of <Variable 2>.
 
Examples:
    APPEND Y2 Y1
    APPEND Y DEL
    APPEND X X
 
Default:
    None.
 
Synonyms:
    EXTEND is a synonym to APPEND, but with the arguments reversed;
    thus if you have 2 variables X1 and X2 and wish to append the
    contents of X2 onto the end of X1, then the following 2 commands
    are equivalent--
       APPEND X2 X1
       EXTEND X1 X2
 
Related Commands:
    EXTEND    = Extends a variable by another variable.
    DELETE    = Deletes (all or part of) a variable.
    LET       = Creates, transforms, etc. a variable.
 
Applications:
    Data Management
 
Implementation Date:
    Pre-1987
 
Program:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET Y2 = LOGISTIC RANDOM NUMBERS FOR I = 1 1 100
    LET Y3 = CAUCHY RANDOM NUMBERS FOR I = 1 1 100
    LET Y4 = DOUBLE EXPONENTIAL RANDOM NUMBERS FOR I = 1 1 100
    APPEND Y2 Y1
    APPEND Y3 Y1
    APPEND Y4 Y1
    LET TAG = 1 100 1 4
    LINE BOX PLOT
    CHARACTER BOX PLOT
    FENCES ON
    BOX PLOT Y1 TAG
 
-----AQUA--------------------------------------------------------------
 
AQUA
 
Name:
    AQUA
 
Type:
    Output Device Command
 
Purpose:
    Generate screen graphics using the Aquaterm library for
    Mac OSX.

Description:
    For Unix/Linux platforms, Dataplot typically uses the
    X Window System to generate screen graphics.  If you have
    X11 installed on your Mac OSX system, this option is
    available (initiate Dataplot from an xterm window and
    enter the command DEVICE 1 X11 to open the graphics
    window).

    The native mode windowing/graphics system under Mac OSX is
    referrred to as Aqua.  In addition to X11, Dataplot supports
    an Aqua driver.  If you initiate Dataplot from a regular
    Mac OSX terminal session, you use the Aqua driver for screen
    graphics rather than the X11 driver.

Syntax:
    DEVICE <1/2/3> AQUA <xsize>  <ysize>
    where <xsize> and <ysize> are the size of the graphics
          window in pixels.
 
    This form designates one of DATAPLOT's 3 devices (typically
    device 1) as an AQUA device.
 
    The <xsize> and <ysize> arguments are optional and default
    to 600 and 450, respectively.

Examples:
    DEVICE 1 AQUA
    DEVICE 1 AQUA 800 600
 
Note:
    Dataplot implements the Aqua driver using the Aquaterm
    library.  For more information about Aquaterm, see

      http://sourceforge.net/projects/aquaterm/

    You need to install Aquaterm on your Mac OSX system before
    installing Dataplot.

Note:
    The Aquaterm graphics window will become visible when you
    generate the first plot after the DEVICE 1 AQUA command,
    not when the DEVICE 1 AQUA command is initiated.

    The Aquaterm graphics window persists even after you complete
    the Dataplot session.  You can delete this window manually.

Note:
    Several SET commands were added to support AQUA specific
    features.

    1) SET AQUA FONT <font name>

       The AQUA font name can be up to 80 characters long.
       The default is "Helvetica".
 
       The list of available fonts is typically quite long
       and not given here.  To see the list of available
       fonts, intitiate Dataplot and enter a DEVICE 1 AQUA
       command.  Click on the graphics window (you may need to
       generate a plot before this becomes visible).  This will
       switch the top menus on the Mac OSX screen to the Aquaterm
       menus.  From this menu bar, select HELP and then select
       "Show Fonts".

       These Aquaterm menus will also allow you to save or print
       the contents of the graphics window.

    2) SET AQUA CAP <BUTT/ROUND/SQUARE>

       The cap style determines how the end of lines are drawn
       (referred to as end-caps).  We suggest that you experiment
       with these options to see which you prefer.

    3) SET AQUA HARDWARE FILL <ON/OFF>

       This command specifies whether solid regions are filled
       in hardware (i.e., Aquaterm library) or software (i.e.,
       Dataplot draws the lines to fill the area).

       The default is ON (i.e., Aquaterm does the fill).  This
       is typically the most efficient method.  However, if
       the hardware fill has a problem, you can try setting
       this switch to OFF.

Note:
    The CROSS HAIR command (used to read the current coordinates
    when you click the mouse) is not currently supported with
    this driver.

    Also, the SAVE PLOT/REPEAT PLOT/CYCLE PLOT commands are not
    currently supported for Aqua.

Default:
    Off

Synonyms:
    None

Related Commands:
    X11                    = Direct graphical output to an X11
                             window.
    POSTSCRIPT             = Direct graphical output to a Postscript
                             device.
    DEVICE                 = Specify certain actions for the graphics
                             output.
    SET AQUA FONT          = Specify the Aqua font to use.
    SET AQUA CAP           = Specify the Aqua cap style to use.
    SET AQUA HARDWARE FILL = Specify how solid fills are performed.
 
Applications:
    Graphics
 
Implementation Date:
    2007/10
 
Program:
    DEVICE 1 AQUA
    PLOT SIN(X) FOR X = 0  0.01  6

-----ARC-------------------------------------------------------
 
ARC
 
Name:
    ARC
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Draws an arc.
 
Description:
    The 3 pairs of coordinates define the (x,y) values for the start
    point, an internal point, and the end point (respectively) of the
    arc.
 
Syntax:
    ARC   <x1>   <y1>   <x2>   <y2>   <x3>   <y3>
    where <x1> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for the start point of
               the arc;
          <y1> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for the start point of
               the arc;
          <x2> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for the internal point of
               the arc;
          <y2> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for the internal point of
               the arc;
          <x3> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for the stop point of
               the arc;
          <y3> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for the stop point of
               the arc.
 
Examples:
    ARC 30 50 50 40 70 50
    ARC 30 30 50 40 70 70
    ARC 20 70 30 50 40 70
    ARC X1 Y1 X2 Y2 X3 Y3
    ARC 50 50 X2 Y2 70 50
    ARC 40 50 50 30 60 50
 
Note:
    The line style (i.e., solid, dash), color, and thickness are
    controlled by the LINE, LINE COLOR, and LINE THICKNESS commands.
 
Note:
    The keywords DATA and RELATIVE were added to the TRIANGLE
    command 7/1997.  These keywords are independent and can
    be used separately or together.  For example, 
    TRIANGLE DATA, TRIANGLE RELATIVE, or TRIANGLE DATA RELATIVE.
    The word DATA should come before the word RELATIVE if both
    appear.

    DATA means that the coordinates are specified in terms of
    the data units of the most recent plot rather than Dataplot
    0 to 100 screen units.

    RELATIVE means that the coordinates of the first point
    are drawn in absolute coordinates an all subsequent points
    in the figure are relative to that first point.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    POINT            = Draws a point.
    ARROW            = Draws an arrow.
    TRIANGLE         = Draws a triangle.
    BOX              = Draws a box.
    HEXAGON          = Draws a hexagon.
    CIRCLE           = Draws a circle.
    SEMI-CIRCLE      = Draws a semi-circle.
    ELLIPSE          = Draws an ellipse.
    OVAL             = Draws an oval.
    DIAMOND          = Draws a diamond.
    DRAW             = Draws a line.
    MOVE             = Moves to a point.
    LINES            = Sets the line types for figures and plot lines.
    LINE THICKNESSES = Sets the line thicknesses for figures and plot
                       lines.
    LINE COLOR       = Sets the line colors for figures and plot lines.
    CROSS-HAIR       = Activates and reads the cross-hair.
    TEXT             = Writes a text string.
 
Applications:
    Drawing
 
Implementation Date:
    Pre-1987
 
Program:
    LINE DASH
    LINE COLOR BLACK
    LINE THICKNESS 0.2
    ARC 30 50 50 40 70 50
 
-----ARCCOS (LET)--------------------------------
 
ARCCOS
 
Name:
    ARCCOS (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the arccosine for a variable or parameter.
 
Description:
    The arccosine is the angle whose cosine is equal to the given
    value.  The angle is limited to values between 0 and PI.  By
    default, the angle is returned in radian units.  To get degree
    values, enter the command ANGLE UNITS DEGREES (ANGLE UNITS RADIANS
    resets it).  Values outside the range -1 to 1 generate an error
    message.
 
Syntax:
    LET <y2> = ARCCOS(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed arccosine value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ARCCOS(-2)
    LET A = ARCCOS(A1)
    LET X2 = ARCCOS(X1)
    LET X2 = ARCCOS(X1-4)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ARCCOSH      = Compute hyperbolic arccosine.
    ARCCOT       = Compute arccotangent.
    ARCCOTH      = Compute hyperbolic arccotangent.
    ARCCSC       = Compute arccosecant.
    ARCCSCH      = Compute hyperbolic arccosecant.
    ARCSEC       = Compute secant.
    ARCSECH      = Compute hyperbolic arcsecant.
    ARCSIN       = Compute arcsine.
    ARCSINH      = Compute hyperbolic arcsine.
    ARCTAN       = Compute arctangent.
    ARCTANH      = Compute hyperbolic arctangent.
 
Reference:
    Consult any standard trigonometry or pre-calculus textbook.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    X1LABEL COSINE VALUE
    Y1LABEL ANGLE (RADIAN UNITS)
    TITLE AUTOMATIC
    PLOT ARCCOS(X) FOR X = -1 .01 1
 
-----ARCCOSH (LET)--------------------------------
 
ARCCOSH
 
Name:
    ARCCOSH (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the hyperbolic arccosine for a variable or parameter.
 
Description:
    The hyperbolic cosine is the value whose hyperbolic cosine is equal
    to the given value.  The formula for the hyperbolic cosine is:
          arccosh(x) = log(x + sqrt(x**2 - 1)     for x >= 1
    An error message is generated if the input value is less than 1.
 
Syntax:
    LET <y2> = ARCCOSH(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed hyperbolic arccosine value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ARCCOSH(-2)
    LET A = ARCCOSH(A1)
    LET X2 = ARCCOSH(X1)
    LET X2 = ARCCOSH(X1-4)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ARCCOS       = Compute arccosine.
    ARCCOT       = Compute arccotangent.
    ARCCOTH      = Compute hyperbolic arccotangent.
    ARCCSC       = Compute arccosecant.
    ARCCSCH      = Compute hyperbolic arccosecant.
    ARCSEC       = Compute secant.
    ARCSECH      = Compute hyperbolic arcsecant.
    ARCSIN       = Compute arcsine.
    ARCSINH      = Compute hyperbolic arcsine.
    ARCTAN       = Compute arctangent.
    ARCTANH      = Compute hyperbolic arctangent.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    X1LABEL HYPERBOLIC COSINE VALUE
    Y1LABEL INVERSE VALUE
    TITLE AUTOMATIC
    PLOT ARCCOSH(X) FOR X = 1 .1 9.9
 
-----ARCCOT (LET)--------------------------------
 
ARCCOT
 
Name:
    ARCCOT (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the arccotangent for a variable or parameter.
 
Description:
    The arccotangent is the angle whose cotangent is equal to the
    given value.  The returned angle is restricted to values between
    -PI/2 and PI/2.  The function is defined for all real numbers.  By
    default, the angle is returned in radian units.  To get degree
    values, enter the command ANGLE UNITS DEGREES (ANGLE UNITS RADIANS
    resets it).
 
Syntax:
    LET <y2> = ARCCOT(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed arccotangent value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ARCCOT(-2)
    LET A = ARCCOT(A1)
    LET X2 = ARCCOT(X1)
    LET X2 = ARCCOT(X1-4)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ARCCOS       = Compute arccosine.
    ARCCOSH      = Compute hyperbolic arccosine.
    ARCCOTH      = Compute hyperbolic arccotangent.
    ARCCSC       = Compute arccosecant.
    ARCCSCH      = Compute hyperbolic arccosecant.
    ARCSEC       = Compute secant.
    ARCSECH      = Compute hyperbolic arcsecant.
    ARCSIN       = Compute arcsine.
    ARCSINH      = Compute hyperbolic arcsine.
    ARCTAN       = Compute arctangent.
    ARCTANH      = Compute hyperbolic arctangent.
 
Reference:
    Consult any standard trigonometry or pre-calculus textbook.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    X1LABEL COTANGENT VALUE
    Y1LABEL ANGLE (RADIAN UNITS)
    READ X Y TAG
    -10   0    1
     10   0    1
      0   2    2
      0  -2    2
    END OF DATA
    LINES SOLID SOLID SOLID SOLID DOT DOT DOT
    PLOT ARCCOT(X) FOR X = 0 .01 2 AND
    PLOT ARCCOT(X) FOR X = 2 .1 10 AND
    PLOT ARCCOT(X) FOR X = -.01 -.01 -2 AND
    PLOT ARCCOT(X) FOR X = -2 -.1 -10 AND
    PLOT Y X TAG
 
-----ARCCOTH (LET)--------------------------------
 
ARCCOTH
 
Name:
    ARCCOTH (LET)
 
Type:
    Library Function
 
Purpose:
    The hyperbolic arccotangent is the value whose hyperbolic
    cotangent is equal to the given value.  The formula for the
    hyperbolic cotangent is:
        arccoth(x) = 2/(log((1+x)/(1-x)))   for x > 1 or x < -1
    Input values between -1 and 1 generate an error message.
 
Syntax:
    LET <y2> = ARCCOTH(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed hyperbolic arccotangent value is
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ARCCOTH(-2)
    LET A = ARCCOTH(A1)
    LET X2 = ARCCOTH(X1)
    LET X2 = ARCCOTH(X1-4)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ARCCOS       = Compute arccosine.
    ARCCOSH      = Compute hyperbolic arccosine.
    ARCCOT       = Compute arccotangent.
    ARCCSC       = Compute arccosecant.
    ARCCSCH      = Compute hyperbolic arccosecant.
    ARCSEC       = Compute secant.
    ARCSECH      = Compute hyperbolic arcsecant.
    ARCSIN       = Compute arcsine.
    ARCSINH      = Compute hyperbolic arcsine.
    ARCTAN       = Compute arctangent.
    ARCTANH      = Compute hyperbolic arctangent.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    X1LABEL HYPERBOLIC COTANGENT VALUE
    Y1LABEL INVERSE VALUE
    READ X Y TAG
    -10   0   1
     10   0   1
      1   3   2
      1  -3   2
     -1   3   3
     -1  -3   3
    END OF DATA
    LINES SOLID SOLID SOLID SOLID DOT DOT DOT
    PLOT ARCCOTH(X) FOR X = 1.01 .01 2 AND
    PLOT ARCCOTH(X) FOR X = 2 .1 10 AND
    PLOT ARCCOTH(X) FOR X = -1.01 -.01 -2 AND
    PLOT ARCCOTH(X) FOR X = -2 -.1 -10 AND
    PLOT Y X TAG
 
-----ARCCSC (LET)--------------------------------
 
ARCCSC
 
Name:
    ARCCSC (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the arccosecant for a variable or parameter.
 
Description:
    The arccosecant is the angle whose cosecant is equal to the given
    value.  The angle is restricted to values between 0 and PI.  By
    default, the angle is returned in radian units.  To get degree
    values, enter the command ANGLE UNITS DEGREES (ANGLE UNITS RADIANS
    resets it).  Values between -1 and 1 return an error message.
 
Syntax:
    LET <y2> = ARCCSC(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed arccosecant value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ARCCSC(-2)
    LET A = ARCCSC(A1)
    LET X2 = ARCCSC(X1)
    LET X2 = ARCCSC(X1-4)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ARCCOS       = Compute arccosine.
    ARCCOSH      = Compute hyperbolic arccosine.
    ARCCOT       = Compute arccotangent.
    ARCCOTH      = Compute hyperbolic arccotangent.
    ARCCSCH      = Compute hyperbolic arccosecant.
    ARCSEC       = Compute secant.
    ARCSECH      = Compute hyperbolic arcsecant.
    ARCSIN       = Compute arcsine.
    ARCSINH      = Compute hyperbolic arcsine.
    ARCTAN       = Compute arctangent.
    ARCTANH      = Compute hyperbolic arctangent.
 
Reference:
    Consult any standard trigonometry or pre-calculus textbook.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    X1LABEL COSECANT VALUE
    Y1LABEL ANGLE (RADIAN UNITS)
    READ X Y TAG
    -10   0    1
     10   0    1
      1   2    2
      1  -2    2
     -1   2    3
     -1  -2    3
    END OF DATA
    LINES SOLID SOLID SOLID SOLID DOT DOT DOT
    PLOT ACRCSC(X) FOR X = 1 .01 2 AND
    PLOT ACRCSC(X) FOR X = 2 .1 10 AND
    PLOT ACRCSC(X) FOR X = -1 -.01 -2 AND
    PLOT ACRCSC(X) FOR X = -2 -.1 -10
    PLOT Y X TAG
 
-----ARCCSCH (LET)--------------------------------
 
ARCSCH
 
Name:
    ARCCSCH (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the hyperbolic arccosecant for a variable or parameter.
 
Description:
    The hyperbolic arccosecant is the value whose hyperbolic cosecant
    is equal to the given value.  The formula for the hyperbolic
    arccosecant is:
        arccsch(x) = 1/(log(x + sqrt(x**2 + 1)))   for x <> 0
    Values identically equal to 0 return an error message.
 
Syntax:
    LET <y2> = ARCCSCH(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed hyperbolic arccosecant value is
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ARCCSCH(-2)
    LET A = ARCCSCH(A1)
    LET X2 = ARCCSCH(X1)
    LET X2 = ARCCSCH(X1-4)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ARCCOS       = Compute arccosine.
    ARCCOSH      = Compute hyperbolic arccosine.
    ARCCOT       = Compute arccotangent.
    ARCCOTH      = Compute hyperbolic arccotangent.
    ARCCSC       = Compute arccosecant.
    ARCSEC       = Compute secant.
    ARCSECH      = Compute hyperbolic arcsecant.
    ARCSIN       = Compute arcsine.
    ARCSINH      = Compute hyperbolic arcsine.
    ARCTAN       = Compute arctangent.
    ARCTANH      = Compute hyperbolic arctangent.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    X1LABEL HYPERBOLIC COSECANT VALUE
    Y1LABEL INVERSE VALUE
    READ X Y TAG
    -10   0  1
     10   0  1
      0  10  5
      0 -10  5
    END OF DATA
    LINES SOLID SOILD SOLID SOLID DOT DOT DOT
    PLOT ARCCSCH(X) FOR X = 0.01 .01 2.0 AND
    PLOT ARCCSCH(X) FOR X = 2 .1 10 AND
    PLOT ARCCSCH(X) FOR X = -.01 -.01 -2 AND
    PLOT ARCCSCH(X) FOR X = -2 -.1 -10 AND
    PLOT Y X TAG
 
-----ARCSEC (LET)--------------------------------
 
ARCSEC
 
Name:
    ARCSEC (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the arcsecant for a variable or parameter.
 
Description:
    The arcsecant of a variable is the angle whose secant is equal to
    the given value.  The returned value will be in the range 0 to PI.
    By default, the angle is returned in radian units.  To get degree
    values, enter the command ANGLE UNITS DEGREES (ANGLE UNITS RADIANS
    resets it).  Values between -1 and 1 return an error message.
 
Syntax:
    LET <y2> = ARCSEC(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed arcsecant value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ARCSEC(-2)
    LET A = ARCSEC(A1)
    LET X2 = ARCSEC(X1)
    LET X2 = ARCSEC(X1-4)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ARCCOS       = Compute arccosine.
    ARCCOSH      = Compute hyperbolic arccosine.
    ARCCOT       = Compute arccotangent.
    ARCCOTH      = Compute hyperbolic arccotangent.
    ARCCSC       = Compute arccosecant.
    ARCCSCH      = Compute hyperbolic arccosecant.
    ARCSECH      = Compute hyperbolic arcsecant.
    ARCSIN       = Compute arcsine.
    ARCSINH      = Compute hyperbolic arcsine.
    ARCTAN       = Compute arctangent.
    ARCTANH      = Compute hyperbolic arctangent.
 
Reference:
    Consult any standard trigonometry or pre-calculus textbook.
 
Applications:
    XX
 
Implementation Date:
    Pre-1987
 
Program:
    X1LABEL SECANT VALUE
    Y1LABEL ANGLE (RADIAN UNITS)
    READ X Y TAG
    -10   1.57  1
     10   1.57  1
      1   0  2
      1   4  2
      -1   0  3
      -1   4  3
    END OF DATA
    LINES SOLID SOILD SOLID SOLID DOT DOT DOT
    PLOT ARCSEC(X) FOR X = 1 .01 2 AND
    PLOT ARCSEC(X) FOR X = 2 .1 10 AND
    PLOT ARCSEC(X) FOR X = -1 -.01 -2 AND
    PLOT ARCSEC(X) FOR X = -2 -.1 -10 AND
    PLOT Y X TAG
 
-----ARCSECH (LET)--------------------------------
 
ARCSECH
 
Name:
    ARCSECH (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the hyperbolic arcsecant for a variable or parameter.
 
Description:
    The hyperbolic arcsecant is the value whose hyperbolic secant is
    equal to the given value.  The formula for the hyperbolic
    arcsecant is:
        arcsech(x) = 1/(log(x + sqrt(x**2 - 1)))    for 0 < x <= 1
    Values less than or equal to 0 or greater than 1 return an error
    message.
 
Syntax:
    LET <y2> = ARCSECH(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter,
          <y2> is a variable or a parameter (depending on what
               <y1> is) where the computed hyperbolic arcsecant
               value is stored,
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ARCSECH(-2)
    LET A = ARCSECH(A1)
    LET X2 = ARCSECH(X1)
    LET X2 = ARCSECH(X1-4)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ARCCOS       = Compute arccosine.
    ARCCOSH      = Compute hyperbolic arccosine.
    ARCCOT       = Compute arccotangent.
    ARCCOTH      = Compute hyperbolic arccotangent.
    ARCCSC       = Compute arccosecant.
    ARCCSCH      = Compute hyperbolic arccosecant.
    ARCSEC       = Compute secant.
    ARCSIN       = Compute arcsine.
    ARCSINH      = Compute hyperbolic arcsine.
    ARCTAN       = Compute arctangent.
    ARCTANH      = Compute hyperbolic arctangent.
 
Applications:
    XX
 
Implementation Date:
    Pre-1987
 
Program:
    X1LABEL HYPERBOLIC SECANT VALUE
    Y1LABEL INVERSE VALUE
    PLOT ARCSECH(X) FOR X = .01 .01 1
 
-----ARCSIN (LET)--------------------------------
 
ARCSIN
 
Name:
    ARCSIN (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the arcsine for a variable or parameter.
 
Description:
    The arcsine is the angle whose sine is equal to the given value.
    The returned value is in the range -PI/2 to PI/2.  By default, the
    angle is returned in radian units.  To get degree values, enter the
    command ANGLE UNITS DEGREES (ANGLE UNITS RADIANS resets it).
    Values outside the range -1 to 1 return an error message.
 
Syntax:
    LET <y2> = ARCSIN(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed arcsine value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ARCSIN(-2)
    LET A = ARCSIN(A1)
    LET X2 = ARCSIN(X1)
    LET X2 = ARCSIN(X1-4)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ARCCOS       = Compute arccosine.
    ARCCOSH      = Compute hyperbolic arccosine.
    ARCCOT       = Compute arccotangent.
    ARCCOTH      = Compute hyperbolic arccotangent.
    ARCCSC       = Compute arccosecant.
    ARCCSCH      = Compute hyperbolic arccosecant.
    ARCSEC       = Compute secant.
    ARCSECH      = Compute hyperbolic arcsecant.
    ARCSINH      = Compute hyperbolic arcsine.
    ARCTAN       = Compute arctangent.
    ARCTANH      = Compute hyperbolic arctangent.
 
Reference:
    Consult any standard trigonometry or pre-calculus textbook.
 
Applications:
    XX
 
Implementation Date:
    Pre-1987
 
Program:
    X1LABEL SINE VALUE
    Y1LABEL ANGLE (RADIAN UNITS)
    PLOT ARCSIN(X) FOR X = -1 .01 1
 
-----ARCSINH (LET)--------------------------------
 
ARCSINH
 
Name:
    ARCSINH (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the hyperbolic arcsine for a variable or parameter.
 
Description:
    The hyperbolic arcsine is the value whose hyperbolic sine is equal
    to the given value.  The formula for the hyperbolic sine is:
        arcsinh(x) = log(x + sqrt(x**2 + 1))    for all real x
 
Syntax:
    LET <y2> = ARCSINH(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed hyperbolic arcsine value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ARCSINH(-2)
    LET A = ARCSINH(A1)
    LET X2 = ARCSINH(X1)
    LET X2 = ARCSINH(X1-4)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ARCCOS       = Compute arccosine.
    ARCCOSH      = Compute hyperbolic arccosine.
    ARCCOT       = Compute arccotangent.
    ARCCOTH      = Compute hyperbolic arccotangent.
    ARCCSC       = Compute arccosecant.
    ARCCSCH      = Compute hyperbolic arccosecant.
    ARCSEC       = Compute secant.
    ARCSECH      = Compute hyperbolic arcsecant.
    ARCSIN       = Compute arcsine.
    ARCTAN       = Compute arctangent.
    ARCTANH      = Compute hyperbolic arctangent.
 
Applications:
    XX
 
Implementation Date:
    Pre-1987
 
Program:
    X1LABEL HYPERBOLIC SINE VALUE
    Y1LABEL INVERSE VALUE
    PLOT ARCSINH(X) FOR X = -10 .1 10
 
-----ARCTAN (LET)--------------------------------
 
ARCTAN
 
Name:
    ARCTAN (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the arctangent for a variable or parameter.
 
Description:
    The arctangent is the angle whose tangent is equal to the given
    value.  The returned value is in the range =PI/2 to PI/2.  By
    default, the angle is returned in radian units.  To get degree
    values, enter the command ANGLE UNITS DEGREES (ANGLE UNITS RADIANS
    resets it).
 
Syntax:
    LET <y2> = ARCTAN(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
          where the computed arctangent value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ARCTAN(-2)
    LET A = ARCTAN(A1)
    LET X2 = ARCTAN(X1)
    LET X2 = ARCTAN(X1-4)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ARCCOS       = Compute arccosine.
    ARCCOSH      = Compute hyperbolic arccosine.
    ARCCOT       = Compute arccotangent.
    ARCCOTH      = Compute hyperbolic arccotangent.
    ARCCSC       = Compute arccosecant.
    ARCCSCH      = Compute hyperbolic arccosecant.
    ARCSEC       = Compute secant.
    ARCSECH      = Compute hyperbolic arcsecant.
    ARCSIN       = Compute arcsine.
    ARCSINH      = Compute hyperbolic arcsine.
    ARCTANH      = Compute hyperbolic arctangent.
 
Reference:
    Consult any standard trigonometry or pre-calculus textbook.
 
Applications:
    XX
 
Implementation Date:
    Pre-1987
 
Program:
    X1LABEL TANGENT VALUE
    Y1LABEL ANGLE (RADIAN UNITS)
    PLOT ARCTAN(X) FOR X = -10 .1  10
 
-----ARCTANH (LET)--------------------------------
 
ARCTANH
 
Name:
    ARCTANH (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the hyperbolic arctangent for a variable or parameter.
 
Description:
    The hyperbolic arctangent is the value whose hyperbolic tangent is
    equal to the given value.  The formula for for the hyperbolic
    arctangent is:
        arctanh(x) = (1/2)*log((1+x)/(1-x))     for -1 < x < 1
    Values greater than or equal to 1 or less than or equal to -1
    return an error message.
 
Syntax:
    LET <y2> = ARCTANH(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed hyperbolic arctangent value is
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ARCTANH(-2)
    LET A = ARCTANH(A1)
    LET X2 = ARCTANH(X1)
    LET X2 = ARCTANH(X1-4)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ARCCOS       = Compute arccosine.
    ARCCOSH      = Compute hyperbolic arccosine.
    ARCCOT       = Compute arccotangent.
    ARCCOTH      = Compute hyperbolic arccotangent.
    ARCCSC       = Compute arccosecant.
    ARCCSCH      = Compute hyperbolic arccosecant.
    ARCSEC       = Compute secant.
    ARCSECH      = Compute hyperbolic arcsecant.
    ARCSIN       = Compute arcsine.
    ARCSINH      = Compute hyperbolic arcsine.
    ARCTAN       = Compute arctangent.
 
Applications:
    XX
 
Implementation Date:
    Pre-1987
 
Program:
    X1LABEL HYPERBOLIC TANGENT VALUE
    Y1LABEL INVERSE VALUES
    PLOT ARCTANH(X) FOR X = -.99 .01 .99
 
-----ARMA-----------------------------------------------
 
ARMA
 
Name:
    ARMA
 
Type:
    Analysis Command
 
Purpose:
    The ARMA command is used to fit an autoregressive/moving
    average (ARMA) model to a univariate time series.

Description:
    ARMA models are a method for modeling univariate time
    series.

    Autoregressive models are defined by:

      X(t) = XMEAN + phi1*X(t-1) + phi2*X(t-2) + ... + phip*X(t-p)
             + A(t)
 
    where X(t) is the series and XMEAN is the mean of the
    series, A(t) represent normally distributed random errors,
    and the phi1, ... ,phip are the parameters of the model.
    Autoregressive models are simply a linear regression of the
    current value of the series against one or more prior values
    of the series.  The value of p is called the order of the
    model.

    Moving average models are defined by:

      X(t) = XMEAN + A(t) - theta1*A(t-1) - theta2*A(t-2) - ...
             - thetaq*A(t-q)

    where X(t) is the series and XMEAN is the mean of the
    series, A(t-i) represent random shocks of one or more prior
    points of the series, and the theta1, ... ,thetaq are the
    parameters of the model.  The random shocks are assumed to
    come from a common (typically normal) distribution with
    common location and scale.  The primary idea behind the
    moving average model is that the random shocks are 
    propogated to future values of the series.   Fitting 
    moving average models require iterative, non-linear
    fitting techniques.

    The power of ARMA models is that they can incorporate both
    autoregressive terms and moving average terms.  The use
    of ARMA models was popularized by Box and Jenkins.
    Although both AR and MA models were previously known and
    used, Box and Jenkins provided a systematic approach
    for modeling both AR and MA terms in the model.  ARMA
    models are also commonly known as Box-Jenkins models or
    ARIMA models.

    ARMA models assume that the data are stationary, i.e. the
    data have constant location and scale.  Trend can often
    be removed from a nonstationary series to achieve 
    stationarity.  Differencing is a common approach for
    removing trend.  The first difference is defined as
    X(t) - X(t-1).  In most cases, a single differencing
    is sufficient.  However, more than one differencing can
    be applied if necessary.  You can also fit a linear or
    non-linear model to remove trend.
    
    ARMA models can also incorporate seasonal terms (and
    seasonal differencing).  See Box and Jenkins for the
    complete mathematical description of this model.
    
    ARMA models typically require fairly long series (at
    least 50 points is recommended by some authors).  Also,
    if the series is dominated by trend and seasonal components,
    a trend/seasonality/residual decomposition method may
    be preferred.  Dataplot supports a SEASONAL LOWESS command
    for this type of decomposition.

    The typical components for fitting ARMA models is:

      1) Model Identification
      2) Model Fitting
      3) Model Validation

    The ARMA command addresses (2), model fitting.  Model
    identification for ARMA models can be difficult and
    require a fair amount of experience.  See the various time
    series texts that describe ARMA modeling for more guidance
    on ARMA model identification.  Model validation is similar
    to the nonlinear fitting case (i.e., various residual
    plots).  Again, see texts that describe nonlinear model
    fitting.
 
Syntax:
    ARMA   <y> <diff> <ma> <sar> <sdiff> <sma> <speriod>
                           <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <ar> is the order of the auto-regressive terms;
          <diff> is the number of differences to apply (typically
               0, 1, or 2);
          <ma> is the order ot the moving average terms;
          <sar> is the order of seasonal auto-regressive terms;
          <sdiff> is the number of seasonal differences to apply
               (typically 0, 1, or 2);
          <sma> is the order of seasonal moving average terms;
          <speriod> is the period for seasonal terms (defaults
               to 12);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If there is no seasonal component, the <sar>, <sdiff>, <sma>,
    and <speriod> terms can be omitted.

Examples:
    ARMA Y 2 0 1
    ARMA Y 2 0 1 1 0 1 12
 
Note:
    To minimize the amount of screen output, but to also to
    keep the maximum amount of information, Dataplot writes
    most of the output to files.  Speficially,

    dpst1f.dat - the parameters and the standard deviations of the
                 parameters from the ARMA fit.  The order is:
                 1) Autoregressive terms
                 2) Seasonal autoregressive terms
                 3) Mean term
                 4) Moving average terms
                 5) Seasonal moving average terms
    dpst2f.dat - this file contains:
                 1) Row number
                 2) Original series (i.e., Y)
                 3) Predicted values
                 4) Standard deviation of predicted values
                 5) Residuals
                 6) Standardized residuals
    dpst3f.dat - Intermediate outut from iterations before
                 convergence.  This is generally useful if
                 the ARMA fit does not converge.
    dpst4f.dat - The parameter variance-covariance matrix.
    dpst5f.dat - The forecast values for (N/10)+1 observations
                 ahead.  Specifically,
                 1) The forecasted values
                 2) The standard deviation of the forecasted values.
                 3) The lower 95% confidence band for the forecast.
                 4) The upper 95% confidence band for the forecast.

Note:
    Dataplot allows you to define the starting values by
    defining the variable ARPAR.  The order of the parameters
    is as given for the file dpst1f.dat above.  By default,
    all parameters are set to 0.5 except for the mean term which
    is set to 0.

    In addition, you can define the variable ARFIXED to fix
    certain parameters to their start values.  That is, you
    define ARPAR to specify the start values.  If the
    corresponding element of ARFIXED is zero, the parameter is
    estimated as usual.  If ARFIXED is one, then the parameter
    is fixed at the start value.  The most common use of this
    is to set certain parameters to zero.  For example, if
    you fit an AR(2) model and you want the AR(1) term to be
    zero, you could enter the following:

        LET ARPAR = DATA 0 1
        LET ARFIXED = DATA 1 0
    
Note:
    Dataplot uses the STARPAC library (developed by Janet Rogers
    and Peter Tyrone of NIST) to compute the ARIMA estimates.

Note:
    Dataplot prints the value of the Akaike Information Critierion
    (AIC).  It also saves this value in the internal parameter AIC.

    The AIC is used in comparing different ARIMA models.  The lower the
    AIC, the better the model.  Note that is in any fitting application,
    you still need to perform appropriate model validation before
    accepting the model suggested by the minimum AIC value.

    Dataplot computes the AIC as:

        AIC(R) = N*LOG(RESVAR) + 2*R

    where R is the number of parameters in the model, N is the number
    of observations, and RESVAR is the residual variance of the fitted
    model.

    At this time (2/2003), Dataplot does not support a command for
    computing the AIC for a range of moving average/autoregressive
    models.  That is, you have to fit the full model to obtain the
    AIC value.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    AUTOCORRELATION PLOT          = Generate an autocorrelation plot.
    PARTIAL AUTOCORRELATION PLOT  = Generate a partial
                                    autocorrelation plot.
    SPECTRAL PLOT                 = Generate a spectral plot.
    SEASONAL LOWESS               = Perform a seasonal lowess.
    FIT                           = Carries out a least squares fit.
 
Reference:
    "Time Series Analysis: Forecasting and Control",
    Box and Jenkins, Holden-Day, 1976.

    "The Analysis of Time Series: An Introduction", Fourth
    Edition, Chatfield, Chapman & Hall, 1989.
 
Applications:
    Time Series Analysis
 
Implementation Date:
    2000/1
    2003/2: Added supoort for AIC (Akaike Information Critierion)
 
Program:
    skip 0
    set read format 3e16.4
    read negiz4.dat junk1 junk2 y
    set read format
    delete junk1 junk2
    let arpar = data 0.1 0.1 0.1
    arma y 3 0 0
 
-----ARROW-------------------------------------------------------
 
ARROW
 
Name:
    ARROW
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Draws an arrow.
 
Description:
    The 2 pairs of coordinates define the (x,y) values for the tail and
    the head (respectively) of the arrow.
 
Syntax:
    ARROW   <x1>   <y1>   <x2>   <y2>
    where <x1> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for the tail of the
               arrow;
          <y1> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for the tail of the
               arrow;
          <x2> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for the head of the
               arrow;
    and   <y2> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for the head of the
               arrow.
 
Examples:
    ARROW 50 50 60 50
    ARROW 50 50 60 60
    ARROW 20 20 30 30
    ARROW 20 70 50 50
    ARROW X1 Y1 X2 Y2
 
Note:
    Arrows defined by the ARROW COORDINATES command are drawn whenever
    a plot is generated.  Arrows defined by the ARROW command are
    generated immediately.
 
Note:
    The length and width of the arrow head are set by the HEIGHT,
    WIDTH, or HW commands.  The size of the base of the arrow head is
    controlled by the height parameter while the distance from the base
    to the tip of the arrow is controlled by the width parameter.  For
    further information, enter HELP HEIGHT, HELP WIDTH, or HELP HW.
 
Note:
    By default, the arrow head is not filled.  Enter the command
    REGION FILL ON to generate a solid filled arrow head.
 
Note:
    The ARROW PATTERN command sets the line style (i.e., solid or some
    dash pattern).  The ARROW COLOR command set the color for the
    arrow.  The ARROW THICKNESS command sets the line thickness for the
    arrow.
 
Note:
    The keywords DATA and RELATIVE were added to the TRIANGLE
    command 7/1997.  These keywords are independent and can
    be used separately or together.  For example, 
    TRIANGLE DATA, TRIANGLE RELATIVE, or TRIANGLE DATA RELATIVE.
    The word DATA should come before the word RELATIVE if both
    appear.

    DATA means that the coordinates are specified in terms of
    the data units of the most recent plot rather than Dataplot
    0 to 100 screen units.

    RELATIVE means that the coordinates of the first point
    are drawn in absolute coordinates an all subsequent points
    in the figure are relative to that first point.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ARROW COORDINATE = Generates arrows on subsequent plots.
    ARROW PATTERN    = Sets the line type for arrows.
    ARROW COLOR      = Sets the color for arrows.
    ARROW THICKNESS  = Sets the thickness for arrows.
    REGION FILL      = Sets the region fill switch for diagrammatic
                       graphics.
    HEIGHT           = Sets height (= length of base) for arrow head.
    WIDTH            = Sets width (= distance from base to the tip) for
                       the arrow head.
    HW               = Sets the height and width for the arrow head.
    POINT            = Draws a point.
    TRIANGLE         = Draws a triangle.
    BOX              = Draws a box.
    HEXAGON          = Draws a hexagon.
    CIRCLE           = Draws a circle.
    SEMI-CIRCLE      = Draws a semi-circle.
    ARC              = Draws an arc.
    ELLIPSE          = Draws an ellipse.
    OVAL             = Draws an oval.
    DIAMOND          = Draws a diamond.
    DRAW             = Draws a line.
    MOVE             = Moves to a point.
    CROSS-HAIR       = Activates and reads the cross-hair.
    TEXT             = Writes a text string.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    Pre-1987
 
Program:
    HW 1.0 0.7
    REGION FILL ON
    ARROW PATTERN SOLID
    ARROW THICKNESS 0.2
    ARROW COLOR BLACK
    LET Y2 = DATA 60 55 50 45 40 45 50 55
    LET X2 = DATA 50 55 60 55 50 45 40 45
    LET X1 = 50
    LET Y1 = 50
    LET N = SIZE Y2
    LOOP FOR K = 1 1 N
    LET XTEMP = X2(K)
    LET YTEMP = Y2(K)
    ARROW X1 Y1 XTEMP YTEMP
    END OF LOOP
 
-----ARROW COLOR-------------------------------------------------------
 
ARROW COLOR
 
Name:
    ARROW ... COLOR
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the colors for arrows to appear on subsequent plots (as
    specified via the ARROW ... COORDINATES command) or arrows
    generated by the ARROW command.  Up to 100 arrows can be specified
    with the ARROW COORDINATES command.

Description:
    Dataplot provides two methods for specifying colors.

        1. Colors can be defined by name (or by the corresponding index).
           Dataplot adopted it's named colors from the X11 project.
           Currently, 162 named colors and 100 levels of grayscale are
           supported.  Grayscale can be specified with either G0, G1, ...,
           G100 (or -1, -2, ..., -100).  Many older devices support only a
           limited number of colors.  For these devices, unsupported colors
           will be mapped to one of the available colors.  To specify a
           named color, see Syntax 1.

        2. Most modern graphics devices support full RGB (RedBlueGreen)
           color.  You can alternatively specify RGB colors by entering
           three integer values to represent the Red, Green and Blue
           components, respectively.  These values should be in the range
           0 to 255.

    When setting the arrow color, Dataplot first checks if the device
    supports RGB colors. If not, the named color will be used.  If the
    device does support RGB color, Dataplot will check if an RGB color
    has been specified.  If yes, then that RGB color is used.  If not,
    the named color will be used.

    To see the list of supported named colors (with the associated index
    number), see

    https://www.itl.nist.gov/div898/software/dataplot/refman1/ch11/homepage.htm

Syntax 1:
    ARROW  <id>  COLOR  <color>
    where <id> is an arrow identifier (an integer number or parameter)
               in the integer range 1 to 100;
    and where <color> is the desired color.
 
Syntax 2:
    ARROW  <id>  RGB COLOR <red-1> <green-1> <blue-1>
    where <id> is an arrow identifier (an integer number or parameter)
               in the integer range 1 to 100;
    and   <red-1>, <green-1>, <blue-1> is a list of integer values that
               specifies the desired RGB arrow color.

    Up to 100 such triplets of color values can be specified.

    To turn off the RGB color, set the values to -1 (any negative value
    will work).  Values greater than 255 will be set to 255.
 
Examples:
    ARROW 1 COLOR BLUE
    ARROW 2 COLOR GREEN
    ARROW 1 RGB COLOR 220 109 88
 
Note:
    Arrows can be generated in two ways.  You can use the ARROW
    COORDINATES command to place arrows on subsequent plots or you can
    use the ARROW command to generate one arrow immediately.  The ARROW
    COLOR command is used to specify the color in either case.  When
    the ARROW command is used, the color is set to the color of the
    first arrow (i.e., <id> is 1).
 
Note:
    An ARROW ... COLOR command with no arguments sets the arrow color
    to default; thus ARROW 1 COLOR with no arguments sets the color for
    arrow 1 to default.  An ARROW ... COLOR command with no <id> refers
    to all 100 arrows; thus ARROW COLOR GREEN assigns the color green
    to all 100 arrows.  Note also that ARROW COLOR with no <id> and no
    arguments sets the color to default for all 100 arrows.
 
Default:
    All arrows are drawn with black lines.
 
Synonyms:
    None
 
Related Commands:
    PLOT             = Generates a data or function plot.
 
    ARROW COORDINATE = Generates arrows on subsequent plots.
    ARROW PATTERN    = Sets the line type for arrows.
    ARROW COLOR      = Sets the color for arrows.
    ARROW THICKNESS  = Sets the thickness for arrows.
    REGION FILL      = Sets the region fill switch for diagrammatic
                       graphics.
    HEIGHT           = Sets height (= length of base) for arrow head.
    WIDTH            = Sets width (= distance from base to the tip) for
                       the arrow head.
    HW               = Sets the height and width for the arrow head.
 
    CHARACTERS COLOR = Sets the colors for plot characters.
    LINE COLORS      = Sets the colors for plot lines.
    SPIKE COLORS     = Sets the colors for plot spikes.
    BAR FILL COLORS  = Sets the colors for plot bar fills.
    BAR PATT COLORS  = Sets the colors for plot bar patterns.
    BAR BORDER COLOR = Sets the colors for plot bar borders.
 
    TITLE COLOR      = Sets the color for plot title.
    LABEL COLOR      = Sets the color for plot labels.
    LEGEND COLOR     = Sets the color for plot legends.
    BOX COLOR        = Sets the color for plot boxes.
    SEGMENT COLOR    = Sets the color for plot segments.
    FRAME COLOR      = Sets the color for plot frame.
    GRID COLOR       = Sets the color for plot grids.
    TIC COLOR        = Sets the color for plot tics.
    TIC LABEL COLOR  = Sets the color for plot tic labels.
    MARGIN COLOR     = Sets the color for plot margin.
    BACKGROUND COLOR = Sets the color for plot background.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    Pre-1987
    2020/11: Support for RGB colors
 
Program 1:
    LET X = DATA 1 2 3 4 5 6 7 8 9 10
    LET Y = DATA 2 4 60 7 9 12 14 15 18 20
    .
    XLIMITS 1 10
    XTIC OFFSET 1 1
    YLIMITS 0 60
    YTIC OFFSET 0 5
    .
    ARROW 1 COORDINATES 45 87 36 85
    ARROW 1 COLOR BLACK
    ARROW 2 COORDINATES 71 46 78 45
    ARROW 2 COLOR G50
    LINE COLOR BLACK G50
    .
    LEGEND 1 OUTLIER
    LEGEND 2 LAST POINT
    LEGEND 1 COORDINATES 47 86
    LEGEND 2 COORDINATES 69 45
    LEGEND 2 JUSTIFICATION RIGHT
    .
    PLOT Y X
    .
    LINE RGB COLOR 175 238 238 220 20 60
    ARROW 1 RGB COLOR 175 238 238
    ARROW 2 RGB COLOR 220 20 60
    .
    PLOT Y X
 
-----ARROW COORDINATES-------------------------------------------------
 
ARROW COORDINATES
 
Name:
    ARROW ... COORDINATES
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the coordinates for arrows to appear on subsequent plots.
    Up to 100 arrows can be specified with this command.
 
Description:
    The 2 pairs of coordinates define the (x,y) values for the tail and
    the head (respectively) of the arrow.
 
Syntax:
    ARROW   <id>   COORDINATES   <x1>   <y1>   <x2>   <y2>
    where <id> is an arrow identifier (a number or parameter) in the
               integer range 1 to 100;
    and where <x1>, <y1>, <x2>, <y2> are coordinates (numbers or
               parameters) in the decimal range 0 to 100.
 
Examples:
    ARROW 2 COORDINATES 50 50 60 50
    ARROW 2 COORDINATES 20 70 50 50
    ARROW 4 COORDINATES 20 80 40 60
    ARROW 4 COORDINATES 80 80 60 70
    ARROW 1 COORDINATES X1 Y1 X2 Y2
 
Note:
    Arrows can be generated in two ways.  You can use the ARROW
    COORDINATES command to place arrows on subsequent plots or you can
    use the ARROW command to generate one arrow immediately.
 
    On plots, arrows drawn with the ARROW COORDINATES command use
    DATAPLOT screen coordinates (i.e., 0 to 100).  If you want to use
    data units, use the character type VECTOR or ARROW (they differ in
    how they handle the first point).  In this case, the attributes
    of the arrow are controlled by the various CHARACTER attribute
    setting commands.  See the documentation for the VECTOR PLOT
    command for details.
 
Note:
    The attributes of the arrow are controlled by the ARROW PATTERN,
    ARROW COLOR, and ARROW THICKNESS commands.  The ARROW COORDINATE
    command always generates filled arrow heads and does not give the
    user control over the size of the arrow head.  The other 2 methods
    for generating arrows (CHARACTER VECTOR and ARROW) do give the
    user control of these attributes.
 
Note:
    An ARROW ... COORDINATES command with no arguments omits the arrow
    from subsequent plots; thus ARROW 1 COORDINATES with no arguments
    omits arrow 1 from subsequent plots.  An ARROW ... COORDINATES
    command with no <id> refers to all 100 arrows; thus ARROW
    COORDINATES 30 80 40 60 assigns the coordinates (30,80) and (40,60)
    to all 100  arrows (but this has no practical use).  Note also that
    ARROW COORDINATES with no <id> and no arguments omits all 100
    arrows from subsequent plots.
 
Default:
    No arrows are drawn on subsequent plots.
 
Synonyms:
    None
 
Related Commands:
    PLOT               = Generates a data or function plot.
    ARROW PATTERN      = Sets the line type for arrows.
    ARROW COLOR        = Sets the color for arrows.
    ARROW THICKNESS    = Sets the thickness for arrows.
 
    LEGEND COORDINATES = Sets the location of plot legends.
    BOX COORDINATES    = Sets the location of plot boxes.
    ARROW COORDINATES  = Sets the location of plot arrows.
    SEGMENT COORDINATE = Sets the location of plot line segments.
    FRAME COORDINATES  = Sets the location of the plot frame.
    WINDOW COORDINATES = Sets the location of the plot window.
    CURSOR COORDINATES = Sets the location of the post-plot cursor.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    XX
 
Program:
    LET X = DATA 1 2 3 4 5 6 7 8 9 10
    LET Y = DATA 2 4 60 7 9 12 14 15 18 20
    .
    XLIMITS 1 10
    XTIC OFFSET 1 1
    YLIMITS 0 60
    YTIC OFFSET 0 5
    .
    ARROW 1 COORDINATES 45 87 36 85
    ARROW 1 PATTERN DASH
    ARROW 1 THICKNESS 0.2
    ARROW 1 COLOR BLACK
    ARROW 2 COORDINATES 71 46 78 45
    ARROW 2 PATTERN SOLID
    ARROW 2 THICKNESS 0.3
    ARROW 2 COLOR G50
    .
    LEGEND 1 OUTLIER
    LEGEND 2 LAST POINT
    LEGEND 1 COORDIANTES 47 86
    LEGEND 2 COORDIANTES 69 45
    LEGEND 2 JUSTIFICATION RIGHT
    .
    PLOT Y X
 
-----ARROW PATTERN-----------------------------------------------------
 
ARROW PATTERN
 
Name:
    ARROW ... PATTERN
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the patterns for arrows to appear on subsequent plots (as
    specified via the ARROW ... COORDINATES command) or arrows
    generated by the ARROW command.  Up to 100 arrows can be specified
    with the ARROW COORDINATES command.
 
Syntax:
    ARROW   <id>   PATTERN   <pattern>
    where <id> is an arrow identifier (a number or parameter) in the
               integer range 1 to 100;
    and where <pattern> is the desired line style.
 
Examples:
    ARROW 2 PATTERN SOLID
    ARROW 2 PATTERN DASH
 
Note:
    This command is rarely used.  Plot arrows are almost always drawn
    with the default style (i.e., solid lines).
 
Note:
    Arrows can be generated in two ways.  You can use the ARROW
    COORDINATES command to place arrows on subsequent plots or you can
    use the ARROW command to generate one arrow immediately.  The ARROW
    PATTERN command is used to specify the pattern in either case.
    When the ARROW command is used, the pattern is set to the pattern
    of the first arrow (i.e., <id> is 1).
 
Note:
    An ARROW ... PATTERN command with no arguments sets the arrow
    pattern to default; thus ARROW 1 PATTERN with no arguments sets the
    pattern for arrow 1 to default.  An ARROW ... PATTERN command with
    no <id> refers to all 100 arrows; thus ARROW PATTERN DASH assigns
    the pattern dash to all 100 arrows.  Note also that ARROW PATTERN
    with no <id> and no arguments sets the pattern to default for all
    100 arrows.
 
Default:
    All arrows are drawn with solid lines.
 
Synonyms:
    None
 
Related Commands:
    PLOT             = Generates a data or function plot.
    ARROW            = Draws an arrow.
    ARROW COORDINATE = Generates arrows on subsequent plots.
    ARROW COLOR      = Sets the color for arrows.
    ARROW THICKNESS  = Sets the thickness for arrows.
    LINE             = Sets the style for plot lines.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    XX
 
Program:
    LET X = DATA 1 2 3 4 5 6 7 8 9 10
    LET Y = DATA 2 4 60 7 9 12 14 15 18 20
    .
    XLIMITS 1 10
    XTIC OFFSET 1 1
    YLIMITS 0 60
    YTIC OFFSET 0 5
    .
    ARROW 1 COORDINATES 45 87 36 85
    ARROW 1 PATTERN DASH
    ARROW 2 COORDINATES 71 46 78 45
    ARROW 2 PATTERN DOTTED
    .
    LEGEND 1 OUTLIER
    LEGEND 2 LAST POINT
    LEGEND 1 COORDIANTES 47 86
    LEGEND 2 COORDIANTES 69 45
    LEGEND 2 JUSTIFICATION RIGHT
    .
    PLOT Y X
 
-----ARROW THICKNESS---------------------------------------------------
 
ARROW THICKNESS
 
Name:
    ARROW ... THICKNESS
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the thicknesses for arrows to appear on subsequent plots
    (as specified via the ARROW ... COORDINATES command) or arrows
    generated by the ARROW command.  Up to 100 arrows can be specified
    with the ARROW COORDINATES command.
 
Syntax:
    ARROW   <id>   THICKNESS   <thickness>
    where <id> is an arrow identifier (an integer number or parameter)
               in the integer range 1 to 100;
    and where <thickness> is the desired line thickness (a number or
               parameter) in the decimal range 0 to 100.
 
Examples:
    ARROW 2 THICKNESS 0.2
    ARROW 2 THICKNESS 0.1
 
Note:
    Arrows can be generated in two ways.  You can use the ARROW
    COORDINATES command to place arrows on subsequent plots or you can
    use the ARROW command to generate one arrow immediately.  The ARROW
    THICKNESS command is used to specify the thickness in either case.
    When the ARROW command is used, the thickness is set to the
    thickness of the first arrow (i.e., <id> is 1).
 
Note:
    An ARROW ... THICKNESS command with no arguments sets the arrow
    thickness to default; thus ARROW 1 THICKNESS with no arguments sets
    the thickness for arrow 1 to default.  An ARROW ... THICKNESS
    command with no <id> refers to all 100 arrows; thus ARROW THICKNESS
    0.1 assigns the thickness 0.1 to all 100 arrows.  Note also that
    ARROW THICKNESS with no <id> and no arguments sets the thickness to
    default for all 100 arrows.
 
Default:
    All arrows are drawn with a line width of 0.1.
 
Synonyms:
    None
 
Related Commands:
    PLOT             = Generates a data or function plot.
    ARROW COORDINATE = Generates arrows on subsequent plots.
    ARROW PATTERN    = Sets the line type for arrows.
    ARROW COLOR      = Sets the color for arrows.
    LINE THICKNESS   = Sets the thicknesses for plot lines.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    Pre-1987
 
Program:
    LET X = DATA 1 2 3 4 5 6 7 8 9 10
    LET Y = DATA 2 4 60 7 9 12 14 15 18 20
    .
    XLIMITS 1 10
    XTIC OFFSET 1 1
    YLIMITS 0 60
    YTIC OFFSET 0 5
    .
    ARROW 1 COORDINATES 45 87 36 85
    ARROW 1 THICKNESS 0.3
    ARROW 2 COORDINATES 71 46 78 45
    ARROW 2 THICKNESS 0.2
    .
    LEGEND 1 OUTLIER
    LEGEND 2 LAST POINT
    LEGEND 1 COORDIANTES 47 86
    LEGEND 2 COORDIANTES 69 45
    LEGEND 2 JUSTIFICATION RIGHT
    .
    PLOT Y X
 
-----ARSCDF (LET)--------------------------------
 
ARSCDF
 
Name:
    ARSCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the arc-sine cumulative distribution function.
 
Description:
    The arc-sine distribution has the following cumulative
    distribution function:

       F(x) = 2*ARCSIN(SQRT(x))/PI         0 < x < 1
 
    The arc-sine distribution is a special case of the Beta
    distribution with both shape parameters equal to 1/2.  The
    generalized arc-sine distribution is a special case of the
    Beta distribution where the two parameters sum to 1 but are
    not necessarily equal to 1/2.  The generalized arc-sine
    probability functions can be computed using the beta
    probability distributions in Dataplot.

    Johnson, Kotz, and Balakrishnan (see the Reference section
    below) give a derivation of this distribution based on
    random walks.

Syntax:
    LET <y> = ARSCDF(<x>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed arc-sine cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ARSCDF(3)
    LET A = ARSCDF(A1)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ARSPDF = Compute the arc-sine probability density function.
    ARSPPF = Compute the arc-sine percent point function.
    BETCDF = Compute the beta cumulative distribution function.
    BETPDF = Compute the beta probability density function.
    BETPPF = Compute the beta percent point function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994,
    pages 212, 253.
 
Applications:
    Data Analysis
 
Implementation Date:
    1995/9
 
Program:
    TITLE AUTOMATIC
    PLOT ARSCDF(X) FOR X = 0.01 0.01 0.99
-----ARSPDF (LET)--------------------------------
 
ARSPDF
 
Name:
    ARSPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the arc-sine probability density function.
 
Description:
    The arc-sine distribution has the following probability density
    function:

       f(x) = 1/[PI*SQRT(x*(1 - x))]       0 < x < 1
 
    The arc-sine distribution is a special case of the Beta
    distribution with both shape parameters equal to 1/2.  The
    generalized arc-sine distribution is a special case of the
    Beta distribution where the two parameters sum to 1 but are
    not necessarily equal to 1/2.  The generalized arc-sine
    probability functions can be computed using the beta
    probability distributions in Dataplot.

    Johnson, Kotz, and Balakrishnan (see the Reference section
    below) give a derivation of this distribution based on
    random walks.

Syntax:
    LET <y> = ARSPDF(<x>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed arc-sine pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ARSPDF(3)
    LET A = ARSPDF(A1)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ARSCDF = Compute the arc-sine cumulative distribution function.
    ARSPPF = Compute the arc-sine percent point function.
    BETCDF = Compute the beta cumulative distribution function.
    BETPDF = Compute the beta probability density function.
    BETPPF = Compute the beta percent point function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994,
    pages 212, 253.
 
Applications:
    Data Analysis
 
Implementation Date:
    1995/9
 
Program:
    TITLE AUTOMATIC
    PLOT ARSPDF(X) FOR X = 0.01 0.01 0.99

-----ARSPPF (LET)--------------------------------
 
ARSPPF
 
Name:
    ARSPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the arc-sine percent point function.
 
Description:
    The arc-sine distribution has the following percent point
    function:

       G(p) = [SIN(p*PI/2)]**2             0 < p < 1
 
    The arc-sine distribution is a special case of the Beta
    distribution with both shape parameters equal to 1/2.  The
    generalized arc-sine distribution is a special case of the
    Beta distribution where the two parameters sum to 1 but are
    not necessarily equal to 1/2.  The generalized arc-sine
    probability functions can be computed using the beta
    probability distributions in Dataplot.

    Johnson, Kotz, and Balakrishnan (see the Reference section
    below) give a derivation of this distribution based on
    random walks.

Syntax:
    LET <y> = ARSPPF(<p>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable in the range (0,1);
          <y> is a variable or a parameter (depending on what <p> is)
              where the computed arc-sine ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ARSPPF(0.95)
    LET A = ARSPPF(A1)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ARSCDF = Compute the arc-sine cumulative distribution function.
    ARSPDF = Compute the arc-sine probability density function.
    BETCDF = Compute the beta cumulative distribution function.
    BETPDF = Compute the beta probability density function.
    BETPPF = Compute the beta percent point function.
 
Reference:
    "Continuous Univariate Distributions: Volume 1", 2nd. Ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley, 1994,
    pages 212, 253.
 
Applications:
    Data Analysis
 
Implementation Date:
    1995/9
 
Program:
    TITLE AUTOMATIC
    PLOT ARSPPF(P) FOR P = 0.01 0.01 0.99

-----ASSOCIATION PLOT (LET)--------------------------------
 
ASSOCIATION PLOT
 
Name:
    ASSOCIATION PLOT (LET)
 
Type:
    Graphics Command
 
Purpose:
    Generate an association plot for a two-way contingency table.

Description:
    The chi-square test of independence for a two-way contingency
    table is based on the following test statistic:

       T = SUM[i=1 to r][j=1 to c][(O(ij) - E(ij)**2/E(ij)]

    where

       r     = the number of rows in the contingency table
       c     = the number of columns in the contingency table
       O(ij) = the observed frequency of the ith row and jth column
       E(ij) = the expected frequency of the ith row and jth column
             = R(i)*C(j)/N
       R(i)  = the sum of the observed frequencies for row i
       C(j)  = the sum of the observed frequencies for column j
       N     = the total sample size

    This test statistic can also be formulated as 

       T = SUM[i=1 to r][j=1 to c][d(ij)**2

    where

       dij = (O(ij) - E(ij))/SQRT(E(ij))

    The dij are referred to as the standardized residuals and they
    show the contribution to the chi-square test statistic of each
    cell.

    The association plot is a graphical way of showing these
    standardized residuals.  Specifically, the cells are laid out
    in a two-way grid and each cell is plotted with a rectangle
    where

       1) The width of the rectangle is proportional to the
          square root of the expected frequency.

       2) The height of the rectangle is proportional to the
          standardized residual (dij).

    For visual clarity, positive and negative standardized residuals
    are typically drawn in different colors.

Syntax 1:
    ASSOCIATION PLOT <y1> <y2>     <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax is used for the case where you have raw data (i.e.,
    the data has not yet been cross tabulated into a two-way table).

Syntax 2:
    ASSOCIATION PLOT <m>    <SUBSET/EXCEPT/FOR qualification>
    where <m> is a matrix containing the two-way table;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax is used for the case where we the data have already
    been cross-tabulated into a two-way contingency table.

Syntax 3:
    ASSOCIATION PLOT <n11> <n12> <n21> <n22>
    where <n11> is a parameter containing the value for row 1,
                column 1 of a 2x2 table;
          <n12> is a parameter containing the value for row 1,
                column 2 of a 2x2 table;
          <n21> is a parameter containing the value for row 2,
                column 1 of a 2x2 table;
          <n22> is a parameter containing the value for row 2,
                column 2 of a 2x2 table.

    This syntax is used for the special case where you have a
    2x2 table.  In this case, you can enter the 4 values directly,
    although you do need to be careful that the parameters are
    entered in the order expected above.

Examples:
    ASSOCIATION PLOT Y1 Y2
    ASSOCIATION PLOT M
    ASSOCIATION PLOT N11 N12 N21 N22

Note:
    The example program below demonstrates how to specify the
    different colors for positive and negative standardized
    residuals.  It also demonstrates how to label the rows and
    columns of the plot.

Default:
    None
 
Synonyms:
    None

Related Commands:
    CHI-SQUARE INDEPENDENCE TEST  = Perform a chi-square test for
                                    independence.
    ODDS RATIO INDEPENDENCE TEST  = Perform a log(odds ratio) test for
                                    independence.
    FISHER EXACT TEST             = Perform Fisher's exact test.
    SIEVE PLOT                    = Generate a sieve plot.
    ROSE PLOT                     = Generate a Rose plot.
    BINARY TABULATION PLOT        = Generate a binary tabulation plot.
    ROC CURVE                     = Generate a ROC curve.
    ODDS RATIO                    = Compute the bias corrected odds ratio.
    LOG ODDS RATIO                = Compute the bias corrected
                                    log(odds ratio).

Reference:
    Friendly (2000), "Visualizing Categorical Data", SAS Institute
    Inc., p. 90.

    Cohen (1980), "On the Graphical Display of the Significant
    Components in a Two-Way Contingency Table", Communications in
    Statistics--Theory and Methods, A9:1025-1041.

Applications:
    Graphical Analysis of Categorical Data
 
Implementation Date:
    2007/6
 
Program:
    . Example from page 61 of Friendly
    read matrix m
     5  29 14 16
    15  54 14 10
    20  84 17 94
    68 119 26 7
    end of data
    .
    label case asis
    tic mark label case asis
    title case asis
    title offset 2
    .
    x3label
    title Association Plot
    y1label displacement 12
    y1label Eye Color
    x1label Hair Color
    tic offset units data
    xlimits 1 4
    major xtic mark number 4
    minor xtic mark number 0
    xtic mark offset 1 1
    x1tic mark label format alpha
    x1tic mark label content Black Brown Red Blond
    ylimits 1 4
    major ytic mark number 4
    minor ytic mark number 0
    ytic mark offset 1 1
    y1tic mark label format alpha
    y1tic mark label content Green Hazel Blue Brown
    y1tic mark label justification right
    .
    line solid
    region fill color blue green
    .
    association plot m

-----ATNINT (LET)--------------------------------

ATNINT

Name:
   ATNINT (LET)
 
Type:
    Library Function

Purpose:
    This program computes the integral of the inverse-tangent
    function.

Description:
    The ATNINT function is defined as:

        ATNINT(x) = integral {0 to x} (arctan t)/t dt

    with arctan denoting the inverse tangent function.

    Dataplot computes this function using ACM Algorithm 757 (see
    Reference: below).  The function is computed using Chebyshev
    expansions, the coefficients of which are given to 20 decimal
    places.

Syntax:
    LET <y> = ATNINT(<x>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, variable or parameter;
          <y> is a variable or a parameter (depending on what <x> 
               is) where the computed ATNINT function values are
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = ATNINT(2.3)
    PLOT ATNINT(X) FOR  X = 0 0.01 5
    LET X2 = ATNINT(X1) FOR X1 = 0.1 0.1 3.0
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TAN        = Compute the tangent function.
    ARCTAN     = Compute the arctangent (=inverse) function.
    ARCTANH    = Compute the hyperbolic arctangent function.
    LOGINT     = Compute the logarithmic integral.
    EXPINTN    = Compute the exponential integral of order N.
    SININT     = Compute the sine integral.
    COSINT     = Compute the cosine integral.

Reference:
    "ACM Transactions of Mathematical Software", Allan MacLead,
    Vol. 22, No. 3, September, 1996, pp. 288-301.
 
Applications:
    Special Functions
 
Implementation Date:
    2005/11
 
Program:
    TITLE ATNINT FUNCTION
    PLOT ATNINT(X) FOR X = 0 0.01 10
 
-----AUTOCORRELATION (LET)--------------------------------
 
AUTOCORRELATION
 
Name:
    AUTOCORRELATION (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the autocorrelation for a variable.
 
Description:
    The autocorrelation is the correlation between x(i) and x(i-1).
    It is often used as a measure of randomness (a random variable
    should have an autocorrelation near zero).
 
Syntax:
    LET <param> = AUTOCORRELATION <y> <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a response variable;
          <param> is a parameter where the computed autocorrelation is
                  stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = AUTOCORRELATION Y1
    LET A = AUTOCORRELATION Y1 SUBSET TAG > 2
 
Note:
    This command computes the autocorrelation for lag 1 (i.e., for x(i)
    vs. x(i-1)).  To compute it for other lags, do the following:
       AUTOCORRELATION PLOT Y1
       LET LAG = 3
       LET AC = YPLOT(LAG)
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    AUTOCORRELATION PLOT      = Generate an autocorrelation plot.
    AUTOCORRELATION STAT PLOT = Generate an autocorrelation versus
                                subset plot.
    AUTOCOVARIANCE            = Compute the autocovariance.
    CORRELATION               = Compute the correlation between two
                                variables.
 
Applications:
    Time Series Analysis, Exploratory Data Analysis
 
Implementation Date:
    Pre-1987
 
Program:
    LET Y1 = EXPONENTIAL RANDOM NUMBERS FOR I = 1 1 100
    LET A1 = AUTOCORRELATION Y1
 
-----AUTOCORRELATION BAND (SET)-------------------------------------
 
AUTOCORRELATION BAND
 
Name:
    AUTOCORRELATION BAND (SET)
 
Type:
    Set Subcommand
 
Purpose:
    Specify what type of confidence bands are drawn on
    subsequent autocorrelation plots.
 
Description:
    Autocorrelation plots are used for the following two
    purposes:

       1) To assess the independence (i.e., randomness) of a
          set of observations.

          In this case, the desired confidence bands are

              +/- z(1-alpha/2)/SQRT(N)

          where alpha is the desired significance level, z is
          the percent point function of the standard normal
          distribution, and N is the sample size.  In this case,
          the confidence bands have a fixed width.

       2) In the context of ARIMA models, confidence bands are
          generated under the assumption that the data are from a
          moving average process.  In this context, confidence
          bands help identify the appropriate order for the
          moving average model.  The formula for the confidence
          bands is

              +/- z(1-alpha/2)*
              SQRT((1/N)*(1 + 2*SUM[i=1 to k][Y(i)**2]))

          where alpha is the desired significance level, z is
          the percent point function of the standard normal
          distribution, N is the sample size, and k is the
          desired lag.  In this case, the width of the confidence
          bands increases as the lag, k, increases.

Syntax:
    SET AUTOCORRELATION BAND <WHITE NOISE/BOX JENKINS>
    where <WHITE NOISE> specifies that the confidence bands are
          drawn to show independence while <BOX JENKINS> specifies
          that confidence bands are drawn to identify the
          order of the movign average process.
 
Examples:
    SET AUTOCORRELATION BAND WHITE NOISE
    SET AUTOCORRELATION BAND BOX JENKINS
 
Default:
    The default is WHITE NOISE.
 
Synonyms:
    ARMA, ARIMA, BOXJENKINS, BOX, and JENKINS are synonyms
    for BOX JENKINS.  Any other text reverts to the default
    choice of WHITE NOISE.
 
Related Commands:
    CORRELATION PLOT      = Generate an autocorrelation, partial
                            autocorrelation, or cross correlation
                            plot.
    AUTOCORRELATION LAG   = Specifies whether the lag 0 value is
                            plotted on subsequent autocorrelation
                            or partial autocorrelation plots.
    SPECTRAL PLOT         = Generate a spectral plot.
 
Applications:
    Time Series Analysis
 
Implementation Date:
    2003/2
 
Program:
    READ NEGIZ4.DAT X1 X2 Y
    LET Y2 = SEQUENTIAL DIFFERENCE Y
    SET AUTOCORRELATION BAND BOX JENKINS
    LINE BLANK
    SPIKE ON
    AUTOCORRELATION PLOT Y2
 
-----AUTOCORRELATION LAG ZERO (SET)----------------------------------
 
AUTOCORRELATION LAG ZERO
 
Name:
    AUTOCORRELATION LAG ZERO (SET)
 
Type:
    Set Subcommand
 
Purpose:
    Specify whether the lag zero correlation is plotted for
    autocorrelation and partial autocorrelation plots.
 
Description:
    For autocorrelation and partial autocorrelation plots,
    the lag zero correlation is always equal to 1.  By
    default, Dataplot will plot this lag zero value.  However,
    some users prefer to omit the lag zero value.  The
    SET AUTOCORRELATION LAG ZERO command allows you to specify
    which option you prefer.

Syntax:
    SET AUTOCORRELATION LAG ZERO <ON/OFF>
    where <ON> specifies that the lag zero value is plotted while
          <OFF> specifies that the lag zero value is not plotted.
 
Examples:
    SET AUTOCORRELATION LAG ZERO OFF
    SET AUTOCORRELATION LAG ZERO ON
 
Default:
    The default is ON (lag zero is plotted)
 
Synonyms:
    None
 
Related Commands:
    CORRELATION PLOT      = Generate an autocorrelation, partial
                            autocorrelation, or cross correlation
                            plot.
    AUTOCORRELATION BAND  = Set type of confidence bounds for
                            autocorrelation plot.
    SPECTRAL PLOT         = Generate a spectral plot.
 
Applications:
    Time Series Analysis
 
Implementation Date:
    2003/2
 
Program:
    SKIP 25
    READ LEW.DAT Y
    SET AUTOCORRELATION LAG ZERO OFF
    LINE BLANK
    SPIKE ON
    AUTOCORRELATION PLOT Y
 
-----AUTOCOVARIANCE (LET)--------------------------------
 
AUTOCOVARIANCE
 
Name:
    AUTOCOVARIANCE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the autocovariance for a variable.
 
Description:
    The autocovariance is the covariance between x(i) and x(i-1).
 
Syntax:
    LET <param> = AUTOCOVARIANCE <y1> <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a response variable;
          <param> is a parameter where the computed autocovariance is
                  stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = AUTOCOVARIANCE Y1
    LET A = AUTOCOVARIANCE Y1 SUBSET TAG > 2
 
Note:
    This command computes the autocovariance for lag 1 (i.e., for x(i)
    vs. x(i-1)).  To compute it for lag 1 through n, do the following:
       LET NSIZE = SIZE Y1
       LET TAG = SEQUENCE 1 1 NSIZE
       LOOP FOR K = 1 1 N
         LET LAG = K
         LET YTEMP1 = Y1
         RETAIN YTEMP1 SUBSET TAG > LAG
         LET YTEMP2 = Y1
         LET TEMP = NSIZE - LAG
         RETAIN YTEMP2 SUBSET TAG < TEMP
         LET TEMP = COVARIANCE YTEMP1 YTEMP2
         LET AC(LAG) = TEMP
       END OF LOOP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    AUTOCORRELATION PLOT     = Generate an autocovariance plot.
    AUTOCOVARIANCE STAT PLOT = Generate an autocovariance vs.
                               subset plot.
    AUTOCORRELATION          = Compute the autocorrelation.
    COVARIANCE               = Compute the covariance between two
                               variables.
 
Applications:
    Time Series Analysis
 
Implementation Date:
    XX
 
Program:
    LET Y1 = EXPONENTIAL RANDOM NUMBERS FOR I = 1 1 100
    LET A1 = AUTOCOVARIANCE Y1
 
-----AUTOCOVARIANCE PLOT----------------------------------------
 
AUTOCOVARIANCE PLOT
 
Name:
    AUTOCOVARIANCE PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates an autocovariance statistics plot.
 
Description:
    An autocovariance statistics plot is a plot consisting of
    subsample autocovariances versus subsample index.  The subsample
    autocovariance is the autocovariance of the data in the
    subsample.  This plot is used to answer the question-- "Does the
    subsample autocovariance change over different subsamples?".  The
    plot consists of:
       Vertical   axis = subsample autocovariance;
       Horizontal axis = subsample index.
    The AUTOCOVARIANCE STATISTICS PLOT yields 2 traces:
       1. a subsample autocovariance trace; and
       2. a full-sample autocovariance reference line.
    Like usual, the appearance of these 2 traces is controlled by the
    first 2 settings of the LINES, CHARACTERS, SPIKES, BARS, and
    similar attributes.
 
Syntax:
    AUTOCOVARIANCE PLOT  <y>  <x>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response (i.e.,  dependent) variable;
          <x> is the subsample identifier variable (this variable
              appears on horizontal axis);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    AUTOCOVARIANCE PLOT Y X
    AUTOCOVARIANCE PLOT Y X1  SUBSET X1 > 5
 
Default:
    None
 
Synonyms:
    AUTOCOVARIANCE STATISTIC PLOT
 
Related Commands:
    CHARACTERS                = Sets the types for plot characters.
    LINES                     = Sets the types for plot lines.
    AUTOCOVARIANCE            = Computes the autocovariance of a
                                variable.
    AUTOCORRELATION STAT PLOT = Generates an autocorrelation versus
                                subset plot.
    MEAN   PLOT               = Generates a mean versus subset plot.
    STANDARD DEVIATION  PLOT  = Generates a standard deviation versus
                                subset plot.
    PLOT                      = Generates a data or function plot.
 
Applications:
    Exploratory Data Analysis
 
Implementation Date:
    88/2
 
Program:
    SKIP 25
    READ SUNSPOT.DAT Y MONTH
    CHARACTER CIRCLE BLANK
    LINE BLANK SOLID
    XLIMITS 1 12
    XTIC OFFSET 0.5 0.5
    X1TIC MARK LABEL FORMAT ALPHA
    X1TIC MARK LABEL CONTENTS JAN FEB MARCH APRIL MAY JUNE JULY AUG ...
         SEP OCT NOV DEC
    MINOR XTIC MARK NUMBER 0
    Y1LABEL AUTOCOVARIANCE
    AUTOCOVARIANCE STAT PLOT Y MONTH
 
-----AUTOCORRELATION STAT PLOT----------------------------------------
 
AUTOCORRELATION STATISTICS PLOT
 
Name:
    AUTOCORRELATION STATISTICS PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates an autocorrelation statistics plot.
 
Description:
    An autocorrelation statistics plot is a plot consisting of
    subsample autocorrelations versus subsample index.  The subsample
    autocorrelation is the autocorrelation of the data in the
    subsample.  This plot is used to answer the question-- "Does the
    subsample autocorrelation change over different subsamples?".  The
    plot consists of:
       Vertical   axis = subsample autocorrelation;
       Horizontal axis = subsample index.
    The AUTOCORRELATION STATISTICS PLOT yields 2 traces:
       1. a subsample autocorrelation trace; and
       2. a full-sample autocorrelation reference line.
    Like usual, the appearance of these 2 traces is controlled by the
    first 2 settings of the LINES, CHARACTERS, SPIKES, BARS, and
    similar attributes.
 
Syntax:
    AUTOCORRELATION STATISTICS PLOT   <y>   <x>
                                    <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response (i.e.,  dependent) variable;
          <x> is the subsample identifier variable (this variable
              appears on horizontal axis);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    AUTOCORRELATION STATISTICS PLOT Y X
    AUTO STAT PLOT Y X1
 
Note:
    The AUTOCORRELATION PLOT is a distinct command (enter HELP
    CORRELATION PLOT for details), so the word STAT is required.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHARACTERS         = Sets the types for plot characters.
    LINES              = Sets the types for plot lines.
    MEAN   PLOT        = Generates a mean plot.
    MEDIAN PLOT        = Generates a median plot.
    MIDMEAN PLOT       = Generates a midmean plot.
    MIDRANGE PLOT      = Generates a midrange plot.
    TRIMMED MEAN PLOT  = Generates a trimmed mean plot.
    WINDSOR  MEAN PLOT = Generates a Windsorized mean plot
    SD   PLOT          = Generates a standard deviation plot.
    PLOT               = Generates a data or function plot.
 
Applications:
    Exploratory Data Analysis
 
Implementation Date:
    88/2
 
Program:
    SKIP 25
    READ SUNSPOT.DAT Y MONTH
    CHARACTER CIRCLE BLANK
    LINE BLANK SOLID
    XLIMITS 1 12
    XTIC OFFSET 0.5 0.5
    X1TIC MARK LABEL FORMAT ALPHA
    X1TIC MARK LABEL CONTENTS JAN FEB MARCH APRIL MAY JUNE JULY AUG ...
         SEP OCT NOV DEC
    MINOR XTIC MARK NUMBER 0
    Y1LABEL AUTOCORRELATION
    AUTOCORRELATION STAT PLOT Y MONTH
 
-----AUTOMATIC-------------------------------------------------------
 
AUTOMATIC
 
Name:
    AUTOMATIC
 
Type:
    Keyword
 
Purpose:
    Sets the DATAPLOT switch in question to the "automatic" position.
 
Syntax:
    <Certain DATAPLOT commands>   AUTOMATIC
 
Examples:
    X3LABEL AUTOMATIC
    FILTER WIDTH AUTOMATIC
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ON      = Allows switches to be set to "on".
    OFF     = Allows switches to be set to "off".
    DEFAULT = Allows switches to be set to "default".
 
Applications:
    XX
 
Implementation Date:
    Pre-1987
 
Program:
    TITLE AUTOMATIC
    PLOT X**2 FOR X = 1 1 9
 
-----AUTO TEXT-------------------------------------------------------
 
AUTO TEXT
 
Name:
    AUTO TEXT
 
Type:
    Support Command
 
Purpose:
    Specifies that all subsequent commands be prepended with a
    TEXT command.
 
Description:
    Entering AUTO TEXT ON specifies that subsequent command lines
    will be prepended until a line starting with AUTO TEXT OFF
    is encountered.

    This command is convenient when entering a block of text for
    a word slide that have common characteristics.  Note that
    commands for setting the attributes of the TEXT command
    should be entered before the AUTO TEXT ON command.  Blocks
    of text that need differenet attributes should be given
    in separate AUTO TEXT ON/AUTO TEXT OFF blocks.

    The AUTO TEXT OFF command must start in column 1 and be
    entered with exactly one space between the words (the case
    does not matter).
 
Syntax:
    AUTO TEXT <ON or OFF>
    where ON specifies that subsequent commands are to be prepended
    with a TEXT command and OFF terminates this.
 
Examples:
    AUTO TEXT ON
    SAMPLE: LINE 1
    SAMPLE: LINE 2
    SAMPLE: LINE 3
    AUTO TEXT OFF
 
Default:
    The default is OFF.
 
Synonyms:
    None
 
Note:
    The AUTO TEXT command with no arguments is equivalent to
    AUTO TEXT OFF.
 
Related Commands:
    TEXT    = Display a text string on the graphics device.
    MARGIN  = Set the margin for the TEXT command.
    CRLF    = Apply a carriage return/line feed after a TEXT command.
    HEIGHT  = Specify the height of characters for the TEXT comamnd.
 
Applications:
    Word Slides
 
Implementation Date:
    8/2002
 
Program:
    ERASE
    MARGIN 20
    CRLF ON
    HEIGHT 3
    MOVE 20 85
    AUTO TEXT ON
    WE CAN ENTER SEVERAL LINES OF TEXT
    BY SIMPLY ENTERING THE TEXT WITHOUT
    ANY DATAPLOT COMMANDS.  JUST KEEP TYPING
    UNTIL STARTING A LINE WITH AUTO TEXT OFF
    AUTO TEXT OFF
 
-----AVERAGE ABSOLUTE DEVIATION (LET)-------------------------------
 
AVERAGE ABSOLUTE DEVIATION
 
Name:
    AVERAGE ABSOLUTE DEVIATION (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the average absolute deviation for a variable.
 
Description:
    The average absolute deviation is defined as

        AAD = SUM(ABS(X-XBAR))/N

    where ABS is the absolute value, XBAR is the mean of the variable,
    and N is the number of observations.  This statistic is sometimes
    used as an alternative to the standard deviation.
 
Syntax:
    LET <par> = AVERAGE ABSOLUTE DEVIATION <y>
                <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the computed average absolute
               deviation is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = AVERAGE ABSOLUTE DEVIATION Y1
    LET A = AVERAGE ABSOLUTE DEVIATION Y1 SUBSET TAG > 2
 
Note:
    Prior to the 2014/07 version, this command computed the difference
    from the median rather than the mean.  The 2014/07 version corrected
    this command to compute differences from the mean and added
    the command

          AVERAGE ABSOLUTE DEVIATION FROM THE MEDIAN

    to compute differences from the median.

Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    AAD is a synonym for AVERAGE ABSOLUTE DEVIATION
 
Related Commands:
    AVERAGE ABSO DEVI FROM THE MEDIAN  = Compute the average absolute
                                         deviation from the median of a
                                         variable.
    DIFFERENCE OF AVERAGE ABSO DEVI    = Compute the difference in absolute
                                         average deviation of two variables.
    MEDIAN ABSOLUTE DEVIATION          = Compute the median absolute
                                         deviation of a variable.
    STANDARD DEVIATION                 = Compute the standard deviation of
                                         a variable.
    VARIANCE                           = Compute the variance of a
                                         variable.
    RANGE                              = Compute the range of a variable.
 
References:
    Dixon and Massey (1957), "Introduction  to Statistical Analysis",
    Second Edition, McGraw-Hill, pp. 75-76.

    Rosner, Bernard (May 1983), Percentage Points for a Generalized ESD
    Many-Outlier Procedure, Technometrics, Vol. 25, No. 2, pp. 165-172.

Applications:
    Data Analysis
 
Implementation Date:
    Pre-1987
    1989/01: Fixed computational bug
    2014/07: Compute difference from mean rather than the median
 
Program:
    .  Step 1: Data from Rosner paper (this data contains outliers)
    .
    serial read y
    -0.25 0.68 0.94 1.15 1.20 1.26 1.26 1.34 1.38 1.43 1.49 1.49 1.55 1.56
     1.58 1.65 1.69 1.70 1.76 1.77 1.81 1.91 1.94 1.96 1.99 2.06 2.09 2.10
     2.14 2.15 2.23 2.24 2.26 2.35 2.37 2.40 2.47 2.54 2.62 2.64 2.90 2.92
     2.92 2.93 3.21 3.26 3.30 3.59 3.68 4.30 4.64 5.34 5.42 6.01
    end of data
    .
    let aad  = average absolute deviation y
    let aad2 = average absolute deviation from the median y
    let mad  = average absolute deviation y
    let sd   = standard deviation y
    .
    print "Average Absolute Deviation:                   ^aad"
    print "Average Absolute Deviation from the median:   ^aad2"
    print "Median Absolute Deviation:                    ^mad"
    print "Standard Deviation:                           ^sd"
 
-----AVERAGE ABSOLUTE DEVIATION FROM THE MEDIAN(LET)---------------------
 
AVERAGE ABSOLUTE DEVIATION FROM THE MEDIAN
 
Name:
    AVERAGE ABSOLUTE DEVIATION FROM THE MEDIAN (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the average absolute deviation from the median for a variable.
 
Description:
    The average absolute deviation from the median is defined as

        AAD = SUM(ABS(X-XMED))/N

    where ABS is the absolute value, XMED is the median of the variable,
    and N is the number of observations.  This statistic is sometimes
    used as an alternative to the standard deviation.
 
Syntax:
    LET <par> = AVERAGE ABSOLUTE DEVIATION FROM THE MEDIAN <y>
                <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the computed average absolute
               deviation is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = AVERAGE ABSOLUTE DEVIATION FROM THE MEDIAN Y1
    LET A = AVERAGE ABSOLUTE DEVIATION FROM THE MEDIAN Y1 SUBSET TAG > 2
 
Note:
    Prior to the 2014/07 version, the AVERAGE ABSOLUTE DEVIATION command
    computed the average absolute deviation from the median.  In the
    2014/07 version, the AVERAGE ABSOLUTE DEVIATION command was modified
    to compute differences from the mean and the AVERAGE ABSOLUTE DEVIATION
    FROM THE MEDIAN command was added to compute differences from the
    median.

Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    AVERAGE ABSOLUTE DEVIATION  = Compute the average absolute deviation
                                  from the mean of a variable.
    DIFFERENCE OF AVERAGE ABSO  = Compute the difference in absolute
        DEVIATION FROM MEDIAN     average deviation from the median of two
                                  variables.
    MEDIAN ABSOLUTE DEVIATION   = Compute the median absolute deviation of
                                  a variable.
    STANDARD DEVIATION          = Compute the standard deviation of a
                                  variable.
    VARIANCE                    = Compute the variance of a variable.
    RANGE                       = Compute the range of a variable.
 
References:
    Dixon and Massey (1957), "Introduction  to Statistical Analysis",
    Second Edition, McGraw-Hill, pp. 75-76.

    Rosner, Bernard (May 1983), Percentage Points for a Generalized ESD
    Many-Outlier Procedure, Technometrics, Vol. 25, No. 2, pp. 165-172.

Applications:
    Data Analysis
 
Implementation Date:
    2014/07: Added as distinct command from AVERAGE ABSOLUTE DEVIATION
 
Program:
    .  Step 1: Data from Rosner paper (this data contains outliers)
    .
    serial read y
    -0.25 0.68 0.94 1.15 1.20 1.26 1.26 1.34 1.38 1.43 1.49 1.49 1.55 1.56
     1.58 1.65 1.69 1.70 1.76 1.77 1.81 1.91 1.94 1.96 1.99 2.06 2.09 2.10
     2.14 2.15 2.23 2.24 2.26 2.35 2.37 2.40 2.47 2.54 2.62 2.64 2.90 2.92
     2.92 2.93 3.21 3.26 3.30 3.59 3.68 4.30 4.64 5.34 5.42 6.01
    end of data
    .
    let aad2 = average absolute deviation from the median y
    let aad  = average absolute deviation y
    let mad  = average absolute deviation y
    let sd   = standard deviation y
    .
    print "Average Absolute Deviation from the median:   ^aad2"
    print "Average Absolute Deviation:                   ^aad"
    print "Median Absolute Deviation:                    ^mad"
    print "Standard Deviation:                           ^sd"
 
-----AVERAGE SHIFTED HISTOGRAM-------------------------------------
 
AVERAGE SHIFTED HISTOGRAM
 
Name:
    AVERAGE SHIFTED HISTOGRAM
 
Type:
    Graphics Command
 
Purpose:
    Generates an average shifted histogram.
 
Description:
    In addition to providing a convenient summary of a
    univariate set of data, the histogram can also be thought
    of as a simple kernel density estimator.

    David Scott has proposed the average shifted histogram
    (see chapter 5 of the "Multivariate Density Estimation: Theory
    and Practice, and Visualization" listed in the Reference
    section below) as a kernel density estimator that maintains
    the computational simplicity of the histogram while providing
    performance comparable to the more computationally intensive
    kernel density plot (enter HELP KERNEL DENSITY PLOT for details
    on the kernel density plot).

    The basic algorithm for the average shifted histogram is:

    1) Choose a class width of h (in Dataplot, you can select
       this class width with either the CLASS WIDTH or the
       SET HISTOGRAM CLASS WIDTH command, otherwise a default
       class width of 0.3 times the sample standard deviation
       will be used).

    2) Choose m where we construct a collection of m histograms,
       each with a class width of h, but with start points
       t0 = 0, h/m, 2*h/m, ... , (m-1)*h/m.

       In Dataplot, the value of m is set by entering the
       command

           LET M = <value>

       before entering the AVERAGE SHIFTED HISTOGRAM command.

       If the number of points is less than or equal to 100, 
       the default value is 4.  If the number of points is less
       than or equal to 1,000, the default value is 8.  If the
       number of points is greater than 1,000, the default value
       is 16.

       Dataplot sets values of m < 1 to 1 and values of m > 64 to
       64.

    3) This results in a "smoothed" histogram with a bin width of
       delta=h/m.  Higher values of m result in a smoother
       estimate.  Values of m are typically in the range 4 to 32.

    This is the algorithm given on page 117 of Scott.  This effectively
    gives an isosceles triangle weighting function.  Scott gives a
    generalization of the ASH algorithm that gives a biweight weighting
    function.  This is the ASH1 algorithm on page 118.  This will
    generate a smoother curve with less local noise than the triangular
    weighting.

    To use this biweight weighting function, enter the command

         SET AVERAGE SHIFTED HISTOGRAM WEIGHT BIWEIGHT

    To restore the default triangular weighting, enter

         SET AVERAGE SHIFTED HISTOGRAM WEIGHT TRIANGULAR

Syntax:
    AVERAGE SHIFTED HISTOGRAM <x> <SUBSET/EXCEPT/FOR qualification>
    where <x> is the variable of raw data values;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    AVERAGE SHIFTED HISTOGRAM TEMP
    AVERAGE SHIFTED HISTOGRAM Y  SUBSET TAG = 2
    AVERAGE SHIFTED HISTOGRAM Y  FOR I = 1 1 800
 
Note:
    Dataplot implements average shifted histograms using
    the algorithms BIN1 and ASH1 given on pages 117-118 of the
    Scott book.

Note:
    The average shifted histogram can be adapted to higher
    dimensional data.  It is this multivariate case where
    the computational simplicity (relative to the kernel
    density plot) is particularly attractive.  At this time,
    we have not implemented the multivariate case.  We do
    plan to implement it in a future release.

Note:
    The AVERAGE SHIFTED HISTOGRAM command generates an estimate
    of the underlying density function.  You can convert this
    to an estimate of the cumulative distribution function by
    integrating the density estimate.  The following shows an
    example of doing this in Dataplot.

       LET Y = NORMAL RANDOM NUMBERS FOR I = 1 1 1000
       AVERAGE SHIFTED HISTOGRAM Y
       LET YPDF = YPLOT
       LET XPDF = XPLOT
       LET YCDF = CUMULATIVE INTEGRAL YPDF XPDF
       TITLE ESTIMATE OF UNDERLYING CUMULATIVE DISTRIBUTION
       PLOT YCDF  XPDF

    You can also obtain an estimate of the percent point function
    (inverse cdf) with the following additional commands:

       LET YPPF = XCDF
       LET XPPF = YCDF

Default:
    None
 
Synonyms:
    ASH is a synonym for the AVERAGE SHIFTED HISTOGRAM command.

Related Commands:
    KERNEL DENSITY PLOT    = Generates a kernel density plot.
    HISTOGRAM              = Generates a histogram.
    FREQUENCY PLOT         = Generates a frequency plot.
    CLASS WIDTH            = Set the class width for a histogram.
    HISTOGRAM CLASS WIDTH  = Set the default class width algorithm
                             for a histogram.
 
Reference:
    David Scott (1992), "Multivariate Density Estimation", John Wiley,
   (chapter 5 in particular).
 
    B. W. Silverman (1986), "Density Estimation for Statistics and Data
    Analysis", Chapman & Hall.

Applications:
    Density Estimation
 
Implementation Date:
    2004/09
 
Program:
    LET Y = NORMAL RANDOM NUMBERS FOR I = 1 1 1000
    TITLE OFFSET 2
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    MULTIPLOT SCALE FACTOR 2
    MULTIPLOT 2 2
    LET M = 1
    TITLE ASH (M=1)
    AVERAGE SHIFTED HISTOGRAM Y
    LET M = 4
    TITLE ASH (M=4)
    AVERAGE SHIFTED HISTOGRAM Y
    LET M = 16
    TITLE ASH (M=16)
    AVERAGE SHIFTED HISTOGRAM Y
    LET M = 32
    TITLE ASH (M=32)
    AVERAGE SHIFTED HISTOGRAM Y
    END OF MULTIPLOT
 
---------------------------------------------------------







































































































-------------------------  *B*  ZZZZZ--------------------
 
-----BACKGROUND COLOR------------------------------------------------
 
BACKGROUND COLOR
 
Name:
    BACKGROUND COLOR
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the color of the background.
 
Description:
    The background is "painted" whenever a subsequent screen erasure
    takes place.  For 2-dimensional graphics (e.g., PLOT, HISTOGRAM,
    BOX PLOT, etc.), the background is the region inside the frame
    lines (while the region outside the frame lines is the "margin").
    For 3-dimensional graphics (3D-PLOT), the background region is the
    entire screen.  For diagrammatic graphics (e.g., TEXT, ARC, BOX,
    CIRCLE, etc..), the background region is also the entire screen.
 
    Dataplot provides two methods for specifying colors.

        1. Colors can be defined by name (or by the corresponding index).
           Dataplot adopted it's named colors from the X11 project.
           Currently, 162 named colors and 100 levels of grayscale are
           supported.  Grayscale can be specified with either G0, G1, ...,
           G100 (or -1, -2, ..., -100).  Many older devices support only a
           limited number of colors.  For these devices, unsupported colors
           will be mapped to one of the available colors.  To specify a
           named color, see Syntax 1.

        2. Most modern graphics devices support full RGB (RedBlueGreen)
           color.  You can alternatively specify RGB colors by entering
           three integer values to represent the Red, Green and Blue
           components, respectively.  These values should be in the range
           0 to 255.

    When setting the background color, Dataplot first checks if the device
    supports RGB colors. If not, the named color will be used.  If the
    device does support RGB color, Dataplot will check if an RGB color
    has been specified.  If yes, then that RGB color is used.  If not,
    the named color will be used.

    To see the list of supported named colors (with the associated index
    number), see

    https://www.itl.nist.gov/div898/software/dataplot/refman1/ch11/homepage.htm

Syntax 1:
    BACKGROUND COLOR  <color>
    where <color> is the desired background color.
 
Syntax 2:
    BACKGROUND RGB COLOR  <ired>  <igreen>  <iblue>
    where <ired> specifies the red component of the background color;
          <igreen> specifies the green component of the background color;
    and   <iblue> specifies the blue component of the background color.

    The components should be integer values in the range 0 - 255.  To turn
    off the RGB color, set the components to -1 (any negative value will
    work and if any of the three components is negative the RGB color will
    be turned off).

Examples:
    BACKGROUND COLOR GREEN
    BACKGROUND COLOR YELLOW
    BACKGROUND COLOR YELLOW
    BACKGROUND RGB COLOR 90 167 102
    BACKGROUND RGB COLOR 110 205 65
 
Note:
    When you enter the BACKGROUND COLOR command, this will also set the
    MARGIN COLOR to the same color.  If you want the MARGIN COLOR to be
    different than the BACKGROUND COLOR, then enter the MARGIN COLOR
    after the BACKGROUND COLOR command.

Note:
    The BACKGROUND COLOR command with no arguments sets the background
    color to default. For a list of available colors, enter HELP COLOR
    TYPES.
 
Note:
    This command is device dependent in that some device may not let
    you set the background color.  In addition, devices vary in the
    colors that they support.

    Postscript and SVG devices set the background color for the first
    plot when the device is initialized, not at the first clear screen
    (e.g., the first PLOT command).  For this reason, if you want to set
    the background color for the first plot, the BACKGROUND COLOR command
    should be entered before the DEVICE 2 POSTSCRIPT or DEVICE 2 SVG
    command.
 
Default:
    The default background color is white.
 
Synonyms:
    None
 
Related Commands:
    PLOT               = Generates a data or function plot.
    MARGIN COLOR       = Sets the color for plot margin.
    CHARACTER COLORS   = Sets the colors for plot characters.
    LINE COLORS        = Sets the colors for plot lines.
    SPIKE COLORS       = Sets the colors for plot spikes.
    BAR FILL COLORS    = Sets the colors for plot bar fills.
    BAR PATTERN COLORS = Sets the colors for plot bar patterns.
    BAR BORDER COLORS  = Sets the colors for plot bar borders.
    TITLE COLOR        = Sets the color for the plot title.
    LABEL COLOR        = Sets the color for plot labels.
    LEGEND COLOR       = Sets the color for plot legends.
    BOX COLOR          = Sets the color for plot boxes.
    ARROW COLOR        = Sets the color for plot arrows.
    SEGMENT COLOR      = Sets the color for plot segments.
    FRAME COLOR        = Sets the color for the plot frame.
    GRID COLOR         = Sets the color for plot grids.
    TIC COLOR          = Sets the color for plot tics.
    TIC LABEL COLOR    = Sets the color for plot tic labels.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    Pre-1987
    2021/03: Support for the BACKGROUND RGB COLOR option
 
Program:
    background color cyan
    background rgb color 110 205 65
    .
    line thickness 0.5
    line color yellow
    title case asis
    title offset 2
    title Sample Plot
    label case asis
    x1label x
    y1label x**2
    .
    plot x**2 for x = 1 1 9

-----BAIRY (LET)--------------------------------
 
BAIRY
 
Name:
    BAIRY (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Airy function of the second kind.
 
Description:
    The Airy function of the second kind is defined as:

        Bi(x) = SQRT(x/32)[I(1/3)(z) + I(-1/3)(z)]         for x >= 0
        Bi(x) = SQRT(-x/32)[J(1/3)ABS(z) + J(-1/3)ABS(z)]  for x > 0

    where I(1/3) and I(-1/3) are the modified Bessel functions of 
    order (1/3) and (-1/3), J(1/3) and J(-1/3) are the Bessel functions
    of the first kind and order (1/3) and (-1/3), and z is
    (2/3)*x**(3/2).  See the documentation for BESSIN and BESSJN for
    a desciption of these Bessel functions.
 
Syntax:
    LET <y2> = BAIRY(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a decimal number, variable or a parameter;
          <y2> is a variable or a parameter (depending on what
               <y1> is) where the computed Airy value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BAIRY(-2)
    LET A = BAIRY(A1)
    LET X2 = BAIRY(0.2)
    LET X2 = BAIRY(X1-4)
 
Note:
    DATAPLOT uses the function BI from the SLATEC Common Mathematical
    Library to compute this function.  SLATEC is a large set of high
    quality, portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal laboratories.

Note:
    The derivative of the Airy function of the second kind is:

        Bi'(x) = x*[(2/SQRT(3))*I(2/3)(z) + (1/PI)*K(2/3)(z)]   x >= 0
        Bi'(x) = -x*[(1/SQRT(3))*J(2/3)(z) - Y(2/3)(z)]         x < 0

    where J and Y are the Bessel functions of the first and second kind
    respectively and z is (2/3)*(-x)**(3/2).

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    AIRY    = Compute the Airy function.
    BESSJN  = Compute the Bessel function of the first kind (fractional
              orders allowed).
    BESSYN  = Compute the Bessel function of the second kind
              (fractional orders allowed).
    BESSIN  = Compute the modified Bessel function (fractional orders
              allowed).
    BESSKN  = Compute the modified Bessel function of the third kind
              (fractional orders allowed).
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 10).
 
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", 2nd Edition, Press, Flannery, Teukolsky, and
    Vetterling.  Cambridge University Press, 1992 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE AUTOMATIC
    PLOT BAIRY(X) FOR X = -5 .1 5
 
-----BAR-------------------------------------------------------
 
BAR
 
Name:
    BAR
 
Type:
    Plot Control Command
 
Purpose:
    Specifies if a bar will be drawn at the plot points of each trace
    on subsequent plots.
 
Description:
    Bar charts are commonly used in business and presentation graphics.
    The following types of bars are commonly produced:
      1) Standard bar charts (a bar is drawn from the data point to
         the X axis);
      2) Grouped bar charts (bars are drawn for 2 or more groups of
         data);
      3) Stacked (or divided) bar charts (the bar is divided into
         several intervals).
    Standard and grouped bar charts are straightforward in DATAPLOT.
    Stacked bars are more difficult, but are possible for small and
    moderate size data sets.
 
    DATAPLOT provides commands to control the various attributes of the
    bars (see the RELATED COMMANDS section).
 
    Many analysts prefer that bar charts be drawn vertically rather
    than horizontally.  This is also straightforward (see the BAR
    DIRECTION and the HORIZONTAL SWITCH commands).
 
Syntax:
    BAR  <ON/OFF>  <ON/OFF>  <ON/OFF>  etc.
    where ON specifies that the trace is to be drawn with a bar and
    OFF specifies that it is not.  Up to 100 bar switches can be
    specified.
 
Examples:
    BAR ON OFF ON OFF
    BAR OFF OFF ON
    BAR ON ALL
    BAR ALL ON
    BAR
 
Note:
    The BAR command with no arguments sets the bar type to blank for
    all traces.  The BAR command with the word ALL before or after the
    specified type assigns that bar type to all traces; thus BAR ON ALL
    or BAR ALL ON plots bars for all traces.
 
Note:
    Although DATAPLOT has a BAR PLOT command, the recommended method
    for generating bar charts is to use the BAR switch with the
    standard PLOT command.
 
Note:
    It is common with bar charts to want to use alphabetic labels.  The
    TIC LABEL FORMAT, TIC LABEL CONTENT, and TIC LABEL OFFSET commands
    make this fairly straightforward.
 
Note:
    The BAR, SPIKE, CHARCTER, and LINE commands all work independently
    of each other.  That is, a plot point can be a line, a character,
    a spike, a bar, or any combination of the above.
 
Note:
    An alternative to bar charts recommended by Bill Cleveland in
    "Elements of Graphing Data" is the dot chart.  These are also
    relatively straightforward to generate in DATAPLOT (use the SPIKE
    and CHARACTER commands rather than the BAR command).
 
Default:
    All OFF
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    CHARACTERS          = Sets the character types for plot points.
    LINES               = Sets the line types for plot points.
    SPIKES              = Sets on/off switches for plot spikes.
    BAR BASE            = Sets the base locations for bars on plots
    BAR FILL            = Sets the on/off switches for plot bar fills.
    BAR FILL COLOR      = Sets the colors of bar fills.
    BAR DIMENSION       = Sets the bar dimensions to 2d or 3d.
    BAR DIRECTION       = Sets the bar directions (H/V).
    BAR PATTERN         = Sets the types for bar fill patterns.
    BAR PATTERN COLOR   = Sets the colors for bar fill patterns.
    BAR PATTERN LINE    = Sets the line types for bar fill patterns.
    BAR PATTERN SPACING = Sets the line spacings for bar fill patterns.
    BAR PATTERN THICK   = Sets line thicknesses for bar fill patterns.
    BAR BORDER COLOR    = Sets the colors for bar border lines.
    BAR BORDER LINE     = Sets the types for bar border lines.
    BAR BORDER THICKNESS= Sets line thicknesses for bar border lines.
    BAR WIDTH           = Sets the widths for plot bars.
 
Reference:
    "Elements of Graphing Data" by William S. Cleveland, Wadsworth
    Advanced Books and Software, 1985.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    XX
 
Program:
    LET X = DATA 81 82 83 84 85
    LET Y = DATA 2 5 9 15 28
    .
    X1TIC MARK LABEL CONTENT ALPHA
    XLIMITS 81 85
    XTIC OFFSET 1 1
    X1TIC LABEL CONTENT 1981 1982 1983 1984 1985
    X1TIC LABEL FORMAT ALPHA
    X1LABEL YEAR
    MINOR X1TIC MARK NUMBER 0
    Y1LABEL SALES (IN MILLIONS OF DOLLARS)
    YLIMITS 0 30
    MAJOR YTIC MARK NUMBER 4
    MINOR YTIC MARK NUMBER 1
    .
    TITLE BAR CHART WITH NO OPTIONS
    LINE BLANK ALL
    BAR ON ALL
    PLOT Y X
 
-----BAR BASE-------------------------------------------------------
 
BAR BASE
 
Name:
    BAR BASE
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the base location for bars on subsequent plots.
 
Description:
    Bars are drawn from the base numbers to the specified Y coordinate.
    Note that bar bases are specified by trace, so if you want to give
    each Y value a distinct base (as you might in creating a divided
    bar chart), create a tag variable that defines each Y value as a
    distinct trace.  Although this is somewhat cumbersome, it works
    reasonably well as long as there are not too many data points.
 
    The more typical use of this command is to define a non-zero base.
 
Syntax:
    BAR BASES  <number>  <number>  <number>  etc.
    where <number> is a decimal number or parameter that specifies the
    desired base.  Up to 100 bar bases can be specified.
 
Examples:
    BAR BASES 0. 0. 10.
    BAR BASES 20. 20. 20.
    BAR BASES 0. ALL
    BAR BASES ALL 0.
    BAR BASES
 
Note:
    The BAR BASE command with no arguments sets the bar base to 0. for
    all traces.  The BAR BASE command with the word ALL before or after
    the specified base assigns that bar base to all traces; thus BAR
    BASE 0. ALL or BAR BASE ALL 0. uses a base of 0. for all traces.
 
Note:
    The BAR, SPIKE, CHARACTER, and LINE switch all work independently
    of each other.  That is, a plot point can be a line, a character, a
    spike or a bar or any combination of the above.
 
Default:
    All 0.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    CHARACTERS          = Sets the character types for plot points.
    LINES               = Sets the line types for plot points.
    SPIKES              = Sets on/off switches for plot spikes.
    BAR                 = Sets on/off switches for plot bars.
    BAR BASE            = Sets the base locations for bars on plots
    BAR FILL            = Sets the on/off switches for plot bar fills.
    BAR FILL COLOR      = Sets the colors of bar fills.
    BAR DIMENSION       = Sets the bar dimensions to 2d or 3d.
    BAR DIRECTION       = Sets the bar directions (H/V).
    BAR PATTERN         = Sets the types for bar fill patterns.
    BAR PATTERN COLOR   = Sets the colors for bar fill patterns.
    BAR PATTERN LINE    = Sets the line types for bar fill patterns.
    BAR PATTERN SPACING = Sets the line spacings for bar fill patterns.
    BAR PATTERN THICK   = Sets line thicknesses for bar fill patterns.
    BAR BORDER COLOR    = Sets the colors for bar border lines.
    BAR BORDER LINE     = Sets the types for bar border lines.
    BAR BORDER THICKNESS= Sets line thicknesses for bar border lines.
    BAR WIDTH           = Sets the widths for plot bars.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    XX
 
Program:
    LET CARTER = DATA 66 30 11 43 44 41 35 82 54 36
    LET REAGAN = DATA 26 54 84 47 51 51 52 14 36 55
    LET X = DATA 1 2 3 5 6 7 8 10 11 12
    LET X1 = X - 0.1
    LET X2 = X + 0.1
    .
    XLIMITS 1 12
    XTIC OFFSET 1 1
    MAJOR XTIC MARK NUMBER 12
    MINOR XTIC MARK NUMBER 0
    Y1LABEL PERCENT
    YLIMITS 0 100
    MAJOR YTIC MARK NUMBER 11
    MINOR YTIC MARK NUMBER 1
    .
    LINE BLANK BLANK SOLID
    BAR ON ON OFF
    BAR BASE 50 ALL
    BAR WIDTH 0.2 ALL
    BAR FILL ON ON OFF
    BAR FILL COLOR G25 G75
    TITLE BAR CHART WITH BASE AT 50%
    .
    LET ZX = DATA 1 12
    LET ZY = DATA 50 50
    PLOT CARTER X1 AND
    PLOT REAGAN X2 AND
    PLOT ZY ZX
 
-----BAR BORDER COLOR--------------------------------------------------
 
BAR BORDER COLOR
 
Name:
    BAR BORDER COLOR
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the border color for bars on subsequent plots.
 
Description:
    Dataplot defines the points on a plot by "traces".  A trace is a set
    of points that are drawn with the same attributes.  For example,

        PLOT Y1 X1 AND
        PLOT Y2 X2

    has two traces.  The first is the points defined by Y1 and X1 and the
    second is the points defined by Y2 and X2.  Attributes can be set for
    up to 100 traces.

    Dataplot provides two methods for specifying colors.

        1. Colors can be defined by name (or by the corresponding index).
           Dataplot adopted it's named colors from the X11 project.
           Currently, 162 named colors and 100 levels of grayscale are
           supported.  Grayscale can be specified with either G0, G1, ...,
           G100 (or -1, -2, ..., -100).  Many older devices support only a
           limited number of colors.  For these devices, unsupported colors
           will be mapped to one of the available colors.  To specify a
           named color, see Syntax 1.

        2. Most modern graphics devices support full RGB (RedBlueGreen)
           color.  You can alternatively specify RGB colors by entering
           three integer values to represent the Red, Green and Blue
           components, respectively.  These values should be in the range
           0 to 255.

    When setting the bar border color, Dataplot first checks if the device
    supports RGB colors. If not, the named color will be used.  If the
    device does support RGB color, Dataplot will check if an RGB color
    has been specified.  If yes, then that RGB color is used.  If not,
    the named color will be used.

    To see the list of supported named colors (with the associated index
    number), see

    https://www.itl.nist.gov/div898/software/dataplot/refman1/ch11/homepage.htm

Syntax 1:
    BAR BORDER COLORS <color 1> <color 2> ... <color n>
    where <color 1>, ..., <color n> specify the desired bar border colors.

    Up to 100 such bar border colors may be specified.

Syntax 2:
    BAR BORDER RGB COLORS <red-1> <green-1> <blue-1> ...
                          <red-n> <green-n> <red-n>
    where <red-1>, <green-1>, <blue-1>, ..., <red-n>, <green-n>, <blue-n>
    is a list of integer values that specify the desired RGB bar border
    colors.

    Up to 100 such triplets of color values can be specified.

    To turn off the RGB color, set the values to -1 (any negative value
    will work).  Values greater than 255 will be set to 255.
 
Examples:
    BAR BORDER COLOR BLACK RED BLUE
    BAR BORDER COLOR GREEN GREEN GREEN
    BAR BORDER COLOR BLACK ALL
    BAR BORDER COLOR ALL BLACK
    BAR BORDER COLOR
    BAR BORDER RGB COLOR 220 109 88 240 220 160
    BAR BORDER RGB COLOR 220 109 88 ALL
 
Note:
    The BAR BORDER COLOR command with no arguments sets the bar border
    color to default for all traces.  The BAR BORDER COLOR command with
    the word ALL before or after the specified color assigns that bar
    border color to all traces; thus BAR BORDER COLOR BLACK ALL or BAR
    BORDER COLOR ALL BLACK plots bar borders as black for all traces.
 
Note:
    The BAR, SPIKE, CHARACTER, and LINE switch all work independently
    of each other.  That is, a plot point can be a line, a character, a
    spike or a bar or any combination of the above.
 
Default:
    All bar borders are set to black and RGB colors are off
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    CHARACTERS          = Sets the character types for plot points.
    LINES               = Sets the line types for plot points.
    SPIKES              = Sets on/off switches for plot spikes.
    BAR                 = Sets on/off switches for plot bars.
    BAR BORDER LINE     = Sets the types for bar border lines.
    BAR BORDER THICK    = Sets line thicknesses for bar border lines.
    BAR BASE            = Sets the base locations for bars on plots
    BAR FILL            = Sets the on/off switches for plot bar fills.
    BAR FILL COLOR      = Sets the colors of bar fills.
    BAR DIMENSION       = Sets the bar dimensions to 2d or 3d.
    BAR DIRECTION       = Sets the bar directions (H/V).
    BAR PATTERN         = Sets the types for bar fill patterns.
    BAR PATTERN COLOR   = Sets the colors for bar fill patterns.
    BAR PATTERN LINE    = Sets the line types for bar fill patterns.
    BAR PATTERN SPACING = Sets the line spacings for bar fill patterns.
    BAR PATTERN THICK   = Sets line thicknesses for bar fill patterns.
    BAR WIDTH           = Sets the widths for plot bars.
    LINE COLOR          = Sets the color for plot lines.
    CHARACTER COLOR     = Sets the color for plot characters.
    SPIKE COLOR         = Sets the color for plot spikes.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    Pre-1987
    2020/11: Support for RGB color
 
Program:
    LET CARTER = DATA 66 30 11 43 44 41 35 82 54 36
    LET REAGAN = DATA 26 54 84 47 51 51 52 14 36 55
    LET X = DATA 1 2 3 5 6 7 8 10 11 12
    LET X1 = X - 0.22
    LET X2 = X + 0.22
    .
    XLIMITS 1 12
    XTIC OFFSET 1 1
    MAJOR XTIC MARK NUMBER 12
    MINOR XTIC MARK NUMBER 0
    Y1LABEL PERCENT
    YLIMITS 0 100
    MAJOR YTIC MARK NUMBER 11
    MINOR YTIC MARK NUMBER 1
    .
    LINE BLANK BLANK
    BAR ON ON
    BAR WIDTH 0.2 ALL
    BAR BORDER THICKNESS 0.3 ALL
    .
    BAR BORDER COLOR G20 G80
    TITLE DEMONSTRATE BAR BORDER GREYSCALE COLOR
    PLOT CARTER X1 AND
    PLOT REAGAN X2
    .
    BAR BORDER COLOR RED BLUE
    TITLE DEMONSTRATE BAR BORDER COLOR
    PLOT CARTER X1 AND
    PLOT REAGAN X2
    .
    BAR BORDER COLOR 220 109 88 240 220 160
    TITLE DEMONSTRATE BAR BORDER RGB COLOR
    PLOT CARTER X1 AND
    PLOT REAGAN X2
 
-----BAR BORDER LINE---------------------------------------------------
 
BAR BORDER LINE
 
Name:
    BAR BORDER LINES
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the line type used to draw the border of bars on
    subsequent plots.
 
Description:
    Bar borders are specified by trace.  All bars belonging to the same
    trace will have the same border line type.
 
Syntax:
    BAR BORDER LINE  <type>  <type>  <type>  etc.
    where <type> specifies the desired line type.  Up to 100 bar border
    line types can be specified.  Enter HELP LINE TYPES for a list of
    available line types.
 
Examples:
    BAR BORDER LINE SOLID DASH DOTTED
    BAR BORDER LINE SOLID DASH
    BAR BORDER LINE SOLID ALL
    BAR BORDER LINE ALL BLANK
    BAR BORDER LINE
 
Note:
    The BAR BORDER LINE command with no arguments sets the bar border
    line type to solid for all traces.  The BAR BORDER LINE command
    with the word ALL before or after the specified line type assigns
    that bar border line type to all traces; thus BAR BORDER LINE SOLID
    ALL or BAR BORDER LINE ALL SOLID plots all bar border lines as
    solid.
 
Note:
    The BAR, SPIKE, CHARACTER, and LINE switch all work independently
    of each other.  That is, a plot point can be a line, a character, a
    spike or a bar or any combination of the above.
 
Default:
    All bar borders are drawn with solid lines.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    CHARACTERS          = Sets the character types for plot points.
    LINES               = Sets the line types for plot points.
    SPIKES              = Sets on/off switches for plot spikes.
    BAR                 = Sets on/off switches for plot bars.
    BAR BASE            = Sets the base locations for bars on plots
    BAR FILL            = Sets the on/off switches for plot bar fills.
    BAR FILL COLOR      = Sets the colors of bar fills.
    BAR DIMENSION       = Sets the bar dimensions to 2d or 3d.
    BAR DIRECTION       = Sets the bar directions (H/V).
    BAR PATTERN         = Sets the types for bar fill patterns.
    BAR PATTERN COLOR   = Sets the colors for bar fill patterns.
    BAR PATTERN LINE    = Sets the line types for bar fill patterns.
    BAR PATTERN SPACING = Sets the line spacings for bar fill patterns.
    BAR PATTERN THICK   = Sets line thicknesses for bar fill patterns.
    BAR BORDER COLOR    = Sets the colors for bar border lines.
    BAR BORDER THICKNESS= Sets line thicknesses for bar border lines.
    BAR WIDTH           = Sets the widths for plot bars.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    XX
 
Program:
    LET CARTER = DATA 66 30 11 43 44 41 35 82 54 36
    LET REAGAN = DATA 26 54 84 47 51 51 52 14 36 55
    LET X = DATA 1 2 3 5 6 7 8 10 11 12
    LET X1 = X - 0.22; LET X2 = X + 0.22
    .
    XLIMITS 1 12
    XTIC OFFSET 1 1
    MAJOR XTIC MARK NUMBER 12
    MINOR XTIC MARK NUMBER 0
    Y1LABEL PERCENT
    YLIMITS 0 100
    MAJOR YTIC MARK NUMBER 11
    MINOR YTIC MARK NUMBER 1
    .
    LINE BLANK BLANK
    BAR ON ON
    BAR WIDTH 0.2 ALL
    BAR BORDER LINE DASH DOTTED
    TITLE DEMONSTRATE BAR BORDER LINE
    .
    PLOT CARTER X1 AND
    PLOT REAGAN X2
 
-----BAR BORDER THICKNESS----------------------------------------------
 
BAR BORDER THICKNESS
 
Name:
    BAR BORDER THICKNESS
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the thickness of the line used to draw the border for
    bars on subsequent plots.
 
Description:
    Bar borders are specified by trace.  All bars belonging to the
    same trace will have the same border line thickness.
 
Syntax:
    BAR BORDER THICKNESS  <number>  <number>  <number>  etc.
    where <number> is a decimal number or parameter in the range 0 to
    100 that specifies the desired line thickness.  Up to 100 bar
    border thicknesses can be specified.  Typical values are between
    0.1 and 0.3.
 
Examples:
    BAR BORDER THICKNESS 0.1 0.2 0.1 0.2
    BAR BORDER THICKNESS 0.2 0.2 0.1
    BAR BORDER THICKNESS 0.1 ALL
    BAR BORDER THICKNESS ALL 0.1
    BAR BORDER THICKNESS
 
Note:
    The BAR BORDER THICKNESS command with no arguments sets the bar
    border thickness to 0.1 for all traces.  The BAR BORDER THICKNESS
    command with the word ALL before or after the specified thickness
    assigns that bar border line thickness to all bars; thus BAR BORDER
    THICKNESS 0.1 ALL or BAR BORDER THICKNESS ALL 0.1 plots all bar
    borders with a 0.1 line thickness.
 
Note:
    The BAR, SPIKE, CHARACTER, and LINE switch all work independently
    of each other.  That is, a plot point can be a line, a character, a
    spike or a bar or any combination of the above.
 
Default:
    All bar borders are drawn with a line thickness of 0.1.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    CHARACTERS          = Sets the character types for plot points.
    LINES               = Sets the line types for plot points.
    SPIKES              = Sets on/off switches for plot spikes.
    BAR                 = Sets on/off switches for plot bars.
    BAR BASE            = Sets the base locations for bars on plots
    BAR FILL            = Sets the on/off switches for plot bar fills.
    BAR FILL COLOR      = Sets the colors of bar fills.
    BAR DIMENSION       = Sets the bar dimensions to 2d or 3d.
    BAR DIRECTION       = Sets the bar directions (H/V).
    BAR PATTERN         = Sets the types for bar fill patterns.
    BAR PATTERN COLOR   = Sets the colors for bar fill patterns.
    BAR PATTERN LINE    = Sets the line types for bar fill patterns.
    BAR PATTERN SPACING = Sets the line spacings for bar fill patterns.
    BAR PATTERN THICK   = Sets line thicknesses for bar fill patterns.
    BAR BORDER COLOR    = Sets the colors for bar border lines.
    BAR BORDER LINE     = Sets the types for bar border lines.
    BAR WIDTH           = Sets the widths for plot bars.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    XX
 
Program:
    LET CARTER = DATA 66 30 11 43 44 41 35 82 54 36
    LET REAGAN = DATA 26 54 84 47 51 51 52 14 36 55
    LET X = DATA 1 2 3 5 6 7 8 10 11 12
    LET X1 = X - 0.22; LET X2 = X + 0.22
    .
    XLIMITS 1 12
    XTIC OFFSET 1 1
    MAJOR XTIC MARK NUMBER 12
    MINOR XTIC MARK NUMBER 0
    Y1LABEL PERCENT
    YLIMITS 0 100
    MAJOR YTIC MARK NUMBER 11
    MINOR YTIC MARK NUMBER 1
    .
    LINE BLANK BLANK
    BAR ON ON
    BAR WIDTH 0.2 ALL
    BAR BORDER THICKNESS 0.1 0.5
    TITLE DEMONSTRATE BAR BORDER THICKNESS
    .
    PLOT CARTER X1 AND
    PLOT REAGAN X2
 
-----BAR DIMENSION-----------------------------------------------------
 
BAR DIMENSION
 
Name:
    BAR DIMENSION
 
Type:
    Plot Control Command
 
Purpose:
    Specifies whether a bar is drawn as a 2d or a 3d bar on subsequent
    plots.
 
Description:
    The 3d effect is created by drawing one rectangle at the top of the
    bar and another rectangle to the right side of the bar.
 
    Bar dimensions are specified by trace.  All bars belonging to the
    same trace will have the same bar dimension.
 
Syntax:
    BAR DIMENSIONS  <dimen>  <dimen>  <dimen>  etc.
    where <dimen> is either 2 (for 2d bars) or 3 (for 3d bars).  Up to
    100 bar dimensions can be specified.
 
Examples:
    BAR DIMENSIONS 2D 2D 3D
    BAR DIMENSIONS 3D 3D
    BAR DIMENSIONS 3D ALL
    BAR DIMENSIONS ALL 3D
    BAR DIMENSIONS
 
Note:
    The BAR FILL and BAR PATTERN commands control whether or not the
    3d effect is filled.  Enter something like the following to fill
    the 3d effect:
        BAR 3D
        BAR FILL ON
        BAR PATTERN ONTS
    The following patterns can be used:
        ONTS  = fill the top and side 3d effects
        ONST  = fill the top and side 3d effects
        ONF   = fill the interior of the bar
        ONS   = fill the side 3d effect
        ONT   = fill the top 3d effect
        ONFS  = fill the interior of the bar and the side 3d effect
        ONSF  = fill the interior of the bar and the side 3d effect
        ONFT  = fill the interior of the bar and the top 3d effect
        ONTF  = fill the interior of the bar and the top 3d effect
        ON    = fill the interior of the bar and the top and side 3d
                effects
        OFF   = do not fill any part of the bar
 
Note:
    The BAR DIMENSION command with no arguments sets the bar type to 2d
    for all bars.  The BAR DIMENSION command with the word ALL before
    or after the specified dimension assigns that bar dimension to all
    traces; thus BAR DIMENSION 3D ALL or BAR DIMENSION ALL 3D plots all
    bars in 3d.
 
Note:
    The BAR, SPIKE, CHARACTER, and LINE switch all work independently
    of each other.  That is, a plot point can be a line, a character, a
    spike or a bar or any combination of the above.
 
Default:
    All bars are drawn as 2d bars.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    CHARACTERS          = Sets the character types for plot points.
    LINES               = Sets the line types for plot points.
    SPIKES              = Sets on/off switches for plot spikes.
    BAR                 = Sets on/off switches for plot bars.
    BAR BASE            = Sets the base locations for bars on plots
    BAR FILL            = Sets the on/off switches for plot bar fills.
    BAR FILL COLOR      = Sets the colors of bar fills.
    BAR DIMENSION       = Sets the bar dimensions to 2d or 3d.
    BAR DIRECTION       = Sets the bar directions (H/V).
    BAR PATTERN         = Sets the types for bar fill patterns.
    BAR PATTERN COLOR   = Sets the colors for bar fill patterns.
    BAR PATTERN LINE    = Sets the line types for bar fill patterns.
    BAR PATTERN SPACING = Sets the line spacings for bar fill patterns.
    BAR PATTERN THICK   = Sets line thicknesses for bar fill patterns.
    BAR BORDER COLOR    = Sets the colors for bar border lines.
    BAR BORDER LINE     = Sets the types for bar border lines.
    BAR BORDER THICKNESS= Sets line thicknesses for bar border lines.
    BAR WIDTH           = Sets the widths for plot bars.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    XX
 
Program:
    LET CARTER = DATA 66 30 11 43 44 41 35 82 54 36
    LET X = DATA 1 2 3 5 6 7 8 10 11 12
    .
    XLIMITS 1 12
    XTIC OFFSET 1 1
    MAJOR XTIC MARK NUMBER 12
    Y1LABEL PERCENT
    YLIMITS 0 100
    MAJOR YTIC MARK NUMBER 11
    MINOR YTIC MARK NUMBER 1
    .
    LINE BLANK
    BAR ON
    BAR WIDTH 0.5
    BAR DIMENSION 3
    BAR FILL ONTS
    TITLE DEMONSTRATE 3D EFFECT
    .
    PLOT CARTER X
 
-----BAR DIRECTION-----------------------------------------------------
 
BAR DIRECTION
 
Name:
    BAR DIRECTION
 
Type:
    Plot Control Command
 
Purpose:
    Specifies if a bar will be drawn horizontally or vertically on
    subsequent plots.
 
Description:
    Vertical bars are drawn from the x-axis to the plot point while
    horizontal bars are drawn from the y-axis to the plot point.
 
    Bars are specified by trace.  All bars belonging to the same trace
    will have the same direction.  Typically, all bars will have the
    same direction.
 
Syntax:
    BAR DIRECTIONS  <H/V>  <H/V>  <H/V>  etc.
    where H specifies horizontal bars and V specifies vertical bars.
    Up to 100 bar directions can be specified.
 
Examples:
    BAR DIRECTIONS H H
    BAR DIRECTIONS V V
    BAR DIRECTIONS V ALL
    BAR DIRECTIONS ALL V
    BAR DIRECTIONS
 
Note:
    The BAR DIRECTION command with no arguments sets the bar direction
    to vertical for all bars.  The BAR DIRECTION command with the word
    ALL before or after the specified direction assigns that bar
    direction to all traces; thus BAR DIRECTION H ALL or BAR DIRECTION
    ALL H plots all bars horizontally.
 
Note:
    The BAR, SPIKE, CHARACTER, and LINE switch all work independently
    of each other.  That is, a plot point can be a line, a character, a
    spike or a bar or any combination of the above.
 
Note:
    Horizontal bars are typically combined with a portrait page
    orientation to generate publication quality bar graphs.
 
Note:
    The HORIZONTAL SWITCH command can also be used to generate
    horizontal bars.  This command is more general in that all plot
    elements are drawn horizontally (BAR DIRECTION only does the bars).
    It also exchanges the x and y data values before plotting (the BAR
    DIRECTION command does not do this).
 
Default:
    All bars are drawn vertically (i.e., V).
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    CHARACTERS          = Sets the character types for plot points.
    LINES               = Sets the line types for plot points.
    SPIKES              = Sets on/off switches for plot spikes.
    BAR                 = Sets on/off switches for plot bars.
    BAR BASE            = Sets the base locations for bars on plots
    BAR FILL            = Sets the on/off switches for plot bar fills.
    BAR FILL COLOR      = Sets the colors of bar fills.
    BAR DIMENSION       = Sets the bar dimensions to 2d or 3d.
    BAR PATTERN         = Sets the types for bar fill patterns.
    BAR PATTERN COLOR   = Sets the colors for bar fill patterns.
    BAR PATTERN LINE    = Sets the line types for bar fill patterns.
    BAR PATTERN SPACING = Sets the line spacings for bar fill patterns.
    BAR PATTERN THICK   = Sets line thicknesses for bar fill patterns.
    BAR BORDER COLOR    = Sets the colors for bar border lines.
    BAR BORDER LINE     = Sets the types for bar border lines.
    BAR BORDER THICKNESS= Sets line thicknesses for bar border lines.
    BAR WIDTH           = Sets the widths for plot bars.
    HORIZONTAL SWITCH   = Specifies whether plots are drawn
                          horizontally or vertically.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    XX
 
Program:
    LET CARTER = DATA 66 30 11 43 44 41 35 82 54 36
    LET REAGAN = DATA 26 54 84 47 51 51 52 14 36 55
    LET X = DATA 1 2 3 5 6 7 8 10 11 12; LET X1 = X - 0.1; LET X2 = X + 0.1
    .
    Y1TIC MARK LABEL FORMAT ALPHA; YLIMITS 1 12; YTIC OFFSET 1 1
    Y1TIC LABEL CONTENT DEMOCRATS INDEPENDENTS REPUBLICANS SP() ...
       EAST SOUTH MIDWEST WEST SP() BLACKS HISPANICS WHITES SP()
    MINOR Y1TIC MARK NUMBER 0
    X1LABEL PERCENT
    XLIMITS 0 100; MAJOR XTIC MARK NUMBER 11; MINOR XTIC MARK NUMBER 1
    .
    LINE BLANK BLANK SOLID
    BAR ON ON OFF
    BAR DIRECTION H ALL
    BAR WIDTH 0.2 ALL
    BAR FILL ON ON OFF
    BAR FILL COLOR G25 G75
    TITLE BAR CHART WITH HORIZONTAL DIRECTION
    .
    PLOT X1 CARTER AND
    PLOT X2 REAGAN
 
-----BAR EXPANSION--------------------------------------------------
 
BAR EXPANSION
 
Name:
    BAR EXPANSION
 
Type:
    Plot Control Command
 
Purpose:
    Control the height and width of bars in a block plot command.
 
Syntax:
    BAR EXPANSION <height> <width>
    where <height> is a constant or paramter that specifies distance
    from the minimum and maximum points in the block plot to the
    bottom and top of the enclosing bar and <width> is the width of the
    enclosing bar.
 
Examples:
    BAR EXPANSION 0.5 2.0
    BAR EXPANSION DEFAULT
 
Default:
    The default height is 1.0 and the default width is 1.0.
 
Synonyms:
    None
 
Related Commands:
    BLOCK PLOT     = Generate a block plot.
 
Applications:
    Analysis of Variance
 
Implementation Date:
    92/5
 
Program:
    SERIAL READ Y
    28.4 21.9 36.8 19.2 28.2 26.6 30.4 25.1 25.5 21.5 26.0 21.9 20.2
    14.3 19.9 22.5 23.4 18.5 38.2 12.8 22.0 22.5 30.3 17.7
    END OF DATA
    LET PROC = PATTERN 1 2 FOR I = 1 1 24
    LET PLANT = SEQUENCE 1 12 1 2
    LET SPEED = SEQUENCE 1 6 1 2 FOR I = 1 1 24
    LET SHIFT = SEQUENCE 1 2 1 3 FOR I = 1 1 24
    CHARACTERS 1 2
    LINE BLANK BLANK
    BLOCK PLOT Y PLANT SPEED SHIFT PROC
 
-----BAR FILL-------------------------------------------------------
 
BAR FILL
 
Name:
    BAR FILL
 
Type:
    Plot Control Command
 
Purpose:
    Specifies if a bar is drawn with a fill pattern on subsequent
    plots.
 
Description:
    DATAPLOT can fill bars with either a solid pattern or one of
    several hatching patterns.  Hatch patterns are specified with the
    BAR PATTERN command.  If no hatch pattern is specified, solid fills
    are generated.  Enter HELP BAR FILL PATTERN for a list of available
    hatch patterns.
 
    Bar fills are specified by trace.  All bars belonging to the same
    trace will have the same fill pattern.
 
Syntax:
    BAR FILL  <ON/OFF>  <ON/OFF>  <ON/OFF>  etc.
    where ON specifies that the bars will be filled and OFF specifies
    that they will not be filled.  Up to 100 bar fill switches can be
    specified.
 
Examples:
    BAR FILL ON OFF ON OFF
    BAR FILL OFF OFF ON
    BAR FILL ON ALL
    BAR FILL ALL ON
    BAR FILL
 
Note:
    Enter HELP BAR DIMENSION for details on how to set fill switches
    for 3d bars.
 
Note:
    The BAR FILL command with no arguments sets the bar fill to blank
    for all traces.  The BAR FILL command with the word ALL before or
    after the specified fill assigns that bar fill to all traces; thus
    BAR FILL ON ALL or BAR FILL ALL ON plots all bars with a fill
    pattern.
 
Note:
    The BAR, SPIKE, CHARACTER, and LINE switch all work independently
    of each other.  That is, a plot point can be a line, a character, a
    spike or a bar or any combination of the above.
 
Default:
    All bars are not filled (i.e., OFF).
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    CHARACTERS          = Sets the character types for plot points.
    LINES               = Sets the line types for plot points.
    SPIKES              = Sets on/off switches for plot spikes.
    BAR                 = Sets on/off switches for plot bars.
    BAR BASE            = Sets the base locations for bars on plots
    BAR FILL COLOR      = Sets the colors of bar fills.
    BAR DIMENSION       = Sets the bar dimensions to 2d or 3d.
    BAR DIRECTION       = Sets the bar directions (H/V).
    BAR PATTERN         = Sets the types for bar fill patterns.
    BAR PATTERN COLOR   = Sets the colors for bar fill patterns.
    BAR PATTERN LINE    = Sets the line types for bar fill patterns.
    BAR PATTERN SPACING = Sets the line spacings for bar fill patterns.
    BAR PATTERN THICK   = Sets line thicknesses for bar fill patterns.
    BAR BORDER COLOR    = Sets the colors for bar border lines.
    BAR BORDER LINE     = Sets the types for bar border lines.
    BAR BORDER THICKNESS= Sets line thicknesses for bar border lines.
    BAR WIDTH           = Sets the widths for plot bars.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    XX
 
Program:
    LET CARTER = DATA 66 30 11 43 44 41 35 82 54 36
    LET REAGAN = DATA 26 54 84 47 51 51 52 14 36 55
    LET X = DATA 1 2 3 5 6 7 8 10 11 12
    LET X1 = X - 0.22
    LET X2 = X + 0.22
    .
    XLIMITS 1 12
    XTIC OFFSET 1 1
    MAJOR XTIC MARK NUMBER 12
    MINOR XTIC MARK NUMBER 0
    Y1LABEL PERCENT
    YLIMITS 0 100
    MAJOR YTIC MARK NUMBER 11
    MINOR YTIC MARK NUMBER 1
    .
    LINE BLANK ALL
    BAR ON ON
    BAR FILL ON ALL
    BAR WIDTH 0.2 ALL
    TITLE DEMONSTRATE BAR FILL
    .
    PLOT CARTER X1 AND
    PLOT REAGAN X
 
-----BAR FILL COLOR----------------------------------------------------
 
BAR FILL COLOR
 
Name:
    BAR FILL COLOR
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the color to use for bar fills on subsequent plots.
 
Description:
    Dataplot defines the points on a plot by "traces".  A trace is a set
    of points that are drawn with the same attributes.  For example,

        PLOT Y1 X1 AND
        PLOT Y2 X2

    has two traces.  The first is the points defined by Y1 and X1 and the
    second is the points defined by Y2 and X2.  Attributes can be set for
    up to 100 traces.

    Dataplot provides two methods for specifying colors.

        1. Colors can be defined by name (or by the corresponding index).
           Dataplot adopted it's named colors from the X11 project.
           Currently, 162 named colors and 100 levels of grayscale are
           supported.  Grayscale can be specified with either G0, G1, ...,
           G100 (or -1, -2, ..., -100).  Many older devices support only a
           limited number of colors.  For these devices, unsupported colors
           will be mapped to one of the available colors.  To specify a
           named color, see Syntax 1.

        2. Most modern graphics devices support full RGB (RedBlueGreen)
           color.  You can alternatively specify RGB colors by entering
           three integer values to represent the Red, Green and Blue
           components, respectively.  These values should be in the range
           0 to 255.

    When setting the bar fill color, Dataplot first checks if the device
    supports RGB colors. If not, the named color will be used.  If the
    device does support RGB color, Dataplot will check if an RGB color
    has been specified.  If yes, then that RGB color is used.  If not,
    the named color will be used.

    To see the list of supported named colors (with the associated index
    number), see

    https://www.itl.nist.gov/div898/software/dataplot/refman1/ch11/homepage.htm

Syntax 1:
    BAR FILL COLOR <color-1> <color-2> ... <color-n>
    where <color-1> ... <color-n> specifies the desired colors.

    Up to 100 bar fill colors can be specified.

Syntax 2:
    BAR FILL COLOR RGB COLORS <red-1> <green-1> <blue-1> ...
                              <red-n> <green-n> <red-n>
    where <red-1>, <green-1>, <blue-1>, ..., <red-n>, <green-n>, <blue-n>
    is a list of integer values that specify the desired RGB bar fill
    colors.

    Up to 100 such triplets of color values can be specified.

    To turn off the RGB color, set the values to -1 (any negative value
    will work).  Values greater than 255 will be set to 255.
 
Examples:
    BAR FILL COLOR RED GREEN BLUE
    BAR FILL COLOR BLACK ALL
    BAR FILL COLOR ALL BLACK
    BAR FILL COLOR
    BAR FILL RGB COLORS 220 109 88 240 220 160
    BAR FILL RGB COLORS 220 109 88 ALL
 
Note:
    The BAR FILL command must be used in order for the bars to be
    filled.  If the bar fill switch is off (the default), this command
    is ignored.
 
Note:
    Dataplot can generate either solid fills or hatch pattern fills.
    This is controlled by the bar pattern command.  If no BAR PATTERN
    command is entered, solid fills are generated.  The BAR FILL
    COLOR command only applies to solid fill bars.  Use the BAR
    PATTERN COLOR command to set the color for hatch pattern fills.
 
Note:
    The BAR FILL COLOR command with no arguments sets the bar fill
    color to default for all bars.  The BAR FILL COLOR command with the
    word ALL before or after the specified color assigns that bar fill
    color to all bars; thus BAR FILL COLOR BLACK ALL or BAR FILL COLOR
    ALL BLACK plots bar fills with black for all bars.
 
Default:
    All bar fills are black and RGB colors are off.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    CHARACTERS          = Sets the character types for plot points.
    LINES               = Sets the line types for plot points.
    SPIKES              = Sets on/off switches for plot spikes.
    BAR                 = Sets on/off switches for plot bars.
    BAR BASE            = Sets the base locations for bars on plots
    BAR FILL            = Sets the on/off switches for plot bar fills.
    BAR DIMENSION       = Sets the bar dimensions to 2d or 3d.
    BAR DIRECTION       = Sets the bar directions (H/V).
    BAR PATTERN         = Sets the types for bar fill patterns.
    BAR PATTERN COLOR   = Sets the colors for bar fill patterns.
    BAR PATTERN LINE    = Sets the line types for bar fill patterns.
    BAR PATTERN SPACING = Sets the line spacings for bar fill patterns.
    BAR PATTERN THICK   = Sets line thicknesses for bar fill patterns.
    BAR BORDER COLOR    = Sets the colors for bar border lines.
    BAR BORDER LINE     = Sets the types for bar border lines.
    BAR BORDER THICKNESS= Sets line thicknesses for bar border lines.
    BAR WIDTH           = Sets the widths for plot bars.
    LINE COLOR          = Sets the colors for plot lines.
    CHARACTER COLOR     = Sets the colors for plot characters.
    SPIKE COLOR         = Sets the colors for plot spikes.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    Pre-1987
    2020/11: Support for RGB colors.
 
Program:
    LET CARTER = DATA 66 30 11 43 44 41 35 82 54 36
    LET REAGAN = DATA 26 54 84 47 51 51 52 14 36 55
    LET ANDERSON = DATA 6 12 4 8 3 6 10 3 7 8
    LET X = DATA 1 2 3 5 6 7 8 10 11 12
    LET X1 = X - 0.22
    LET X2 = X + 0.22
    .
    XLIMITS 1 12
    XTIC OFFSET 1 1
    MAJOR XTIC MARK NUMBER 12
    MINOR XTIC MARK NUMBER 0
    Y1LABEL PERCENT
    YLIMITS 0 100
    MAJOR YTIC MARK NUMBER 11
    MINOR YTIC MARK NUMBER 1
    .
    LINE BLANK ALL
    BAR ON ALL
    BAR FILL ON ALL
    BAR WIDTH 0.2 ALL
    .
    BAR FILL COLOR G10 G50 G90
    TITLE DEMONSTRATE GRAYSCALE BAR FILL COLOR
    PLOT CARTER X1 AND
    PLOT REAGAN X AND
    PLOT ANDERSON X2
    .
    BAR FILL COLOR RED BLUE GREEN
    TITLE DEMONSTRATE BAR FILL COLORS
    PLOT CARTER X1 AND
    PLOT REAGAN X AND
    PLOT ANDERSON X2
    .
    BAR FILL RGB COLOR 175 238 238 220 20 60 127 255 0
    TITLE DEMONSTRATE BAR FILL RGB COLORS
    PLOT CARTER X1 AND
    PLOT REAGAN X AND
    PLOT ANDERSON X2
 
-----BAR PATTERN-------------------------------------------------------
 
BAR PATTERN
 
Name:
    BAR PATTERN
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the type of pattern used to fill bars on subsequent
    plots.
 
Description:
    The following bar fill patterns are available:
        BLANK   - no fill
        SOLID   - solid fill
        HORI    - horizontal lines
        VERT    - vertical lines
        D1      - up diagonals
        D2      - down diagonals
        D1D2    - both up and down diagonals
        VED1    - both vertical lines and up diagonals
        VED2    - both vertical lines and down diagonals
        HOD1    - both horizontal lines and up diagonals
        HOD2    - both vertical lines and down diagonals
        VEDD    - both horizontal and vertical lines, and both up and
                  down diagonals
    In practice, the first 7 are heavily used while the last 5 are
    rarely used.
 
    Bar patterns are specified by trace.  All bars belonging to the
    same trace will have the same bar pattern.
 
Syntax:
    BAR PATTERN  <pattern>  <pattern>  <pattern>  etc.
    where <pattern> specifies the desired fill pattern.  Up to 100 bar
              fill patterns can be specified.
 
Examples:
    BAR PATTERN SOLID VERTICAL HORIZONTAL BLANK
    BAR PATTERN D1 D2 D1D2 HOD1 VED2 VEDD
    BAR PATTERN D1 ALL
    BAR PATTERN ALL D1
    BAR PATTERN
 
Note:
    The BAR FILL command must be used in order for bars to be filled
    with a pattern.  If the bar fill switch is off (the default), this
    command is ignored.
 
Note:
    The BAR PATTERN command with no arguments sets the bar pattern type
    to blank for all traces.  The BAR PATTERN command with the word ALL
    before or after the specified pattern type assigns that bar
    pattern type to all bars; thus BAR PATTERN D1 ALL or BAR PATTERN
    ALL D1 fills all bars with pattern D1.
 
Default:
    All bar patterns are blank.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    CHARACTERS          = Sets the character types for plot points.
    LINES               = Sets the line types for plot points.
    SPIKES              = Sets on/off switches for plot spikes.
    BAR                 = Sets on/off switches for plot bars.
    BAR BASE            = Sets the base locations for bars on plots
    BAR FILL            = Sets the on/off switches for plot bar fills.
    BAR FILL COLOR      = Sets the colors of bar fills.
    BAR DIMENSION       = Sets the bar dimensions to 2d or 3d.
    BAR DIRECTION       = Sets the bar directions (H/V).
    BAR PATTERN COLOR   = Sets the colors for bar fill patterns.
    BAR PATTERN LINE    = Sets the line types for bar fill patterns.
    BAR PATTERN SPACING = Sets the line spacings for bar fill patterns.
    BAR PATTERN THICK   = Sets line thicknesses for bar fill patterns.
    BAR BORDER COLOR    = Sets the colors for bar border lines.
    BAR BORDER LINE     = Sets the types for bar border lines.
    BAR BORDER THICKNESS= Sets line thicknesses for bar border lines.
    BAR WIDTH           = Sets the widths for plot bars.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    XX
 
Program:
    LET CARTER = DATA 66 30 11 43 44 41 35 82 54 36
    LET REAGAN = DATA 26 54 84 47 51 51 52 14 36 55
    LET ANDERSON = DATA 6 12 4 8 3 6 10 3 7 8
    LET X = DATA 1 2 3 5 6 7 8 10 11 12
    LET X1 = X - 0.22
    LET X2 = X + 0.22
    .
    XLIMITS 1 12
    XTIC OFFSET 1 1
    MAJOR XTIC MARK NUMBER 12
    MINOR XTIC MARK NUMBER 0
    Y1LABEL PERCENT
    YLIMITS 0 100
    MAJOR YTIC MARK NUMBER 11
    MINOR YTIC MARK NUMBER 1
    .
    LINE BLANK ALL
    BAR ON ALL
    BAR FILL ON ALL
    BAR WIDTH 0.2 ALL
    BAR PATTERN D1 D1D2 D2
    TITLE DEMONSTRATE BAR PATTERNS
    .
    PLOT CARTER X1 AND
    PLOT REAGAN X AND
    PLOT ANDERSON X2
 
-----BAR PATTERN COLOR------------------------------------------------
 
BAR PATTERN COLOR
 
Name:
    BAR PATTERN COLOR
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the color used for bar patterns on subsequent plots.
 
Description:
    Dataplot supports two methods for filling the interiors of plot bars:

        1) Bars can be solid filled.  The BAR FILL COLOR command is used
           in this case.

        2) Bars can be filled with a cross-hatch pattern.  The BAR
           PATTERN COLOR command is used in this case.

    Dataplot defines the points on a plot by "traces".  A trace is a set
    of points that are drawn with the same attributes.  For example,

        PLOT Y1 X1 AND
        PLOT Y2 X2

    has two traces.  The first is the points defined by Y1 and X1 and the
    second is the points defined by Y2 and X2.  Attributes can be set for
    up to 100 traces.

    Dataplot provides two methods for specifying colors.

        1. Colors can be defined by name (or by the corresponding index).
           Dataplot adopted it's named colors from the X11 project.
           Currently, 162 named colors and 100 levels of grayscale are
           supported.  Grayscale can be specified with either G0, G1, ...,
           G100 (or -1, -2, ..., -100).  Many older devices support only a
           limited number of colors.  For these devices, unsupported colors
           will be mapped to one of the available colors.  To specify a
           named color, see Syntax 1.

        2. Most modern graphics devices support full RGB (RedBlueGreen)
           color.  You can alternatively specify RGB colors by entering
           three integer values to represent the Red, Green and Blue
           components, respectively.  These values should be in the range
           0 to 255.

    When setting the bar pattern color, Dataplot first checks if the
    device supports RGB colors. If not, the named color will be used.  If
    the device does support RGB color, Dataplot will check if an RGB
    color has been specified.  If yes, then that RGB color is used.  If
    not, the named color will be used.

    To see the list of supported named colors (with the associated index
    number), see

    https://www.itl.nist.gov/div898/software/dataplot/refman1/ch11/homepage.htm

Syntax 1:
    BAR PATTERN COLORS  <color 1> <color 2> ... <color n>
    where <color 1>, ..., <color n> specify the desired bar pattern
    colors.

    Up to 100 such bar pattern colors may be specified.

Syntax 2:
    BAR PATTERN RGB COLORS <red-1> <green-1> <blue-1> ...
                    <red-n> <green-n> <red-n>
    where <red-1>, <green-1>, <blue-1>, ..., <red-n>, <green-n>, <blue-n>
    is a list of integer values that specify the desired RGB bar pattern
    colors.

    Up to 100 such triplets of color values can be specified.

    To turn off the RGB color, set the values to -1 (any negative value
    will work).  Values greater than 255 will be set to 255.
 
 
Examples:
    BAR PATTERN COLOR RED BLUE GREEN
    BAR PATTERN COLOR BLACK ALL
    BAR PATTERN COLOR ALL BLACK
    BAR PATTERN COLOR
    BAR PATTERN RGB COLORS 220 109 88 240 220 160
    BAR PATTERN RGB COLORS 220 109 88 ALL
 
Note:
    The BAR FILL command must be used in order for bars to be filled
    with a pattern.  If the bar fill switch is off (the default), this
    command is ignored.  The pattern is specified with the BAR PATTERN
    command.
 
Note:
    The BAR PATTERN COLOR command with no arguments sets the bar
    pattern color to default for all bars.  The BAR PATTERN COLOR
    command with the word ALL before or after the specified color
    assigns that bar pattern color to all bars; thus BAR PATTERN COLOR
    BLACK ALL or BAR PATTERN COLOR ALL BLACK plot all bar fills in
    black.
 
Note:
    The BAR, SPIKE, CHARACTER, and LINE switch all work independently
    of each other.  That is, a plot point can be a line, a character, a
    spike or a bar or any combination of the above.
 
Default:
    All bar pattern colors are set to black and RGB colors are off.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    CHARACTERS          = Sets the character types for plot points.
    LINES               = Sets the line types for plot points.
    SPIKES              = Sets on/off switches for plot spikes.
    BAR                 = Sets on/off switches for plot bars.
    BAR BASE            = Sets the base locations for bars on plots
    BAR FILL            = Sets the on/off switches for plot bar fills.
    BAR DIMENSION       = Sets the bar dimensions to 2d or 3d.
    BAR DIRECTION       = Sets the bar directions (H/V).
    BAR PATTERN         = Sets the types for bar fill patterns.
    BAR PATTERN LINE    = Sets the line types for bar fill patterns.
    BAR PATTERN SPACING = Sets the line spacings for bar fill patterns.
    BAR PATTERN THICK   = Sets line thicknesses for bar fill patterns.
    BAR BORDER COLOR    = Sets the colors for bar border lines.
    BAR BORDER LINE     = Sets the types for bar border lines.
    BAR BORDER THICKNESS= Sets line thicknesses for bar border lines.
    BAR WIDTH           = Sets the widths for plot bars.
    BAR FILL COLOR      = Sets the colors of bar fills.
    LINE COLOR          = Set the color for plot lines.
    CHARACTER COLOR     = Set the color for plot characters.
    SPIKE COLOR         = Set the color for plot spikes.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    Pre-1987
    2020/11: Support for RGB color
 
Program:
    LET CARTER = DATA 66 30 11 43 44 41 35 82 54 36
    LET REAGAN = DATA 26 54 84 47 51 51 52 14 36 55
    LET ANDERSON = DATA 6 12 4 8 3 6 10 3 7 8
    LET X = DATA 1 2 3 5 6 7 8 10 11 12
    LET X1 = X - 0.3
    LET X2 = X + 0.3
    .
    XLIMITS 1 12
    XTIC OFFSET 1 1
    MAJOR XTIC MARK NUMBER 12
    MINOR XTIC MARK NUMBER 0
    Y1LABEL PERCENT
    YLIMITS 0 100
    MAJOR YTIC MARK NUMBER 11
    MINOR YTIC MARK NUMBER 1
    .
    LINE BLANK ALL
    BAR ON ALL
    BAR FILL ON ALL
    BAR WIDTH 0.3 ALL
    BAR PATTERN D1 D1D2 D2
    BAR PATTERN THICK 0.3 ALL
    .
    BAR PATTERN COLOR G10 G50 G90
    TITLE DEMONSTRATE BAR PATTERN GRAYSCALE COLORS
    PLOT CARTER X1 AND
    PLOT REAGAN X AND
    PLOT ANDERSON X2
    .
    BAR PATTERN COLOR RED GREEN BLUE
    TITLE DEMONSTRATE BAR PATTERN COLORS
    PLOT CARTER X1 AND
    PLOT REAGAN X AND
    PLOT ANDERSON X2
    .
    BAR PATTERN RGB COLOR 175 238 238 220 20 60 127 255 0
    TITLE DEMONSTRATE BAR PATTERN RGB COLORS
    PLOT CARTER X1 AND
    PLOT REAGAN X AND
    PLOT ANDERSON X2
 
-----BAR PATTERN LINE--------------------------------------------------
 
BAR PATTERN LINES
 
Name:
    BAR PATTERN LINES
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the line patterns used to do bar fills on subsequent
    plots.  Note that the line type (e.g., solid or dashed) is distinct
    from the pattern type (e.g., solid or horizontal).
 
Description:
    Bar pattern line types are specified by trace.  All bars belonging
    to the same trace will have the same bar pattern line type.
 
Syntax:
    BAR PATTERN LINE  <type>  <type>  <type>  etc.
    where <type> specifies the desired line type.  Up to 100 bar
              pattern line types can be specified.  Enter HELP LINE
              TYPES for a list of available line types.
 
Examples:
    BAR PATTERN LINE SOLID DASH DOT
    BAR PATTERN LINES SOLID ALL
    BAR PATTERN LINES ALL SOLID
    BAR PATTERN LINES
 
Note:
    The BAR PATTERN LINE command with no arguments sets the bar type to
    blank for all traces.  The BAR PATTERN LINE command with the word
    ALL before or after the specified type assigns that pattern line
    type to all traces; thus BAR PATTERN LINE SOLID ALL or BAR PATTERN
    LINE ALL SOLID plots bar patterns with solid lines for all bars.
 
Note:
    The BAR FILL command must be used in order for bars to be filled
    with a pattern.  If the bar fill switch is off (the default), this
    command is ignored.
 
Note:
    The BAR, SPIKE, CHARACTER, and LINE switch all work independently
    of each other.  That is, a plot point can be a line, a character, a
    spike or a bar or any combination of the above.
 
Default:
    All bar patterns are drawn with solid lines.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    CHARACTERS          = Sets the character types for plot points.
    LINES               = Sets the line types for plot points.
    SPIKES              = Sets on/off switches for plot spikes.
    BAR                 = Sets on/off switches for plot bars.
    BAR BASE            = Sets the base locations for bars on plots
    BAR FILL            = Sets the on/off switches for plot bar fills.
    BAR FILL COLOR      = Sets the colors of bar fills.
    BAR DIMENSION       = Sets the bar dimensions to 2d or 3d.
    BAR DIRECTION       = Sets the bar directions (H/V).
    BAR PATTERN         = Sets the types for bar fill patterns.
    BAR PATTERN COLOR   = Sets the colors for bar fill patterns.
    BAR PATTERN SPACING = Sets the line spacings for bar fill patterns.
    BAR PATTERN THICK   = Sets line thicknesses for bar fill patterns.
    BAR BORDER COLOR    = Sets the colors for bar border lines.
    BAR BORDER LINE     = Sets the types for bar border lines.
    BAR BORDER THICKNESS= Sets line thicknesses for bar border lines.
    BAR WIDTH           = Sets the widths for plot bars.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    XX
 
Program:
    LET CARTER = DATA 66 30 11 43 44 41 35 82 54 36
    LET REAGAN = DATA 26 54 84 47 51 51 52 14 36 55
    LET ANDERSON = DATA 6 12 4 8 3 6 10 3 7 8
    LET X = DATA 1 2 3 5 6 7 8 10 11 12
    LET X1 = X - 0.2
    LET X2 = X + 0.2
    .
    XLIMITS 1 12
    XTIC OFFSET 1 1
    MAJOR XTIC MARK NUMBER 12
    MINOR XTIC MARK NUMBER 0
    Y1LABEL PERCENT
    YLIMITS 0 100
    MAJOR YTIC MARK NUMBER 11
    MINOR YTIC MARK NUMBER 1
    .
    LINE BLANK ALL
    BAR ON ALL
    BAR FILL ON ALL
    BAR WIDTH 0.2 ALL
    BAR PATTERN VERTICAL ALL
    BAR PATTERN THICK 0.2 ALL
    BAR PATTERN LINE SOLID DASH DOT
    TITLE DEMONSTRATE BAR PATTERN LINES
    .
    PLOT CARTER X1 AND
    PLOT REAGAN X AND
    PLOT ANDERSON X2
 
-----BAR PATTERN SPACING-----------------------------------------------
 
BAR PATTERN SPACING
 
Name:
    BAR PATTERN SPACING
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the spacing to be used between lines for pattern fills of
    bars on subsequent plots.  The spacing determines the density of
    the bar pattern fill.
 
Description:
    Bar pattern spacings are specified by trace.  All bars belonging to
    the same trace will have the same bar pattern spacing.
 
Syntax:
    BAR PATTERN SPACINGS  <number>  <number>  <number>  etc.
    where <number> is a number or parameter in the decimal range 0 to
              100 that specifies the desired bar pattern spacing.  Up
              to 100 bar pattern spacings can be specified.
 
Examples:
    BAR PATTERN SPACINGS 1.0 0.5 1.0 0.5
    BAR PATTERN SPACINGS 0.5 0.5 1.0
    BAR PATTERN SPACINGS 1.0 ALL
    BAR PATTERN SPACINGS ALL 1.0
    BAR PATTERN SPACINGS
 
Note:
    The BAR FILL command must be used in order for bars to be filled
    with a pattern.  If the bar fill switch is off (the default), this
    command is ignored.
 
Note:
    DATAPLOT can generate either solid fills or hatch pattern fills.
    The BAR PATTERN SPACING command only applies to hatch fills.  The
    BAR PATTERN command is used to specify a hatch fill.
 
Note:
    The BAR PATTERN SPACING command with no arguments sets the bar
    pattern spacing to default for all bars.  The BAR PATTERN SPACING
    command with the word ALL before or after the specified pattern
    spacing assigns that pattern spacing to all bars; thus BAR PATTERN
    SPACING 1.0 ALL or BAR PATTERN SPACING ALL 1.0 uses a pattern
    spacing of 1.0 for all bars on the plot.
 
Note:
    The BAR, SPIKE, CHARACTER, and LINE switch all work independently
    of each other.  That is, a plot point can be a line, a character, a
    spike or a bar or any combination of the above.
 
Default:
    All bar pattern spacings are 1.0.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    CHARACTERS          = Sets the character types for plot points.
    LINES               = Sets the line types for plot points.
    SPIKES              = Sets on/off switches for plot spikes.
    BAR                 = Sets on/off switches for plot bars.
    BAR BASE            = Sets the base locations for bars on plots
    BAR FILL            = Sets the on/off switches for plot bar fills.
    BAR FILL COLOR      = Sets the colors of bar fills.
    BAR DIMENSION       = Sets the bar dimensions to 2d or 3d.
    BAR DIRECTION       = Sets the bar directions (H/V).
    BAR PATTERN         = Sets the types for bar fill patterns.
    BAR PATTERN COLOR   = Sets the colors for bar fill patterns.
    BAR PATTERN LINE    = Sets the line types for bar fill patterns.
    BAR PATTERN THICK   = Sets line thicknesses for bar fill patterns.
    BAR BORDER COLOR    = Sets the colors for bar border lines.
    BAR BORDER LINE     = Sets the types for bar border lines.
    BAR BORDER THICKNESS= Sets line thicknesses for bar border lines.
    BAR WIDTH           = Sets the widths for plot bars.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    XX
 
Program:
    LET CARTER = DATA 66 30 11 43 44 41 35 82 54 36
    LET REAGAN = DATA 26 54 84 47 51 51 52 14 36 55
    LET ANDERSON = DATA 6 12 4 8 3 6 10 3 7 8
    LET X = DATA 1 2 3 5 6 7 8 10 11 12
    LET X1 = X - 0.22
    LET X2 = X + 0.22
    .
    XLIMITS 1 12
    XTIC OFFSET 1 1
    MAJOR XTIC MARK NUMBER 12
    MINOR XTIC MARK NUMBER 0
    Y1LABEL PERCENT
    YLIMITS 0 100
    MAJOR YTIC MARK NUMBER 11
    MINOR YTIC MARK NUMBER 1
    .
    LINE BLANK ALL
    BAR ON ALL
    BAR FILL ON ALL
    BAR WIDTH 0.2 ALL
    BAR PATTERN VERTICAL ALL
    BAR PATTERN SPACING 1 5 3
    TITLE DEMONSTRATE BAR PATTERN SPACING
    .
    PLOT CARTER X1 AND
    PLOT REAGAN X AND
    PLOT ANDERSON X2
 
-----BAR PATTERN THICKNESS---------------------------------------------
 
BAR PATTERN THICKNESS
 
Name:
    BAR PATTERN THICKNESS
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the thickness of lines used to draw bar pattern fills on
    subsequent plots.
 
Description:
    Bar pattern thicknesses are specified by trace.  All bars belonging
    to the same trace will have the same bar pattern thickness.
 
Syntax:
    BAR PATTERN THICKNESSS  <thickness>  <thickness>  <thickness>  etc.
    where <thickness> is a number or parameter in the decimal range 0
              to 100 that specifies the desired bar pattern thickness.
              Up to 100 thicknesses can be specified.
 
Examples:
    BAR PATTERN THICKNESSS 0.1 0.2 0.1 0.2
    BAR PATTERN THICKNESSS 0.2 0.2 0.1
    BAR PATTERN THICKNESSS 0.1 ALL
    BAR PATTERN THICKNESSS ALL 0.1
    BAR PATTERN THICKNESSS
 
Note:
    The BAR FILL command must be used in order for bars to be filled
    with a pattern.  If the bar fill switch is off (the default), this
    command is ignored.
 
Note:
    DATAPLOT can generate either solid fills or hatch pattern fills.
    The BAR PATTERN THICKNESS command only applies to hatch fills.  The
    BAR PATTERN command is used to specify a hatch fill.
 
Note:
    The BAR PATTERN THICKNESS command with no arguments sets the bar
    pattern line thickness to default for all traces.  The BAR PATTERN
    THICKNESS command with the word ALL before or after the specified
    thickness assigns that bar pattern line thickness to all bars; thus
    BAR PATTERN THICKNESS 0.1 ALL or BAR PATTERN THICKNESS ALL 0.1
    plots bar pattern fills with a line thickness of 0.1 for all bars
    on the plot.
 
Note:
    The BAR, SPIKE, CHARACTER, and LINE switch all work independently
    of each other.  That is, a plot point can be a line, a character, a
    spike or a bar or any combination of the above.
 
Default:
    All bar pattern line thicknesses are 0.1.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data/function plot.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    LET CARTER = DATA 66 30 11 43 44 41 35 82 54 36
    LET X = DATA 1 2 3 5 6 7 8 10 11 12
    .
    HORIZONTAL SWITCH ON
    YLIMITS 1 12; YTIC OFFSET 1 1; MINOR Y1TIC MARK NUMBER 0
    Y1TIC MARK LABEL FORMAT ALPHA
    Y1TIC LABEL CONT DEMOCRATS INDEPENDENTS REPUBLICANS SP() EAST ...
       SOUTH MIDWEST WEST SP() BLACKS HISPANICS WHITES SP()
    X1LABEL PERCENT; XLIMITS 0 100
    MAJOR XTIC MARK NUMBER 11; MINOR XTIC MARK NUMBER 1
    LINE BLANK; BAR ON
    BAR FILL ON; BAR WIDTH 0.5
    BAR PATTERN D1; BAR PATTERN SPACING 4
    BAR PATTERN THICK 0.5
    TITLE DEMONSTRATE BAR PATTERN THICKNESS
    PLOT CARTER X
 
-----BAR PLOT-------------------------------------------------------
 
BAR PLOT
 
Name:
    BAR PLOT
 
Type:
    Graphics Command
 
Note:
    This command is now obsolete.  Although it still works, the
    preferred method is to use the BAR command in conjunction with the
    PLOT command.
 
Purpose:
    Generate a bar plot.
 
Description:
    Bar charts are commonly used in business and presentation graphics.
    The following types of bars are commonly produced:
      1) Standard bar charts (a bar is drawn from the data point to
         the X axis);
      2) Grouped bar charts (bars are drawn for 2 or more groups of
         data);
      3) Stacked (or divided) bar charts (the bar is divided into
         several intervals).
    The BAR PLOT command is really only useful for generating standard
    bar charts (see the NOTE section below for an explanation).  The
    attributes of the bar are set with the various bar commands (see
    the RELATED COMMANDS section).  The BAR PLOT command treats
    observations with the same X value as belonging to the same trace
    when setting bar attributes.
 
Syntax:
    BAR PLOT Y X  <SUBSET/EXCEPT/FOR qualification>
    where <Y> is a response variable;
          <X> is a group identifier variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    BAR PLOT Y X
 
Note:
    The BAR PLOT command and the PLOT command using the BAR switch
    define traces differently.  For example, BAR PLOT Y X treats each
    distinct value of X as defining a separate trace.  PLOT Y X treats
    Y as a single trace.  PLOT Y1 Y2 VS X as treats Y1 as the first
    trace and Y2 as the second trace.  PLOT Y X TAG treats each
    distinct value of TAG as defining a separate trace.  This
    distinction between PLOT and BAR PLOT is relevant when assigning
    attributes to the bar since these commands use traces.  That is,
    the first setting is applied to the first trace, the second setting
    is applied to the second trace, and so on.
 
Note:
    Creating grouped and stacked bars is easier with the PLOT command.
    The problem with grouped bars using the BAR PLOT command is that
    it essentially functions as a histogram with a fixed width class
    interval.  Setting up data for groups typically violates this
    assumption (the groups are typically clustered around equi-spaced
    X values so the X values look something like 0.9, 1.1, 1.9, 2.1,
    etc.).  It can be done by using using separate BAR PLOT for each
    group (and using the PRE-ERASE OFF and LIMITS commands).  However,
    it is simpler to use the PLOT command.  The problem with divided
    bar charts is that it is difficult to give corresponding bars the
    same fill pattern since the BAR PLOT command gives bars with the
    same X value the same pattern.
 
Default:
    All OFF
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    CHARACTERS          = Sets the character types for plot points.
    LINES               = Sets the line types for plot points.
    SPIKES              = Sets on/off switches for plot spikes.
    BAR                 = Sets on/off switches for plot bars.
    BAR BASE            = Sets the base locations for bars on plots
    BAR FILL            = Sets the on/off switches for plot bar fills.
    BAR FILL COLOR      = Sets the colors of bar fills.
    BAR DIMENSION       = Sets the bar dimensions to 2d or 3d.
    BAR DIRECTION       = Sets the bar directions (H/V).
    BAR PATTERN         = Sets the types for bar fill patterns.
    BAR PATTERN COLOR   = Sets the colors for bar fill patterns.
    BAR PATTERN LINE    = Sets the line types for bar fill patterns.
    BAR PATTERN SPACING = Sets the line spacings for bar fill patterns.
    BAR PATTERN THICK   = Sets line thicknesses for bar fill patterns.
    BAR BORDER COLOR    = Sets the colors for bar border lines.
    BAR BORDER LINE     = Sets the types for bar border lines.
    BAR BORDER THICKNESS= Sets line thicknesses for bar border lines.
    BAR WIDTH           = Sets the widths for bar border lines.
 
Reference:
    "Statistical Graphics", Calvin Schmid, John Wiley and Sons.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    XX
 
Program:
    LET X = DATA 81 82 83 84 85
    LET Y = DATA 2 5 9 15 28
    .
    X1TIC MARK LABEL FORMAT ALPHA
    XLIMITS 81 85
    XTIC OFFSET 1 1
    X1TIC LABEL CONTENT 1981 1982 1983 1984 1985
    X1LABEL YEAR
    MINOR X1TIC MARK NUMBER 0
    Y1LABEL SALES (IN MILLIONS OF DOLLARS)
    YLIMITS 0 30
    MAJOR YTIC MARK NUMBER 4
    MINOR YTIC MARK NUMBER 1
    .
    TITLE BAR CHART WITH NO OPTIONS
    BAR PLOT Y X
 
-----BAR WIDTH-------------------------------------------------------
 
BAR WIDTH
 
Name:
    BAR WIDTH
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the widths of bars on subsequent plots.
 
Description:
    Bar widths are specified by trace.  All bars belonging to the same
    trace will have the same bar width.
 
Syntax:
    BAR WIDTHS  <width>  <width>  <width>  etc.
    where <width> is a positive number or parameter in the units of the
              plot frame that specifies the desired bar width.  Up to
              100 bar widths can be specified.
 
Examples:
    BAR WIDTHS 0.5 1.0 0.5 1.0
    BAR WIDTHS 1.0 1.0 0.5
    BAR WIDTHS 0.5 ALL
    BAR WIDTHS ALL 0.5
    BAR WIDTHS
 
Note:
    The BAR WIDTH command with no arguments sets the bar type to
    default for all bars.  The BAR WIDTH command with the word ALL
    before or after the specified width assigns that bar width to all
    bars; thus BAR WIDTH 0.5 ALL or BAR WIDTH ALL 0.5 plots all bars
    with a 0.5 width.
 
Note:
    The BAR, SPIKE, CHARACTER, and LINE switch all work independently
    of each other.  That is, a plot point can be a line, a character, a
    spike or a bar or any combination of the above.
 
Default:
    All bar widths are 1.0.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    CHARACTERS          = Sets the character types for plot points.
    LINES               = Sets the line types for plot points.
    SPIKES              = Sets on/off switches for plot spikes.
    BAR                 = Sets on/off switches for plot bars.
    BAR BASE            = Sets the base locations for bars on plots
    BAR FILL            = Sets the on/off switches for plot bar fills.
    BAR FILL COLOR      = Sets the colors of bar fills.
    BAR DIMENSION       = Sets the bar dimensions to 2d or 3d.
    BAR DIRECTION       = Sets the bar directions (H/V).
    BAR PATTERN         = Sets the types for bar fill patterns.
    BAR PATTERN COLOR   = Sets the colors for bar fill patterns.
    BAR PATTERN LINE    = Sets the line types for bar fill patterns.
    BAR PATTERN SPACING = Sets the line spacings for bar fill patterns.
    BAR PATTERN THICK   = Sets line thicknesses for bar fill patterns.
    BAR BORDER COLOR    = Sets the colors for bar border lines.
    BAR BORDER LINE     = Sets the types for bar border lines.
    BAR BORDER THICKNESS= Sets line thicknesses for bar border lines.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    XX
 
Program:
    LET CARTER = DATA 66 30 11 43 44 41 35 82 54 36
    LET REAGAN = DATA 26 54 84 47 51 51 52 14 36 55
    LET ANDERSON = DATA 6 12 4 8 3 6 10 3 7 8
    LET X = DATA 1 2 3 5 6 7 8 10 11 12
    LET X1 = X - 0.3
    LET X2 = X + 0.3
    .
    XLIMITS 1 12
    XTIC OFFSET 1 1
    MAJOR XTIC MARK NUMBER 12
    MINOR XTIC MARK NUMBER 0
    Y1LABEL PERCENT
    YLIMITS 0 100
    MAJOR YTIC MARK NUMBER 11
    MINOR YTIC MARK NUMBER 1
    .
    LINE BLANK ALL
    BAR ON ALL
    BAR WIDTH 0.2 0.4 0.2
    TITLE BAR CHART WITH VARYING BAR WIDTHS
    .
    PLOT CARTER X1 AND
    PLOT REAGAN X AND
    PLOT ANDERSON X2
 
-----BARTLETT TEST--------------------------------------------------
 
BARTLETT TEST
 
Name:
    BARTLETT TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform a k-sample Bartlett test for the homogeneity of variances
    across samples.
 
Description:
    The F test used in analysis of variance problem with k factors
    can be sensitive to unequal standard deviations in the k factors.
    Bartlett's test is a test of the hypothesis that all factor 
    standard deviations (or equivalently variances) are equal against
    the alternative that the standard deviations are not all equal.
    The sampling distribution of the Bartlett statistic is
    approximately chi-square when the k factor samples are from 
    independent normal populations.  Note that Bartlett's test can be
    sensitive to departures from this normality assumption.  The 
    details for computing the Bartlett statistic can be found in most
    introductory statistics books that cover analysis of variance.

Syntax:
    BARTLETT TEST  <y>  <tag>   <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a response variable;
          <tag> is a factor identifier variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    BARTLETT TEST Y1  GROUP
    BARTLETT TEST Y1  GROUP  SUBSET GROUP > 2
 
Note 1:
    The various values printed by the BARTLETT TEST command are
    saved as parameters that can be used later by the analyst.  Enter
    the command STATUS PARAMETERS after the BARTLETT TEST command 
    to see a list of the saved parameters.
 
Note 2:
    The HOMOGENEITY PLOT is a graphical technique for testing for
    unequal variances.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    HOMOGENEITY PLOT    = Plot group standard deviations against group
                          means.
    CONFIDENCE LIMITS   = Compute the confidence limits for the mean
                          of a sample.
    F TEST              = Performs a two-sample F test.
    T TEST              = Performs a two-sample t test.
    CHI-SQUARE TEST     = Performs a one sample chi-square test that
                          the standard deviation is equal to a given
                          value.
    STANDARD DEVIATION  = Computes the standard deviation of a
                          variable.
 
Reference:
    The Bartlett test is discussed in most introductory statistics
    books.
 
Applications:
    Analysis of Variance, Regression
 
Implementation Date:
    94/2
 
Program:
    SKIP 50
    SET READ FORMAT 3F4.0,F5.0,F6.0,F3.0,2F9.0
    READ PBF11.DAT YEAR DAY BOT SD F11 FLAG WV CO2
    .
    RETAIN YEAR DAY BOT SD F11 WV CO2 FLAG SUBSET FLAG 0
    LET MONTH=INT(DAY/30.25)+1
    .
    BARTLETT TEST WV MONTH
    STATUS PARAMETERS
 
-----BASIS TOLERANCE LIMITS--------------------------------------
 
BASIS TOLERANCE LIMITS
 
Name:
    <A/B> BASIS <DIST> TOLERANCE LIMITS
 
Type:
    Analysis Command
 
Purpose:
    Generates A-basis and B-basis tolerance intervals for the 
    Weibull, normal, and lognormal distributions.
 
Description:
    Standard tolerance intervals calculate a confidence interval
    that contains a fixed percentage (or proportion) of the data.
    This is related to, but distinct from, the confidence interval
    for the mean.
 
    There are two numbers for the tolerance interval:
   
       1) The coverage probability is the fixed percentage of
          the data to be covered.
       2) The confidence level.

    Standard tolerance limits are given by 

       XBAR +/-  k*s

    where XBAR is the sample mean, s is the sample standard
    deviation, and k is determined so that one can state with
    (1-alpha)% confidence that at least phi% of the data fall within
    the given limits.  The values for k, assuming a normal
    distribution, have been numerically tabulated.

    This is commonly stated as something like "a 95% confidence
    interval for 90% coverage".

    A and B basis values are a special case of this.  Specifically,
    the B basis value is a 95% lower confidence bound on the
    tenth percentile of a specified population of measurements
    and the A basis value is a 95% lower confidence bound of
    the first percentile.  Alternatively, this can be stated
    as the B basis value is a 95% lower tolerance bound for the
    upper 90% of a specified population and the A basis value is
    a 95% lower tolerance bound for the upper 99% of a
    specified population.
 
    Note that the A and B basis values are one sided intervals
    (the standard tolerance limits are two sided).  Also, the
    standard tolerance limits are typically based on a
    normality assumption while the A and B basis values can
    be computed for Weibull, normal, or lognormal distributions
    or they can be computed non-parametrically if none of
    these distributions provide an adequate fit.

    A and B basis values were added to support the MIL-17
    Handbook standard (see the Reference section below).
    The mathematics of computing these basis values are given
    in the MIL-17 Handbook and are not given here.

    A and B basis values are used for the case where the data
    can be considered unstructured.  That is, the data are
    either univariate to start with or the Anderson-Darling
    k-sample test has determined that the data can be treated
    as coming from a common sample.  Also, the appropriate
    distribution should be determined first.  The MIL-17
    Handbook recommends using the Anderson-Darling goodness
    of fit test.  It also recommends trying the Weibull,  then
    the lognormal, then the normal.  If all of these fail, then
    the non-parametric case can be used.

Syntax 1:
    BBASIS <dist>  TOLERANCE LIMITS   <y> 
                             <SUBSET/EXCEPT/FOR qualification>
    where <dist> is WEIBULL, NORMAL, LOGNORMAL, or NONPARAMETRIC;
          <y> is the response variable,
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes B basis values.

Syntax 2:
    ABASIS <dist>  TOLERANCE LIMITS   <y> 
                             <SUBSET/EXCEPT/FOR qualification>
    where <dist> is WEIBULL, NORMAL, LOGNORMAL, or NONPARAMETRIC;
          <y> is the response variable,
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes A basis values.

Examples:
    BBASIS WEIBULL TOLERANCE LIMITS Y1
    BBASIS LOGNORMAL TOLERANCE LIMITS Y1
    BBASIS NORMAL TOLERANCE LIMITS Y1
    BBASIS NONPARAMETRIC TOLERANCE LIMITS Y1
    ABASIS WEIBULL TOLERANCE LIMITS Y1
    ABASIS WEIBULL TOLERANCE LIMITS Y1   SUBSET BATCH > 1
 
Note:
    The following statistics are also supported:

        LET A = NORMAL        A BASIS  Y
        LET A = LOGNORMAL     A BASIS  Y
        LET A = WEIUBULL      A BASIS  Y
        LET A = NONPARAMETRIC A BASIS  Y
        LET A = NORMAL        B BASIS  Y
        LET A = LOGNORMAL     B BASIS  Y
        LET A = WEIUBULL      B BASIS  Y
        LET A = NONPARAMETRIC B BASIS  Y

    Enter HELP STATISTICS to see what commands can use these statistics.

Default:
    If no distribution is specified, the normal distribution
    is assumed.
 
Synonyms:
    The following are synonyms for ABASIS <dist> TOLERANCE LIMIT:

        ABASIS <dist>
        ABASIS <dist> TOLERANCE
        A BASIS <dist>
        A BASIS <dist> TOLERANCE
 
    The following are synonyms for BBASIS <dist> TOLERANCE LIMIT:

        BBASIS <dist>
        BBASIS <dist> TOLERANCE
        B BASIS <dist>
        B BASIS <dist> TOLERANCE

Related Commands:
    RECIPE                         = Generate tolerance values (in
                                     the basis values sense) for the
                                     structured case.
    ANDERSON-DARLING K SAMPLE TEST = Perform an Anderson-Darling
                                     k sample test.
    ANDERSON-DARLING TEST          = Perform an Anderson-Darling
                                     goodness of fit test.
    GRUBBS TEST                    = Perform Grubbs test for
                                     outliers.
    TOLERANCE LIMITS               = Generate tolerance limits for
                                     the normal distribution.
 
Reference:
    "MIL-HDBK-17 Volume 1: Guidelines for Characterization of
    Structural Materials", Depeartment of Defense, chapter 8.
    The URL for MIL-HDBK-17 is http://mil-17.udel.edu/.
 
Applications:
    Reliability of Materials
 
Implementation Date:
    1998/04
    2016/12: Corrected computation of tolerance limit factor for
             Weibull A BASIS
 
Program:
    SKIP 25
    READ VANGEL31.DAT Y
    BBASIS WEIBULL TOLERANCE LIMITS Y
    ABASIS WEIBULL TOLERANCE LIMITS Y
 
-----BATCH-------------------------------------------------------
 
BATCH
 
Name:
    BATCH
 
Type:
    Output Device Command
 
Purpose:
    Specifies that output device 1 (that is, the terminal) is:
       1) discrete (i.e., it cannot produce hardware-generated lines);
       2) wide-carriage (i.e., it is at least 120 characters wide).
 
Syntax:
    BATCH   <ON or OFF>
    where ON specifies that device 1 is a BATCH device while OFF
    reverts device 1 back to a Tektronix 4014.
    the m
 
Examples:
    BATCH ON
    BATCH OFF
    BATCH
 
Note:
    The BATCH command with no arguments is equivalent to BATCH ON.
 
Default:
    Device 1 is a Tektronix 4014 terminal.
 
Synonyms:
    None.
 
Related Commands:
    DISCRETE   = Sets the terminal to discrete.
    CONTINUOUS = Sets the terminal to continuous (Tektronix 4014).
    TEKTRONIX  = Sets the terminal to a Tektronix model.
    HP         = Sets the terminal to an HP model.
    GENERAL    = Sets the terminal to device-independent (a metafile).
    DEVICE     = Sets the device manufacturer and model.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XX
 
-----BAUD-------------------------------------------------------
 
BAUD
 
Name:
    BAUD
 
Type:
    Support Command
 
Purpose:
    Specifies the baud rate (= transmission rate) from host to terminal
    (in units of bits/second = 10 x characters/second).
 
Syntax:
    BAUD   <n>
    where <n> is a number or parameter that specifies the desired baud
    rate.
 
Examples:
    BAUD 9600
    BAUD 1200
    BAUD
 
Note:
    The BAUD command with no arguments sets the default baud rate.
 
Note:
    This is an obsolete command that was previously used for
    some Tektronix terminals.  It currently has no effect.

Default:
    The default baud rate is 1200.
 
Synonyms:
    None
 
Related Commands:
    ERASE DELAY = Sets the delay for screen erasure.
    COPY DELAY  = Sets the delay for screen hardcopying.
 
Applications:
    XX
 
Implementation Date:
    Pre-1987
 
Program:
    XX
 
-----BBNCDF (LET)--------------------------------
 
BBNCDF
 
Name:
    BBNCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the beta-binomial cumulative distribution function with
    shape parameters alpha, beta, and N.
 
Description:
    The beta-binomial distribution has the following probability
    density function:
          p(x,alpha,beta,n) = B(n-x+alpha,x+beta)/
                              [(n+1)*B(n-x+1,x+1)*B(alpha,beta)]
                                        x, n = 0, 1, 2, ..., n
                                        alpha > 0, beta > 0
    where B is the complete beta function and alpha and beta are
    shape parameters.  See the documentation for the BETA command for
    a description of the complete beta function.
 
    The cumulative distribution is the probability of obtaining x or
    fewer events.  It is the sum of the beta-binomial probabilities
    for 0 to x.

Syntax:
    LET <y> = BBNCDF(<x>,<a>,<b>,<n>) <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable containing
               non-negative integer values;
          <a> is a number, parameter, or variable that specifies the
               first shape parameter;
          <b> is a number, parameter, or variable that specifies the
               second shape parameter;
          <n> is a number, parameter, or variable that specifies the
               third shape parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed beta-binomial cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BBNCDF(10,0.5,0.9,22)
    LET A = BBNCDF(X,2.1,4,N)
    LET X2 = BBNCDF(X1,ALPHA,BETA,N)
 
Note:
    The beta-binomial distribution is derived from a binomial
    distribution B:n,p where the p parameter is a beta distributed
    variable with parameters alpha and beta.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BBNPDF = Compute the beta-binomial probability density function.
    BBNPPF = Compute the beta-binomial percent point function.
    BETCDF = Compute the beta cumulative distribution function.
    BETPDF = Compute the beta probability density function.
    BETPPF = Compute the beta percent point function.
    BINCDF = Compute the binomial cumulative distribution function.
    BINPDF = Compute the binomial probability density function.
    BINPPF = Compute the binomial percent point function.
 
Reference:
    "Empirical Bayes Estimation Of Generator Reliability", Martz, Kvam,
    and Abramson, Technometrics, February, 1996 (page 23).
 
    "Statistical Distributions", 2nd Edition, Evans, Hastings, and
    Peacock, 1994 (chapter 5).
 
Applications:
    Reliability, Bayeseian Analysis
 
Implementation Date:
    96/2
 
Program:
    XLIMITS 0 50
    XTIC OFFSET 0.5 0.5
    LINE BLANK
    SPIKE ON
    SPIKE THICKNESS 0.3
    TITLE AUTOMATIC
    X1LABEL NUMBER OF SUCCESSES
    Y1LABEL PROBABILITY
    .
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    PLOT BBNCDF(X,0.5,0.5,50) FOR X = 0 1 50
    PLOT BBNCDF(X,3.0,0.5,50) FOR X = 0 1 50
    PLOT BBNCDF(X,0.5,3.0,50) FOR X = 0 1 50
    PLOT BBNCDF(X,3.0,3.0,50) FOR X = 0 1 50
    END OF MULTIPLOT
 
-----BBNPDF (LET)--------------------------------
 
BBNPDF
 
Name:
    BBNPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the beta-binomial probability density function with
    shape parameters alpha, beta, and N.
 
Description:
    If the probability of success parameter, p, of a binomial
    distribution has a Beta distribution with shape parameters
    alpha and beta, the resulting distribution is referred to
    as a beta-binomial distribution.  For a standard binomial
    distribution, p is assumed to be fixed for successive trials.
    For the beta-binomial distribution, the value of p changes
    for each trial.

    The beta-binomial distribution has the following probability
    mass function:

        p(x,alpha,beta,n) = B(n-x+alpha,x+beta)/{(n+1)*B(n-x+1,x+1)*
                            B(alpha,beta)}
                            x = 0, 1, 2, ..., n; alpha, beta > 0

    where B is the complete beta function and alpha and beta are
    shape parameters.  See the documentation for the BETA command
    for a description of the complete beta function.

    Note that some sources reverse the role of alpha and beta
    in the above formula.  In this case, the probability mass
    function is sometimes given as

        p(x;alpha,beta,n) = B(alpha+x,beta+n-x)/{B(x+1,n-x+1)*
                            B(alpha,beta)*(n+1)}
                            x = 0, 1, 2, ..., n; alpha, beta > 0
 
Syntax:
    LET <y> = BBNPDF(<x>,<alpha>,<beta>,<n>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable containing
               non-negative integer values;
          <alpha> is a number, parameter, or variable that specifies
               the first shape parameter;
          <beta> is a number, parameter, or variable that specifies
               the second shape parameter;
          <n> is a number, parameter, or variable that specifies the
               third shape parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed beta-binomial pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BBNPDF(10,0.5,0.9,22)
    LET A = BBNPDF(X,2.1,4,N)
    LET X2 = BBNPDF(X1,ALPHA,BETA,N)
 
Note:
    The beta-binomial as given above is derived as a beta
    mixture of binomial random variables.

    Alternatively, it can be derived from the Polya urn model
    for contagion.  An urn containing w white balls and b black
    balls is augmented after each draw of a single ball by c
    balls of the drawn color (the ball withdrawn is also replaced).
    X is the total number of white balls drawn after n draws.
    This is known as the Polya distribution with probability mass
    function

       P(x;w,b,c,n) = (n x) B(x+w/c,n-x+b/c)/B(w/c,b/c)
                      x = 0, 1, 2, ..., n

    This probability mass function can also be given in the
    following equivalent forms (given on page 245 of Johnson,
    Kotz, and Kemp).

        P(x;w,b,c,n) = (n x) (-n-(w+b)/c  -x-w/c)/(-(w+b)/c  -w/c)
                       x = 0, 1, 2, ..., n

    or

        P(x;w,b,c,n) = (-w/c  x) (-b/c  n-x)/(-(w+b)/c  n)
                       x = 0, 1, 2, ..., n

    The Polya distribution is somewhat more general than the
    beta-binomial in that w, b, and c parameters are not
    restricted to positive numbers.  Johnson, Kotz, and Kemp also
    point out the following special cases of the Polya distribution
    based on the sign of c.

    1) If c is zero, withdrawals are independent events and the
       Polya distribution reduces to the binomial distribution.

    2) If c is negative, each withdrawal leads to a reversal of
       fortune.  If w/c is a negative integer, the Polya
       distribution reduces to the hypergeometric distribution.

    3) If c is positive, both success and failure are contagious.
       If w/c is a positive integer, the Polya distribution reduces
       to the negative hypergeometric distribution (if w/c is
       non-integer, then we have the beta-binomial distribution.

    Currently, Dataplot only support the case where w/c and
    b/c are positive (i.e., the beta-binomial or negative
    hypergeometric cases).

    Be aware that there are a number of derivations and formulas
    for the probability mass function for this distribution in
    the literature.  It may be referred to as the inverse
    hypergeometric distribution, the hypergeometric waiting-time
    distribution, the Markov-Polya distribution, or the
    generalized hypergeometric distribution.

Note:
    For a number of commands utilizing the beta-binomial
    distribution, it is convenient to bin the data.  There are
    two basic ways of binning the data.

      1) For some commands (histograms, maximum likelihood
         estimation), bins with equal size widths are
         required.  This can be accomplished with the
         following commands:

            LET AMIN = MINIMUM Y
            LET AMAX = MAXIMUM Y
            LET AMIN2 = AMIN - 0.5
            LET AMAX2 = AMAX + 0.5
            CLASS MINIMUM AMIN2
            CLASS MAXIMUM AMAX2
            CLASS WIDTH 1
            LET Y2 X2 = BINNED

      2) For some commands, unequal width bins may be
         helpful.  In particular, for the chi-square goodness
         of fit, it is typically recommended that the minimum
         class frequency be at least 5.  In this case, it may
         be helpful to combine small frequencies in the tails.
         Unequal class width bins can be created with the
         commands

            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = INTEGER FREQUENCY TABLE Y

         If you already have equal width bins data, you can
         use the commands
         
            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = COMBINE FREQUENCY TABLE Y2 X2

         The MINSIZE parameter defines the minimum class
         frequency.  The default value is 5.

Note:
    You can generate beta-binomial random numbers, probability
    plots, and chi-square goodness of fit tests with the following
    commands:

       LET N = VALUE
       LET ALPHA = <value>
       LET BETA = <value>
       LET Y = BETA BINOMIAL RANDOM NUMBERS FOR I = 1 1 N

       BETA BINOMIAL PROBABILITY PLOT Y
       BETA BINOMIAL PROBABILITY PLOT Y2 X2
       BETA BINOMIAL PROBABILITY PLOT Y3 XLOW XHIGH

       BETA BINOMIAL CHI-SQUARE GOODNESS OF FIT Y
       BETA BINOMIAL CHI-SQUARE GOODNESS OF FIT Y2 X2
       BETA BINOMIAL CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    To obtain the maximum likelihood estimates of alpha and beta,
    enter the command

        BETA BINOMIAL MAXIMUM LIKELIHOOD Y

    Dataplot computes the maximum likelihood estimates using
    Applied Statistics algorithm 189 written by David Smith
    (see References below).  Note that the Smith algorithm
    computes the maximum likelihood estimates for the
    beta-binomial distribution in terms of the parameters
    mu and theta

       theta = 1/(alpha + beta)
       mu    = beta/(alpha + beta)

    Dataplot prints the estimates for both parameterizations.

    You can generate estimates of alpha and beta based on the
    maximum ppcc value or the minimum chi-square goodness of fit
    with the commands

        LET N = <value>
        LET ALPHA1 = <value>
        LET ALPHA2 = <value>
        LET BETA1  = <value>
        LET BETA2  = <value>
        BETA BINOMIAL KS PLOT Y
        BETA BINOMIAL KS PLOT Y2 X2
        BETA BINOMIAL KS PLOT Y3 XLOW XHIGH
        BETA BINOMIAL PPCC PLOT Y
        BETA BINOMIAL PPCC PLOT Y2 X2
        BETA BINOMIAL PPCC PLOT Y3 XLOW XHIGH

    The default values of alpha1 and alpha2 are 0.5 and 5,
    respectively.  The default values for beta1 and beta2 are
    0.5 and 5, respectively.  Due to the discrete nature of the
    percent point function for discrete distributions, the
    ppcc plot will not be smooth.  For that reason, if there is
    sufficient sample size the KS PLOT (i.e., the minimum
    chi-square value) is typically preferred.  However, it may
    sometimes be useful to perform one iteration of the PPCC PLOT
    to obtain a rough idea of an appropriate neighborhood for the
    shape parameters since the minimum chi-square statistic can
    generate extremely large values for non-optimal values of
    the shape parameters.  Also, since the data is integer values,
    one of the binned forms is preferred for these commands.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BBNCDF                   = Compute the beta-binomial cumulative
                               distribution function.
    BBNPPF                   = Compute the beta-binomial percent
                               point function.
    BETPDF                   = Compute the beta probability density
                               function.
    BINPDF                   = Compute the binomial probability
                               mass function.
    BGEPPF                   = Compute the beta-geometric (Waring)
                               probability mass function.
    BNBPPF                   = Compute the beta-negative binomial
                               (generalized Waring) probability mass
                               function.
    INTEGER FREQUENCY TABLE  = Generate a frequency table at
                               integer values with unequal bins.
    COMBINE FREQUENCY TABLE  = Convert an equal width frequency
                               table to an unequal width frequency
                               table.
    KS PLOT                  = Generate a minimum chi-square plot.
    PPCC PLOT                = Generate a ppcc plot.
    PROBABILITY PLOT         = Generate a probability plot.
    MAXIMUM LIKELIHOOD       = Perform maximum likelihood
                               estimation for a distribution.
 
Reference:
    "Empirical Bayes Estimation Of Generator Reliability", Martz,
    Kvam, and Abramson, Technometrics, February, 1996 (page 23).
 
    "Statistical Distributions", 2nd Edition, Evans, Hastings, and
    Peacock, 1994 (chapter 5).
 
    "Algorithm AS 189: Maximum Likelihood Estimation of the
    Parameters of the Beta Binomial Distribution", D. M. Smith,
    Applied Statistics, 1983, Vol. 32, No. 2.

Applications:
    Reliability, Bayeseian Analysis
 
Implementation Date:
    1996/2
 
Program:
    XLIMITS 0 50
    XTIC OFFSET 0.5 0.5
    LINE BLANK
    SPIKE ON
    SPIKE THICKNESS 0.3
    .
    TITLE CASE ASIS
    LABEL CASE ASIS
    X1LABEL Number of Successes
    Y1LABEL Probability Mass
    TITLE DISPLACEMENT 2
    Y1LABEL DISPLACEMENT 15
    X1LABEL DISPLACEMENT 12
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    TITLE Alpha = 0.5, Beta = 0.5, N = 50
    PLOT BBNPDF(X,0.5,0.5,50) FOR X = 0 1 50
    .
    TITLE Alpha = 3, Beta = 0.5, N = 50
    PLOT BBNPDF(X,3.0,0.5,50) FOR X = 0 1 50
    .
    TITLE Alpha = 0.5, Beta = 3, N = 50
    PLOT BBNPDF(X,0.5,3.0,50) FOR X = 0 1 50
    .
    TITLE Alpha = 3, Beta = 3, N = 50
    PLOT BBNPDF(X,3.0,3.0,50) FOR X = 0 1 50
    .
    END OF MULTIPLOT
    .
    CASE ASIS
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Beta-Binomial Probability Mass Functions
 
-----BBNPPF (LET)--------------------------------
 
BBNPPF
 
Name:
    BBNPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the beta-binomial percent point function with shape
    parameters alpha, beta, and N.
 
Description:
    The beta-binomial distribution has the following probability
    density function:
          p(x,alpha,beta,n) = B(n-x+alpha,x+beta)/
                              [(n+1)*B(n-x+1,x+1)*B(alpha,beta)]
                                        x, n = 0, 1, 2, ..., n
                                        alpha > 0, beta > 0
    where B is the complete beta function and alpha and beta are
    shape parameters.  See the documentation for the BETA command for
    a description of the complete beta function.
 
    The percent point function is the inverse of the cumulative
    distribution function.  The cumulative distribution sums the
    probability from 0 to the given x value.  The percent point
    function takes a cumulative probability value and computes the
    corresponding x value.

Syntax:
    LET <y> = BBNPPF(<p>,<a>,<b>,<n>) <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or variable containing
               values between 0 and 1;
          <a> is a number, parameter, or variable that specifies the
               first shape parameter;
          <b> is a number, parameter, or variable that specifies the
               second shape parameter;
          <n> is a number, parameter, or variable that specifies the
               third shape parameter;
          <y> is a variable or a parameter (depending on what <p> is)
               where the computed beta-binomial ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BBNPPF(10,0.5,0.9,22)
    LET A = BBNPPF(P,2.1,4,N)
    LET X2 = BBNPPF(P,ALPHA,BETA,N)
 
Note:
    The beta-binomial distribution is derived from a binomial
    distribution B:n,p where the p parameter is a beta distributed
    variable with parameters alpha and beta.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BBNCDF = Compute the beta-binomial cumulative distribution
             function.
    BBNPDF = Compute the beta-binomial probability density function.
    BETCDF = Compute the beta cumulative distribution function.
    BETPDF = Compute the beta probability density function.
    BETPPF = Compute the beta percent point function.
    BINCDF = Compute the binomial cumulative distribution function.
    BINPDF = Compute the binomial probability density function.
    BINPPF = Compute the binomial percent point function.
 
Reference:
    "Empirical Bayes Estimation Of Generator Reliability", Martz, Kvam,
    and Abramson, Technometrics, February, 1996 (page 23).
 
    "Statistical Distributions", 2nd Edition, Evans, Hastings, and
    Peacock, 1994 (chapter 5).
 
Applications:
    Reliability, Bayeseian Analysis
 
Implementation Date:
    96/2
 
Program:
    XLIMITS 0 1
    YLIMITS 0 50
    YTIC OFFSET 0.5 0.5
    LINE BLANK
    SPIKE ON
    SPIKE THICKNESS 0.3
    TITLE AUTOMATIC
    Y1LABEL NUMBER OF SUCCESSES
    X1LABEL PROBABILITY
    .
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    PLOT BBNPPF(P,0.5,0.5,50) FOR P = 0 0.05 1
    PLOT BBNPPF(P,3.0,0.5,50) FOR P = 0 0.05 1
    PLOT BBNPPF(P,0.5,3.0,50) FOR P = 0 0.05 1
    PLOT BBNPPF(P,3.0,3.0,50) FOR P = 0 0.05 1
    END OF MULTIPLOT
 
-----BELL-------------------------------------------------------
 
BELL
 
Name:
    BELL
 
Type:
    Plot Control Command
 
Purpose:
    Specifies that the bell should be automatically sounded for all
    subsequent plots.
 
Syntax:
    BELL   <ON or OFF>
    where ON specifies that the bell should be rung while OFF specifies
    that the bell should not be rung.
 
Examples:
    BELL ON
    BELL OFF
    BELL
 
Note:
    The BELL command with no arguments is equivalent to BELL ON.
 
Default:
    The default is to have automatic sounding of the bell at the
    beginning of the plot (i.e., ON).
 
Synonyms:
    None
 
Related Commands:
    PLOT      = Generates a data or function plot.
    PRE-ERASE = Sets the auto-pre-erase switch for plots.
    HARDCOPY  = Sets the automatic copy switch for plots.
    SEQUENCE  = Sets the automatic sequence switch for plots.
    RING      = Rings the bell (immediately).
    ERASE     = Erases the screen (immediately).
    COPY      = Copies the screen (immediately).
 
Applications:
    XX
 
Implementation Date:
    Pre-1987
 
Program:
    XX
 
-----BEICDF (LET)--------------------------------
 
BEICDF
 
Name:
    BEICDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Bessel I-function cumulative distribution function.
 
Description:
    The standard form of the Bessel I-function distribution has
    the following probability density function:

        f(x;s1sq,s2sq,nu) = K*x**M*EXP(-C*x/B)*PI*I(x/B,M)
                            X > 0; |1 - C**2| > 1

    where
        B = 4*s1sq**2*s2sq**2/(s1sq**2 - s2sq**2)
        C = (s1sq**2 + s2sq**2)/(s1sq**2 - s2sq**2)
        M = 2*nu + 1
    and
        K      = |1 - C**2|**(M+0.5)/
                 [SQRT(PI)*2**M*B**(M+1)*GAMMA(M+0.5)]
        I(Z,N) = the modified Bessel function of the first kind
        Gamma  = the Gamma function

    The Bessel I-function is the distribution of

        s1**2*X1 + s2**2*X2

    with X1 and X2 are chi-square distributions with degrees
    of freedom parameter nu.

    The cumulative distribution function is computed by
    numerically integrating the probability density function.
    Dataplot performs the integration using the DQAG routine
    from the Slatec library.

    The standard Bessel I-function distribution can be generalized
    with location and scale parameters in the usual way.

Syntax:
    LET <y> = BEICDF(<x>,<s1sq>,<s2sq>,<nu>,<loc>,<scale>)
                                <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable or a parameter;
          <s1sq> is a positive number of parameter that specifies the
              value of the first shape parameter;
          <s2sq> is a positive number of parameter that specifies the
              value of the second shape parameter;
          <nu> is a positive number of parameter that specifies the
              value of the third shape parameter;
          <loc> is an optional number or parameter that specifies the
              value of the location parameter;
          <scale> is an optional positive number or parameter that
              specifies the value of the scale parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed Bessel I-function cdf
               value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y = BEICDF(3,2,0.5,3)
    LET Y = BEICDF(X1,S1SQ,S2SQ,NU)
    PLOT BEICDF(X,S1SQ,S2SQ,NU) FOR X = 0.1  0.1  100
 
Note:
    DATAPLOT uses the routine DBESI from the SLATEC Common Mathematical
    Library to compute the modified Bessel function of the third
    kind.  SLATEC is a large set of high quality, portable, public
    domain Fortran routines for various mathematical capabilities
    maintained by seven federal laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BEIPDF = Compute the Bessel I-function probability density
             function.
    BEIPPF = Compute the Bessel I-function percent point function.
    GALPDF = Compute the generalized asymmetric Laplace cumulative
             distribution function.
    GIGPDF = Compute the generalized inverse Gaussian probability
             density function.
    BEKPDF = Compute the Bessel K-function probability density
             function.
    MCLPDF = Compute the McLeish probability density function.
 
Reference:
    Johnson, Kotz, and Balakrisnan, "Continuous Univariate
    Distributions--Volume I", Second Edition, Wiley, 1994,
    pp. 50-53.

Applications:
    Distributional Modeling
 
Implementation Date:
    8/2004
 
Program:
    Y1LABEL Probability
    X1LABEL X
    LABEL CASE ASIS
    TITLE CASE ASIS
    CASE ASIS
    Y1LABEL DISPLACEMENT 12
    LINE COLOR BLACK BLUE RED GREEN
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    LINE SOLID DASH DOTTED
    TITLE S1SQ = 2, S2SQ = 0.5, NU = 1, 2, 3, 10
    PLOT BEICDF(X,2,0,0.5,1) FOR X = 0.1  0.1  100 AND
    PLOT BEICDF(X,2,0,0.5,2) FOR X = 0.1  0.1  100 AND
    PLOT BEICDF(X,2,0,0.5,3) FOR X = 0.1  0.1  100 AND
    PLOT BEICDF(X,2,0,0.5,10) FOR X = 0.1  0.1  100
    TITLE S1SQ = 2, S2SQ = 0.5, NU = 0.1, 0.2, 0.5, 1.0
    PLOT BEICDF(X,2,0,0.5,1) FOR X = 0.1  0.1  100 AND
    PLOT BEICDF(X,2,0,0.5,2) FOR X = 0.1  0.1  100 AND
    PLOT BEICDF(X,2,0,0.5,3) FOR X = 0.1  0.1  100 AND
    PLOT BEICDF(X,2,0,0.5,10) FOR X = 0.1  0.1  100
    TITLE S1SQ = 5, S2SQ = 0.5, NU = 1, 2, 3, 10
    PLOT BEICDF(X,5,0,0.5,1) FOR X = 0.1  0.1  100 AND
    PLOT BEICDF(X,5,0,0.5,2) FOR X = 0.1  0.1  100 AND
    PLOT BEICDF(X,5,0,0.5,3) FOR X = 0.1  0.1  100 AND
    PLOT BEICDF(X,5,0,0.5,10) FOR X = 0.1  0.1  100
    TITLE S1SQ = 5, S2SQ = 0.5, NU = 0.1, 0.2, 0.5, 1.0
    PLOT BEICDF(X,5,0,0.5,1) FOR X = 0.1  0.1  100 AND
    PLOT BEICDF(X,5,0,0.5,2) FOR X = 0.1  0.1  100 AND
    PLOT BEICDF(X,5,0,0.5,3) FOR X = 0.1  0.1  100 AND
    PLOT BEICDF(X,5,0,0.5,10) FOR X = 0.1  0.1  100
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT Bessel I-Function Distribution
 
-----BEIPDF (LET)--------------------------------
 
BEIPDF
 
Name:
    BEIPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Bessel I-function probability density function.
 
Description:
    The standard form of the Bessel I-function
    distribution has the following probability density function:

        f(x;s1sq,s2sq,nu) = K*x**M*EXP(-C*x/B)*PI*I(x/B,M)
                            X > 0; |1 - C**2| > 1

    where
        B = 4*s1sq**2*s2sq**2/(s1sq**2 - s2sq**2)
        C = (s1sq**2 + s2sq**2)/(s1sq**2 - s2sq**2)
        M = 2*nu + 1
    and
        K      = |1 - C**2|**(M+0.5)/
                 [SQRT(PI)*2**M*B**(M+1)*GAMMA(M+0.5)]
        I(Z,N) = the modified Bessel function of the first kind
        Gamma  = the Gamma function

    The Bessel I-function is the distribution of

        s1**2*X1 + s2**2*X2

    with X1 and X2 are chi-square distributions with degrees
    of freedom parameter nu.

    The standard Bessel I-function distribution can be generalized
    with location and scale parameters in the usual way.

Syntax:
    LET <y> = BEIPDF(<x>,<s1sq>,<s2sq>,<nu>,<loc>,<scale>)
                                <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable or a parameter;
          <s1sq> is a positive number of parameter that specifies the
              value of the first shape parameter;
          <s2sq> is a positive number of parameter that specifies the
              value of the second shape parameter;
          <nu> is a positive number of parameter that specifies the
              value of the third shape parameter;
          <loc> is an optional number or parameter that specifies the
              value of the location parameter;
          <scale> is an optional positive number or parameter that
              specifies the value of the scale parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed Bessel I-function pdf
               value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y = BEIPDF(3,2,0.5,3)
    LET Y = BEIPDF(X1,S1SQ,S2SQ,NU)
    PLOT BEIPDF(X,S1SQ,S2SQ,NU) FOR X = 0.1  0.1  100
 
Note:
    DATAPLOT uses the routine DBESI from the SLATEC Common Mathematical
    Library to compute the modified Bessel function of the third
    kind.  SLATEC is a large set of high quality, portable, public
    domain Fortran routines for various mathematical capabilities
    maintained by seven federal laboratories.

Note:
    To generate Bessel I-function random numbers, enter
    the commands

        LET SIGMA1SQ = <value>
        LET SIGMA2SQ = <value>
        LET NU = <value>
        LET Y = BESSEL I FUNCTION RANDOM NUMBERS ...
                FOR I = 1 1 N

    To generate a Bessel I-function probability plot
    or a Bessel I-function Kolmogorov-Smirnov or
    chi-square goodness of fit test, enter the following commands

        LET SIGMA1SQ = <value>
        LET SIGMA2SQ = <value>
        LET NU = <value>
        BESSEL I FUNCTION PROBABILITY PLOT Y
        BESSEL I FUNCTION KOLMOGOROV SMIRNOV ...
                   GOODNESS OF FIT Y
        BESSEL I FUNCTION CHI-SQUARE GOODNESS OF FIT Y
       
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BEICDF = Compute the Bessel I-function cumulative distribution
             function.
    BEIPPF = Compute the Bessel I-function percent point function.
    GALPDF = Compute the generalized asymmetric Laplace cumulative
             distribution function.
    GIGPDF = Compute the generalized inverse Gaussian probability
             density function.
    BEKPDF = Compute the Bessel K-function probability density
             function.
    MCLPDF = Compute the McLeish probability density function.
 
Reference:
    Johnson, Kotz, and Balakrisnan, "Continuous Univariate
    Distributions--Volume I", Second Edition, Wiley, 1994,
    pp. 50-53.

Applications:
    Distributional Modeling
 
Implementation Date:
    8/2004
 
Program:
    Y1LABEL Probability
    X1LABEL X
    LABEL CASE ASIS
    TITLE CASE ASIS
    CASE ASIS
    Y1LABEL DISPLACEMENT 12
    LINE COLOR BLACK BLUE RED GREEN
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    LINE SOLID DASH DOTTED
    TITLE S1SQ = 2, S2SQ = 0.5, NU = 1, 2, 3, 10
    PLOT BEIPDF(X,2,0,0.5,1) FOR X = 0.1  0.1  100 AND
    PLOT BEIPDF(X,2,0,0.5,2) FOR X = 0.1  0.1  100 AND
    PLOT BEIPDF(X,2,0,0.5,3) FOR X = 0.1  0.1  100 AND
    PLOT BEIPDF(X,2,0,0.5,10) FOR X = 0.1  0.1  100
    TITLE S1SQ = 2, S2SQ = 0.5, NU = 0.1, 0.2, 0.5, 1.0
    PLOT BEIPDF(X,2,0,0.5,1) FOR X = 0.1  0.1  100 AND
    PLOT BEIPDF(X,2,0,0.5,2) FOR X = 0.1  0.1  100 AND
    PLOT BEIPDF(X,2,0,0.5,3) FOR X = 0.1  0.1  100 AND
    PLOT BEIPDF(X,2,0,0.5,10) FOR X = 0.1  0.1  100
    TITLE S1SQ = 5, S2SQ = 0.5, NU = 1, 2, 3, 10
    PLOT BEIPDF(X,5,0,0.5,1) FOR X = 0.1  0.1  100 AND
    PLOT BEIPDF(X,5,0,0.5,2) FOR X = 0.1  0.1  100 AND
    PLOT BEIPDF(X,5,0,0.5,3) FOR X = 0.1  0.1  100 AND
    PLOT BEIPDF(X,5,0,0.5,10) FOR X = 0.1  0.1  100
    TITLE S1SQ = 5, S2SQ = 0.5, NU = 0.1, 0.2, 0.5, 1.0
    PLOT BEIPDF(X,5,0,0.5,1) FOR X = 0.1  0.1  100 AND
    PLOT BEIPDF(X,5,0,0.5,2) FOR X = 0.1  0.1  100 AND
    PLOT BEIPDF(X,5,0,0.5,3) FOR X = 0.1  0.1  100 AND
    PLOT BEIPDF(X,5,0,0.5,10) FOR X = 0.1  0.1  100
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT Bessel I-Function Distribution
 
-----BEIPPF (LET)--------------------------------
 
BEIPPF
 
Name:
    BEIPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Bessel I-function percent point function.
 
Description:
    The standard form of the Bessel I-function distribution has
    the following probability density function:

        f(x;s1sq,s2sq,nu) = K*x**M*EXP(-C*x/B)*PI*I(x/B,M)
                            X > 0; |1 - C**2| > 1

    where
        B = 4*s1sq**2*s2sq**2/(s1sq**2 - s2sq**2)
        C = (s1sq**2 + s2sq**2)/(s1sq**2 - s2sq**2)
        M = 2*nu + 1
    and
        K      = |1 - C**2|**(M+0.5)/
                 [SQRT(PI)*2**M*B**(M+1)*GAMMA(M+0.5)]
        I(Z,N) = the modified Bessel function of the first kind
        Gamma  = the Gamma function

    The Bessel I-function is the distribution of

        s1**2*X1 + s2**2*X2

    with X1 and X2 are chi-square distributions with degrees
    of freedom parameter nu.

    The cumulative distribution function is computed by
    numerically integrating the probability density function.
    Dataplot performs the integration using the DQAG routine
    from the Slatec library.  The percent point function is
    then computed by numerically inverting the cumulative
    distribution function using the DFZERO subroutine from
    the Slatec library.

    The standard Bessel I-function distribution can be generalized
    with location and scale parameters in the usual way.

Syntax:
    LET <y> = BEIPPF(<p>,<s1sq>,<s2sq>,<nu>,<loc>,<scale>)
                                <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, number, or a parameter in the interval
              (0,1);
          <s1sq> is a positive number of parameter that specifies the
              value of the first shape parameter;
          <s2sq> is a positive number of parameter that specifies the
              value of the second shape parameter;
          <nu> is a positive number of parameter that specifies the
              value of the third shape parameter;
          <loc> is an optional number or parameter that specifies the
              value of the location parameter;
          <scale> is an optional positive number or parameter that
              specifies the value of the scale parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed Bessel I-function ppf
               value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y = BEIPPF(0.95,2,0.5,3)
    LET Y = BEIPPF(P,S1SQ,S2SQ,NU)
    PLOT BEIPPF(P,S1SQ,S2SQ,NU) FOR X = 0.01  0.01  0.99
 
Note:
    DATAPLOT uses the routine DBESI from the SLATEC Common Mathematical
    Library to compute the modified Bessel function of the third
    kind.  SLATEC is a large set of high quality, portable, public
    domain Fortran routines for various mathematical capabilities
    maintained by seven federal laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BEICDF = Compute the Bessel I-function cumulative distribution
             function.
    BEIPDF = Compute the Bessel I-function probability density
             function.
    GALPDF = Compute the generalized asymmetric Laplace cumulative
             distribution function.
    GIGPDF = Compute the generalized inverse Gaussian probability
             density function.
    BEKPDF = Compute the Bessel K-function probability density
             function.
    MCLPDF = Compute the McLeish probability density function.
 
Reference:
    Johnson, Kotz, and Balakrisnan, "Continuous Univariate
    Distributions--Volume I", Second Edition, Wiley, 1994,
    pp. 50-53.

Applications:
    Distributional Modeling
 
Implementation Date:
    8/2004
 
Program:
    X1LABEL Probability
    Y1LABEL X
    LABEL CASE ASIS
    TITLE CASE ASIS
    CASE ASIS
    Y1LABEL DISPLACEMENT 12
    LINE COLOR BLACK BLUE RED GREEN
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    LINE SOLID DASH DOTTED
    TITLE S1SQ = 2, S2SQ = 0.5, NU = 1, 2, 3, 10
    PLOT BEIPPF(P,2,0,0.5,1) FOR P = 0.01  0.01  0.99 AND
    PLOT BEIPPF(P,2,0,0.5,2) FOR P = 0.01  0.01  0.99 AND
    PLOT BEIPPF(P,2,0,0.5,3) FOR P = 0.01  0.01  0.99 AND
    PLOT BEIPPF(P,2,0,0.5,10) FOR P = 0.01  0.01  0.99
    TITLE S1SQ = 2, S2SQ = 0.5, NU = 0.1, 0.2, 0.5, 1.0
    PLOT BEIPPF(P,2,0,0.5,1) FOR P = 0.01  0.01  0.99 AND
    PLOT BEIPPF(P,2,0,0.5,2) FOR P = 0.01  0.01  0.99 AND
    PLOT BEIPPF(P,2,0,0.5,3) FOR P = 0.01  0.01  0.99 AND
    PLOT BEIPPF(P,2,0,0.5,10) FOR P = 0.01  0.01  0.99
    TITLE S1SQ = 5, S2SQ = 0.5, NU = 1, 2, 3, 10
    PLOT BEIPPF(P,5,0,0.5,1) FOR P = 0.01  0.01  0.99 AND
    PLOT BEIPPF(P,5,0,0.5,2) FOR P = 0.01  0.01  0.99 AND
    PLOT BEIPPF(P,5,0,0.5,3) FOR P = 0.01  0.01  0.99 AND
    PLOT BEIPPF(P,5,0,0.5,10) FOR P = 0.01  0.01  0.99
    TITLE S1SQ = 5, S2SQ = 0.5, NU = 0.1, 0.2, 0.5, 1.0
    PLOT BEIPPF(P,5,0,0.5,1) FOR P = 0.01  0.01  0.99 AND
    PLOT BEIPPF(P,5,0,0.5,2) FOR P = 0.01  0.01  0.99 AND
    PLOT BEIPPF(P,5,0,0.5,3) FOR P = 0.01  0.01  0.99 AND
    PLOT BEIPPF(P,5,0,0.5,10) FOR P = 0.01  0.01  0.99
    END OF MULTIPLOT
    MOVE 50 97
    JUSTIFICATION CENTER
    TEXT Bessel I-Function Distribution
 
-----BER (LET)--------------------------------
 
BER
 
Name:
    BER (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the ber Kelvin function or the derivative of the
    ber Kelvin function.
 
Description:
    The Bessel function of the first kind with order v (v is a
    non-negative real number) can be defined as:

        Jv(z) = (z/2)**v*SUM((-z**2/4)**k/(k!*GAMMA(v+k+1)))

    where the sum is for k from zero to infinity, GAMMA is the 
    Gamma function, and ! is the factorial function.
 
    The Kelvin functions of the first kind can then be defined
    in terms of the Bessel function of the first kind:
  
       ber(v)(x) + i*bei(v)(x) = J(v)(x*exp(3*pi*i/4)
    
    The functions described here compute these functions
    for the case when there is a real, non-negative input
    argument and order zero (i.e., v = 0).
 
    Dataplot computes these function using the KLVNA routines from
    "Computation of Special Functions" (see the References section
    below).
 

Syntax 1:
    LET <yr> = BER(<x>)      <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative number, variable or parameter;
          <yr> is a variable or a parameter (depending on what
              <x> is) where the computed Kelvin value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the real component of the Kelvin
    function of the first kind.

Syntax 2:
    LET <yc> = BERI(<x>)      <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative number, variable or parameter;
          <yc> is a variable or a parameter (depending on what
              <x> is) where the computed Kelvin value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the complex component of the Kelvin
    function of the first kind.

Syntax 3:
    LET <yr> = BER1(<x>)      <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative number, variable or parameter;
          <yr> is a variable or a parameter (depending on what
              <x> is) where the computed Kelvin value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the real component of the derivative of
    the Kelvin function of the first kind.

Syntax 4:
    LET <yc> = BERI1(<x>)      <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative number, variable or parameter;
          <yc> is a variable or a parameter (depending on what
              <x> is) where the computed Kelvin value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the complex component of the derivative
    of the Kelvin function of the first kind.

Examples:
    LET A = BER(2)
    LET A = BERI(2)
    LET A = BER1(2)
    LET A = BERI1(2)

    LET YR = BER(X)
    LET YC = BERI(X)

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    KER     = Compute the KER Kelvin functions.
    CBESSJR = Compute the real component of the Bessel function of
              the first kind, order N, and complex argument.
    CBESSJI = Compute the complex component of the Bessel function of
              the first kind, order N, and complex argument.
    CBESSYR = Compute the real component of the Bessel function of
              the second kind, order N, and complex argument.
    CBESSYI = Compute the complex component of the Bessel function of
              the second kind, order N, and complex argument.
    CBESSIR = Compute the real component of the modified Bessel
              function of order N and complex argument.
    CBESSII = Compute the complex component of the modified Bessel
              function of order N and complex argument.
    CBESSKR = Compute the real component of the modified Bessel
              function of the third kind, order N, and complex
              argument.
    CBESSKI = Compute the complex component of the modified Bessel
              function of the third kind, order N, and complex
              argument.
    BESSJN  = Compute the Bessel function of the first kind, order N,
              and real argument.
 
Reference:
    "Computation of Special Functions", Shanjie Zhang and Jianming
    Jin, John Wiley and Sons, 1996, chapter 9.
 
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (pages 379-385).
 
Applications:
    Special Functions
 
Implementation Date:
    1997/12
 
Program:
    LINE SOLID DASH
    TITLE BER KELVIN FUNCTION
    PLOT BER(X) FOR X = 0.1 0.1 10 AND
    PLOT BERI(X) FOR X = 0.1 0.1 10
 
-----BERNOULLI NUMBERS (LET)----------------------------------
 
BERNOULLI NUMBERS
 
Name:
    BERNOULLI NUMBERS (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Generate a sequence of Bernoulli numbers.
 
Description:
    For a description of Bernoulli numbers and polynomials,
    enter the command:

        HELP BN

    BN is a library function for computing Bernoulli numbers
    and polynomials.  The BERNOULLI NUMBERS command can be
    used to generate a sequence of Bernoulli numbers.

Syntax:
    LET <y> = BERNOULLI NUMBERS FOR I = <start> <inc>  <stop> 
    where <start> is the starting row for the Bernoulli numbers;
          <inc> is the increment for the Bernoulli numbers;
          <stop> is the stopping row for the Bernoulli numbers;
          <y> is a variable where the Bernoulli numbers are saved.
 
    Typically <start> and <inc> are 1 and <stop> is set to the
    number of Bernoulli numbers to generate.  If <start> and <inc>
    are not 1, then <y> will still contain <stop> elements, but
    the empty rows will be set to 0.

Examples:
    LET Y = BERNOULLI NUMBERS FOR I = 1 1 50

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BINCDF       = Compute the binomial cumulative distribution
                   function.
    BINPDF       = Compute the binomial probability mass function.
    BINPPF       = Compute the binomial percent point function.
    BINOMIAL     = Compute the binomial coefficients.
    EN           = Compute Euler number or polynomial.
 
Reference:
    "Computation of Special Functions", Shanjie Zhang and Jianming
    Jin, John Wiley and Sons, 1996, chapter 1.
 
Applications:
    Probability
 
Implementation Date:
    1997/12
 
Program:
    LET Y = BERNOULLI NUMBERS FOR I = 1 1 50
    PRINT Y
 
-----BESS0 (LET)--------------------------------
 
BESS0
 
Name:
    BESS0 (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Bessel function of the first kind and order 0.
 
Description:
    The definition of Bessel functions of the first kind with order v
    (v is a non-negative real number) is:

        Jv(x) = (x/2)**v*SUM((-x**2/4)**k/(k!*GAMMA(v+k+1)))

    where the sum is for k from zero to infinity, GAMMA is the 
    Gamma function, and ! is the factorial function.
 
Syntax:
    LET <y2> = BESS0(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a decimal number, variable or parameter;
          <y2> is a variable or a parameter (depending on what
               <y1> is) where the computed Bessel value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET X2 = BESS0(2)
    LET A = BESS0(-2)
    LET A = BESS0(A1)
    LET X2 = BESS0(X1-4)
 
Note:
    DATAPLOT uses the function BESJ0 from the SLATEC Common
    Mathematical Library to compute this function.  SLATEC is a large
    set of high quality, portable, public domain Fortran routines
    for various mathematical capabilities maintained by seven federal
    laboratories.

Note:
    Versions prior to September, 1994 used a different algorithm that
    did not allow input values less thant -3.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BESSJ0 is a synonym for BESS0 (added 94/9).
 
Related Commands:
    BESS1  = Compute the Bessel function of the first kind and order 1.
    BESSJN = Compute the Bessel function of the first kind and order N.
    BESSY0 = Compute the Bessel function of the second kind and 
             order 0.
    BESSI0 = Compute the modified Bessel function of order 0.
    BESSK0 = Compute the modified Bessel function of the third kind
             and order 0.
    BESSYN = Compute the Bessel function of the second kind and 
             order N.
    BESSIN = Compute the modified Bessel function of order N.
    BESSKN = Compute the modified Bessel function of the third kind
             and of order N.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (pages 355-433).
 
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", 2nd Edition, Press, Flannery, Teukolsky, and Vetterling.
    Cambridge University Press, 1992 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    The SLATEC function was implemented 94/9.
 
Program:
    TITLE AUTOMATIC
    PLOT BESS0(X) FOR X = -5 .1 5
 
-----BESS1 (LET)--------------------------------
 
BESS1
 
Name:
    BESS1 (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Bessel function of the first kind and order 1.
 
Description:
    The definition of Bessel functions of the first kind with order v
    (v is a non-negative real number) is:

        Jv(x) = (x/2)**v*SUM((-x**2/4)**k/(k!*GAMMA(v+k+1)))

    where the sum is for k from zero to infinity, GAMMA is the 
    Gamma function, and ! is the factorial function.
 
Syntax:
    LET <y2> = BESS1(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a decimal number, variable or a parameter;
          <y2> is a variable or a parameter (depending on what
               <y1> is) where the computed Bessel value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BESS1(-2)
    LET A = BESS1(A1)
    LET X2 = BESS1(X1)
    LET X2 = BESS1(X1-4)
 
Note:
    DATAPLOT uses the function BESJ1 from the SLATEC Common
    Mathematical Library to compute this function.  SLATEC is a large
    set of high quality, portable, public domain Fortran routines
    for various mathematical capabilities maintained by seven federal
    laboratories.

Note:
    Versions prior to September, 1994 used a different algorithm that
    did not allow input values less thant -3.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BESS0  = Compute the Bessel function of the first kind and order 0.
    BESSJN = Compute the Bessel function of the first kind and order N.
    BESSY1 = Compute the Bessel function of the second kind and 
             order 1.
    BESSI1 = Compute the modified Bessel function of order 1.
    BESSK1 = Compute the modified Bessel function of the third kind
             and order 1.
    BESSYN = Compute the Bessel function of the second kind and 
             order N.
    BESSIN = Compute the modified Bessel function of order N.
    BESSKN = Compute the modified Bessel function of the third kind
             and of order N.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (pages 355-433).
 
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", 2nd Edition, Press, Flannery, Teukolsky, and Vetterling.
    Cambridge University Press, 1992 (chapter 6).
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    TITLE AUTOMATIC
    PLOT BESS1(X) FOR X = -5 .1 5
 
-----BESSI0 (LET)--------------------------------
 
BESSI0
 
Name:
    BESSI0 (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the modified Bessel function of order 0.
 
Description:
    The modified Bessel function of the first kind with order v (v is a
    non-negative real number) can be defined as:

        Iv(x) = (x/2)**v*SUM((x**2/4)**k/(k!*GAMMA(v+k+1)))

    where the sum is for k from zero to infinity, GAMMA is the 
    Gamma function, and ! is the factorial function.

    The modified Bessel function can also be defined in terms of
    the Bessel function of the first kind:

        I(0)(x) = J(0)(ix)

    See the documentation for BESS0 for details on the J(0) function.

Syntax:
    LET <y2> = BESSI0(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a non-negative number, variable or parameter;
          <y2> is a variable or parameter (depending on what
               <y1> is) where the computed Bessel value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET X2 = BESSI0(2)
    LET A = BESSI0(2)
    LET A = BESSI0(A1)
 
Note:
    DATAPLOT uses the routine BESI0 from the SLATEC Common Mathematical
    Library to compute this function.  SLATEC is a large set of high
    quality, portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal laboratories.

Note:
    Although DATAPLOT does not allow negative orders, negative orders
    can be calculated with the following relation:

        I(-v) = I(v) + (2/PI)*SIN(v*PI)*K(v)

    where K(v) is the modified Bessel function of the third kind.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BESSI1  = Compute the modified Bessel function of order 1.
    BESSI0E = Compute the exponentially scaled modified Bessel function
              of order 0.
    BESSIN  = Compute the modified Bessel function of order N.
    BESSINE = Compute the exponentially scaled modified Bessel function
              of order N.
    BESSJN  = Compute the Bessel function of the first kind and order N.
    BESSIN  = Compute the modified Bessel function of order N.
    BESSKN  = Compute the modified Bessel function of the third kind
              and order N.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (pages 355-433).
 
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", 2nd Edition, Press, Flannery, Teukolsky, and Vetterling.
    Cambridge University Press, 1992 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE AUTOMATIC
    PLOT BESSI0(X) FOR X = .1 .1 10
 
-----BESSI0E (LET)--------------------------------
 
BESSI0E
 
Name:
    BESSI0E (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the exponentially scaled modified Bessel function of order 0.
 
Description:
    This function can be defined as:

        IE(1)(x) = EXP(-ABS(x))*I(0)(x)           x >= 0

    where I(0) is the modified Bessel function of order 0.  See the
    documentation for the BESSI0 command for a description of this 
    function.

Syntax:
    LET <y2> = BESSI0E(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a non-negative number, variable or parameter;
          <y2> is a variable or parameter (depending on what
               <y1> is) where the computed Bessel value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET X2 = BESSI0E(2)
    LET A = BESSI0E(2)
    LET A = BESSI0E(A1)
 
Note:
    DATAPLOT uses the routine BESI0E from the SLATEC Common Mathematical
    Library to compute this function.  SLATEC is a large set of high
    quality, portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BESSI0  = Compute the modified Bessel function of order 0.
    BESSI1  = Compute the modified Bessel function of order 1.
    BESSI1E = Compute the exponentially scaled modified Bessel function
              of order 1.
    BESSIN  = Compute the modified Bessel function of order N.
    BESSINE = Compute the exponentially scaled modified Bessel function
              of order N.
    BESSJN  = Compute the Bessel function of the first kind and order N.
    BESSIN  = Compute the modified Bessel function of order N.
    BESSKN  = Compute the modified Bessel function of the third kind
              and order N.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (pages 355-433).
 
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", 2nd Edition, Press, Flannery, Teukolsky, and Vetterling.
    Cambridge University Press, 1992 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE AUTOMATIC
    PLOT BESSI0E(X) FOR X = .1 .1 10
 
-----BESSI1 (LET)--------------------------------
 
BESSI1
 
Name:
    BESSI1 (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the modified Bessel function of order 1.
 
Description:
    The modified Bessel function of the first kind with order v (v is a
    non-negative real number) can be defined as:

        Iv(x) = (x/2)**v*SUM((x**2/4)**k/(k!*GAMMA(v+k+1)))

    where the sum is for k from zero to infinity, GAMMA is the 
    Gamma function, and ! is the factorial function.

    The modified Bessel function can also be defined in terms of
    the Bessel function of the first kind:

        I(1)(x) = J(1)(ix)

    See the documentation for BESS1 for details on the J(1) function.

Syntax:
    LET <y2> = BESSI1(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a non-negative number, variable or parameter;
          <y2> is a variable or parameter (depending on what
               <y1> is) where the computed Bessel value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET X2 = BESSI1(2)
    LET A = BESSI1(2)
    LET A = BESSI1(A1)
 
Note:
    DATAPLOT uses the routine BESI1 from the SLATEC Common Mathematical
    Library to compute this function.  SLATEC is a large set of high
    quality, portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal laboratories.

Note:
    Although DATAPLOT does not allow negative orders, negative orders
    can be calculated with the following relation:

        I(-v) = I(v) + (2/PI)*SIN(v*PI)*K(v)

    where K(v) is the modified Bessel function of the third kind.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BESSI0  = Compute the modified Bessel function of order 0.
    BESSI1E = Compute the exponentially scaled modified Bessel function
              of order 0.
    BESSIN  = Compute the modified Bessel function of order N.
    BESSINE = Compute the exponentially scaled modified Bessel function
              of order N.
    BESSJN  = Compute the Bessel function of the first kind and order N.
    BESSIN  = Compute the modified Bessel function of order N.
    BESSKN  = Compute the modified Bessel function of the third kind
              and order N.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (pages 355-433).
 
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", 2nd Edition, Press, Flannery, Teukolsky, and Vetterling.
    Cambridge University Press, 1992 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE AUTOMATIC
    PLOT BESSI1(X) FOR X = .1 .1 10
 
-----BESSI1E (LET)--------------------------------
 
BESSI1E
 
Name:
    BESSI1E (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the exponentially scaled modified Bessel function of
    order 1.
 
Description:
    This function can be defined as:

        IE(1)(x) = EXP(-ABS(x))*I(1)(x)         x >= 0

    where I(1) is the modified Bessel function.  See the documentation
    for the BESSI1 command for a description of this function.

Syntax:
    LET <y2> = BESSI1E(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a non-negative number, variable or parameter;
          <y2> is a variable or parameter (depending on what
               <y1> is) where the computed Bessel value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET X2 = BESSI1E(2)
    LET A = BESSI1E(2)
    LET A = BESSI1E(A1)
 
Note:
    DATAPLOT uses the routine BESIE1 from the SLATEC Common Mathematical
    Library to compute this function.  SLATEC is a large set of high
    quality, portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BESSI0  = Compute the modified Bessel function of order 0.
    BESSI0E = Compute the exponentially scaled modified Bessel function
              of order 0.
    BESSI1  = Compute the modified Bessel function of order 1.
    BESSIN  = Compute the modified Bessel function of order N.
    BESSINE = Compute the exponentially scaled modified Bessel function
              of order N.
    BESSJN  = Compute the Bessel function of the first kind and order N.
    BESSIN  = Compute the modified Bessel function of order N.
    BESSKN  = Compute the modified Bessel function of the third kind
              and order N.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (pages 355-433).
 
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", 2nd Edition, Press, Flannery, Teukolsky, and Vetterling.
    Cambridge University Press, 1992 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE AUTOMATIC
    PLOT BESSI1E(X) FOR X = .1 .1 10
 
-----BESSIN (LET)--------------------------------
 
BESSIN
 
Name:
    BESSIN (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the modified Bessel function of order v where v is a
    non-negative real number.
 
Description:
    The modified Bessel function of the first kind with order v (v is a
    non-negative real number) can be defined as:

        Iv(x) = (x/2)**v*SUM((x**2/4)**k/(k!*GAMMA(v+k+1)))

    where the sum is for k from zero to infinity, GAMMA is the 
    Gamma function, and ! is the factorial function.

    The modified Bessel function can also be defined in terms of
    the Bessel function of the first kind:

        I(v)(x) = J(v)(ix)

    See the documentation for BESSJN for details on the J(v) function.

Syntax:
    LET <y2> = BESSIN(<y1>,<v>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a non-negative number, variable or parameter;
          <y2> is a variable or a parameter (depending on what
               <y1> is) where the computed Bessel value is stored;
          <v> is a non-negative number, variable, or parameter that
               specifies the order of the Bessel function;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET X2 = BESSIN(2,2)
    LET A = BESSIN(2,2.5)
    LET A = BESSIN(A1,3)
 
Note:
    DATAPLOT uses the routine BESI from the SLATEC Common Mathematical
    Library to compute this function.  SLATEC is a large set of high
    quality, portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal laboratories.

Note:
    Although DATAPLOT does not allow negative orders, negative orders
    can be calculated with the following relation:

        I(-v) = I(v) + (2/PI)*SIN(v*PI)*K(v)

    where K(v) is the modified Bessel function of the third kind.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BESSI0  = Compute the modified Bessel function of order 0.
    BESSI1  = Compute the modified Bessel function of order 1.
    BESSINE = Compute the exponentially scaled modified Bessel function
              of order N.
    BESSJN  = Compute the Bessel function of the first kind and order N.
    BESSIN  = Compute the modified Bessel function of order N.
    BESSKN  = Compute the modified Bessel function of the third kind
              and order N.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (pages 355-433).
 
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", 2nd Edition, Press, Flannery, Teukolsky, and Vetterling.
    Cambridge University Press, 1992 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE MODIFIED BESSEL FUNCTIONS
    LINE SOLID DASH DOT
    PLOT BESSIN(X,2) FOR X = .1 .1 10 AND
    PLOT BESSIN(X,2.5) FOR X = .1 .1 10 AND
    PLOT BESSIN(X,3) FOR X = .1 .1 10
 
-----BESSINE (LET)--------------------------------
 
BESSINE
 
Name:
    BESSINE (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the exponentially scaled modified Bessel function of order
    v where v is a non-negative real number.
 
Description:
    This function is defined to be:

        IE(n)(x) = EXP(-x)*I(v)(x)      x > = 0

    where I(v) is the modified Bessel function of order v.  See the
    documentation for BESSIN for details of the modfied Bessel
    function.

Syntax:
    LET <y2> = BESSINE(<y1>,<v>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a non-negative number, variable or parameter;
          <y2> is a variable or a parameter (depending on what
               <y1> is) where the computed Bessel value is stored;
          <v> is a non-negative number, variable, or parameter that
               specifies the order of the Bessel function;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET X2 = BESSINE(2,2)
    LET A = BESSINE(2,2.5)
    LET A = BESSINE(A1,3)
 
Note:
    DATAPLOT uses the routine BESIE from the SLATEC Common Mathematical
    Library to compute this function.  SLATEC is a large set of high
    quality, portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BESSI0  = Compute the modified Bessel function of order 0.
    BESSI1  = Compute the modified Bessel function of order 1.
    BESSIN  = Compute the modified Bessel function of order N.
    BESSJN  = Compute the Bessel function of the first kind and order N.
    BESSIN  = Compute the modified Bessel function of order N.
    BESSKN  = Compute the modified Bessel function of the third kind
              and order N.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (pages 355-433).
 
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", 2nd Edition, Press, Flannery, Teukolsky, and Vetterling.
    Cambridge University Press, 1992 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE MODIFIED BESSEL FUNCTIONS
    LINE SOLID DASH DOT
    PLOT BESSINE(X,2) FOR X = .1 .1 10 AND
    PLOT BESSINE(X,2.5) FOR X = .1 .1 10 AND
    PLOT BESSINE(X,3) FOR X = .1 .1 10
 
-----BESSJN (LET)--------------------------------
 
BESSJN
 
Name:
    BESSJN (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Bessel function of the first kind and order v where
    v is a non-negative real number.
 
Description:
    The Bessel function of the first kind with order v (v is a
    non-negative real number) can be defined as:

        Jv(x) = (x/2)**v*SUM((-x**2/4)**k/(k!*GAMMA(v+k+1)))

    where the sum is for k from zero to infinity, GAMMA is the 
    Gamma function, and ! is the factorial function.
 
Syntax:
    LET <y2> = BESSJN(<y1>,<v>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a decimal number, variable or parameter;
          <y2> is a variable or a parameter (depending on what
               <y1> is) where the computed Bessel value is stored;
          <v> is a non-negative number, variable, or parameter that
               specifies the order of the Bessel function;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET X2 = BESSJN(2,2)
    LET A = BESSJN(2,2.5)
    LET A = BESSJN(A1,3)
    LET X2 = BESSJN(X1-4,1.5)
 
Note:
    DATAPLOT uses the routine BESJ from the SLATEC Common Mathematical
    Library to compute this function.  SLATEC is a large set of high
    quality, portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal laboratories.

Note:
    DATAPLOT does not calculate this function for negative orders.
    However, the following relation can be used:

       J(-v) = COS(v*PI)*J(v) - SIN(v*PI)*Y(v)

    where Y(v) is the Bessel function of the second kind.  See the
    documentation for the BESSYN command for further details on this
    function.

Note:
    Spherical Bessel functions can be defined for integer n by:
    
        j(n)(x) = SQRT(PI/(2x))*J(n+0.5)(x)

    The second program example shows how to plot a spherical Bessel
    function.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BESS0  = Compute the Bessel function of the first kind and order 0.
    BESS1  = Compute the Bessel function of the first kind and order 1.
    BESSYN = Compute the Bessel function of the second kind and 
             order N.
    BESSIN = Compute the modified Bessel function of order N.
    BESSKN = Compute the modified Bessel function of the third kind
             and order N.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (pages 355-433).
 
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", 2nd Edition, Press, Flannery, Teukolsky, and Vetterling.
    Cambridge University Press, 1992 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9.
 
Program 1:
    TITLE BESSEL FUNCTIONS
    LINE SOLID DASH DOT
    PLOT BESSJN(X,2) FOR X = -10 .1 10 AND
    PLOT BESSJN(X,2.5) FOR X = -10 .1 10 AND
    PLOT BESSJN(X,3) FOR X = -10 .1 10
 
Program 2:
    TITLE SPHERICAL BESSEL FUNCTIONS (N = 2, 3, 4)
    LINE SOLID DASH DOT
    LET FACT = SQRT(PI/2)
    PLOT (FACT/SQRT(X))*BESSJN(X,2.5) FOR X = -10 .1 10 AND
    PLOT (FACT/SQRT(X))*BESSJN(X,3.5) FOR X = -10 .1 10 AND
    PLOT (FACT/SQRT(X))*BESSJN(X,4.5) FOR X = -10 .1 10

-----BESSK0 (LET)--------------------------------
 
BESSK0
 
Name:
    BESSK0 (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the modified Bessel function of the third kind and order 0.
 
Description:
    The modified Bessel function of the third kind can be defined in
    terms of the modified Bessel function of the first kind:

        K(v)(x) = (PI/2)*(I(-v)(x) - I(v)(x))/SIN(PI*v)   x > 0

    where I(v) is the modified Bessel function of the first kind.  See
    the documentation for BESSIN for details on the I(v) function.

Syntax:
    LET <y2> = BESSK0(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a positive number, variable or parameter;
          <y2> is a variable or a parameter (depending on what
               <y1> is) where the computed Bessel value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET X2 = BESSK0(2)
    LET A = BESSK0(6)
    LET A = BESSK0(A1)
 
Note:
    DATAPLOT uses the routine BESK0 from the SLATEC Common Mathematical
    Library to compute this function.  SLATEC is a large set of high
    quality, portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BESSK1  = Compute the modified Bessel function of the third kind
              and order 1.
    BESSKN  = Compute the modified Bessel function of the third kind
              and order N.
    BESSKNE = Compute the exponentially scaled modified Bessel function
              of the third kind and order N.
    BESSJ0  = Compute the Bessel function of the first kind and order 0.
    BESSI0  = Compute the modified Bessel function of order 0.
    BESSY0  = Compute the Bessel function of the second kind and 
              order 0.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (pages 355-433).
 
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", 2nd Edition, Press, Flannery, Teukolsky, and Vetterling.
    Cambridge University Press, 1992 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE AUTOMATIC
    PLOT BESSK0(X) FOR X = .1 .1 10
 
-----BESSK0E (LET)--------------------------------
 
BESSK0E
 
Name:
    BESSK0E (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the exponentially scaled modified Bessel function of the
    third kind and order 0.
 
Description:
    This function can be defined as:

        KE(0)(x) = EXP(x)*K(0)(x)         x > 0

    where K(0) is the modified Bessel function of the third kind.  See
    the documentation for the BESSK0 command for a description of this
    function.

Syntax:
    LET <y2> = BESSK0E(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a positive number, variable or parameter;
          <y2> is a variable or a parameter (depending on what
               <y1> is) where the computed Bessel value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET X2 = BESSK0E(2)
    LET A = BESSK0E(6)
    LET A = BESSK0E(A1)
 
Note:
    DATAPLOT uses the routine BESK0E from the SLATEC Common Mathematical
    Library to compute this function.  SLATEC is a large set of high
    quality, portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BESSK0  = Compute the modified Bessel function of the third kind
              and order 0.
    BESSK1  = Compute the modified Bessel function of the third kind
              and order 1.
    BESSKN  = Compute the modified Bessel function of the third kind
              and order N.
    BESSK1E = Compute the exponentially scaled modified Bessel function
              of the third kind and order 1.
    BESSKNE = Compute the exponentially scaled modified Bessel function
              of the third kind and order N.
    BESSJ0  = Compute the Bessel function of the first kind and order 0.
    BESSI0  = Compute the modified Bessel function of order 0.
    BESSY0  = Compute the Bessel function of the second kind and 
              order 0.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (pages 355-433).
 
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", 2nd Edition, Press, Flannery, Teukolsky, and Vetterling.
    Cambridge University Press, 1992 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE AUTOMATIC
    PLOT BESSK1(X) FOR X = .1 .1 10
 
-----BESSK1 (LET)--------------------------------
 
BESSK1
 
Name:
    BESSK1 (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the modified Bessel function of the third kind and order 1.
 
Description:
    The modified Bessel function of the third kind can be defined in
    terms of the modified Bessel function of the first kind:

        K(v)(x) = (PI/2)*(I(-v)(x) - I(v)(x))/SIN(PI*v)   x > 0

    where I(v) is the modified Bessel function of the first kind.  See
    the documentation for BESSIN for details on the I(v) function.

Syntax:
    LET <y2> = BESSK1(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a positive number, variable or parameter;
          <y2> is a variable or a parameter (depending on what
               <y1> is) where the computed Bessel value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET X2 = BESSK1(2)
    LET A = BESSK1(6)
    LET A = BESSK1(A1)
 
Note:
    DATAPLOT uses the routine BESK1 from the SLATEC Common Mathematical
    Library to compute this function.  SLATEC is a large set of high
    quality, portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BESSK0  = Compute the modified Bessel function of the third kind
              and order 0.
    BESSKN  = Compute the modified Bessel function of the third kind
              and order N.
    BESSKNE = Compute the exponentially scaled modified Bessel function
              of the third kind and order N.
    BESSJ1  = Compute the Bessel function of the first kind and order 1.
    BESSI1  = Compute the modified Bessel function of order 1.
    BESSY1  = Compute the Bessel function of the second kind and 
              order 1.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (pages 355-433).
 
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", 2nd Edition, Press, Flannery, Teukolsky, and Vetterling.
    Cambridge University Press, 1992 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE AUTOMATIC
    PLOT BESSK1(X) FOR X = .1 .1 10
 
-----BESSK1E (LET)--------------------------------
 
BESSK1E
 
Name:
    BESSK1E (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the exponentially scaled modified Bessel function of the
    third kind and order 1.
 
Description:
    This function can be defined as:

        KE(1)(x) = EXP(x)*K(1)(x)         x >= 0

    where K(1) is the modified Bessel function of the third kind.  See
    the documentation for the BESSK1 command for a description of this
    function.

Syntax:
    LET <y2> = BESSK1E(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a positive number, variable or parameter;
          <y2> is a variable or a parameter (depending on what
               <y1> is) where the computed Bessel value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET X2 = BESSK1E(2)
    LET A = BESSK1E(6)
    LET A = BESSK1E(A1)
 
Note:
    DATAPLOT uses the routine BESK1E from the SLATEC Common Mathematical
    Library to compute this function.  SLATEC is a large set of high
    quality, portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BESSK0  = Compute the modified Bessel function of the third kind
              and order 0.
    BESSK1  = Compute the modified Bessel function of the third kind
              and order 1.
    BESSKN  = Compute the modified Bessel function of the third kind
              and order N.
    BESSK0E = Compute the exponentially scaled modified Bessel function
              of the third kind and order 0.
    BESSKNE = Compute the exponentially scaled modified Bessel function
              of the third kind and order N.
    BESSJ1  = Compute the Bessel function of the first kind and order 1.
    BESSI1  = Compute the modified Bessel function of order 1.
    BESSY1  = Compute the Bessel function of the second kind and 
              order 1.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (pages 355-433).
 
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", 2nd Edition, Press, Flannery, Teukolsky, and Vetterling.
    Cambridge University Press, 1992 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE AUTOMATIC
    PLOT BESSK1E(X) FOR X = .1 .1 10
 
-----BESSKN (LET)--------------------------------
 
BESSKN
 
Name:
    BESSKN (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the modified Bessel function of the third kind and order v
    where v is a non-negative real number.
 
Description:
    The modified Bessel function of the third kind can be defined in
    terms of the modified Bessel function of the first kind:

        K(v)(x) = (PI/2)*(I(-v)(x) - I(v)(x))/SIN(PI*v)   x > 0

    where I(v) is the modified Bessel function of the first kind.  See
    the documentation for BESSIN for details on the I(v) function.

Syntax:
    LET <y2> = BESSKN(<y1>,<v>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a positive number, variable or parameter;
          <y2> is a variable or a parameter (depending on what
               <y1> is) where the computed Bessel value is stored;
          <v> is a non-negative number, variable, or parameter that
               specifies the order of the Bessel function;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET X2 = BESSKN(2,2)
    LET A = BESSKN(2,2.5)
    LET A = BESSKN(A1,3)
 
Note:
    DATAPLOT uses the routine BESK from the SLATEC Common Mathematical
    Library to compute this function.  SLATEC is a large set of high
    quality, portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal laboratories.

Note:
    Although DATAPLOT does not allow negative orders, negative orders
    can be calculated with the following relation:

        K(-v) = K(v)

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BESSK0  = Compute the modified Bessel function of the third kind
              and order 0.
    BESSK1  = Compute the modified Bessel function of the third kind
              and order 1.
    BESSKNE = Compute the exponentially scaled modified Bessel function
              of the third kind and order N.
    BESSJN  = Compute the Bessel function of the first kind and order N.
    BESSIN  = Compute the modified Bessel function of order N.
    BESSYN  = Compute the Bessel function of the second kind and 
              order N.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (pages 355-433).
 
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", 2nd Edition, Press, Flannery, Teukolsky, and Vetterling.
    Cambridge University Press, 1992 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE MODIFIED BESSEL FUNCTIONS OF THE THIRD KIND
    LINE SOLID DASH DOT
    PLOT BESSKN(X,2) FOR X = .1 .1 10 AND
    PLOT BESSKN(X,2.5) FOR X = .1 .1 10 AND
    PLOT BESSKN(X,3) FOR X = .1 .1 10
 
-----BESSKNE (LET)--------------------------------
 
BESSKNE
 
Name:
    BESSKNE (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the exponentially scaled modified Bessel function of the
    third kind and order v where v is a non-negative real number.

Description:
    This function can be defined as:

        KE(v)(x) = EXP(x)*K(v)(x)          x > 0

    where K(v) is the modified Bessel function of the third kind.  See
    the documentation for BESSKN for details on the I(v) function.

Syntax:
    LET <y2> = BESSKNE(<y1>,<v>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a positive number, variable or parameter;
          <y2> is a variable or a parameter (depending on what
               <y1> is) where the computed Bessel value is stored;
          <v> is a non-negative number, variable, or parameter that
               specifies the order of the Bessel function;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET X2 = BESSKNE(2,2)
    LET A = BESSKNE(2,2.5)
    LET A = BESSKNE(A1,3)
 
Note:
    DATAPLOT uses the routine BESK from the SLATEC Common Mathematical
    Library to compute this function.  SLATEC is a large set of high
    quality, portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BESSK0  = Compute the modified Bessel function of the third kind
              and order 0.
    BESSK1  = Compute the modified Bessel function of the third kind
              and order 1.
    BESSKN  = Compute the modified Bessel function of the third kind
              and order N.
    BESSJN  = Compute the Bessel function of the first kind and order N.
    BESSIN  = Compute the modified Bessel function of order N.
    BESSYN  = Compute the Bessel function of the second kind and 
              order N.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (pages 355-433).
 
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", 2nd Edition, Press, Flannery, Teukolsky, and Vetterling.
    Cambridge University Press, 1992 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE EXPONENTIALLY SCALED MODIFIED BESSEL FUNCTIONS OF THE THIRD KIND
    LINE SOLID DASH DOT
    PLOT BESSKNE(X,2) FOR X = .1 .1 10 AND
    PLOT BESSKNE(X,2.5) FOR X = .1 .1 10 AND
    PLOT BESSKNE(X,3) FOR X = .1 .1 10
 
-----BESSY0 (LET)--------------------------------
 
BESSY0
 
Name:
    BESSY0 (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Bessel function of the second kind and order 0.
 
Description:
    The definition of Bessel functions of the second kind with order v
    (v is a non-negative real number) is:

        Yv(x) = (Jv(x)*COS(v*PI) - J-v(x))/SIN(v*PI)    X > 0

    where Jv is the Bessel function of the first kind.  See the
    documentation for BESSJN for a description of this function.
    For integer v, the above formula is the limit as v approaches 
    that integer.
 
Syntax:
    LET <y2> = BESSY0(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a positive decimal number, variable or parameter;
          <y2> is a variable or a parameter (depending on what
               <y1> is) where the computed Bessel value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET X2 = BESSY0(2)
    LET A = BESSY0(A1)
 
Note:
    DATAPLOT uses the routine BESY0 from the SLATEC Common Mathematical
    Library to compute this function.  SLATEC is a large set of high
    quality, portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BESSY1 = Compute the Bessel function of the second kind and
             order 1.
    BESSYN = Compute the Bessel function of the second kind and 
             order N.
    BESSJ0 = Compute the Bessel function of the first kind of order 0.
    BESSI0 = Compute the modified Bessel function of order 0.
    BESSK0 = Compute the modified Bessel function of the third kind
             and order 0.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (pages 355-433).
 
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", 2nd Edition, Press, Flannery, Teukolsky, and Vetterling.
    Cambridge University Press, 1992 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE AUTOMATIC
    PLOT BESSY0(X) FOR X = .1 .1 10

-----BESSY1 (LET)--------------------------------
 
BESSY1
 
Name:
    BESSY1 (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Bessel function of the second kind and order 1.
 
Description:
    The definition of Bessel functions of the second kind with order v
    (v is a non-negative real number) is:

        Yv(x) = (Jv(x)*COS(v*PI) - J-v(x))/SIN(v*PI)    X > 0

    where Jv is the Bessel function of the first kind.  See the
    documentation for BESSJN for a description of this function.
    For integer v, the above formula is the limit as v approaches 
    that integer.
 
Syntax:
    LET <y2> = BESSY1(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a positive decimal number, variable or parameter;
          <y2> is a variable or a parameter (depending on what
               <y1> is) where the computed Bessel value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET X2 = BESSY1(2)
    LET A = BESSY1(A1)
 
Note:
    DATAPLOT uses the routine BESY1 from the SLATEC Common Mathematical
    Library to compute this function.  SLATEC is a large set of high
    quality, portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal laboratories.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BESSY0 = Compute the Bessel function of the second kind and
             order 0.
    BESSYN = Compute the Bessel function of the second kind and 
             order N.
    BESSJ1 = Compute the Bessel function of the first kind of order 1.
    BESSI1 = Compute the modified Bessel function of order 1.
    BESSK1 = Compute the modified Bessel function of the third kind
             and order 1.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (pages 355-433).
 
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", 2nd Edition, Press, Flannery, Teukolsky, and Vetterling.
    Cambridge University Press, 1992 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE AUTOMATIC
    PLOT BESSY1(X) FOR X = .1 .1 10

-----BESSYN (LET)--------------------------------
 
BESSYN
 
Name:
    BESSYN (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Bessel function of the second kind and order v where
    v is a non-negative real number.
 
Description:
    The definition of Bessel functions of the second kind with order v
    (v is a non-negative real number) is:

        Yv(x) = (Jv(x)*COS(v*PI) - J-v(x))/SIN(v*PI)    X > 0

    where Jv is the Bessel function of the first kind.  See the
    documentation for BESSJN for a description of this function.
    For integer v, the above formula is the limit as v approaches 
    that integer.
 
Syntax:
    LET <y2> = BESSYN(<y1>,<v>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a positive decimal number, variable or parameter;
          <y2> is a variable or a parameter (depending on what
               <y1> is) where the computed Bessel value is stored;
          <v> is a non-negative number, variable, or parameter that
               specifies the order of the Bessel function;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET X2 = BESSYN(2,2)
    LET A = BESSYN(2,2.5)
    LET A = BESSYN(A1,3)
 
Note:
    DATAPLOT uses the routine BESY from the SLATEC Common Mathematical
    Library to compute this function.  SLATEC is a large set of high
    quality, portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal laboratories.

Note:
    DATAPLOT does not calculate this function for negative orders.
    However, the following relation can be used:

       Y(-v) = SIN(v*PI)*J(v) + COS(v*PI)*Y(v)

    where J(v) is the Bessel function of the second kind.  See the
    documentation for the BESSJN command for further details on this
    function.

Note:
    Spherical Bessel functions can be defined for integer n by:
    
        y(n)(x) = SQRT(PI/(2x))*Y(n+0.5)(x)

    The second program example shows how to plot a spherical Bessel
    function.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BESSY0 = Compute the Bessel function of the second kind and
             order 0.
    BESSY1 = Compute the Bessel function of the second kind and
             order 1.
    BESSYN = Compute the Bessel function of the second kind and 
             order N.
    BESSIN = Compute the modified Bessel function of order N.
    BESSKN = Compute the modified Bessel function of the third kind
             and order N.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (pages 355-433).
 
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", 2nd Edition, Press, Flannery, Teukolsky, and Vetterling.
    Cambridge University Press, 1992 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9.
 
Program 1:
    TITLE BESSEL FUNCTIONS
    LINE SOLID DASH DOT
    PLOT BESSYN(X,2) FOR X = .1 .1 10 AND
    PLOT BESSYN(X,2.5) FOR X = .1 .1 10 AND
    PLOT BESSYN(X,3) FOR X = .1 .1 10
 
Program 2:
    TITLE SPHERICAL BESSEL FUNCTIONS (N = 2, 3, 4)
    LINE SOLID DASH DOT
    LET FACT = SQRT(PI/2)
    PLOT (FACT/SQRT(X))*BESSYN(X,2.5) FOR X = .1 .1 10 AND
    PLOT (FACT/SQRT(X))*BESSYN(X,3.5) FOR X = .1 .1 10 AND
    PLOT (FACT/SQRT(X))*BESSYN(X,4.5) FOR X = .1 .1 10

-----BEST CP---------------------------------
 
BEST CP
 
Name:
    BEST CP
 
Type:
    Analysis Command
 
Purpose:
    Performs a best CP analysis.
 
Description:
    In multilinear regression, a common task is to determine
    the "best" set of independent variables to use in the
    fit.  There are three basic approaches to this problem:

       1) Perform all regressions and pick the best candidate
          models from this list.   This is called "all subsets"
          regression.
       2) Start with one independent variable that provides the
          best fit for models containing only one independent
          variable.  Then at each step, add one more independent
          variable from the remaining variables that provides
          the most improvement in the fit.  Continue until adding
          an additional variable results in no significant
          improvement in the model.  This is called
          "forward stepwise" regression.
       3) "Backward stepwise" regression is similar to forward
          stepwise regression.  However, instead of starting
          with one indpendent variable and adding one at each
          stage, the initial model contains all the independent
          variable.  Then one variable is deleted at each
          stage until the best model is reached.

    There can be some variations in the above approaches.  For
    example,

       1) Different critierion have been proposed for deciding
          which variable to add/delete at a given step in
          forward/backward stepwise regression.
       2) Different criterion have been proposed for deciding
          when to quit adding/deleting variables in 
          forward/backward stepwise regression.
       3) Some algorithms allow an entered variable
          to be removed at a later step.

    The choice of these critierion is complicated by the
    fact that adding additional variables will always increase
    the R**2 of the fit (or at least not decrease it).  However,
    including too many variables increase multicolinearity which
    results in  numerically unstable models (i.e., you are
    essentially fitting noise).  In addition, the model becomes
    more complex than it needs to be.  A number of critierion
    have been proposed that attempt to balance maximizing the
    fit while trying to protect against overfitting.
    
    All subsets regression is the preferred algorithm in that
    it examines all models.  However, it can be computationally
    impractical to perform all subsets regression when the
    number of independent variables becomes large.  The
    primary disadvantage of forward/backward stepwise regression
    is that it may miss good candidate models.  Also, they
    pick a single model rather than a list of good candidate
    models that can be examined closer.
    
    Dataplot addresses this issue with the BEST CP command.
    This is based on the following:

       1) It implements the "leaps and bounds" algorithm of
          Furnival and Wilson (see reference below).  This
          algorithm is a compromise between all subsets
          regression and forward/backward stepwise regression.
          It provides an efficient algorithm for identifying
          the best candidate models without actually computing
          all possible models.  It thus provides the advantage
          of all subset regressions (i.e., all potential
          models are included)  while remaining computationally
          practical for a large number of indpendent variables.

       2) Dataplot uses the Mallow's Cp critierion (suggested
          by Mallows, see References below).  The C(p) statistic
          is defined as follows:

             C(p) = RSS(p)/(sigmahat)**2 + 2*p - n

          where

             n            = the number of observations
             p            = the number of variables in the
                            regression
             RSS(p)       = the residual sum of squares using p
                            variables
             sigmahat**2  = an independent estimate of the error

          The residual variance from the full model is used as
          the estimate of sigmahat**2.

          If the model is satisfactory, C(p) will be approximately
          equal to p.

    It should be emphasized that the BEST CP command is intended
    simply to identify good candidate models.  Also, the BEST CP
    command uses a computationally fast algorithm that is not as
    accurate as the algorithm used by the FIT command.  The
    FIT command should be applied to all identified models that
    are of interest.  Also, standard regression diagnostics
    should be examined to the candidate models of interest.

Syntax:
    BEST CP <y> <x1> ... <xk>
                  <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response (dependent) variable;
          <x1> .... <xk> is a list of one or more independent
              variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    BEST CP Y X1 X2 X3 X4 X5 X6 X7
    BEST CP Y X1 X2 X3 X4 X5 X6 X7  SUBSET TAG > 1
 
Note:
    The BEST CP commands requires at least three indpendent
    variables and at most 38 independent variables.

Note:
    By default, the BEST CP command returns the 10 best candidate
    models (7 if there only three independent variables).  Note
    that more than 10 may actually be returned.  This is due
    to the fact that additional models may be "free" in the
    leaps and bounds computations.

    To change the number of candidate models chosen, enter the
    command

        SET NUMBER OF CP <value>

    where <value> identifies the number of candidate models.

    Note that increasing <value> will result in greater
    time to generate the best candidate models.  In most cases,
    the default value of 10 is adequate.

Note:
    It can be helpful to plot the results of the BEST CP command.

    Dataplot writes the results of the CP analysis to file.  The
    example program below shows how to generate a CP plot using
    these files.  Specifically,

       1) The C(p) statistic and the corresponding model is
          written to "dpst1f.dat".  The following is a sample
          dpst1f.dat file:

               1 138.731 : X4
               1 142.487 : X2
               1 202.549 : X1
               1 315.155 : X3
               2   2.678 : X1       X2
               2   5.496 : X1       X4
               2  22.373 : X3       X4
               2  62.438 : X2       X3
               2 138.226 : X2       X4
               3   3.018 : X1       X2       X4
               3   3.041 : X1       X2       X3
               3   3.497 : X1       X3       X4
               3   7.338 : X2       X3       X4
               4   5.000 : X1       X2       X3       X4

       2) A coded form of the model is written to the file
          "dpst2f.dat".  This coded form is useful as an
          identifying plot character in a CP plot.  The rows
          of dpst1f.dat correspond to the rows of dpst2f.dat.
          The following is a sample dpst2f.dat file:

               4
               2
               1
               3
               12
               14
               34
               23
               24
               124
               123
               134
               234
               1234

Note:
    Dataplot uses code from OMNITAB to implement the BEST CP comamnd.

Note:
    The Mallows CP statistic can be affected by outliers.  This
    is discussed by Ryan (see References below).  Currently,
    Dataplot makes no provisions for outliers in the BEST CP
    command.

Note:
    Akaike introduced the concept of information criterion for model
    selection.  Information criterion are based on penalizing the
    likelihood based on the number of parameters in the model.  Akaike's
    original formulation is referred to as AIC (Akaike Information
    Critierion) and has been shown to be equivalent to Mallow's CP
    in the case of linear regression by Boisbunon, Canu, Fourdrinier,
    Strawderman, and Wells (2013).

    Schwarz introduced an alternative information critierion called the
    Bayesian Information Critierion (BIC).  The BIC penalizes the
    likelihood more than the AIC for additional parameters.  For large
    n, the BIC can be approximated by

        BIC = -2*LN(Lhat) + k*LN(n)

    Lhat is the maximized value of the likelihood function.  In the context
    of regression, the BIC can be computed as

       BIC = n*log(resvar) + k*log(n)

    where

       n       = sample size
       k       = the number of estimated coefficients
       resvar  = SUM[i=1 to n][(Y(i) - Ypred)**2]/n

    The 2013/10 version of Dataplot added the BIC value for the selected
    models to the output.  Note that the models are selected on the basis
    of Mallow's CP, not BIC.  BIC is provided as an additional comparison.

Default:
    10 candidate models are extracted

Synonyms:
    None
 
Related Commands:
    FIT                     = Perform linear/nonlinear fitting.
    PARTIAL RESIDUAL PLOT   = Generate a partial residual plot.
    PARTIAL REGRESSION PLOT = Generate a partial regression plot.
    PARTIAL LEVERAGE PLOT   = Generate a partial leverage plot.
    PARTIAL CCPR PLOT       = Generate a CCPR plot.
    PLOT                    = Generates a data/function plot.
 
Reference:
    Furnival and Wilson (1974), "Regression by Leaps and Bounds,"
    Technometrics, Vol. 16, No. 4.
 
    C. L. Mallows (1966), "Choosing a Subset Regression,"
    Joint Statistical Meetings, Los Angeles, CA.

    Sally Peavy, Shirley Bremer, Ruth Varner, and David Hogben (1986),
    "OMNITAB 80: An Interpretive System for Statistical and Numerical
    Data Analysis," NIST Special Publication 701.

    Thomas Ryan (1997), "Modern Regresion Methods," John Wiley.

    Boisbunon A. et. al. (2013),"AIC and Cp as estimators of loss for
    spherically symmetric distributions", arXiv:1308.2766.
 
    Schwarz (1978), "Estimating the dimension of a model," Annals of
    Statistics, Vol. 6, No. 2, pp. 461–464.

Applications:
    Multilinear Fitting
 
Implementation Date:
    2002/7
    2013/10: Reformatted output
    2013/10: Added BIC to output
 
Program:
    skip 25
    read hald647.dat y x1 x2 x3 x4
    .
    echo on
    capture junk.dat
    best cp y x1 x2 x3 x4
    end of capture
    .
    skip 0
    read dpst1f.dat p cp
    read row labels dpst2f.dat
    title case asis
    label case asis
    character rowlabels
    line blank
    tic offset units data
    xtic offset 0.3 0.3
    ytic offset 10 0
    let maxp = maximum p
    major xtic mark number maxp
    xlimits 1 maxp
    title Best CP Plot (HALD647.DAT Example)
    x1label P
    y1label C(p)
    plot cp p
    line solid
    draw data 1 1 maxp maxp
 
-----BEST DISTRIBUTIONAL FIT------------------------------------
 
BEST DISTRIBUTIONAL FIT
 
Name:
    BEST DISTRIBUTIONAL FIT
 
Type:
    Analysis Command
 
Purpose:
    Generate a ranked list of best distributional fit for univariate
    data.
 
Description:
    A common task is to find a good distributional fit to a set of
    univariate data.  This command can be used as a screening tool
    to identify good candidate models.

    There are two steps in this process:

        1) Fitting
        2) Ranking by a goodness of fit critierion

    You can specify the fit method with the command

         SET BEST FIT METHOD <value>

    where <value> is one of the following

         MAXIMUM LIKELIHOOD:        maximum likelihood
         PPCC:                      PPCC goodness of fit
         ANDERSON DARLING:          Anderson-Darling goodness of fit
         KOLMOGOROV SMIRNOV:        Kolmogorov-Smirnov goodness of fit

    The default method is maximum likelihood.

    You can specify the goodness of fit critierion with the command

         SET BEST FIT CRITERION <value>

    where <value> is one of the following

         ANDERSON DARLING:          Anderson-Darling
         KOLMOGOROV SMIRNOV:        Kolmogorov-Smirnov
         PPCC:                      PPCC
         AIC:                       Akaike Information Criterion
         AICc:                      Akaike Information Criterion with
                                    sample size adjustment
         BIC:                       Bayesian Information Critierion 

    The default goodness of fit criterion is Anderson-Darling.

    Note that this command is intended strictly as a screening tool
    to identify good candidate distributions.  You should perform
    a more complete analysis once you identify appropriate candidate
    distributions.  Also, you may be able to improve the fit for
    certain distributions by fine tuning the starting values.

    We do not recommend simply selecting the "best" distribution from
    the list.  Rather this command is meant to identify good
    candidate models that should be examined more carefully.
    For example, a simpler distribution that provides
    nearly as good a fit as a more complicated distribution may be
    preferred.  In some cases, a distribution that has a more
    meaningful physical interpretation or has established usage in
    a given area of work may be preferred.

    For performance reasons, not all possible distributions are
    included.

Syntax 1:
    BEST DISTRIBUTIONAL FIT  <y>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    For this syntax, the response variable can be a matrix.

Syntax 2:
    MULTIPLE BEST DISTRIBUTIONAL FIT  <y1> ... <yk>
                                      <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of 1 to 30 response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax generates a best distributional analysis for each
    listed response variable.  These response variables can be matrices.

Syntax 3:
    REPLICATED BEST DISTRIBUTIONAL FIT  <y> <x1> ... <xk>
                                   <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <x1> ... <xk> is a list of 1 to 6 group-id variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax peforms a cross-tabulation of <x1> ... <xk> and performs
    the best distributional fit analysis for each unique combination of
    cross-tabulated values.  For example, if X1 has 3 levels and X2 has
    2 levels, there will be a total of 6 best distributional fit
    analyses performed.

Examples:
    BEST DISTRIBUTIONAL FIT Y
    BEST DISTRIBUTIONAL FIT Y  SUBSET TAG = 1
    MULTIPLE BEST DISTRIBUTIONAL FIT Y1 TO Y5
    REPLICATED BEST DISTRIBUTIONAL FIT Y X

Note:
    This command is currently limited to raw data (i.e., not binned)
    and continuous distributions.

Note:
    If fitting is performed using maximum likelihood, the generalzied
    Pareto and generalized extreme value distributions will be fit
    using the elemental percentileds method.  This is done since the
    maximum likelihood, moment, and L-moment estimates may not be
    valid for certain ranges of the distribution parameters.

    Also, distributions that expect all positive (or negative) numbers
    will be shifted appropriately before performing the maximum
    likelihood estimation.

    Since this command is intended as a quick screening method, not all
    methods for which Dataplot supports maximum likelihood estimation
    are included.

Note:
    If fitting is performed using one of the goodness of fit statistics
    (i.e., PPCC, Anderson-Darling, Kolmogorov-Smirnov), then the
    distributions are limited to location-scale distributions or
    distributions with a single shape parameter.  The one exeception
    is the g-and-h distribution (which has two shape parameters).

    This restriction is primarily for performance reasons.

Note:
    The AIC is computed as

        AIC = 2*k - 2*LN(L)

    with k denoting the number of parameters being fit and L is the
    maximized value of the likelihood function.

    The AICc is computed as

        AICc = AIC + 2*k*(k+1)/(n-k-1)

    The AICc is recommended over the AIC when the sample size
    is small or k is large.  Since AICc converges to AIC for
    large n, some analysts prefer to use AICc rather than AIC
    for all cases.

    The BIC is computed as

        -2*LN(L) + k*LN(n)

    The penalty term for extra parameters is larger in the BIC
    than it is for the AIC.

Note:
    The PPCC ranking method is based on the "most linear" probability
    plot where linearity is measured by correlation coefficient of
    the points on the probability plot.  The probability plot has
    the property that it is invariant to location and scale.  In
    practical terms, this means that the linearity of the probability
    plot only depends on the shape parameters, not the location and
    scale parameters.

    So if we use a non-PPCC method to estimate the parameters
    and use the PPCC as a ranking method, there is an additional
    implicit estimate for the location and scale parameters.  For
    this reason, the PPCC ranking method is only supported when a
    PPCC fitting method is used.

Note:
    Some distributions are bounded and are more commonly defined by
    the lower and upper limits rather than the location and scale
    parameters (for these distributions, the lower limit is the
    location parameter and the upper limit minus the lower limit
    is the scale parameter).  Examples include the uniform, beta,
    power, and Topp and Leone distributions.  In the output table,
    these distributions are marked with an asterisk to indicate
    that the estimated values for the location and scale parameters
    are actually the estimates for the lower and upper limit,
    respectively.

Note:
    If the following command is given

       SET BEST FIT FONG ON

    then two additional columns are given.

    The first additional column gives the PDF value at 0.  The
    second additional column is set to 1 if the distribution
    has an infinite lower tail and it is set to 0 if the distribution
    has a bounded lower tail.

    For the first additional column, the following commands
    can also be used

       SET BEST FIT FONG TYPE <PDF/CDF>
       SET BEST FIT FONG XVALUE <VALUE>

    The SET BEST FIT FONG TYPE command is used to specify whether
    we want to print the CDF or the PDF value (the default is the
    PDF value).  The SET BEST FIT FONG XVALUE command specifies
    at what value (the default is 0) we want to print the PDF
    (or CDF value).

    These options were added at the request of Jeffrey Fong.  For
    lifetime data (and many other types of measurement data), we
    will only have positive measurements.  So it is of interest
    whether we have non-negligble probability below some threshold
    value.  It may be that some distributions indicate good fit, but
    they are not appropriate distributional models due to
    non-negligible probability for inadmissable values.

    Note that unbounded distributions may provide adequate
    distributional models for these cases if the cumulative
    probability below some threshold is practically, even if
    not theoretically,  zero.

Note:
    For the 2-parameter Beta, power, reflected power, Topp and
    Leone, reflected generalized Topp and Leone, and two-sided
    power distributions, you can fix the lower and upper limits
    with the commands

        LET LOWLIMIT = <value>
        LET UPPLIMIT = <value>

    These limits will apply to all of these distributions.  There is
    currently no way to specify different lower and upper limits for
    the different distributions.

    If these values are not set, then default values based on the
    data will be used (typically based on the minimum and maximum
    values of the data).

Note:
    The 2020/05 version of Dataplot added the ability to specify which
    distributions to include.  The following commands were added

       SET BEST FIT DISTRIBUTION NORMAL <ON/OFF>
       SET BEST FIT DISTRIBUTION LOGISTIC <ON/OFF>
       SET BEST FIT DISTRIBUTION LOG LOGISTIC <ON/OFF>
       SET BEST FIT DISTRIBUTION HYPERBOLIC SECANT <ON/OFF>
       SET BEST FIT DISTRIBUTION UNIFORM <ON/OFF>
       SET BEST FIT DISTRIBUTION POWER <ON/OFF>
       SET BEST FIT DISTRIBUTION ARCSINE <ON/OFF>
       SET BEST FIT DISTRIBUTION TRIANGULAR <ON/OFF>
       SET BEST FIT DISTRIBUTION ERROR <ON/OFF>
       SET BEST FIT DISTRIBUTION SLASH <ON/OFF>
       SET BEST FIT DISTRIBUTION CAUCHY <ON/OFF>
       SET BEST FIT DISTRIBUTION COSINE <ON/OFF>
       SET BEST FIT DISTRIBUTION BRADFORD <ON/OFF>
       SET BEST FIT DISTRIBUTION ANGLIT <ON/OFF>
       SET BEST FIT DISTRIBUTION RAYLEIGH <ON/OFF>
       SET BEST FIT DISTRIBUTION FOLDED NORMAL <ON/OFF>
       SET BEST FIT DISTRIBUTION TUKEY LAMBDA <ON/OFF>
       SET BEST FIT DISTRIBUTION GENERALIZED TUKEY LAMBDA <ON/OFF>
       SET BEST FIT DISTRIBUTION DOUBLE GAMMA <ON/OFF>
       SET BEST FIT DISTRIBUTION DOUBLE WEIBULL <ON/OFF>
       SET BEST FIT DISTRIBUTION REFLECTED POWER <ON/OFF>
       SET BEST FIT DISTRIBUTION TWO SIDED POWER <ON/OFF>
       SET BEST FIT DISTRIBUTION TOPP AND LEONE <ON/OFF>
       SET BEST FIT DISTRIBUTION REFLECTED GENERALIZED TOPP AND LEONE <ON/OFF>
       SET BEST FIT DISTRIBUTION GENERALIZED EXTREME VALUE MINIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION GENERALIZED EXTREME VALUE MAXIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION PARETO <ON/OFF>
       SET BEST FIT DISTRIBUTION GENERALIZED PARETO MINIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION GENERALIZED PARETO MAXIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION G AND H <ON/OFF>
       SET BEST FIT DISTRIBUTION G <ON/OFF>
       SET BEST FIT DISTRIBUTION INVERTED WEIBULL <ON/OFF>
       SET BEST FIT DISTRIBUTION GAMMA <ON/OFF>
       SET BEST FIT DISTRIBUTION LOG GAMMA <ON/OFF>
       SET BEST FIT DISTRIBUTION INVERTED GAMMA <ON/OFF>
       SET BEST FIT DISTRIBUTION FATIGUE LIFE <ON/OFF>
       SET BEST FIT DISTRIBUTION WALD <ON/OFF>
       SET BEST FIT DISTRIBUTION LOGISTIC EXPONENTIAL <ON/OFF>
       SET BEST FIT DISTRIBUTION GEOMETRIC EXTREME EXPONENTIAL <ON/OFF>
       SET BEST FIT DISTRIBUTION LOG DOUBLE EXPONENTIAL <ON/OFF>

       SET BEST FIT DISTRIBUTION TWO PARAMETER LOGNORMAL <ON/OFF>
       SET BEST FIT DISTRIBUTION 2 PARAMETER LOGNORMAL <ON/OFF>

       SET BEST FIT DISTRIBUTION THREE PARAMETER LOGNORMAL <ON/OFF>
       SET BEST FIT DISTRIBUTION 3 PARAMETER LOGNORMAL <ON/OFF>

       SET BEST FIT DISTRIBUTION TWO PARAMETER EXPONENTIAL <ON/OFF>
       SET BEST FIT DISTRIBUTION 2 PARAMETER EXPONENTIAL <ON/OFF>
       SET BEST FIT DISTRIBUTION EXPONENTIAL <ON/OFF>

       SET BEST FIT DISTRIBUTION TWO PARAMETER WEIBULL MINIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION 2 PARAMETER WEIBULL MINIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION TWO PARAMETER WEIBULL <ON/OFF>
       SET BEST FIT DISTRIBUTION 2 PARAMETER WEIBULL <ON/OFF>

       SET BEST FIT DISTRIBUTION TWO PARAMETER WEIBULL MAXIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION 2 PARAMETER WEIBULL MAXIMUM <ON/OFF>

       SET BEST FIT DISTRIBUTION THREE PARAMETER WEIBULL MINIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION 3 PARAMETER WEIBULL MINIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION THREE PARAMETER WEIBULL <ON/OFF>
       SET BEST FIT DISTRIBUTION 3 PARAMETER WEIBULL <ON/OFF>

       SET BEST FIT DISTRIBUTION THREE PARAMETER WEIBULL MAXIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION 3 PARAMETER WEIBULL MAXIMUM <ON/OFF>

       SET BEST FIT DISTRIBUTION ONE PARAMETER EXPONENTIAL <ON/OFF>
       SET BEST FIT DISTRIBUTION 1 PARAMETER EXPONENTIAL <ON/OFF>

       SET BEST FIT DISTRIBUTION ASYMMETRIC DOUBLE EXPONENTIAL <ON/OFF>
       SET BEST FIT DISTRIBUTION ASYMMETRIC LAPLACE <ON/OFF>

       SET BEST FIT DISTRIBUTION DOUBLE EXPONENTIAL <ON/OFF>
       SET BEST FIT DISTRIBUTION LAPLACE <ON/OFF>

       SET BEST FIT DISTRIBUTION BURR TYPE TEN <ON/OFF>
       SET BEST FIT DISTRIBUTION BURR TYPE 10 <ON/OFF>

       SET BEST FIT DISTRIBUTION TWO PARAMETER INVERSE GAUSSIAN <ON/OFF>
       SET BEST FIT DISTRIBUTION 2 PARAMETER INVERSE GAUSSIAN <ON/OFF>

       SET BEST FIT DISTRIBUTION THREE PARAMETER INVERSE GAUSSIAN <ON/OFF>
       SET BEST FIT DISTRIBUTION 3 PARAMETER INVERSE GAUSSIAN <ON/OFF>

       SET BEST FIT DISTRIBUTION THREE PARAMETER LOGNORMAL <ON/OFF>
       SET BEST FIT DISTRIBUTION 3 PARAMETER LOGNORMAL <ON/OFF>

       SET BEST FIT DISTRIBUTION TWO PARAMETER EXPONENTIAL <ON/OFF>
       SET BEST FIT DISTRIBUTION GUMBEL MINIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION GUMBEL MAXIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION EXTREME VALUE TYPE 1 MINIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION EXTREME VALUE TYPE 1 MAXIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION EXTREME VALUE TYPE I MINIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION EXTREME VALUE TYPE I MAXIMUM <ON/OFF>

       SET BEST FIT DISTRIBUTION FRECHET MINIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION FRECHET MAXIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION EXTREME VALUE TYPE TWO MINIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION EXTREME VALUE TYPE TWO MAXIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION EXTREME VALUE TYPE II MINIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION EXTREME VALUE TYPE II MAXIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION EXTREME VALUE TYPE 2 MINIMUM <ON/OFF>
       SET BEST FIT DISTRIBUTION EXTREME VALUE TYPE 2 MAXIMUM <ON/OFF>

       SET BEST FIT DISTRIBUTION TWO PARAMETER BETA <ON/OFF>
       SET BEST FIT DISTRIBUTION 2 PARAMETER BETA <ON/OFF>

       SET BEST FIT DISTRIBUTION FOUR PARAMETER BETA <ON/OFF>
       SET BEST FIT DISTRIBUTION 4 PARAMETER BETA <ON/OFF>

       SET BEST FIT DISTRIBUTION ONE PARAMETER HALF NORMAL <ON/OFF>
       SET BEST FIT DISTRIBUTION 1 PARAMETER HALF NORMAL <ON/OFF>

       SET BEST FIT DISTRIBUTION TWO PARAMETER HALF NORMAL <ON/OFF>
       SET BEST FIT DISTRIBUTION 2 PARAMETER HALF NORMAL <ON/OFF>
       SET BEST FIT DISTRIBUTION HALF NORMAL <ON/OFF>

       SET BEST FIT DISTRIBUTION ONE PARAMETER HALF LOGISTIC <ON/OFF>
       SET BEST FIT DISTRIBUTION 1 PARAMETER HALF LOGISTIC <ON/OFF>

       SET BEST FIT DISTRIBUTION TWO PARAMETER HALF LOGISTIC <ON/OFF>
       SET BEST FIT DISTRIBUTION 2 PARAMETER HALF LOGISTIC <ON/OFF>
       SET BEST FIT DISTRIBUTION HALF LOGISTIC <ON/OFF>

       SET BEST FIT DISTRIBUTION TWO COMPONENT NORMAL MIXTURE <ON/OFF>
       SET BEST FIT DISTRIBUTION 2 COMPONENT NORMAL MIXTURE <ON/OFF>

    The following resets the default list of distributions

       SET BEST FIT DISTRIBUTION ALL
       SET BEST FIT DISTRIBUTION DEFAULT

    The following turns off all the distributions.  If you have a small
    set of distributions, you can enter one of these commands first and
    then use the above commands to turn on the specific distributions
    you want to include

       SET BEST FIT DISTRIBUTION NONE
       SET BEST FIT DISTRIBUTION OFF

Default:
    None
 
Synonyms:
    ML is a synonym for MAXIMUM LIKELIHOOD
    AD is a synonym for ANDERSON DARLING
    KS is a synonym for KOLMOGOROV SMIRNOV
 
Related Commands:
    GOODNESS OF FIT         = Perform a goodness of fit test.
    MAXIMUM LIKELIHOOD      = Perform maximum likelihood estimation for
                              a number of distributions.
    PROBABILITY PLOT        = Generates a probability plot.
    PPCC PLOT               = Generates probability plot correlation
                              coefficient plot.
    RANDOM NUMBERS          = Generate random numbers.
    HISTOGRAM               = Generates a histogram.

Applications:
    Distributional Modeling

Default:
    None
 
Synonyms:
    ML is a synonym for MAXIMUM LIKELIHOOD
    AD is a synonym for ANDERSON DARLING
    KS is a synonym for KOLMOGOROV SMIRNOV
 
Related Commands:
    GOODNESS OF FIT         = Perform a goodness of fit test.
    MAXIMUM LIKELIHOOD      = Perform maximum likelihood estimation for
                              a number of distributions.
    PROBABILITY PLOT        = Generates a probability plot.
    PPCC PLOT               = Generates probability plot correlation
                              coefficient plot.
    RANDOM NUMBERS          = Generate random numbers.
    HISTOGRAM               = Generates a histogram.

Applications:
    Distributional Modeling
 
Implementation Date:
    2011/03
    2012/10: Added the AIC, AICc, and BIC ranking criterion
    2020/05: Added support for specifying which distributions to include
 
Program:
    .  Step 1: Read the data
    .
    .          Following data from Jeffery Fong of the NIST
    .          Applied and Computational Mathematics Division.
    .          This is strength data in ksi units.
    .
    read y
    18.830
    20.800
    21.657
    23.030
    23.230
    24.050
    24.321
    25.500
    25.520
    25.800
    26.690
    26.770
    26.780
    27.050
    27.670
    29.900
    31.110
    33.200
    33.730
    33.760
    33.890
    34.760
    35.750
    35.910
    36.980
    37.080
    37.090
    39.580
    44.045
    45.290
    45.381
    end of data
    .
    set write decimals 5
    .
    .  Step 2: Apply goodness of fit tests for Weibull distribution
    .          based on ML estimates
    .
    .  Maximum likelihood method
    .
    set best fit method     ml
    set best fit criterion  anderson darling
    best distributional fit  y
    .
    set best fit method     ml
    set best fit criterion  kolm smir
    best distributional fit  y
    .
    .  PPCC method
    .
    set best fit method     ppcc
    set best fit criterion  ppcc
    best distributional fit  y

-----BETA (LET)--------------------------------
 
BETA
 
Name:
    BETA (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Beta function.
 
Description:
    The Beta function is defined as:
        BETA(A,B) = INTEGRAL(t**(A-1)*(1-t)**(b-1)dt
    where the integral is taken from 0 to 1 and A and B are positive
    real numbers.  The Beta function can also be defined in terms of
    the gamma function:
        BETA(A,B) = GAMMA(A)*GAMMA(B)/GAMMA(A+B)

Syntax:
    LET <y2> = BETA(<a>,<b>)  <SUBSET/EXCEPT/FOR qualification>
    where <a> is a positive number, variable, or parameter;
          <b> is a positive number, variable, or parameter;
          <y2> is a variable or a parameter (depending on what <a> and
               <b> are) where the computed Beta values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BETA(1,2)
    LET A = BETA(A1,B3)
    LET X2 = BETA(X,2)
    LET X2 = BETA(X1-4,0.2)
 
Note:
    DATAPLOT uses the routine DBETA from the SLATEC Common Mathematical
    Library to compute this function.  SLATEC is a large set of high
    quality, portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal laboratories.

Note:
    The Beta function can overflow even for moderate values of
    A and B.  The LNBETA function can be used in these cases.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BETAI      = Compute the incomplete Beta function.
    LNBETA     = Compute the log Beta function.
    GAMMA      = Compute the gamma function.
    LOGGAMMA   = Compute the log gamma function.
 
Reference:
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", 2nd Edition, Press, Flannery, Teukolsky, and Vetterling.
    Cambridge University Press, 1992 (chapter 6).
 
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE AUTOMATIC
    PLOT BETA(X,4) FOR X = 1 1 20
 
-----BETCDF (LET)--------------------------------
 
BETCDF
 
Name:
    BETCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the beta cumulative distribution function with shape
    parameters A and B.
 
Description:
    The beta distribution has the following probability density
    function:
          f(x,a,b) = x**(a-1)*(1-x)**(b-1)/BETA(a,b)    0 < x < 1
    where BETA is the complete beta function.  See the documentation
    for the BETA command for a description of the complete beta
    function.  The cumulative distribution is the area from 0 to x.
    For the beta distribution, this is the incomplete beta function.
    See the documentation for the BETAI command for a description of
    the incomplete Beta function.  Since this is a probability
    function, the returned value will be between 0 and 1.
 
    The input value should be greater than 0 and less than 1.  The
    shape parameters should be positive.
 
Syntax:
    LET <y2> = BETCDF(<y1>,<a>,<b>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a number, parameter, or variable containing values
               between 0 and 1;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed beta cdf value is stored;
          <a> is a number, parameter, or variable that specifies the
               first shape parameter;
          <b> is a number, parameter, or variable that specifies the
               second shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BETCDF(0.3,10,8)
    LET A = BETCDF(A1,10,8)
    LET X2 = BETCDF(X1,2,6)
 
Note:
    Several other probability functions can be considered special cases
    of the Beta distribution or they can be transformed to a beta
    distribution.  See the books listed in the REFERENCE below for 
    details.

Note:
    DATAPLOT uses the routine DBETAI from the SLATEC Common
    Mathematical Library to compute this function.  SLATEC is a large
    set of high quality, portable, public domain Fortran routines for
    various mathematical capabilities maintained by seven federal
    laboratories.

    The DBETAI routine is an implementation of the Bosten and Battiste
    algorithm (see the REFERENCE section below).

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BETAI
 
Related Commands:
    BETPDF = Compute the beta probability density function.
    BETPPF = Compute the beta percent point function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
    FCDF   = Compute the F cumulative distribution function.
    FPDF   = Compute the F probability density function.
    FPPF   = Compute the F percent point function.
    GAMCDF = Compute the gamma cumulative distribution function.
    GAMPDF = Compute the gamma probability density function.
    GAMPPF = Compute the gamma percent point function.
    NCBCDF = Compute the non-central beta cumulative distribution
             function.
    NCBPPF = Compute the non-central beta percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    TCDF   = Compute the T cumulative distribution function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
    UNICDF = Compute the uniform cumulative distribution function.
    UNIPDF = Compute the uniform probability density function.
    UNIPPF = Compute the uniform percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, 1970.

    "Statistical Distributions", 2nd Edition, Evans, Hastings, and
    Peacock, 1970 (chapter 5).
 
Applications:
    XX
 
Implementation Date:
    94/9
 
Program:
    TITLE PLOT BETA CDF FOR VARIOUS VALUES OF A AND B
    SEGMENT 1 COORDINATES 64 38 69 38; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 64 34 69 34; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 64 30 69 30; SEGMENT 3 PATTERN DOT
    SEGMENT 4 COORDINATES 64 26 69 26; SEGMENT 4 PATTERN DASH2
    LEGEND 1 A = 2, B = 4; LEGEND 1 COORDINATES 70 37
    LEGEND 2 A = 1, B = 1; LEGEND 2 COORDINATES 70 33
    LEGEND 3 A = 0.5, B = 0.5; LEGEND 3 COORDINATES 70 29
    LEGEND 4 A = 0.2, B = 1; LEGEND 4 COORDINATES 70 25
    YLIMITS 0 1; MAJOR YTIC NUMBER 6
    MINOR YTIC NUMBER 1; YTIC DECIMAL 1
    XLIMITS 0 1; XTIC OFFSET 0.1 0.1
    MAJOR XTIC NUMBER 6; MINOR XTIC NUMBER 1
    LINES SOLID DASH DOT DASH2
    PLOT BETCDF(X,2,4) FOR X = 0.01 0.01 0.99 AND
    PLOT BETCDF(X,1,1) FOR X = 0.01 0.01 0.99 AND
    PLOT BETCDF(X,0.5,0.5) FOR X = 0.01 0.01 0.99 AND
    PLOT BETCDF(X,0.2,1) FOR X = 0.01 0.01 0.99
 
-----BETPDF (LET)--------------------------------
 
BETPDF
 
Name:
    BETPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the beta probability density function with shape parameters
    A and B.
 
Description:
    The beta distribution has the following probability density
    function:
          f(x,a,b) = x**(a-1)*(1-x)**(b-1)/BETA(a,b)    0 < x < 1
    where BETA is the complete beta function.  See the documentation
    for the BETA command for a description of the complete beta
    function.  The BETPDF function evaluates this function for a given
    x value.  The input value should be greater than 0 and less than 1.
    The shape parameters should be positive.
 
Syntax:
    LET <y2> = BETPDF(<y1>,<a>,<b>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a number, parameter, or variable containing values
               between 0 and 1;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed beta pdf value is stored;
          <a> is a number, parameter, or variable that specifies the
               first shape parameter;
          <b> is a number, parameter, or variable that specifies the
               second shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BETPDF(0.3,10,8)
    LET A = BETPDF(A1,10,8)
    LET X2 = BETPDF(X1,2,6)
 
Note:
    Several other probability functions can be considered special cases
    of the Beta distribution or they can be transformed to a beta
    distribution.  See the books listed in the REFERENCE below for 
    details.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BETCDF = Compute the beta cumulative distribution function.
    BETPPF = Compute the beta percent point function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
    FCDF   = Compute the F cumulative distribution function.
    FPDF   = Compute the F probability density function.
    FPPF   = Compute the F percent point function.
    GAMCDF = Compute the gamma cumulative distribution function.
    GAMPDF = Compute the gamma probability density function.
    GAMPPF = Compute the gamma percent point function.
    NCBCDF = Compute the non-central beta cumulative distribution
             function.
    NCBPPF = Compute the non-central beta percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    TCDF   = Compute the T cumulative distribution function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
    UNICDF = Compute the uniform cumulative distribution function.
    UNIPDF = Compute the uniform probability density function.
    UNIPPF = Compute the uniform percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, 1970.
 
    "Statistical Distributions", 2nd Edition, Evans, Hastings, and
    Peacock, 1970 (chapter 5).
 
Applications:
    XX
 
Implementation Date:
    94/9
 
Program:
    TITLE PLOT BETPDF FOR VARIOUS VALUES OF NU
    SEGMENT 1 COORDINATES 64 88 69 88; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 64 84 69 84; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 64 80 69 80; SEGMENT 3 PATTERN DOT
    SEGMENT 4 COORDINATES 64 76 69 76; SEGMENT 4 PATTERN DASH2
    LEGEND 1 A = 2, B = 4; LEGEND 1 COORDINATES 70 87
    LEGEND 2 A = 1, B = 1; LEGEND 2 COORDINATES 70 83
    LEGEND 3 A = 0.5, B = 0.5; LEGEND 3 COORDINATES 70 79
    LEGEND 4 A = 0.2, B = 1; LEGEND 4 COORDINATES 70 75
    XLIMITS 0 1; XTIC OFFSET 0.1 0.1
    MAJOR XTIC NUMBER 6; MINOR XTIC NUMBER 1
    LINES SOLID DASH DOT DASH2
    PLOT BETPDF(X,2,4) FOR X = 0.01 0.01 0.99 AND
    PLOT BETPDF(X,1,1) FOR X = 0.01 0.01 0.99 AND
    PLOT BETPDF(X,0.5,0.5) FOR X = 0.01 0.01 0.99 AND
    PLOT BETPDF(X,0.2,1) FOR X = 0.01 0.01 0.99
 
-----BETPPF (LET)--------------------------------
 
BETPPF
 
Name:
    BETPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the beta percent point function with shape parameters A and
    B.
 
Description:
    The beta distribution has the following probability density
    function:
          f(x,a,b) = x**(a-1)*(1-x)**(b-1)/BETA(a,b)    0 < x < 1
    where BETA is the complete beta function.  See the documentation
    for the BETA command for a description of the complete beta
    function. 
 
    The percent point function is the inverse of the cumulative
    distribution function.  The cumulative distribution sums the
    probability from 0 to the given x value.  The percent point
    function takes a cumulative probability value and computes the
    corresponding x value.
 
Syntax:
    LET <y2> = BETPPF(<p>,<a>,<b>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a number, parameter, or variable containing values
               between 0 and 1;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed beta ppf value is stored;
          <a> is a number, parameter, or variable that specifies the
               first shape parameter;
          <b> is a number, parameter, or variable that specifies the
               second shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BETPPF(0.9,10,8)
    LET X2 = BETPPF(X1,10,8)
 
Note:
    DATAPLOT uses a bisection method to compute the beta ppf value.
    The algorithm is from the Kennedy and Gentle book (see the
    REFERENCE section below).

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BETCDF = Compute the beta cumulative distribution function.
    BETPDF = Compute the beta probability density function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
    FCDF   = Compute the F cumulative distribution function.
    FPDF   = Compute the F probability density function.
    FPPF   = Compute the F percent point function.
    GAMCDF = Compute the gamma cumulative distribution function.
    GAMPDF = Compute the gamma probability density function.
    GAMPPF = Compute the gamma percent point function.
    NCBCDF = Compute the non-central beta cumulative distribution
             function.
    NCBPPF = Compute the non-central beta percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    TCDF   = Compute the T cumulative distribution function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
    UNICDF = Compute the uniform cumulative distribution function.
    UNIPDF = Compute the uniform probability density function.
    UNIPPF = Compute the uniform percent point function.
 
Reference:
    "Statistical Computing", Kennedy and Gentle, Marcel-Dekker, 
    1978 (chapter 5).

    "Continuous Univariate Distributions", Johnson and Kotz, 1970.

    "Statistical Distributions", 2nd Edition, Evans, Hastings, and
    Peacock, 1970 (chapter 5).
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, 1970.
 
Applications:
    XX
 
Implementation Date:
    94/9
 
Program:
    TITLE PLOT BETPPF FOR VARIOUS VALUES OF A AND B
    SEGMENT 1 COORDINATES 16 88 21 88; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 16 84 21 84; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 16 80 21 80; SEGMENT 3 PATTERN DOT
    SEGMENT 4 COORDINATES 16 76 21 76; SEGMENT 4 PATTERN DASH2
    LEGEND 1 A = 5, B = 5; LEGEND 1 COORDINATES 22 87
    LEGEND 2 A = 5, B = 10; LEGEND 2 COORDINATES 22 83
    LEGEND 3 A = 10, B=5; LEGEND 3 COORDINATES 22 79
    LEGEND 4 A = 10, B = 10; LEGEND 4 COORDINATES 22 75
    LIMITS 0 1; MAJOR TIC NUMBER 6
    MINOR TIC NUMBER 1; TIC DECIMAL 1
    LINES SOLID DASH DOT DASH2
    PLOT BETPPF(X,5,5) FOR X = 0.01 .01 0.99 AND
    PLOT BETPPF(X,5,10) FOR X = 0.01 .01 0.99 AND
    PLOT BETPPF(X,10,5) FOR X = 0.01 .01 0.99 AND
    PLOT BETPPF(X,10,10) FOR X = 0.01 .01 0.99
 
-----BETAI (LET)--------------------------------
 
BETAI
 
Name:
    BETAI (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the incomplete beta function.
 
Description:
    The incomplete beta function is defined as:
        BETAI(X,A,B) = (1/BETA(A,B))*INTEGRAL(t**(A-1)*(1-t)**(b-1)dt
    where the integral is taken from 0 to x, x must be in the interval
    (0,1) inclusive, BETA is the complete beta function, and A and B are
    positive real numbers.  See the documentation for the BETA command
    for a description of the complete beta function.

Syntax:
    LET <y2> = BETAI(<x>,<a>,<b>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a positive number, variable, or parameter;
          <a> is a positive number, variable, or parameter;
          <b> is a positive number, variable, or parameter;
          <y2> is a variable or a parameter (depending on what <x>, <a>
               and <b> are) where the computed incomplete beta values
               are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BETAI(X,1,2)
    LET A = BETAI(X,A1,B3)
    LET X2 = BETAI(X,2,A1)
    LET X2 = BETAI(0.5,0.2,3)
 
Note:
    DATAPLOT uses the routine DBETAI from the SLATEC Common Mathematical
    Library to compute this function.  SLATEC is a large set of high
    quality, portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal laboratories.

    The DBETAI routine is an implementation of the Bosten and Battiste
    algorithm (see the REFERENCE section below).

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BETCDF
 
Related Commands:
    BETA       = Compute the complete beta function.
    LNBETA     = Compute the log beta function.
    BETPDF     = Compute the beta probability density function.
    BETPPF     = Compute the beta percent point function.
    GAMMA      = Compute the gamma function.
    GAMMAI     = Compute the incomplete gamma function.
    LOGGAMMA   = Compute the log gamma function.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 6).
 
    "Remark on algorithm 179", Bosten and Battiste, Communications of
    the ACM, 17, 1974.

    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", 2nd Edition, Press, Flannery, Teukolsky, and Vetterling.
    Cambridge University Press, 1992 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE AUTOMATIC
    PLOT BETAI(X,2,4) FOR X = .01 .01 .99
 
-----BGECDF (LET)--------------------------------
 
BGECDF
 
Name:
    BGECDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the beta-geometric cumulative distribution function
    with shape parameters alpha and beta.
 
Description:
    If the probability of success parameter, p, of a geometric
    distribution has a Beta distribution with shape parameters
    alpha and beta, the resulting distribution is referred to
    as a beta-geometric distribution.  For a standard geometric
    distribution, p is assumed to be fixed for successive trials.
    For the beta-geometric distribution, the value of p changes
    for each trial.

    The beta-geometric distribution has the following probability
    density function:

       p(x;alpha,beta) = B(alpha+1,x+beta-1)/B(alpha,beta)
                         x = 1, 2, ...; alpha, beta > 0

    with alpha, beta, and B denoting the two shape parameters and
    the complete beta function, respectively.  See the
    documentation for the BETA command for a description of the
    complete beta function.

    Dataplot computes the cumulative distribution function
    using a recurrence relation given by Hesselager.  Hesselager
    gives the recurrence relation as:

       p(x;alpha,beta) = [(x+alpha-1)/(x+alpha+beta)]*
                         p(x-1;alpha,beta)

    Converting this to the parameterization above yields

       p(x;alpha,beta) = [(x+beta-2)/(x+alpha+beta-1)]*
                         p(x-1;alpha,beta)

Syntax:
    LET <y> = BGECDF(<x>,<alpha>,<beta>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable containing
               non-negative integer values;
          <alpha> is a number, parameter, or variable that specifies
               the first shape parameter;
          <beta> is a number, parameter, or variable that specifies
               the second shape parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed beta-geometric cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BGECDF(4,0.5,0.9)
    LET A = BGECDF(X,2.1,4)
    PLOT BGECDF(X,ALPHA,BETA) FOR X = 1 1 20
 
Note:
    Some sources shift this distribution to start at x = 0.  In
    this case, the probability mass function is

       p(x;alpha,beta) = B(alpha+1,x+beta)/B(alpha,beta)
                         x = 0, 1, 2, ...; alpha, beta > 0

    We will refer to the first parameterization as the unshifted
    parameterization and the second parameterization as the
    shifted parameterization.

    To specify the shifted parameterization (i.e., starting
    at x = 0), enter the command

       SET BETA GEOMETRIC DEFINITION SHIFTED

    To reset the unshifted parameterization (i.e., starting
    at x = 1), enter the command

       SET BETA GEOMETRIC DEFINITION UNSHIFTED

    This distribution is also sometimes given with alpha and
    beta reversed.  In this case, the probability mass functions
    become

        p(x;alpha,beta) = B(alpha+1,x+beta-1)/B(alpha,beta)
                          x = 1, 2, ...; alpha, beta > 0

    and

        p(x;alpha,beta) = B(alpha+1,x+beta)/B(alpha,beta)
                          x = 0, 1, 2, ...; alpha, beta > 0
 
    To use this parameterization, simply interchange the order
    in which you give the alpha and beta arguments to the
    BGECDF command.

Note:
    The beta-geometric as given above is derived as a beta
    mixture of geometric random variables.

    Irwin developed the Waring distribution based on the Waring
    expansion.  The probability mass function for the Waring
    distribution is

       p(x;c,a) = (c-a)*(a+x-1)!*c!/[c*(a-1)!*(c+x)!]
                  x = 0, 1, 2, ...; a > 0; c > a

    The Waring distribution can be computed with the shifted
    form of the beta-geometric distribution with the following
    change in parameters:

        beta = a
        alpha = c - a

    If a = 1, then the Waring distribution reduces to the
    Yule distribution.

    You can compute the Waring (and Yule) distributions using
    the BGECDF routine with the above re-parameterization
    or you can use the WARCDF or YULCDF routines directly
    (enter HELP WARCDF or HELP YULCDF for details).

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BGEPDF                   = Compute the beta-geometric probability
                               mass function.
    BGECDF                   = Compute the beta-geometric cumulative
                               distribution function.
    BETPDF                   = Compute the beta probability density
                               function.
    GEOPDF                   = Compute the geometric probability
                               mass function.
    BBNPPF                   = Compute the beta-binomial (Waring)
                               probability mass function.
    BNBPPF                   = Compute the beta-negative binomial
                               (generalized Waring) probability mass
                               function.
Reference:
    Ole Hesselager (1994), "A Recursive Procedure for Calculations
    of Some Compound Distributions", Astin Bulliten, Vol. 24,
    No. 1, pp. 19-32.

    Sudhir R. Paul (2004), "Applications of the Beta Distribution"
    in "Handbook of the Beta Distribution", edited by Gupta and
    Nadarajah, Marcel-Dekker, pp. 431-436.

    J. O. Irwin (1963), "The Place of Mathematics in Medical and
    Biological Statistics", Journal of the Royal Statistical
    Society, Series A, 126, pp. 1-44.

    Johnson, Kotz, and Kemp (1992), "Univariate Discrete
    Distributions", Second Edition, Wiley, chapter 6.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/7
 
Program:
    XLIMITS 0 50
    XTIC OFFSET 0.5 0.5
    LINE BLANK
    SPIKE ON
    SPIKE THICKNESS 0.3
    .
    TITLE CASE ASIS
    LABEL CASE ASIS
    X1LABEL Number of Successes
    Y1LABEL Probability
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    TITLE Alpha = 0.5, Beta = 0.5
    PLOT BGECDF(X,0.5,0.5) FOR X = 0 1 50
    .
    TITLE Alpha = 3, Beta = 0.5
    PLOT BGECDF(X,3.0,0.5) FOR X = 0 1 50
    .
    TITLE Alpha = 0.5, Beta = 3
    PLOT BGECDF(X,0.5,3.0) FOR X = 0 1 50
    .
    TITLE Alpha = 3, Beta = 3
    PLOT BGECDF(X,3.0,3.0) FOR X = 0 1 50
    .
    END OF MULTIPLOT
    .
    CASE ASIS
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Beta-Geometric Cumulative Distribution Functions
 
-----BGEPDF (LET)--------------------------------
 
BGEPDF
 
Name:
    BGEPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the beta-geometric probability mass function with
    shape parameters alpha and beta.
 
Description:
    If the probability of success parameter, p, of a geometric
    distribution has a Beta distribution with shape parameters
    alpha and beta, the resulting distribution is referred to
    as a beta-geometric distribution.  For a standard geometric
    distribution, p is assumed to be fixed for successive trials.
    For the beta-geometric distribution, the value of p changes
    for each trial.

    The beta-geometric distribution has the following probability
    density function:

       p(x;alpha,beta) = B(alpha+1,x+beta-1)/B(alpha,beta)
                         x = 1, 2, ...; alpha, beta > 0

    with alpha, beta, and B denoting the two shape parameters and
    the complete beta function, respectively.  See the
    documentation for the BETA command for a description of the
    complete beta function.

Syntax:
    LET <y> = BGEPDF(<x>,<alpha>,<beta>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable containing
               non-negative integer values;
          <alpha> is a number, parameter, or variable that specifies
               the first shape parameter;
          <beta> is a number, parameter, or variable that specifies
               the second shape parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed beta-geometric pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BGEPDF(4,0.5,0.9)
    LET A = BGEPDF(X,2.1,4)
    PLOT BGEPDF(X,ALPHA,BETA) FOR X = 1 1 20
 
Note:
    Some sources shift this distribution to start at x = 0.  In
    this case, the probability mass function is

       p(x;alpha,beta) = B(alpha+1,x+beta)/B(alpha,beta)
                         x = 0, 1, 2, ...; alpha, beta > 0

    We will refer to the first parameterization as the unshifted
    parameterization and the second parameterization as the
    shifted parameterization.

    To specify the shifted parameterization (i.e., starting
    at x = 0), enter the command

       SET BETA GEOMETRIC DEFINITION SHIFTED

    To reset the unshifted parameterization (i.e., starting
    at x = 1), enter the command

       SET BETA GEOMETRIC DEFINITION UNSHIFTED

    This distribution is also sometimes given with alpha and
    beta reversed.  In this case, the probability mass functions
    become

        p(x;alpha,beta) = B(alpha+1,x+beta-1)/B(alpha,beta)
                          x = 1, 2, ...; alpha, beta > 0

    and

        p(x;alpha,beta) = B(alpha+1,x+beta)/B(alpha,beta)
                          x = 0, 1, 2, ...; alpha, beta > 0
 
    To use this parameterization, simply interchange the order
    in which you give the alpha and beta arguments to the
    BGEPDF command.

Note:
    The beta-geometric as given above is derived as a beta
    mixture of geometric random variables.

    Irwin developed the Waring distribution based on the Waring
    expansion.  The probability mass function for the Waring
    distribution is

       p(x;c,a) = (c-a)*(a+x-1)!*c!/[c*(a-1)!*(c+x)!]
                  x = 0, 1, 2, ...; a > 0; c > a

    The Waring distribution can be computed with the shifted
    form of the beta-geometric distribution with the following
    change in parameters:

        beta = a
        alpha = c - a

    If a = 1, then the Waring distribution reduces to the
    Yule distribution.

    You can compute the Waring (and Yule) distributions using
    the BGEPDF routine with the above re-parameterization
    or you can use the WARPDF or YULPDF routines directly
    (enter HELP WARPDF or HELP YULPDF for details).

Note:
    For a number of commands utilizing the beta-geometric
    distribution, it is convenient to bin the data.  There are
    two basic ways of binning the data.

      1) For some commands (histograms, maximum likelihood
         estimation), bins with equal size widths are
         required.  This can be accomplished with the
         following commands:

            LET AMIN = MINIMUM Y
            LET AMAX = MAXIMUM Y
            LET AMIN2 = AMIN - 0.5
            LET AMAX2 = AMAX + 0.5
            CLASS MINIMUM AMIN2
            CLASS MAXIMUM AMAX2
            CLASS WIDTH 1
            LET Y2 X2 = BINNED

      2) For some commands, unequal width bins may be
         helpful.  In particular, for the chi-square goodness
         of fit, it is typically recommended that the minimum
         class frequency be at least 5.  In this case, it may
         be helpful to combine small frequencies in the tails.
         Unequal class width bins can be created with the
         commands

            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = INTEGER FREQUENCY TABLE Y

         If you already have equal width bins data, you can
         use the commands
         
            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = COMBINE FREQUENCY TABLE Y2 X2

         The MINSIZE parameter defines the minimum class
         frequency.  The default value is 5.

Note:
    You can generate beta-geometric random numbers, probability
    plots, and chi-square goodness of fit tests with the following
    commands:

       LET ALPHA = <value>
       LET BETA = <value>
       LET Y = BETA GEOMETRIC RANDOM NUMBERS FOR I = 1 1 N

       BETA GEOMETRIC PROBABILITY PLOT Y
       BETA GEOMETRIC PROBABILITY PLOT Y2 X2
       BETA GEOMETRIC PROBABILITY PLOT Y3 XLOW XHIGH

       BETA GEOMETRIC CHI-SQUARE GOODNESS OF FIT Y
       BETA GEOMETRIC CHI-SQUARE GOODNESS OF FIT Y2 X2
       BETA GEOMETRIC CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    To obtain the first frequency and sample mean estimates and
    the maximum likelihood estimates of alpha and beta, enter the
    command

        BETA GEOMETRIC MAXIMUM LIKELIHOOD Y
        BETA GEOMETRIC MAXIMUM LIKELIHOOD Y2 X2

    The maximim likelihood estimates are computed using the
    parameterization

        PI    = ALPHA/(ALPHA+BETA)
        THETA = 1/(ALPHA + BETA)
    
    The maximim likelihood estimates are the solutions of the
    equations

     (N/PI) - SUM[i=1 to N]{SUM[r=1 to Y(i)-1]
              [1/(1-PI+(r-1)*THETA)]} = 0

     SUM[i=1 to N]{SUM[r=1 to Y(i)-1]
              [(r-1)/(1-PI+(r-1)*THETA)] - SUM[r=1 to Y*i]
              [(r-1)/(1+(r-1)*THETA)] = 0

    Dataplot prints the estimates for both parameterizations.

    You can generate estimates of alpha and beta based on the
    maximum ppcc value or the minimum chi-square goodness of fit
    with the commands

        LET ALPHA1 = <value>
        LET ALPHA2 = <value>
        LET BETA1  = <value>
        LET BETA2  = <value>
        BETA GEOMETRIC KS PLOT Y
        BETA GEOMETRIC KS PLOT Y2 X2
        BETA GEOMETRIC KS PLOT Y3 XLOW XHIGH
        BETA GEOMETRIC PPCC PLOT Y
        BETA GEOMETRIC PPCC PLOT Y2 X2
        BETA GEOMETRIC PPCC PLOT Y3 XLOW XHIGH

    The default values of alpha1 and alpha2 are 0.5 and 5,
    respectively.  The default values for beta1 and beta2 are
    0.5 and 5, respectively.  Due to the discrete nature of the
    percent point function for discrete distributions, the
    ppcc plot will not be smooth.  For that reason, if there is
    sufficient sample size the KS PLOT (i.e., the minimum
    chi-square value) is typically preferred.  However, it may
    sometimes be useful to perform one iteration of the PPCC PLOT
    to obtain a rough idea of an appropriate neighborhood for the
    shape parameters since the minimum chi-square statistic can
    generate extremely large values for non-optimal values of
    the shape parameters.  Also, since the data is integer values,
    one of the binned forms is preferred for these commands.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BGECDF                   = Compute the beta-geometric cumulative
                               distribution function.
    BGECDF                   = Compute the beta-geometric cumulative
                               distribution function.
    BETPDF                   = Compute the beta probability density
                               function.
    GEOPDF                   = Compute the geometric probability
                               mass function.
    WARPDF                   = Compute the Waring probability mass
                               function.
    YULPDF                   = Compute the Yule probability mass
                               function.
    BBNPDF                   = Compute the beta-binomial probability
                               mass function.
    BNBPDF                   = Compute the beta-negative binomial
                               probability mass function.
    INTEGER FREQUENCY TABLE  = Generate a frequency table at
                               integer values with unequal bins.
    COMBINE FREQUENCY TABLE  = Convert an equal width frequency
                               table to an unequal width frequency
                               table.
    KS PLOT                  = Generate a minimum chi-square plot.
    PPCC PLOT                = Generate a ppcc plot.
    PROBABILITY PLOT         = Generate a probability plot.
    MAXIMUM LIKELIHOOD       = Perform maximum likelihood
                               estimation for a distribution.
 
Reference:
    Ole Hesselager (1994), "A Recursive Procedure for Calculations
    of Some Compound Distributions", Astin Bulliten, Vol. 24,
    No. 1, pp. 19-32.

    Sudhir R. Paul (2004), "Applications of the Beta Distribution"
    in "Handbook of the Beta Distribution", edited by Gupta and
    Nadarajah, Marcel-Dekker, pp. 431-436.

    J. O. Irwin (1963), "The Place of Mathematics in Medical and
    Biological Statistics", Journal of the Royal Statistical
    Society, Series A, 126, pp. 1-44.

    Johnson, Kotz, and Kemp (1992), "Univariate Discrete
    Distributions", Second Edition, Wiley, chapter 6.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/7
 
Program 1:
    XLIMITS 0 50
    XTIC OFFSET 0.5 0.5
    LINE BLANK
    SPIKE ON
    SPIKE THICKNESS 0.3
    .
    TITLE CASE ASIS
    LABEL CASE ASIS
    X1LABEL Number of Successes
    Y1LABEL Probability Mass
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    TITLE Alpha = 0.5, Beta = 0.5
    PLOT BGEPDF(X,0.5,0.5) FOR X = 0 1 50
    .
    TITLE Alpha = 3, Beta = 0.5
    PLOT BGEPDF(X,3.0,0.5) FOR X = 0 1 50
    .
    TITLE Alpha = 0.5, Beta = 3
    PLOT BGEPDF(X,0.5,3.0) FOR X = 0 1 50
    .
    TITLE Alpha = 3, Beta = 3
    PLOT BGEPDF(X,3.0,3.0) FOR X = 0 1 50
    .
    END OF MULTIPLOT
    .
    CASE ASIS
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Beta-Geometric Probability Mass Functions
 
Program 2:
let alpha = 1.3
let beta = 3.1
.
let y = beta geometric random numbers for i = 1 1 200
let y3 xlow xhigh = integer frequency table y
class width 1
let amin = minimum y
let amin2 = amin - 0.5
class lower amin2
let amax = maximum y
let amax2 = amax + 0.5
class upper amax2
let y2 x2 = binned y
retain y2 x2 subset y2 > 0
.
beta geometric mle y2 x2
let alpha = alphaml
let beta  = betaml
beta geometric chi-square goodness of fit test y3 xlow xhigh
.
title case asis
title offset 2
label case asis
title Relative Histogram with Overlaid ML Fit PDF
xlimits 0 100
relative hist y2 x2
limits freeze
pre-erase off
line color blue
plot bgepdf(x,alpha,beta) for x = amin 1 amax
limits
pre-erase on
line color black
.
title Probability Plot for ML Fit
y1label Theoretical
x1label Data
x2label Alpha = ^alpha, Beta = ^beta
char x
line blank
beta geometric probability plot y2 x2
.
title Minimum Chi-Square Plot
y1label Chi-Square Value
x1label Beta (Curves represent values of Alpha)
x2label
line solid all
char blank all
beta geometric ks plot y3 xlow xhigh
justification center
move 50 6
text Alpha = ^shape1, Beta = ^shape2
move 50 2
text Minimum Chi-Square Value = ^minks
-----BGEPPF (LET)--------------------------------
 
BGEPPF
 
Name:
    BGEPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the beta-geometric percent point function with
    shape parameters alpha and beta.
 
Description:
    If the probability of success parameter, p, of a geometric
    distribution has a Beta distribution with shape parameters
    alpha and beta, the resulting distribution is referred to
    as a beta-geometric distribution.  For a standard geometric
    distribution, p is assumed to be fixed for successive trials.
    For the beta-geometric distribution, the value of p changes
    for each trial.

    The beta-geometric distribution has the following probability
    density function:

       p(x;alpha,beta) = B(alpha+1,x+beta-1)/B(alpha,beta)
                         x = 1, 2, ...; alpha, beta > 0

    with alpha, beta, and B denoting the two shape parameters and
    the complete beta function, respectively.  See the
    documentation for the BETA command for a description of the
    complete beta function.

    Dataplot computes the cumulative distribution function
    using a recurrence relation given by Hesselager.  Hesselager
    gives the recurrence relation as:

       p(x;alpha,beta) = [(x+alpha-1)/(x+alpha+beta)]*
                         p(x-1;alpha,beta)

    Converting this to the parameterization above yields

       p(x;alpha,beta) = [(x+beta-2)/(x+alpha+beta-1)]*
                         p(x-1;alpha,beta)

     Dataplot computes the percent point function by summing
     the cumulative distribution function until the specified
     probability is obtained.

Syntax:
    LET <y> = BGEPPF(<p>,<alpha>,<beta>)
              <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or variable in the
               interval (0,1);
          <alpha> is a number, parameter, or variable that specifies
               the first shape parameter;
          <beta> is a number, parameter, or variable that specifies
               the second shape parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed beta-geometric ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BGEPPF(0.95,0.5,0.9)
    LET A = BGEPPF(P,2.1,4)
    PLOT BGEPPF(P,ALPHA,BETA) FOR P = 0  0.01  0.99
 
Note:
    Some sources shift this distribution to start at x = 0.  In
    this case, the probability mass function is

       p(x;alpha,beta) = B(alpha+1,x+beta)/B(alpha,beta)
                         x = 0, 1, 2, ...; alpha, beta > 0

    We will refer to the first parameterization as the unshifted
    parameterization and the second parameterization as the
    shifted parameterization.

    To specify the shifted parameterization (i.e., starting
    at x = 0), enter the command

       SET BETA GEOMETRIC DEFINITION SHIFTED

    To reset the unshifted parameterization (i.e., starting
    at x = 1), enter the command

       SET BETA GEOMETRIC DEFINITION UNSHIFTED

    This distribution is also sometimes given with alpha and
    beta reversed.  In this case, the probability mass functions
    become

        p(x;alpha,beta) = B(alpha+1,x+beta-1)/B(alpha,beta)
                          x = 1, 2, ...; alpha, beta > 0

    and

        p(x;alpha,beta) = B(alpha+1,x+beta)/B(alpha,beta)
                          x = 0, 1, 2, ...; alpha, beta > 0
 
    To use this parameterization, simply interchange the order
    in which you give the alpha and beta arguments to the
    BGEPPF command.

Note:
    The beta-geometric as given above is derived as a beta
    mixture of geometric random variables.

    Irwin developed the Waring distribution based on the Waring
    expansion.  The probability mass function for the Waring
    distribution is

       p(x;c,a) = (c-a)*(a+x-1)!*c!/[c*(a-1)!*(c+x)!]
                  x = 0, 1, 2, ...; a > 0; c > a

    The Waring distribution can be computed with the shifted
    form of the beta-geometric distribution with the following
    change in parameters:

        beta = a
        alpha = c - a

    If a = 1, then the Waring distribution reduces to the
    Yule distribution.

    You can compute the Waring (and Yule) percent point functions
    using the BGEPPF routine with the above re-parameterization
    or you can use the WARPPF or YULPPF routines directly
    (enter HELP WARPPF or HELP YULPPF for details).

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BGECDF                   = Compute the beta-geometric cumulative
                               distribution function.
    BGEPDF                   = Compute the beta-geometric probability
                               mass function.
    BETPDF                   = Compute the beta probability density
                               function.
    GEOPDF                   = Compute the geometric probability
                               mass function.
    BBNPPF                   = Compute the beta-binomial (Waring)
                               probability mass function.
    BNBPPF                   = Compute the beta-negative binomial
                               (generalized Waring) probability mass
                               function.
Reference:
    Ole Hesselager (1994), "A Recursive Procedure for Calculations
    of Some Compound Distributions", Astin Bulliten, Vol. 24,
    No. 1, pp. 19-32.

    Sudhir R. Paul (2004), "Applications of the Beta Distribution"
    in "Handbook of the Beta Distribution", edited by Gupta and
    Nadarajah, Marcel-Dekker, pp. 431-436.

    J. O. Irwin (1963), "The Place of Mathematics in Medical and
    Biological Statistics", Journal of the Royal Statistical
    Society, Series A, 126, pp. 1-44.

    Johnson, Kotz, and Kemp (1992), "Univariate Discrete
    Distributions", Second Edition, Wiley, chapter 6.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/7
 
Program:
    XLIMITS 0 1
    XTIC OFFSET 0.5 0.5
    .
    TITLE CASE ASIS
    LABEL CASE ASIS
    Y1LABEL Number of Successes
    X1LABEL Probability
    TITLE DISPLACEMENT 2
    Y1LABEL DISPLACEMENT 15
    X1LABEL DISPLACEMENT 12
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    TITLE Alpha = 0.5, Beta = 0.5
    PLOT BGEPPF(P,0.5,0.5) FOR P = 0  0.01  0.99
    .
    TITLE Alpha = 3, Beta = 0.5
    PLOT BGEPPF(P,3.0,0.5) FOR P = 0  0.01  0.99
    .
    TITLE Alpha = 0.5, Beta = 3
    PLOT BGEPPF(P,0.5,3.0) FOR P = 0  0.01  0.99
    .
    TITLE Alpha = 3, Beta = 3
    PLOT BGEPPF(P,3.0,3.0) FOR P = 0  0.01  0.99
    .
    END OF MULTIPLOT
    .
    CASE ASIS
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Beta-Geometric Percent Point Functions
 
-----BIHISTOGRAM--------------------------------------
 
BIHISTOGRAM
 
Name:
    BIHISTOGRAM
 
Type:
    Graphics Command
 
Purpose:
    Generates a bihistogram.
 
Description:
    The bihistogram is a graphical data analysis technique for
    summarizing and comparing the distributions of the 2 data sets.
    It is a graphical alternative for the various classical 2-sample
    tests (e.g., t for location, F for dispersion).  Frequencies (or
    relative frequencies) are plotted on the vertical axis and the
    response variable is plotted on the horizontal axis.
 
    There are 2 types of bihistograms--
         1) bihistogram (absolute frequencies are plotted);
         2) relative bihistogram (relative frequencies are plotted).
 
    The (relative) bihistogram is a plot consisting of 2 (relative)
    histograms.  The (relative) histogram for data set 1 is positioned
    above the zero-line while the (relative) histogram for data set 2
    is positioned below the zero-line.  The advantage of the
    bihistogram is 2-fold--
       1) the sample sizes do not need to be identical;
       2) many distributional aspects may be simultaneously tested--
          shifts in location, shifts in dispersion, changes in
          symmetry/skewness, outliers, etc.
 
Syntax 1:
    BIHISTOGRAM          <y1> <y2>  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    RELATIVE BIHISTOGRAM <y1> <y2>  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    BIHISTOGRAM Y1 Y2
    RELATIVE BIHISTOGRAM Y1 Y2
    BIHISTOGRAM RUN1 RUN2
    BIHISTOGRAM BATCH1 BATCH2
    BIHISTOGRAM Y1 Y2 SUBSET AUTO 4
    BIHISTOGRAM Y1 Y2 SUBSET STATE 25
 
Note:
    Since the bihistogram is essentially a histogram, the CHARACTERS
    command setting will be ignored.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LINES          = Sets the types for plot lines.
    HISTOGRAM      = Generates a histogram.
    QUAN-QUAN PLOT = Generates a quantile-quantile plot
    BOX PLOT       = Generates a box plot
    YOUDEN PLOT    = Generates a Youden plot.
    T-TEST         = Carries out a 2 sample t test
    ANOVA          = Carries out an ANOVA.
    PLOT           = Generates a data/function plot.
    MULTIPLOT      = Allows multiple plots per page
 
Reference:
 
 
Applications:
    Exploratory Data Analysis
 
Implementation Date:
    88/09
 
Program:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET Y2 = EXPONENTIAL RANDOM NUMBERS FOR I = 1 1 60
    BIHISTOGRAM Y1 Y2
 
-----BILINEAR INTERPOLATION (LET)------------------------------------
 
BILINEAR INTERPOLATION
 
Name:
    BILINEAR INTERPOLATION (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Perform a bilinear interpolation of a series of data points.
 
Description:
    Two dimensional interpolation takes a series of (x,y,z) points and
    generates estimated values for z's at new (x,y) points.
    Interpolation is used when the function that generated the original
    (x,y,z) points is unknown.
 
    Interpolation is related to, but distinct from, fitting a function
    to a series of points.  In particular, an interpolated function
    goes through all the original points while a fitted function does
    not.
 
    There are two distinct types of 2d interpolation.  In the first,
    data is available for a rectangular grid of points and
    interpolation is performed for points off the grid.  In the second,
    data is available for a random set of points and the interpolation
    is generated on a rectangular grid.  This second form can be used
    to generate a contour or surface plot when the data do not form a
    grid.
 
    The BILINEAR INTERPOLATION and BIVARIATE INTERPOLATION commands
    are used for the first type.  The bilinear interpolation is
    analogous to linear interpolation.  A weighted average of the 4
    surrounding grid points is used to determine the interpolated
    value.  The BIVARIATE INTERPOLATION command uses piecewise
    polynomials to do the interpolation and is generally more accurate.
    See the documentation for BIVARIATE INTERPOLATION command for
    details.  The 2D INTERPOLATION command is used for the second type
    of interpolation.
 
Syntax:
    LET <z2> = BILINEAR INTERPOLATION <z1> <y1> <x1> <y2> <x2>
                 <SUBSET/EXCEPT/FOR qualification>
    where <z1> is a variable containing the z-axis data points;
          <y1> is a variable containing the vertical axis data points;
          <x1> is a variable containing the horizontal axis data
               points;
          <x2> is a variable containing the horizontal points where the
               interpolation is to be performed;
          <y2> is a variable containing the vertical points where the
               interpolation is to be performed;
          <z2> is a variable (same length as <x2>) where the
               interpolated values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Z2 = BILINEAR INTERPOLATION Z1 Y1 X1 Y2 X2
 
Note:
    The <z1>, <y1>, and <x1> arrays should be the same size.  In
    addition, <y1> and <x1> must form a rectangular grid.  The <x2>
    and <y2> arrays must be the same size.  An error message is
    printed if any of these conditions is not met.
 
Note:
    The rectangular grid must be complete.  No provision is made for
    missing data values on the grid.
 
Note:
    The interpolation points (i.e., <x2> and <y2>) must be within the
    range of the original data points (i.e., <x1>).  An error message
    is generated if this is not the case.
 
Note:
    The original data do not have to be in sorted order.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    INTERPOLATION            = Compute a cubic spline interpolation of
                               a series of points.
    LINEAR INTERPOLATION     = Compute a linear interpolation of a
                               series of points.
    BIVARIATE INTERPOLATION  = Compute a bivariate interpolation from a
                               grid to random points of a 2D series of
                               points.
    2D INTERPOLATION         = Compute a bivariate interpolation from a
                               2D series of points to a rectangular
                               grid.
    FIT                      = Perform a least squares fit.
 
Reference:
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", Press, Flannery, Teukolsky, and Vetterling.  Cambridge
    University Press, 1989 (chapter 3).
 
Applications:
    Mathematics
 
Implementation Date:
    94/6
 
Program:
    LET X = SEQUENCE -4 1 4 FOR I = 1 1 81
    LET Y = SEQUENCE -4 9 1 4
    LET Z = X**2 + Y**2 - X*Y
    LET Y(5)=-5
    .
    READ X2 Y2
    -3.5 -2.8
    -1.5 -0.8
    -0.6 3.2
    2.1 -3.1
    3.8 3.2
    END OF DATA
    .
    LET Z2 = BILINEAR INTERPOLATION Z Y X Y2 X2
    SET WRITE DECIMALS 3
    PRINT X2 Y2 Z2
 
-----BINARY MATCH (LET)--------------------------------
 
BINARY MATCH DISSIMILARITY
BINARY MATCH SIMILARITY
BINARY ROGERS MATCH DISSIMILARITY
BINARY ROGERS MATCH SIMILARITY
BINARY SOKAL MATCH DISSIMILARITY
BINARY SOKAL MATCH SIMILARITY
BINARY JACCARD DISSIMILARITY
BINARY JACCARD SIMILARITY
BINARY ASYMMETRIC SOKAL MATCH DISSIMILARITY
BINARY ASYMMETRIC SOKAL MATCH SIMILARITY
BINARY ASYMMETRIC DICE MATCH DISSIMILARITY
BINARY ASYMMETRIC DICE MATCH SIMILARITY
YULES Q
YULES Y
YOUDEN INDEX
 
Name:
    BINARY MATCH DISSIMILARITY (LET)
    BINARY MATCH SIMILARITY (LET)
    BINARY ROGERS MATCH DISSIMILARITY (LET)
    BINARY ROGERS MATCH SIMILARITY (LET)
    BINARY SOKAL MATCH DISSIMILARITY (LET)
    BINARY SOKAL MATCH SIMILARITY (LET)
    BINARY JACCARD DISSIMILARITY (LET)
    BINARY JACCARD SIMILARITY (LET)
    BINARY ASYMMETRIC SOKAL MATCH DISSIMILARITY (LET)
    BINARY ASYMMETRIC SOKAL MATCH SIMILARITY (LET)
    BINARY ASYMMETRIC DICE MATCH DISSIMILARITY (LET)
    BINARY ASYMMETRIC DICE MATCH SIMILARITY (LET)
    YULES Q
    YULES Y
    YOUDEN INDEX
 
Type:
    Let Subcommand
 
Purpose:
    Given two binary (i.e., 0 or 1 values) response variables, compute
    various matching statistics that define either a similarity or
    dissimilarity score.
 
Description:
    Given two variables with n parired observations where each
    variable has exactly two possible outcomes, we can generate
    the following 2x2 table:

                      |       Variable 2        |
        Variable 1    | Not Present   Present   |  Row Total
        =======================================================
        Not present   |    A              B     |   A  +  B 
        Present       |    C              D     |   C  +  D 
        =======================================================
        Column Total  |   A + C         B + D   | A + B + C + D

    In the data, we use a value of "0" to denote "not present" and a
    value of "1" to denote "present".

    The parameters A, B, C, and D denote the counts for each category.
    The various matching statistics combine A, B, C, and D in various
    ways.  A distinction is made between "symmetric" and "asymmetric"
    matching statistics.  Symmetric statistics are typically preferred
    when the "0" and the "1" outcome are considered equally meaningful.
    Asymmetric statistics are preferred when the "1" outcome is
    more meaningful.  The case where matching the presence of rare
    events is what is considered important is an example where the
    asymmetric scores would be recommended.

    Specifically

        Symmetric Binary Variables
           Similarity:
           Matching Coefficient:    (A+D)/(A+B+C+D)
           Rogers and Tanimoto:     (A+D)/((A+D) + 2*(B+C))
           Sokal and Sneath:        2*(A+D)/(2*(A+D) + (B+C))

           Dissimilarity:
           Matching Coefficient:    (B+C)/(A+B+C+D)
           Rogers and Tanimoto:     2*(B+C)/((A+D) + 2*(B+C))
           Sokal and Sneath:        (B+C)/(2*(A+D) + (B+C))

        Asymmetric Binary Variables (most important value coded as 1)
           Similarity:
           Jaccard Coefficient:    A/(A+B+C)
           Dice Coefficient:       2*A/(2*A+B+C)
           Sokal Coefficient:      A/(A+2(B+C))

           Dissimilarity:
           Jaccard Coefficient:    (B+C)/(A+B+C)
           Dice Coefficient:       (B+C)/(2*A+B+C)
           Sokal Coefficient:      2*(B+C)/(A+2(B+C))

    Three related statistics are
           Yule's Q:               (A*D - B*C)/(A*D + B*C)
           Yule's Y:               (SQRT(A*D) - SQRT(B*C))/
                                   (SQRT(A*D) + SQRT(B*C))
           Youden index:           (A*D - B*C)/((A+B)*(C+D))

    These statistics are often used to create dissimilarity or
    similarity matrices that will be used as input to various
    multivariate procedures such as clustering.
 
    The above statstics where taken from Kauffman and Rousseeuw (see
    Reference below).  They recommend using the matching coefficient for
    the symmetric case and the Jaccard coefficient for the asymmetric
    case.  However, the above list is not exhaustive and other authors
    recommend other choices.  Also, other sources may have somewhat
    different formulas for these statistics.

    The Youden index (also known as Youden's J statistic) can also be
    expressed as "sensitivity + specificity - 1".  It has a value from
    0 (a test gives the same proportion of positive results for groups
    with and without the disease, i.e., the test has no value) to 1
    (there are no false positives and no false negatives).

    Yule's Q can take a value from -1 to +1 where -1 indicates total
    negative correlation, 0 indicates no association, and +1 indicates
    total positive correlation.  Yule's Q is related to the odds ratio
    in the following way

       Q = (Odds ratio - 1)/(Odds ratio + 1)

    Yule's Y can be defined in terms of Yule's Q as

       Y = (1 - SQRT(1 - Q**2))/Q

    or in terms of the odds ratio

       Y = (SQRT(Odds ratio) - 1)/(SQRT(Odds ratio) + 1)

    Yule's Y is also known as the coefficient of colligation.

Syntax 1:
    LET <par> = BINARY MATCH DISSIMILARITY <y1> <y2>
                              <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed matching dissimilarity
               coefficient is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    LET <par> = BINARY MATCH SIMILARITY <y1> <y2>
                              <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed matching similarity
               coefficient is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Syntax 3:
    LET <par> = BINARY ROGERS MATCH DISSIMILARITY <y1> <y2>
                              <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Rogers and
               Tanimato matching dissimilarity coefficient is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 4:
    LET <par> = BINARY ROGERS MATCH SIMILARITY <y1> <y2>
                              <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Rogers and
               Tanimato matching similarity coefficient is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 5:
    LET <par> = BINARY SOKAL MATCH DISSIMILARITY <y1> <y2>
                              <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Sokal and Sneath
               matching dissimilarity coefficient is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Syntax 6:
    LET <par> = BINARY SOKAL MATCH SIMILARITY <y1> <y2>
                              <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Sokal and Sneath
               matching similarity coefficient is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Syntax 7:
    LET <par> = BINARY JACCARD DISSIMILARITY <y1> <y2>
                               <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Jaccard
               dissimilarity coefficient is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Syntax 8:
    LET <par> = BINARY JACCARD SIMILARITY <y1> <y2>
                               <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Jaccard
               similarity coefficient is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Syntax 9:
    LET <par> = BINARY ASYMMETRIC SOKAL MATCH DISSIMILARITY <y1> <y2>
                                  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Sokal asymmetric
               matching dissimilarity coefficient is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Syntax 10:
    LET <par> = BINARY ASYMMETRIC SOKAL MATCH SIMILARITY <y1> <y2>
                                  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Sokal asymmetric
               matching similarity coefficient is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Syntax 11:
    LET <par> = BINARY ASYMMETRIC DICE MATCH DISSIMILARITY <y1> <y2>
                                  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Dice asymmetric
               matching dissimilarity coefficient is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Syntax 12:
    LET <par> = BINARY ASYMMETRIC DICE MATCH SIMILARITY <y1> <y2>
                                  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Dice asymmetric
               matching similarity coefficient is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Syntax 13:
    LET <par> = YOUDEN INDEX <y1> <y2>  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Youden index is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Syntax 14:
    LET <par> = YULES Q <y1> <y2>  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Yule's Q is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Syntax 15:
    LET <par> = YULES Y <y1> <y2>  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Yule's Y is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Examples:
    LET A = BINARY MATCHING DISSIMILARITY Y1 Y2
    LET A = BINARY MATCHING DISSIMILARITY Y1 Y2 ...
            SUBSET Y1 0 1 SUBSET Y2 0 1

    LET A = BINARY MATCHING SIMILARITY Y1 Y2
    LET A = BINARY ROGERS MATCH DISSIMILARITY Y1 Y2
    LET A = BINARY ROGERS MATCH SIMILARITY Y1 Y2
    LET A = BINARY SOKAL MATCH DISSIMILARITY Y1 Y2
    LET A = BINARY SOKAL MATCH SIMILARITY Y1 Y2
    LET A = BINARY JACCARD DISSIMILARITY Y1 Y2
    LET A = BINARY JACCARD SIMILARITY Y1 Y2
    LET A = BINARY ASYMMETRIC SOKAL MATCH DISSIMILARITY Y1 Y2
    LET A = BINARY ASYMMETRIC SOKAL MATCH SIMILARITY Y1 Y2
    LET A = BINARY ASYMMETRIC DICE MATCH DISSIMILARITY Y1 Y2
    LET A = BINARY ASYMMETRIC DICE MATCH SIMILARITY Y1 Y2

    LET A = YOUDEN INDEX Y1 Y2
    LET A = YULES Q Y1 Y2

Note:
    The two response variables must have the same number of elements.
    For raw data, the response variables should only contain the values
    0 and 1.  See the next Note for a discussion of how to enter the
    A, B, C, and D values directly.
 
Note:
    There are two ways you can define the response variables:

       1) Raw data - in this case, the variables contain
          0's and 1's.

          If the data is not coded as 0's and 1's, Dataplot
          will check for the number of distinct values.  If
          there are two distinct values, the minimum value
          is converted to 0's and the maximum value is
          converted to 1's.  If there is a single distinct
          value, it is converted to 0's if it is less than
          0.5 and to 1's if it is greater than or equal to
          0.5.  If there are more than two distinct values,
          an error is returned.

       2) Summary data - if there are two observations, the data is
          assummed to be the 2x2 summary table.  That is,

              Y1(1) = A
              Y1(2) = C
              Y2(1) = B
              Y2(2) = D

Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COSINE DISTANCE         = Compute the cosine distance.
    MANHATTAN DISTANCE      = Compute the Euclidean distance.
    EUCLIDEAN DISTANCE      = Compute the Euclidean distance.
    MATRIX DISTANCE         = Compute various distance metrics for
                              a matrix.
    GENERATE MATRIX <stat>  = Compute a matrix of pairwise statistic
                              values.
    CLUSTER                 = Perform a cluster analysis.

Reference:
    Kaufman and Rousseeuw (1990), "Finding Groups in Data: An
    Introduction To Cluster Analysis", Wiley.
 
    Youden, W.J. (1950). "Index for rating diagnostic tests,"
    Cancer, No. 3, pp. 32–35.

    Yule, G. Udny (1912), "On the Methods of Measuring Association
    Between Two Attributes," Journal of the Royal Statistical Society,
    Vol. 75, No. 6, pp. 579–652.

Applications:
    Clustering, Multivariate Analysis
 
Implementation Date:
    2017/08
    2019/01: Support for Youden index
    2019/08: Support for Yule's Y
 
Program:
    .  Example from page 24 of Kaufman and Rousseeuw text.
    .  The rows are 8 people and the columns are 10 binary variables
    .
    set write decimals 3
    dimension 100 columns
    .
    read matrix x
    1   0  1  1  0  0  1  0  0  0
    0   1  0  0  1  0  0  0  0  0
    0   0  1  0  0  0  1  0  0  1
    0   1  0  0  0  0  0  1  1  0
    1   1  0  0  1  1  0  1  1  0
    1   1  0  0  1  0  1  1  0  0
    0   0  0  1  0  1  0  0  0  0
    0   0  0  1  0  1  0  0  0  0
    end of data
    .
    let d = generate matrix binary match dissimilarity ...
            x1 x2 x3 x4 x5 x6 x7 x8 x9 x10
    print d
    .
    let ad = generate matrix binary jaccard dissimilarity ...
             x1 x2 x3 x4 x5 x6 x7 x8 x9 x10
    print ad

-----BINARY PLOT--------------------------------------
 
BINARY PLOT
 
Name:
    BINARY PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a summary plot for correct matches, false
    positives, false negatives, true positives, or true
    negatives for certain types of categorical data.
 
Description:
    Given two variables with n parired observations where each
    variable has exactly two possible outcomes, we can generate
    the following 2x2 table:

                      |       Variable 2        |
        Variable 1    |   Success      Failure  |  Row Total
        ====================================================
        Success       |   N11            N12    |  N11 + N12
        Failure       |   N21            N22    |  N21 + N22
        ====================================================
        Column Total  |   N11+N21      N12+N22  |  Total

    The parameters N11, N12, N21, and N22 denote the counts
    for each category.
 
    Success and failure can denote any binary response.
    Dataplot expects "success" to be coded as "1" and "failure"
    to be coded as "0".  Some typical examples would be:

       1) Variable 1 denotes whether or not a patient has a
          disease (1 denotes disease is present, 0 denotes
          disease not present).  Variable 2 denotes the result
          of a test to detect the disease (1 denotes a positive
          result and 0 denotes a negative result).

       2) Variable 1 denotes whether an object is present or
          not (1 denotes present, 0 denotes absent). Variable 2
          denotes a detection device (1 denotes object detected
          and 0 denotes object not detected).

    In these examples, the "ground truth" is typically given
    as variable 1 while some estimator of the ground truth is
    given as variable 2.

    We can define the following quantities from this table:

    1) The proportion of false positives is N21/N (i.e., the
       number of cases where variable 1 is a failure and
       variable 2 is a "successes").  In the context of the first
       examples above, the test detected the disease when it was
       in fact not present.
 
    2) The proportion of false negatives is N12/N (i.e., the
       number of cases where variable 1 is a "success" and
       variable 2 is a "failure").  In the context of the first
       example above, the test does not detect the disease when
       it was in fact present.

    3) The proportion of true positives is then N11/N (i.e., the
       number of cases where variable 1 and variable 2 are both
       "successes").  In the context of the first examples above,
       the test detected the disease when it was in fact present.

    4) The proportion of true negatives is N22/N (i.e., the
       number of cases where variable 1 and variable 2 are both
       "failures").  In the context of the first examples above,
       the test does not detect the disease when it was in fact
       not present.

    5) The proportion of correct matches is (N11+N22)/N (i.e.,
       the sum of true positives and true negatives).  In the
       context of the first example above, the test detects
       disease when it was in fact present and the test does
       not detect the disease when it was in fact not present.

    The above table can be generated when there are one or
    more groups for the data (there will be one table for
    each group, or each cross-tabulation of groups).

    The BINARY PLOT command provides a useful way for
    summarizing the proportions (or percentages) of
    correct matches, false positives, and false negatives
    when there are either one or two groups in the data. 
    
    For the BINARY ... PLOT, the Y coordinate is the group-id
    variable and the X coordinate is the proportion (or
    percentage) for one of the statistics described above.

    This command is most effectively used in combination
    with the MULTIPLOT command.  The columns of the multiplot
    will specify one of the specific statistics and the rows
    of the multiplot will specify the values of the second
    group-id variable (if there is only one group-id variable,
    there will only be one row in the multiplot).  Of course,
    the role of columns and rows in the multiplot can be
    reversed.

    The BINARY TABULATION PLOT is a special form of this
    command that will automatically create the multiplot.
    For this form of the command, the columns in the multiplot
    are:

       1) column 1 = proportion of correct mathces
       2) column 2 = proportion of false negatives
       3) column 3 = proportion of false positives
     
    The first group-id variable specified is used to determine
    the Y coordinate for the individual plots.  The second
    group-id variable is used to define the rows of the
    multiplot.  If there is only one group-id variable,
    create a second group-id variable where all rows in the
    second group-id variable have the same value.

    It is typically easier to use the BINARY TABULATION PLOT
    form of this command.  However, if you want a different
    layout for the multiplot (e.g., you might want a 4-column
    format where true positives and true negatives are used
    rather than correct matches), then you can use the
    BINARY ... PLOT form to have more control of the layout.
    
Syntax 1:
    BINARY <type> PLOT <y1> <y2> <x>
                       <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <x> is a group-id variable;
          <type> is one of the following:
              CORRECT MATCHES
              TRUE POSITIVES
              TRUE NEGATIVES
              FALSE POSITIVES
              FALSE NEGATIVES
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This form will plot percentages (rather than proportions).
 
Syntax 2:
    BINARY PERCENTAGE <type> PLOT <y1> <y2> <x>
                       <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <x> is a group-id variable;
          <type> is one of the following:
              CORRECT MATCHES
              TRUE POSITIVES
              TRUE NEGATIVES
              FALSE POSITIVES
              FALSE NEGATIVES
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This form will plot percentages (rather than proportions).
 
Syntax 3:
    BINARY PROPORTION <type> PLOT <y1> <y2> <x>
                       <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <x> is a group-id variable;
          <type> is one of the following:
              CORRECT MATCHES
              TRUE POSITIVES
              TRUE NEGATIVES
              FALSE POSITIVES
              FALSE NEGATIVES
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This form will plot proportions (rather than percentages).
 
Syntax 4:
    BINARY TABULATION PLOT <y1> <y2> <x1> <x2>
                       <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <x1> is the first group-id variable;
          <x2> is the second group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This form generates the multiplot form of the command.  It
    plots percentages (rather than proportions).
 
Examples:
    BINARY FALSE POSITIVES PLOT Y1 Y2 LAB
    BINARY TABULATION PLOT Y1 Y2 X1 X2
 
Note:
    For the BINARY TABULATION PLOT form of the command, the
    following commands can be used to control the format
    of the multiplot.

        SET CONDITION PLOT LABELS <ON/OFF/XON/YON/BOX>
        SET CONDITION PLOT X AXIS <BOTTOM/TOP/ALTERNATE>
        SET CONDITION PLOT Y AXIS <LEFT/RIGHT/ALTERNATE>
        SET CONDITION PLOT FRAME <DEFAULT/CONNECTED/USER>
        SET CONDITION PLOT LABEL DISPLACEMENT
                <NORMAL/STAGGERED/VALUE>

    Enter HELP CONDITION PLOT for the details of these commands.

    You can use the following command to specify the name of a
    group-id variable that will be used to provide y-axis labels
    for the plot.

    These commands are demonstrated in the Program 3 example.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CONDITION PLOT             = Generate a condition plot.
    MULTIPLOT                  = Generate multiple plots per page.
    ROC CURVE                  = Generate a ROC curve plot.
    FALSE NEGATIVES            = Compute the proportion of
                                 false negatives.
    FALSE POSITIVES            = Compute the proportion of
                                 false positives.
    TRUE NEGATIVES             = Compute the proportion of
                                 true negatives.
    TRUE POSITIVES             = Compute the proportion of
                                 true positives.
    TEST SPECIFICITY           = Compute the test specificity.
    TEST SENSITIVITY           = Compute the test sensitivity.
    RELTIVE RISK               = Compute the relative risk.
    ODDS RATIO                 = Compute the bias corrected
                                 log(odds ratio).
    ODDS RATIO STANDARD ERROR  = Compute the standard error of the
                                 bias corrected log(odds ratio).

Reference:
    Hosmer and Lemeshow (2000), "Applied Logistic Regression",
    Second Edition, Wiley, pp. 160-164.
 
Applications:
     Categorical Data Analysis
 
Implementation Date:
    2007/5
 
Program 1:
    let n = 1
    .
    let p = 0.2
    let y1 = binomial rand numb for i = 1 1 100
    let p = 0.1
    let y2 = binomial rand numb for i = 1 1 100
    .
    let p = 0.4
    let y1 = binomial rand numb for i = 101 1 200
    let p = 0.08
    let y2 = binomial rand numb for i = 101 1 200
    .
    let p = 0.15
    let y1 = binomial rand numb for i = 201 1 300
    let p = 0.18
    let y2 = binomial rand numb for i = 201 1 300
    .
    let p = 0.6
    let y1 = binomial rand numb for i = 301 1 400
    let p = 0.45
    let y2 = binomial rand numb for i = 301 1 400
    .
    let p = 0.3
    let y1 = binomial rand numb for i = 401 1 500
    let p = 0.1
    let y2 = binomial rand numb for i = 401 1 500
    .
    let x = sequence 1 100 1 5
    .
    label
    title case asis
    title offset 2
    label case asis
    tic mark label case asis
    tic offset units data
    xlimits 0  100
    major xtic mark number 6
    minor xtic mark number 1
    xtic mark offset 5 5
    ylimits 1 5
    major ytic mark number 5
    minor ytic mark number 0
    ytic offset 0.5 0.5
    y1tic mark label format alpha
    y1tic mark label content Groupsp()1 Groupsp()2 Groupsp()3 Groupsp()4 ...
                            Groupsp()5
    ygrid on
    grid pattern dotted
    .
    multiplot 1 3
    multiplot corner coordinates 10 0 90 95
    multiplot scale factor 1 2.5
    character circle
    character fill on
    character color blue
    character fill color blue
    character hw 2 1.50
    line blank
    .
    x1label Correct Matches
    binary correct match plot y1 y2 x
    x1label False Positives
    binary false positives plot y1 y2 x
    x1label False Negatives
    binary false negatives plot y1 y2 x
    .
    end of multiplot
    justication center
    move 50 97
    case asis
    text Binary Plot

Program 2:
    let n = 1
    .
    let p = 0.2
    let y1 = binomial rand numb for i = 1 1 100
    let p = 0.1
    let y2 = binomial rand numb for i = 1 1 100
    .
    let p = 0.4
    let y1 = binomial rand numb for i = 101 1 200
    let p = 0.08
    let y2 = binomial rand numb for i = 101 1 200
    .
    let p = 0.15
    let y1 = binomial rand numb for i = 201 1 300
    let p = 0.18
    let y2 = binomial rand numb for i = 201 1 300
    .
    let p = 0.6
    let y1 = binomial rand numb for i = 301 1 400
    let p = 0.45
    let y2 = binomial rand numb for i = 301 1 400
    .
    let p = 0.3
    let y1 = binomial rand numb for i = 401 1 500
    let p = 0.1
    let y2 = binomial rand numb for i = 401 1 500
    .
    let x1 = sequence 1 100 1 5
    let ntemp = size y1
    let x2 = sequence 1 50 1 2 for i = 1 1 ntemp
    .
    label
    title case asis
    title offset 2
    label case asis
    tic mark label case asis
    tic offset units data
    xlimits 0  100
    major xtic mark number 6
    minor xtic mark number 1
    xtic mark offset 5 5
    ylimits 1 5
    major ytic mark number 5
    minor ytic mark number 0
    ytic offset 0.5 0.5
    ytic mark label format alpha
    ytic mark label content Groupsp()1 Groupsp()2 Groupsp()3 Groupsp()4 ...
                            Groupsp()5
    ygrid on
    grid pattern dotted
    .
    multiplot corner coordinates 10 0 90 95
    character circle
    character fill on
    character color blue
    character fill color blue
    character hw 2 1.50
    line blank
    .
    set condition plot y axis alternate
    set condition plot x axis bottom
    set condition plot frame connected
    frame corner coordinates 5 5 95 95
    multiplot corner coordinates 10 10 90 95
    binary tabulation plot y1 y2 x1 x2
    end of multiplot
    .
    case asis
    justification center
    move 50 3
    text Percentage
    height 3
    move 50 97
    text Binary Tabulation Plot

Program 3:
    orientation portrait
    skip 25
    read alarm.dat x1 x2 y1 y2
    name x1 inst
    name x2 src
    name y1 exp
    name y2 obs
    .
    let string s1 = Instsp()1
    let string s2 = Instsp()2
    let string s3 = Instsp()3
    let string s4 = Instsp()4
    let string s5 = Instsp()5
    let string s6 = Instsp()6
    let string s7 = Instsp()7
    let string s8 = Instsp()8
    let string s9 = Instsp()9
    let string s10 = Instsp()10
    let string s11 = Instsp()11
    let string s12 = Instsp()12
    let string s13 = Instsp()13
    let string s14 = Instsp()14
    let string s15 = Instsp()15
    let ig = group label s1 to s15
    .
    character circle
    character fill on
    character color blue
    character hw 0.5 0.375
    line blank
    xlimits 0 100
    major xtic mark number 6
    minor xtic mark number 1
    xtic offset 3 3
    let instdist = distinct inst
    let ninst = size instdist
    let srcdist = distinct src
    let nsrc = size srcdist
    ylimits 1 nsrc
    major ytic mark number nsrc
    minor ytic mark number 0
    ytic offset 0.5 0.5
    ygrid on
    ygrid pattern dotted
    .
    x3label
    label case asis
    title case asis
    title offset 15
    .
    set condition plot y axis alternate
    set condition plot x axis bottom
    set condition plot frame connected
    set binary tabulation plot group name ig
    frame corner coordinates 5 5 95 95
    multiplot corner coordinates 10 10 90 95
    multiplot scale factor 10 2.5
    binary tabulation plot y1 y2 x2 x1
    .
    case asis
    justification center
    move 50 3
    text Percentage
    height 3
    move 50 97
    text Binary Tabulation Plot

-----BINCDF (LET)--------------------------------
 
BINCDF
 
Name:
    BINCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the binomial cumulative distribution function.
 
Description:
    The binomial distribution is used when there are exactly two
    mutually exclusive outcomes of a trial.  These outcomes are often
    called successes and failures.  The binomial probability
    distribution is the probability of obtaining X successes in n
    trials.  It has the following probability density function:
       b(x;x,n) = (n x)*p**x*(1-p)**(n-x)
    where p is the probability of a success on a single trial and
    (n x) is the combinatorial function of n things taken x at a time.
    It has the formula:
       (n x) = n!/(x!*(n-x)!)
    The cumulative distribution is the probability of obtaining x or
    fewer successes in n trials.  It is the sum of the binomial
    probabilities of 0 to x.
 
Syntax:
    LET <y2> = BINCDF(<y1>,<p>,<n>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is an integer variable, number, or parameter between 0
               and <n> (a warning message is printed if it is not);
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed binomial cdf value is stored;
          <p> is a number or parameter that is the probability of
               success on a single trial (it should be between 0 and 1);
          <n> is the number of trials;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BINCDF(3,0.5,10)
    LET X2 = BINCDF(X1,0.3,25))
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BINPDF = Compute the binomial probability density function.
    BINPPF = Compute the binomial percent point function.
    POIPDF = Compute the Poisson probability density function.
    POICDF = Compute the Poisson cumulative distribution function.
    POIPPF = Compute the Poisson percent point function.
    NBCDF  = Compute the negative binomial cumulative distribution
             function.
    NBPDF  = Compute the negative binomial probability density function.
    NBPPF  = Compute the negative binomial percent point function.
    GEOCDF = Compute the geometric cumulative distribution function.
    GEOPDF = Compute the geometric probability density function.
    GEOPPF = Compute the geometric percent point function.
 
Reference:
    "Discrete Univariate Distributions", Johnson and Kotz, 1970.
 
Applications:
    XX
 
Implementation Date:
    94/4
 
Program:
    YLIMITS 0 1
    MAJOR YTIC NUMBER 6
    MINOR YTIC NUMBER 1
    YTIC DECIMAL 1
    XLIMITS 0 50
    XTIC OFFSET 0.5 0.5
    LINE BLANK
    SPIKE ON
    SPIKE LINE DASH
    CHARACTER CIRCLE
    CHARACTER FILL ON
    CHARACTER SIZE 1.2
    TITLE AUTOMATIC
    X1LABEL NUMBER OF SUCCESSES
    Y1LABEL PROBABILITY
    PLOT BINCDF(X,0.5,50) FOR X = 0 1 50
 
-----BINNED (LET)-----------------------------------------
 
BINNED
 
Name:
    BINNED (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Bin (i.e., create a frequency table) a response variable.  
 
Description:
    Binning a data variable means to divide it into classes
    and compute the frequency for each class.  This is the
    numerical equivalent of a histogram.  Creating the classes
    for the binning uses the same rules as the histogram.
    That is

      1) The class width is 0.3 times the sample standard
         deviation.
      2) The lower limit is the sample mean minus 6 times the
         standard deviation.
      3) The upper limit is the sample mean plus 6 times the
         standard deviation.

    As with the histogram, you can use the CLASS WIDTH, CLASS
    LOWER, and CLASS UPPER commands to override these defaults.
    Also, you can specify that relative frequencies rather than
    counts be computed.   The command
    SET RELATIVE HISTOGRAM <AREA/PERCENT> can be used to specify
    whether relative frequencies are computed so that the area
    sums to 1 or so that frequencies sum to 1.  The first option,
    which is the default, is useful for when using the relative
    binning as an estimate of a probability distribution.  The
    second option is useful when you want to see what percentage
    of the data falls in a given class. 
 
Syntax:
    LET <y2> <x> = BINNED <y1>    <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the response variable;
          <y2> is a variable where the computed counts (or
              frequencies) are stored;
          <x> is a variable where the computed bin mid-points
              are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y2 X = BINNED Y
    LET Y2 X = BINNED Y SUBSET TAG > 2
    LET Y2 X = RELATIVE BINNED Y
 
Default:
    None
 
Synonyms:
    FREQUENCY TABLE is a synonym for BINNED and RELATIVE FREQUENCY
    TABLE is a synonym for RELATIVE BINNED.
 
Related Commands:
    HISTOGRAM                = Generate a histogram.
    FREQUENCY PLOT           = Generate a frequency plot.
    FREQUENCY                = Compute frequency of occurences of specified
                               values in a variable.
    CLASS LIMIT              = Set class limits for histograms.
    COMBINE FREQUENCY TABLE  = Combine low frequency classes in a frequency
                               table.
 
Applications:
    Data Analysis
 
Implementation Date:
    1998/12
 
Program:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET Y2 X = RELATIVE FREQUENCY TABLE Y
    SET WRITE DECIMALS 3
    PRINT X Y2
 
-----BINOMIAL (LET)--------------------------------
 
BINOMIAL
 
Name:
    BINOMIAL (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the binomial coefficients.
 
Description:
    The binomial coefficient of the integers N and M is:

        B(N,M) = N!/(M!(N-M)!)

    where "!" is the factorial function.

    Dataplot computes this function using the BINOM function
    from the SLATEC library.  This routine was written by 
    W. Fullerton of LANL.
 
Syntax:
    LET <y> = BINOMIAL(<n>,<m>)    <SUBSET/EXCEPT/FOR qualification>
    where <n> is a non-negagive integer number, variable or
              parameter;
          <m> is a non-negagive integer number, variable or
              parameter (less than or equal to <n>);
          <y> is a variable or a parameter (depending on what <n> 
               and <m> are) where the computed binomial coefficient
               values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BINOMIAL(10,6)
    LET A = BINOMIAL(N,M)
    LET Y = BINOMIAL(N,M)  FOR M = 0 1 N
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BINOM is a synonym for BINOMIAL.
 
Related Commands:
    BINCDF       = Compute the binomial cumulative distribution
                   function.
    BINPDF       = Compute the binomial probability mass function.
    BINPPF       = Compute the binomial percent point function.
    BN           = Compute Bernoulli number or polynomial.
 
Reference:
    "Statistical Methods", Eigth Edition, Snedecor and Cochran, 
    1989, Iowa State University Press, page 112.
 
Applications:
    Probability
 
Implementation Date:
    1997/12
 
Program:
    LET N = 20
    TITLE BINOMIAL COEFFICIENTS: N = 20
    LINE BLANK
    SPIKE ON
    PLOT BINOM(N,M) FOR I = 0 1 N

-----BINOMIAL PRODUCT CONFIDENCE LIMITS (LET)--------------------------
 
BINOMIAL PRODUCT CONFIDENCE LIMITS
 
Name:
    BINOMIAL PRODUCT CONFIDENCE LIMITS (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the standard error and confidence limits for the product of
    two binomial proportions.
 
Description:
    Given two binomial proportions, p1 and p2, with associated
    sample sizes, n1 and n2, the formula for the confidence interval
    for the ratio p1/p2 is

         p1*p2  +/-  NORPPF(alpha/2)*SE

    where SE denotes the standard error of p1*p2

         SE = SQRT(p2**2*p1*(1 - p1)/n1 +
                   p1**2*p2*(1 - p2)/n2)

    In the above formula, we actually use the Bayes estimators of
    p1 and p2:

          p1hat = (V + 0.5)/(n1 + 1)
          p2hat = (U + 0.5)/(n2 + 1)

    with V and U denoting the number of successes in the binomial
    trials.

Syntax:
    LET <se> <lowlim> <upplim> = BINOMIAL PRODUCT CONFIDENCE LIMITS
             <p1> <n1> <p2> <n2> <alpha>
             <SUBSET/EXCEPT/FOR qualification>
    where <p1> is constant, parameter, or variable that contains the
              proportion of successes for the first sample;
          <n1> is constant, parameter, or variable that contains the
              number of trials for the first sample;
          <p2> is constant, parameter, or variable that contains the
              proportion of successes for the second sample;
          <n2> is constant, parameter, or variable that contains the
              number of trials for the second sample;
          <alpha> is constant or parameter that contains the significance
              level;
          <se> is a variable that contains the standard error of the
              computed product (p1*p2);
          <lowlim> is a variable that contains the computed lower
              confidence limit;
          <upplim> is a variable that contains the computed upper
              confidence limit;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The <p1>, <n1>, <p2>, and <n2> arguments can be either parameters
    or variables.  If they are variables, then the variables must have
    the same number of elements.  The <alpha> argument is always assumed
    to be either a constant or a parameter.

    If <p1>, <n1>, <p2> and <n2> are all parameters, then <se>,
    <lowlim> and <upplim> will be parameters.  Otherwise, they will be
    variables.

Examples:
    LET SE AL AU = BINOMIAL PRODUCT CONFIDENCE LIMITS P1 N1 P2 N2 ALPHA
 
Note:
    If you would like to use this command on raw data (i.e., you have
    variables containing a sequence of 0's and 1's), do something like
    the following

        LET YSUM1 = SUM Y1
        LET N1 = SIZE Y1
        LET P1 = YSUM1/N1
        LET YSUM2 = SUM Y2
        LET N2 = SIZE Y2
        LET P2 = YSUM2/N2
        LET SE AL AU = BINOMIAL PRODUCT CONFIDENCE LIMITS P1 N1 P2 N2 ALPHA

    If you have group-id variables (X1 and X2), you would do something
    like

        SET LET CROSS TABULATE COLLAPSE
        LET YSUM1 = CROSS TABULATE SUM Y1 X1
        LET N1 = CROSS TABULATE SIZE Y1 X1
        LET P1 = YSUM1/N1
        LET YSUM2 = CROSS TABULATE SUM Y2 X2
        LET N2 = CROSS TABULATE SIZE Y2 X2
        LET P2 = YSUM2/N2
        LET SE AL AU = BINOMIAL PRODUCT CONFIDENCE LIMITS P1 N1 P2 N2 ALPHA

    In this case, P1, N1, P2, and N2 are now variables rather than
    parameters.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BINOMIAL RATIO CONF LIMITS      = Compute confidence limits for
                                      the ratio of two binomial
                                      proportions.
    AGRESTI-COULL CONF LIMITS       = Compute the Agresti-Coull confidence
                                      limits for binomial proportions.
    EXACT BINOMIAL CONF LIMITS      = Compute the exact binomial confidence
                                      limits for binomial proportions.
    DIFFERENCE OF PROP CONF LIMITS  = Compute the confidence limtis for
                                      the difference of two binomial
                                      proportions.
    BINOMIAL PROPORTION             = Compute the binomial proportion
                                      statistic.
    AGRESTI-COULL                   = Compute Agresti-Coull confidence
                                      limits statistic for binomial
                                      proportions.
    BINOMIAL PROPORTION TEST        = Perform a binomial proportions test.
    CROSS TABULATE (LET)            = Perform a cross tabulation for a
                                      specified statistic.
 
Reference:
    Private communication with Andrew Rukhin and Bill Strawderman.

Applications:
    Statistics
 
Implementation Date:
    2010/07
 
Program:
    LET P1 = 8/12
    LET N1 = 12
    LET P2 = 7/8
    LET N2 = 8
    LET ALPHA = 0.95
    .
    LET BPROD = P1*P2
    LET SE LOWLIM UPPLIM = BINOMIAL PRODUCT CONFIDENCE LIMIT ...
        P1 N1 P2 N2 ALPHA

-----BINOMIAL PROPORTION TEST--------------------------------------
 
BINOMIAL PROPORTION TEST
 
Name:
    BINOMIAL PROPORTION TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform a large sample hypothesis test for the equality of two
    binomial proportions.
 
Description:
    Given a set of N1 observations in a variable X1 and a set of
    N2 observations in a variable X2, we can compute a normal
    approximation test that the two proportions are equal (or
    alternatively, that the difference of the two proportions is
    equal to 0).  In the following, let p1 and p2 be the population
    proportion of successes for samples one and two, respectively.

    The hypothesis test that the two binomial proportions are
    equal is

        H0: p1 = p2
        Ha: p1 <> p2
        Test Statistic: Z = (p1hat - p2hat)/
                        SQRT(phat*(1-phat)*((1/n1) + (1/n2)))

                        where phat is the proportion of successes
                        for the combined sample and

                        phat = (n1*p1hat + n2*phat2)/(n1 + n2) 
                             = (x1 + x2)/(n1 + n2)
        Significance Level: alpha
        Critical Region: For a two-tailed test

                            Z > NORPPF(1 - alpha/2)
                            Z < NORPPF(alpha/2)

                         For a lower tailed test

                            Z < NORPPF(alpha)

                         For an upper tailed test

                            Z > NORPPF(1 - alpha)
        Conclusion: Reject the null hypothesis if Z is in the
                    critical region

    Dataplot computes this test for a number of different
    significance levels.
 
Syntax 1:
    BINOMIAL PROPORTION TEST  <y1>  <y2>
                              <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for the case where you have raw data and
    want to perform a two-tailed test.

Syntax 2:
    BINOMIAL PROPORTION LOWER TAILED TEST  <y1>  <y2>
                              <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for the case where you have raw data and
    want to perform a lower tailed test.

Syntax 3:
    BINOMIAL PROPORTION UPPER TAILED TEST  <y1>  <y2>
                              <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for the case where you have raw data and
    want to perform a upper tailed test.

Syntax 4:
    BINOMIAL PROPORTION TEST  <p1>  <n1>  <p2>  <n2>
    where <p1> is a parameter that specifies the proportion of
               successes for sample 1;
          <n1> is a parameter that specifies the sample size for
               sample 1;
          <p2> is a parameter that specifies the proportion of
               successes for sample 2;
    and   <n2> is a parameter that specifies the sample size for
               sample 2.
 
    This syntax is used for the case where you have summary data
    and want to perform a two-tailed test.

Syntax 5:
    BINOMIAL PROPORTION LOWER TAILED TEST  <p1>  <n1>  <p2>  <n2>
    where <p1> is a parameter that specifies the proportion of
               successes for sample 1;
          <n1> is a parameter that specifies the sample size for
               sample 1;
          <p2> is a parameter that specifies the proportion of
               successes for sample 2;
    and   <n2> is a parameter that specifies the sample size for
               sample 2.
 
    This syntax is used for the case where you have summary data
    and want to perform a lower tailed test.

Syntax 6:
    BINOMIAL PROPORTION UPPER TAILED TEST  <p1>  <n1>  <p2>  <n2>
    where <p1> is a parameter that specifies the proportion of
               successes for sample 1;
          <n1> is a parameter that specifies the sample size for
               sample 1;
          <p2> is a parameter that specifies the proportion of
               successes for sample 2;
    and   <n2> is a parameter that specifies the sample size for
               sample 2.
 
    This syntax is used for the case where you have summary data
    and want to perform a upper tailed test.

Examples:
    BINOMIAL PROPORTION TEST Y1 Y2
    BINOMIAL PROPORTION TEST P1 N1 P2 N2
 
Note:
    For small samples, it is recommended that the Fisher exact
    test be used instead of this test.
 
Note:
    The value of the test statistic and the CDF value are saved in the
    internal parameters STATVAL and STATCDF, respectively.  The CDF value
    is NORCDF(Z) where NORCDF is the cumulative distribution function
    for the standard normal distribution.
 
    For a lower tailed test, the p-value is equal to STATCDF.  For
    an upper tailed test, the p-value is equal to 1 - STATCDF.  For a
    two-tailed test, the p-value is equal to 2*(1 - STATCDF).

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DIFFERENCE OF PROPORTION     = Compute the confidence interval
        CONFIDENCE LIMITS          for the difference of proportions.
    PROPORTION CONFIDENCE LIMITS = Compute the confidence interval
                                   for the difference of proportions.
    FISHER EXACT TEST            = Perform a Fisher exact test.
 
References:
    NIST/SEMATECH e-Handbook of Statistical Methods,
    http://www.itl.nist.gov/div898/handbook/prc/section3/prc33.htm.
 
    Ryan (2008), "Modern Engineering Statistics", Wiley, pp. 124-126.

Applications:
    Categorical Data Analysis
 
Implementation Date:
    2008/8
 
Program 1:
    LET X1 = 32
    LET N1 = 38
    LET P1 = X1/N1
    LET X2 = 39
    LET N2 = 44
    LET P2 = X1/N1
    BINOMIAL PROPORTION TEST P1 N1 P2 N2

-----BINOMIAL PROPORTION (LET)-----------------------------------------
 
BINOMIAL PROPORTION
 
Name:
    BINOMIAL PROPORTION (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the binomial proportion of a variable.
 
Description:
    The binomial proportion is defined as the number of successes
    divided by the number of trials.

    In this context, we define success as "1" and failure as "0".
    Dataplot actually allows any two distinct values to be used.
    However, the larger value will always be considered "success" and
    the smaller value will always be considered "failure".  If the
    variable contains more than two distinct values, an error is
    reported.

    The case where the data consists of a sequence of 0's and 1's
    is referred to as the raw data case.

    There may be times where we only have summary data.  This case is
    referred to as the summary data case.  The two response variables
    are the number of successes and the number of trials and we use the
    BINOMIAL RATIO command instead of the BINOMIAL PROPORTION command.
 
    We may also sometimes be interested in the difference of two
    binomial proportions.  The DIFFERENCE OF BINOMIAL PROPORTIONS
    command can be used for this case.

Syntax 1:
    LET <par> = BINOMIAL PROPORTION <y>
                <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the computed binomial proportion
              is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This is for raw data case and <y> should contain a sequence of
    0's and 1's.

Syntax 2:
    LET <par> = DIFFERENCE OF BINOMIAL PROPORTIONS <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed difference of
              binomial proportions is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax computes the binomial proportions of <y1> and <y2> and
    then computes their difference.  The <y1> and <y2> variables do not
    need to be the same length.
 
    This is for raw data case and <y1> and <y2> should both contain a
    sequence of 0's and 1's.

Syntax 3:
    LET <par> = BINOMIAL RATIO <ysucc>  <ytrial>
                <SUBSET/EXCEPT/FOR qualification>
    where <ysucc> is a variable that contains the number of successes;
          <ytrial> is a variable that contains the number of trials;
          <par> is a parameter where the computed binomial proportion
              is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This is for summary data case.  The <ysucc> and <ytrial> variables
    must contain non-negative (they will be rounded to the closest
    integer) values and should be of the same length.

    The elements in <ysucc> and <ytrial> are summed if they have
    length greater than one and a single binomial proportion is returned.
    If they have only a single element, they must still be defined as
    variables rather than parameters.  For example,

       LET YSUCC = DATA 12
       LET YTRIAL = DATA 20

    defines YSUCC and YTRIAL as variables with a single row.  However

       LET YSUCC = 12
       LET YTRIAL = 20

    defines them as parameters and they cannot be used with this
    command.

Examples:
    LET A = BINOMIAL PROPORTION Y1
    LET A = BINOMIAL PROPORTION Y1  SUBSET TAG > 2
    LET A = DIFFERENCE OF BINOMIAL PROPORTION Y1 Y2
 
Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

    These various commands are actually where the BINOMIAL PROPORTION
    and BINOMIAL RATIO statistics are most commonly used.

    For the BINOMIAL PROPORTION and BINOMIAL RATIO statistics, the
    TABULATE/CROSS TABULATE commands will return the number of trials
    and the Agresti-Coull lower and upper confidence limits in addition
    to the binomial proportion.

    For the BINOMIAL PROPORTION and BINOMIAL RATIO statistics, the
    FLUCTUATION PLOT command supports an uncertainty option based on
    the Agresti-Coull interval.  Enter HELP FLUCTUATION PLOT for details.

Default:
    None
 
Synonyms:
    BINOMIAL PROBABILITY is a synonym for BINOMIAL PROPORTION
 
Related Commands:
    AGRESTI-COULL             = Compute Agresti-Coull confidence limits
                                for binomial proportions.
    EXACT BINOMIAL            = Compute "exact" confidence limits for
                                binomial proportions.
    BINOMIAL PROPORTION TEST  = Perform a binomial proportions test.
    CROSS TABULATE            = Perform a cross-tabulation for a
                                specified statistic.
    FLUCTUATION PLOT          = Generate a fluctuation plot.
 
Reference:
    NIST/SEMATECH e-Handbook of Statistical Methods,
    http://www.itl.nist.gov/div898/handbook/prc/section3/prc33.htm.
 
    Ryan (2008), "Modern Engineering Statistics", Wiley, pp. 124-126.

Applications:
    Statistics
 
Implementation Date:
    2008/4: BINOMIAL PROPORTION added
    2008/9: DIFFERENCE OF BINOMIAL PROPORTIONS added
    2010/1: BINOMIAL RATIO added
 
Program:
    LET N = 1
    LET P = 0.8
    LET Y = BINOMIAL RANDOM NUMBERS FOR I = 1 1 50
    LET A = BINOMIAL PROPORTION Y
 
-----BINOMIAL RATIO CONFIDENCE LIMITS (LET)----------------------------
 
BINOMIAL RATIO CONFIDENCE LIMITS
 
Name:
    BINOMIAL RATIO CONFIDENCE LIMITS (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the confidence limits for the ratio of two binomial
    proportions.
 
Description:
    Given two binomial proportions, p1 and p2, with associated
    sample sizes, n1 and n2, the formula for the confidence interval
    for the ratio p1/p2 is

         (p1/p2)*EXP{+/-NORPPF(alpha/2)*
         SQRT((1-p1)/(n1*p1) + (1-p2)/(n2*p2))}

    If p1 and p2 are both 1, the resulting uncertainty is zero.
    If either p1 or p2 is zero, we have division by zero in the
    above formula.  For that reason, we use the Bayes estimators of
    p1 and p2:

          p1hat = (V + 0.5)/(n1 + 1)
          p2hat = (U + 0.5)/(n2 + 1)

    with V and U denoting the number of successes in the binomial
    trials.  We then use these updated estimates for p1 and p2 in
    the above formula.

Syntax:
    LET <ratio> <lowlim> <upplim> = BINOMIAL RATIO CONFIDENCE LIMITS
                <p1> <n1> <p2> <n2> <alpha>
                <SUBSET/EXCEPT/FOR qualification>
    where <p1> is constant, parameter, or variable that contains the
              proportion of successes for the first sample;
          <n1> is constant, parameter, or variable that contains the
              number of trials for the first sample;
          <p2> is constant, parameter, or variable that contains the
              proportion of successes for the second sample;
          <n2> is constant, parameter, or variable that contains the
              number of trials for the second sample;
          <alpha> is constant or parameter that contains the significance
              level;
          <ratio> is a variable that contains the computed ratio (p1/p2);
          <lowlim> is a variable that contains the computed lower
              confidence limit;
          <upplim> is a variable that contains the computed upper
              confidence limit;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The <p1>, <n1>, <p2>, and <n2> arguments can be either parameters
    or variables.  If they are variables, then the variables must have
    the same number of elements.  The <alpha> argument is always assumed
    to be either a constant or a parameter.

    If <p1>, <n1>, <p2> and <n2> are all parameters, then <ratio>,
    <lowlim> and <upplim> will be parameters.  Otherwise, they will be
    variables.

Examples:
    LET RATIO AL AU = BINOMIAL RATIO CONFIDENCE LIMITS P1 N1 P2 N2 ALPHA
 
Note:
    If you would like to use this command on raw data (i.e., you have
    variables containing a sequence of 0's and 1's), do something like
    the following

        LET YSUM1 = SUM Y1
        LET N1 = SIZE Y1
        LET P1 = YSUM1/N1
        LET YSUM2 = SUM Y2
        LET N2 = SIZE Y2
        LET P2 = YSUM2/N2
        LET RATIO AL AU = BINOMIAL RATIO CONFIDENCE LIMITS P1 N1 P2 N2 ALPHA

    If you have group-id variables (X1 and X2), you would do something
    like

        SET LET CROSS TABULATE COLLAPSE
        LET YSUM1 = CROSS TABULATE SUM Y1 X1
        LET N1 = CROSS TABULATE SIZE Y1 X1
        LET P1 = YSUM1/N1
        LET YSUM2 = CROSS TABULATE SUM Y2 X2
        LET N2 = CROSS TABULATE SIZE Y2 X2
        LET P2 = YSUM2/N2
        LET RATIO AL AU = BINOMIAL RATIO CONFIDENCE LIMITS P1 N1 P2 N2 ALPHA

    In this case, P1, N1, P2, and N2 are now variables rather than
    parameters.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BINOMIAL PRODUCT CONF LIMITS    = Compute confidence limits for
                                      the product of two binomial
                                      proportions.
    AGRESTI-COULL CONF LIMITS       = Compute the Agresti-Coull confidence
                                      limits for binomial proportions.
    EXACT BINOMIAL CONF LIMITS      = Compute the exact binomial confidence
                                      limits for binomial proportions.
    DIFFERENCE OF PROP CONF LIMITS  = Compute the confidence limtis for
                                      the difference of two binomial
                                      proportions.
    BINOMIAL PROPORTION             = Compute the binomial proportion
                                      statistic.
    AGRESTI-COULL                   = Compute Agresti-Coull confidence
                                      limits statistic for binomial
                                      proportions.
    BINOMIAL PROPORTION TEST        = Perform a binomial proportions test.
    CROSS TABULATE (LET)            = Perform a cross tabulation for a
                                      specified statistic.
 
Reference:
    Private communication with Andrew Rukhin and Bill Strawderman.

Applications:
    Statistics
 
Implementation Date:
    2009/10
 
Program:
    LET P1 = 8/12
    LET N1 = 12
    LET P2 = 7/8
    LET N2 = 8
    LET ALPHA = 0.05
    .
    LET ARATIO LOWLIM UPPLIM = BINOMIAL RATIO CONFIDENCE LIMIT ...
        P1 N1 P2 N2 ALPHA

-----BINPAT (LET)--------------------------------
 
BINPAT
 
Name:
    BINPAT (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the binary pattern of -1 and +1.
 
Description:
    The BINPAT function is used in the construction of Yates design
    matrices for 2-level full factorial designs.  If one is
    constructing a design to examine k factors, such a Yates design
    will have 2**k rows and k columns.  The first argument (usually a
    variable) designates the row numbers in the matrix and so is
    commonly the sequence 1 to 2**k.  The second argument (usually a
    parameter) designates the column number in the Yates design matrix
    and so is commonly 1 to k.  The output from the BINPAT command
    (usually a variable) is a series of -1's and +1's corresponding to
    a given column in the Yates design matrix.  Thus if one were
    constructing a 2-level design to examine 3 factors (i.e., k=3),
    the Yates design matrix would consist of 2**3=8 rows and k=3
    columns.  The Yates design matrix could be computed with the
    following commands:
       LET X = SEQUENCE 1 1 8
       LET X1 = BINPAT(X,1)
       LET X2 = BINPAT(X,2)
       LET X3 = BINPAT(X,3)
    This would yield the following Yates values for X1, X2, and X3:
         X1     X2     X3
         ================
         -1     -1     -1
         +1     -1     -1
         -1     +1     -1
         +1     +1     -1
         -1     -1     +1
         +1     -1     +1
         -1     +1     +1
         +1     +1     +1
 
Syntax:
    LET <y2> = BINPAT(<y1>,<a1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter specifying the rows of the
               design matrix;;
          <a1> is a parameter designating the column of the design
               matrix to compute;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed column of the design matrix is
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional and
    rarely used in this context.
 
Examples:
    LET X2 = BINPAT(X,2)
    LET X3 = BINPAT(X,3)
 
 
Note:
    Yates designs can also be read directly from the various on-line
    design of experiment files in the DATAPLOT reference directory.
    The list of available designs can be viewed by entering the
    command:
        LIST 2KINDEX.DAT
    The 2**3 design can be read by entering:
        SKIP 25
        READ 2TO3.DAT X1 X2 X3
    Note that the above file names can vary on some operating systems.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = BINPAT(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    XX
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    LET X = SEQUENCE 1 1 8
    LET X1 = BINPAT(X,1)
    LET X2 = BINPAT(X,2)
    LET X3 = BINPAT(X,3)
 
-----BINPDF (LET)--------------------------------
 
BINPDF
 
Name:
    BINPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the binomial probability density function.
 
Description:
    The binomial distribution is used when there are exactly two
    mutually exclusive outcomes of a trial.  These outcomes are often
    called successes and failures.  The binomial probability
    distribution is the probability of obtaining X successes in n
    trials.  It has the following probability density function:

       b(x;x,n) = (n x)*p**x*(1-p)**(n-x)

    where p is the probability of a success on a single trial and
    (n x) is the combinatorial function of n things taken x at a
    time.  It has the formula:

       (n x) = n!/(x!*(n-x)!)
 
Syntax:
    LET <y2> = BINPDF(<y1>,<p>,<n>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is an integer variable, number, or parameter between 0
               and <n> (a warning message is printed if it is not);
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed binomial pdf value is stored;
          <p> is a number or parameter that is the probability of
               success on a single trial (it should be between 0 and 1);
          <n> is the number of trials;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BINPDF(3,0.5,10)
    LET X2 = BINPDF(X1,0.3,25))
 
Note:
    For a number of commands utilizing the binomial
    distribution, it is convenient to bin the data.  There
    are two basic ways of binning the data.

      1) For some commands (histograms, maximum likelihood
         estimation), bins with equal size widths are
         required.  This can be accomplished with the
         following commands:

            LET AMIN = MINIMUM Y
            LET AMAX = MAXIMUM Y
            LET AMIN2 = AMIN - 0.5
            LET AMAX2 = AMAX + 0.5
            CLASS MINIMUM AMIN2
            CLASS MAXIMUM AMAX2
            CLASS WIDTH 1
            LET Y2 X2 = BINNED

      2) For some commands, unequal width bins may be
         helpful.  In particular, for the chi-square goodness
         of fit, it is typically recommended that the minimum
         class frequency be at least 5.  In this case, it may
         be helpful to combine small frequencies in the tails.
         Unequal class width bins can be created with the
         commands

            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = INTEGER FREQUENCY TABLE Y

         If you already have equal width bins data, you can
         use the commands
         
            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = COMBINE FREQUENCY TABLE Y2 X2

         The MINSIZE parameter defines the minimum class
         frequency.  The default value is 5.

Note:
    For the binomial distribution, we make a distinction
    between n and ntrials.  The n parameter denotes the number
    of events in a single binomial trial (so if n is 10, the
    number of successes could be any integer value between 0
    and 10 for a single trial).  The ntrial parameter is then
    the number of times the binomial experiment is repeated.
    For example, if we had 5 trials with n = 10 for each trial,
    our data could then be represented in either one of the
    following ways:

       1) The data could be represented as a sequence of
          50 (50 = 5*10) 0's and 1's.

       2) Alternatively, the data could consist of 5 values
          between 0 and 10 (the sum of these 5 values would
          equal the sum of the 1's if the data were given as
          a sequence of 0's and 1's).

    For maximum likelihood estimation, the choices are
    effectively equivalent.  However, for probability plots,
    ppcc plots, and chi-square plots, the second alternative
    generates more useful results.  Note that the specific
    split between "ntrials" and "n" can be somewhat arbitrary,
    although any reasonable choice should work well.

Note:
    You can generate binary random numbers, probability plots,
    and chi-square goodness of fit tests with the following
    commands:

       LET NTRIALS = <value>
       LET N = <value>
       LET P = <value>
       LET Y = BINOMIAL RANDOM NUMBERS FOR I = 1 1 NTRIALS

       BINOMIAL PROBABILITY PLOT Y
       BINOMIAL PROBABILITY PLOT Y2 X2
       BINOMIAL PROBABILITY PLOT Y3 XLOW XHIGH

       BINOMIAL CHI-SQUARE GOODNESS OF FIT Y
       BINOMIAL CHI-SQUARE GOODNESS OF FIT Y2 X2
       BINOMIAL CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    To obtain the maximum likelihood estimate of p, enter
    the commands

        BINOMIAL MAXIMUM LIKELIHOOD Y
        BINOMIAL MAXIMUM LIKELIHOOD Y2 X2

    The maximum likelihood estimator of p (n and ntrials are
    assumed known and fixed) is
  
       phat = (SUM[i=1 to ntrial][x(i)]/ntrail)/n

    with x(i) denoting the number of successes in the ith trial.

    In addition to the estimate for p, a confidence interval
    for p based on the Agresti and Coull method is generated.
    If the sample size is 25 or less, the exact interval is also
    generated.  For more information on these confidence
    intervals, see the following web site (from the NIST/SEMATECH
    e-Handbook of Statistical Methods):

    http://www.itl.nist.gov/div898/handbook/prc/section2/prc241.htm

    You can generate an estimate of p based on the maximum ppcc
    value or the minimum chi-square goodness of fit with the
    commands

        LET N = <value>
        LET P1  = <value>
        LET P2  = <value>
        BINOMIAL KS PLOT Y
        BINOMIAL KS PLOT Y2 X2
        BINOMIAL KS PLOT Y3 XLOW XHIGH
        BINOMIAL PPCC PLOT Y
        BINOMIAL PPCC PLOT Y2 X2
        BINOMIAL PPCC PLOT Y3 XLOW XHIGH

    The default values of p1 and p2 are 0.05 and 0.95,
    respectively.  Due to the discrete nature of the percent point
    function for discrete distributions, the ppcc plot will not be
    smooth.  For that reason, if there is sufficient sample size
    the KS PLOT (i.e., the minimum chi-square value) is typically
    preferred.  However, it may sometimes be useful to perform
    one iteration of the PPCC PLOT to obtain a rough idea of an
    appropriate neighborhood for the shape parameters since the
    minimum chi-square statistic can generate extremely large
    values for non-optimal values of the shape parameters.
    Also, since the data is integer values, one of the binned
    forms is preferred for these commands.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BINCDF = Compute the binomial cumulative distribution function.
    BINPPF = Compute the binomial percent point function.
    POIPDF = Compute the Poisson probability density function.
    POICDF = Compute the Poisson cumulative distribution function.
    POIPPF = Compute the Poisson percent point function.
    NBCDF  = Compute the negative binomial cumulative distribution
             function.
    NBPDF  = Compute the negative binomial probability density function.
    NBPPF  = Compute the negative binomial percent point function.
    GEOCDF = Compute the geometric cumulative distribution function.
    GEOPDF = Compute the geometric probability density function.
    GEOPPF = Compute the geometric percent point function.
 
Reference:
    "Discrete Univariate Distributions", Johnson and Kotz, 1970.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    1994/4
 
Program:
    YLIMITS 0 0.15
    MAJOR YTIC MARK NUMBER 4
    XLIMITS 0 50
    XTIC OFFSET 0.5 0.5
    LINE BLANK
    SPIKE ON
    SPIKE LINE DASH
    CHARACTER CIRCLE
    CHARACTER FILL ON
    CHARACTER SIZE 1.2
    TITLE AUTOMATIC
    X1LABEL NUMBER OF SUCCESSES
    Y1LABEL PROBABILITY
    PLOT BINPDF(X,0.5,50) FOR X = 0 1 50
 
-----BINPPF (LET)--------------------------------
 
BINPPF
 
Name:
    BINPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the binomial percent point function.
 
Description:
    The binomial distribution is used when there are exactly two
    mutually exclusive outcomes of a trial.  These outcomes are often
    called successes and failures.  The binomial probability
    distribution is the probability of obtaining X successes in n
    trials.  It has the following probability density function:
       b(x;x,n) = (n x)*p**x*(1-p)**(n-x)
    where p is the probability of a success on a single trial and
    (n x) is the combinatorial function of n things taken x at a time.
    It has the formula:
       (n x) = n!/(x!*(n-x)!)
    The percent point function is the inverse of the cumulative
    distribution function.  The cumulative distribution sums the
    probability from 0 to the given x value.  The percent point
    function takes a cumulative probability value and computes the
    corresponding x value.
 
    The input value is a real number between 0 and 1 (since it
    corresponds to a probability).
    number.
 
Syntax:
    LET <y2> = BINPPF(<y1>,<p>,<n>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, a number, or a parameter in the range 0
              to 1;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed binomial ppf value is stored;
          <p> is a number or parameter that is the probability of
               success on a single trial (it should be between 0 and 1);
          <n> is the number of trials;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BINPPF(0.9,0.5,50)
    LET X2 = BINPPF(X1,0.7,100)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BINPDF = Compute the binomial probability density function.
    BINCDF = Compute the binomial cumulative distribution function.
    POIPDF = Compute the Poisson probability density function.
    POICDF = Compute the Poisson cumulative distribution function.
    POIPPF = Compute the Poisson percent point function.
    NBCDF  = Compute the negative binomial cumulative distribution
             function.
    NBPDF  = Compute the negative binomial probability density function.
    NBPPF  = Compute the negative binomial percent point function.
    GEOCDF = Compute the geometric cumulative distribution function.
    GEOPDF = Compute the geometric probability density function.
    GEOPPF = Compute the geometric percent point function.
 
Reference:
    "Discrete Univariate Distributions", Johnson and Kotz, 1969.
 
Applications:
    XX
 
Implementation Date:
    94/4
 
Program:
    XLIMITS 0 1
    MAJOR XTIC NUMBER 6
    MINOR XTIC NUMBER 1
    XTIC DECIMAL 1
    TITLE AUTOMATIC
    X1LABEL PROBABILITY
    Y1LABEL NUMBER OF SUCCESSES
    PLOT BINPPF(X,0.5,50) FOR X = 0 0.01 1
 
e----BIPLOT (LET)-------------------------------------------------
 
BIPLOT
 
Name:
    BIPLOT (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the biplot of a matrix.
 
Description:
    Given a matrix X where the columns denote variables and the rows
    denote observations, the biplot can be used to generate a graphical
    representation of X.  The "bi" in biplot refers to the joint
    representation of the rows and columns of X, not the fact that the
    biplot is typically rendered as a two-dimensional plot.

    The primary purpose of the biplot is to determine what type of model
    might be appropriate for analyzing the data in the matrix.

    The biplot method used in Dataplot is based on the singular value
    factorization of the matrix.  The rank 2 singular value factorization
    leads to the following equation (X is a matrix with n rows and p
    columns)

       X(2) = A*B'

    where

       A = | U(11)*l(1)^k   U(12)*l(2)^k|
           | U(21)*l(1)^k   U(22)*l(2)^k|
                     ...
           | U(n1)*l(1)^k   U(n2)*l(2)^k|

       B' = | V(11)*l(1)^(1-k)   V(21)*l(1)^(1-k) ...  V(p1)*l(1)^(1-k)|
            | V(21)*l(2)^(1-k)   V(22)*l(2)^(1-k) ...  V(p2)*l(2)^(1-k)|

       l(1) >= l(2) >= ... >= l(p)  are the eigenvalues of X
       U are the left eigenvectors of X
       V are the right eigenvectors of X

    The rank 2 approximation will be useful if the l(3), ... ,l(p) are
    small relative to the l(1) and l(2).

    The two colums of A are used as coordinates for plotting the n rows
    (these are referred to as the row markers).  Similarly, the two rows
    of B' are the coordinates for plotting the variables (these are
    referred to as the column markers).

    The following values of k are typically used:

        k = 0.5   when row and column markers are jointly displayed
        k = 0     when only column markers are displayed
        k = 1     when only row markers are displayed

    To set the value of k, enter the command

       SET BIPLOT COEFFICIENT <VALUE>

    The default is 0.5 (for versions prior to 2018/11, the default is
    1.0).  Values outside the (0,1) interval will be set to the default.

    It is also common to scale the data by subtracting the column mean.
    Alternatively, you can subtract the grand mean.  To specify the
    scaling to use, enter

        SET BIPLOT SCALE <COLUMN MEAN/GRAND MEAN/NONE>

    The default is COLUMN MEAN (for versions prior to 2018/11, the
    default is GRAND MEAN).

    Although the rank 2 singular value factorization is most commonly
    used for biplots, the biplot can in fact be based on any rank 2
    approximation of the X matrix.  However, other rank 2 approximations
    are not currently supported in Dataplot.

    A goodness of fit measure for the biplot is

        (l(1) + l(2))/(l(1) + l(2) + l(3) + ... + l(p))

    This is the ratio of the sum of the first two eigenvalues to the
    sum of all the eigenvalues.  This value is an indication of how well
    the rank 2 approximation of X fits the original X matrix.

    Dataplot saves this goodness of fit statistic in the parameter
    BIPLOTGF when it executes the BIPLOT command.

    The primary application of the biplot is as a diagnostic tool.
    Specifically,

      1. If both the row markers and column markers are colinear and
         they form a 90 degree angle, an additive model is suggested.

      2. If both the row markers and column markers are colinear but
         they do not form a 90 degree angle, a concurrent model is
         suggested.

      3. If the row markers are colinear but the column markers are not
         colinear, a column linear model is suggested.

      4. If the row markers are not colinear but the column markers are
         colinear, a row linear model is suggested.

    For a disucussion of row linear, column linear, and concurrent models,
    see the Mandel reference.  For a fuller discussion of interpreting and
    using biplots, see the References section below.

Syntax:
    LET <y> <x> <tag> = BIPLOT <m>     <SUBSET/EXCEPT/FOR qualification>
    where <m> is a matrix for which the biplot coordinates are to be
                 computed;
          <y> is an variable where the y coordinates of the biplot
                 values are saved;
          <x> is an variable where the x coordinates of the biplot
                 values are saved;
          <tag> is a variable that identifies whether the given row of
                 <y> and <x> is a row marker (<tag> = 1) or a column
                 marker (<tag> = 2);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y X TAG = BIPLOT M
 
Note:
    Dataplot generates the most basic form of the biplot.  The Gower,
    Lubbe, and le Roux (2011) book provides an extensive treatment of
    the many variants of the basic biplot.

    In the terminology of Gower, Lubbe, and le Roux, Dataplot generates
    a 2-dimensional principal components analysis (PCA) asymmetric biplot.
    Asymmetric implies the rows and columns of the matrix cannot be
    interchanged.  The columns represent continuous variables.  Coordinates
    are generated in 2 dimensions and the rank 2 approximation is based
    on the singular value factorization.

Note:
    Mandel (1995) discusses "row linear" and "column linear" models for
    two-way tables.  This is an alternative to the use of biplots.  Mandel
    gives some comparisons of his models to the biplot.  Row linear and
    column linear models are what Gabriel refers to as "row regressions"
    and "column regressions".

Note:
    Matrices are created with either the READ MATRIX command or the
    MATRIX DEFINITION command.  Enter HELP MATRIX DEFINITION and HELP
    READ MATRIX for details.
 
Note:
    The columns of a matrix are accessible as variables by appending an
    index to the matrix name.  For example, the 4x4 matrix C has
    columns C1, C2, C3, and C4.  These columns can be operated on like
    any other DATAPLOT variable.
 
Note:
    The maximum size matrix that Dataplot can handle is set when Dataplot
    is built on a particular site.  However, for the size problems for
    which biplots are used, insufficient storage space for the matrix is
    typically not an issue.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    READ MATRIX          = Read data into a matrix.
    PRINCIPAL COMPONENTS = Compute the principal components of a
                           matrix.
    SINGULAR VALUES      = Compute the singular values of a matrix.
    SINGULAR VALUE FACT  = Compute the singular value factorization of
                           a matrix.
    TWO WAY PLOT         = Given a response variable and associated
                           variables containing laboratory id's and
                           material id's, generate a plot of each
                           laboratory against the column average. In
                           addition, perform a row linear (or column
                           linear) analysis of variance. 
 
Reference:
    Gabriel and Badru (1978), "The biplot as a diagnostic tool for models
    of two-way tables," Technometrics, Vol. 20, pp. 47-68.

    du Toit, Steyn, and Stumpf (1986), "Graphical Exploratory Data
    Analysis," Springer-Verlang, 1986, pp. 107-114.

    Mandel (1995), "Analysis of Two-Way Layouts," Chapman-Hall, pp. 49-53.
 
    Gower, Lubbe, Le Roux (2011), "Understanding Biplots", Wiley.
 
Applications:
    Multivariate Analysis, Analysis of Two-Way Tables
 
Implementation Date:
    2009/04
 
Program:
    .  Step 1: Define data
    .
    .          Source: "The Biplot as a Diagnostic Tool for Models of
    .                  Two-Way Tables", Brandu, Gabriel, Technometrics,
    .                  February, 1978.
    .
    .                  Data is yeilds of cotton, with rows denoting variety
    .                  and columns denoting center.
    .
    DIMENSION 100 COLUMNS
    READ MATRIX M
     1.55 1.26 1.41  1.78
     3.39 3.47 2.82  3.89
     1.95 1.91 1.74  2.29
    10.47 9.12 9.55 17.78
     1.45 1.51 1.41  1.70
     3.72 3.55 3.09  4.27
     4.47 4.07 3.98  4.47
    END OF DATA
    .
    LET P = MATRIX NUMBER OF COLUMNS M
    LOOP FOR K = 1 1 P
        LET M^K = LOG(M^K)
    END OF LOOP
    .
    .  Step 2: Generate the coordinates for the biplot (this is a
    .          combined row/column marker biplot).
    .
    LET Y X TAG = BIPLOT M
    LET Y2 = Y
    LET X2 = -X
    .
    .  Step 3: Now plot the biplot.
    .
    .
    .  Step 3a: Iteration 1 will draw row markers as filled
    .           circle and column markers as filled squares.
    .
    TITLE Example of Biplot
    TITLE OFFSET 2
    TITLE CASE AS IS
    LABEL CASE ASIS
    X1LABEL Biplot Goodness of Fit = ^BIPLOTGF
    LEGEND CASE ASIS
    LEGEND JUSTIFICATION CENTER
    LEGEND 1 Squares - Column Markers
    LEGEND 2 Circles - Row Markers
    LEGEND 1 COORDINATES 50 7
    LEGEND 2 COORDINATES 50 4
    .
    CHARACTER HW 2.0 1.5 ALL
    CHARACTER CIRCLE SQUARE
    CHARACTER FILL SOLID ALL
    CHARACTER COLOR BLUE RED
    LINE BLANK ALL
    PLOT Y2 X2 TAG
    .
    .  Step 3b: Now generate row and column ID's
    .
    LEGEND 1
    LEGEND 2
    LIMITS FREEZE
    PRE-ERASE OFF
    CHARACTER OFFSET 1.5 0 ALL
    CHARACTER COLOR BLACK ALL
    .
    LET NTOT = SIZE Y
    LET ROWID = SEQUENCE 1 1 NTOT
    CHARACTER AUTOMATIC ROWID
    PLOT Y2 X2 ROWID SUBSET TAG = 1
    PLOT Y2 X2 ROWID SUBSET TAG = 2
 
-----BIRINT (LET)--------------------------------

BIRINT

Name:
   BIRINT (LET)
 
Type:
    Library Function

Purpose:
    This program computes the integral of the Airy function Bi(x).

Description:
    The BIRINT function is defined as:

        BIRINT(x) = {integral 0 to x} Bi(t) dt

    with Bi denoting the Airy function of the second kind.

    Dataplot computes this function using ACM Algorithm 757 (see
    Reference: below).  The function is computed using Chebyshev
    expansions, the coefficients of which are given to 20 decimal
    places.

Syntax:
    LET <y> = BIRINT(<x>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, variable or parameter;
          <y> is a variable or a parameter (depending on what <x> 
               is) where the computed BIRINT function values are
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BIRINT(2.3)
    PLOT BIRINT(X) FOR  X = -5 0.01 5
    LET X2 = BIRINT(X1) FOR X1 = 0.1 0.1 3.0
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    AIRY       = Compute the Airy function.
    BAIRY      = Compute the Airy function of the second kind.
    AIRINT     = Compute the integral of the Airy function.
    BESSIN     = Compute the modified Bessel function of the first
                 kind and order N.
    BESSJN     = Compute the Bessel function of the first kind and
                 order N.
    BESSKN     = Compute the modified Bessel function of the third
                 kind and order N.
    BESSYN     = Compute the Bessel function of the second kind and
                 order N.
    J0INT      = Compute the integral of the Bessel function of
                 the first kind and order 0.
    K0INT      = Compute the integral of the modified Bessel
                 function of the third kind and order 0.
    Y0INT      = Compute the integral of the Bessel function of
                 the second kind and order 0.

Reference:
    "ACM Transactions of Mathematical Software", Allan MacLead,
    Vol. 22, No. 3, September, 1996, pp. 288-301.
 
Applications:
    Special Functions
 
Implementation Date:
    2005/11
 
Program:
    TITLE BIRINT FUNCTION
    PLOT BIRINT(X) FOR X = -5 0.01 5
 
-----BIVARIATE INTERPOLATION (LET)------------------------------------
 
BIVARIATE INTERPOLATION
 
Name:
    BIVARIATE INTERPOLATION (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Perform a bivariate interpolation of a series of gridded data
    points.
 
Description:
    Two dimensional interpolation takes a series of (x,y,z) points and
    generates estimated values for z's at new (x,y) points.
    Interpolation is used when the function that generated the original
    (x,y,z) points is unknown.
 
    Interpolation is related to, but distinct from, fitting a function
    to a series of points.  In particular, an interpolated function
    goes through all the original points while a fitted function does
    not.
 
    There are two distinct types of 2d interpolation.  In the first,
    data is available for a rectangular grid of points and
    interpolation is performed for points off the grid.  In the second,
    data is available for a random set of points and the interpolation
    is generated on a rectangular grid.  This second form can be used
    to generate a contour or surface plot when the data do not form a
    grid.
 
    The BILINEAR INTERPOLATION and BIVARIATE INTERPOLATION commands
    are used for the first type.  The bilinear interpolation is
    analogous to linear interpolation.  The bivariate interpolation
    uses an interpolating function that is a piecewise polynomial
    function that is represented as a tensor product of one-dimensional
    B-splines.  That is,
                  NX  NY
        S(x,Y) = SUM SUM  a  U (x) V (y)
                 i=1 j=1   ij i     j
    where U(i) and V(j) are one-dimensional B-spline basis functions
    and the coefficients a(i,j) are chosen so that the interpolating
    function equals the z axis input values at the grid points.
 
    The 2D INTERPOLATION command is used for the second type of
    interpolation.  See the documentation for the BILINEAR
    INTERPOLATION and the 2D INTERPOLATION commands for more details
    on these methods.
 
Syntax:
    LET <z2> = BIVARIATE INTERPOLATION <z1> <y1> <x1> <y2> <x2>
                 <SUBSET/EXCEPT/FOR qualification>
    where <z1> is a variable containing the z-axis data points;
          <y1> is a variable containing the vertical axis data points;
          <x1> is a variable containing the horizontal axis data
               points;
          <x2> is a variable containing the horizontal points where the
               interpolation is to be performed;
          <y2> is a variable containing the vertical points where the
               interpolation is to be performed;
          <z2> is a variable (same length as <x2>) where the
               interpolated values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Z2 = BIVARIATE INTERPOLATION Z1 Y1 X1 Y2 X2
 
Note:
    The <z1>, <y1>, and <x1> arrays should be the same size.  In
    addition, <y1> and <x1> must form a rectangular grid.  The <x2>
    and <y2> arrays must be the same size.  An error message is
    printed if any of these conditions is not met.
 
Note:
    The rectangular grid must be complete.  No provision is made for
    missing data values on the grid.
 
Note:
    The interpolation points (i.e., <x2> and <y2>) must be within the
    range of the original data points (i.e., <x1>).  An error message
    is generated if this is not the case.
 
Note:
    The original data do not have to be in sorted order.
 
Note:
    The degree of the polynomial in each direction can be specified
    with the following commands:
        LET XDEGREE = <value>
        LET YDEGREE = <value>
    where <value> is 3 for cubic polynomials, 2 for quadratic
    polynomials, and 1 for linear polynomials.  The default is cubic
    polynomials.
 
Note:
    DATAPLOT uses the B2INK and B2VAL routines written by Dr. Ron
    Boisvert of the National Institute of Standards and Technology.
    These routines are available in the NIST CMLIB (Core Mathematical
    Library) library.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    INTERPOLATION            = Compute a cubic spline interpolation of
                               a series of points.
    LINEAR INTERPOLATION     = Compute a linear interpolation of a
                               series of points.
    BILINEAR INTERPOLATION   = Compute a bilinear interpolation from a
                               grid to random points of a 2D series of
                               points.
    2D INTERPOLATION         = Compute a bivariate interpolation from a
                               2D series of points to a rectangular
                               grid.
    FIT                      = Perform a least squares fit.
 
Reference:
    "A Practical Guide to Splines", Carl de Boor, Springer-Verlang,
    1978.
 
    "Efficient Computer Manipulation of Tensor Products", Carl de Boor,
    ACM Transaction of Mathematical Software, Vol. 5, 1979
    (pp. 173-182).
 
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", Press, Flannery, Teukolsky, and Vetterling.  Cambridge
    University Press, 1989 (pages 170-172).
 
Applications:
    Mathematics
 
Implementation Date:
    94/6
 
Program:
    LET X = SEQUENCE -4 1 4 FOR I = 1 1 81
    LET Y = SEQUENCE -4 9 1 4
    LET Z = X**2 + Y**2 - X*Y
    LET Y(5)=-5
    .
    READ X2 Y2
    -3.5 -2.8
    -1.5 -0.8
    -0.6 3.2
    2.1 -3.1
    3.8 3.2
    END OF DATA
    .
    LET Z2 = BIVARIATE INTERPOLATION Z Y X Y2 X2
    SET WRITE DECIMALS 3
    PRINT X2 Y2 Z2
 
-----BIVARIATE NORMAL TOLERANCE REGION PLOT-------------------------
 
BIVARIATE NORMAL TOLERANCE REGION PLOT
 
Name:
    BIVARIATE NORMAL TOLERANCE REGION PLOT
    BIVARIATE NORMAL CONFIDENCE REGION PLOT
    POINCARE PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a bivariate normal tolerance region plot.  Alternatively,
    a bivariate normal confidence region plot or a Poincare plot can be
    generated.
 
Description:
    The bivariate normal tolerance region and bivariate normal confidence
    region plots have a starting point of a Youden plot.  The Poincare plot
    has as a starting point of a lag plot.  All of these plots then overlay
    different types of ellipses on the basic underlying plot.

    A tolerance interval calculate a confidence interval
    that contains at least a fixed percentage (or proportion)
    of the data.

    There are two probability values involved in the tolerance
    region:

        1) The coverage probability is the fixed percentage
           of the data to be covered.  We call this delta.

        2) The confidence level.  We call this gamma.

    That is, we can state with gamma% confidence that at least
    delta% of the data fall within the given limits.  For example,
    if gamma = 0.95 and delta = 0.90, we say that we have
    a "95% confidence interval for 90% coverage". 

    The TOLERANCE LIMITS command is used to compute
    univariate normal tolerance intervals (it will also
    compute non-parametric tolerance interals).  The
    BASIS TOLERANCE LIMITS is used to compute normal,
    lognormal, and Weibull tolerance limits.

    The BIVARIATE NORMAL TOLERANCE REGION PLOT is used for
    the case where we have bivariate, normally distributed
    data.  In this case, if X and Y denote our bivariate data,
    we define a region A such that

        Pr(Pr[(X,Y) element of A] > delta} = gamma

    Hall and Sheldon state that with a properly chosen K
    the following ellipse is the smallest region that will
    contain delta of the probability mass:

         (1/(1 - rho**2))*[((x - mu(x))/sigma(x))**2 -
         2*rho*((x - mu(x))/sigma(x))*((y - mu(y))/sigma(y)) +
         ((y - mu(y))/sigma(y))] = K

    When we have a sample of n data points, we replace the
    population means, standard deviations, and correlation
    with the sample values. 

    The problem then becomes how to find the appropriate
    value of K.
   
    Hall and Sheldon describe how to find K for several
    different cases.  We focus on their case 4 where the
    population means and standard deviations and the population
    correlation between X and Y are unknown.

    Hall and Sheldon developed a table (Table 3 in their paper)
    using Monte Carlo methods for gamma = 0.75, 0.90, and 0.95
    and delta = 0.50, 0.80, 0.90, and 0.95 for n = 10 to 50.

    Dataplot will use the tabled values when appropriate.
    For n > 50 or for gamma and delta values not available
    in the table, Dataplot uses an approximation given on
    pp. 325-327 of Krishnamoorthy.

    We recommend using the tabled values for gamma and
    delta for smaller values of n. 

    The BIVARIATE NORMAL TOLERANCE REGION PLOT generates a
    scatter plot of Y versus X and then overlays the
    tolerance region ellipse on this plot.  Note that Dataplot
    allows multiple ellipses (corresponding to different values
    of delta) to be overlaid on the plot.

    You can specify the desired value of gamma by entering
    the command

        LET GAMMA = <value>

    If you do not specify a value for gamma, then 0.95 will
    be used.

    To specify a single value of delta, then enter the command

        LET DELTA = <value>

    To specify multiple values of delta, see Syntax 3.  If
    no delta values are specified, then 0.90 will be used.

    Alternatively, a bivariate normal confidence region plot can be
    generated.  In this case, we are generating a joint confidence
    interval for the means of the two datasets.  For this alternative,
    the ellipse has a similar form to the tolerance ellipse.  However,
    the K is replaced with Hotelling's T**2:

        T**2 = 2*{(p - 1)/(p - 2)}*F(1 - alpha)(2,p - 1)

    with F denoting the percent point function of the F
    distribution.

    The bivariate normal confidence regions are discussed in
    the ISO 13528 standard based on the method given by Jackson.

    The Poincare plots Y(i) versus Y(i-1).  This is equivalent to a
    lag plot.  However, the Poincare plot adds an overlaid ellipse
    to the plot.  Specifically, compute (where Y1 is Y(i) and Y2 is
    Y(i-1) and Y is the original series)

       X1 = (Y1 - Y2)/SQRT(2)
       X2 = (Y1 + Y2)/SQRT(2)

    X1 and X2 correspond to the rotation of Y1 and Y2 by PI/4.  Then
    the quantities SD1 and SD2 correspond to the standard deviations
    of X1 and X2, respectively.  The quantities SD1 and SD2 and the
    ratio SD1/SD2 are used to characterize the original time series.
    Also, SD2 defines the radius of the major axis of the ellipse and
    SD1 defines the radius of the minor axis of the ellipse.  The
    ellipse is centered at the means of Y1 and Y2.

    The lag plot is typically used to detect first order autocorrelation
    (e.g., to test the independence of residuals in a regression model).
    The Poincare plot is typically used in a context where we expect
    first order autocorrelation and is used to characterize that
    autocorrelation.

Syntax 1:
    BIVARIATE NORMAL TOLERANCE REGION PLOT <y1> <y2>
                     <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used when there are no groups in the
    data and there is a single value of delta.

Syntax 2:
    BIVARIATE NORMAL TOLERANCE REGION PLOT <y1> <y2> <lab>
                     <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <lab> is a group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used when there are multiple groups in the
    data (e.g., multiple labs or multiple methods) and there is
    a single value of delta.

Syntax 3:
    BIVARIATE NORMAL TOLERANCE REGION PLOT <y1> <y2> <lab> <delta>
                     <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <lab> is a group-id variable;
          <delta> is a variable containing the desired values
                of delta;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used when there are multiple groups in the
    data (e.g., multiple labs or multiple methods) and multiple
    values of delta are desired.

    If you want multiple values of delta when there are no
    groups, create a group-id variable with all values equal.
    For example

        LET LAB = 1 FOR I = 1  1  N

Syntax 4:
    BIVARIATE NORMAL CONFIDENCE REGION PLOT <y1> <y2>
                     <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used when there are no groups in the
    data and there is a single value of delta (here delta
    denotes the confidence level rather than the coverage
    level).

Syntax 5:
    BIVARIATE NORMAL CONFIDENCE REGION PLOT <y1> <y2> <lab>
                     <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <lab> is a group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used when there are multiple groups in the
    data (e.g., multiple labs or multiple methods) and there is
    a single value of delta (here delta denotes a confidence level
    rather than a confidence level).

Syntax 6:
    BIVARIATE NORMAL CONFIDENCE REGION PLOT <y1> <y2> <lab> <delta>
                     <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <lab> is a group-id variable;
          <delta> is a variable containing the desired values
                of delta;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used when there are multiple groups in the
    data (e.g., multiple labs or multiple methods) and multiple
    values of delta (here delta denotes the confidence level
    rather than the coverage level) are desired.

    If you want multiple values of delta when there are no
    groups, create a group-id variable with all values equal.
    For example

        LET LAB = 1 FOR I = 1  1  N

Syntax 7:
    POINCARE PLOT <y>    <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    BIVARIATE NORMAL TOLERANCE REGION PLOT Y1 Y2
    BIVARIATE NORMAL TOLERANCE REGION PLOT Y1 Y2 LAB
    BIVARIATE NORMAL TOLERANCE REGION PLOT Y1 Y2 LAB DELTA
    BIVARIATE NORMAL TOLERANCE REGION PLOT Y1 Y2 LAB SUBSET LAB > 2
 
    BIVARIATE NORMAL CONFIDENCE REGION PLOT Y1 Y2
    BIVARIATE NORMAL CONFIDENCE REGION PLOT Y1 Y2 LAB
    BIVARIATE NORMAL CONFIDENCE REGION PLOT Y1 Y2 LAB DELTA
    BIVARIATE NORMAL CONFIDENCE REGION PLOT Y1 Y2 LAB SUBSET LAB > 2

    POINCARE PLOT Y

Note:
    You can use the CHARACTER and LINE commands to control
    the appearance of the plot.  If there are NGROUP groups and
    NDELTA values of delta in the data, settings 1 through NDELTA
    control the appearance of the NDELTA ellipses and settings
    NDELTA + 1 through NDELTA + NGROUP control the appearance of
    the raw data for each group.

    For the Poincare plot, the first setting controls the appearance of
    the ellipse, the second setting controls the appearance of the
    data points, the third setting controls the appearance of a line
    throught the major axis of the ellipse, and the fourth setting
    controls the appearance of a line through the minor axis of the
    ellipse.  If you do not want the axis lines drawn, simply set the
    third and fourth LINE and CHARACTER settings to BLANK.

Note:
    By default, the Poincare generates a lag 1 plot (i.e., Y(i) versus
    Y(i-1)).  If you want a different lag, then enter

        SET POINCARE PLOT LAG <value>

    If <value> is less than 1 a lag 1 plot will be generated.  If <value>
    is greater than N/4, this command will be ignored and a lag 1 plot
    will be generated.

Note:
    The Poincare plot saves the following parameters

       SD1    - the radius of the minor axis of the ellipse
       SD2    - the radius of the major axis of the ellipse
       SAREA  - the area of the ellipse (= PI*SD1*SD2)
       CCM    - the complex correlation measure

    The CCM has been suggested as an alternative way to characterize the
    Poincare plot.  It is defined by

       CCM = (1/(SAREA*(N-1))*SUM[i=1 to N-2][D]

    where

       D = (1/2)*determinant(A)

       A = | x1 y1 1 |
           | x2 y2 1 |
           | x3 y3 1 |

    The (x1,y1), (x2,y2), and (x3,y3) define the coordinates of three
    successive points in the Poincare plot.

    If any of the determinants have a condition number less than
    1.0E-10, the CCM statistic will not be computed.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    TOLERANCE LIMITS        = Generate normal or nonparameteric
                              tolerance limits.
    BASIS TOLERANCE LIMITS  = Generate normal, lognormal, and
                              Weibull tolerance limits.
    YOUDEN PLOT             = Generate a Youden plot.
    LAG  PLOT               = Generate a lag plot.
    PLOT                    = Generates a data or function plot.
    CHARACTERS              = Sets the type for plot characters.
    LINES                   = Sets the type for plot lines.
 
References:
    Hall and Sheldon (1979), "Improved Bivariate Normal
    Tolerance Regions with Some Applications", Journal of
    Quality Technology, Vol. 11, No. 1, pp. 13-19.

    Krishnamoorthy (2006), "Handbook of Statistical Distributions
    with Applications", Chapman & Hall/CRC, pp. 325-327.

    ISO 13528 (2005), "Statistical Methods for Use in
    Proficiency Testing by Interlaboratory Comparisons",
    ISO 13528:2005(E).

    Jackson (1956), "Quality Control Methods for Two Related
    Variables", Industrial Quality Control, 7, pp. 2-6.

    Tayel and AlSaba (2015), "Poincare Plot for Heart Rate Variability",
    International Journal of Medical, Health, Biomedical, Bioengineering
    and Pharmaceutical Engineering", Vol. 9, No. 9, pp. 708-711.

Applications:
     Interlaboratory Analysis
 
Implementation Date:
    2007/04
    2013/11: Support for BIVARIATE NORMAL CONFIDENCE REGION PLOT
    2013/11: Support for POINCARE PLOT
 
Program 1:
    ORIENTATION SQUARE
    DIMENSION 20 COLUMNS
    .
    SKIP 25
    READ STG.DAT LABID F LABAVE FAVE
    .
    TITLE OFFSET 2
    TITLE CASE ASIS
    LABEL CASE ASIS
    TITLE Youden with Bivariate Normal Tolerance (95%-90%)
    LET GAMMA = 0.95
    LET DELTA = 0.90
    X1LABEL Filter Average Value
    Y1LABEL Lab Value for Filter
    X2label Labs 1 to 9 with Bivariate Normal Contour
    X3LABEL SED/ITL/NIST March 2007
    .
    TIC OFFSET UNITS DATA
    XLIMITS 0 1200
    XTIC OFFSET -25 100
    YLIMITS 0 1500
    YTIC OFFSET -350 100
    .
    CHARACTERS BLANK 1 2 3 4 5 6 7 8 9
    LINES BLANK ALL
    LINES SOLID
    .
    .  Base tolerance curve on all labs, but only plot first 9
    .
    BIVARIATE NORMAL TOLERANCE REGION PLOT LABAVE FAVE LABID
 
Program 2:
    ORIENTATION SQUARE
    DIMENSION 20 COLUMNS
    .
    SKIP 25
    READ STG.DAT LABID F LABAVE FAVE
    .
    TITLE OFFSET 2
    TITLE CASE ASIS
    LABEL CASE ASIS
    TITLE Youden with Bivariate Normal Confidence (95%)
    LET DELTA = 0.95
    X1LABEL Filter Average Value
    Y1LABEL Lab Value for Filter
    X2label Labs 1 to 9 with Bivariate Normal Contour
    X3LABEL SED/ITL/NIST March 2007
    .
    TIC OFFSET UNITS DATA
    XLIMITS 0 1200
    XTIC OFFSET -25 100
    YLIMITS 0 1500
    YTIC OFFSET -350 100
    .
    CHARACTERS BLANK 1 2 3 4 5 6 7 8 9
    LINES BLANK ALL
    LINES SOLID
    .
    .  Base confidence curve on all labs, but only plot first 9
    .
    BIVARIATE NORMAL CONFIDENCE REGION PLOT LABAVE FAVE LABID
 
Program 3:
    ORIENTATION SQUARE
    DIMENSION 20 COLUMNS
    .
    READ NEGIZ4.DAT Y1 Y2 Y3 Y4
    .
    TITLE OFFSET 2
    TITLE CASE ASIS
    LABEL CASE ASIS
    TITLE Poincare Plot for NEGIZ4.DAT (Column 3)
    X1LABEL Y(n-1)
    Y1LABEL Y(n)
    .
    CHARACTERS BLANK CIRCLE
    CHARACTERS HW 0.5 0.375 ALL
    CHARACTER FILL OFF ON
    LINES SOLID BLANK DASH DASH
    LINE THICKNESS 0.3 ALL
    LINE COLOR BLUE ALL
    .
    POINCARE PLOT Y3
    .
    LET SD1 = ROUND(SD1,2)
    LET SD2 = ROUND(SD2,2)
    JUSTIFICATION LEFT
    MOVE 16 75
    TEXT SD1: ^SD1
    MOVE 16 72
    TEXT SD2: ^SD2
 
-----BIWEIGHT (LET)----------------------------------------------
 
BIWEIGHT
 
Name:
    BIWEIGHT (LET)
 
Type:
    Subcommand under LET
 
Purpose:
    Carry out a biweight transformation (also called a bisquare
    transformation) of residuals from a (linear or non-linear) fit.
 
Description:
    The biweight transformation has the advantage that it allows the
    analyst to carry out subsequent weighted linear or non-linear fits
    that are robust and resistive to outliers in the data.  The
    biweight transformation is defined as follows:
       1) m      = the median absolute residual from some previous fit
       2) cutoff = 6 * m
       3) T(res) = (1- (res/cutoff)**2 )**2     if abs(res) < cutoff
          T(res) = 0                            if abs(res) >= cutoff
    The transformed residuals are then usually used as weights in a
    subsequent fit.  This subsequent fit will be robust.  The following
    is a typical sequence using BIWEIGHT:
       FIT Y = A+B*EXP(-C*X)  To carry out an unweighted (that is,
                              equally-weighted) fit.
       LET W = BIWEIGHT RES   To use the residuals from the unweighted
                              fit to create robust/resistive weights.
       WEIGHTS W              To tell DATAPLOT that the next fit is a
                              weighted fit with the weights in W.
       FIT Y = A+B*EXP(-C*X)  To carry out a weighted fit using robust
                              biweighted weights.
 
Syntax:
    LET <v1> = BIWEIGHT <v2>   <SUBSET/EXCEPT/FOR qualification>
    where <v1> will be the output variable containing the
               biweight-transformed values;
          <v2> is the input variable of residuals from some
               previous fit;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional
               (and rarely used in this context).
 
Examples:
    LET W = BIWEIGHT RES
    LET W2 = BIWEIGHT RES
 
Default:
    None
 
Synonyms:
    BISQUARE for BIWEIGHT
 
Related Commands:
    FIT             = Carries out a least squares fit.
    RES             = A variable containing the residuals from a FIT.
    WEIGHTS         = Specifies the weights variable.
    TRIWEIGHT (LET) = Carry out a triweight transformation
 
Reference:
    "Graphical Methods for Data Analysis", Chambers, Cleveland,
    Kleiner, and Tukey.  Wadsworth, 1983 (page 122).
 
Applications:
    Robust Fitting
 
Implementation Date:
    88/7
 
Program:
    LET X = DATA 1 2 3 4 5 6 7 8 9 10
    LET Y = DATA 2 4 60 7 9 12 14 15 18 20
    FIT Y = A+B*X
    PLOT Y PRED VS X
    LET WT = BIWEIGHT RES
    WEIGHTS WT
    FIT Y = A+B*X
    PLOT Y PRED VS X
 
-----BIWEIGHT CONFIDENCE LIMITS--------------------------------------
 
BIWEIGHT CONFIDENCE LIMITS
 
Name:
    BIWEIGHT CONFIDENCE LIMITS
 
Type:
    Analysis Command
 
Purpose:
    Generates a biweight based confidence interval for the
    location of a variable.
 
Description:
    Mosteller and Tukey (see Reference section below) define
    two types of robustness:

      1) resistance means that changing a small part, even by a
         large amount, of the data does not cause a large change
         in the estimate

      2) robustness of efficiency means that the statistic has
         high efficiency in a variety of situations rather than
         in any one situation.  Efficiency means that the estimate
         is close to optimal estimate given that we distribution
         that the data comes from.  A useful measure of efficiency
         is:

              Efficiency = (lowest variance feasible)/
                           (actual variance)
   
    Many statistics have one of these properties.  However,
    it can be difficult to find statistics that are both
    resistant and have robustness of efficiency.

    Standard confidence intervals are base in the mean and
    variance.  These are the optimal estimators if the data
    are in fact from a Gaussian population.  However, they
    lack both resistance and robustness of efficiency.  The
    biweight confidence interval is based on estimates of
    of location and scale that are both resistant and have
    robustness of efficiency.  Therefore it should provide
    a reasonable confidence interval when the normality
    assumption cannot be validated.  Note that it is still
    a symmetric confidence interval.  However, symmetry is
    a much looser assumption than normality.

    The biweight confidence interval for the population biweight
    location is defined by:

       biweight location +/- T(v)*SQRT((biweight scale)/n)

    where the biweight location and biweight scale are location
    and scale estimators based on the biweight and v = 0.7*(n-1).
    The definitions for the biweight location and biweight
    scale estimators are given in:

        HELP BIWEIGHT LOCATION
        HELP BIWEIGHT SCALE
    
Syntax:
    BIWEIGHT CONFIDENCE LIMITS  <y>  <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable,
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    BIWEIGHT CONFIDENCE LIMITS Y1
    BIWEIGHT CONFIDENCE LIMITS Y1  SUBSET TAG > 2
 
Note:
    A table of confidence intervals is printed for alpha levels of
    50.0, 75.0, 90.0, 95.0, 99.0, 99.9, 99.99, and 99.999.  The sample
    biweight location estiamte and sample biweight scale estimate
    are also printed.  The t-value and t-value X SQRT(s(bi)**2)
    are printed in the table.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CONFIDENCE LIMITS =  Compute a Gaussian based confidence limit.
    T-TEST            = Perform a t-test.
    BIWEIGHT LOCATION = Compute a biweight location estimate.
    BIWEIGHT SCALE    = Compute a biweight scale estimate.
 
Reference:
    "Data Analysis and Regression: A Second Course in Statistics",
    Mosteller and Tukey, Addison-Wesley, 1977, pp. 203-209.
 
Applications:
    Robust Data Analysis
 
Implementation Date:
    2001/11
 
Program:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET Y2 = LOGISTIC RANDOM NUMBERS FOR I = 1 1 100
    LET Y3 = CAUCHY RANDOM NUMBERS FOR I = 1 1 100
    LET Y4 = DOUBLE EXPONENTIAL RANDOM NUMBERS FOR I = 1 1 100
    BIWEIGHT CONFIDENCE LIMITS Y1
    BIWEIGHT CONFIDENCE LIMITS Y2
    BIWEIGHT CONFIDENCE LIMITS Y3
    BIWEIGHT CONFIDENCE LIMITS Y4
 
-----BIWEIGHT MIDCORRELATION (LET)-------------------------------
 
BIWEIGHT MIDCORRELATION
 
Name:
    BIWEIGHT MIDCORRELATION (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the biweight midcorrelation between two variables.
 
Description:
    Mosteller and Tukey (see Reference section below) define
    two types of robustness:

      1) resistance means that changing a small part, even by a
         large amount, of the data does not cause a large change
         in the estimate

      2) robustness of efficiency means that the statistic has
         high efficiency in a variety of situations rather than
         in any one situation.  Efficiency means that the estimate
         is close to optimal estimate given that we know what
         distribution that the data comes from.  A useful measure
         of efficiency is:

              Efficiency = (lowest variance feasible)/
                           (actual variance)
   
    Many statistics have one of these properties.  However,
    it can be difficult to find statistics that are both
    resistant and have robustness of efficiency.

    The standard Pearson correlation coefficient is the optimal
    estimator for Gaussian data.  However, it is not resistant and
    it does not have robustness of efficiency.  The Spearman rank
    correlation is one example of a robust estimate of correlation.

    The biweight midcorrelation estimator is another alternative
    correlation estimate.  It is both resistant and robust
    of efficiency.

    The biweight midcorrelation can be defined in terms of
    the biweight midvariance and the biweight midcovariance:

       Corr(bxy) = S(bxy)/SQRT(S(bx)*S(by))

    where S(bxy) is the biweight midcovariance between X and Y
    and S(bx) and S(by) are the biweight midvariances of
    X and Y respectively.  Enter HELP BIWEIGHT MIDVARANCE and
    HELP BIWEIGHT MIDCOVARIANCE for the details on these
    statistics.

Syntax:
    LET <par> = BIWEIGHT MIDCORRELATION <y1> <y2>
                      <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed biweight
               midcorrelation is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BIWEIGHT MIDCORRELATION Y1 Y2
    LET A = BIWEIGHT MIDCORRELATION Y1 Y2 SUBSET TAG > 2
 

Note:
    Support for the biweight midcorrelation has been added to the
    following plots and commands:

       BIWEIGHT MIDCORRELATION PLOT
       CROSS TABULATE BIWEIGHT MIDCORRELATION PLOT
       BOOTSTRAP BIWEIGHT MIDCORRELATION PLOT
       JACKNIFE BIWEIGHT MIDCORRELATION PLOT
       BIWEIGHT MIDCORRELATION INTERACTION STATISTIC PLOT

Note:
    The CORRELATION MATRIX command generates pairwise correlation
    estimates of the columns in a matrix.  By default, this command
    generates the standard correlation estimate.  The command

       SET CORRELATION TYPE  <type>

    can be used to specify an alternate correlation measure to
    compute in the CORRELATION MATRIX command.  The following
    types are supported:

        DEFAULT    - use the standard estimate
        BIWEIGHT   - use the biweight midcorrelation estimate
        WINSOR     - use the Winsorized correlation estimate
        RANK       - use the rank correlation estimate

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BIWEIGHT MIDCOVARIANCE     = Compute a biweight midcovariance
                                 estimate between two variables.
    BIWEIGHT MIDVARIANCE       = Compute a biweight midvariance
                                 estimate of a variable.
    BIWEIGHT SCALE             = Compute a biweight scale estimate
                                 of a variable.
    BIWEIGHT LOCATION          = Compute a biweight location estimate
                                 of a variable.
    BIWEIGHT CONFIDENCE LIMITS = Compute a biweight based confidence
                                 interval.
    WINSORIZED CORRELATION     = Compute the Winsorized correlation
                                 of two variables.
    CORRELATION                = Compute the correlation between two
                                 variables.
    RANK CORRELATION           = Compute the rank correlation between
                                 two variables.
    STATISTIC PLOT             = Generate a statistic versus group
                                 plot for a given statistic.
    CROSS TABULATE PLOT        = Generate a statistic versus group
                                 plot for a given statistic and two
                                 group variables.
    BOOTSTRAP PLOT             = Generate a bootstrap plot for a
                                 given statistic.
    INTERACTION STATISTIC PLOT = Generate an interaction plot for a
                                 given statistic.
 
Reference:
    "Introduction to Robust Estimation and Hypothesis Testing",
    Rand Wilcox, Academic Press, 1997.

    "Data Analysis and Regression: A Second Course in Statistics",
    Mosteller and Tukey, Addison-Wesley, 1977, pp. 203-209.

Applications:
    Robust Data Analysis
 
Implementation Date:
    2002/7
 
Program 1:
    SKIP 25
    READ MATRIX IRIS.DAT Y1 Y2 Y3 Y4 X
    LET M = CREATE MATRIX Y1 Y2 Y3 Y4
    SET CORRELATION TYPE BIWEIGHT
    LET B = CORRELATION MATRIX Y1 Y2 Y3 Y4
 
Program 2:
    SKIP 25
    READ IRIS.DAT Y1 Y2 Y3 Y4 X
    .
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT 2 1
    BOOTSTRAP SAMPLES 500
    BOOTSTRAP BIWEIGHT MIDCORRELATION PLOT Y1 Y2
    X1LABEL B025 = ^B025, B975=^B975
    HISTOGRAM YPLOT
    END OF MULTIPLOT
    MOVE 50 96
    JUSTIFICATION CENTER
    TEXT BIWEIGHT MIDCORRELATION BOOTSTRAP: IRIS DATA
 
-----BIWEIGHT MIDCOVARIANCE (LET)-------------------------------
 
BIWEIGHT MIDCOVARIANCE
 
Name:
    BIWEIGHT MIDCOVARIANCE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the biweight midcovariance for a variable.
 
Description:
    Mosteller and Tukey (see Reference section below) define
    two types of robustness:

      1) resistance means that changing a small part, even by a
         large amount, of the data does not cause a large change
         in the estimate

      2) robustness of efficiency means that the statistic has
         high efficiency in a variety of situations rather than
         in any one situation.  Efficiency means that the estimate
         is close to optimal estimate given that we know what
         distribution that the data comes from.  A useful measure
         of efficiency is:

              Efficiency = (lowest variance feasible)/
                           (actual variance)
   
    Many statistics have one of these properties.  However,
    it can be difficult to find statistics that are both
    resistant and have robustness of efficiency.

    The standard covariance estimate is the optimal estimator for
    Gaussian data.  However, it is not resistant and it does not
    have robustness of efficiency.  The rank covariance statistic
    is one example of a robust estimate of correlation.

    The biweight midcovariance estimator is both resistant and robust
    of efficiency.  Mosteller and Tukey recommend using the MAD or
    interquartile range for exploratory work where moderate efficiency
    in a variety of situations is adequate.   The biweight
    midcovariance estimator can be considered for situations where high
    performance is needed.

    The biweight midcovariance estimate is defined as:

       s(bxy)**2 = {n*SUM[a(i)*(x(i)-x')*(1 - u(i)**2)**2*
                      SUM[b(i)*(y(i)-y')*(1 - v(i)**2)**2}/
                   {[SUM[a(i)*(1-u(i)**2)*(1-5*u(i)**2)]*
                    [SUM[b(i)*(1-v(i)**2)*(1-5*v(i)**2)]}

    where 

      x' = median x
      y' = median y
      u(i) = (X(i) - x')/[9*MAD]
      v(i) = (Y(i) - y')/[9*MAD]
      a(i) = 1 if -1 <= u(i) <= 1
      b(i) = 1 if -1 <= v(i) <= 1
      MAD = median absolute deviation

Syntax:
    LET <par> = BIWEIGHT MIDCOVARIANCE <y1> <y2>
                      <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed biweight
               midcovariance is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BIWEIGHT MIDCOVARIANCE Y1
    LET A = BIWEIGHT MIDCOVARIANCE Y1 SUBSET TAG > 2
 
Note:
    Support for the biweight midcovariance has been added to the
    following plots and commands:

       BIWEIGHT MIDCOVARIANCE PLOT
       CROSS TABULATE BIWEIGHT MIDCOVARIANCE PLOT
       BOOTSTRAP BIWEIGHT MIDCOVARIANCE PLOT
       JACKNIFE BIWEIGHT MIDCOVARIANCE PLOT
       BIWEIGHT MIDCOVARIANCE INTERACTION STATISTIC PLOT

Note:
    The COVARIANCE MATRIX command generates pairwise covariance
    estimates of the columns in a matrix.  By default, this command
    generates the standard covariance estimate.  The command

       SET COVARIANCE TYPE  <type>

    can be used to specify an alternate covariance measure to
    compute in the COVARIANCE MATRIX command.  The following
    types are supported:

        DEFAULT    - use the standard estimate
        BIWEIGHT   - use the biweight midcovariance estimate
        WINSOR     - use the Winsorized covariance estimate
        RANK       - use the rank covariance estimate

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BIWEIGHT MIDCORRELATION    = Compute a biweight midcocorelation
                                 estimate between two variable.
    BIWEIGHT MIDVARIANCEION    = Compute a biweight midvariance
                                 estimate of a variable.
    BIWEIGHT SCALE             = Compute a biweight scale estimate
                                 of a variable.
    BIWEIGHT LOCATION          = Compute a biweight location estimate
                                 of a variable.
    BIWEIGHT CONFIDENCE LIMITS = Compute a biweight based confidence
                                 interval.
    COVARIANCE                 = Compute the covariance between two
                                 variables.
    WINSORIZED COVARIANCE      = Compute the Winsorized covariance
                                 between two variables.
    RANK COVARIANCE            = Compute the rank covariance between
                                 two variables.
    STATISTIC PLOT             = Generate a statistic versus group
                                 plot for a given statistic.
    CROSS TABULATE PLOT        = Generate a statistic versus group
                                 plot for a given statistic and two
                                 group variables.
    BOOTSTRAP PLOT             = Generate a bootstrap plot for a
                                 given statistic.
    INTERACTION STATISTIC PLOT = Generate an interaction plot for a
                                 given statistic.
 
Reference:
    "Introduction to Robust Estimation and Hypothesis Testing",
    Rand Wilcox, Academic Press, 1997.

    "Data Analysis and Regression: A Second Course in Statistics",
    Mosteller and Tukey, Addison-Wesley, 1977, pp. 203-209.

Applications:
    Robust Data Analysis
 
Implementation Date:
    2002/7
 
Program 1:
    SKIP 25
    READ MATRIX IRIS.DAT Y1 Y2 Y3 Y4 X
    LET M = CREATE MATRIX Y1 Y2 Y3 Y4
    SET COVARIANCE TYPE BIWEIGHT
    LET B = COVARIANCE MATRIX Y1 Y2 Y3 Y4
 
Program 2:
    SKIP 25
    READ IRIS.DAT Y1 Y2 Y3 Y4 X
    .
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT 2 1
    BOOTSTRAP SAMPLES 500
    BOOTSTRAP BIWEIGHT MIDCOVARIANCE PLOT Y1 Y2
    X1LABEL B025 = ^B025, B975=^B975
    HISTOGRAM YPLOT
    END OF MULTIPLOT
    MOVE 50 96
    JUSTIFICATION CENTER
    TEXT BIWEIGHT MIDCOVARIANCE BOOTSTRAP: IRIS DATA
 
-----BIWEIGHT LOCATION (LET)-------------------------------
 
BIWEIGHT LOCATION
 
Name:
    BIWEIGHT LOCATION (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute a biweight based location estimate for a variable.
 
Description:
    Mosteller and Tukey (see Reference section below) define
    two types of robustness:

      1) resistance means that changing a small part, even by a
         large amount, of the data does not cause a large change
         in the estimate

      2) robustness of efficiency means that the statistic has
         high efficiency in a variety of situations rather than
         in any one situation.  Efficiency means that the estimate
         is close to optimal estimate given that we distribution
         that the data comes from.  A useful measure of efficiency
         is:

              Efficiency = (lowest variance feasible)/
                           (actual variance)
   
    Many statistics have one of these properties.  However,
    it can be difficult to find statistics that are both
    resistant and have robustness of efficiency.

    For location estimaors, the mean is the optimal estimator
    for Gaussian data.  However, it is not resistant and it
    does not have robustness of efficiency.  The median is
    a resistant estimate, but it has only moderate robustness
    of efficiency.

    The biweight location estimator is both resistant and
    robust of efficiency.  Mosteller and Tukey recommend using
    the median for exploratory work where moderate efficiency
    in a variety of situations is adequate and the biweight
    in situations when high performance is needed.

    The biweight location estimate is defined as:

       y* = SUM[i=1 to n][w(i)*y(i)]/SUM[i=1 to n][w(i)]

    where 

      w(i) = (1 - ((y(i)-y*)/(c*S))**2)**2  for (Y(i)-y*)/(c*S)**2 < 1
           = 0                              otherwise

      S = median{|y(i) - y*|}

      c = 6  (using 6 means that residuals up to approximately
             4*sigma are included)

   Note that this is an iterative estimate since y* depends on
   w(i) and w(i) depends on y*.

   Dataplot will compute up to 10 iterations (computation is
   terminated if the biweight location estimate does not
   change in value by more than 0.000001).

Syntax:
    LET <par> = BIWEIGHT LOCATION <y>
                      <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the computed biweight location
               is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BIWEIGHT LOCATION Y1
    LET A = BIWEIGHT LOCATION Y1 SUBSET TAG > 2
 
Note:
    Support for the biweight location has been added to the 
    following plots and commands:

       BIWEIGHT LOCATION PLOT
       BOOTSTRAP BIWEIGHT LOCATION PLOT
       JACKNIFE BIWEIGHT LOCATION PLOT
       CROSS TABULATE BIWEIGHT LOCATION PLOT
       DEX BIWEIGHT LOCATION PLOT
       BIWEIGHT LOCATION INFLUENCE CURVE

       LET Y2 = CROSS TABULATE BIWEIGHT LOCATION Y X1 X2

       SET LOCATION STATISTIC BIWEIGHT LOCATION
       LET Y2 = STANDARDIZE Y X1 X2
    
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BIWEIGHT SCALE             = Compute a biweight scale estimate of
                                 a variable.
    BIWEIGHT CONFIDENCE LIMITS = Compute a biweight based confidence
                                 interval.
    MEAN                       = Compute the mean of a variable.
    MEDIAN                     = Compute the median of a variable.
    MIDMEAN                    = Compute the midmean of a variable.
    TRIMMED MEAN               = Compute the trimmed mean of a
                                 variable.
    WINSORIZED MEAN            = Compute the Winsorized mean of a
                                 variable.
    AVERAGE ABSOLUTE DEVIATION = Compute the average absolute
                                 deviation of a variable.
    MEDIAN ABSOLUTE DEVIATION  = Compute the median absolute
                                 deviation of a variable.
    STANDARD DEVIATION         = Compute the standard deviation of a
                                 variable.
    VARIANCE                   = Compute the variance of a variable.
    RANGE                      = Compute the range of a variable.
 
Reference:
    "Data Analysis and Regression: A Second Course in Statistics",
    Mosteller and Tukey, Addison-Wesley, 1977, pp. 203-209.

Applications:
    Robust Data Analysis
 
Implementation Date:
    2001/11
 
Program 1:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET Y2 = LOGISTIC RANDOM NUMBERS FOR I = 1 1 100
    LET Y3 = CAUCHY RANDOM NUMBERS FOR I = 1 1 100
    LET Y4 = DOUBLE EXPONENTIAL RANDOM NUMBERS FOR I = 1 1 100
    LET A1 = BIWEIGHT LOCATION Y1
    LET A2 = BIWEIGHT LOCATION Y2
    LET A3 = BIWEIGHT LOCATION Y3
    LET A4 = BIWEIGHT LOCATION Y4
 
Program 2:
    SKIP 25
    READ GEAR.DAT DIAMETER BATCH
    TITLE AUTOMATIC
    XLIMITS 1 10
    MAJOR XTIC MARK NUMBER 10
    MINOR XTIC MARK NUMBER 0
    XTIC OFFSET 1 1
    X1LABEL BATCH
    Y1LABEL BIWEIGHT LOCATION OF DIAMETER
    BIWEIGHT LOCATION PLOT DIAMETER BATCH
 
Program 3:
    LET Y = CAUCHY RANDOM NUNBERS FOR I = 1 1 200
    TITLE AUTOMATIC
    BOOTSTRAP BIWEIGHT LOCATION PLOT Y
    X1LABEL B025 = ^B025, B975=B975
    TITLE BOOTSTRAP OF BIWEIGHT LOCATION: CAUCHY RANDOM NUMBERS
    HISTOGRAM YPLOT
 
-----BIWEIGHT MIDVARIANCE (LET)-------------------------------
 
BIWEIGHT MIDVARIANCE
 
Name:
    BIWEIGHT MIDVARIANCE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the biweight midvariance for a variable.
 
Description:
    Mosteller and Tukey (see Reference section below) define
    two types of robustness:

      1) resistance means that changing a small part, even by a
         large amount, of the data does not cause a large change
         in the estimate

      2) robustness of efficiency means that the statistic has
         high efficiency in a variety of situations rather than
         in any one situation.  Efficiency means that the estimate
         is close to optimal estimate given that we know what
         distribution that the data comes from.  A useful measure
         of efficiency is:

              Efficiency = (lowest variance feasible)/
                           (actual variance)
   
    Many statistics have one of these properties.  However,
    it can be difficult to find statistics that are both
    resistant and have robustness of efficiency.

    For scale estimaors, the standard deviation (or variance) is
    the optimal estimator for Gaussian data.  However, it is not
    resistant and it does not have robustness of efficiency.  The
    median absolute deviation (MAD) is a resistant estimate, but
    it has only modest robustness of efficiency.

    The biweight midvariance estimator is both resistant and robust
    of efficiency.  Mosteller and Tukey recommend using the MAD or
    interquartile range for exploratory work where moderate efficiency
    in a variety of situations is adequate.   The biweight
    midvariance estimator can be considered for situations where high
    performance is needed.

    The biweight midvariance estimate is defined as:

       s(bi)**2 = {SUM'[(y-y')**2]*(1-u**2)**4}/
                   {[SUM'[1-u**2)*(1-5*u**2)]**2}

    where 

      y' = median y
      u(i) = (Y(i) - y')/[9*MAD]
      MAD = median absolute deviation
      SUM' means the summation is for u**2 <= 1

Syntax:
    LET <par> = BIWEIGHT MIDVARIANCE <y>
                      <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the computed biweight midvariance
               is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BIWEIGHT MIDVARIANCE Y1
    LET A = BIWEIGHT MIDVARIANCE Y1 SUBSET TAG > 2
 
Note:
    A refinement of the biweight midvariance, called the biweight
    scale estimate, has slightly better performance than the
    biweight midvariance.  Enter HELP BIWEIGHT SCALE for details.

Note:
    Support for the biweight midvariance has been added to the
    following plots and commands:

       BIWEIGHT MIDVARIANCE PLOT
       BOOTSTRAP BIWEIGHT MIDVARIANCE PLOT
       JACKNIFE BIWEIGHT MIDVARIANCE PLOT
       CROSS TABULATE BIWEIGHT MIDVARIANCE PLOT
       DEX BIWEIGHT MIDVARIANCE PLOT
       BIWEIGHT MIDVARIANCE INFLUENCE CURVE
       BIWEIGHT MIDVARIANCE INTERACTION STATISTIC PLOT

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BIWEIGHT MIDCOVARIANCE     = Compute a biweight midcovariance
                                 estimate of two variable.
    BIWEIGHT SCALE             = Compute a biweight scale estimate
                                 of a variable.
    BIWEIGHT LOCATION          = Compute a biweight location estimate
                                 of a variable.
    BIWEIGHT CONFIDENCE LIMITS = Compute a biweight based confidence
                                 interval.
    WINSORIZED VARIANCE        = Compute the Winsorized variance of a
                                 variable.
    MEDIAN ABSOLUTE DEVIATION  = Compute the median absolute
                                 deviation of a variable.
    VARIANCE                   = Compute the variance of a variable.
    STATISTIC PLOT             = Generate a statistic versus group
                                 plot for a given statistic.
    CROSS TABULATE PLOT        = Generate a statistic versus group
                                 plot for a given statistic and two
                                 group variables.
    BOOTSTRAP PLOT             = Generate a bootstrap plot for a
                                 given statistic.
    DEX PLOT                   = Generate various types of design
                                 of experiment plots.
    INFLUENCE CURVE            = Generate an influence curve for a
                                 given statistic.
    INTERACTION STATISTIC PLOT = Generate an interaction plot for a
                                 given statistic.
 
Reference:
    "Introduction to Robust Estimation and Hypothesis Testing",
    Rand Wilcox, Academic Press, 1997.

    "Data Analysis and Regression: A Second Course in Statistics",
    Mosteller and Tukey, Addison-Wesley, 1977, pp. 203-209.

Applications:
    Robust Data Analysis
 
Implementation Date:
    2002/7
 
Program 1:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET Y2 = LOGISTIC RANDOM NUMBERS FOR I = 1 1 100
    LET Y3 = CAUCHY RANDOM NUMBERS FOR I = 1 1 100
    LET Y4 = DOUBLE EXPONENTIAL RANDOM NUMBERS FOR I = 1 1 100
    LET A1 = BIWEIGHT MIDVARIANCE Y1
    LET A2 = BIWEIGHT MIDVARIANCE Y2
    LET A3 = BIWEIGHT MIDVARIANCE Y3
    LET A4 = BIWEIGHT MIDVARIANCE Y4
 
Program 2:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100
    MULTIPLOT SCALE FACTOR 2
    .
    LET Y1 = NORMAL RANDOM NUNBERS FOR I = 1 1 200
    LET Y2 = CAUCHY RANDOM NUNBERS FOR I = 1 1 200
    .
    BOOTSTRAP SAMPLES 500
    TITLE BIWEIGHT MIDVARIANCE BOOTSTRAP: CAUCHY
    BOOTSTRAP BIWEIGHT MIDVARIANCE PLOT Y1
    X1LABEL B025 = ^B025, B975=^B975
    TITLE
    HISTOGRAM YPLOT
    .
    TITLE BIWEIGHT MIDVARIANCE BOOTSTRAP: NORMAL
    BOOTSTRAP BIWEIGHT MIDVARIANCE PLOT Y1
    X1LABEL B025 = ^B025, B975=^B975
    TITLE
    HISTOGRAM YPLOT
    .
    END OF MULTIPLOT
 
-----BIWEIGHT SCALE (LET)-------------------------------
 
BIWEIGHT SCALE
 
Name:
    BIWEIGHT SCALE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute a biweight based scale estimate for a variable.
 
Description:
    Mosteller and Tukey (see Reference section below) define
    two types of robustness:

      1) resistance means that changing a small part, even by a
         large amount, of the data does not cause a large change
         in the estimate

      2) robustness of efficiency means that the statistic has
         high efficiency in a variety of situations rather than
         in any one situation.  Efficiency means that the estimate
         is close to optimal estimate given that we distribution
         that the data comes from.  A useful measure of efficiency
         is:

              Efficiency = (lowest variance feasible)/
                           (actual variance)
   
    Many statistics have one of these properties.  However,
    it can be difficult to find statistics that are both
    resistant and have robustness of efficiency.

    For scale estimaors, the standard deviation (or variance) is
    the optimal estimator for Gaussian data.  However, it is not
    resistant and it does not have robustness of efficiency.  The
    median absolute deviation (MAD) is a resistant estimate, but
    it has only modest robustness of efficiency.

    The biweight scale estimator is both resistant and robust of
    efficiency.  Mosteller and Tukey recommend using the MAD or
    interquartile range for exploratory work where moderate efficiency
    in a variety of situations is adequate.   The biweight
    scale estimator can be considered for situations where high
    performance is needed.

    The biweight scale estimate is defined as:

       ns(bi)**2 = {n*SUM'[(y-y')**2]*(1-u**2)**4}/
                   {[SUM'[1-u**2)*(1-5*u**2)]*
                   [-1 + SUM'[1-u**2)*(1-5*u**2)]}

    where 

      y' = median y
      u(i) = (Y(i) - y')/[9*MAD]

Syntax:
    LET <par> = BIWEIGHT SCALE <y>
                      <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the computed biweight location
               is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BIWEIGHT SCALE Y1
    LET A = BIWEIGHT SCALE Y1 SUBSET TAG > 2
 
Note:
    Support for the biweight scale has been added to the 
    following plots and commands:

       BIWEIGHT SCALE PLOT
       BOOTSTRAP BIWEIGHT SCALE PLOT
       JACKNIFE BIWEIGHT SCALE PLOT
       CROSS TABULATE BIWEIGHT SCALE PLOT
       DEX BIWEIGHT SCALE PLOT

       LET Y2 = CROSS TABULATE BIWEIGHT SCALE Y X1 X2

       SET SCALE STATISTIC BIWEIGHT SCALE
       LET Y2 = STANDARDIZE Y X1 X2
    
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BIWEIGHT LOCATION          = Compute a biweight location estimate
                                 of a variable.
    BIWEIGHT CONFIDENCE LIMITS = Compute a biweight based confidence
                                 interval.
    MEAN                       = Compute the mean of a variable.
    MEDIAN                     = Compute the median of a variable.
    MIDMEAN                    = Compute the midmean of a variable.
    TRIMMED MEAN               = Compute the trimmed mean of a
                                 variable.
    WINSORIZED MEAN            = Compute the Winsorized mean of a
                                 variable.
    AVERAGE ABSOLUTE DEVIATION = Compute the average absolute
                                 deviation of a variable.
    MEDIAN ABSOLUTE DEVIATION  = Compute the median absolute
                                 deviation of a variable.
    STANDARD DEVIATION         = Compute the standard deviation of a
                                 variable.
    VARIANCE                   = Compute the variance of a variable.
    RANGE                      = Compute the range of a variable.
 
Reference:
    "Data Analysis and Regression: A Second Course in Statistics",
    Mosteller and Tukey, Addison-Wesley, 1977, pp. 203-209.

Applications:
    Robust Data Analysis
 
Implementation Date:
    2001/11
 
Program 1:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET Y2 = LOGISTIC RANDOM NUMBERS FOR I = 1 1 100
    LET Y3 = CAUCHY RANDOM NUMBERS FOR I = 1 1 100
    LET Y4 = DOUBLE EXPONENTIAL RANDOM NUMBERS FOR I = 1 1 100
    LET A1 = BIWEIGHT SCALE Y1
    LET A2 = BIWEIGHT SCALE Y2
    LET A3 = BIWEIGHT SCALE Y3
    LET A4 = BIWEIGHT SCALE Y4
 
Program 2:
    SKIP 25
    READ GEAR.DAT DIAMETER BATCH
    TITLE AUTOMATIC
    XLIMITS 1 10
    MAJOR XTIC MARK NUMBER 10
    MINOR XTIC MARK NUMBER 0
    XTIC OFFSET 1 1
    X1LABEL BATCH
    Y1LABEL BIWEIGHT SCALE OF DIAMETER
    BIWEIGHT SCALE PLOT DIAMETER BATCH
 
Program 3:
    LET Y = CAUCHY RANDOM NUNBERS FOR I = 1 1 200
    TITLE AUTOMATIC
    BOOTSTRAP BIWEIGHT SCALE PLOT Y
    X1LABEL B025 = ^B025, B975=B975
    TITLE BOOTSTRAP OF BIWEIGHT SCALE: CAUCHY RANDOM NUMBERS
    HISTOGRAM YPLOT
 
-----BLAND ALTMAN PLOT--------------------------------------
 
BLAND ALTMAN PLOT
 
Name:
    BLAND ALTMAN PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a Bland Altman plot for a paired set of measurements.
 
Description:
    Given a set of paired measurements, X(i) and Y(i), for i = 1 to
    n, the Bland Altman plots the following

        Vertical axis: Y(i) - X(i)
        Horizontal axis: (Y(i) + X(i))/2

    That is, it plots the difference of the variables against their
    means.  Often Y and X will represent two different measurement
    methods.

    The Bland Altman plot is similar to the Tukey mean difference plot,
    but there are a few differences.

       1. The Bland Altman plots are based on the raw data while the
          Tukey mean difference is based on plotting quantiles of the
          data.

       2. The Bland Altman plot assumes the data are paired while the
          Tukey mean difference plot can be applied to either paired or
          unpaired data.  Since the Tukey mean difference plots quantiles
          of the data sets, it does not require that the response
          variables to have the same length.

       3. The Tukey mean difference plot is primarily focused on the
          question: do these two response variables have the same
          underlying distribution?  The Bland Altman is primarily
          focused on the differences between the pairs (e.g., is there
          a systematic bias, is one method better than another, and so
          on).

    Several reference lines are added to the Bland Altman plot (these
    can be omitted from plot with appropriate settings for the LINE and
    CHARACTER commands).  Specifically, the following curves are
    generated

        1  - Y(i) - X(i) versus (Y(i) + X(i))/2.
        2  - a reference line at Y = 0 (this line denotes where the two
             samples are equal.
        3  - the mean of the Y(i) - X(i) points.  This denotes the bias
             between the two samples.
        4  - ybar - tppf(0.975,n-1)*s/SQRT(n) where ybar and s denote the
             mean and standard deviations of the differences
             (Y(i) - X(i)), repsectively, n denotes the sampel size, and
             tppf is the percent point function of the t distribution.
             This is the lower confidence limit of the mean of the
             differences for normally distributed data.
        5  - ybar + tppf(0.975,n-1)*s/SQRT(n).  This is the upper
             confidence limit of the mean of the differences for normally
             distributed data.
        6 - ybar + 2*s - this is the upper limit of agreement (if the
            differences are normally distributed, approximately 95% of
            the differences should lie within +/- two standard deviations
            of the mean of the differences.
        7 - (ybar + 2*s) - tppf(0.975,n-1)*s*SQRT(3/n) - this is an
            approximate 95% lower confidence limit for the upper limit of
            agreement.
        8 - (ybar + 2*s) + tppf(0.975,n-1)*s*SQRT(3/n) - this is an
            approximate 95% upper confidence limit for the upper limit of
            agreement.
        9 - ybar - 2*s.  This the lower limit of agreement.
       10 - (ybar - 2*s) - tppf(0.975,n-1)*s*SQRT(3/n) - this is an
            approximate 95% lower confidence limit for the lower limit of
            agreement.
       11 - (ybar - 2*s) + tppf(0.975,n-1)*s*SQRT(3/n) - this is an
            approximate 95% upper confidence limit for the lower limit of
            agreement.

    The reference line for the mean of the differences gives an indication
    of the bias between the two methods.  If the bias is relatively
    consistent across the horizontal axis, the methods may be calibrated
    by simply subtracting (or adding) this value.  If there is a trend
    as the mean values increase, then a linear, quadratic  or some other
    more involved calibration may be required.

    The limits of agreement can be used to asses whether the differences
    between the two methods are practically significant.  If the
    differences are approximately normally distributed, then approximately
    95% of the differences should be within these limits.  If the limits
    of agreement are deemed clinically insignficant, then the two
    measurement methods may be considered equivalent for practical
    purposes. However, particularly for small samples, these limits of
    agreement may not be reliable.  So the confidence limits for these
    can help give an indication of the uncertainty in these limits.  These
    confidence limits are only approximate, but they should be adequate
    for most purposes.

    The LINE and CHARACTER commands can be used to control the appearance
    of the plot.  This is demonstrated in the Program examples below.
    Setting particular LINE or CHARACTER settings to BLANK can be used to
    omit some of the reference lines.  Typically, the reference lines
    for the mean difference and the lower and upper limits of agreement
    will be included.  However, you have control over all of them.

Syntax 1:
    BLAND ALTMAN PLOT <y1> <y2> 
                      <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax assumes that the response variables contain the summary
    location statistic (typically the mean) for each group and that
    the groups are properly paired between the two response variables.

Syntax 2:
    HIGHLIGHT BLAND ALTMAN PLOT <y1> <y2> <tag>
                                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <tag> is a group-id variable that defines the highlighting;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax assumes that the response variables contain the summary
    location statistic (typically the mean) for each group and that
    the groups are properly paired between the two response variables.
    Both response variables and the highlight variable must have the same
    number of rows.
 
    This syntax can be used to plot different plot points with
    different attributes.  For example, it can be used to highlight
    groups in the data or to highlight points that indicate where
    the two methods are clinically different.  It can also be used to
    label the plot points with the laboratory id.

    You need to account for the number of groups in the <tag> variable
    when setting the LINE attributes.  For example, if you have three
    groups, then the zero reference line is curve 4 rather than curve 2
    (and all the other curves will be adjusted accordingly).

Syntax 3:
    BLAND ALTMAN PLOT <y1> <x1> <y2> <x2>
                      <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <x1> is the group-id variable corresponding to the first
               response variable;
          <y2> is the second response variable;
          <x2> is the group-id variable corresponding to the second
               response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for the case where you have raw data.  The
    <y1> and <x1> variables should have the same number of elements
    and the <y2> and <x2> variables should have the same length.
    However, <y1> and <y2> are not required to have the same length.

    Note that group-id variables should have the same group-id's.  They
    do not need to be in the same order, but the distinct elements of
    <x1> and <x2> should be the same.

    Highlighting (Syntax 2) is not supported for raw data.

Examples:
    BLAND ALTMAN PLOT Y1 Y2
    BLAND ALTMAN PLOT Y1 Y2 SUBSET TAG > 2
    HIGHLIGHT BLAND ALTMAN PLOT Y1 Y2 TAG
 
Note:
    When the BLAND ALTMAN plot is generated, the following parameters
    are saved

       DIFFMEAN  - the mean of the differences (Y(i) - X(i))
       DIFFSD    - the standard deviation of the differences
       DIFFMLCL  - the lower 95% confidence limit for the mean of thes
                   differences
       DIFFMUCL  - the upper 95% confidence limit for the mean of the
                   differences
       LOWLIMIT  - the lower limit of agreement
       LOWLMLCL  - the lower 95% confidence limit for the lower limit of
                   agreement
       LOWLMUCL  - the upper 95% confidence limit for the lower limit of
                   agreement
       UPPLIMIT  - the upper limit of agreement
       UPPLMLCL  - the lower 95% confidence limit for the upper limit of
                   agreement
       UPPLMUCL  - the upper 95% confidence limit for the upper limit of
                   agreement

    These parameters can be used to label certain features of the plot.

Note:
    It is sometimes preferred that percentage differences be plotted.
    That is, the vertical axis will plot

         100*(Y(i) - X(i))/[(Y(i) + X(i))/2)]

    To plot percentage differences, enter

        SET BLAND ALTMAN PLOT PERCENTAGES

    To reset the default, enter

        SET BLAND ALTMAN PLOT RAW

Note:
    The following are written to the file dpst1f.dat using a 2E15.7
    format

        Column 1: Y(i) - X(i)
        Column 2: (Y(i) + X(i))/2

    If percentage differences were requested, these will be written to
    column one rather than the raw differences.

    This can be useful for the following purposes.

       1. The various reference lines generated for the plot are based
          on the assumption that the differences are approximately
          normally distributed.  You may want to generate a normal
          probability plot or perform some normal goodness of fit test
          for these differences.

       2. If the differences seem to exhibit some trend as the average
          increases, then you may want to perform a fit to model this
          trend.  This fit can be overlaid on the plot or used for
          calibration purposes.

    For example, you can do something like the following

        SKIP 0
        READ dpst1f.dat YDIFF YAVE
        .
        NORMAL PROBABILITY PLOT YAVE
        NORMAL ANDERSON DARLING GOODNESS OF FIT YAVE
        .
        FIT YDIFF YAVE

Note:
    For the raw data case, means will be computed for each distinct
    group.  To request that medians be computed rather than means,
    enter

        SET BLAND ALTMAN PLOT STATISTIC MEDIANS

    To reset the default of means, enter

        SET BLAND ALTMAN PLOT STATISTIC MEANS

Note:
    The confidence intervals for the mean difference and for the lower
    and upper limits of agreement are based on the assumption that the
    differences are normally distributed.  If this normality assumption
    is not satisfied, then you can request that they be generated using
    a bootstrap method.  To request the bootstrap based confidence
    intervals, enter

        SET BLAND ALTMAN PLOT CONFIDENCE INTERVALS BOOTSTRAP

    To reset the default intervals, enter

        SET BLAND ALTMAN PLOT CONFIDENCE INTERVALS ANALYTIC

    Note that it is the differences between the two sets of data that
    are bootstrapped, not the original response variables.  It is
    recommended that you have at least 20 differences before using the
    bootstrap based confidence intervals.

    The mean of the difference of the means, and the limit of agreement
    lines (YBAR +/- 2*s with YBAR and s denoting the mean and standard
    deviation of the original differences) are computed as before.
    These 3 values are then computed for each bootstrap sample and the
    2.5 and 97.5 percentiles of these bootstrap samples are used for the
    confidence limits.

Default:
    None
 
Synonyms:
    BLAND ALTMAN HIGHLIGHT PLOT is a synonym for
    HIGHLIGHT BLAND ALTMAN PLOT
 
Related Commands:
    CHARACTERS                 = Sets the type for plot characters.
    LINES                      = Sets the type for plot lines.
    TUKEY MEAN DIFFERENCE PLOT = Generates a q-q plot.
    DIFF OF MEANS CONF LIMIT   = Generates a difference of means
                                 confidence limit.
    QUANTILE-QUANTILE PLOT     = Generates a q-q plot.
    BOX PLOT                   = Generates a box plot.
    BIHISTOGRAM                = Generates a bihistogram.
    PLOT                       = Generates a data or function plot.
    PROBABILITY PLOT           = Generates a probability plot.
    T-TEST                     = Carries out a 2-sample t test.
    F-TEST                     = Carries out a 2-sample F test.
 
References:
    Giavarina (2015), "Understanding Bland Altman Analysis", Biochemia
    Medica, Vol. 25, No. 2, pp. 141-151.

    Bland and Altman (1983), "Measurement in Medicine: The Analysis of
    Method Comparison Studies", Statistician, Vol. 32, pp. 307-317.

Applications:
    Exploratory Data Analysis
 
Implementation Date:
    2017/07
 
Program 1:
    . Step 1:   Read the data
    .
    skip 25
    read bland.dat y1 y2
    skip 0
    .
    . Step 2:   Set plot control features
    .
    case asis
    title case asis
    label case asis
    title offset 2
    y1label Method A - Method B
    x1label Mean of Method A and Method B
    title Bland Altman Plot
    .
    line blank solid solid dash dash solid dash dash solid dash dash
    line color black black red red red blue blue blue blue blue blue
    character circle
    character hw 1.0 0.75
    character fill on
    .
    ylimits -140 80
    .
    . Step 3:   Generate the plot
    .
    bland altman plot y1 y2
    .
    . Step 4:   Now generate the plot with uncertainty regions shaded
    .
    subregion on on on
    let xmin = minimum xplot subset tagplot = 1
    let xmax = maximum xplot subset tagplot = 1
    subregion 1 xlimit xmin xmax
    subregion 2 xlimit xmin xmax
    subregion 3 xlimit xmin xmax
    subregion 1 ylimit diffmlcl diffmucl
    subregion 2 ylimit lowlmlcl lowlmucl
    subregion 3 ylimit upplmlcl upplmucl
    region fill on on on
    region color g90 g90 g90
    region border line bl bl bl
    .
    bland altman plot y1 y2
    subregion off off off
    region fill off off off
    .
    . Step 5:   Generate normal probability plot of differences
    .
    skip 0
    read dpst1f.dat ydiff
    y1label Sorted Differences
    x1label Percentils of Normal Distribution
    Title Normal Probability Plot of Differences
    ylimits
    normal probability plot ydiff
 
Program 2:
    . Step 1:   Read the data
    .
    skip 25
    read bland.dat y1 y2
    skip 0
    .
    . Step 2:   Set plot control features
    .
    case asis
    title case asis
    label case asis
    title offset 2
    y1label ((Method A - Method B)/Mean) %
    x1label Mean of Method A and Method B
    title Bland Altman Plot
    .
    line blank solid solid dash dash solid dash dash solid dash dash
    line color black black red red red blue blue blue blue blue blue
    character circle
    character hw 1.0 0.75
    character fill on
    .
    . Step 3:   Generate the plot
    .
    set bland altman plot percentage
    bland altman plot y1 y2
 
Program 3:
    . Step 1:   Read the data
    .
    skip 25
    read bland.dat y1 y2
    skip 0
    let n = size y1
    let tag = 1 for i = 1 1 n
    let ydiff = y1 - y2
    let tag = 2 subset ydiff < -80
    let tag = 3 subset ydiff >  35
    .
    . Step 2:   Set plot control features
    .
    case asis
    title case asis
    label case asis
    title offset 2
    y1label Method A - Method B
    x1label Mean of Method A and Method B
    title Bland Altman Plot
    .
    line       blank blank blank solid solid blank blank solid blank ...
               blank solid blank blank
    line color black black black black red   red   red   blue  blue  ...
               blue  blue  blue  blue
    character circle circle circle
    character hw 2.0 1.50 all
    character fill on on on
    character color black red blue
    .
    . Step 3:   Generate the plot
    .
    ylimits -140 80
    highlight bland altman plot y1 y2 tag

Program 4:
    . Step 1:   Read the data
    .
    skip 25
    read bland.dat y1 y2
    skip 0
    .
    . Step 2:   Set plot control features
    .
    case asis
    title case asis
    label case asis
    title offset 2
    y1label Method A - Method B
    x1label Mean of Method A and Method B
    title Bland Altman Plot with Bootstrap Confidence Intervals
    .
    line blank solid solid dash dash solid dash dash solid dash dash
    line color black black red red red blue blue blue blue blue blue
    character circle
    character hw 1.0 0.75
    character fill on
    .
    ylimits -140 80
    .
    . Step 3:   Generate the plot
    .
    bootstrap samples 10000
    seed 31298
    set random number generator fibbonacci congruential
    set bland altman plot confidence intervals bootstrap
    .
    bland altman plot y1 y2

-----BLANK POSTSCRIPT--------------------------------------------
 
BLANK POSTSCRIPT
 
Name:
    BLANK POSTSCRIPT
 
Type:
    Output Device Command
 
Purpose:
    Controls whether Postscript output to device 3 contains an initial
    blank page.
 
Description:
    The Postscript driver does a page erase when it is initialized to
    ensure valid output when diagrammatic graphics are done before the
    first PLOT command.  However, this is a nuisance for device 3 since
    it initializes the device for each PLOT command (device 3 contains
    the most recent plot only).  This command allows you to toggle the
    initial page erase on or off (you may want it on if you are doing a
    lot of diagrammatic graphics).  This does not affect the initial
    blank page for device 2 (set PRE-ERASE OFF before the first plot
    command to get the same effect).
 
Syntax:
    BLANK POSTSCRIPT <ON/OFF>
    where OFF suppresses the initial page erase and ON turns it on.
 
Examples:
    BLANK POSTSCRIPT ON
    BLANK POSTSCRIPT OFF
 
Note:
    This command only applies to device 3 Postsript output.
 
Default:
    The initial page erase is suppressed (i.e., OFF).
 
Synonyms:
    None
 
Related Commands:
    POSTSCRIPT          = Set device 1 to POSTSCRIPT.
    DEVICE 3 ...        = Set device 3 type.
    PRE-ERASE           = Control whether PLOT does an erase.
 
Applications:
    XX
 
Implementation Date:
    1992/5
 
Program:
    XX
 
-----BLANK STRING-----------------------------------------------------
 
BLANK STRING

Name:
    BLANK STRING
 
Type:
    Let Subcommand
 
Purpose:
    Create a blank string of specified length.
 
Description:
    It may sometimes be convenient to create a blank string of a given
    length.  This is most likely to be useful when concatenating strings
    where it is desired to have a specified number of blank spaces
    between the separate strings.

Syntax:
    LET <sout> = BLANK STRING WORD <nlen>
    where <sout> is the name of the resulting string;
    and   <nlen> is a number or parameter that specifies the
                 number of blanks to include in the string.

Examples:
    LET SOUT = BLANK STRING STRING WORD 1
    LET SOUT = BLANK STRING STRING WORD NLENGTH

Note:
    The requested number of blanks must be a positive integer value
    between 1 and 50,000.  Real numbers will be rounded to the closest
    integer.  For values outside this range, an error is reported and
    no output string is generated.
 
Note:
    The total number of characters that DATAPLOT can use for storing
    functions and strings is set when DATAPLOT is built.  The current
    default (11/2008) is 50,000 characters.  Previous versions may set
    this limit at 1,000 or 10,000 characters.  This limit applies to the
    combined number of characters for all functions and strings.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    NUMBER OF WORDS           = Return the number of words in a string.
    UPPER CASE                = Convert a string to upper case.
    LOWER CASE                = Convert a string to lower case.
    LET FUNCTION              = Defines a function.
    LET STRING                = Defines a string.
    READ STRING               = Reads a string from a file.
    SUBSTITUTE CHARACTER (^)  = Substitute the value of a string or
                                parameter.
    CONCATENATE CHARACTER (&) = Concatenate two strings.
    SUBTRING                  = Extract a substring from an existing
                                string.
    STRING INDEX              = Extract the start/stop positions of a
                                substring within a string.
    STRING CONCATENATE        = Concatenate one or more previously
                                defined strings.
    STRING EDIT               = Edit a string.
    STRING MERGE              = Insert a string into another string
                                without overwrite.
    STRING LENGTH             = Return the length of a string.
    CHARACTER                 = Convert numeric values to strings based
                                on the ASCII collating sequence.
    ICHAR                     = Convert a string to numeric values based
                                on the ASCII collating sequence.
    GROUP LABEL               = Define the text for group labels.
 
Applications:
    Data Management
 
Implementation Date:
    2017/01
 
Program:
    let nlen = 1
    let sblank = blank string nlen
    let s1 = One
    let s2 = Two
    let s3 = Three
    let sout = string concatenate s1 sblank s2 sblank s3
    print sout

-----BLOCK PLOT-----------------------------------------------------
 
BLOCK PLOT
 
Name:
    BLOCK PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a block plot.
 
Description:
    The block plot is an graphical tool for assessing whether the factor of
    interest (the primary factor) has a statistically significant effect on
    the response, and whether that conclusion about the primary factor
    effect is valid robustly over all other nuisance or secondary factors
    in the experiment.

    It replaces the analysis of variance test with a less
    assumption-dependent binomial test and should be routinely used whenever
    we are trying to robustly decide whether a primary factor has an effect.

    Block plots are formed as follows:

         Vertical axis:   the response variable
         Horizontal axis: all combinations of all levels of all nuisance
                          (secondary) factors
         Plot Character:  levels of the primary factor

    For example, if we have 2 nuisance factors and n1=2 and n2=2, the
    blocks will be set up on the X axis as follows:
 
          |                |          |               |
        =====================       =====================
        x2(1)            x2(2)      X2(1)           X2(2)
                 |                           |
               x1(1)                       x1(2)
 
    The groups of block plots will be centered around the numeric
    values for the levels of the x1 variable.  Within each block, the
    levels of the <char> variable are plotted as distinct traces at
    the values of the corresponding response variable.  The levels of
    <char> are identified by using the CHARACTER command (e.g.,
    CHAR 1 2 3; LINE BL BL BL).  A box is drawn around the <char>
    levels for each unique combination of factor levels (this is where
    the term block plot comes from).  The command BAR EXPANSION
    controls the height and width of the boxes.
 
Syntax 1:
    BLOCK PLOT <y> <x1> ... <xk>  <char>
               <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable variable;
          <x1> ... <xk> is a list of one or more nuisance factor
              variables;
          <char> is the primary factor variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    <stat> BLOCK PLOT <y> <x1> ... <xk>  <char>
               <SUBSET/EXCEPT/FOR qualification>
    where <stat> is one of Dataplot's supported statistics;
          <y> is the response variable variable;
          <x1> ... <xk> is a list of one or more nuisance factor
              variables;
          <char> is the primary factor variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    Enter HELP STATISTICS for a list of Dataplot's supported statistics.

    Note that only statistics requiring a single response variable
    are supported (e.g., MEAN BLOCK PLOT is supported, but
    CORRELATION BLOCK PLOT is not).
 
    This syntax can be used when there is replication at each of the
    combinations of factor levels.  The requested statistic is
    calculated for all the response values with the same levels of the
    factor variables.  The <char> variable is plotted at the computed
    statistic on the vertical axis.  MEAN BLOCK PLOT is the most
    commonly used.

Examples:
    BLOCK PLOT Y X1 X2
    BLOCK PLOT Y X1 X2 X3
    BLOCK PLOT Y X1 X2 X3 X4
    MEAN BLOCK PLOT Y X1 X2 X3

Note:
    For each block, the values of the primary factor are plotted.  Dataplot
    computes a binomial test of these blocks.  Specifically, the settings
    are defined as 1, 2, and so on.  The setting that occurs most
    frequently is set to "heads" and all other settings are set to "tails"
    (i.e., this extends the test to cases where there are more than 2
    settings).  Based on this, the block plot saves the following
    parameters:

        HEADS:     the number of times the heads setting is the maximum
                   value
        TRIALS:    the total number of blocks
        FACES:     the number of settings for the primary factor
        TAILPROB:  the binomial CDF based on the number of heads and
                   the number of trials
        AVEDEL:    the mean difference between the minimum setting and the
                   maximum setting of the primary factor
        SDAVED:    the standard error of AVEDEL

Note:
    The following commands were added 4/2012:

        SET BLOCK PLOT FILTER <ON/OFF>
        SET BLOCK PLOT LABEL <ON/OFF>
        SET BLOCK PLOT WIDTH <value>

    When the BLOCK PLOT FILTER option is ON, when a specific block
    only has one value for the combination of factor levels, that
    block will be suppressed.  This option is OFF by default.

    The other two commands are most frequently used when the FILTER
    option is ON.  The BLOCK PLOT LABEL will label the level of the
    last nuisance factor of the block.  When the FILTER option
    results in many missing blocks, this can be helpful.  The
    BLOCK PLOT WIDTH option allows you to manually set the width
    of the blocks.  In most cases, this is not needed.  However,
    it may occassionally be helpful to be able to do this.  The
    value is set in 0 to 100 screen units.  A typical value would
    be on the order of 0.05.

Note:
    The following command was added 12/2012:

       SET BLOCK PLOT BACKGROUND <ON/OFF>

    If this option is ON, you can use the REGION commands to
    provide a background color for the blocks.  The first block
    uses the first arguments of the REGION commands, the second block
    uses the second argumemts of the REGION commands, and so on.
    This is demonstrated in the Program 2 example below.

    In some cases, you may want to give all blocks the same
    background.  You can do this with the command

       REGION FILL ON ALL
       REGION FILL COLOR G75 ALL

    In other cases, you may want to highlight specific blocks
    with different colors.  For example, if the blocks have two
    levels (say 1 and 2), you may want to color those blocks where
    1 is higher than 2 with one color and those blocks where
    2 is higher than 1 with another color.  In this case, you
    need to list the specific color for each block as is
    demonstrated in the Program 2 example.

Note:
    The following command was added 11/2016:

       SET BLOCK PLOT JITTER <value>

    where <value> is a value between 0 and 1 (values less than 0 are set
    to 0 and values greater than 1 are set to 1).  Typically this value
    should be less than 0.5.  A value of 0 means that no jittering is
    applied (this is the default).

    This option can be useful if the plot characters within a block
    have significant overlap so that some of the characters are not
    readable.  With this option, you can add some "jitter" so that the
    characters are offset horizontally.

    Specifically, a uniform random number between -<value> and +<value>
    will be generated and that will be added to the x-coordinate value
    of the character position.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LINES       = Sets the type for plot lines.
    CHARACTER   = Sets the type for plot characters
    BOX PLOT    = Generates a box plot
    YOUDEN PLOT = Generates a Youden plot.
    ANOVA       = Performs a fixed effects analysis of variance for
                  balanced data.
    PLOT        = Generates a data or function plot.
 
Applications:
    Analysis of Variance

Reference:
    Kuo, Way and Pierson, Marcia Martens, Eds. (1993), Quality Through
    Engineering Design", specifically, the article Filliben, Cetinkunt,
    Yu, and Dommenz (1993), Exploratory Data Analysis Techniques as
    Applied to a High-Precision Turning Machine, Elsevier, New York,
    pp. 199-223.

Implementation Date:
    2002/8:  The list of supported statistics was significantly
             upgraded
    2012/4:  Added SET BLOCK PLOT FILTER, SET BLOCK PLOT LABEL and
             SET BLOCK PLOT WIDTH
    2012/12: Added SET BLOCK PLOT BACKGROUND
    2016/11: Added SET BLOCK PLOT JITTER
 
Program 1:
    READ Y PROC PLANT SPEED SHIFT
    28.4    1     1    1    1
    21.9    2     1    1    1
    36.8    1     1    1    2
    19.2    2     1    1    2
    28.2    1     1    1    3
    26.6    2     1    1    3
    30.4    1     1    2    1
    25.1    2     1    2    1
    25.5    1     1    2    2
    21.5    2     1    2    2
    26.0    1     1    2    3
    21.9    2     1    2    3
    20.2    1     2    1    1
    14.3    2     2    1    1
    19.9    1     2    1    2
    22.5    2     2    1    2
    23.4    1     2    1    3
    18.5    2     2    1    3
    38.2    1     2    2    1
    12.8    2     2    2    1
    22.0    1     2    2    2
    22.5    2     2    2    2
    30.3    1     2    2    3
    17.7    2     2    2    3
    END OF DATA
    .
    XLIMITS 1 2
    MAJOR X1TIC MARK NUMBER 2
    MINOR X1TIC MARK NUMBER 0
    TIC MARK OFFSET UNITS DATA
    X1TIC MARK OFFSET 0.6 0.6
    X1TIC MARK LABEL FORMAT ALPHA
    X1TIC MARK LABEL CASE ASIS
    X1TIC MARK LABEL CONTENT PlantSP()1CR()Speed(2)-Shift(3) ...
                             PlantSP()2CR()Speed(2)-Shift(3)
    .
    CHARACTERS 1 2
    LINE BLANK BLANK
    BLOCK PLOT Y PLANT SPEED SHIFT PROC
    .
    LET CDF = ROUND(TAILPROB,3)
    CASE ASIS
    JUST CENTER
    MOVE 50 5
    TEXT Heads: ^heads, Trials: ^trials, CDF: ^cdf
 
Program 2:
    LET Y = DATA  55 61 57 58 62 54
    LET X = DATA   1  1  2  2  3  3
    LET TAG = DATA 1  2  1  2  1  2
    .
    CHARACTER 1 2
    REGION FILL ON ON ON
    REGION FILL COLOR BLUE BLUE RED
    .
    SET BLOCK PLOT BACKGROUND ON
    BLOCK PLOT Y X TAG

-----BN (LET)--------------------------------
 
BN
 
Name:
    BN (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Bernoulli number or the Bernoulli polynomial.
 
Description:
    The Bernoulli numbers can be defined by the recurrence
    relation:

        B(N) = -SUM[(1/(k!(n-k)!)B(k)]

    where N defines the order of the Bernouilli numbers, the
    summation is from k = 0 to N-1, "!" is the factorial
    function, and B(0) = 1.  

    The Bernoulli polynomials can be defined in terms of the
    Bernoulli numbers:

        B(x,n) = SUM[BINOM(n,k)*B(k)*x**(n-k)]

    where the summation is from k = 0 to n, BINOM is the
    binomial coefficient function (n!/(k!(n-k)!), and B(k) is
    the Bernoulli number of order k.

    Dataplot computes this function using the BERNOB and BERNPN
    routines from "Computation of Special Functions" (see the
    Reference section below).
 
Syntax 1:
    LET <y> = BN(<x>,<n>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, variable or parameter;
          <n> is a non-negagive integer number, variable or
              parameter;
          <y> is a variable or a parameter (depending on what <x> 
               and <n> are) where the computed Bernoulli polynomial
               values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the Bernoulli polynomial of order <n>.

Syntax 2:
    LET <y> = BN(<n>)    <SUBSET/EXCEPT/FOR qualification>
    where <n> is a non-negagive integer number, variable or
              parameter;
          <y> is a variable or a parameter (depending on what <n> 
               is) where the computed Bernoulli numbers are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the Bernoulli number of order <n>.

Examples:
    LET A = BN(12)
    LET A = BN(B)
    LET A = BN(2.5,4)
    LET Y = BN(X,N)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BINCDF       = Compute the binomial cumulative distribution
                   function.
    BINPDF       = Compute the binomial probability mass function.
    BINPPF       = Compute the binomial percent point function.
    BINOMIAL     = Compute the binomial coefficients.
    EN           = Compute Euler number or polynomial.
 
Reference:
    "Computation of Special Functions", Shanjie Zhang and Jianming
    Jin, John Wiley and Sons, 1996, chapter 1.
 
Applications:
    Probability
 
Implementation Date:
    1997/12
 
Program:
    TITLE AUTOMATIC
    PLOT BN(X,2) FOR X = 0 0.01 5

-----BNBCDF (LET)--------------------------------
 
BNBCDF
 
Name:
    BNBCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the beta-negative binomial cumulative distribution
    function with shape parameters alpha, beta, and k.
 
Description:
    If the probability of success parameter, p, of a
    negative binomial distribution has a Beta distribution with
    shape parameters alpha and beta, the resulting distribution
    is referred to as a beta-negative binomial distribution.  For
    a standard negative binomial distribution, p is assumed to be
    fixed for successive trials.  For the beta-negative binomial
    distribution, the value of p changes for each trial.

    The formula for the beta-negative binomial probability mass
    function is

       p(x;alpha,beta,k) = [Gamma(beta+alpha)*Gamma(k+beta)*
                           Gamma(x+k)*Gamma(x+alpha)]/
                           [Gamma(k)*Gamma(beta)*Gamma(alpha)*
                           Gamma(x+1)*Gamma(x+k_alpha+beta)]
                           x = 0, 1, 2, ...; alpha, beta > 0;
                           k is a positive integer">

    with alpha, beta, and k denoting the shape parameters and
    Gamma denoting the gamma function.

    Dataplot compumtes the cumulative distribution function
    using the following recurrence relation derived by
    Hesselager:

       p(x) = p(x-1)*[x+(k-1)]*[x+(alpha-1)]/
              [x*(x+(alpha+beta+k-1))]

Syntax:
    LET <y> = BNBCDF(<x>,<alpha>,<beta>,<k>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable containing
               non-negative integer values;
          <alpha> is a number, parameter, or variable that specifies
               the first shape parameter;
          <beta> is a number, parameter, or variable that specifies
               the second shape parameter;
          <k> is a number, parameter, or variable that specifies
               the third shape parameter;
          <y> is a variable or a parameter (depending on what <x>
               is) where the computed beta-negative binomial cdf
               value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BNBCDF(4,0.5,0.9,3)
    LET A = BNBCDF(X,2.1,4,2.5)
    PLOT BNBCDF(X,ALPHA,BETA,K) FOR X = 0 1 20
 
Note:
    This distribution is sometimes referred to as the inverse
    Markov-Polya (or inverse Polya-Eggenberger) distribution.

    Irwin developed the generalized Waring distribution based
    on a generalization of the Waring expansion.  The generalized
    Waring distribution is a re-parameterized beta-negative
    binomial distribution.  Irwin's uses the parameterization

        beta = a
        alpha = c - a
        k = k

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    GWACDF is a synonym for BNBCDF
 
Related Commands:
    BNBPDF                   = Compute the beta-negative binomial
                               probability mass function.
    BNBPPF                   = Compute the beta-negative binomial
                               percent point function.
    BGEPDF                   = Compute the beta-geomeric probability
                               mass function.
    BETPDF                   = Compute the beta probability density
                               function.
    NBPDF                    = Compute the negative binomial
                               probability mass function.
    BBNPDF                   = Compute the beta-binomial (Waring)
                               probability mass function.
 
Reference:
    Ole Hesselager (1994), "A Recursive Procedure for Calculations
    of Some Compound Distributions", Astin Bulliten, Vol. 24,
    No. 1, pp. 19-32.

    J. O. Irwin (1975), "The Generalized Waring Distribution
    Part 1", Journal of the Royal Statistical Society, Series A,
    138, pp. 18-31.

    J. O. Irwin (1975), "The Generalized Waring Distribution
    Part 2", Journal of the Royal Statistical Society, Series A,
    138, pp. 204-227.

    J. O. Irwin (1975), "The Generalized Waring Distribution
    Part 3", Journal of the Royal Statistical Society, Series A,
    138, pp. 374-378.

    Johnson, Kotz, and Kemp (1992), "Univariate Discrete
    Distributions", Second Edition, Wiley, chapter 6.

    Luc Devroye (1992), "Random Variate Generation for the Digamma
    and Trigamma Distributions", Journal of Statistical Computation
    and Simulation", Vol. 43, pp. 197-216.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/7
 
Program:
    XLIMITS 0 50
    XTIC OFFSET 0.5 0.5
    LINE BLANK
    SPIKE ON
    SPIKE THICKNESS 0.3
    .
    TITLE CASE ASIS
    LABEL CASE ASIS
    X1LABEL Number of Successes
    Y1LABEL Probability
    TITILE DISPLACEMENT 2
    Y1LABEL DISPLACEMENT 15
    X1LABEL DISPLACEMENT 12
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    LET K = 3
    TITLE Alpha = 0.5, Beta = 0.5, K = 3
    PLOT BNBCDF(X,0.5,0.5,K) FOR X = 0 1 50
    .
    TITLE Alpha = 3, Beta = 0.5, K = 3
    PLOT BNBCDF(X,3.0,0.5,K) FOR X = 0 1 50
    .
    TITLE Alpha = 0.5, Beta = 3, K = 3
    PLOT BNBCDF(X,0.5,3.0,K) FOR X = 0 1 50
    .
    TITLE Alpha = 3, Beta = 3, K = 3
    PLOT BNBCDF(X,3.0,3.0,K) FOR X = 0 1 50
    .
    END OF MULTIPLOT
    .
    CASE ASIS
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Beta-Negative Binomial Cumulative Distribution Functions
 
-----BNBPDF (LET)--------------------------------
 
BNBPDF
 
Name:
    BNBPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the beta-negative binomial probability mass function
    with shape parameters alpha, beta, and k.
 
Description:
    If the probability of success parameter, p, of a
    negative binomial distribution has a Beta distribution with
    shape parameters alpha and beta, the resulting distribution
    is referred to as a beta-negative binomial distribution.  For
    a standard negative binomial distribution, p is assumed to be
    fixed for successive trials.  For the beta-negative binomial
    distribution, the value of p changes for each trial.

    The formula for the beta-negative binomial probability mass
    function is

       p(x;alpha,beta,k) = [Gamma(beta+alpha)*Gamma(k+beta)*
                           Gamma(x+k)*Gamma(x+alpha)]/
                           [Gamma(k)*Gamma(beta)*Gamma(alpha)*
                           Gamma(x+1)*Gamma(x+k_alpha+beta)]
                           x = 0, 1, 2, ...; alpha, beta > 0;
                           k is a positive integer">

    with alpha, beta, and k denoting the shape parameters and
    Gamma denoting the gamma function.

    Note that there are a number of different parameterizations
    and formulations of this distribution in the literature.  We
    use the above formulation because it makes clear the relation
    between the beta-negative binomial and the negative binomial
    distributions.  It also demonstrates the relation between the
    beta-negative binomial and the beta-binomial and beta-geometric
    distributions.  It also provides a computationally convenient
    formula since the beta-negative binomial can be computed as
    the sums and differences of log gamma functions.

Syntax:
    LET <y> = BNBPDF(<x>,<alpha>,<beta>,<k>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable containing
               non-negative integer values;
          <alpha> is a number, parameter, or variable that specifies
               the first shape parameter;
          <beta> is a number, parameter, or variable that specifies
               the second shape parameter;
          <k> is a number, parameter, or variable that specifies
               the third shape parameter;
          <y> is a variable or a parameter (depending on what <x>
               is) where the computed beta-negative binomial pdf
               value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BNBPDF(4,0.5,0.9,3)
    LET A = BNBPDF(X,2.1,4,2.5)
    PLOT BNBPDF(X,ALPHA,BETA,K) FOR X = 0 1 20
 
Note:
    This distribution is sometimes referred to as the inverse
    Markov-Polya (or inverse Polya-Eggenberger) distribution.

    Irwin developed the generalized Waring distribution based
    on a generalization of the Waring expansion.  The generalized
    Waring distribution is a re-parameterized beta-negative
    binomial distribution.  Irwin's uses the parameterization

        beta = a
        alpha = c - a
        k = k

Note:
    For a number of commands utilizing the beta-negative binomial
    distribution, it is convenient to bin the data.  There are
    two basic ways of binning the data.

      1) For some commands (histograms, maximum likelihood
         estimation), bins with equal size widths are
         required.  This can be accomplished with the
         following commands:

            LET AMIN = MINIMUM Y
            LET AMAX = MAXIMUM Y
            LET AMIN2 = AMIN - 0.5
            LET AMAX2 = AMAX + 0.5
            CLASS MINIMUM AMIN2
            CLASS MAXIMUM AMAX2
            CLASS WIDTH 1
            LET Y2 X2 = BINNED

      2) For some commands, unequal width bins may be
         helpful.  In particular, for the chi-square goodness
         of fit, it is typically recommended that the minimum
         class frequency be at least 5.  In this case, it may
         be helpful to combine small frequencies in the tails.
         Unequal class width bins can be created with the
         commands

            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = INTEGER FREQUENCY TABLE Y

         If you already have equal width bins data, you can
         use the commands
         
            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = COMBINE FREQUENCY TABLE Y2 X2

         The MINSIZE parameter defines the minimum class
         frequency.  The default value is 5.

Note:
    You can generate beta-negative binomial random numbers,
    probability plots, and chi-square goodness of fit tests
    with the following commands:

       LET K     = <value>
       LET ALPHA = <value>
       LET BETA = <value>
       LET Y = BETA NEGATIVE BINOMIAL RANDOM NUMBERS FOR I = 1 1 N

       BETA NEGATIVE BINOMIAL PROBABILITY PLOT Y
       BETA NEGATIVE BINOMIAL PROBABILITY PLOT Y2 X2
       BETA NEGATIVE BINOMIAL PROBABILITY PLOT Y3 XLOW XHIGH

       BETA NEGATIVE BINOMIAL CHI-SQUARE GOODNESS OF FIT Y
       BETA NEGATIVE BINOMIAL CHI-SQUARE GOODNESS OF FIT Y2 X2
       BETA NEGATIVE BINOMIAL CHI-SQUARE GOODNESS OF FIT ...
            Y3 XLOW XHIGH

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    GWAPDF is a synonym for BNBPDF
 
Related Commands:
    BNBCDF                   = Compute the beta-negative binomial
                               cumulative distribution function.
    BNBPPF                   = Compute the beta-negative binomial
                               percent point function.
    BGEPDF                   = Compute the beta-geomeric cumulative
                               distribution function.
    BETPDF                   = Compute the beta probability density
                               function.
    NBPDF                    = Compute the negative binomial
                               probability mass function.
    BBNPDF                   = Compute the beta-binomial probability
                               mass function.
    INTEGER FREQUENCY TABLE  = Generate a frequency table at
                               integer values with unequal bins.
    COMBINE FREQUENCY TABLE  = Convert an equal width frequency
                               table to an unequal width frequency
                               table.
    PROBABILITY PLOT         = Generate a probability plot.
 
Reference:
    Ole Hesselager (1994), "A Recursive Procedure for Calculations
    of Some Compound Distributions", Astin Bulliten, Vol. 24,
    No. 1, pp. 19-32.

    J. O. Irwin (1975), "The Generalized Waring Distribution
    Part 1", Journal of the Royal Statistical Society, Series A,
    138, pp. 18-31.

    J. O. Irwin (1975), "The Generalized Waring Distribution
    Part 2", Journal of the Royal Statistical Society, Series A,
    138, pp. 204-227.

    J. O. Irwin (1975), "The Generalized Waring Distribution
    Part 3", Journal of the Royal Statistical Society, Series A,
    138, pp. 374-378.

    Johnson, Kotz, and Kemp (1992), "Univariate Discrete
    Distributions", Second Edition, Wiley, chapter 6.

    Luc Devroye (1992), "Random Variate Generation for the Digamma
    and Trigamma Distributions", Journal of Statistical Computation
    and Simulation", Vol. 43, pp. 197-216.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/7
 
Program 1:
    XLIMITS 0 50
    XTIC OFFSET 0.5 0.5
    LINE BLANK
    SPIKE ON
    SPIKE THICKNESS 0.3
    .
    TITLE CASE ASIS
    LABEL CASE ASIS
    X1LABEL Number of Successes
    Y1LABEL Probability Mass
    TITILE DISPLACEMENT 2
    Y1LABEL DISPLACEMENT 15
    X1LABEL DISPLACEMENT 12
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    LET K = 3
    TITLE Alpha = 0.5, Beta = 0.5, K = 3
    PLOT BNBPDF(X,0.5,0.5,K) FOR X = 0 1 50
    .
    TITLE Alpha = 3, Beta = 0.5, K = 3
    PLOT BNBPDF(X,3.0,0.5,K) FOR X = 0 1 50
    .
    TITLE Alpha = 0.5, Beta = 3, K = 3
    PLOT BNBPDF(X,0.5,3.0,K) FOR X = 0 1 50
    .
    TITLE Alpha = 3, Beta = 3, K = 3
    PLOT BNBPDF(X,3.0,3.0,K) FOR X = 0 1 50
    .
    END OF MULTIPLOT
    .
    CASE ASIS
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Beta-Negative Binomial Probability Mass Functions
 
Program 2:
    let alpha = 1.5
    let beta = 3
    let k = 4
    .
    let y = beta negative binomial random numbers for i = 1 1 500
    let amax = maximum y
    let amax2 = amax + 0.5
    class lower -0.5
    class upper amax2
    class width 1
    let y2 x2 = binned y
    let y3 xlow xhigh = integer frequency table y
    .
    tic offset units screen
    tic offset 3 3
    .
    relative histogram y2 x2
    limits freeze
    pre-erase off
    line color blue
    .
    plot bnbpdf(x,alpha,beta,k) for x = 0 1 20
    limits
    pre-erase on
    .
    beta negative binomial chi-square goodness of fit y3 xlow xhigh
    .
    char x
    line blank
    beta negative binomial probability plot y3 xlow xhigh

-----BNBPPF (LET)--------------------------------
 
BNBPPF
 
Name:
    BNBPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the beta-negative binomial percent point
    function with shape parameters alpha, beta, and k.
 
Description:
    If the probability of success parameter, p, of a
    negative binomial distribution has a Beta distribution with
    shape parameters alpha and beta, the resulting distribution
    is referred to as a beta-negative binomial distribution.  For
    a standard negative binomial distribution, p is assumed to be
    fixed for successive trials.  For the beta-negative binomial
    distribution, the value of p changes for each trial.

    The formula for the beta-negative binomial probability mass
    function is

       p(x;alpha,beta,k) = [Gamma(beta+alpha)*Gamma(k+beta)*
                           Gamma(x+k)*Gamma(x+alpha)]/
                           [Gamma(k)*Gamma(beta)*Gamma(alpha)*
                           Gamma(x+1)*Gamma(x+k_alpha+beta)]
                           x = 0, 1, 2, ...; alpha, beta > 0;
                           k is a positive integer">

    with alpha, beta, and k denoting the shape parameters and
    Gamma denoting the gamma function.

    Dataplot compumtes the cumulative distribution function
    using the following recurrence relation derived by
    Hesselager:

       p(x) = p(x-1)*[x+(k-1)]*[x+(alpha-1)]/
              [x*(x+(alpha+beta+k-1))]

    Dataplot computes the percent point function by summing 
    the cumulative distribution function until the specified
    probability is obtained.

Syntax:
    LET <y> = BNBPPF(<p>,<alpha>,<beta>,<k>)
              <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or variable in the
               interval (0,1);
          <alpha> is a number, parameter, or variable that specifies
               the first shape parameter;
          <beta> is a number, parameter, or variable that specifies
               the second shape parameter;
          <k> is a number, parameter, or variable that specifies
               the third shape parameter;
          <y> is a variable or a parameter (depending on what <p>
               is) where the computed beta-negative binomial ppf
               value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BNBPPF(0.95,0.5,0.9,3)
    LET A = BNBPPF(P,2.1,4,2.5)
    PLOT BNBPPF(P,ALPHA,BETA,K) FOR P = 0  0.01  0.99
 
Note:
    This distribution is sometimes referred to as the inverse
    Markov-Polya (or inverse Polya-Eggenberger) distribution.

    Irwin developed the generalized Waring distribution based
    on a generalization of the Waring expansion.  The generalized
    Waring distribution is a re-parameterized beta-negative
    binomial distribution.  Irwin's uses the parameterization

        beta = a
        alpha = c - a
        k = k

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    GWAPPF is a synonym for BNBPPF
 
Related Commands:
    BNBCDF                   = Compute the beta-negative binomial
                               cumulative distribution function.
    BNBPDF                   = Compute the beta-negative binomial
                               probability mass function.
    BGEPDF                   = Compute the beta-geomeric probability
                               mass function.
    BETPDF                   = Compute the beta probability density
                               function.
    NBPDF                    = Compute the negative binomial
                               probability mass function.
    BBNPDF                   = Compute the beta-binomial (Waring)
                               probability mass function.
 
Reference:
    Ole Hesselager (1994), "A Recursive Procedure for Calculations
    of Some Compound Distributions", Astin Bulliten, Vol. 24,
    No. 1, pp. 19-32.

    J. O. Irwin (1975), "The Generalized Waring Distribution
    Part 1", Journal of the Royal Statistical Society, Series A,
    138, pp. 18-31.

    J. O. Irwin (1975), "The Generalized Waring Distribution
    Part 2", Journal of the Royal Statistical Society, Series A,
    138, pp. 204-227.

    J. O. Irwin (1975), "The Generalized Waring Distribution
    Part 3", Journal of the Royal Statistical Society, Series A,
    138, pp. 374-378.

    Johnson, Kotz, and Kemp (1992), "Univariate Discrete
    Distributions", Second Edition, Wiley, chapter 6.

    Luc Devroye (1992), "Random Variate Generation for the Digamma
    and Trigamma Distributions", Journal of Statistical Computation
    and Simulation", Vol. 43, pp. 197-216.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/7
 
Program:
    TITLE CASE ASIS
    LABEL CASE ASIS
    Y1LABEL Number of Successes
    X1LABEL Probability
    TITILE DISPLACEMENT 2
    Y1LABEL DISPLACEMENT 15
    X1LABEL DISPLACEMENT 12
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    LET K = 3
    TITLE Alpha = 0.5, Beta = 0.5, K = 3
    PLOT BNBPPF(P,0.5,0.5,K) FOR P = 0  0.01  0.99
    .
    TITLE Alpha = 3, Beta = 0.5, K = 3
    PLOT BNBPPF(P,3.0,0.5,K) FOR P = 0  0.01  0.99
    .
    TITLE Alpha = 0.5, Beta = 3, K = 3
    PLOT BNBPPF(P,0.5,3.0,K) FOR P = 0  0.01  0.99
    .
    TITLE Alpha = 3, Beta = 3, K = 3
    PLOT BNBPPF(P,3.0,3.0,K) FOR P = 0  0.01  0.99
    .
    END OF MULTIPLOT
    .
    CASE ASIS
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Beta-Negative Binomial Percent Point Functions
 
-----BNOCDF (LET)--------------------------------
 
BNOCDF
 
Name:
    BNOCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the beta-normal cumulative distribution function
    with shape parameters alpha and beta.
 
Description:
    There are a class of distributions defined by the following
    cumulative distribution function:

       F(x;alpha,beta) = (1/BETA(ALPHA,BETA)*INTEGRAL[0 to G(x)]
                         [w**(alpha-1)*(1-w)**(beta-1)dw]
                         alpha, beta > 0

    with G(x) denoting a function.  That is, this is the beta
    cumulative distribution function, but the upper limit of
    integration is defined by another cumulative distribution
    function.

    The case where G(x) denotes the normal cumulative distribution
    function results in the beta-normal distribution with the following
    cumulative distribution function:

       F(x;alpha,beta) = (1/BETA(ALPHA,BETA)*INTEGRAL[0 to Phi(x)]
                         [w**(alpha-1)*(1-w)**(beta-1)dw]
                         alpha, beta > 0

    with Phi denoting the cumulative distribution function of the
    standard normal distribution.

    This distribution can be extended with location and scale
    parameters by replacing the standard normal distribution with a
    normal distribution with location parameter mu and scale parameter
    sigma.  The mu and sigma are also the location and scale parameter
    of the beta-normal distribution.

Syntax:
    LET <y> = BNOCDF(<x>,<alpha>,<beta>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what <x>
               is) where the computed beta-normal cdf value is
               stored;
          <alpha> is a number, parameter, or variable that specifies
               the first shape parameter;
          <beta> is a number, parameter, or variable that specifies
               the second shape parameter;
          <loc> is a number, parameter, or variable that specifies
               the location parameter;
          <scale> is a number, parameter, or variable that specifies
               the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The <loc> and <scale> parameters are optional.

Examples:
    LET A = BNOCDF(0.3,0.1,0.1)
    LET X2 = BNOCDF(X1,0.1,0.1)
    PLOT BNOCDF(X,0.1,0.1) FOR X = -10  0.01  10

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BNOPDF = Compute the beta-normal probability density function.
    BNOPPF = Compute the beta-normal percent point function.
    BETPDF = Compute the beta probability density function.
    NORPDF = Compute the normal probability density function.
    GAMPDF = Compute the gamma probability density function.
 
Reference:
    "Handbook of Beta Distribution and Its Applications",
    Edited by Arjun Gupta and Saralees Nadarajah,
    Marcel Dekker Inc., 2004, pp. 146-152.

    Eugene, Lee, and Famoye (2002).  "Beta-Normal Distribution and
    Its Applications", Communications in Statistics-Theory and
    Methods, 31, pp. 497-512.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2006/3
 
Program:
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 3
    LABEL CASE ASIS
    X1LABEL X
    Y1LABEL Probability
    Y1TIC MARK LABEL DECIMAL 2
    X1LABEL DISPLACEMENT 14
    Y1LABEL DISPLACEMENT 15
    TITLE DISPLACEMENT 2
    .
    LET A = DATA 0.1  1  5
    LET B = DATA 0.1  1  5
    LOOP FOR K = 1 1 3
        LET ALPHA = A(K)
        LOOP FOR L = 1 1 3
            LET BETA = B(L)
            TITLE ALPHA = ^ALPHA, BETA = ^BETA
            PLOT BNOCDF(X,ALPHA,BETA) FOR X = -10  0.01  10
        END OF LOOP
    END OF LOOP
    .
    END OF MULTIPLOT
    JUSTIFICATION CENTER
    MOVE 50 97
    CASE ASIS
    TEXT CDF's For Beta-Normal Distribution
 
-----BNOPDF (LET)--------------------------------
 
BNOPDF
 
Name:
    BNOPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the beta-normal probability density function with
    shape parameters alpha and beta.
 
Description:
    There are a class of distributions defined by the following
    cumulative distribution function:

       F(x;alpha,beta) = (1/BETA(ALPHA,BETA)*INTEGRAL[0 to G(x)]
                         [w**(alpha-1)*(1-w)**(beta-1)dw]
                         alpha, beta > 0

    with G(x) denoting a cumulative distribution function.  That is,
    this is the beta cumulative distribution function, but the upper
    limit of integration is defined by another cumulative distribution
    function.

    The case where G(x) denotes the standard normal cumulative
    distribution function results in the beta-normal distribution.
    The probability density function for this distribution is:

        f(x;alpa,beta) = (1/BETA(alpha,bets)*NORCDF(X)**(alpha-1)*
                         (1-NORCDF(x))**(beta-1)*NORPDF(x)
                         alpha, beta > 0
    
    with alpha, beta, BETA, NORCDF, and NORPDF denoting the
    two shape parameters, the Beta function, the standard normal
    cumulative distribution function, and the standard normal
    probability density function, respectively.

    This distribution can be extended with location and scale
    parameters by replacing the standard normal distribution with a
    normal distribution with location parameter mu and scale parameter
    sigma.  The mu and sigma are also the location and scale parameter
    of the beta-normal distribution.  The above formula for the pdf
    can be modified by replacing x with (x-mu)/sigma.

Syntax:
    LET <y> = BNOPDF(<x>,<alpha>,<beta>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what <x>
               is) where the computed beta-normal pdf value is
               stored;
          <alpha> is a number, parameter, or variable that specifies
               the first shape parameter;
          <beta> is a number, parameter, or variable that specifies
               the second shape parameter;
          <loc> is a number, parameter, or variable that specifies
               the location parameter;
          <scale> is a number, parameter, or variable that specifies
               the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The <loc> and <scale> parameters are optional.

Examples:
    LET A = BNOPDF(0.3,0.1,0.1)
    LET X2 = BNOPDF(X1,0.1,0.1)
    PLOT BNOPDF(X,0.1,0.1) FOR X = -10  0.01  10
 

Note:
    Beta-normal random numbers, probability plots, and goodness
    of fit tests can be generated with the commands:

       LET ALPHA = <value>
       LET BETA = <value>
       LET Y = BETA-NORMAL RANDOM NUMBERS FOR I = 1 1 N
       BETA NORMAL PROBABILITY PLOT Y
       BETA NORMAL KOLMOGOROV SMIRNOV GOODNESS OF FIT Y
       BETA NORMAL CHI-SQUARE GOODNESS OF FIT Y

    The following commands can be used to estimate the shape
    parameters for the beta-normal distribution:

       LET ALPHA1 = <value>
       LET ALPHA2 = <value>
       LET BETA1 = <value>
       LET BETA2 = <value>
       BETA NORMAL PPCC PLOT Y
       BETA NORMAL KS PLOT Y

    The default values for ALPHA1 and ALPHA2 are 0.5 and 5.  The
    default values for BETA1 and BETA2 are 0.5 and 5.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BNOCDF = Compute the beta-normal cumulative distribution function.
    BNOPPF = Compute the beta-normal percent point function.
    BETPDF = Compute the beta probability density function.
    NORPDF = Compute the normal probability density function.
    GAMPDF = Compute the gamma probability density function.
 
Reference:
    "Handbook of Beta Distribution and Its Applications",
    Edited by Arjun Gupta and Saralees Nadarajah,
    Marcel Dekker Inc., 2004, pp. 146-152.

    Eugene, Lee, and Famoye (2002).  "Beta-Normal Distribution and
    Its Applications", Communications in Statistics-Theory and
    Methods, 31, pp. 497-512.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2006/3
 
Program:
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 3
    LABEL CASE ASIS
    X1LABEL X
    Y1LABEL Probability Density
    Y1TIC MARK LABEL DECIMAL 2
    X1LABEL DISPLACEMENT 14
    Y1LABEL DISPLACEMENT 15
    TITLE DISPLACEMENT 2
    .
    LET A = DATA 0.1  1  5
    LET B = DATA 0.1  1  5
    LOOP FOR K = 1 1 3
        LET ALPHA = A(K)
        LOOP FOR L = 1 1 3
            LET BETA = B(L)
            TITLE ALPHA = ^ALPHA, BETA = ^BETA
            PLOT BNOPDF(X,ALPHA,BETA) FOR X = -10  0.01  10
        END OF LOOP
    END OF LOOP
    .
    END OF MULTIPLOT
    JUSTIFICATION CENTER
    MOVE 50 97
    CASE ASIS
    TEXT PDF's For Beta-Normal Distribution
 
-----BNOPPF (LET)--------------------------------
 
BNOPPF
 
Name:
    BNOPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the beta-normal percent point function with shape
    parameters alpha and beta.
 
Description:
    There are a class of distributions defined by the following
    cumulative distribution function:

       F(x;alpha,beta) = (1/BETA(ALPHA,BETA)*INTEGRAL[0 to G(x)]
                         [w**(alpha-1)*(1-w)**(beta-1)dw]
                         alpha, beta > 0

    with G(x) denoting a function.  That is, this is the beta
    cumulative distribution function, but the upper limit of
    integration is defined by another cumulative distribution
    function.

    The case where G(x) denotes the normal cumulative distribution
    function results in the beta-normal distribution with the following
    cumulative distribution function:

       F(x;alpha,beta) = (1/BETA(ALPHA,BETA)*INTEGRAL[0 to Phi(x)]
                         [w**(alpha-1)*(1-w)**(beta-1)dw]
                         alpha, beta > 0

    with Phi denoting the cumulative distribution function of the
    standard normal distribution.

    The beta-normal percent point function is computed by numerically
    inverting the beta-normal cumulative distribution function.

    This distribution can be extended with location and scale
    parameters by replacing the standard normal distribution with a
    normal distribution with location parameter mu and scale parameter
    sigma.  The mu and sigma are also the location and scale parameter
    of the beta-normal distribution.

 
Syntax:
    LET <y> = BNOPPF(<p>,<alpha>,<beta>,<loc>,<scale>)
              <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or variable in the range [0,1];
          <y> is a variable or a parameter (depending on what <p>
               is) where the computed beta-normal ppf value is
               stored;
          <alpha> is a number, parameter, or variable that specifies
               the first shape parameter;
          <beta> is a number, parameter, or variable that specifies
               the second shape parameter;
          <loc> is a number, parameter, or variable that specifies
               the location parameter;
          <scale> is a number, parameter, or variable that specifies
               the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The <loc> and <scale> parameters are optional.

Examples:
    LET A = BNOPPF(0.95,0.1,0.1)
    LET X2 = BNOPPF(P1,0.1,0.1)
    PLOT BNOPPF(P,0.1,0.1) FOR P = 0.01  0.01  0.99

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BNOCDF = Compute the beta-normal cumulative distribution function.
    BNOPDF = Compute the beta-normal probability density function.
    BETPDF = Compute the beta probability density function.
    NORPDF = Compute the normal probability density function.
    GAMPDF = Compute the gamma probability density function.
 
Reference:
    "Handbook of Beta Distribution and Its Applications",
    Edited by Arjun Gupta and Saralees Nadarajah,
    Marcel Dekker Inc., 2004, pp. 146-152.

    Eugene, Lee, and Famoye (2002).  "Beta-Normal Distribution and
    Its Applications", Communications in Statistics-Theory and
    Methods, 31, pp. 497-512.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2006/3
 
Program:
    MULTIPLOT 3 3
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 3
    LABEL CASE ASIS
    Y1LABEL X
    X1LABEL Probability
    X1LABEL DISPLACEMENT 14
    Y1LABEL DISPLACEMENT 15
    TITLE DISPLACEMENT 2
    .
    LET A = DATA 0.1  1  5
    LET B = DATA 0.1  1  5
    LOOP FOR K = 1 1 3
        LET ALPHA = A(K)
        LOOP FOR L = 1 1 3
            LET BETA = B(L)
            TITLE ALPHA = ^ALPHA, BETA = ^BETA
            PLOT BNOPPF(P,ALPHA,BETA) FOR P = 0.01  0.01  0.99
        END OF LOOP
    END OF LOOP
    .
    END OF MULTIPLOT
    JUSTIFICATION CENTER
    MOVE 50 97
    CASE ASIS
    TEXT PPF's For Beta-Normal Distribution
 
-----BOOTSTRAP FIT---------------------------------
 
BOOTSTRAP FIT
 
Name:
    BOOTSTRAP FIT
 
Type:
    Graphics Command
 
Purpose:
    Performs a bootstrap linear or multilinear fit.
 
Description:
    The standard solution for linear/nultilinear fitting is
    to use ordinary least squares (OLS).  OLS is based on
    several assumptions:

       1) The residuals from the fit have constant location and
          variance.
       2) The residuals from the fit are independent.
       3) The residuals from the fit follow a common distribution,
          usually assumed to be the normal distribution. 
    
    When these assumptions are at least approximately satisfied,
    OLS provides the optimal estimates and uncertainty intervals
    for the fit coefficients.  However, if the assumptions are
    not at least approximately satisfied, then the OLS estimates
    may no longer be optimal.  Applying transformations and
    weighting are common approaches to fitting when the assumptions
    are not satisfied.

    Bootstrap fitting provides an additional alternative.
    The bootstrap is a non-parametric method for calculating a sampling
    distribution for a statistic.  The bootstrap calculates the
    statistic with N different subsamples.  The subsampling is done
    with replacement.  In the context of fitting, we are
    estimating the coefficients of the fit and providing
    bootstrap estimates of the uncertainty.
 
    There are two approaches to bootstrapping for fitting.

       1) In the first approach, the OLS fit is computed from
          the original data.  The residuals are then resampled.
          The residuals are then added to the predicted values
          of the original fit to obtain a new Y vector.  This
          new Y vector is then fit against the original X
          variables.  We call this approach residual resampling
          (or the Efron approach).

       2) In the second approach, rows of the original data
          (both the Y vector and the corresponding rows of the
          X variables) are resampled.  The resampled data are
          then fit.  We call this approach data resampling (or
          the Wu approach).

    Hamilton (see Reference below) gives some guidance on the
    contrasts between these approaches.

       1) Residual resampling assumes fixed X values and
          independent and identically distributed residuals. 

       2) Data resampling does not assume independent and
          identically distributed residuals.

    Given the above, if the assumption of fixed X is realistic
    (that is, we could readily collect new Y's with the same
    X values), then residual resampling is justified.  For example,
    this would be the case in a designed experiment.  However,
    if this assumption is not realistic (i.e., the X values
    vary randomly as well as the Y's), then data resampling is
    preferred.
 
    If the bootstrap methods produce substantially different
    results, this is an indication that the assumptions of fixed
    X and independent and identically distributed residuals may
    not be valid.

    The BOOTSTRAP FIT command produces the following output:

       1) A few lines listing the sample size, the number of
          bootstrap samples, and the bootstrap method used
          (residual resampling or data resampling).

       2) A summary table where each row of the table corresponds
          to one of fit coefficients.  The first column identifies
          the parameter.  Columns 2 and 3 list the coeficient
          estimate and standard deviation from the original fit.
          Columns 4 through 7 list the mean, the standard
          deviation, and the 2.5 and 97.5 percentiles of the
          bootstrap sample.

       3) Typically, the analyst will want to further viewing
          and analysis of the bootstrap samples.  For example,
          a histogram of the bootstrap samples are often
          displayed.

          Dataplot writes the bootstrap samples to file.  You
          can read these back into Dataplot to generate
          additional graphing and analysis of the bootstrap samples.

          Specifically,

          a) The bootstrap samples for the coefficient estimates
             are written to the file "dpst1f.dat".
 
          b) The bootstrap samples for the coefficient standard
             deviation estimates are written to the file
             "dpst2f.dat".
 
          c) The bootstrap samples for the residual standard
             deviation estimates are written to the file
             "dpst3f.dat".
 
          The program example below demonstrates the use of
          these files after the BOOTSTRAP FIT command.

Syntax 1:
    BOOTSTRAP FIT <y> <x1> ... <xk>
                  <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response (dependent) variable;
          <x1> .... <xk> is a list of one or more independent
              variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    BOOTSTRAP FIT Y X
    BOOTSTRAP FIT Y X1 X2 X3 X4
    BOOTSTRAP FIT Y X1 X2 X3 X4 SUBSET TAG > 1
 
Note:
    Use the following command to specify which bootstrap
    method is used:

        SET BOOTSTRAP FIT METHOD <RESIDUAL/DATA>

    The default is RESIDUAL.  You can use EFRON as a synonym
    for RESIDUAL and WU as a synonym for DATA.

Note:
    Linear and quadratic calibration are special applications
    of fitting.   The following commands can be used to
    perform a bootstrap analysis of linear and quadratic
    calibration, respectively:

        LET Y0 = <value>
        BOOTSTRAP LINEAR CALIBRATION PLOT
        BOOTSTRAP QUADRATIC CALIBRATION PLOT

    The BOOTSTRAP FIT METHOD command also applies to theses commands.

Note:
    The number of bootstrap samples can be specified with the
    command:

        BOOTSTRAP SAMPLES <value>

Note:
    Confidence intervals for the coefficients of the fit model
    can be obtained from the appropriate percentiles of the
    bootstrap samples (e.g., the 2.5% and 97.5% percentiles
    provided in the summary table).  However, in some cases
    these percentiles may have less than the nominal coverage
    probability.

    Some refinements to generate more accurate confidence
    intervals have been proposed.  The issue of bootstrap
    confidence intervals for multilinear fitting is discussed
    on pages 319-325 of Hamilton.

Default:
    Residual resampling is used with 100 bootstrap samples.
 
Synonyms:
    None
 
Related Commands:
    BOOTSTRAP SAMPLES   = Specify the number of bootstrap samples
                          to generate.
    BOOTSTRAP METHOD    = Specify whether residual or data
                          resampling is used.
    BOOTSTRAP PLOT      = Generate a bootstrap plot.
    JACKNIFE PLOT       = Generate a jacknife plot.
    HISTOGRAM           = Generates a histogram.
    KERNEL DENSITY PLOT = Generates a kernel density plot.
    PLOT                = Generates a data/function plot.
 
Reference:
    "A Leisurely Look at the Bootstrap, the Jacknife, and
    Cross-Validation", Efron and Gong, The American Statistician,
    February, 1983.
 
    "Regression with Graphics: A Second Course in Applied
    Statistics", Duxbury Press, 1992.

Applications:
    Fitting
 
Implementation Date:
    2002/7
 
Program:
    skip 25
    read berger1.dat y x
    .
    set bootstrap fit method data
    bootstrap samples 100
    bootstrap fit y x
    .
    delete a0 a1
    skip 0
    set read format 2e15.7
    read dpst1f.dat a0 a1
    read dpst2f.dat a0sd a1sd
    .
    multiplot corner coordinates 0 0 100 100
    multiplot scale factor 2
    multiplot 2 2
    .
    title a0 estimate
    let bmean = mean a0
    let b025 = 2.5 percentile a0
    let b975 = 97.5 percentile a0
    x2label mean = ^bmean, b025 = ^b025, b975 = ^b975
    histogram a0
    title a1 estimate
    let bmean = mean a1
    let b025 = 2.5 percentile a1
    let b975 = 97.5 percentile a1
    x2label mean = ^bmean, b025 = ^b025, b975 = ^b975
    histogram a1
    title a0 standard deviation
    let bmean = mean a0sd
    x2label mean = ^bmean
    histogram a0sd
    title a1 standard deviation
    let bmean = mean a1sd
    x2label mean = ^bmean
    histogram a1sd
    .
    end of multiplot
 
-----BOOTSTRAP INDEX (LET)--------------------------------
 
BOOTSTRAP INDEX
 
Name:
    BOOTSTRAP INDEX (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the BOOTSTRAP INDEX for a variable.
 
Description:
    This command is used in conjunction with the LOOP and BOOTSTRAP
    SAMPLE commands to perform a bootstrap analysis for a statistic not
    directly supported by the BOOTSTRAP PLOT command.
 
    The bootstrap is a non-parametric method for estimating the sampling
    distribution of a statistic.  Given a sample data set and a desired
    statistic (e.g., the mean), the bootstrap works by computing the
    desired statistic for a subsample of the data set.  The subsampling
    is done with replacement and the size of the sample is equal to the
    size of the original data set.  The pair of commands BOOTSTRAP INDEX
    and BOOTSTRAP SAMPLE compute one subsample.  The LOOP command is
    typically used to generate a large number of samples (values between
    100 and 1000 are typical).  The desired statistic is calculated for
    each subsample.  The collection of these statistics is used as an
    estimate of the sampling distribution.  A histogram or some other
    type of distributional plot is usually performed on the computed
    values of the statistic.
 
    The BOOTSTRAP INDEX command generates a random sample of the
    integers from 1 to N (where N is the sample size).  The BOOTSTRAP
    SAMPLE command then uses these numbers as indices into the original
    data.  For example, suppose that Y is an array containing the values
    106, 212, 314, and 58 and that the BOOTSTRAP INDEX command returned
    an array with 2 1 2 4, then the bootstrap sample would be 212, 106,
    212, and 58 (that is, Y(2), Y(1), Y(2), Y(4)).
 
Syntax:
    LET <ind> = BOOTSTRAP INDEX FOR I = 1 1 <par>
    where <ind> is a variable that contains the computed index numbers;
    and   <par> is the size of the variable for which the bootstrap
                analysis is being performed.
 
Examples:
    LET IND = BOOTSTRAP INDEX FOR I = 1 1 100
    LET IND2 = BOOTSTRAP INDEX FOR I = 1 1 N
 
Note:
    It is significantly faster to perform a bootstrap analysis for one
    of the 25 supported statistics (HELP BOOTSTRAP PLOT to see a list).
    However, the sample program below demonstrates how to do it for an
    arbitrary statistic.
 
Note:
    The SEED command can be used to specify the seed for the random
    bootstrap index.
 
Note:
    The jacknife is a similar technique.  However, it uses a different
    resampling scheme.  See the JACKIFE PLOT command for details.
 
Default:
    None
 
Synonyms:
    RANDOM INDEX
 
Related Commands:
    BOOTSTRAP PLOT      = Generate a bootstrap plot.
    BOOTSTRAP SAMPLE    = Generate a bootstrap sample.
    LOOP                = Initiate a loop.
    JACKNIFE PLOT       = Generate a jacknife plot.
    JACKINFE INDEX      = Generate a jacknife index.
    SEED                = Specify the seed for random numbers.
 
Reference:
    "A Leisurely Look at the Bootstrap, the Jacknife, and
    Cross-Validation", Efron and Gong, The American Statistician,
    February, 1983.
 
Applications:
    Sample Distribution of a Statistic
 
Implementation Date:
    89/2
 
Program:
    READ BERGER1.DAT X Y
    LET N = NUMBER Y
    LET NUMBOOT = 100
    LET Y2 = LOG(Y)
    LET X2 = LOG(X)
    FIT Y2 X2
    LET PRED2 = PRED
    LET RES2 = RES
    LET Y0 = 50
    LET Y20 = LOG(50)
    FEEDBACK OFF
    PRINTING OFF
    LOOP FOR K = 1 1 NUMBOOT
        LET IND = BOOTSTRAP INDEX FOR I = 1 1 N
        LET RES3 = BOOTSTRAP SAMPLE RES2 IND
        LET Y3 = PRED2 + RES3
        FIT Y3 X
        LET X0(K) = (Y20-A0)/A1
    END OF LOOP
    FEEDBACK ON
    PRINTING ON
    LET SDX0 = STANDARD DEVIATION X0
    HISTOGRAM X0
 
-----BOOTSTRAP PLOT---------------------------------
 
BOOTSTRAP PLOT
 
Name:
    BOOTSTRAP PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a bootstrap plot for a given statistic.
 
Description:
    The bootstrap is a non-parametric method for calculating a sampling
    distribution for a statistic.  The bootstrap calculates the
    statistic with N different subsamples.  The subsampling is done
    with replacement.  For details on how to calculate bootstrap
    estimates for unsupported statistics, enter
    HELP BOOTSTRAP SAMPLE.
 
    For the bootstrap plot, the vertical axis contains the computed
    value of the statistic and the horizontal axis contains the sample
    number (for k = 1, 2,  ..., N).  The number of response variables
    depends on the number of variables required to compute the
    statistic (e.g., the MEAN uses one while the LINEAR INTERCEPT uses
    two). The bootstrap plot is typically followed by some type of
    distributional plot such as a histogram.
 
    Dataplot also supports BOOTSTRAP computations for the case
    when there is one group variable.  In this case, the horizontal
    axis is group id and the vertical axis contains the computed
    values of the statistic for that group.  The number of bootstrap
    samples is applied to each group.  For example,if the requested
    number of bootstrap samples is 100, then each group will
    have 100 bootstrap samples applied.

Syntax 1:
    BOOTSTRAP <stat> PLOT <y1> ... <yk>
                          <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of 1 to 3 response variables
              (depending on what <stat> is);
          <stat> is one of Dataplot's supported statistics
              (enter HELP STATISTICS for a list);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for the no group-id's case.

Syntax 2:
    BOOTSTRAP <stat> PLOT <y1> ... <yk> <x>
                          <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of 1 to 3 response variables
              (depending on what <stat> is);
          <x> is a group id variable;
          <stat> is one of Dataplot's supported statistics
              (enter HELP STATISTICS for a list);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for the case when there is one group-id
    variable.

Syntax 3:
    BOOTSTRAP <stat> PLOT <y1> ... <yk> <x1> <x2>
                          <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of 1 to 3 response variables
              (depending on what <stat> is);
          <x1> is the first group id variable;
          <x2> is the second group id variable;
          <stat> is one of Dataplot's supported statistics
              (enter HELP STATISTICS for a list);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for the case when there are two group-id
    variables.

Examples:
    BOOTSTRAP MEAN PLOT Y
    BOOTSTRAP LINEAR SLOPE PLOT Y1 X1
    BOOTSTRAP MEAN PLOT Y TAG
    BOOTSTRAP MEAN PLOT Y TAG  SUBSET TAG > 2
    BOOTSTRAP DIFFERENCE OF MEAN PLOT Y1 Y2 TAG
 
Note:
    The 2010/3 version of Dataplot updated the BOOTSTRAP PLOT command
    to include reports in addition to the plots.

    1) If the BOOTSTRAP PLOT is applied to a statistic (e.g.,
       BOOTSTRAP MEAN PLOT Y), the following tables are generated:

       a) An initial summary table.

       b) A table containing percent points for the computed statistic.

       c) A table containing percentile confidence limits for
          the statistic for various values of alpha.

    2) If the BOOTSTRAP PLOT is applied to a a distributional fit
       (e.g., BOOTSTRAP WEIBULL PPCC PLOT Y or BOOTSTRAP WEIBULL MLE
       PLOT Y), the following tables are generated:

       a) An initial summary table.

       b) A table containing percentile confidence limits for each of
          the parameters of the distribution for various levels of
          alpha.

       c) If the SET MAXIMUM LIKELIHOOD PERCENTILES command was
          given, a table containing confidence limits for the
          specified percentiles will be generated.

       Enter HELP DISTRIBUTIONAL BOOTSTRAP for details on this version
       of the BOOTSTRAP PLOT.

    The SET WRITE DECIMALS command can be used to specify the
    number of decimals to use in the tables and the CAPTURE HTML,
    CAPTURE LATEX, and CAPTURE RTF options are supported.

Note:
    When there are two response variables, the bootstrap is applied
    differently depending on whether the two response variables are
    paired (dependent) or unpaired (independent).  In the paired case,
    each bootstrap sample uses the same rows for the two response
    variables.  In the unpaired case, different bootstrap samples are
    applied to each response variable.  If the response variables have
    different sample sizes, the unpaired case is assumed.  If the
    sample sizes are equal, you can use the following command

        SET BOOTSTRAP GROUPS  <INDEPENDENT/DEPENDENT>

    to specify whether you have paired or unpaired response
    variables.  The default is INDEPENDENT (i.e., unpaired).

Note:
    In addition to the supported statistics, the following
    additional statistics are supported

        LINEAR CALIBRATION
        QUADRATIC CALIBRATION

Note:
    The BOOTSTRAP PLOT command saves the following internal
    parameters.

       BMEAN  - the mean of the plotted bootstrap values
       BSD    - the standard deviation of the plotted bootstrap
                values
       B001   - the 0.1% percentile of the plotted bootstrap values
       B005   - the 0.5% percentile of the plotted bootstrap values
       B01    - the 1% percentile of the plotted bootstrap values
       B025   - the 2.5% percentile of the plotted bootstrap values
       B05    - the 5% percentile of the plotted bootstrap values
       B10    - the 10% percentile of the plotted bootstrap values
       B20    - the 20% percentile of the plotted bootstrap values
       B80    - the 80% percentile of the plotted bootstrap values
       B90    - the 90% percentile of the plotted bootstrap values
       B95    - the 95% percentile of the plotted bootstrap values
       B975   - the 97.5% percentile of the plotted bootstrap values
       B99    - the 99% percentile of the plotted bootstrap values
       B999   - the 99.9% percentile of the plotted bootstrap values

    The values are typically used in setting confidence intervals.

    Note that for the replication case (i.e., you have a group
    id variable), the above quantities are computed using all the
    groups.  In most cases, you will want these quantities for
    each group.  See the Note section below regarding information
    written to DPST1F.DAT, DPST2F.DAT, and DPST3F.DAT.

Note:
    A number of these statistics require one or more parameters
    to be defined before entering the BOOTSTRAP PLOT command.
    Specifically,

       1. The trimmed and Winsorized statistics, the percentage
          of data in each tail to be trimmed/Winsorized needs to
          be specified.  For example, to trim/Winsorize 10% of the
          data in each tail, enter the commands:

             LET P1 = 10%
             LET P2 = 10%

       2. For the QUANTILE and QUANTILE STANDARD ERROR, the
          quantile being estimated needs to be specified by
          entering the command

             LET XQ = <value>

          where <value> is a number in the range 0 to 1.

          Likewise, for the PERCENTILE, the desired percentile
          needs to be specified by entering the command

             LET P100 = <value>

          where <value> is a number in the range 0 to 100.

       3. For the PERCENTAGE BEND MIDVARIANCE and PERCENTAGE
          BEND CORRELATION, the value of beta needs to be
          specified by entering the command:

              LET BETA = <value>

          where <value> is a number between 0 and 0.5.  A
          default value of 0.1 is used if beta is not defined.

       4. For the LINEAR CALIBRATION and QUADRATIC CALIBRATION
          statistics, the value of Y for which the calibration
          is to be computed is specified by entering the command

              LET Y0 = <value>

Note:
    The 1/2004 version of Dataplot now writes information to
    the files dpst1f.dat and dpst2f.dat (in the current directory).
 
    1) The file dpst1f.dat will contain the group-id (will be a
       column of 1's if no group variable was specified) and
       the estimate of the statistic of interest for each
       bootstrap sample.

       This can sometimes be useful if you want to some additional
       processing of the bootstrap estimates (e.g., generate
       percentiles not automatically computed by Dataplot).

    2) The file dpst2f.dat is only written if at least one
       group-id variable is specified.  In that case, the dpst2f.dat
       file will contain:

       - the first group-id 
       - the second group-id (if applicable)
       - mean of the bootstrap estimates for the given group
       - median of the bootstrap estimates for the given group
       - the 2.5 percentile of the bootstrap estimates for the given
         group
       - the 97.5 percentile of the bootstrap estimates for the given
         group
       - the 5.0 percentile of the bootstrap estimates for the given
         group
       - the 95.0 percentile of the bootstrap estimates for the given
         group
       - the 0.5 percentile of the bootstrap estimates for the given
         group
       - the 99.5 percentile of the bootstrap estimates for the given
         group

Note:
    The 1/2004 version of Dataplot added support for the
    BCA BOOTSTRAP PLOT.  The BCA BOOTSTRAP plot is used to
    generate more accurate confidence intervals.

    The regular BOOTSTRAP PLOT command generates confidence
    intervals based on the percentiles of the bootstrap
    statistics.  This method of computing confidence intervals,
    referred to as the percentile bootstrap, is first order
    accurate for confidence intervals.

    Section 14.3 of Efron and Tibshirani discuss the BCa method
    of generating bootstrap confidence intervals that is second
    order accurate.

    BCa is an abbreviation for "acceleration" and
    "bias-correction".  The BCa confidence interval is given by:

       BCa : (thetahat*(alpha1),thetahat*(alpha2)

    where

       thetahat*(alpha) = 100.alphath percentile of the bootstrap
                          replications
       alpha1 = NORCDF[zhat(0) +
                (zhat(0) + z(alpha))/(1 - ahat*(zhat(0) + z(alpha))]
       alpha2 = NORCDF[zhat(0) +
                (zhat(0) + z(1-alpha))/(1 - ahat*(zhat(0) + z(1-alpha))]
       NORCDF = cumulative distribution function of the standard
                normal distribution

    If ahat and zhat(0) are zero, the BCa confidence interval
    reduces to the percentile bootstrap.  Non-zero values change
    the percentiles used for the BCa interval.

    The BCa confidence interval above depends on ahat and
    zhat(0).  The zhat(0) is the bias correction and ahat is
    the acceleration.

    The value of zhat(0) is computed by

       zhat(0) = NORPPF(number of {thetahat*(b) < thetahat}/B)
    
    where

       NORPPF       = the normal percent point function
       thetahat     = the full sample estimate of the statistic of
                      interest
       thetahat*(b) = the estimate of the statistic of interest for
                      the b-th bootstrap replication
       B            = the number of bootstrap replications taken

    To compute ahat, let thetahat(i) be the estimate of the
    statistic of interest with the i-th point deleted (i.e., the
    jackknife values).  Let thetahat(.) equal the mean of the
    thetahat(i).  Then ahat can be computed by

       ahat = SUM[i=1 to n][(thetahat(.) - thetahat(i))**3]/
              (6*{SUM[i=1 to n][(thetahat(.) - thetahat(i))**2}**(3/2))

    The details of the BCa method are explained in more detail in
    Efron and Tibshirani.

    To have Dataplot generate BCa confidence intervals, enter a
    command like

       BCA BOOTSTRAP MEAN PLOT Y

    For the BCA BOOTSTRAP, Dataplot will generate the same plot
    as if the BCA option was not given.  It will write the
    following values to the file dpst3f.dat (in the current
    directory):

       1. lower confidence interval
       2. upper confidence interval
       3. zhat(0)
       4. ahat
       5. alpha1
       6. alpha2
       7. group-id 1 (if applicable)
       8. group-id 2 (if applicable)
    
    These values are written to a single row.  If you have
    the group case, one row is written for each group.  The
    confidence interval printed is for the 95% two-sided case.
    If you want a different significance level or a one-sided
    interval, you can read these values into Dataplot to
    compute the interval (see the relevant definitions above).
    To read these values back into Dataplot, you can enter
    the commands

       BCA BOOTSTRAP MEAN PLOT Y
       SKIP 6
       SET READ FORMAT 4E15.7,2F8.4,2F10.0
       READ PARAMETER DPST1F.DAT LCL UCL ZOHAT A0HAT ALPHA1 ALPHA2

    Note that you can use the BCA option with all six of the
    syntax options given above.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    JACKNIFE PLOT      = Generate a jacknife plot.
    BOOTSTRAP SAMPLE   = Set the sample size for the bootstrap
    BOOTSTRAP FIT      = Compute a bootstrap linear/multilinear fit.
    LINES              = Sets type for plot lines.
    HISTOGRAM          = Generates a histogram.
    PLOT               = Generates a data/function plot.
 
Reference:
    Efron and Gong, "A Leisurely Look at the Bootstrap, the Jacknife,
    and Cross-Validation", The American Statistician, February, 1983.
 
    Efron and Tibshirabi (1993), "An Introduction to the Bootstrap",
    Springer-Verlang.

Applications:
    Sample Distribution of a Statistic
 
Implementation Date:
    1989/2:  Original implementation
    1998/5:  added the saving of the parameters (BMEAN, BSD, etc.)
    2001/3:  added GEOMETRIC MEAN, GEOMETRIC STANDARD DEVIATION,
             HARMONIC MEAN
    2001/9:  added IQ RANGE
    2001/11: added BIWEIGHT LOCATION, BIWEIGHT SCALE
    2002/7:  activated CORRELATION, COVARIANCE, RANK CORRELATION,
             RANK COVARIANCE
    2002/7:  added LINEAR CALIBRTION, QUADRATIC CALIBRATION,
             WINSORIZED VARIANCE, WINSORIZED CORRELATION,
             WINSORIZED COVARIANCE, BIWEIGHT MIDVARIANCE,
             BIWEIGHT MIDCOVARIANCE, PERCENTAGE BEND MIDVARIANCE,
             PERCENTAGE BEND CORRELATION, HODGE LEHMAN,
             TRIMMED MEAN STANDARD ERROR,
             QUANTILE, QUANTILE STANDARD ERROR
    2003/3:  added support for the "DIFFERENCE OF" statistics
    2003/3:  added documentation for the replication (i.e., groups)
             case
    2003/5:  Added support for SN SCALE, QN SCALE,
             DIFFERENCE OF SN, DIFFERENCE OF QN
    2004/1:  Added support for two group variables
    2004/1:  Added support for BCA BOOTSTRAP commands
    2010/3:  Added support for tabular report in addition to the plot
 
Program 1:
    LET Y = UNIFORM RANDOM NUMBERS FOR I = 1 1 1000
    BOOTSTRAP SAMPLE SIZE 500
    MULTIPLOT CORNER COORDINATES 0 0 100 100
    MULTIPLOT SCALE FACTOR 2
    MULTIPLOT 2 3
    TITLE AUTOMATIC
    BOOTSTRAP MEAN PLOT Y
    LET YMEAN = YPLOT
    BOOTSTRAP MEDIAN PLOT Y
    LET YMEDIAN = YPLOT
    BOOTSTRAP MIDRANGE PLOT Y
    LET YMIDR = YPLOT
    XLIMITS 0.45 0.55
    HISTOGRAM YMEAN
    HISTOGRAM YMEDIAN
    HISTOGRAM YMIDR
    END OF MULTIPLOT

Program 2:
    SKIP 25
    READ GEAR.DAT Y X
    XLIMITS 1 10
    MAJOR XTIC MARK NUMBER 10
    MINOR XTIC MARK NUMBER 0
    XTIC OFFSET 0.5 0.5
    TIC OFFSET UNITS DATA
    X1LABEL BATCH
    Y1LABEL BOOTSTRAP ESTIMATES OF THE MEAN
    CHARACTER CIRCLE ALL
    CHARACTER HW 0.5 0.375 ALL
    CHARACTER FILL ON ALL
    LINE BLANK ALL
    SET WRITE DECIMALS 4
    BOOTSRAP MEAN PLOT Y X

-----BOOTSTRAP SAMPLE (LET)--------------------------------
 
BOOTSTRAP SAMPLE
 
Name:
    BOOTSTRAP SAMPLE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute a bootstrap sample for a variable.
 
Description:
    This command is used in conjunction with the LOOP and BOOTSTRAP
    INDEX commands to perform a bootstrap analysis for a statistic not
    directly supported by the BOOTSTRAP PLOT command.
 
    The bootstrap is a non-parametric method for estimating the sampling
    distribution of a statistic.  Given a sample data set and a desired
    statistic (e.g., the mean), the bootstrap works by computing the
    desired statistic for a subsample of the data set.  The subsampling
    is done with replacement and the size of the sample is equal to the
    size of the original data set.  The pair of commands BOOTSTRAP INDEX
    and BOOTSTRAP SAMPLE compute one subsample.  The LOOP command is
    typically used to generate a large number of samples (values between
    100 and 1000 are typical).  The desired statistic is calculated for
    each subsample.  The collection of these statistics is used as an
    estimate of the sampling distribution.  A histogram or some other
    type of distributional plot is usually performed on the computed
    values of the statistic.
 
    The BOOTSTRAP INDEX command generates a random sample of the
    integers from 1 to N (where N is the sample size).  The BOOTSTRAP
    SAMPLE command then uses these numbers as indices into the original
    data.  For example, suppose that Y is an array containing the values
    106, 212, 314, and 58 and that the BOOTSTRAP INDEX command returned
    an array with 2 1 2 4, then the bootstrap sample would be 212, 106,
    212, and 58 (that is, Y(2), Y(1), Y(2), Y(4)).
 
Syntax:
    LET <var1> = BOOTSTRAP SAMPLE <var2> <ind>
    where <var2> is the variable being resampled;
          <var1> is a variable where the resampled values are returned;
    and   <ind> is computed from the bootstrap index command.
 
Examples:
    LET RES3 = BOOTSTRAP SAMPLE RES2 IND
 
Note:
    It is significantly faster to perform a bootstrap analysis for one
    of the 25 supported statistics (HELP BOOTSTRAP PLOT to see a list).
    However, the sample program above demonstrates how to do it for an
    arbitrary statistic.
 
Note:
    The SEED command can be used to specify the seed for the random
    bootstrap index.
 
Note:
    The jacknife is a similar technique.  However, it uses a different
    resampling scheme.  See the JACKIFE PLOT command for details.
 
Default:
    None
 
Synonyms:
    RANDOM SAMPLE
    JACKNIFE SAMPLE
 
Related Commands:
    BOOTSTRAP PLOT      = Generate a bootstrap plot.
    BOOTSTRAP INDEX     = Generate a bootstrap index.
    LOOP                = Initiate a loop.
    JACKNIFE PLOT       = Generate a jacknife plot.
    JACKINFE INDEX      = Generate a jackife index.
    SEED                = Specify the seed for random number generation.
 
Reference:
    "A Leisurely Look at the Bootstrap, the Jacknife, and
    Cross-Validation", Efron and Gong, The American Statistician,
    February, 1983.
 
Applications:
    Sample Distribution of a Statistic
 
Implementation Date:
    89/2
 
Program:
    READ BERGER1.DAT X Y
    LET N = NUMBER Y
    LET NUMBOOT = 100
    LET Y2 = LOG(Y)
    LET X2 = LOG(X)
    FIT Y2 X2
    LET PRED2 = PRED
    LET RES2 = RES
    LET Y0 = 50
    LET Y20 = LOG(50)
    FEEDBACK OFF
    PRINTING OFF
    LOOP FOR K = 1 1 NUMBOOT
        LET IND = BOOTSTRAP INDEX FOR I = 1 1 N
        LET RES3 = BOOTSTRAP SAMPLE RES2 IND
        LET Y3 = PRED2 + RES3
        FIT Y3 X
        LET X0(K) = (Y20-A0)/A1
    END OF LOOP
    FEEDBACK ON
    PRINTING ON
    LET SDX0 = STANDARD DEVIATION X0
    HISTOGRAM X0
 
 
Name:
    BOOTSTRAP SAMPLE
 
Type:
    Support Command
 
Purpose:
    Specify the number of bootstrap samples to calculate for the
    BOOTSTRAP PLOT command.
 
Syntax:
    BOOTSTRAP SAMPLE <n>
    where <n> is an integer number or parameter (typically in the range
    100 to 1000) that specifies the desired number of bootstrap
    samples.
 
Examples:
    BOOTSTRAP SAMPLE 100
    BOOTSTRAP SAMPLE 1000
 
Default:
    100
 
Synonyms:
    None
 
Related Commands:
    BOOTSTRAP PLOT      = Generate a bootstrap plot.
    BOOTSTRAP INDEX     = Generate a bootstrap index.
    HISTOGRAM           = Generates a histogram.
    PLOT                = Generates a data or function plot.
 
Reference:
    "A Leisurely Look at the Bootstrap, the Jacknife, and
    Cross-Validation", Efron and Gong, The American Statistician,
    February, 1983.
 
Applications:
    Sample Distribution of a Statistic
 
Implementation Date:
    89/2
 
Program:
    BOOTSTRAP SAMPLE 100
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 1000
    HISTOGRAM YPLOT
 
-----BOX-------------------------------------------------------
 
BOX
 
Name:
    BOX
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Draws a box.
 
Description:
    The 2 pairs of coordinates define the (x,y) values for opposing
    corners (respectively) of the box.
 
Syntax:
    BOX   <x1>   <y1>   <x2>   <y2>
    where <x1> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for one corner of the
               box;
          <y1> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for one corner of the
               box;
          <x2> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for the other corner of
               the box;
    and   <y2> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for the other corner of
               the box.
 
Examples:
    BOX 50 50 60 60
    BOX 40 40 60 60
    BOX 20 70 40 80
    BOX 70 80 80 90
 
Note:
    Boxes defined by the BOX CORNER COORDINATES command are drawn
    whenever a subsequent plot is generated.  Boxes defined by the
    BOX command are generated immediately.
 
Note:
    The attributes of the box border are controlled by the BOX PATTERN,
    BOX COLOR, and BOX THICKNESS commands.  The attributes of the box
    interior are controlled by the BOX FILL COLOR, BOX FILL GAP, BOX
    FILL LINE, BOX FILL PATTERN, and BOX FILL THICKNESS commands.  The
    box shadow is controlled by the BOX SHADOW HW command.
 
Note:
    The keywords DATA and RELATIVE were added to the TRIANGLE
    command 7/1997.  These keywords are independent and can
    be used separately or together.  For example, 
    TRIANGLE DATA, TRIANGLE RELATIVE, or TRIANGLE DATA RELATIVE.
    The word DATA should come before the word RELATIVE if both
    appear.

    DATA means that the coordinates are specified in terms of
    the data units of the most recent plot rather than Dataplot
    0 to 100 screen units.

    RELATIVE means that the coordinates of the first point
    are drawn in absolute coordinates an all subsequent points
    in the figure are relative to that first point.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BOX CORNER COORD    = Generate a box on subsequent plots.
    BOX COLOR           = Sets the colors for box borders.
    BOX PATTERN         = Sets the line styles for box borders.
    BOX THICKNESS       = Sets the line thicknesses for box borders.
    BOX FILL COLOR      = Sets the colors for box fill patterns.
    BOX FILL GAP        = Sets the spacings for box hatch patterns.
    BOX FILL LINE       = Sets the line types for box hatch patterns.
    BOX FILL PATTERN    = Sets the fill patterns for boxes.
    BOX FILL THICKNESS  = Sets the line thicknesses for box hatch
                          patterns.
    BOX SHADOW HW       = Sets the height and width for box shadows.
    POINT               = Draws a point.
    ARROW               = Draws an arrow.
    TRIANGLE            = Draws a triangle.
    HEXAGON             = Draws a hexagon.
    CIRCLE              = Draws a circle.
    SEMI-CIRCLE         = Draws a semi-circle.
    ARC                 = Draws an arc.
    ELLIPSE             = Draws an ellipse.
    OVAL                = Draws an oval.
    DIAMOND             = Draws a diamond.
    DRAW                = Draws a line.
    MOVE                = Moves to a point.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    Pre-1987
 
Program:
    BOX SHADOW HW 0 0
    BOX BORDER COLOR RED
    BOX PATTERN DASH
    BOX THICKNESS 0.5
    BOX 10 10 40 40
    BOX FILL PATTERN D1D2
    BOX FILL SPACING 5.0
    BOX FILL THICKNESS 0.3
    BOX FILL COLOR BLUE
    BOX 60 60 90 90
 
-----BOX COLOR-------------------------------------------------------
 
BOX COLOR
 
Name:
    BOX ... COLOR
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the color for the frame of a box to appear on subsequent
    plots (as specified via the BOX ... COORDINATES command) or boxes
    generated by the BOX command.  Up to 100 boxes can be specified
    with the BOX ... COORDINATES command.
 
Description:
    Dataplot provides two methods for specifying colors.

        1. Colors can be defined by name (or by the corresponding index).
           Dataplot adopted it's named colors from the X11 project.
           Currently, 162 named colors and 100 levels of grayscale are
           supported.  Grayscale can be specified with either G0, G1, ...,
           G100 (or -1, -2, ..., -100).  Many older devices support only a
           limited number of colors.  For these devices, unsupported colors
           will be mapped to one of the available colors.  To specify a
           named color, see Syntax 1.

        2. Most modern graphics devices support full RGB (RedBlueGreen)
           color.  You can alternatively specify RGB colors by entering
           three integer values to represent the Red, Green and Blue
           components, respectively.  These values should be in the range
           0 to 255.

    When setting the box color, Dataplot first checks if the device
    supports RGB colors. If not, the named color will be used.  If the
    device does support RGB color, Dataplot will check if an RGB color
    has been specified.  If yes, then that RGB color is used.  If not,
    the named color will be used.

    To see the list of supported named colors (with the associated index
    number), see

    https://www.itl.nist.gov/div898/software/dataplot/refman1/ch11/homepage.htm

Syntax 1:
    BOX  <id>  COLOR  <color>
    where <id> is a box identifier (a number or parameter) in the
               integer range 1 to 100;
    and <color> specifies the desired color (enter HELP COLOR TYPES for
               a list of available colors).
 
Syntax 2:
    BOX  <id>  RGB COLOR <red-1> <green-1> <blue-1>
    where <id> is a box identifier (a number or parameter) in the
               integer range 1 to 100;
    and   <red-1>, <green-1>, <blue-1> is a list of integer values that
               specifies the desired RGB box color.

    Up to 100 such triplets of color values can be specified.

    To turn off the RGB color, set the values to -1 (any negative value
    will work).  Values greater than 255 will be set to 255.
 
Examples:
    BOX 1 COLOR GREEN
    BOX 2 COLOR BLUE
    BOX 2 RGB COLOR 220 109 88
 
Note:
    Boxes can be generated in two ways.  You can use the BOX ...
    COORDINATES command to place boxes on subsequent plots or you can
    use the BOX command to draw one box immediately.  The BOX COLOR
    command is used to specify the color of the box frame in either
    case.  When the BOX command is used, the color is set to color of
    the first box (i.e., <id> is 1).
 
Note:
    A BOX ... COLOR command with no arguments sets the box color to the
    default; thus BOX 1 COLOR with no arguments sets the color for box
    1 to the default.  A BOX ... COLOR command with no <id> refers to
    all 100 boxes; thus BOX COLOR GREEN sets the color green for all
    100 boxes.  Note also that BOX COLOR with no <id> and no arguments
    sets the default color for all 100 boxes.
 
Default:
    All box borders are black.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    BOX                 = Draws a box (immediately).
    BOX CORNER COORD    = Generate a box on subsequent plots.
    BOX PATTERN         = Sets the line styles for box borders.
    BOX THICKNESS       = Sets the line thicknesses for box borders.
    BOX FILL COLOR      = Sets the colors for box fill patterns.
    BOX FILL GAP        = Sets the spacings for box hatch patterns.
    BOX FILL LINE       = Sets the line types for box hatch patterns.
    BOX FILL PATTERN    = Sets the fill patterns for boxes.
    BOX FILL THICKNESS  = Sets the line thicknesses for box hatch
                          patterns.
    CHARACTERS COLORS   = Sets the colors for plot characters.
    LINE COLORS         = Sets the colors for plot lines.
    SPIKE COLORS        = Sets the colors for plot spikes.
    BAR FILL COLORS     = Sets the colors for plot bar fills.
    BAR PATTERN COLORS  = Sets the colors for plot bar patterns.
    BAR BORDER COLORS   = Sets the colors for plot bar borders.
    TITLE COLOR         = Sets the color for the plot title.
    LABEL COLOR         = Sets the color for plot labels.
    LEGEND COLOR        = Sets the color for plot legends.
    ARROW COLOR         = Sets the color for plot arrows.
    SEGMENT COLOR       = Sets the color for plot segments.
    FRAME COLOR         = Sets the color for the plot frame.
    GRID COLOR          = Sets the color for plot grids.
    TIC COLOR           = Sets the color for plot tics.
    TIC LABEL COLOR     = Sets the color for plot tic labels.
    MARGIN COLOR        = Sets the color for the plot margin.
    BACKGROUND COLOR    = Sets the color for the plot background.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    Pre-1987
    2020/11: Support for RGB colors
 
Program:
    ERASE
    BOX COLOR RED
    BOX SHADOW HW 0 0
    BOX 10 10 40 40
    BOX COLOR BLUE
    BOX 60 10 90 40
    BOX RGB COLOR 175 238 238
    BOX 10 60 40 90
    BOX RGB COLOR 220 20 60
    BOX 60 60 90 90
 
-----BOX COORDINATES---------------------------------------------------
 
BOX COORDINATES
 
Name:
    BOX ... CORNER COORDINATES
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the coordinates of a box to appear on subsequent plots.
 
Description:
    The 2 pairs of coordinates define the (x,y) values for opposing
    corners of the box.  The most common uses of this command are to
    draw boxes around legends and in creating legends for bar plots.
 
Syntax:
    BOX  <id>  COORDINATES  <x1>  <y1>  <x2>  <y2>
    where <id> is a box identifier (a number or parameter) in the
               integer range 1 to 100;
    and where <x1>, <y1>, <x2>, <y2> are coordinates (numbers or
               parameters) in the decimal range 0 to 100.
 
Examples:
    BOX 2 COORDINATES 50 50 60 60
    BOX 2 COORDINATES 20 60 40 80
 
Note:
    Boxes can be generated in two ways.  You can use the BOX ...
    COORDINATES command to place boxes on subsequent plots or you can
    use the BOX command to draw one box immediately.  In either case,
    the attributes of the box border are set with the BOX COLOR, BOX
    PATTERN, and BOX THICKNESS commands while the attributes of the
    box interior are set with the BOX FILL COLOR, BOX FILL GAP, BOX
    FILL PATTERN, BOX FILL LINE, and BOX FILL THICKNESS commands.
 
Note:
    You can use the CHARACTER command to set specific traces to a box
    (e.g., CHARACTER CIRCLE BOX).  In this case, the attributes of the
    box are set with the various CHARACTER attribute setting commands.
    The distinction between this and the BOX CORNER COORDINATES
    command is that you can use plot units rather than DATAPLOT 0 to
    100 screen coordinates.
 
Note:
    A BOX ... COORDINATES command with no arguments omits the box from
    subsequent plots; thus BOX 1 COORDINATES with no arguments omits
    box 1 from subsequent plots.  A BOX ... COORDINATES command with no
    <id> refers to all 100 boxes; thus BOX COORDINATES 30 50 assigns
    the coordinates (30,50) to all 100 boxes (but this has no practical
    use).  Note also that BOX COORDINATES with no <id> and no arguments
    omits all 100 boxes from subsequent plots.
 
Default:
    No boxes are drawn.
 
Synonyms:
    BOX COORDINATERS
 
Related Commands:
    PLOT                = Generates a data or function plot.
    BOX                 = Draws a box (immediately).
    BOX PATTERN         = Sets the line styles for box borders.
    BOX THICKNESS       = Sets the line thicknesses for box borders.
    BOX FILL COLOR      = Sets the colors for box fill patterns.
    BOX FILL GAP        = Sets the spacings for box hatch patterns.
    BOX FILL LINE       = Sets the line types for box hatch patterns.
    BOX FILL PATTERN    = Sets the fill patterns for boxes.
    BOX FILL THICKNESS  = Sets the line thicknesses for box hatch
                          patterns.
    LEGEND COORDINATES  = Sets the location of plot legends.
    ARROW COORDINATES   = Sets the location of plot arrows.
    SEGMENT COORDINATES = Sets the location of plot line segments.
    FRAME COORDINATES   = Sets the location of the plot frame.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    XX
 
Program:
    BOX 1 CORNER COODINATES 18 80 23 85
    BOX 1 FILL PATTERN SOLID
    LEGEND 1 COORDINATES 25 82
    LEGEND 1 XSUP()2
    BOX 2 CORNER COODINATES 18 73 23 78
    LEGEND 2 COORDINATES 25 75
    LEGEND 2 XSUP()3
    LEGEND FONT SIMPLEX
    CHARACTER BOX BOX
    CHARACTER FILL ON OFF
    PLOT X**2 FOR X = 1 1 9 AND
    PLOT X**3 FOR X = 1 1 9
 
-----BOX-COX------------------------------------------------
 
BOX COX
The following are DATAPLOT Box-Cox transformational plot commands:
    BOX-COX NORMALITY PLOT        = Generates a Box-Cox normality plot;
    BOX-COX LINEARITY PLOT        = Generates a Box-Cox linearity plot;
    BOX-COX HOMOSCEDASTICITY PLOT = Generates a Box-Cox
                                    homoscedasticity plot
 
-----BOX-COX HOMOSCEDASTICITY PLOT-----------------------------------
 
BOX COX HOMOSCEDASTICITY PLOT
 
Name:
    BOX-COX HOMOSCEDASTICITY PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a Box-Cox homoscedasticity plot.
 
Description:
    Many statistical procedures (e.g., regression) make assumptions of
    constant variance relative to the value of an independent variable.
    For example, in regression it is assumed that the variance of the
    residuals does not depend on the value of the independent variable.
    This assumption is generally referred to as homogeneous variances
    or as homoscedasticity.
 
    A Box-Cox homoscedasticity plot is a graphical technique for
    determining the Box-Cox transformation that yields the most
    constant variance of one variable relative to the values of a
    second variable.
 
    The Box-Cox family is essentially the power-transformation family
    (adjusted to include log transformations).  The form of the family
    is:
 
       T(y) = (y**lambda - 1)/lambda
 
    There are various methods for measuring constant variance.  The
    particular method DATAPLOT uses is to divide the first variable
    into groups with the same value for the second value.  For a given
    value of lambda, the standard deviation is computed for each group.
    The statistic used is the ratio of the minimum standard deviation
    to the maximum standard deviation (this ratio will always be
    between 0 and 1).  The plot then consists of this statistic on the
    vertical axis versus the lambda parameter on the horizontal axis.
    The lambda corresponding to the highest ratio is the appropriate
    transformation to use to provide the most constant variance.
 
    This command only applies if there is replication in the second
    response variable.
 
Syntax 1:
    BOX-COX HOMOSCEDASTICITY PLOT  <y>  <x>
                                   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the dependent variable;
          <x> is the independent variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    REPLICATED BOX-COX HOMOSCEDASTICITY PLOT  <y>  <x>  <tag1>
               <SUBSET/EXCEPT/FOR qualification>
    where <y> is the dependent variable;
          <x> is the independent variable;
          <tag1> is a group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    A Box-Cox homoscedasticity plot will be generated for each distinct
    value of the group-id variable.  These plots will be overlaid
    on the same plot. 

Syntax 3:
    REPLICATED BOX-COX HOMOSCEDASTICITY PLOT  <y>  <x>  <tag1>  <tag2>
               <SUBSET/EXCEPT/FOR qualification>
    where <y> is the dependent variable;
          <x> is the independent variable;
          <tag1> is a group-id variable;
          <tag2> is a group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The two group-id variables are cross-tabulated and a 
    Box-Cox homescedasticity plot will be generated for each distinct
    combination of values for the group-id variables.  These plots 
    will be overlaid on the same plot.

Examples:
    BOX COX HOMOSCED PLOT Y X
    REPLICATED BOX COX HOMOSCED PLOT Y X TAG
 
Note:
    The number of observations in the two response variables (and
    any group-id variables) must be equal.
 
Note:
    The TO syntax is supported for the BOX COX LINEARITY command.

 
Default:
    None
 
Synonyms:
    BOX-COX HOMOGENITY PLOT
 
Related Commands:
    LINES                  = Sets the types for plot lines.
    CHARACTERS             = Sets the types for plot characters.
    BOX COX LINEARITY PLOT = Generates a Box-Cox linearity plot.
    BOX COX NORMALITY PLOT = Generates a Box-Cox normality plot.
    PLOT                   = Generates a data or function plot.
 
Applications:
    Exploratory Data Analysis
 
Implementation Date:
    93/7
    2010/5: Support for REPLICATION option
 
Program:
    SKIP 25
    READ NELSON.DAT Y X1 X2
    .
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    FIT Y X2
    LINE SOLID BLANK
    CHARACTER BLANK X
    TITLE LINEAR FIT OF RAW DATA
    PLOT PRED Y VS X2
    .
    TITLE BOX-COX HOMOSCEDASTICITY PLOT
    X1LABEL LAMBDA
    Y1LABEL CORRELATION COEFFICIENT
    BOX-COX HOMOSCEDASTICTY PLOT Y X2
    .
    LET YTEMP = MAXIMUM YPLOT
    RETAIN XPLOT SUBSET YPLOT = YTEMP
    LET LAMBDA = XPLOT(1)
    LET Y2 = (Y**LAMBDA - 1)/LAMBDA
    FIT Y2 X2
    TITLE LINEAR FIT OF TRANSFORMED DATA
    X1LABEL ; Y1LABEL
    PLOT PRED Y2 VS X2
    END OF MULTIPLOT
 
-----BOX-COX LINEARITY PLOT--------------------------------------
 
BOX COX LINEARITY PLOT
 
Name:
    BOX-COX LINEARITY PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a Box-Cox Linearity Plot.
 
Description:
    A Box-Cox linearity plot is a graphical technique for determining
    the Box-Cox transformation that yields the maximum correlation
    between two variables.  Specifically, the correlation between
    (y,T(x)) where
 
       T(x) = (x**lambda - 1)/lambda
 
    is essentially the power-transformation family (adjusted to include
    log transformations).

    The horizontal axis is the lambda parameter.  The vertical axis is
    the computed correlation coefficient between <y> and the
    transformed <x>.  The lambda corresponding to the highest
    correlation is the appropriate transformation to use in linearizing
    the relationship between <y> and <x>.
 
Syntax 1:
    BOX-COX LINEARITY PLOT  <y>  <x>  <SUBSET/EXCEPT/FOR qualification>
    where <y> is the first  response variable;
          <x> is the second response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    REPLICATED BOX-COX LINEARITY PLOT  <y>  <x>  <tag1>
               <SUBSET/EXCEPT/FOR qualification>
    where <y> is the first  response variable;
          <x> is the second response variable;
          <tag1> is a group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    A Box-Cox linearity plot will be generated for each distinct
    value of the group-id variable.  These plots will be overlaid
    on the same plot. 

Syntax 3:
    REPLICATED BOX-COX LINEARITY PLOT  <y>  <x>  <tag1>  <tag2>
               <SUBSET/EXCEPT/FOR qualification>
    where <y> is the first  response variable;
          <x> is the second response variable;
          <tag1> is a group-id variable;
          <tag2> is a group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The two group-id variables are cross-tabulated and a 
    Box-Cox linearity plot will be generated for each distinct
    combination of values for the group-id variables.  These plots 
    will be overlaid on the same plot.

Examples:
    BOX-COX LINEARITY PLOT Y X
    REPLICATED BOX-COX LINEARITY PLOT Y X TAG
 
Note:
    The number of observations in the two response variables (and
    any group-id variables) must be equal.
 
Note:
    The TO syntax is supported for the BOX COX LINEARITY command.

Default:
    None
 
Synonyms:
    BOX COX LINEARITY PLOT
 
Related Commands:
    BOX-COX NORMALITY PLOT = Generate Box-Cox normality plot.
    BOX-COX HOMO      PLOT = Generate Box-Cox homoscedasticity plot.
    LINES                  = Sets type for plot lines.
    PLOT                   = Generates a data/function plot.
 
Applications:
    Exploratory Data Analysis
 
Implementation Date:
    Pre-1987
    2010/5: Support for REPLICATION option
 
Program 1:
    SKIP 25
    READ BERGER1.DAT Y X
    LABEL CASE ASIS
    Y1LABEL Correlation
    X1LABEL Lambda
    BOX COX LINEARITY PLOT Y X
 
Program 2:
    title case asis
    title offset 2
    title automatic
    label case asis
    multiplot corner coordinates 0 0 100 95
    tic mark offset units screen
    y1tic mark offset 2 0
    .
    reset data
    skip 25
    read nelson.dat y x tag
    .
    replicated box cox linearity plot y x tag

-----BOX-COX NORMALITY PLOT-------------------------------------------
 
BOX COX NORMALITY PLOT
 
Name:
    BOX-COX NORMALITY PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a Box-Cox normality plot.
 
Description:
    A Box-Cox normality plot is a graphical data analysis technique
    for determining the transformation (from the Box-Cox transformation
    family) that will yield a transformed variable that is "closest" to
    being normally distributed.  The Box-Cox transformation family is
    essentially the power-transformation family (adjusted to include
    log transformations).  The form for the family is:
 
        T(y) = (y**lambda - 1) / lambda
 
    For each of selected members of the Box-Cox family, the
    transformation is carried out, a normal probability plot is
    computed, and the linearity of the normal probability plot is
    summarized via the correlation coefficient.  The resulting
    normality plot thus consists of:

       Vertical   axis = normal probability plot correlation
                         coefficient;
       Horizontal axis = Box-Cox lambda parameter.

    The value of the lambda parameter (on the horizontal axis) which
    corresponds to the maximum of the normal probability plot
    correlation coefficient curve (on the vertical axis) is of interest
    since it indicates the best-transformation member of the family.
    The normality technique is applicable for general transformation
    families.  Currently, DATAPLOT only implements it for the Box-Cox
    family (the most important and common of the various transformation
    families).
 
Syntax 1:
    BOX-COX NORMALITY PLOT   <y>    <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax generates a single Box-Cox normality plot.  Note that
    <y> can also be a matrix argument.  If <y> is a matrix, a single
    Box-Cox normality plot is generated for all the values in the
    matrix.

Syntax 2:
    MULTIPLE BOX-COX NORMALITY PLOT  <y1> ... <yk>
                                     <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    Note that response variables can also be matrices.  If a matrix
    name is encountered, a Box-Cox normality plot  will be drawn for
    all the values in the matrix.

Syntax 3:
    REPLICATED BOX-COX NORMALITY PLOT  <y>  <x1>
                                       <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <x1> is a group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    A Box-Cox normality plot will be generated for each distinct
    value of the group-id variable.  These plots will be overlaid
    on the same plot.

Syntax 4:
    REPLICATED BOX-COX NORMALITY PLOT  <y>  <x1>  <x2>
                                       <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <x1> is a group-id variable;
          <x2> is a group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    The two group-id variables are cross-tabulated and a
    Box-Cox normality plot will be generated for each distinct
    combination of values for the group-id variables.  These plots
    will be overlaid on the same plot.

Examples:
    BOX-COX NORMALITY PLOT Y
    BOX-COX NORMALITY PLOT Y2
    MULTIPLE BOX-COX NORMALITY PLOT Y1 TO Y5
    REPLICATED BOX-COX NORMALITY PLOT Y X1
 
Note:
    The TO syntax is supported for the BOX COX NORMALITY command.
    It is most useful for the MULTIPLE version of the command.
 
Note:
    The following LET commands are also available:

        LET A = BOX COX NORMALITY PPCC   Y
        LET A = BOX COX NORMALITY LAMBDA Y

    These return the maximum PPCC value on the Box-Cox normality plot and
    the corresponding value of lambda, respectively.

    These statistics can be used in a large number of plots and commands.
    For details, enter

        HELP STATISTICS

Default:
    None
 
Synonyms:
    BOX COX NORMALITY PLOT
 
Related Commands:
    BOX-COX LINE PLOT  = Generates a Box-Cox linearity plot.
    BOX-COX HOMO PLOT  = Generates a Box-Cox homoscedasticity plot.
    LET                = Transforms variables (and many other options).
    PROBABILITY PLOT   = Generates a probability plot.
    PPCC PLOT          = Generates a probability plot correlation
                         coefficent plot.
    PLOT               = Generates a data or function plot.
 
Applications:
    Exploratory Data Analysis
 
Implementation Date:
    Pre-1987
    2010/5: Support for MULTIPLE and REPLICATION options
 
Program 1:
    LET Y = EXPONENTIAL RANDOM NUMBERS FOR I = 1 1 100
    Y1LABEL CORRELATION COEFFICIENT
    X1LABEL LAMBDA
    BOX-COX NORMALITY PLOT Y
 
Program 2:
    title case asis
    title offset 2
    title automatic
    label case asis
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    tic mark offset units screen
    y1tic mark offset 2 0
    .
    let y1 = norm rand numb for i = 1 1 100
    let y2 = logistic rand numb for i = 1 1 100
    let y3 = double exponential rand numb for i = 1 1 100
    let y4 = gumbel rand numb for i = 1 1 100
    multiplot 2 2
    box cox normality plot y1
    box cox normality plot y2
    box cox normality plot y3
    box cox normality plot y4
    end of multiplot
    move 50 97
    just center
    text Normal/Logistic/Double Exponential/Gumbel Random Numbers
    .
    line color blue red green cyan
    multiple box cox normality plot y1 to y4
    .
    reset data
    skip 25
    read rehm.dat y1 y2 x1 x2
    .
    line color blue red green
    replicated box cox normality plot y1 x2

-----BOX FILL COLOR---------------------------------------------------
 
BOX FILL COLOR
 
Name:
    BOX ... FILL COLOR
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the color to use for the interior region of a box to
    appear on subsequent plots (as specified via the BOX ...
    COORDINATES command) or boxes generated by the BOX command.  Up to
    100 boxes can be specified with the BOX ... COORDINATES command.
 
Description:
    DATAPLOT can draw either solid filled boxes or hatch pattern filled
    boxes.  This command is used in either case.  The BOX FILL PATTERN
    is used to set type of pattern fill.
 
    Dataplot provides two methods for specifying colors.

        1. Colors can be defined by name (or by the corresponding index).
           Dataplot adopted it's named colors from the X11 project.
           Currently, 162 named colors and 100 levels of grayscale are
           supported.  Grayscale can be specified with either G0, G1, ...,
           G100 (or -1, -2, ..., -100).  Many older devices support only a
           limited number of colors.  For these devices, unsupported colors
           will be mapped to one of the available colors.  To specify a
           named color, see Syntax 1.

        2. Most modern graphics devices support full RGB (RedBlueGreen)
           color.  You can alternatively specify RGB colors by entering
           three integer values to represent the Red, Green and Blue
           components, respectively.  These values should be in the range
           0 to 255.

    When setting the box fill color, Dataplot first checks if the device
    supports RGB colors. If not, the named color will be used.  If the
    device does support RGB color, Dataplot will check if an RGB color
    has been specified.  If yes, then that RGB color is used.  If not,
    the named color will be used.

    To see the list of supported named colors (with the associated index
    number), see

    https://www.itl.nist.gov/div898/software/dataplot/refman1/ch11/homepage.htm

Syntax 1:
    BOX  <id>  FILL COLOR  <color>
    where <id> is a box identifier (a number or parameter) in the
               integer range 1 to 100;
    and   <color> identifies the desired color (enter HELP COLOR TYPE for
               a list of available colors).

    If no <id> is given, all 100 box fill colors will be set to the
    specified color.
 
Syntax 2:
    BOX <id> RGB FILL COLOR <red> <green> <blue>
    where <id> is a box identifier (a number or parameter) in the
               integer range 1 to 100;
    and   <red>, <green>, <blue> is a list of integer values that
               specifies the desired RGB box fill color.

    If no <id> is given, all 100 box fill rgb colors will be set to the
    specified color.

    To turn off the RGB color, set the values to -1 (any negative value
    will work).  Values greater than 255 will be set to 255.
 
Examples:
    BOX 1 FILL COLOR BLACK
    BOX 2 FILL COLOR RED
    BOX 1 FILL RGB COLOR 175 238 238
    BOX 2 FILL RGB COLOR 220 20 60
 
Note:
    Boxes can be generated in two ways.  You can use the BOX ...
    COORDINATES command to place boxes on subsequent plots or you can
    use the BOX command to draw one box immediately.  The BOX FILL
    COLOR command is used to specify the color of the box interior in
    either case.  When the BOX command is used, the color is set to
    color of the first box (i.e., <id> is 1).
 
Note:
    A BOX ... FILL COLOR command with no arguments sets the color to
    default; thus BOX 1 FILL COLOR with no arguments sets the fill
    color for box 1 to default.  BOX FILL COLOR command with no <id>
    refers to all 100 boxes; thus BOX FILL COLOR RED assigns the color
    red to all 100 boxes.  Note also that BOX FILL COLOR with no <id>
    and no arguments sets the default fill color for all 100 boxes.
 
Default:
    Box interiors are drawn in black for both solid fills and hatch
    pattern fills.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    BOX                 = Draws a box (immediately).
    BOX CORNER COORD    = Generate a box on subsequent plots.
    BOX PATTERN         = Sets the line styles for box borders.
    BOX THICKNESS       = Sets the line thicknesses for box borders.
    BOX FILL GAP        = Sets the spacings for box hatch patterns.
    BOX FILL LINE       = Sets the line types for box hatch patterns.
    BOX FILL PATTERN    = Sets the fill patterns for boxes.
    BOX FILL THICKNESS  = Sets the line thicknesses for box hatch
                          patterns.
    LEGEND COORDINATES  = Sets the location of plot legends.
    ARROW COORDINATES   = Sets the location of plot arrows.
    SEGMENT COORDINATES = Sets the location of plot line segments.
    FRAME COORDINATES   = Sets the location of the plot frame.
    BAR PATTERN COLOR   = Sets the colors for bar pattern fills.
    BAR FILL COLOR      = Sets the colors for bar solid fills.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    1992/08
    2020/11: Support for RGB colors
 
Program 1:
    BOX 1 COORDINATES 18 80 23 85
    BOX 1 FILL COLOR RED
    LEGEND 1 COORDINATES 25 82
    LEGEND 1 XSUP()2
    .
    BOX 2 COORDINATES 18 73 23 78
    BOX 2 FILL COLOR BLUE
    LEGEND 2 COORDINATES 25 75
    LEGEND 2 XSUP()3
    .
    BOX FILL PATTERN SOLID
    LEGEND FONT SIMPLEX
    CHARACTER BOX BOX
    CHARACTER FILL ON ON
    CHARACTER COLOR RED BLUE
    .
    PLOT X**2 FOR X = 1 1 9 AND
    PLOT X**3 FOR X = 1 1 9
    .
    BOX FILL COLOR GREEN
    BOX 18 50 25 57
 
Program 2:
    BOX 1 COORDINATES 18 80 23 85
    BOX 1 FILL COLOR RED
    BOX 1 FILL RGB COLOR 220 20 60
    LEGEND 1 COORDINATES 25 82
    LEGEND 1 XSUP()2
    BOX 2 COORDINATES 18 73 23 78
    BOX 2 FILL COLOR BLUE
    BOX 2 FILL RGB COLOR 175 238 238
    LEGEND 2 COORDINATES 25 75
    LEGEND 2 XSUP()3
    BOX FILL PATTERN SOLID
    LEGEND FONT SIMPLEX
    CHARACTER BOX BOX
    CHARACTER FILL ON ON
    CHARACTER COLOR RED BLUE
    CHARACTER RGB COLOR 220 20 60 175 238 238
    PLOT X**2 FOR X = 1 1 9 AND
    PLOT X**3 FOR X = 1 1 9
    .
    BOX FILL COLOR GREEN
    BOX FILL RGB COLOR 0 158 115
    BOX 18 50 25 57
 
-----BOX FILL GAP---------------------------------------------------
 
BOX FILL GAP
 
Name:
    BOX ... FILL GAP
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the gap between lines when generating a pattern fill of a
    box to appear on subsequent plots (as specified via the BOX ...
    COORDINATES command) or boxes generated by the BOX command.  Up to
    100 boxes can be specified with the BOX ... COORDINATES command.
 
Description:
    This command only applies when filling the interior with a
    non-solid pattern (e.g., horizontal or vertical).  It is ignored
    for solid fills.  Also, the BAR FILL PATTERN command must be
    entered to specify the type of pattern fill.
 
Syntax:
    BOX  <id>  FILL GAP  <gap>
    where <id> is a box identifier (a number or parameter) in the
               integer range 1 to 100;
    and where <gap> identifies the gap (a decimal number or parameter
               between 0.0 and 100.0).
 
Examples:
    BOX 2 FILL GAP 0.5
    BOX 2 FILL GAP 0.3
    BOX 2 FILL GAP 1.5
 
Note:
    Boxes can be generated in two ways.  You can use the BOX ...
    COORDINATES command to place boxes on subsequent plots or you can
    use the BOX command to draw one box immediately.  The BOX FILL GAP
    command is used to specify the fill gap of the box pattern fill in
    either case.  When the BOX command is used, the fill gap is set to
    the fill gap of the first box (i.e., <id> is 1).
 
Note:
    A BOX ... FILL GAP command with no arguments sets the gap to
    default; thus BOX 1 FILL GAP with no arguments sets the fill gap
    for box 1 to default.  BOX FILL GAP command with no <id> refers to
    all 100 boxes; thus BOX FILL GAP 0.5 sets the fill gap to 0.5 for
    all 100 boxes.  Note also that BOX FILL GAP with no <id> and no
    arguments sets the default fill gap for all 100 boxes.
 
Default:
    All box fill gaps are set to 0.0.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    BOX                 = Draws a box (immediately).
    BOX CORNER COORD    = Generate a box on subsequent plots.
    BOX PATTERN         = Sets the line styles for box borders.
    BOX THICKNESS       = Sets the line thicknesses for box borders.
    BOX FILL COLOR      = Sets the colors for box fill patterns.
    BOX FILL GAP        = Sets the spacings for box hatch patterns.
    BOX FILL LINE       = Sets the line types for box hatch patterns.
    BOX FILL PATTERN    = Sets the fill patterns for boxes.
    BOX FILL THICKNESS  = Sets the line thicknesses for box hatch
                          patterns.
    BAR PATTERN SPACING = Sets the line spacings for bar fill patterns.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    92/8
 
Program:
    BOX 1 FILL PATTERN D1D2
    BOX 1 FILL GAP 1
    BOX 10 10 40 40
    BOX 1 FILL GAP 5
    BOX 60 60 90 90
 
-----BOX FILL LINE---------------------------------------------------
 
BOX FILL LINE
 
Name:
    BOX ... FILL LINE
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the line style when generating a pattern fill of a box to
    appear on subsequent plots (as specified via the BOX ...
    COORDINATES command) or boxes generated by the BOX command.  Up to
    100 boxes can be specified with the BOX ... COORDINATES command.
 
Description:
    This command only applies when filling the interior with a
    non-solid pattern (e.g., horizontal or vertical).  It is ignored
    for solid fills.  Also, the BAR FILL PATTERN command must be
    entered to specify the type of pattern fill.
 
Syntax:
    BOX  <id>  FILL LINE  <line style>
    where <id> is a box identifier (a number or parameter) in the
               integer range 1 to 100;
    and where <line style> specifies the desired line style (enter HELP
               LINE TYPES for a list of available line types).
 
Examples:
    BOX 2 FILL LINE SOLID
    BOX 2 FILL LINE DASH
 
Note:
    Boxes can be generated in two ways.  You can use the BOX ...
    COORDINATES command to place boxes on subsequent plots or you can
    use the BOX command to draw one box immediately.  The BOX FILL LINE
    command is used to specify the fill line style of the box pattern
    fill in either case.  When the BOX command is used, the fill line
    style is set to the fill line style of the first box (i.e., <id> is
    1).
 
Note:
    A BOX ... FILL LINE command with no arguments sets the line style
    to default; thus BOX 1 FILL LINE with no arguments sets the FILL
    LINE for box 1 to default.  BOX FILL LINE command with no <id>
    refers to all 100 boxes; thus BOX FILL LINE DASH assigns the line
    style dash to all 100 boxes.  Note also that BOX FILL LINE with no
    <id> and no arguments sets the default fill line for all 100 boxes.
 
Default:
    All pattern fills are drawn with solid lines.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    BOX                 = Draws a box (immediately).
    BOX CORNER COORD    = Generate a box on subsequent plots.
    BOX PATTERN         = Sets the line styles for box borders.
    BOX THICKNESS       = Sets the line thicknesses for box borders.
    BOX FILL COLOR      = Sets the colors for box fill patterns.
    BOX FILL GAP        = Sets the spacings for box hatch patterns.
    BOX FILL PATTERN    = Sets the fill patterns for boxes.
    BOX FILL THICKNESS  = Sets the line thicknesses for box hatch
                          patterns.
    BAR PATTERN LINE    = Sets the line types for bar fill patterns.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    92/8
 
Program:
    BOX 1 FILL PATTERN D1D2
    BOX 1 FILL GAP 5
    BOX 1 FILL LINE DASH
    BOX 10 10 40 40
    BOX 1 FILL LINE DOTTED
    BOX 60 60 90 90
 
-----BOX FILL PATTERN-------------------------------------------------
 
BOX FILL PATTERN
 
Name:
    BOX ... FILL PATTERN
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the pattern type when generating a pattern fill of a box
    to appear on subsequent plots (as specified via the BOX ...
    COORDINATES command) or boxes generated by the BOX command.  Up to
    100 boxes can be specified with the BOX ... COORDINATES command.
 
Description:
    The pattern can be one of the following:
         BLANK - no fill
         EMPTY - no fill
         OFF   - no fill
         SOLID - solid fill
         ON    - solid fill
         HORI  - horizontal lines
         VERT  - vertical lines
         D1    - up diagonals
         D2    - down diagonals
         D1D2  - both up and down diagonals
         VED1  - both vertical lines and up diagonals
         VED2  - both vertical lines and down diagonals
         HOD1  - both horizontal lines and up diagonals
         HOD2  - both horizontal lines and down diagonals
         VEDD  - horizontal lines, vertical lines, and both up and down
                 diagonal lines
    In practice, the first 7 (OFF, ON, HORI, VERT, D1, D2, D1D2) are
    heavily used and the last 5 (VED1, VED2, HOD1, HOD2, VEDD) are
    rarely used.
 
Syntax:
    BOX  <id>  FILL PATTERN  <pattern>
    where <id> is a box identifier (a number or parameter) in the
               integer range 1 to 100;
    and where <pattern> specifies the desired fill pattern.
 
Examples:
    BOX 2 FILL PATTERN SOLID
    BOX 2 FILL PATTERN HORIZONTAL
    BOX 2 FILL PATTERN VERTICAL
    BOX 2 FILL PATTERN D1
    BOX 2 FILL PATTERN D2
    BOX 2 FILL PATTERN D1D2
    BOX 2 FILL PATTERN BLANK
 
Note:
    Boxes can be generated in two ways.  You can use the BOX ...
    COORDINATES command to place boxes on subsequent plots or you can
    use the BOX command to draw one box immediately.  The BOX FILL
    PATTERN command is used to specify the fill pattern of the box in
    either case.  When the BOX command is used, the fill pattern is set
    to the fill pattern of the first box (i.e., <id> is 1).
 
Note:
    A BOX ... FILL PATTERN command with no arguments sets the pattern
    to default; thus BOX 1 FILL PATTERN with no arguments sets the fill
    pattern for box 1 to default.  BOX FILL PATTERN command with no
    <id> refers to all 100 boxes; thus BOX FILL PATTERN VERT sets the
    fill pattern to vertical for all 100 boxes.  Note also that BOX
    FILL PATTERN with no <id> and no arguments sets the default fill
    pattern for all 100 boxes.
 
Default:
    All box pattern fills are blank.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    BOX                 = Draws a box (immediately).
    BOX CORNER COORD    = Generate a box on subsequent plots.
    BOX PATTERN         = Sets the line styles for box borders.
    BOX THICKNESS       = Sets the line thicknesses for box borders.
    BOX FILL COLOR      = Sets the colors for box fill patterns.
    BOX FILL GAP        = Sets the spacings for box hatch patterns.
    BOX FILL LINE       = Sets the line types for box hatch patterns.
    BOX FILL THICKNESS  = Sets the line thicknesses for box hatch
                          patterns.
    BAR FILL PATTERN    = Sets the fill pattern for plot bars.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    92/8
 
Program:
    BOX 1 FILL PATTERN D1D2
    BOX 1 FILL GAP 5
    BOX 10 10 40 40
    BOX 1 FILL PATTERN VERT
    BOX 60 60 90 90
 
-----BOX FILL THICKNESS-----------------------------------------------
 
BOX FILL THICKNESS
 
Name:
    BOX ... FILL THICKNESS
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the thickness (i.e., line width)  when generating a
    pattern fill of a box to appear on subsequent plots (as specified
    via the BOX ...  COORDINATES command) or boxes generated by the BOX
    command.  Up to 100 boxes can be specified with the BOX ...
    COORDINATES command.
 
Description:
    This command only applies when filling the interior with a
    non-solid pattern (e.g., horizontal or vertical).  It is ignored
    for solid fills.  Also, the BAR FILL PATTERN command must be
    entered to specify the type of pattern fill.
 
Syntax:
    BOX  <id>  FILL THICKNESS  <thickness>
    where <id> is a box identifier (a number or parameter) in the
               integer range 1 to 100;
    and where <thickness> specifies the desired line width (a decimal
               number or parameter  between 0.0 and 100.0).  The
               thickness is normally set to a value between .05 and .3.
 
Examples:
    BOX 2 FILL THICKNESS 0.1
    BOX 2 FILL THICKNESS 0.3
    BOX 2 FILL THICKNESS 0.2
 
Note:
    Boxes can be generated in two ways.  You can use the BOX ...
    COORDINATES command to place boxes on subsequent plots or you can
    use the BOX command to draw one box immediately.  The BOX FILL
    THICKNESS command is used to specify the fill thickness of the box
    pattern fill in either case.  When the BOX command is used, the
    fill gap is set to the fill thickness of the first box (i.e., <id>
    is 1).
 
Note:
    A BOX ... FILL THICKNESS command with no arguments sets the
    THICKNESS to default; thus BOX 1 FILL THICKNESS with no arguments
    sets the fill THICKNESS for box 1 to default.  BOX FILL THICKNESS
    command with no <id> refers to all 100 boxes; thus BOX FILL
    THICKNESS 0.2 sets the thickness to 0.2 for all 100 boxes.  Note
    also that BOX FILL THICKNESS with no <id> and no arguments sets
    the default fill thickness for all 100 boxes.
 
Default:
    All line thicknesses for box hatch fills are set to 0.1.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    BOX                 = Draws a box (immediately).
    BOX CORNER COORD    = Generate a box on subsequent plots.
    BOX PATTERN         = Sets the line styles for box borders.
    BOX THICKNESS       = Sets the line thicknesses for box borders.
    BOX FILL COLOR      = Sets the colors for box fill patterns.
    BOX FILL GAP        = Sets the spacings for box hatch patterns.
    BOX FILL LINE       = Sets the line types for box hatch patterns.
    BOX FILL PATTERN    = Sets the fill patterns for boxes.
    BOX FILL THICKNESS  = Sets the line thicknesses for box hatch
                          patterns.
    BAR PATTERN THICK   = Sets the line thicknesses for plot bar fills.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    92/8
 
Program:
    BOX 1 FILL THICKNESS 0.3
    BOX 1 FILL GAP 5
    BOX 1 FILL PATTERN VERT
    BOX 10 10 40 40
    BOX 1 FILL THICKNESS 0.5
    BOX 60 60 90 90
 
-----BOX PATTERN-------------------------------------------------------
 
BOX PATTERN
 
Name:
    BOX ... PATTERN
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the line type for the frame of a box to appear on
    subsequent plots (as specified via the BOX ... COORDINATES command)
    or boxes generated by the BOX command.  Up to 100 boxes can be
    specified with the BOX ... COORDINATES command.
 
Syntax:
    BOX   <id>   PATTERN   <pattern>
    where <id> is a box identifier (a number or parameter) in the
               integer range 1 to 100;
    and <pattern> specifies the desired line style (enter HELP LINE
               TYPES for a list of available line styles).
 
Examples:
    BOX 2 PATTERN SOLID
    BOX 2 PATTERN DASH
 
Note:
    Boxes can be generated in two ways.  You can use the BOX ...
    COORDINATES command to place boxes on subsequent plots or you can
    use the BOX command to draw one box immediately.  The BOX PATTERN
    command is used to specify the line style of the box border in
    either case.  When the BOX command is used, the box border line
    style is set to the line style of the first box (i.e., <id> is 1).
 
Note:
    A BOX ... PATTERN command with no arguments sets the box
    pattern to default; thus BOX 1 PATTERN with no arguments
    sets the pattern for box 1 to default.  A BOX ... PATTERN
    command with no <id> will refer to all 100 boxes; thus
    BOX PATTERN DASH sets the pattern dash for all 100 boxes.
    Note also that BOX PATTERN with no <id> and no arguments
    sets the pattern to default for all 100 boxes.  This command
    sets the line type for the frame of the box.  Use the
    command BOX FILL LINE to set the line type of the interior
    region fill of the box.
 
Default:
    All box borders are drawn with solid lines.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    BOX                 = Draws a box (immediately).
    BOX CORNER COORD    = Generate a box on subsequent plots.
    BOX THICKNESS       = Sets the line thicknesses for box borders.
    BOX FILL COLOR      = Sets the colors for box fill patterns.
    BOX FILL GAP        = Sets the spacings for box hatch patterns.
    BOX FILL LINE       = Sets the line types for box hatch patterns.
    BOX FILL PATTERN    = Sets the fill patterns for boxes.
    BOX FILL THICKNESS  = Sets the line thicknesses for box hatch
                          patterns.
    BAR BORDER LINE     = Sets the line styles for plot bar borders.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    89/2
 
Program:
    BOX 1 PATTERN DASH
    BOX 10 10 40 40
    BOX 1 PATTERN DOTTED
    BOX 60 60 90 90
 
-----BOX SHADOW HW---------------------------------------------------
 
BOX SHADOW HW
 
Name:
    BOX ... SHADOW HW
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the shadow for a box to appear on subsequent plots (as
    specified via the BOX ... COORDINATES command) or boxes generated
    by the BOX command.  Up to 100 boxes can be specified with the BOX
    ... COORDINATES command.
 
Description:
    The shadow is a small solid region drawn to the right and the
    bottom of a box to give it a 3-d effect.
 
Syntax 1:
    BOX  <id>  SHADOW HW  <height> <width>
    where <id> is a box identifier (a number or parameter) in the
               integer range 1 to 100;
          <height> is a number or parameter in the decimal range 0 to
               100 that specifies the size of the region below the box;
    and   <width> is a number or parameter in the decimal range 0 to
               100 that specifies the size of the region to the right
               of the box.
 
Syntax 2:
    BOX  <id>  SHADOW HEIGHT  <height>
    where <id> is a box identifier (a number or parameter) in the
               integer range 1 to 100;
    and   <height> is a number or parameter in the decimal range 0 to
               100 that specifies the size of the region below the box.
 
Syntax 3:
    BOX  <id>  SHADOW WIDTH  <width>
    where <id> is a box identifier (a number or parameter) in the
               integer range 1 to 100;
    and   <width> is a number or parameter in the decimal range 0 to
               100 that specifies the size of the region to the right
               of the box.
 
Examples:
    BOX 2 SHADOW HW 0.8 0.6
    BOX 2 SHADOW HW 0 0
    BOX 2 SHADOW HEIGHT 0.8
    BOX 2 SHADOW WIDTH 0.6
 
Note:
    To suppress the shadow, enter the height and width as zero.
 
Note:
    Boxes can be generated in two ways.  You can use the BOX ...
    COORDINATES command to place boxes on subsequent plots or you can
    use the BOX command to draw one box immediately.  The BOX SHADOW
    command is used to specify the shadow of the box in either case.
    When the BOX command is used, the shadow is set to the shadow of
    the first box (i.e., <id> is 1).
 
Note:
    A BOX ... SHADOW HW command with no arguments sets the shadow to
    default; thus BOX 1 SHADOW HW with no arguments sets the SHADOW HW
    for box 1 to default.  BOX SHADOW HW command with no <id> refers to
    all 100 boxes; thus BOX SHADOW HW 0.8 0.6 sets the height to 0.8
    and the width to 0.6 for all 100 boxes.  Note also that BOX SHADOW
    HW with no <id> and no arguments sets the default SHADOW HW for all
    100 boxes.  Set the height and width to 0 turn it off.  The shadow
    is drawn in the same color as the box frame (BOX COLOR command).
 
Default:
    The box shadow height is 0.8 and the box shadow width is 0.6.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    BOX                 = Draws a box (immediately).
    BOX CORNER COORD    = Generate a box on subsequent plots.
    BOX PATTERN         = Sets the line styles for box borders.
    BOX THICKNESS       = Sets the line thicknesses for box borders.
    BOX FILL COLOR      = Sets the colors for box fill patterns.
    BOX FILL GAP        = Sets the spacings for box hatch patterns.
    BOX FILL LINE       = Sets the line types for box hatch patterns.
    BOX FILL PATTERN    = Sets the fill patterns for boxes.
    BOX FILL THICKNESS  = Sets the line thicknesses for box hatch
                          patterns.
    BAR DIMENSION       = Sets plot bars to 2d or 3d.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    XX
 
Program:
    BOX 1 SHADOW HW 0 0
    BOX 10 10 40 40
    BOX 1 SHADOW HW 0.8 0.6
    BOX 60 60 90 90
 
-----BOX THICKNESS-----------------------------------------------------
 
BOX THICKNESS
 
Name:
    BOX ... THICKNESS
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the thickness for the frame of a box to appear on
    subsequent plots (as specified via the BOX ... COORDINATES command)
    or boxes generated by the BOX command.  Up to 100 boxes can be
    specified with the BOX ... COORDINATES command.
 
Syntax:
    BOX   <id>   THICKNESS   <thickness>
    where <id> is a box identifier (a number or parameter) in the
               integer range 1 to 100;
    and   <thickness> is a decimal number or parameter in the range 0.0
               to 100.0 (typically between 0.05 and 0.3) that specifies
               the desired line thickness.
 
Examples:
    BOX 2 THICKNESS 0.1
    BOX 2 THICKNESS 0.2
 
Note:
    Boxes can be generated in two ways.  You can use the BOX ...
    COORDINATES command to place boxes on subsequent plots or you can
    use the BOX command to draw one box immediately.  The BOX THICKNESS
    command is used to specify the thickness of the box border in
    either case.  When the BOX command is used, the box border
    thickness is set to the thickness of the first box (i.e., <id> is
    1).
 
Note:
    A BOX ... THICKNESS command with no arguments sets the box
    thickness to default; thus BOX 1 THICKNESS with no arguments sets
    the thickness for box 1 to default.  A BOX ... THICKNESS command
    with no <id> refers to all 100 boxes; thus BOX THICKNESS 0.2 sets
    the thickness 0.2 for all 100 boxes.  Note also that BOX THICKNESS
    with no <id> and no arguments sets the thickness to default for all
    100 boxes.  This command sets the thickness of the frame of the
    box.  Use the command BOX FILL GAP to set the thickness of the
    lines used to draw the interior of the box.
 
Default:
    All box borders are drawn with a line thickness of 0.1.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    BOX                 = Draws a box (immediately).
    BOX CORNER COORD    = Generate a box on subsequent plots.
    BOX PATTERN         = Sets the line styles for box borders.
    BOX FILL COLOR      = Sets the colors for box fill patterns.
    BOX FILL GAP        = Sets the spacings for box hatch patterns.
    BOX FILL LINE       = Sets the line types for box hatch patterns.
    BOX FILL PATTERN    = Sets the fill patterns for boxes.
    BOX FILL THICKNESS  = Sets the line thicknesses for box hatch
                          patterns.
    BAR BORDER THICK    = Sets the line thicknesses for plot bar
                          borders.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    XX
 
Program:
    BOX 1 THICKNESS 0.3
    BOX 10 10 40 40
    BOX 1 THICKNESS 0.5
    BOX 60 60 90 90
 
-----BOX PLOT-------------------------------------------------------
 
BOX PLOT
 
Name:
    BOX PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a box plot.
 
Description:
    A box plot is a graphical data analysis technique for determining
    if differences exist between the various levels of a 1-factor
    model.  It is a graphical alternative to 1-factor ANOVA.  It
    consist of:

       Vertical   axis = response variable;
       Horizontal axis = level identification.

    The bottom x is the data minimum; the bottom of the box is the
    estimated 25% point; the middle x in the box is the data median;
    the top of the box is the estimated 75% point; the top x is the
    data maximum.  The box plot has 24 components (characters and
    lines) which may be individually controlled.  For the box plot to
    appear as it should, the BOX PLOT command is usually preceded by 2
    commands--

       CHARACTERS BOX PLOT
       LINES BOX PLOT

    which will automatically define proper values for the 24 components
    of the box plot.  After the box plot is formed, the analyst should
    redefine plot characters and lines via the usual CHARACTERS and
    LINES commands.
 
Syntax 1:
    BOX PLOT   <y>         <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response (= dependent) variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax generates a single box.  Note that <y> can also
    be a matrix argument.  If <y> is a matrix, a single box is
    drawn for all the values in the matrix.

Syntax 2:
    BOX PLOT   <y>   <x>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response (= dependent) variable;
          <x> is an independent variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 3:
    MULTIPLE BOX PLOT  <y1> ... <yk>   <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of response (= dependent) variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    Note that response variables can also be matrices.  If a matrix
    name is encountered, a box will be drawn for all the values in
    the matrix.

Syntax 4:
    REPLICATED BOX PLOT  <y>  <x1> ... <xk>
                         <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response (= dependent) variable;
          <x1> ... <xk> is a list of 1 to 6 group-id variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    The group-id variables are cross-tabulated and a box is drawn
    for each distinct combination of values for the group-id
    variables.  These are sometimes referred to as nested box plots.
 
    For the REPLICATED case, you can control the spacing between
    groups.  Internally, Dataplot uses the CODE CROSS TABULATE
    command to generate a single combined group-id variable.  Enter
    HELP CODE CROSS TABULATE for details on how to control the
    spacing (the SET commands used by CODE CROSS TABULATE are
    supported for the BOX PLOT command).

Examples:
    BOX PLOT Y X
    BOX PLOT Y X1
    MULTIPLE BOX PLOT Y1 TO Y10
    REPLICATED BOX PLOT Y X1 TO X4
 
Note:
    Outliers can be identified by entering the FENCES ON command.  If
    the inter-quartile range (i.e., the difference between the 25%
    point and the 75% point) is IQ, then values that are between 1.5
    and 3.0 times the IQ above (or below) the 75% point (or the 25%)
    point are drawn as circles and points that are more than 3.0 times
    the IQ above (or below) the 75% point (or the 25%) are drawn as
    large circles.
 
Note:
    The width of the box is proportional to the number of data
    points in that box.

    If you want to generate fixed width box plots, enter the command

        SET BOX PLOT WIDTH FIXED

    To restore variable width box plots, enter the command
 
        SET BOX PLOT WIDTH VARIABLE

Note:
    An alternate form of the box plot can be generated by entering the
    commands CHARACTERS TUFTE BOX PLOT and LINES TUFTE BOX PLOT.  You
    can also define your own plot symbols with the standard CHARACTER
    and LINE commands (e.g., you may prefer to use a dash (-) rather
    than the default X.
 
Note:
    The TO syntax is supported for the BOX PLOT command.  It is
    most useful for the MULTIPLE and REPLICATED versions of the
    commands.

Note:
    If you use MEAN BOX PLOT rather than BOX PLOT, Dataplot will
    generate the plot based on the mean and standard deviations
    rather than the median and lower and upper hinges.

Note:
    The commands LINES BOX PLOT and CHARACTER BOX PLOT actually
    define 24 components:

        1 - character at maximum point (if FENCES OFF)
          - character at upper adjacent point (if FENCES ON)
        2 - character at top of the box (upper hinge)
        3 - character in the box but towards the top of the box
            (such as upper confidence level for mean, if any)
        4 - define the character for the median (or mean)
        5 - character in the box but towards the bottom of the box
            (such as lower confidence level for mean, if any)
        6 - character at bottom of the box (lower hinge)
        7 - character at minimum point (if FENCES OFF)
          - character at lower adjacent point (if FENCES ON)
        8 - vertical line from maximum value to the top of the
            box (if FENCES (OFF)
          - vertical line from upper adjacent value to the top of the
            box (if FENCES (ON)
        9 - vertical line from the top of the box to the point in the
            box towards the top of the box (such as upper confidence
            level for mean, if any)
       10 - vertical line from the point in the box toward the top
            (such as the upper confidence limit point) to the median
            (or mean)
       11 - vertical line from the median (or mean) to the point in
            the box toward the bottom (such as the lower confidence
            limit point)
       12 - vertical line from the point in the box toward the bottom
            (such as the lower confidence limit point) to the bottom
            of the box
       13 - vertical line from minimum value to the bottom of the
            box (if FENCES (OFF)
          - vertical line from lower adjacent value to the bottom of the
            box (if FENCES (ON)
       14 - vertical line constituting the left side of the box
       15 - vertical line constituting the right side of the box
       16 - horizontal line at the top of the box
       17 - horizontal line at the bottom of the box
       18 - horizontal line running through the median (or mean)
       19 - horizontal line running through the lower confidence limit
       20 - horizontal line running through the upper confidence limit
       21 - characters for the upper far out values
       22 - characters for the upper near out values
       23 - characters for the lower near out values
       24 - characters for the lower far out values

Note:
    The 2016/06 version of Dataplot no longer treats a single point
    for the response variable or all values in the response variable
    as being an error.  Box plots are not typically drawn for a small
    number of points.  However, when automating the analysis for a
    large data set, it can be more desirable to have these cases
    treated as degenerate cases rather than as errors.

Note:
    To have a horizontal bars drawn at the 1%, 5%, 10%, 90%, 95%, and
    99% points of the distribution, enter

        SET BOX PLOT EXTREME PERCENTILES ON

    This option may be useful for large data sets.

    If the FENCES switch is OFF, then the CHARACTER and LINE settings for
    traces 21 through 26 will be used to draw these percentiles.  If the
    FENCES switch is ON, then the CHARACTER and LINE settings for traces
    25 through 30 will be used to draw these percentiles.  Currently, the
    LINES BOX PLOT and CHARACTER BOX PLOT commands do not set these.  You
    can use something like the following to set these switches.

        LET INDX = DATA 21 22 23 24 25 26
        LET PLOT CHARACTER INDX = BLANK
        LET PLOT LINE      INDX = SOLID

Note:
    If you use the MULTIPLE syntax as in the following example

        MULTIPLE BOX PLOT Y1 Y2 Y3 Y4 Y5

    Dataplot will internally create a stacked Y X set of data.  This means
    that Dataplot's limit on the maximum number of rows applies to the
    combined number of rows in the response variables.  Dataplot was
    modified so that if there are four or fewer response variables, then
    Dataplot will not stack the data to generate the box plot.  Although
    this has no effect on the appearance of the plot, it can be useful
    when generating box plots for large data sets in that it may avoid
    exceeding Dataplot's limit on the maximum number of rows.

Note:
    The FENCES ON command is used to help identify outliers.  One criticism
    of the box plot is that the method used identifies too many potential
    outliers for skewed data.

    Walker proposed the following alternative for the fences

        f(L) = q1 - 1.5*IQR*(SIQR(L)/SIQR(U))
        f(U) = q3 + 1.5*IQR*(SIQR(U)/SIQR(L))

    where

        q1      = the lower quartile
        q3      = the upper quartile
        IQR     = the interquartile range
                = q3 - q1
        SIQR(L) = the lower semi-interquartile range
                = q2 - q1
        SIQR(U) = the upper semi-interquartile range
                = q3 - q2
        q2 = the median

    This formulation is based on the Galton (or Bowley) formula for
    skewness

        B(c) = (q2 + q1 - 2*q2)/(q3 - q1)
             = (SIQR(U) - SIQR(L))/IQR
             = (SIQR(U) - SIQR(L))/(SIQR(U) + SIQR(L))

    For a more complete explanation of this method, see the Walker
    paper.

    Kimber had earlier proposed

        f(L) = q1 - 1.5*(2*(q2 - q1))
        f(U) = q3 + 1.5*(2*(q3 - q2))

    For skewed data, the Kimber method tends to be intermediate between
    the default method and the Walker method in the number of potential
    outliers it identifies.  For symmetric data, the Kimber and Walker
    methods are essentially equivalent to the default method.  However,
    for skewed data, the Kimber and Walker methods will identify fewer
    potential outliers than the default method.

    The above formulas are for the "inner fences" boundary.  For the
    "outer fences" boundary, replace 1.5 with 3.0.

    To use the Walker method, enter the command

        SET BOXPLOT FENCE SKEWNESS WALKER

    To use the Kimber method, enter the command

        SET BOXPLOT FENCE SKEWNESS KIMBER

    To reset the default method, enter

        SET BOXPLOT FENCE SKEWNESS OFF

    Note that using the Walker or Kimber methods is recommended when
    you are specifically interested in identifying outliers.  For
    exploratory purposes, it may be preferrable to use the default
    method (i.e., showing the skewness may be desirable).

Default:
    None
 
Synonyms:
    The word REPLICATED is optional in the REPLICATED BOX PLOT syntax.
    SET BOXPLOT FENCE SKEWNESS OFF and SET BOXPLOT FENCE SKEWNESS BOWLEY
    are synonyms for SET BOXPLOT FENCE SKEWNESS WALKER.
 
Related Commands:
    CHARACTERS    = Sets the types for plot characters.
    LINES         = Sets the types for plot lines.
    I PLOT        = Generates an I plot.
    ANOVA         = Carries out an ANOVA.
    MEDIAN POLISH = Carries out a median polish.
    CONTROL CHART = Generates a control chart.
    PLOT          = Generates a data or function plot.
 
References:
    Tukey (1977), "Exploratory Data Analysis", Addison-Wesley.

    Walker, Dovedo, Chakraborti and Hilton (2019), "An Improved Boxplot
    for Univariate Data". American Statistician, Vol. 72, No. 4,
    pp. 348-353.

    Kimber (1990), "Exploratory Data Analysis for Possibly Censored
    Data from Skewed Distribution", Applied Statistics, Vol. 39,
    pp. 21-30.

Applications:
    Exploratory Data Analysis, Comparing Distributions
 
Implementation Date:
    Pre-1987
    2002/03: Support for fixed width box plot
    2010/06: Support for TO syntax and matrix arguments
    2010/06: Support for MULTIPLE and REPLICATED options
    2016/06: Sample size of one or all response values having
             the same value no longer treated as an error
    2016/06: Support for the SET BOX PLOT EXTREME PERCENTILES
    2016/06: For MULTIPLE option, four or fewer response variables
             not stacked internally
    2019/08: Support for the SET BOXPLOT FENCE SKEWNESS command
 
Program 1:
    LET X = SEQUENCE 0 1 999
    LET X = X/100
    LET X = INT(X)+1
    LET Z = NORMAL RANDOM NUMBERS FOR I = 1 1 1000
    CHARACTERS BOX PLOT
    LINES BOX PLOT
    FENCES ON
    BOX PLOT Z X
 
Program 2:
    title offset 2
    title automatic
    xlimits 1 10
    xtic mark offset 1 1
    major xtic mark number 10
    ylimits 0.97 1.02
    .
    char box plot
    line box plot
    fences on
    .
    box plot y x
    .
    ylimits
    reset data
    skip 25
    read sheesley.dat y x1 to x5
    let x1d = distinct x1
    let x2d = distinct x2
    .
    SET CODE CROSS TABULATE GROUP SIZE ONE 5
    xlimits 0 8
    xtic mark offset 0 1
    major xtic mark number 9
    x1tic mark label format alpha
    x1tic mark label content Shift 1 2cr()Weldingsp()Process=1 3 sp() sp() ...
          1 2cr()Weldingsp()Process=2 3
    box plot y x1 x2
    .
    SET CODE CROSS TABULATE GROUP SIZE ONE 5
    SET CODE CROSS TABULATE GROUP SIZE TWO 3
    xlimits 0 26
    xtic mark offset 1 0
    major xtic mark number 27
    set string space ignore
    let string s1 = 1cr()1
    let string s2 = 2
    let string s3 = sp()
    let string s4 = 1cr()2
    let string s5 = 2cr()sp()cr()Weldingsp()Process=1
    let string s6 = sp()
    let string s7 = 1cr()3
    let string s8 = 2
    let string s9 = sp()
    let string s10 = sp()
    let string s11 = sp()
    let string s12 = sp()
    let string s13 = sp()
    let string s14 = sp()
    let string s15 = sp()
    let string s16 = sp()
    let string s17 = 1cr()1
    let string s18 = 2
    let string s19 = sp()
    let string s20 = 1cr()2
    let string s21 = 2cr()sp()cr()Weldingsp()Process=2
    let string s22 = sp()
    let string s23 = 1cr()3
    let string s24 = 2
    let string s25 = sp()
    let string s26 = sp()
    let string s27 = Machinecr()Shift
    let igx = group label s1 to s27
    .
    x1tic mark label format group label
    x1tic mark label content igx
    box plot y x1 x2 x3
    .
    reset data
    skip 25
    read iris.dat y1 y2 y3 y4 species
    let m = create matrix y1 y2 y3 y4
    .
    xlimits 1 4
    xtic mark offset 1 1
    major xtic mark number 4
    x1tic mark label format alpha
    x1tic mark label content Sepalcr()Length Sepalcr()Width ...
          Petalcr()Length Petalcr()Width
    multiple box plot m1 m2 m3 m4
    .
    reset data
    let y1 = norm rand numb for i = 1 1 1000
    let y2 = logistic rand numb for i = 1 1 1000
    let y3 = double exponential rand numb for i = 1 1 1000
    let y4 = slash rand numb for i = 1 1 1000
    .
    xlimits 1 4
    xtic mark offset 1 1
    major xtic mark number 4
    x1tic mark label format alpha
    x1tic mark label content Normal Logistic Laplace Slash
          Petalcr()Length Petalcr()Width
    set box plot extreme percentiles on
    .
    .  Reset character/line settings above 20
    .
    fences off
    loop for k = 21 1 26
        let plot character ^k = blank
        let plot line      ^k = solid
    end of loop
    .
    multiple box plot y1 y2 y3
 
Program 3:
    . Step 1:   Create data (skewed)
    .
    let nu = 1
    let y = chisquare random numbers for i = 1 1 100
    .
    . Step 2:   Define plot control
    .
    character box plot
    line box plot
    fences on
    title case asis
    x1tic marks off
    x1tic mark labels off
    tic mark offset units screen
    y1tic mark offset 3 3
    .
    . Step 3:   Generate the box plots
    .
    multiplot 1 3
    multiplot scale factor 1 3
    title Default Box Plot
    box plot y
    set box plot fence skewness galton
    title Fences Based oncr()Semi-Interquartile Ranges
    box plot y
    set box plot fence skewness kimber
    title Fences Based oncr()Kimber Method
    box plot y
    .
    end of multiplot

-----BRACDF (LET)--------------------------------
 
BRACDF
 
Name:
    BRACDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Bradford cumulative distribution function.
 
Description:
    The probability density function is:
       f(x.beta) = [beta/LOG(1+beta)]*(1/(1+beta*x))   for 0< x < 1
                                                       for beta > -1
    where beta is the shape parameter.
 
    The cumulative distribution function is:
       F(x,beta) = LOG(1+beta*x)/LOG(1+beta)  for 0 < x < 1, beta > -1

Syntax:
    LET <y> = BRACDF(<x>,<beta>)   <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed Bradford cdf value is saved;
          <beta> is a number, parameter, or variable that specifies
               the shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BRACDF(0.5,1.5)
    LET X2 = BRACDF(X1,BETA)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BRAPDF = Compute the Bradford probability density function.
    BRAPPF = Compute the Bradford percent point function.
    WARCDF = Compute the Waring cumulative distribution function.
    WARPDF = Compute the Waring probability density function.
    WARPPF = Compute the Waring percent point function.
    PARCDF = Compute the Pareto cumulative distribution function.
    PARPDF = Compute the Pareto probability density function.
    PARPPF = Compute the Pareto percent point function.
    BETCDF = Compute the beta cumulative distribution function.
    BETPDF = Compute the beta probability density function.
    BETPPF = Compute the beta percent point function.
 
Reference:
    "Continuous Univariate Distributions--Vol. 2", 2nd. Ed., Johnson,
    Kotz, and Balakrishnan, John Wiley and Sons, 1994 (page 347).
 
Applications:
    Approximation to the Zipf or Yule discrete distributions
 
Implementation Date:
    96/2
 
Program:
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LET B = -0.5
    X1LABEL  BETA = ^B
    PLOT BRACDF(X,B) FOR X = 0.01 0.01 0.99
    LET B = 0.5
    X1LABEL  BETA = ^B
    PLOT BRACDF(X,B) FOR X = 0.01 0.01 0.99
    LET B = 1.0
    X1LABEL  BETA = ^B
    PLOT BRACDF(X,B) FOR X = 0.01 0.01 0.99
    LET B = 2.0
    X1LABEL  BETA = ^B
    PLOT BRACDF(X,B) FOR X = 0.01 0.01 0.99
    END OF MULTIPLOT
 
-----BRAPDF (LET)--------------------------------
 
BRAPDF
 
Name:
    BRAPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Bradford probability density function.
 
Description:
    The probability density function is:
       f(x.beta) = [beta/LOG(1+beta)]*(1/(1+beta*x))   for 0< x < 1
                                                       for beta > -1
    where beta is the shape parameter.
 
Syntax:
    LET <y> = BRAPDF(<x>,<beta>)   <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, a number, or a parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed Bradford pdf value is saved;
          <beta> is a number, parameter, or variable that specifies
               the shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BRAPDF(0.5,1.5)
    LET X2 = BRAPDF(X1,BETA)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BRACDF = Compute the Bradford cumulative distribution function.
    BRAPPF = Compute the Bradford percent point function.
    WARCDF = Compute the Waring cumulative distribution function.
    WARPDF = Compute the Waring probability density function.
    WARPPF = Compute the Waring percent point function.
    PARCDF = Compute the Pareto cumulative distribution function.
    PARPDF = Compute the Pareto probability density function.
    PARPPF = Compute the Pareto percent point function.
    BETCDF = Compute the beta cumulative distribution function.
    BETPDF = Compute the beta probability density function.
    BETPPF = Compute the beta percent point function.
 
Reference:
    "Continuous Univariate Distributions--Vol. 2", 2nd. Ed., Johnson,
    Kotz, and Balakrishnan, John Wiley and Sons, 1994 (page 347).
 
Applications:
    Approximation to the Zipf or Yule discrete distributions
 
Implementation Date:
    96/2
 
Program:
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LET B = -0.5
    X1LABEL  BETA = ^B
    PLOT BRAPDF(X,B) FOR X = 0.01 0.01 0.99
    LET B = 0.5
    X1LABEL  BETA = ^B
    PLOT BRAPDF(X,B) FOR X = 0.01 0.01 0.99
    LET B = 1.0
    X1LABEL  BETA = ^B
    PLOT BRAPDF(X,B) FOR X = 0.01 0.01 0.99
    LET B = 2.0
    X1LABEL  BETA = ^B
    PLOT BRAPDF(X,B) FOR X = 0.01 0.01 0.99
    END OF MULTIPLOT
 
-----BRAPPF (LET)--------------------------------
 
BRAPPF
 
Name:
    BRAPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Bradford percent point function.
 
Description:
    The Bradford probability density function is:
       f(x.beta) = [beta/LOG(1+beta)]*(1/(1+beta*x))   for 0< x < 1
                                                       for beta > -1
    where beta is the shape parameter.
 
    The percent point function is the inverse of the cumulative
    distribution function.  The cumulative distribution sums the
    probability from 0 to the given x value (i.e., the integral of the
    above function).  The percent point function takes a cumulative
    probability value and computes the corresponding x value.  It has
    the following formula:
       G(p,beta) = (1/beta)*(EXP(LOG(1+beta)*p)-1) 0<p<1, beta>-1
 
    The input value is a real number between 0 and 1 (since it
    corresponds to a probability).
 
Syntax:
    LET <y> = BRAPPF(<p>,beta)    <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, a number, or a parameter in the range
               0 to 1;
          <y> is a variable or a parameter (depending on what <p> is)
               where the computed Bradford ppf value is stored;
          <beta> is a number, parameter, or variable that specifies
               the shape parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BRAPPF(0.9,0.7)
    LET X2 = BRAPPF(P,BETA)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BRACDF = Compute the Bradford cumulative distribution function.
    BRAPDF = Compute the Bradford probability density function.
    WARCDF = Compute the Waring cumulative distribution function.
    WARPDF = Compute the Waring probability density function.
    WARPPF = Compute the Waring percent point function.
    PARCDF = Compute the Pareto cumulative distribution function.
    PARPDF = Compute the Pareto probability density function.
    PARPPF = Compute the Pareto percent point function.
    BETCDF = Compute the beta cumulative distribution function.
    BETPDF = Compute the beta probability density function.
    BETPPF = Compute the beta percent point function.
 
Reference:
    "Continuous Univariate Distributions--Vol. 2", 2nd. Ed., Johnson,
    Kotz, and Balakrishnan, John Wiley and Sons, 1994 (page 347).
 
Applications:
    Approximation to the Zipf or Yule discrete distributions
 
Implementation Date:
    96/2
 
Program:
    XLIMITS 0 1
    MAJOR XTIC MARK NUMBER 6
    XTIC OFFSET 0.1 0.1
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LET B = -0.5
    X1LABEL BETA = ^B
    PLOT BRAPPF(P,B) FOR P = 0.01 0.01 0.99
    LET B = 0.5
    X1LABEL BETA = ^B
    PLOT BRAPPF(P,B) FOR P = 0.01 0.01 0.99
    LET B = 1.0
    X1LABEL BETA = ^B
    PLOT BRAPPF(P,B) FOR P = 0.01 0.01 0.99
    LET B = 2.0
    X1LABEL BETA = ^B
    PLOT BRAPPF(P,B) FOR P = 0.01 0.01 0.99
    END OF MULTIPLOT
 
-----BREAK LOCATIONS (LET)-------------------------------------
 
BREAK LOCATIONS
FRAGMENT LOCATIONS
FRAGMENT LENGTHS
 
Name:
    BREAK LOCATIONS (LET)
    FRAGMENT LOCATIONS (LET)
    FRAGMENT LENGTHS (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Given a variable that contains the X coordinates of the
    four corners of breaks, compute either the break locations,
    the fragment locations, or the fragment lengths.
 
Description:
    Given a fiber that has been subjected to stress, it is desired
    to identify the break locations.  This command assumes that the
    input variable is a sequence of points where each point contains
    four X coordinates.  These coordinates identify the boundary of
    the breaks.  This command can return one of the following:

       1. break location - the break location is defined to be the
          break centroid, i.e., the average of the four points.

       2. fragment location - given two successive breaks, define the
          lower boundary of the fragment by the average of the right
          corner points of the first break and the upper boundary by
          the average of the left corner points of the second break.
          The fragment location is then the average of the lower
          and upper boundary values.

       3. fragment length - the fragment length is distance between
          the lower boundary and the upper boundary.

    The input variable will be interpreted in sequences of four
    values.  For break locations, the breaks do not have to be
    in a sorted order.  However, for the fragment locations and
    fragment lengths, the points are assumed to be in order (they can
    be in either left to right order or right to left order).  Within
    the sequence of four points for a single break, no particular
    order is required.

Syntax 1:
    LET <y> = BREAK LOCATIONS <x>   <SUBSET/EXCEPT/FOR qualification>
    where <x> is the response variable;
          <y> is a variable where the break locations are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    LET <y> = FRAGMENT LOCATIONS <x>   <SUBSET/EXCEPT/FOR qualification>
    where <x> is the response variable;
          <y> is a variable where the fragment locations are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 3:
    LET <y> = FRAGMENT LEGNTHS <x>   <SUBSET/EXCEPT/FOR qualification>
    where <x> is the response variable;
          <y> is a variable where the fragment legnths are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET BREAKLOC = BREAK LOCATIONS X
    LET FRAGLOC = FRAGMENT LOCATIONS X
    LET FRAGLEN = FRAGMENT LEGNTHS X
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    PROBABILITY PLOT         = Generate a probability plot.
    PPCC PLOT                = Generate a probability plot correlation
                               coefficient plot.
    BEST DISTRIBUTIONAL FIT  = Generate a ranked list of best
                               distributional fit.

Applications:
    Reliability
 
Implementation Date:
    2019/08
 
Program:
    . Step 1:   Read the data
    .
    skip 25
    read BREAKS.DAT marker x y
    .
    . Step 2:   Set some basic plot control
    .
    title offset 2
    title case asis
    case asis
    label cases asis
    character circle
    character hw 1.0 0.75
    character fill on
    line blank
    ylimits 0 30000
    major ytic mark number 4
    minor ytic mark number 1
    xlimits 0 1
    major xtic mark number 6
    minor xtic mark number 1
    .
    . Step 3:   Generate uniform probablity plot of break locations
    .
    let break = break locations x
    let n = size break
    y1label Sorted Data
    x1label Uniform Order Statistic Medians
    title Uniform Probability Plot of Breaks for File BREAK.DAT
    uniform probability plot break
    .
    justification left
    move 17 82
    text N: ^n
    let ppcc = round(ppcc,3)
    move 17 79
    text PPCC: ^ppcc
 
-----BREAK LOOP------------------------------------------------------

BREAK LOOP

Name:
    BREAK LOOP

Type:
    Support Command

Purpose:
    Terminate a sequential loop.

Description:
    A sequential loop is one that has a defined start and stop value
    and a constant increment.  The values for the start, increment, 
    and stop can have real values (i.e., DATAPLOT is not limited to
    integer loops).  DATAPLOT loops can have either a positive or a 
    negative increment.

    Sometimes it is convenient to terminate a loop before the last
    value has been incremented.  For example, a loop may be iterating
    a calculation until some convergence criterion is reached.  The
    BREAK LOOP command is used for this purpose.  In effect, it allows
    the LOOP to function as a DO WHILE type of loop (DATAPLOT does not
    provide any formal DO WHILE or REPEAT UNTIL control structure at
    this time).  The BREAK LOOP command is almost always contained
    within an IF block.

Syntax:
    BREAK LOOP

Examples:
    LOOP FOR ITER = 1 1 MAXITER
           ...
        IF CONV <= 0.0001
          BREAK LOOP
        END OF IF
    END OF LOOP

Default:
    None

Synonyms:
    None

Related commands:
    END OF LOOP    = Normal termination of a loop.
    LOOP           = Execute a sequential loop.
    IF             = Conditionally execute commands.

Applications:
    XX

Implementation Date:
    94/4

Program:
    FEEDBACK OFF
    .  Computes Least Absolute Deviations fit using
    .  using iteratively re-weighted least squares.
    .  The following assumes that a string F has been defined before
    .  calling this macro to define the type of fit.  E.g., 
    .           LET STRING F = FIT Y X
    WEIGHT
    ^F
    LET MAXITER = 10
    LOOP FOR K = 1 1 MAXITER
        LET RESOLD = RES
        LET MED = MEDIAN RES
        LET TEMP = ABS(RES - MED)
        LET MAD = MEDIAN TEMP
        LET S = MAD/0.6745
        LET U = RES/S
        LET TEMP = ABS(RES)
        LET C = MEDIAN TEMP
        LET TAG = ABS(Y - PRED)
        LET WT = C/TAG  SUBSET TAG > C
        LET WT = 1 SUBSET TAG <= C
        WEIGHTS WT
        ^F
        .
        LET DELTA = (RESOLD - RES)**2
        LET NUM = SUM DELTA
        LET NUM = SQRT(NUM)
        LET DELTA2 = RESOLD*RESOLD
        LET DENOM = SUM DELTA2
        LET CONV = NUM/DENOM
        IF CONV <= 0.0001 
          BREAK LOOP
        END OF IF
    END OF LOOP

-----BTACDF (LET)--------------------------------
 
BTACDF
 
Name:
    BTACDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Borel-Tanner cumulative distribution function.
 
Description:
    Given a single queue with random arrival times of customers
    at constant rate l, constant service time beta, and k
    initial customers, the Borel-Tanner distribution is the
    distribution of the total number of customers served 
    before the queue vanishes.

    The probability mass function of the Borel-Tanner
    distribution is

       p(x;lambda,k) = k*EXP(-lambda*x)*(lambda*x)**(x-k)/
                       (x*(x-k)!),   x >= k, 0 < lambda < 1.

    with lambda and k denoting the shape parameters.  The
    k shape parameter is a positive integer and lambda = l*beta.

    The cumulative distribution function is computed by summing
    the probability mass function.

Syntax:
    LET <y> = BTACDF(<x>,<lambda>,<k>)
                         <SUBSET/EXCEPT/FOR qualification>
    where <x> is a positive integer variable, number, or
               parameter;
          <lambda> is a number or parameter in the range (0,1)
               that specifies the first shape parameter;
          <k> is a number or parameter denoting a positive
               integer that specifies the second shape parameter;
          <y> is a variable or a parameter where the computed
               Borel-Tanner cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BTACDF(3,0.5,3)
    LET Y = BTACDF(X1,0.3,2)
    PLOT BTACDF(X,0.3,2) FOR X = 2  1  20
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BTAPDF                   = Compute the Borel-Tanner probability
                               mass function.
    BTAPPF                   = Compute the Borel-Tanner
                               percent point function.
    POIPDF                   = Compute the Poisson probability
                               mass function.
    HERPDF                   = Compute the Hermite probability
                               mass function.
    BINPDF                   = Compute the binomial probability
                               mass function.
    NBPDF                    = Compute the negative binomial
                               mass density function.
    GEOPDF                   = Compute the geometric probability
                               mass function.

Reference:
    Haight and Breuer (1960), "The Borel-Tanner Distribution",
    Biometrika, 47, pp. 143-150.

    Johnson, Kotz, and Kemp (1992),  "Univariate Discrete
    Distributions", Second Edition, Wiley, pp. 394-396.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/5
 
Program:
    title size 3
    tic label size 3
    label size 3
    legend size 3
    height 3
    multiplot scale factor 1.5
    x1label displacement 12
    y1label displacement 17
    .
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    label case asis
    title case asis
    case asis
    tic offset units screen
    tic offset 3 3
    title displacement 2
    y1label Probability
    x1label X
    .
    ylimits 0 1
    major ytic mark number 6
    minor ytic mark number 3
    xlimits 0 20
    line blank
    spike on
    .
    multiplot 2 2
    .
    title Lambda = 0.3
    plot btacdf(x,0.3,1) for x = 1 1 20
    .
    title Lambda = 0.5
    plot btacdf(x,0.5,1) for x = 1 1 20
    .
    title Lambda = 0.7
    plot btacdf(x,0.7,1) for x = 1 1 20
    .
    title Lambda = 0.9
    plot btacdf(x,0.9,1) for x = 1 1 20
    .
    end of multiplot
    .
    justification center
    move 50 97
    text Cumulative Distribution for Borel-Tanner
 
-----BTAPDF (LET)--------------------------------
 
BTAPDF
 
Name:
    BTAPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Borel-Tanner probability density function.
 
Description:
    Given a single queue with random arrival times of customers
    at constant rate l, constant service time beta, and k
    initial customers, the Borel-Tanner distribution is the
    distribution of the total number of customers served 
    before the queue vanishes.

    The probability mass function of the Borel-Tanner
    distribution is

       p(x;lambda,k) = k*EXP(-lambda*x)*(lambda*x)**(x-k)/
                       (x*(x-k)!),   x >= k, 0 < lambda < 1.

    with lambda and k denoting the shape parameters.  The
    k shape parameter is a positive integer and lambda = l*beta.

    The mean and variance of the Borel-Tanner distribution are

        mean     = k/(1-lambda)
        variance = k*lambda/(1-lambda)**3
        
Syntax:
    LET <y> = BTAPDF(<x>,<lambda>,<k>)
                         <SUBSET/EXCEPT/FOR qualification>
    where <x> is a positive integer variable, number, or
               parameter;
          <lambda> is a number or parameter in the range (0,1)
               that specifies the first shape parameter;
          <k> is a number or parameter denoting a positive
               integer that specifies the second shape parameter;
          <y> is a variable or a parameter where the computed
               Borel-Tanner pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BTAPDF(3,0.5,3)
    LET Y = BTAPDF(X1,0.3,2)
    PLOT BTAPDF(X,0.3,2) FOR X = 2  1  20
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Note:
    For a number of commands utilizing the Borel-Tanner
    distribution, it is convenient to bin the data.  There
    are two basic ways of binning the data.

      1) For some commands (histograms, maximum likelihood
         estimation), bins with equal size widths are
         required.  This can be accomplished with the
         following commands:

            LET AMIN = MINIMUM Y
            LET AMAX = MAXIMUM Y
            LET AMIN2 = AMIN - 0.5
            LET AMAX2 = AMAX + 0.5
            CLASS MINIMUM AMIN2
            CLASS MAXIMUM AMAX2
            CLASS WIDTH 1
            LET Y2 X2 = BINNED

      2) For some commands, unequal width bins may be
         helpful.  In particular, for the chi-square goodness
         of fit, it is typically recommended that the minimum
         class frequency be at least 5.  In this case, it may
         be helpful to combine small frequencies in the tails.
         Unequal class width bins can be created with the
         commands

            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = INTEGER FREQUENCY TABLE Y

         If you already have equal width bins data, you can
         use the commands
         
            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = COMBINE FREQUENCY TABLE Y2 X2

         The MINSIZE parameter defines the minimum class
         frequency.  The default value is 5.

Note:
    You can generate Borel-Tanner random numbers and probability
    plots with the following commands:

       LET N = VALUE
       LET K = <value>
       LET LAMBDA = <value>
       LET Y = BOREL-TANNER RANDOM NUMBERS FOR I = 1 1 N

       BOREL TANNER PROBABILITY PLOT Y
       BOREL TANNER PROBABILITY PLOT Y2 X2
       BOREL TANNER PROBABILITY PLOT Y3 XLOW XHIGH

    To obtain the maximum likelihood estimate of lambda
    assuming that k is known, enter the command

        BOREL TANNER MAXIMUM LIKELIHOOD Y
        BOREL TANNER MAXIMUM LIKELIHOOD Y2 X2

    The maximum likelihood estimate is

        lambdahat = (xbar - k)/xbar

    with xbar denoting the mean.

    For a given value of k, generate an estimate of lambda
    based on the maximum ppcc value or the minimum
    chi-square goodness of fit with the commands

        LET K = <value>
        LET LAMBDA1 = <value>
        LET LAMBDA2 = <value>
        BOREL TANNER KS PLOT Y
        BOREL TANNER KS PLOT Y2 X2
        BOREL TANNER KS PLOT Y3 XLOW XHIGH
        BOREL TANNER PPCC PLOT Y
        BOREL TANNER PPCC PLOT Y2 X2
        BOREL TANNER PPCC PLOT Y3 XLOW XHIGH

    The default values of lambda1 and lambda2 are 0.05 and
    0.95, respectively.  The value of k should typically be
    set to the minimum value of the data.  Due to the discrete
    nature of the percent point function for discrete
    distributions, the ppcc plot will not be smooth.  For that
    reason, if there is sufficient sample size the KS PLOT
    (i.e., the minimum chi-square value) is typically preferred.
    Also, since the data is integer values, one of the binned
    forms is preferred for these commands.

    To generate a chi-square goodness of fit test, enter the
    commands

       LET K = <value>
       LET LAMBDA = <value>
       BOREL-TANNER CHI-SQUARE GOODNESS OF FIT Y2 X2
       BOREL-TANNER CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

Note:
    The case where k = 1 is referred to as the Borel
    distribution.  It has probability mass function

       p(x;lambda) = (lambda*x)**(x-1)*EXP(-lambda*x)/x!
                     x = 1, 2, ... ; 0 < lambda < 1

Note:
    If the Borel-Tanner distribution is shifted to start at
    X = 0 and is reparameterized with

       alpha = lambda
       theta = k*lambda

    the resulting distribution is referred to as the
    Lagrange-Poisson distribution (or the Consul generalized
    Poisson distribution).  This distribution has probability
    mass function

       p(x;alpha,theta) = theta*(theta+x*alpha)**(x-1)*
                          EXP(-theta-x*alpha)/x!    x = 0, 1, ...

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BTACDF                   = Compute the Borel-Tanner cumulative
                               distribution function.
    BTAPPF                   = Compute the Borel-Tanner
                               percent point function.
    POIPDF                   = Compute the Poisson probability
                               density function.
    HERPDF                   = Compute the Hermite probability
                               density function.
    BINPDF                   = Compute the binomial probability
                               density function.
    NBPDF                    = Compute the negative binomial
                               probability density function.
    GEOPDF                   = Compute the geometric probability
                               density function.
    INTEGER FREQUENCY TABLE  = Generate a frequency table at
                               integer values with unequal bins.
    COMBINE FREQUENCY TABLE  = Convert an equal width frequency
                               table to an unequal width frequency
                               table.
    KS PLOT                  = Generate a minimum chi-square plot.
    MAXIMUM LIKELIHOOD       = Perform maximum likelihood
                               estimation for a distribution.

Reference:
    Haight and Breuer (1960), "The Borel-Tanner Distribution",
    Biometrika, 47, pp. 143-150.

    Johnson, Kotz, and Kemp (1992),  "Univariate Discrete
    Distributions", Second Edition, Wiley, pp. 394-396.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/5
 
Program:
    let k = 2
    let lambda = 0.8
    let y = borel tanner random numbers for i = 1 1 500
    .
    let y3 xlow xhigh = integer frequency table y
    class lower 1.5
    class width 1
    let amax = maximum y
    let amax2 = amax + 0.5
    class upper amax2
    let y2 x2 = binned y
    .
    let k = minimum y
    borel tanner mle y
    relative histogram y2 x2
    limits freeze
    pre-erase off
    line color blue
    plot btapdf(x,lambdaml,k) for x = 2 1 amax
    limits
    pre-erase on
    line color black
    let lambda = lambdaml
    borel tanner chi-square goodness of fit y3 xlow xhigh
    case asis
    justification center
    move 50 97
    text Lambda = ^lambdaml
    move 50 93
    text Minimum Chi-Square = ^minks, 95% CV = ^cutupp95
    .
    let k = 2
    label case asis
    x1label Lambda
    y1label Minimum Chi-Square
    let lambda1 = 0.5
    let lambda2 = 0.9
    borel tanner ks plot y3 xlow xhigh
    let lambda = shape
    borel tanner chi-square goodness of fit y3 xlow xhigh
    case asis
    justification center
    move 50 97
    text Lambda = ^lambda
    move 50 93
    text Minimum Chi-Square = ^minks, 95% CV = ^cutupp95
 
-----BTAPPF (LET)--------------------------------
 
BTAPPF
 
Name:
    BTAPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Borel-Tanner percent point function.
 
Description:
    Given a single queue with random arrival times of customers
    at constant rate l, constant service time beta, and k
    initial customers, the Borel-Tanner distribution is the
    distribution of the total number of customers served 
    before the queue vanishes.

    The probability mass function of the Borel-Tanner
    distribution is

       p(x;lambda,k) = k*EXP(-lambda*x)*(lambda*x)**(x-k)/
                       (x*(x-k)!),   x >= k, 0 < lambda < 1.

    with lambda and k denoting the shape parameters.  The
    k shape parameter is a positive integer and lambda = l*beta.

    The cumulative distribution function is computed by summing
    the probability mass function.  The percent point function
    is the inverse of the cumulative distribution function and
    is obtained by computing the cumulative distribution function
    until the specified probability is reached.

Syntax:
    LET <y> = BTAPPF(<p>,<lambda>,<k>)
                         <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, number, or parameter in the
               range (0,1);
          <lambda> is a number or parameter in the range (0,1)
               that specifies the first shape parameter;
          <k> is a number or parameter denoting a positive
               integer that specifies the second shape parameter;
          <y> is a variable or a parameter where the computed
               Borel-Tanner ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BTAPPF(0.95,0.5,3)
    LET Y = BTAPPF(P1,0.3,2)
    PLOT BTAPPF(P,0.4,2) FOR P = 0  0.01 0.99
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BTACDF                   = Compute the Borel-Tanner
                               cumulative distribution function.
    BTAPDF                   = Compute the Borel-Tanner probability
                               mass function.
    POIPDF                   = Compute the Poisson probability
                               mass function.
    HERPDF                   = Compute the Hermite probability
                               mass function.
    BINPDF                   = Compute the binomial probability
                               mass function.
    NBPDF                    = Compute the negative binomial
                               mass density function.
    GEOPDF                   = Compute the geometric probability
                               mass function.

Reference:
    Haight and Breuer (1960), "The Borel-Tanner Distribution",
    Biometrika, 47, pp. 143-150.

    Johnson, Kotz, and Kemp (1992),  "Univariate Discrete
    Distributions", Second Edition, Wiley, pp. 394-396.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/5
 
Program:
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    label case asis
    title case asis
    case asis
    tic offset units screen
    tic offset 3 3
    title displacement 2
    y1label Probability
    x1label X
    .
    xlimits 0 1
    major xtic mark number 6
    minor xtic mark number 3
    line blank
    spike on
    .
    multiplot 2 2
    .
    title Lambda = 0.3
    plot btappf(p,0.3,1) for p = 0  0.01  0.99
    .
    title Lambda = 0.5
    plot btappf(p,0.5,1) for p = 0  0.01  0.99
    .
    title Lambda = 0.7
    plot btappf(p,0.7,1) for p = 0  0.01  0.99
    .
    title Lambda = 0.9
    plot btappf(p,0.9,1) for p = 0  0.01  0.99
    .
    end of multiplot
    .
    justification center
    move 50 97
    text Percent Point Functions for Borel-Tanner
 
-----BUG SWITCHES (SET)--------------------------------------------
 
BUG SWITCHES
 
Name:
    BUG SWITCHES (SET)
 
Type:
    Set Subcommand
 
Purpose:
    Turn on various debugging switches.
 
Description:
    Dataplot contains a number of commands for turning on debug switches.
    When a debugging switch is turned on, certain print statements will
    be activated to aid in debugging.

    Although these commands are primarily of interest to the Dataplot
    developers, they can be turned on by any Dataplot user.

    The list of available bug switches is

        IBUGMA  - Debugging for Dataplot's main routine
        IBUGIN  - Debugging for initialization
        IBUGLS  - Debugging for LET subcommands
        IBUGMS  - Not used
        IBUGGC  - Debugging for DPGETC routine (DPGETC parses the
                  command line)
        IBUGTY  - Debugging for DPTYPE routine (DPTYPE creates character,
                  floating point and integer representations for each
                  component of the command line)
        IBUGTE  - Not used
        IBUGPC  - Debugging for plot control commands (high level
                  routines)
        IBUGP2  - Debugging for plot control commands (lower level
                  routines)
        IBUGOD  - Debugging for output device commands (high level
                  routines)
        IBUGO2  - Debugging for output device commands (low level
                  routines)
        IBUGSU  - Debugging for support commands (high level
                  routines)
        IBUGS2  - Debugging for support commands (low level
                  routines)
        IBUGGR  - Debugging for graphics commands (high level
                  routines)
        IBUGG2  - Debugging for graphics commands (low level
                  routines)
        IBUGG3  - Debugging for graphics commands (low level
                  routines)
        IBUGAN  - Debugging for analysis commands (high level
                  routines)
        IBUGA2  - Debugging for analysis commands (low level
                  routines)
        IBUGA3  - Debugging for analysis commands (low level
                  routines)
        IBUGPL  - Debugging for plotting routines (high level
                  routines)
        IBUGP1  - Debugging for plotting routines (low level
                  routines)
        IBUGP3  - Debugging for plotting routines (low level
                  routines)
        IBUGDG  - Debugging for diagrammatic graphics commands (high level
                  routines)
        IBUGD2  - Debugging for diagrammatic graphics commands (low level
                  routines)
        IBUGCO  - Debugging for function evaluation (COMPIM and COMPID
                  routines)
        IBUGEV  - Debugging for function evaluation (EVALM routine)
        IBUGQ   - Debugging for subsetting
        IBUGRE  - Debugging for reading
        IBUGWR  - Debugging for writing
        IBUGSO  - Not used
        IBUGTO  - Not used
        IBUGUG  - Debugging for graphics routines
        IBUGU2  - Debugging for graphics routines
        IBUGU3  - Debugging for graphics routines
        IBUGU4  - Debugging for graphics routines
        IBUGEX  - Debugging for expert subsystem (obsolete)
        IBUGE2  - Debugging for expert subsystem (obsolete)
        IBUGHE  - Debugging for help command (high level)
        IBUGH2  - Debugging for help command (low level)
        IBUGWI  - Debugging for GUI subsystem (obsolete)
        IBUGLO  - Debugging for LOOP command

Syntax:
    SET <BUG SWITCH> <ON/OFF>
    where <BUG SWITCH> is one of the names listed above;
    and where <ON/OFF> specifies whether the bug switch is turned on or off.
 
Examples:
    SET IBUGG2 ON
    SET IBUGA2 ON
    SET IBUGG2 OFF

Note:
    The debug switches can result in a large amount of output being
    generated.  For that reason, you may want to use the CAPTURE command
    to save the output to a file.

Default:
    All bug switches are OFF.
 
Synonyms:
    None
 
Related Commands:
    SET ISUBRO       = Turn on debugging for a specific subroutine.
    SET FATAL ERROR  = Specify what action to take when an error is
                       detected.
    CAPTURE          = Redirect terminal output to a file.
 
Applications:
    Debugging
 
Implementation Date:
    Pre-1987
 
Program:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    SET IBUGGR ON
    SET IBUGG2 ON
    CAPTURE JUNK.OUT
    HISTOGRAM Y
    END OF CAPTURE
 
-----BUGS-------------------------------------------------------
 
BUGS
 
Name:
    BUGS
 
Type:
    Support Command
 
Purpose:
    Generates a list of known bugs in the local DATAPLOT
    implementation.
 
Syntax:
    BUGS
 
Examples:
    BUGS
 
Default:
    Off
 
Synonyms:
    None
 
Related Commands:
    NEWS = Lists the news file.
    MAIL = Lists the mail file.
    HELP = Lists portions of the help file.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XX
 
-----BU2CDF (LET)--------------------------------
 
BU2CDF
 
Name:
    BU2CDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 2 cumulative distribution function
    with shape parameter r.
 
Description:
    The standard Burr type 2 distribution has the following
    cumulative distribution function:

       F(x;r) = 1/[(1+EXP(-x))**r]    -INF <  x <  INF; r > 0
 
    with r denoting the shape parameter.

    This distribution can be generalized with location and
    scale parameters in the usual way using the relation

       F(x;r,loc,scale) = F((x-loc)/scale;r,0,1)

Syntax:
    LET <y> = BU2CDF(<x>,<r>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed Burr type 2 cdf value
              is stored;
          <r> is a positive number, parameter, or variable that
              specifies the shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = BU2CDF(0.3,0.2)
    LET Y = BU2CDF(X,0.5,0,5)
    PLOT BU2CDF(X,2,0,3) FOR X = 0  0.01  5
 
Default:
    None
 
Synonyms:
    BURR TYPE II is a synonym for BURR TYPE 2.
 
Related Commands:
    BU2PDF = Compute the Burr type 2 probability density
             function.
    BU2PPF = Compute the Burr type 2 percent point function.
    B10PDF = Compute the Burr type 10 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU5PDF = Compute the Burr type 6 probability density function.
    BU7PDF = Compute the Burr type 7 probability density function.
    BU8PDF = Compute the Burr type 8 probability density function.
    BU9PDF = Compute the Burr type 9 probability density function.
    B11PDF = Compute the Burr type 11 probability density function.
    B12PDF = Compute the Burr type 12 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Burr (1942), "Cumulative Frequency Functions", Annals of
    Mathematical Statistics, 13, pp. 215-232.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    LET R  = 0.5
    TITLE R = ^r
    PLOT BU2CDF(X,R) FOR X = 0.01  0.01  5
    .
    LET R  = 1
    TITLE R = ^r
    PLOT BU2CDF(X,R) FOR X = 0.01  0.01  5
    .
    LET R  = 2
    TITLE R = ^r
    PLOT BU2CDF(X,R) FOR X = 0.01  0.01  5
    .
    LET R  = 5
    TITLE R = ^r
    PLOT BU2CDF(X,R) FOR X = 0.01  0.01  5
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 2 Cumulative Distribution Functions
 
-----BU2PDF (LET)--------------------------------
 
BU2PDF
 
Name:
    BU2PDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 2 probability density function
    with shape parameter r.
 
Description:
    The standard Burr type 2 distribution has the following
    probability density function:

       f(x;r) = r*(1 + EXP(-x))**(-1-r)/EXP(x)
                -INF <  x <  INF; r > 0
 
    with r denoting the shape parameter.

    This distribution can be generalized with location and
    scale parameters in the usual way using the relation

       f(x;r,loc,scale) = (1/scale)*f((x-loc)/scale;r,0,1)

Syntax:
    LET <y> = BU2PDF(<x>,<r>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed Burr type 2 pdf value
              is stored;
          <r> is a positive number, parameter, or variable that
              specifies the shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = BU2PDF(0.3,0.2)
    LET Y = BU2PDF(X,0.5,0,5)
    PLOT BU2PDF(X,2,0,3) FOR X = 0  0.01  5
 
Note:
    Burr type 2 random numbers, probability plots, and
    goodness of fit tests can be generated with the commands:

       LET R = <value>
       LET Y = BURR TYPE 2 RANDOM NUMBERS FOR I = 1 1 N
       BURR TYPE 2 PROBABILITY PLOT Y
       BURR TYPE 2 PROBABILITY PLOT Y2 X2
       BURR TYPE 2 PROBABILITY PLOT Y3 XLOW XHIGH
       BURR TYPE 2 KOLMOGOROV SMIRNOV GOODNESS OF FIT Y
       BURR TYPE 2 CHI-SQUARE GOODNESS OF FIT Y2 X2
       BURR TYPE 2 CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    The following commands can be used to estimate the r
    shape parameter for the Burr type 2 distribution:

       LET R1 = <value>
       LET R2 = <value>
       BURR TYPE 2 PPCC PLOT Y
       BURR TYPE 2 PPCC PLOT Y2 X2
       BURR TYPE 2 PPCC PLOT Y3 XLOW XHIGH
       BURR TYPE 2 KS PLOT Y
       BURR TYPE 2 KS PLOT Y2 X2
       BURR TYPE 2 KS PLOT Y3 XLOW XHIGH

    The default values for R1 and R2 are 0.5 and 10.

    The probability plot can then be used to estimate the
    location and scale (location = PPA0, scale = PPA1).

    The BOOTSTRAP DISTRIBUTION command can be used to find
    uncertainty intervals for the ppcc plot and ks plot.
       
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE II is a synonym for BURR TYPE 2.
 
Related Commands:
    BU2CDF = Compute the Burr type 2 cumulative distribution
             function.
    BU2PPF = Compute the Burr type 2 percent point function.
    B10PDF = Compute the Burr type 10 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU5PDF = Compute the Burr type 6 probability density function.
    BU7PDF = Compute the Burr type 7 probability density function.
    BU8PDF = Compute the Burr type 8 probability density function.
    BU9PDF = Compute the Burr type 9 probability density function.
    B11PDF = Compute the Burr type 11 probability density function.
    B12PDF = Compute the Burr type 12 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Burr (1942), "Cumulative Frequency Functions", Annals of
    Mathematical Statistics, 13, pp. 215-232.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program 1:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    LET R  = 0.5
    TITLE R = ^r
    PLOT BU2PDF(X,R) FOR X = 0.01  0.01  5
    .
    LET R  = 1
    TITLE R = ^r
    PLOT BU2PDF(X,R) FOR X = 0.01  0.01  5
    .
    LET R  = 2
    TITLE R = ^r
    PLOT BU2PDF(X,R) FOR X = 0.01  0.01  5
    .
    LET R  = 5
    TITLE R = ^r
    PLOT BU2PDF(X,R) FOR X = 0.01  0.01  5
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 2 Probability Density Functions
 
Program 2:
   let r = 2.1
   let rsav = r
   .
   let y = burr type 2 random numbers for i = 1 1 200
   let y = 10*y
   let amax = maximum y
   .
   burr type 2 ppcc plot y
   let rtemp = shape - 2
   let r1 = max(rtemp,0.05)
   let r2 = shape + 2
   y1label Correlation Coefficient
   x1label R
   burr type 2 ppcc plot y
   let r = shape
   justification center
   move 50 6
   text Rhat = ^r (R = ^rsav)
   move 50 2
   text Maximum PPCC = ^maxppcc
   .
   y1label Data
   x1label Theoretical
   char x
   line bl
   burr type 2 prob plot y
   move 50 6
   text Location = ^ppa0, Scale = ^ppa1
   char bl
   line so
   .
   y1label Relative Frequency
   x1label
   relative hist y
   limits freeze
   pre-erase off
   plot bu2pdf(x,r,ppa0,ppa1) for x = 0.01 .01 amax
   limits 
   pre-erase on
   .
   let ksloc = ppa0
   let ksscale = ppa1
   burr type 2 kolmogorov smirnov goodness of fit y

-----BU2PPF (LET)--------------------------------
 
BU2PPF
 
Name:
    BU2PPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 2 percent point function
    with shape parameter r.
 
Description:
    The standard Burr type 2 distribution has the following
    percent point function:

       G(p;r) = -LOG((1/p)**(1/r) - 1)   0 < p < 1; r > 0
 
    with r denoting the shape parameter.

    This distribution can be generalized with location and
    scale parameters in the usual way using the relation

       G(p;r,loc,scale) = loc + scale*G(p;r,0,1)

Syntax:
    LET <y> = BU2PPF(<p>,<r>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or variable in the
              interval (0,1);
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed Burr type 2 cdf value
              is stored;
          <r> is a positive number, parameter, or variable that
              specifies the shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = BU2PPF(0.95,2.2)
    LET Y = BU2PPF(P,2.5,0,5)
    PLOT BU2PPF(P,2,0,3) FOR P = 0.01  0.01  0.99
 
Default:
    None
 
Synonyms:
    BURR TYPE II is a synonym for BURR TYPE 2.
 
Related Commands:
    BU2CDF = Compute the Burr type 2 cumulative distribution
             function.
    BU2PDF = Compute the Burr type 2 probability density
             function.
    B10PDF = Compute the Burr type 10 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU5PDF = Compute the Burr type 6 probability density function.
    BU7PDF = Compute the Burr type 7 probability density function.
    BU8PDF = Compute the Burr type 8 probability density function.
    BU9PDF = Compute the Burr type 9 probability density function.
    B11PDF = Compute the Burr type 11 probability density function.
    B12PDF = Compute the Burr type 12 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Burr (1942), "Cumulative Frequency Functions", Annals of
    Mathematical Statistics, 13, pp. 215-232.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    LET R  = 0.5
    TITLE R = ^r
    PLOT BU2PPF(P,R) FOR P = 0.01  0.01  0.99
    .
    LET R  = 1
    TITLE R = ^r
    PLOT BU2PPF(P,R) FOR P = 0.01  0.01  0.99
    .
    LET R  = 2
    TITLE R = ^r
    PLOT BU2PPF(P,R) FOR P = 0.01  0.01  0.99
    .
    LET R  = 5
    TITLE R = ^r
    PLOT BU2PPF(P,R) FOR P = 0.01  0.01  0.99
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 2 Percent Point Functions
 
-----BU3CDF (LET)--------------------------------
 
BU3CDF
 
Name:
    BU3CDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 3 cumulative distribution function
    with shape parameters r and k.
 
Description:
    The Burr type 3 distribution is typically defined in terms
    of its cumulative distribution function:

       F(x;r,k,l,s) = (1+((x-l)/s)**(-k))**(-r)      x >  0; r, k,s  > 0
 
    with r, k, l, and s denoting the two shape parameters, the location
    parameter, and the scale parameter, respectively.

    The case where l = 0 and s = 1 is referred to as the standard
    Burr type 3 distribution.

    If X has a Burr type 12 distribution, then 1/X has a
    Burr type 3 distribution.  For this reason, the
    Burr type 3 distribution is often referred to as the
    inverse Burr distribution.

    The Burr type 3 distribution is also sometimes referred to
    as the Dagum type I distribution.

Syntax:
    LET <y> = BU3CDF(<x>,<r>,<k>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed Burr type 3 cdf value
              is stored;
          <r> is a positive number, parameter, or variable that
              specifies the first shape parameter;
          <k> is a positive number, parameter, or variable that
              specifies the second shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = BU3CDF(0.3,0.2,1.7)
    LET Y = BU3CDF(X,0.5,2.2,0,5)
    PLOT BU3CDF(X,2.3,1.4) FOR X = 0  0.01  5
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE III is a synonym for BURR TYPE 3.
 
Related Commands:
    BU3PDF = Compute the Burr type 3 probability density function.
    BU3PPF = Compute the Burr type 3 percent point function.
    B10PDF = Compute the Burr type 10 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU5PDF = Compute the Burr type 6 probability density function.
    BU7PDF = Compute the Burr type 7 probability density function.
    BU8PDF = Compute the Burr type 8 probability density function.
    BU9PDF = Compute the Burr type 9 probability density function.
    B11PDF = Compute the Burr type 11 probability density function.
    B12PDF = Compute the Burr type 12 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Burr (1942), "Cumulative Frequency Functions", Annals of
    Mathematical Statistics, 13, pp. 215-232.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 4 4
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 4
    .
    LET RVAL = DATA 0.5  1  2  5
    LET KVAL = DATA 0.5  1  2  5
    .
    LOOP FOR IROW = 1 1 4
        LOOP FOR ICOL = 1 1 4
            LET R  = RVAL(IROW)
            LET K = KVAL(ICOL)
            TITLE R = ^r, K = ^k
            PLOT BU3CDF(X,R,K) FOR X = 0.01  0.01  5
        END OF LOOP
    END OF LOOP
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 3 Cumulative Distribution Functions
 
-----BU3PDF (LET)--------------------------------
 
BU3PDF
 
Name:
    BU3PDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 3 probability density function
    with shape parameters r and k.
 
Description:
    The standard Burr type 3 distribution has the following
    probability density function:

       f(x;r,k) = r*k*x**(r*k-1)/(1+x**k)**(r+1)
                  x >  0; r, k > 0
 
    with r and k denoting the shape parameters.

    This distribution can be generalized with location and
    scale parameters in the usual way using the relation

       f(x;r,k,loc,scale) = (1/scale)*f((x-loc)/scale;r,k,0,1)

    If X has a Burr type 12 distribution, then 1/X has a
    Burr type 3 distribution.  For this reason, the
    Burr type 3 distribution is often referred to as the
    inverse Burr distribution.

    The Burr type 3 distribution is also sometimes referred to as
    the Dagum type I distribution.

Syntax:
    LET <y> = BU3PDF(<x>,<r>,<k>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed Burr type 3 pdf value
              is stored;
          <r> is a positive number, parameter, or variable that
              specifies the first shape parameter;
          <k> is a positive number, parameter, or variable that
              specifies the second shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = BU3PDF(0.3,0.2,1.7)
    LET Y = BU3PDF(X,0.5,2.2,0,5)
    PLOT BU3PDF(X,2.3,1.4) FOR X = 0  0.01  5
 
Note:
    Burr type 3 random numbers, probability plots, and
    goodness of fit tests can be generated with the commands:

       LET R = <value>
       LET K = <value>
       LET Y = BURR TYPE 3 RANDOM NUMBERS FOR I = 1 1 N
       BURR TYPE 3 PROBABILITY PLOT Y
       BURR TYPE 3 PROBABILITY PLOT Y2 X2
       BURR TYPE 3 PROBABILITY PLOT Y3 XLOW XHIGH
       BURR TYPE 3 KOLMOGOROV SMIRNOV GOODNESS OF FIT Y
       BURR TYPE 3 CHI-SQUARE GOODNESS OF FIT Y2 X2
       BURR TYPE 3 CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    The following commands can be used to estimate the r and k
    shape parameters for the Burr type 3 distribution:

       LET R1 = <value>
       LET R2 = <value>
       LET K1 = <value>
       LET K2 = <value>
       BURR TYPE 3 PPCC PLOT Y
       BURR TYPE 3 PPCC PLOT Y2 X2
       BURR TYPE 3 PPCC PLOT Y3 XLOW XHIGH
       BURR TYPE 3 KS PLOT Y
       BURR TYPE 3 KS PLOT Y2 X2
       BURR TYPE 3 KS PLOT Y3 XLOW XHIGH

    The default values for R1, R2, K1, and K2 are 0.5, 10,
    0.5, and 10, respectively.

    The probability plot can then be used to estimate the
    location and scale (location = PPA0, scale = PPA1).

    Since the Burr type 3 distribution can sometimes be
    heavy-tailed, the following command can be useful
    before using the BURR TYPE 3 KS PLOT:

        SET PPCC PLOT LOCATION SCALE BIWEIGHT

    This bases the location and scale estimates on the biweight
    estimates of the fitted line for the underlying probability
    plot.  In the final probability plot, use PPA0BW and PPA1BW
    as the estimates of location and scale rather than PPA0 and PPA1.
    Since the ppcc plot is invariant to location and scale, this
    option does not apply.

    The BOOTSTRAP DISTRIBUTION command can be used to find
    uncertainty intervals for the ppcc plot and ks plot.
       
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE III is a synonym for BURR TYPE 3.
 
Related Commands:
    BU3CDF = Compute the Burr type 3 cumulative distribution
             function.
    BU3PPF = Compute the Burr type 3 percent point function.
    B10PDF = Compute the Burr type 10 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU5PDF = Compute the Burr type 6 probability density function.
    BU7PDF = Compute the Burr type 7 probability density function.
    BU8PDF = Compute the Burr type 8 probability density function.
    BU9PDF = Compute the Burr type 9 probability density function.
    B11PDF = Compute the Burr type 11 probability density function.
    B12PDF = Compute the Burr type 12 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Burr (1942), "Cumulative Frequency Functions", Annals of
    Mathematical Statistics, 13, pp. 215-232.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program 1:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 4 4
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 4
    .
    LET RVAL = DATA 0.5  1  2  5
    LET KVAL = DATA 0.5  1  2  5
    .
    LOOP FOR IROW = 1 1 4
        LOOP FOR ICOL = 1 1 4
            LET R  = RVAL(IROW)
            LET K = KVAL(ICOL)
            TITLE R = ^r, K = ^k
            PLOT BU3PDF(X,R,K) FOR X = 0.01  0.01  5
        END OF LOOP
    END OF LOOP
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 3 Probability Density Functions
 
Program 2:
    let r = 2.1
    let k = 1.3
    let rsav = r
    let ksav = k
    .
    let y = burr type 3 random numbers for i = 1 1 200
    let y = 10*y
    let amin = minimum y
    let amax = maximum y
    .
    set ppcc plot location scale biweight
    y1label KS Value
    x1label K (Curves Represent Values of R)
    let r1 = 0.5
    let r2 = 5
    let k1 = 0.5
    let k2 = 3
    burr type 3 ks plot y
    let r = shape1
    let k = shape2
    justification center
    move 50 6
    text Rhat = ^r (R = ^rsav), Khat = ^k (K = ^ksav)
    move 50 2
    text Minimum KS = ^minks
    .
    y1label Data
    x1label Theoretical
    char x
    line bl
    burr type 3 prob plot y
    move 50 6
    text Location = ^ppa0bw, Scale = ^ppa1bw
    char bl
    line so
    .
    let loc = min(ppa0bw,amin)
    let scale = ppa1bw
    .
    y1label Relative Frequency
    x1label
    relative hist y
    limits freeze
    pre-erase off
    line color blue
    plot bu3pdf(x,r,k,loc,scale) for x = amin .01 amax
    line color black
    limits 
    pre-erase on
    .
    let ksloc = loc
    let ksscale = scale
    burr type 3 kolmogorov smirnov goodness of fit y

-----BU3PPF (LET)--------------------------------
 
BU3PPF
 
Name:
    BU3PPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 3 percent point function
    with shape parameters r and k.
 
Description:
    The standard Burr type 3 distribution has the following
    percent point function:

       G(p;r,k) = (p**(-1/r) - 1)**(-1/k)
                  0 < p < 1; r, k > 0
 
    with r and k denoting the shape parameters.

    This distribution can be generalized with location and
    scale parameters in the usual way using the relation

       G(p;r,k,loc,scale) = loc + scale*G(p;r,k,0,1)

    If X has a Burr type 12 distribution, then 1/X has a
    Burr type 3 distribution.  For this reason, the
    Burr type 3 distribution is often referred to as the
    inverse Burr distribution.

    The Burr type 3 distribution is also sometimes referred to
    as the Dagum type I distribution.

Syntax:
    LET <y> = BU3PPF(<p>,<r>,<k>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or variable in the
              interval (0,1);
          <y> is a variable or a parameter (depending on what
              <p> is) where the computed Burr type 3 ppf value
              is stored;
          <r> is a positive number, parameter, or variable that
              specifies the first shape parameter;
          <k> is a positive number, parameter, or variable that
              specifies the second shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = BU3PPF(0.95,0.2,1.7)
    LET Y = BU3PPF(X,0.5,2.2,0,5)
    PLOT BU3PPF(P,2.3,1.4) FOR P = 0.01  0.01  0.99
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE III is a synonym for BURR TYPE 3.
 
Related Commands:
    BU3CDF = Compute the Burr type 3 cumulative distribution
             function.
    BU3PDF = Compute the Burr type 3 probability density function.
    B10PDF = Compute the Burr type 10 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU5PDF = Compute the Burr type 6 probability density function.
    BU7PDF = Compute the Burr type 7 probability density function.
    BU8PDF = Compute the Burr type 8 probability density function.
    BU9PDF = Compute the Burr type 9 probability density function.
    B11PDF = Compute the Burr type 11 probability density function.
    B12PDF = Compute the Burr type 12 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Burr (1942), "Cumulative Frequency Functions", Annals of
    Mathematical Statistics, 13, pp. 215-232.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 4 4
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 4
    .
    LET RVAL = DATA 0.5  1  2  5
    LET KVAL = DATA 0.5  1  2  5
    .
    LOOP FOR IROW = 1 1 4
        LOOP FOR ICOL = 1 1 4
            LET R  = RVAL(IROW)
            LET K = KVAL(ICOL)
            TITLE R = ^r, K = ^k
            PLOT BU3PPF(P,R,K) FOR P = 0.01  0.01  0.99
        END OF LOOP
    END OF LOOP
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 3 Percent Point Functions
 
-----BU4CDF (LET)--------------------------------
 
BU4CDF
 
Name:
    BU4CDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 4 cumulative distribution function
    with shape parameters r and c.
 
Description:
    The standard Burr type 4 distribution has the following
    cumulative distribution function:

       F(x;r,c) = [1 + (c-x)/x)**(1/c)]**(-r)
                  0 <  x <  c; c, r > 0
 
    with r and c denoting the shape parameters.

    This distribution can be generalized with location and
    scale parameters in the usual way using the relation

       F(x;r,c,loc,scale) = F((x-loc)/scale;r,c,0,1)

Syntax:
    LET <y> = BU4CDF(<x>,<r>,<c>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed Burr type 4 cdf value
              is stored;
          <r> is a positive number, parameter, or variable that
              specifies the first shape parameter;
          <c> is a positive number, parameter, or variable that
              specifies the second shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = BU4CDF(0.3,0.2,1.7)
    LET Y = BU4CDF(X,0.5,2.2,0,5)
    PLOT BU4CDF(X,2,1.8) FOR X = -1.57  0.01  1.57
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE IV is a synonym for BURR TYPE 4.
 
Related Commands:
    BU4PDF = Compute the Burr type 4 probability density function.
    BU4PPF = Compute the Burr type 4 percent point function.
    BU2PDF = Compute the Burr type 2 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU6PDF = Compute the Burr type 6 probability density function.
    BU7PDF = Compute the Burr type 7 probability density function.
    BU8PDF = Compute the Burr type 8 probability density function.
    BU9PDF = Compute the Burr type 9 probability density function.
    B10PDF = Compute the Burr type 10 probability density function.
    B11PDF = Compute the Burr type 11 probability density function.
    B12PDF = Compute the Burr type 12 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Burr (1942), "Cumulative Frequency Functions", Annals of
    Mathematical Statistics, 13, pp. 215-232.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 4 4
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 4
    .
    LET RVAL = DATA 0.5  1  2  5
    LET CVAL = DATA 0.5  1  2  5
    .
    LOOP FOR IROW = 1 1 4
        LOOP FOR ICOL = 1 1 4
            LET R  = RVAL(IROW)
            LET C = CVAL(ICOL)
            LET STOP = C - 0.01
            TITLE R = ^r, K = ^k
            PLOT BU4CDF(X,R,C) FOR X = 0.01 STOP
        END OF LOOP
    END OF LOOP
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 4 Cumulative Distribution Functions
 
-----BU4PPF (LET)--------------------------------
 
BU4PPF
 
Name:
    BU4PPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 4 percent point function with
    shape parameters r and c.
 
Description:
    The standard Burr type 4 distribution has the following
    percent point function:

       G(p;r,c) = c/[1 + (p**(-1/r) - 1)**c]
                  0 <= p < 1; r, c > 0
 
    with r and c denoting the shape parameters.

    This distribution can be generalized with location and
    scale parameters in the usual way using the relation

       G(p;r,c,loc,scale) = loc + scale*G(p;r,c,0,1)

Syntax:
    LET <y> = BU4PPF(<p>,<r>,<c>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or variable in the
              interval (0,1);
          <y> is a variable or a parameter (depending on what
              <p> is) where the computed Burr type 4 ppf value
              is stored;
          <r> is a positive number, parameter, or variable that
              specifies the first shape parameter;
          <c> is a positive number, parameter, or variable that
              specifies the second shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = BU4PPF(0.95,0.2,1.7)
    LET Y = BU4PPF(P,0.5,2.2,0,5)
    PLOT BU4PPF(P,2,1.8,0,5) FOR P = 0.01  0.01  0.99
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE IV is a synonym for BURR TYPE 4.
 
Related Commands:
    BU4CDF = Compute the Burr type 4 cumulative distribution
             function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU2PDF = Compute the Burr type 2 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU6PDF = Compute the Burr type 6 probability density function.
    BU7PDF = Compute the Burr type 7 probability density function.
    BU8PDF = Compute the Burr type 8 probability density function.
    BU9PDF = Compute the Burr type 9 probability density function.
    B10PDF = Compute the Burr type 10 probability density function.
    B11PDF = Compute the Burr type 11 probability density function.
    B12PDF = Compute the Burr type 12 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Burr (1942), "Cumulative Frequency Functions", Annals of
    Mathematical Statistics, 13, pp. 215-232.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 4 4
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 4
    .
    LET RVAL = DATA 0.5  1  2  5
    LET CVAL = DATA 0.5  1  2  5
    .
    LOOP FOR IROW = 1 1 4
        LOOP FOR ICOL = 1 1 4
            LET R  = RVAL(IROW)
            LET C = CVAL(ICOL)
            TITLE R = ^r, C = ^c
            PLOT BU4PPF(P,R,C) FOR P = 0  0.01  0.99
        END OF LOOP
    END OF LOOP
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 4 Percent Point Functions
 
-----BU5CDF (LET)--------------------------------
 
BU5CDF
 
Name:
    BU5CDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 5 cumulative distribution function
    with shape parameters r and k.
 
Description:
    The standard Burr type 5 distribution has the following
    cumulative distribution function:

       F(x;r,k) = (1 + k*EXP(-TAN(x)))**(-r)
                  -PI/2 <  x <  PI/2; r, k > 0
 
    with r and k denoting the shape parameters.

    This distribution can be generalized with location and
    scale parameters in the usual way using the relation

       F(x;r,k,loc,scale) = F((x-loc)/scale;r,k,0,1)

Syntax:
    LET <y> = BU5CDF(<x>,<r>,<k>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed Burr type 5 cdf value
              is stored;
          <r> is a positive number, parameter, or variable that
              specifies the first shape parameter;
          <k> is a positive number, parameter, or variable that
              specifies the second shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = BU5CDF(0.3,0.2,1.7)
    LET Y = BU5CDF(X,0.5,2.2,0,5)
    PLOT BU5CDF(X,2,1.8) FOR X = -1.57  0.01  1.57
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE V is a synonym for BURR TYPE 5.
 
Related Commands:
    BU5PDF = Compute the Burr type 5 probability density function.
    BU5PPF = Compute the Burr type 5 percent point function.
    BU2PDF = Compute the Burr type 2 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU6PDF = Compute the Burr type 6 probability density function.
    BU7PDF = Compute the Burr type 7 probability density function.
    BU8PDF = Compute the Burr type 8 probability density function.
    BU9PDF = Compute the Burr type 9 probability density function.
    B10PDF = Compute the Burr type 10 probability density function.
    B11PDF = Compute the Burr type 11 probability density function.
    B12PDF = Compute the Burr type 12 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Burr (1942), "Cumulative Frequency Functions", Annals of
    Mathematical Statistics, 13, pp. 215-232.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 4 4
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 4
    .
    LET RVAL = DATA 0.5  1  2  5
    LET KVAL = DATA 0.5  1  2  5
    .
    LOOP FOR IROW = 1 1 4
        LOOP FOR ICOL = 1 1 4
            LET R  = RVAL(IROW)
            LET K = KVAL(ICOL)
            TITLE R = ^r, K = ^k
            PLOT BU5CDF(X,R,K) FOR X = -1.57  0.01  1.57
        END OF LOOP
    END OF LOOP
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 5 Cumulative Distribution Functions
 
-----BU5PDF (LET)--------------------------------
 
BU5PDF
 
Name:
    BU5PDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 5 probability density function
    with shape parameters r and k.
 
Description:
    The standard Burr type 5 distribution has the following
    probability density function:

       f(x;r,k) = r*k*(1 + k/(EXP(TAN(x))**(-r-1)*SEC(x)**2/
                  EXP(TAN(x))
                  -PI/2 <  x <  PI/2; r, k > 0
 
    with r and k denoting the shape parameters.

    This distribution can be generalized with location and
    scale parameters in the usual way using the relation

       f(x;r,k,loc,scale) = (1/scale)*f((x-loc)/scale;r,k,0,1)

Syntax:
    LET <y> = BU5PDF(<x>,<r>,<k>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed Burr type 5 pdf value
              is stored;
          <r> is a positive number, parameter, or variable that
              specifies the first shape parameter;
          <k> is a positive number, parameter, or variable that
              specifies the second shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = BU5PDF(0.3,0.2,1.7)
    LET Y = BU5PDF(X,0.5,2.2,0,5)
    PLOT BU5PDF(X,2,1.8) FOR X = -1.57  0.01  1.57
 
Note:
    Burr type 5 random numbers, probability plots, and
    goodness of fit tests can be generated with the commands:

       LET R = <value>
       LET K = <value>
       LET Y = BURR TYPE 5 RANDOM NUMBERS FOR I = 1 1 N
       BURR TYPE 5 PROBABILITY PLOT Y
       BURR TYPE 5 PROBABILITY PLOT Y2 X2
       BURR TYPE 5 PROBABILITY PLOT Y3 XLOW XHIGH
       BURR TYPE 5 KOLMOGOROV SMIRNOV GOODNESS OF FIT Y
       BURR TYPE 5 CHI-SQUARE GOODNESS OF FIT Y2 X2
       BURR TYPE 5 CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    The following commands can be used to estimate the r
    shape parameter for the Burr type 5 distribution:

       LET R1 = <value>
       LET R2 = <value>
       BURR TYPE 5 PPCC PLOT Y
       BURR TYPE 5 PPCC PLOT Y2 X2
       BURR TYPE 5 PPCC PLOT Y3 XLOW XHIGH
       BURR TYPE 5 KS PLOT Y
       BURR TYPE 5 KS PLOT Y2 X2
       BURR TYPE 5 KS PLOT Y3 XLOW XHIGH

    The default values for R1 and R2 are 0.5 and 10.

    The probability plot can then be used to estimate the
    location and scale (location = PPA0, scale = PPA1).

    The BOOTSTRAP DISTRIBUTION command can be used to find
    uncertainty intervals for the ppcc plot and ks plot.
       
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE V is a synonym for BURR TYPE 5.
 
Related Commands:
    BU5CDF = Compute the Burr type 5 cumulative distribution
             function.
    BU5PPF = Compute the Burr type 5 percent point function.
    BU2PDF = Compute the Burr type 2 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU6PDF = Compute the Burr type 6 probability density function.
    BU7PDF = Compute the Burr type 7 probability density function.
    BU8PDF = Compute the Burr type 8 probability density function.
    BU9PDF = Compute the Burr type 9 probability density function.
    B10PDF = Compute the Burr type 10 probability density function.
    B11PDF = Compute the Burr type 11 probability density function.
    B12PDF = Compute the Burr type 12 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Burr (1942), "Cumulative Frequency Functions", Annals of
    Mathematical Statistics, 13, pp. 215-232.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program 1:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 4 4
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 4
    .
    LET RVAL = DATA 0.5  1  2  5
    LET KVAL = DATA 0.5  1  2  5
    .
    LOOP FOR IROW = 1 1 4
        LOOP FOR ICOL = 1 1 4
            LET R  = RVAL(IROW)
            LET K = KVAL(ICOL)
            TITLE R = ^r, K = ^k
            PLOT BU5PDF(X,R,K) FOR X = -1.57  0.01  1.57
        END OF LOOP
    END OF LOOP
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 5 Probability Density Functions
 
Program 2:
    let r = 2.1
    let k = 1.3
    let rsav = r
    let ksav = k
    .
    let y = burr type 5 random numbers for i = 1 1 200
    let y = 10*y
    let amin = minimum y
    let amax = maximum y
    .
    y1label Correlation Coefficeint
    x1label K (Curves Represent Values of R)
    let r1 = 0.5
    let r2 = 5
    let k1 = 0.5
    let k2 = 3
    burr type 5 ppcc plot y
    let r = shape1
    let k = shape2
    justification center
    move 50 6
    text Rhat = ^r (R = ^rsav), Khat = ^k (K = ^ksav)
    move 50 2
    text Maximum PPCC = ^maxppcc
    .
    y1label Data
    x1label Theoretical
    char x
    line bl
    burr type 5 prob plot y
    move 50 6
    text Location = ^ppa0, Scale = ^ppa1
    char bl
    line so
    .
    let loc = ppa0
    let scale = ppa1
    .
    y1label Relative Frequency
    x1label
    relative hist y
    limits freeze
    pre-erase off
    line color blue
    plot bu5pdf(x,r,k,loc,scale) for x = amin .01 amax
    line color black
    limits 
    pre-erase on
    .
    let ksloc = loc
    let ksscale = scale
    burr type 5 kolmogorov smirnov goodness of fit y

-----BU5PPF (LET)--------------------------------
 
BU5PPF
 
Name:
    BU5PPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 5 percent point function with
    shape parameters r and k.
 
Description:
    The standard Burr type 5 distribution has the following
    percent point function:

       G(p;r,k) = ARCTAN{-LOG((p**(-1/r) - 1)/k)}
                  0 < p < 1; r, k > 0
 
    with r and k denoting the shape parameters.

    This distribution can be generalized with location and
    scale parameters in the usual way using the relation

       G(p;r,k,loc,scale) = loc + scale*G(p;r,k,0,1)

Syntax:
    LET <y> = BU5PPF(<p>,<r>,<k>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or variable in the
              interval (0,1);
          <y> is a variable or a parameter (depending on what
              <p> is) where the computed Burr type 5 ppf value
              is stored;
          <r> is a positive number, parameter, or variable that
              specifies the first shape parameter;
          <k> is a positive number, parameter, or variable that
              specifies the second shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = BU5PPF(0.95,0.2,1.7)
    LET Y = BU5PPF(P,0.5,2.2,0,5)
    PLOT BU5PPF(P,2,1.8,0,5) FOR P = 0.01  0.01  0.99
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE V is a synonym for BURR TYPE 5.
 
Related Commands:
    BU5CDF = Compute the Burr type 5 cumulative distribution
             function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU2PDF = Compute the Burr type 2 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU6PDF = Compute the Burr type 6 probability density function.
    BU7PDF = Compute the Burr type 7 probability density function.
    BU8PDF = Compute the Burr type 8 probability density function.
    BU9PDF = Compute the Burr type 9 probability density function.
    B10PDF = Compute the Burr type 10 probability density function.
    B11PDF = Compute the Burr type 11 probability density function.
    B12PDF = Compute the Burr type 12 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Burr (1942), "Cumulative Frequency Functions", Annals of
    Mathematical Statistics, 13, pp. 215-232.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 4 4
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 4
    .
    LET RVAL = DATA 0.5  1  2  5
    LET KVAL = DATA 0.5  1  2  5
    .
    LOOP FOR IROW = 1 1 4
        LOOP FOR ICOL = 1 1 4
            LET R  = RVAL(IROW)
            LET K = KVAL(ICOL)
            TITLE R = ^r, K = ^k
            PLOT BU5PPF(P,R,K) FOR P = 0.01  0.01  0.99
        END OF LOOP
    END OF LOOP
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 5 Percent Point Functions
 
-----BU6CDF (LET)--------------------------------
 
BU6CDF
 
Name:
    BU6CDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 6 cumulative distribution function
    with shape parameters r and k.
 
Description:
    The standard Burr type 6 distribution has the following
    cuumulative distribution function:

       F(x;r,k) = (1 + k*EXP(-SINH(x)))**(-r)
                  -INF <  x <  INF; r, k > 0
 
    with r and k denoting the shape parameters.

    This distribution can be generalized with location and
    scale parameters in the usual way using the relation

       F(x;r,k,loc,scale) = F((x-loc)/scale;r,k,0,1)

Syntax:
    LET <y> = BU6CDF(<x>,<r>,<k>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed Burr type 6 cdf value
              is stored;
          <r> is a positive number, parameter, or variable that
              specifies the first shape parameter;
          <k> is a positive number, parameter, or variable that
              specifies the second shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = BU6CDF(0.3,0.2,1.7)
    LET Y = BU6CDF(X,0.5,2.2,0,5)
    PLOT BU6CDF(X,2,1.8) FOR X = -5  0.01  5
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE VI is a synonym for BURR TYPE 6.
 
Related Commands:
    BU6PDF = Compute the Burr type 6 probability density function.
    BU6PPF = Compute the Burr type 6 percent point function.
    BU2PDF = Compute the Burr type 2 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU7PDF = Compute the Burr type 7 probability density function.
    BU8PDF = Compute the Burr type 8 probability density function.
    BU9PDF = Compute the Burr type 9 probability density function.
    B10PDF = Compute the Burr type 10 probability density function.
    B11PDF = Compute the Burr type 11 probability density function.
    B12PDF = Compute the Burr type 12 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Burr (1942), "Cumulative Frequency Functions", Annals of
    Mathematical Statistics, 13, pp. 215-232.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 4 4
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 4
    .
    LET RVAL = DATA 0.5  1  2  5
    LET KVAL = DATA 0.5  1  2  5
    .
    LOOP FOR IROW = 1 1 4
        LOOP FOR ICOL = 1 1 4
            LET R  = RVAL(IROW)
            LET K = KVAL(ICOL)
            TITLE R = ^r, K = ^k
            PLOT BU6CDF(X,R,K) FOR X = -3  0.01  3
        END OF LOOP
    END OF LOOP
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 6 Cumulative Distribution Functions
 
-----BU6PDF (LET)--------------------------------
 
BU6PDF
 
Name:
    BU6PDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 6 probability density function
    with shape parameters r and k.
 
Description:
    The standard Burr type 6 distribution has the following
    probability density function:

       f(x;r,k) = r*k*(1 + k/EXP(SINH(x)))**(-r-1)*COSH(x)/
                  EXP(SINH(x))
                  -INF < x < INF;  r, k > 0
 
    with r and k denoting the shape parameters.

    This distribution can be generalized with location and
    scale parameters in the usual way using the relation

       f(x;r,k,loc,scale) = (1/scale)*f((x-loc)/scale;r,k,0,1)

Syntax:
    LET <y> = BU6PDF(<x>,<r>,<k>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed Burr type 6 pdf value
              is stored;
          <r> is a positive number, parameter, or variable that
              specifies the first shape parameter;
          <k> is a positive number, parameter, or variable that
              specifies the second shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = BU6PDF(0.3,0.2,1.7)
    LET Y = BU6PDF(X,0.5,2.2,0,5)
    PLOT BU6PDF(X,2,1.8) FOR X = -5  0.01  5
 
Note:
    Burr type 6 random numbers, probability plots, and
    goodness of fit tests can be generated with the commands:

       LET R = <value>
       LET K = <value>
       LET Y = BURR TYPE 6 RANDOM NUMBERS FOR I = 1 1 N
       BURR TYPE 6 PROBABILITY PLOT Y
       BURR TYPE 6 PROBABILITY PLOT Y2 X2
       BURR TYPE 6 PROBABILITY PLOT Y3 XLOW XHIGH
       BURR TYPE 6 KOLMOGOROV SMIRNOV GOODNESS OF FIT Y
       BURR TYPE 6 CHI-SQUARE GOODNESS OF FIT Y2 X2
       BURR TYPE 6 CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    The following commands can be used to estimate the r
    shape parameter for the Burr type 6 distribution:

       LET R1 = <value>
       LET R2 = <value>
       BURR TYPE 6 PPCC PLOT Y
       BURR TYPE 6 PPCC PLOT Y2 X2
       BURR TYPE 6 PPCC PLOT Y3 XLOW XHIGH
       BURR TYPE 6 KS PLOT Y
       BURR TYPE 6 KS PLOT Y2 X2
       BURR TYPE 6 KS PLOT Y3 XLOW XHIGH

    The default values for R1 and R2 are 0.5 and 10.

    The probability plot can then be used to estimate the
    location and scale (location = PPA0, scale = PPA1).

    The BOOTSTRAP DISTRIBUTION command can be used to find
    uncertainty intervals for the ppcc plot and ks plot.
       
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE VI is a synonym for BURR TYPE 6.
 
Related Commands:
    BU6CDF = Compute the Burr type 6 cumulative distribution
             function.
    BU6PPF = Compute the Burr type 6 percent point function.
    BU2PDF = Compute the Burr type 2 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU7PDF = Compute the Burr type 7 probability density function.
    BU8PDF = Compute the Burr type 8 probability density function.
    BU9PDF = Compute the Burr type 9 probability density function.
    B10PDF = Compute the Burr type 10 probability density function.
    B11PDF = Compute the Burr type 11 probability density function.
    B12PDF = Compute the Burr type 12 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Burr (1942), "Cumulative Frequency Functions", Annals of
    Mathematical Statistics, 13, pp. 215-232.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program 1:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 4 4
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 4
    .
    LET RVAL = DATA 0.5  1  2  5
    LET KVAL = DATA 0.5  1  2  5
    .
    LOOP FOR IROW = 1 1 4
        LOOP FOR ICOL = 1 1 4
            LET R  = RVAL(IROW)
            LET K = KVAL(ICOL)
            TITLE R = ^r, K = ^k
            PLOT BU6PDF(X,R,K) FOR X = -3  0.01  3
        END OF LOOP
    END OF LOOP
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 6 Probability Density Functions
 
Program 2:
    let r = 2.1
    let k = 1.3
    let rsav = r
    let ksav = k
    .
    let y = burr type 6 random numbers for i = 1 1 200
    let y = 10*y
    let amin = minimum y
    let amax = maximum y
    .
    y1label Correlation Coefficeint
    x1label K (Curves Represent Values of R)
    let r1 = 0.5
    let r2 = 5
    let k1 = 0.5
    let k2 = 3
    burr type 6 ppcc plot y
    let r = shape1
    let k = shape2
    justification center
    move 50 6
    text Rhat = ^r (R = ^rsav), Khat = ^k (K = ^ksav)
    move 50 2
    text Maximum PPCC = ^maxppcc
    .
    y1label Data
    x1label Theoretical
    char x
    line bl
    burr type 6 prob plot y
    move 50 6
    text Location = ^ppa0, Scale = ^ppa1
    char bl
    line so
    .
    let loc = ppa0
    let scale = ppa1
    .
    y1label Relative Frequency
    x1label
    relative hist y
    limits freeze
    pre-erase off
    line color blue
    plot bu6pdf(x,r,k,loc,scale) for x = amin .01 amax
    line color black
    limits 
    pre-erase on
    .
    let ksloc = loc
    let ksscale = scale
    burr type 6 kolmogorov smirnov goodness of fit y

-----BU6PPF (LET)--------------------------------
 
BU6PPF
 
Name:
    BU6PPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 6 percent point function with
    shape parameters r and k.
 
Description:
    The standard Burr type 6 distribution has the following
    percent point function:

       G(p;r,k) = ARCSINH{-LOG((p**(-1/r) - 1)/k)}
                  0 < p < 1; r, k > 0
 
    with r and k denoting the shape parameters.

    This distribution can be generalized with location and
    scale parameters in the usual way using the relation

       G(p;r,k,loc,scale) = loc + scale*G(p;r,k,0,1)

Syntax:
    LET <y> = BU6PPF(<p>,<r>,<k>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or variable in the
              interval (0,1);
          <y> is a variable or a parameter (depending on what
              <p> is) where the computed Burr type 6 ppf value
              is stored;
          <r> is a positive number, parameter, or variable that
              specifies the first shape parameter;
          <k> is a positive number, parameter, or variable that
              specifies the second shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = BU6PPF(0.95,0.2,1.7)
    LET Y = BU6PPF(P,0.5,2.2,0,5)
    PLOT BU6PPF(P,2,1.8) FOR X = 0.01  0.01  0.99
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE VI is a synonym for BURR TYPE 6.
 
Related Commands:
    BU6CDF = Compute the Burr type 6 cumulative disribution
             function.
    BU6PDF = Compute the Burr type 6 probability density function.
    BU2PDF = Compute the Burr type 2 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU7PDF = Compute the Burr type 7 probability density function.
    BU8PDF = Compute the Burr type 8 probability density function.
    BU9PDF = Compute the Burr type 9 probability density function.
    B10PDF = Compute the Burr type 10 probability density function.
    B11PDF = Compute the Burr type 11 probability density function.
    B12PDF = Compute the Burr type 12 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Burr (1942), "Cumulative Frequency Functions", Annals of
    Mathematical Statistics, 13, pp. 215-232.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 4 4
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 4
    .
    LET RVAL = DATA 0.5  1  2  5
    LET KVAL = DATA 0.5  1  2  5
    .
    LOOP FOR IROW = 1 1 4
        LOOP FOR ICOL = 1 1 4
            LET R  = RVAL(IROW)
            LET K = KVAL(ICOL)
            TITLE R = ^r, K = ^k
            PLOT BU6PPF(P,R,K) FOR P = 0.01  0.01  0.99
        END OF LOOP
    END OF LOOP
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 6 Percent Point Functions
 
-----BU7CDF (LET)--------------------------------
 
BU7CDF
 
Name:
    BU7CDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 7 cumulative distribution function
    with shape parameter r.
 
Description:
    The standard Burr type 7 distribution has the following
    cumulative distribution function:

       F(x;r) = 2**(-r)*(1+TANH(x))**r
                -INF <  x <  INF; r > 0
 
    with r denoting the shape parameter.

    This distribution can be generalized with location and
    scale parameters in the usual way using the relation

       F(x;r,loc,scale) = F((x-loc)/scale;r,0,1)

Syntax:
    LET <y> = BU7CDF(<x>,<r>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed Burr type 7 cdf value
              is stored;
          <r> is a positive number, parameter, or variable that
              specifies the shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = BU7CDF(0.3,0.2)
    LET Y = BU7CDF(X,0.5,0,5)
    PLOT BU7CDF(X,2,0,3) FOR X = -3  0.01  3
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE VII is a synonym for BURR TYPE 7.
 
Related Commands:
    BU7PDF = Compute the Burr type 7 probability density function.
    BU7PPF = Compute the Burr type 7 percent point function.
    BU2PDF = Compute the Burr type 2 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU5PDF = Compute the Burr type 7 probability density function.
    BU6PDF = Compute the Burr type 6 probability density function.
    BU8PDF = Compute the Burr type 8 probability density function.
    BU9PDF = Compute the Burr type 9 probability density function.
    B10PDF = Compute the Burr type 10 probability density function.
    B11PDF = Compute the Burr type 11 probability density function.
    B12PDF = Compute the Burr type 12 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Burr (1942), "Cumulative Frequency Functions", Annals of
    Mathematical Statistics, 13, pp. 215-232.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program 1:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    LET R  = 0.5
    TITLE R = ^r
    PLOT BU7CDF(X,R) FOR X = -3  0.01  3
    .
    LET R  = 1
    TITLE R = ^r
    PLOT BU7CDF(X,R) FOR X = -3  0.01  3
    .
    LET R  = 2
    TITLE R = ^r
    PLOT BU7CDF(X,R) FOR X = -3  0.01  3
    .
    LET R  = 5
    TITLE R = ^r
    PLOT BU7CDF(X,R) FOR X = -3  0.01  3
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 7 Cumulative Distribution Functions
 
-----BU7PDF (LET)--------------------------------
 
BU7PDF
 
Name:
    BU7PDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 7 probability density function
    with shape parameter r.
 
Description:
    The standard Burr type 7 distribution has the following
    probability density function:

       f(x;r) = r*SECH(x)**2*(1+TANH(x))**(r-1)/(2**r)
                -INF <  x <  INF; r > 0
 
    with r denoting the shape parameter.

    This distribution can be generalized with location and
    scale parameters in the usual way using the relation

       f(x;r,loc,scale) = (1/scale)*f((x-loc)/scale;r,0,1)

Syntax:
    LET <y> = BU7PDF(<x>,<r>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed Burr type 7 pdf value
              is stored;
          <r> is a positive number, parameter, or variable that
              specifies the shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = BU7PDF(0.3,0.2)
    LET Y = BU7PDF(X,0.5,0,5)
    PLOT BU7PDF(X,2,0,3) FOR X = -3  0.01  3
 
Note:
    Burr type 7 random numbers, probability plots, and
    goodness of fit tests can be generated with the commands:

       LET R = <value>
       LET Y = BURR TYPE 7 RANDOM NUMBERS FOR I = 1 1 N
       BURR TYPE 7 PROBABILITY PLOT Y
       BURR TYPE 7 PROBABILITY PLOT Y2 X2
       BURR TYPE 7 PROBABILITY PLOT Y3 XLOW XHIGH
       BURR TYPE 7 KOLMOGOROV SMIRNOV GOODNESS OF FIT Y
       BURR TYPE 7 CHI-SQUARE GOODNESS OF FIT Y2 X2
       BURR TYPE 7 CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    The following commands can be used to estimate the r
    shape parameter for the Burr type 7 distribution:

       LET R1 = <value>
       LET R2 = <value>
       BURR TYPE 7 PPCC PLOT Y
       BURR TYPE 7 PPCC PLOT Y2 X2
       BURR TYPE 7 PPCC PLOT Y3 XLOW XHIGH
       BURR TYPE 7 KS PLOT Y
       BURR TYPE 7 KS PLOT Y2 X2
       BURR TYPE 7 KS PLOT Y3 XLOW XHIGH

    The default values for R1 and R2 are 0.5 and 10.

    The probability plot can then be used to estimate the
    location and scale (location = PPA0, scale = PPA1).

    The BOOTSTRAP DISTRIBUTION command can be used to find
    uncertainty intervals for the ppcc plot and ks plot.
       
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE VII is a synonym for BURR TYPE 7.
 
Related Commands:
    BU7CDF = Compute the Burr type 7 cumulative distribution
             function.
    BU7PPF = Compute the Burr type 7 percent point function.
    BU2PDF = Compute the Burr type 2 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU5PDF = Compute the Burr type 7 probability density function.
    BU6PDF = Compute the Burr type 6 probability density function.
    BU8PDF = Compute the Burr type 8 probability density function.
    BU9PDF = Compute the Burr type 9 probability density function.
    B10PDF = Compute the Burr type 10 probability density function.
    B11PDF = Compute the Burr type 11 probability density function.
    B12PDF = Compute the Burr type 12 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Burr (1942), "Cumulative Frequency Functions", Annals of
    Mathematical Statistics, 13, pp. 215-232.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program 1:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    LET R  = 0.5
    TITLE R = ^r
    PLOT BU7PDF(X,R) FOR X = -3  0.01  3
    .
    LET R  = 1
    TITLE R = ^r
    PLOT BU7PDF(X,R) FOR X = -3  0.01  3
    .
    LET R  = 2
    TITLE R = ^r
    PLOT BU7PDF(X,R) FOR X = -3  0.01  3
    .
    LET R  = 5
    TITLE R = ^r
    PLOT BU7PDF(X,R) FOR X = -3  0.01  3
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 7 Probability Density Functions
 
Program 2:
   let r = 2.1
   let rsav = r
   .
   let y = burr type 7 random numbers for i = 1 1 200
   let y = 10*y
   let amax = maximum y
   let amin = minimum y
   .
   burr type 7 ppcc plot y
   let rtemp = shape - 2
   let r1 = max(rtemp,0.05)
   let r2 = shape + 2
   y1label Correlation Coefficient
   x1label R
   burr type 7 ppcc plot y
   let r = shape
   justification center
   move 50 6
   text Rhat = ^r (R = ^rsav)
   move 50 2
   text Maximum PPCC = ^maxppcc
   .
   y1label Data
   x1label Theoretical
   char x
   line bl
   burr type 7 prob plot y
   move 50 6
   text Location = ^ppa0, Scale = ^ppa1
   char bl
   line so
   .
   y1label Relative Frequency
   x1label
   relative hist y
   limits freeze
   pre-erase off
   plot bu7pdf(x,r,ppa0,ppa1) for x = amin  0.01  amax
   limits 
   pre-erase on
   .
   let ksloc = ppa0
   let ksscale = ppa1
   burr type 7 kolmogorov smirnov goodness of fit y

-----BU7PPF (LET)--------------------------------
 
BU7PPF
 
Name:
    BU7PPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 7 percent point function with shape
    parameter r.
 
Description:
    The standard Burr type 7 distribution has the following
    percent point function:

       G(p;r) = ARCTANH((2**r*p)**(1/r) - 1)
                0 < p < 1; r > 0
 
    with r denoting the shape parameter.

    This distribution can be generalized with location and
    scale parameters in the usual way using the relation

       G(p;r,loc,scale) = loc + scale*G(p;r,0,1)

Syntax:
    LET <y> = BU7PPF(<p>,<r>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or variable in the
              interval (0,1);
          <y> is a variable or a parameter (depending on what
              <p> is) where the computed Burr type 7 ppf value
              is stored;
          <r> is a positive number, parameter, or variable that
              specifies the shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = BU7PPF(0.95,0.2)
    LET Y = BU7PPF(X,0.5,0,5)
    PLOT BU7PPF(P,2,0,3) FOR X = -5  0.01  5
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE VII is a synonym for BURR TYPE 7.
 
Related Commands:
    BU7PDF = Compute the Burr type 7 probability density function.
    BU7CDF = Compute the Burr type 7 cumulative distribution
             function.
    BU2PDF = Compute the Burr type 2 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU5PDF = Compute the Burr type 7 probability density function.
    BU6PDF = Compute the Burr type 6 probability density function.
    BU8PDF = Compute the Burr type 8 probability density function.
    BU9PDF = Compute the Burr type 9 probability density function.
    B10PDF = Compute the Burr type 10 probability density function.
    B11PDF = Compute the Burr type 11 probability density function.
    B12PDF = Compute the Burr type 12 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Burr (1942), "Cumulative Frequency Functions", Annals of
    Mathematical Statistics, 13, pp. 215-232.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    LET R  = 0.5
    TITLE R = ^r
    PLOT BU7PPF(P,R) FOR P = 0.01  0.01 0.99
    .
    LET R  = 1
    TITLE R = ^r
    PLOT BU7PPF(P,R) FOR P = 0.01  0.01 0.99
    .
    LET R  = 2
    TITLE R = ^r
    PLOT BU7PPF(P,R) FOR P = 0.01  0.01 0.99
    .
    LET R  = 5
    TITLE R = ^r
    PLOT BU7PPF(P,R) FOR P = 0.01  0.01 0.99
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 7 Percent Point Functions
 
-----BU8CDF (LET)--------------------------------
 
BU8CDF
 
Name:
    BU8CDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 8 cumulative distribution function
    with shape parameter r.
 
Description:
    The standard Burr type 8 distribution has the following
    cumulative distribution function:

       F(x;r) = ((2/PI)*ARCTAN(EXP(x)))**r
                -INF <  x <  INF; r > 0
 
    with r denoting the shape parameter.

    This distribution can be generalized with location and
    scale parameters in the usual way using the relation

       F(x;r,loc,scale) = F((x-loc)/scale;r,0,1)

Syntax:
    LET <y> = BU8CDF(<x>,<r>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed Burr type 8 cdf value
              is stored;
          <r> is a positive number, parameter, or variable that
              specifies the shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = BU8CDF(0.3,0.2)
    LET Y = BU8CDF(X,0.5,0,5)
    PLOT BU8CDF(X,2,0,3) FOR X = -3  0.01  3
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE VIII is a synonym for BURR TYPE 8.
 
Related Commands:
    BU8PDF = Compute the Burr type 8 probability density
             function.
    BU8PPF = Compute the Burr type 8 percent point function.
    BU2PDF = Compute the Burr type 2 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU6PDF = Compute the Burr type 6 probability density function.
    BU7PDF = Compute the Burr type 7 probability density function.
    BU9PDF = Compute the Burr type 9 probability density function.
    B10PDF = Compute the Burr type 10 probability density function.
    B11PDF = Compute the Burr type 11 probability density function.
    B12PDF = Compute the Burr type 12 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Burr (1942), "Cumulative Frequency Functions", Annals of
    Mathematical Statistics, 13, pp. 215-232.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    LET R  = 0.5
    TITLE R = ^r
    PLOT BU8CDF(X,R) FOR X = -3  0.01  3
    .
    LET R  = 1
    TITLE R = ^r
    PLOT BU8CDF(X,R) FOR X = -3  0.01  3
    .
    LET R  = 2
    TITLE R = ^r
    PLOT BU8CDF(X,R) FOR X = -3  0.01  3
    .
    LET R  = 5
    TITLE R = ^r
    PLOT BU8CDF(X,R) FOR X = -3  0.01  3
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 8 Cumulative Distribution Functions
 
-----BU8PDF (LET)--------------------------------
 
BU8PDF
 
Name:
    BU8PDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 8 probability density function
    with shape parameter r.
 
Description:
    The standard Burr type 8 distribution has the following
    probability density function:

       f(x;r) = r*EXP(x)*(2/PI)**r*ARCTAN(EXP(x))**(r-1)/
                (1 + EXP(2*X))
                -INF <  x <  INF; r > 0
 
    with r denoting the shape parameter.

    This distribution can be generalized with location and
    scale parameters in the usual way using the relation

       f(x;r,loc,scale) = (1/scale)*f((x-loc)/scale;r,0,1)

Syntax:
    LET <y> = BU8PDF(<x>,<r>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed Burr type 8 pdf value
              is stored;
          <r> is a positive number, parameter, or variable that
              specifies the shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = BU8PDF(0.3,0.2)
    LET Y = BU8PDF(X,0.5,0,5)
    PLOT BU8PDF(X,2,0,3) FOR X = -3  0.01  3
 
Note:
    Burr type 8 random numbers, probability plots, and
    goodness of fit tests can be generated with the commands:

       LET R = <value>
       LET Y = BURR TYPE 8 RANDOM NUMBERS FOR I = 1 1 N
       BURR TYPE 8 PROBABILITY PLOT Y
       BURR TYPE 8 PROBABILITY PLOT Y2 X2
       BURR TYPE 8 PROBABILITY PLOT Y3 XLOW XHIGH
       BURR TYPE 8 KOLMOGOROV SMIRNOV GOODNESS OF FIT Y
       BURR TYPE 8 CHI-SQUARE GOODNESS OF FIT Y2 X2
       BURR TYPE 8 CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    The following commands can be used to estimate the r
    shape parameter for the Burr type 8 distribution:

       LET R1 = <value>
       LET R2 = <value>
       BURR TYPE 8 PPCC PLOT Y
       BURR TYPE 8 PPCC PLOT Y2 X2
       BURR TYPE 8 PPCC PLOT Y3 XLOW XHIGH
       BURR TYPE 8 KS PLOT Y
       BURR TYPE 8 KS PLOT Y2 X2
       BURR TYPE 8 KS PLOT Y3 XLOW XHIGH

    The default values for R1 and R2 are 0.5 and 10.

    The probability plot can then be used to estimate the
    location and scale (location = PPA0, scale = PPA1).

    The BOOTSTRAP DISTRIBUTION command can be used to find
    uncertainty intervals for the ppcc plot and ks plot.
       
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE VIII is a synonym for BURR TYPE 8.
 
Related Commands:
    BU8CDF = Compute the Burr type 8 cumulative distribution
             function.
    BU8PPF = Compute the Burr type 8 percent point function.
    BU2PDF = Compute the Burr type 2 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU6PDF = Compute the Burr type 6 probability density function.
    BU7PDF = Compute the Burr type 7 probability density function.
    BU9PDF = Compute the Burr type 9 probability density function.
    B10PDF = Compute the Burr type 10 probability density function.
    B11PDF = Compute the Burr type 11 probability density function.
    B12PDF = Compute the Burr type 12 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Burr (1942), "Cumulative Frequency Functions", Annals of
    Mathematical Statistics, 13, pp. 215-232.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program 1:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    LET R  = 0.5
    TITLE R = ^r
    PLOT BU8PDF(X,R) FOR X = -3  0.01  3
    .
    LET R  = 1
    TITLE R = ^r
    PLOT BU8PDF(X,R) FOR X = -3  0.01  3
    .
    LET R  = 2
    TITLE R = ^r
    PLOT BU8PDF(X,R) FOR X = -3  0.01  3
    .
    LET R  = 5
    TITLE R = ^r
    PLOT BU8PDF(X,R) FOR X = -3  0.01  3
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 7 Probability Density Functions
 
Program 2:
   let r = 2.1
   let rsav = r
   .
   let y = burr type 8 random numbers for i = 1 1 200
   let y = 10*y
   let amax = maximum y
   let amin = minimum y
   .
   burr type 8 ppcc plot y
   let rtemp = shape - 2
   let r1 = max(rtemp,0.05)
   let r2 = shape + 2
   y1label Correlation Coefficient
   x1label R
   burr type 8 ppcc plot y
   let r = shape
   justification center
   move 50 6
   text Rhat = ^r (R = ^rsav)
   move 50 2
   text Maximum PPCC = ^maxppcc
   .
   y1label Data
   x1label Theoretical
   char x
   line bl
   burr type 8 prob plot y
   move 50 6
   text Location = ^ppa0, Scale = ^ppa1
   char bl
   line so
   .
   y1label Relative Frequency
   x1label
   relative hist y
   limits freeze
   pre-erase off
   plot bu7pdf(x,r,ppa0,ppa1) for x = amin  0.01  amax
   limits 
   pre-erase on
   .
   let ksloc = ppa0
   let ksscale = ppa1
   burr type 8 kolmogorov smirnov goodness of fit y

-----BU8PPF (LET)--------------------------------
 
BU8PPF
 
Name:
    BU8PPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 8 percent point function
    with shape parameter r.
 
Description:
    The standard Burr type 8 distribution has the following
    percent point function:

       G(p;r) = LOG(TAN(PI*p**(1/r)/2))
                0 < p < 1; r > 0
 
    with r denoting the shape parameter.

    This distribution can be generalized with location and
    scale parameters in the usual way using the relation

       G(p;r,loc,scale) = loc + scale*G(p;r,0,1)

Syntax:
    LET <y> = BU8PPF(<p>,<r>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or variable in the
              interval (0,1);
          <y> is a variable or a parameter (depending on what
              <p> is) where the computed Burr type 8 ppf value
              is stored;
          <r> is a positive number, parameter, or variable that
              specifies the shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = BU8PPF(0.95,0.2)
    LET Y = BU8PPF(P,0.99,0,5)
    PLOT BU8PPF(P,2,0,3) FOR P = 0.01  0.01  0.99
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE VIII is a synonym for BURR TYPE 8.
 
Related Commands:
    BU8PDF = Compute the Burr type 8 probability density
             function.
    BU8CDF = Compute the Burr type 8 cumulative distribution
             function.
    BU2PDF = Compute the Burr type 2 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU6PDF = Compute the Burr type 6 probability density function.
    BU7PDF = Compute the Burr type 7 probability density function.
    BU9PDF = Compute the Burr type 9 probability density function.
    B10PDF = Compute the Burr type 10 probability density function.
    B11PDF = Compute the Burr type 11 probability density function.
    B12PDF = Compute the Burr type 12 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Burr (1942), "Cumulative Frequency Functions", Annals of
    Mathematical Statistics, 13, pp. 215-232.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    LET R  = 0.5
    TITLE R = ^r
    PLOT BU8PPF(P,R) FOR P = 0.01  0.01  0.99
    .
    LET R  = 1
    TITLE R = ^r
    PLOT BU8PPF(P,R) FOR P = 0.01  0.01  0.99
    .
    LET R  = 2
    TITLE R = ^r
    PLOT BU8PPF(P,R) FOR P = 0.01  0.01  0.99
    .
    LET R  = 5
    TITLE R = ^r
    PLOT BU8PPF(P,R) FOR P = 0.01  0.01  0.99
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 8 Percent Point Functions
 
-----BU9CDF (LET)--------------------------------
 
BU9CDF
 
Name:
    BU9CDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 9 cumulative distribution function
    with shape parameters r and k.
 
Description:
    The standard Burr type 9 distribution has the following
    cuumulative distribution function:

       F(x;r,k) = 1 - 2/{2 + k*((1+EXP(x))**r - 1)}
                  -INF <  x <  INF; r, k > 0
 
    with r and k denoting the shape parameters.

    This distribution can be generalized with location and
    scale parameters in the usual way using the relation

       F(x;r,k,loc,scale) = F((x-loc)/scale;r,k,0,1)

Syntax:
    LET <y> = BU9CDF(<x>,<r>,<k>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed Burr type 9 cdf value
              is stored;
          <r> is a positive number, parameter, or variable that
              specifies the first shape parameter;
          <k> is a positive number, parameter, or variable that
              specifies the second shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = BU9CDF(0.3,0.2,1.7)
    LET Y = BU9CDF(X,0.5,2.2,0,5)
    PLOT BU9CDF(X,2,1.8) FOR X = -5  0.01  5
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE IX is a synonym for BURR TYPE 9.
 
Related Commands:
    BU9PDF = Compute the Burr type 9 probability density function.
    BU9PPF = Compute the Burr type 9 percent point function.
    BU2PDF = Compute the Burr type 2 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU6PDF = Compute the Burr type 6 probability density function.
    BU7PDF = Compute the Burr type 7 probability density function.
    BU8PDF = Compute the Burr type 8 probability density function.
    B10PDF = Compute the Burr type 10 probability density function.
    B11PDF = Compute the Burr type 11 probability density function.
    B12PDF = Compute the Burr type 12 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Burr (1942), "Cumulative Frequency Functions", Annals of
    Mathematical Statistics, 13, pp. 215-232.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 4 4
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 4
    .
    LET RVAL = DATA 0.5  1  2  5
    LET KVAL = DATA 0.5  1  2  5
    .
    LOOP FOR IROW = 1 1 4
        LOOP FOR ICOL = 1 1 4
            LET R  = RVAL(IROW)
            LET K = KVAL(ICOL)
            TITLE R = ^r, K = ^k
            PLOT BU9CDF(X,R,K) FOR X = -3  0.01  3
        END OF LOOP
    END OF LOOP
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 9 Cumulative Distribution Functions
 
-----BU9PDF (LET)--------------------------------
 
BU9PDF
 
Name:
    BU9PDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 9 probability density function
    with shape parameters r and k.
 
Description:
    The standard Burr type 9 distribution has the following
    probability density function:

       f(x;r,k) = 2*EXP(x)*(1+EXP(x))**(r-1)*k*r/
                  (2 + k*(-1+(1+EXP(x))**r))**2
                  -INF < x < INF;  r, k > 0
 
    with r and k denoting the shape parameters.

    This distribution can be generalized with location and
    scale parameters in the usual way using the relation

       f(x;r,k,loc,scale) = (1/scale)*f((x-loc)/scale;r,k,0,1)

Syntax:
    LET <y> = BU9PDF(<x>,<r>,<k>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed Burr type 9 pdf value
              is stored;
          <r> is a positive number, parameter, or variable that
              specifies the first shape parameter;
          <k> is a positive number, parameter, or variable that
              specifies the second shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = BU9PDF(0.3,0.2,1.7)
    LET Y = BU9PDF(X,0.5,2.2,0,5)
    PLOT BU9PDF(X,2,1.8) FOR X = -5  0.01  5
 
Note:
    Burr type 9 random numbers, probability plots, and
    goodness of fit tests can be generated with the commands:

       LET R = <value>
       LET K = <value>
       LET Y = BURR TYPE 9 RANDOM NUMBERS FOR I = 1 1 N
       BURR TYPE 9 PROBABILITY PLOT Y
       BURR TYPE 9 PROBABILITY PLOT Y2 X2
       BURR TYPE 9 PROBABILITY PLOT Y3 XLOW XHIGH
       BURR TYPE 9 KOLMOGOROV SMIRNOV GOODNESS OF FIT Y
       BURR TYPE 9 CHI-SQUARE GOODNESS OF FIT Y2 X2
       BURR TYPE 9 CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    The following commands can be used to estimate the r
    shape parameter for the Burr type 9 distribution:

       LET R1 = <value>
       LET R2 = <value>
       BURR TYPE 9 PPCC PLOT Y
       BURR TYPE 9 PPCC PLOT Y2 X2
       BURR TYPE 9 PPCC PLOT Y3 XLOW XHIGH
       BURR TYPE 9 KS PLOT Y
       BURR TYPE 9 KS PLOT Y2 X2
       BURR TYPE 9 KS PLOT Y3 XLOW XHIGH

    The default values for R1 and R2 are 0.5 and 10.

    The probability plot can then be used to estimate the
    location and scale (location = PPA0, scale = PPA1).

    The BOOTSTRAP DISTRIBUTION command can be used to find
    uncertainty intervals for the ppcc plot and ks plot.
       
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE IX is a synonym for BURR TYPE 9.
 
Related Commands:
    BU9CDF = Compute the Burr type 9 cumulative distribution
             function.
    BU9PPF = Compute the Burr type 9 percent point function.
    BU2PDF = Compute the Burr type 2 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU6PDF = Compute the Burr type 6 probability density function.
    BU7PDF = Compute the Burr type 7 probability density function.
    BU8PDF = Compute the Burr type 8 probability density function.
    B10PDF = Compute the Burr type 10 probability density function.
    B11PDF = Compute the Burr type 11 probability density function.
    B12PDF = Compute the Burr type 12 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Burr (1942), "Cumulative Frequency Functions", Annals of
    Mathematical Statistics, 13, pp. 215-232.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program 1:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 4 4
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 4
    .
    LET RVAL = DATA 0.5  1  2  5
    LET KVAL = DATA 0.5  1  2  5
    .
    LOOP FOR IROW = 1 1 4
        LOOP FOR ICOL = 1 1 4
            LET R  = RVAL(IROW)
            LET K = KVAL(ICOL)
            TITLE R = ^r, K = ^k
            PLOT BU9PDF(X,R,K) FOR X = -3  0.01  3
        END OF LOOP
    END OF LOOP
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 9 Probability Density Functions
 
Program 2:
    let r = 2.1
    let k = 1.3
    let rsav = r
    let ksav = k
    .
    let y = burr type 9 random numbers for i = 1 1 200
    let y = 10*y
    let amin = minimum y
    let amax = maximum y
    .
    y1label Correlation Coefficeint
    x1label K (Curves Represent Values of R)
    let r1 = 0.5
    let r2 = 5
    let k1 = 0.5
    let k2 = 3
    burr type 9 ppcc plot y
    let r = shape1
    let k = shape2
    justification center
    move 50 6
    text Rhat = ^r (R = ^rsav), Khat = ^k (K = ^ksav)
    move 50 2
    text Maximum PPCC = ^maxppcc
    .
    y1label Data
    x1label Theoretical
    char x
    line bl
    burr type 9 prob plot y
    move 50 6
    text Location = ^ppa0, Scale = ^ppa1
    char bl
    line so
    .
    let loc = ppa0
    let scale = ppa1
    .
    y1label Relative Frequency
    x1label
    relative hist y
    limits freeze
    pre-erase off
    line color blue
    plot bu9pdf(x,r,k,loc,scale) for x = amin .01 amax
    line color black
    limits 
    pre-erase on
    .
    let ksloc = loc
    let ksscale = scale
    burr type 9 kolmogorov smirnov goodness of fit y

-----BU9PPF (LET)--------------------------------
 
BU9PPF
 
Name:
    BU9PPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 9 percent point function with
    shape parameters r and k.
 
Description:
    The standard Burr type 9 distribution has the following
    percent point function:

       G(p;r,k) = LOG{[1 + (1/k)*(2/(1-p) - 2)]**(1/r) - 1}
                  0 < p < 1; r, k > 0
 
    with r and k denoting the shape parameters.

    This distribution can be generalized with location and
    scale parameters in the usual way using the relation

       G(p;r,k,loc,scale) = loc + scale*G(p;r,k,0,1)

Syntax:
    LET <y> = BU9PPF(<p>,<r>,<k>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or variable in the
              interval (0,1);
          <y> is a variable or a parameter (depending on what
              <p> is) where the computed Burr type 9 ppf value
              is stored;
          <r> is a positive number, parameter, or variable that
              specifies the first shape parameter;
          <k> is a positive number, parameter, or variable that
              specifies the second shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = BU9PPF(0.95,0.2,1.7)
    LET Y = BU9PPF(P,0.5,2.2,0,5)
    PLOT BU9PPF(P,2,1.8) FOR X = 0.01  0.01  0.99
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE IX is a synonym for BURR TYPE 9.
 
Related Commands:
    BU9CDF = Compute the Burr type 9 cumulative disribution
             function.
    BU9PDF = Compute the Burr type 9 probability density function.
    BU2PDF = Compute the Burr type 2 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU6PDF = Compute the Burr type 6 probability density function.
    BU7PDF = Compute the Burr type 7 probability density function.
    BU8PDF = Compute the Burr type 8 probability density function.
    B10PDF = Compute the Burr type 10 probability density function.
    B11PDF = Compute the Burr type 11 probability density function.
    B12PDF = Compute the Burr type 12 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Burr (1942), "Cumulative Frequency Functions", Annals of
    Mathematical Statistics, 13, pp. 215-232.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 4 4
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 4
    .
    LET RVAL = DATA 0.5  1  2  5
    LET KVAL = DATA 0.5  1  2  5
    .
    LOOP FOR IROW = 1 1 4
        LOOP FOR ICOL = 1 1 4
            LET R  = RVAL(IROW)
            LET K = KVAL(ICOL)
            TITLE R = ^r, K = ^k
            PLOT BU9PPF(P,R,K) FOR P = 0.01  0.01  0.99
        END OF LOOP
    END OF LOOP
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 9 Percent Point Functions
 
-----BVNCDF (LET)--------------------------------
 
BVNCDF
 
Name:
    BVNCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the bivariate normal cumulative distribution function with
    zero means, standard deviations of one, and a correlation of p.
 
Description:
    The cumulative distribution function for the standard bivariate 
    normal distribution has the formula:
        F(x1,x2,p)=(1/(2*PI*SQRT(1-p**2)))*
              INT1(INT2(EXP(-(u**2-2*p*u*v+v**2)/(2*(1-p)))))dudv
    where INT1 is the integral from -infinity to x1 and INT2 is the
    integral from -infinity to x2.
 
    The first two input values can be any real number.  The third input
    argument should be in the interval (-1,1).
 
    A correlation of +/-1 is treated as a special case.  In this case,
    the univariate normal cdf function is used with the minimum of x1
    and x2 as the argument.

Syntax:
    LET <y> = BVNCDF(<x1>,<x2>,<p>)  <SUBSET/EXCEPT/FOR qualification>
    where <x1> is a number, parameter, or variable;
          <x2> is a number, parameter, or variable;
          <p> is a number, parameter, or variable in the interval
               (-1,1);
          <y> is a variable or a parameter (depending on what <x1>,
               <x2>, and <p> are) where the computed cdf values are 
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BVNCDF(-2,-2,0)
    LET A = BVNCDF(-2,-2,.8)
    LET X2 = BVNCDF(H,K,CORR)
 
Note:
    For a non-standard bivariate normal distribution with means XBAR1
    and XBAR2 and standard deviations SD1 and SD2, calculate the cdf by
    doing something like the following:

        LET H = -2
        LET K = -1
        LET P = 0
        LET X1 = (H-XBAR1)/SD1
        LET X2 = (K-XBAR2)/SD2
        LET CDF = BVNCDF(X1,X2,P)
        PRINT "CDF VALUE FOR ^H, ^K, AND ^P = ^H, ^K, ^CDF"
 
Note:
    DATAPLOT uses the algorithm of Owen (see REFERENCE section below)
    to compute the bivariate cdf value.  It uses algorithm AS R80 to
    compute an integral used by this method.  The AS R80 algorithm was
    obtained from the statlib archive.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
    FCDF   = Compute the F cumulative distribution function.
    FPDF   = Compute the F probability density function.
    FPPF   = Compute the F percent point function.
    TCDF   = Compute the T cumulative distribution function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
 
Reference:
    "Tables for Computing Bivariate Normal Probabilities", Owen, 
    Annals of Mathematical Statistics, Volume 27, 1956 (pp. 1075-1090).

    "Algorithm AS R80, A Remark on Algorithm AS 76: An Integral Useful
    in Calculating Noncentral t and Bivariate Normal Probabilities",
    Boys, Applied Statistics, Volume 38, No. 3, 1989.

    "Continuous Univariate Distributions", Johnson and Kotz, 1970.
 
Applications:
    XX
 
Implementation Date:
    94/10
 
Program:
    TITLE AUTOMATIC
    LET X2 = -2
    PLOT BVNCDF(X1,X2,0) FOR X1 = -3. 0.1 3
    LET X2 = 2
    PLOT BVNCDF(X1,X2,0) FOR X1 = -3. 0.1 3
    PLOT BVNCDF(X1,X2,0.5) FOR X1 = -2. 0.2 2 FOR X2 = -2 0.2 2
 
-----BVNPDF (LET)--------------------------------
 
BVNPDF
 
Name:
    BVNPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the bivariate normal probability density function with
    zero means, standard deviations of one, and a correlation of p.
 
Description:
    The probability densityfunction for the standard bivariate normal
    distribution has the formula:
        f(x1,x2,p)=(1/(2*PI*SQRT(1-p**2)))*
                     EXP(-(x1**2-2*p*x1*x2+x2**2)/(2*(1-p)))
    This function can be calculated from the univariate normal density
    function with the formula:
        f(x1,x2,p)=(1/sqrt(1-p**2))*NORPDF(x1)*
                     NORPDF((x2-p*x1)/SQRT(1-p**2))
 
    The first two input values can be any real number.  The third input
    argument should be in the interval (-1,1).  Correlation values
    exactly equal to 1 are undefined.
 
Syntax:
    LET <y> = BVNPDF(<x1>,<x2>,<p>)  <SUBSET/EXCEPT/FOR qualification>
    where <x1> is a number, parameter, or variable;
          <x2> is a number, parameter, or variable;
          <p> is a number, parameter, or variable in the interval
               (-1,1);
          <y> is a variable or a parameter (depending on what <x1>,
               <x2>, and <p> are) where the computed pdf values are 
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BVNPDF(-2,-2,0)
    LET A = BVNPDF(-2,-2,.8)
    LET Y = BVNPDF(H,K,CORR)
 
Note:
    For a non-standard bivariate normal distribution with means XBAR1
    and XBAR2 and standard deviations SD1 and SD2, calculate the pdf
    as follows:

        LET CONST = (1/(SD1*SD2))
        LET PDF = CONST*BVNPDF((X1-XBAR1)/SD1,(X2-XBAR2)/SD2,P)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BVNCDF = Compute the bivariate normal cumulative distribution
             function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series
    Vol. 55", Abramowitz and Stegum, National Bureau of Standards,
    1964.

Applications:
    Data Analysis
 
Implementation Date:
    95/9
 
Program:
    TITLE AUTOMATIC
    3D-PLOT BVNPDF(X1,X2,0) FOR X1 = -3. 0.2 3 FOR X2 = -3 0.2 3
 
-----BYE--------------------------------------------------------
 
BYE
 
Name:
    BYE
 
Type:
    Support Command
 
Purpose:
    End a DATAPLOT session.
 
Syntax:
    BYE
 
Examples:
    BYE
 
Default:
    Off
 
Synonyms:
    STOP
    QUIT
    END
    HALT
 
Related Commands:
    XX
 
Applications:
    Session Management
 
Implementation Date:
    Pre-1987
 
Program:
    XX
 
-----BWECDF (LET)--------------------------------
 
BWECDF
 
Name:
    BWECDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Bi-Weibull cumulative distribution function with
    shape parameters SCALE1, GAMMA1, LOC2, SCALE2, and GAMMA2.
 
Description:
    The Bi-Weibull distribution is a mixture of two Weibull
    distributions: a "burn-in" Weibull and a "wear out" Weibull.
    This makes it a very flexible distribution for reliability
    applications.

    The cumulative distribution function for the bi-Weibull
    distribution is:

       F(x,s1,g1,mu2,s2,g2) =
           1 - EXP[-(x/x1)**g1]                         0 < X < MU2
           1 - EXP[-{(x/s1)**g1 + ((x-mu2)/s2)**g2}]    X > MU2

           s1, g1, s2, g2 > 0
           mu2 >= 0

    This is a mixture of a 2-parameter Weibull (the
    burn-in) and a 3-parameter Weibull (the wear out).  This
    is related to, but slightly different than, the standard
    Weibull mixture which is simply a weighted sum of two or
    more Weibull distributions.

    Note that Evans, Hastings, and Peacock define the first
    scale parameter as the reciprocal of what we have defined
    above.

Syntax:
    LET <y> = BWECDF(<x>,<scale1>,<gamma>,<loc2>,<scale2>,<gamma2>)
                         <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed Bi-Weibull cumulative distribution
               value is stored;
          <scale1> is a positive number, parameter, or variable that
               specifies the scale parameter for the first Weibull
               component;
          <gamma1> is a positive number, parameter, or variable that
               specifies the shape parameter for the first Weibull
               component;
          <loc2> is a positive number, parameter, or variable that
               specifies the location parameter for the second Weibull
               component;
          <scale2> is a positive number, parameter, or variable that
               specifies the scale parameter for the second Weibull
               component;
          <gamma2> is a positive number, parameter, or variable that
               specifies the shape parameter for the second Weibull
               component;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BWECDF(3,10,0.6,4,5,2.5)
    LET A = BWECDF(X,S1,G1,L2,S2,G2)
    PLOT BWECDF(X,10,0.7,4,4,3) FOR X = 0.01 0.01 15
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BWECHAZ = Compute the Bi-Weibull cumulative hazard function.
    BWEHAZ  = Compute the Bi-Weibull hazard function.
    BWEPDF  = Compute the Bi-Weibull probability density function.
    BWEPPF  = Compute the Bi-Weibull percent point function.
    WEIPDF  = Compute the Weibull probability density function.
    EXPPDF  = Compute the exponential probability density function.
    LGNPDF  = Compute the lognormal probability density function.
 
Reference:
    "Statistical Distributions", Third Edition, Evans, Hastings, and
    Peacock, Wiley and Sons, 2001.
 
Applications:
    Reliability Analysis
 
Implementation Date:
    2002/5
 
Program:
    LET SCALE1 = 10
    LET GAMMA1 = 0.7
    LET LOC2 = 4
    LET SCALE2 = 4
    LET GAMMA2 = 3
    Y1LABEL PROBABILITY
    X1LABEL X
    TITLE BI-WEIBULL CUMULATIVE DISTRIBUTION FUNCTION CR() ...
     S1 = ^SCALE1, G1 = ^GAMMA1, LOC2 = ^LOC2, S2 = ^SCALE2, G2 = ^GAMMA2
    PLOT BWECDF(X,SCALE1,GAMMA1,LOC2,SCALE2,GAMMA2) FOR X = .01 .01 10
 
-----BWECHAZ (LET)--------------------------------
 
BWECHAZ
 
Name:
    BWECHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Bi-Weibull cumulative hazard function with shape
    parameters SCALE1, GAMMA1, LOC2, SCALE2, and GAMMA2.
 
Description:
    The Bi-Weibull distribution is a mixture of two Weibull
    distributions: a "burn-in" Weibull and a "wear out" Weibull.
    This makes it a very flexible distribution for reliability
    applications.

    The cumulative hazard function for the bi-Weibull distribution
    is computed as:

       h(x,scale1,gamma1,loc2,scale2,gamma2) =
           -LOG(F(x,scale1,gamma1,loc2,scale2,gamma2))

           scale1, gamma1, scale2, gamma2 > 0
           loc2 >= 0

    with F denoting the cumulative distribution function of
    the Bi-Weibull distribution.

    This is a mixture of a 2-parameter Weibull (the
    burn-in) and a 3-parameter Weibull (the wear out).  This
    is related to, but slightly different than, the standard
    Weibull mixture which is simply a weighted sum of two or
    more Weibull distributions.

    Note that Evans, Hastings, and Peacock define the first
    scale parameter as the reciprocal of what we have defined
    above.

Syntax:
    LET <y> = BWECHAZ(<x>,<scale1>,<gamma>,<loc2>,<scale2>,<gamma2>)
                         <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed Bi-Weibull cumulative hazard value
               is stored;
          <scale1> is a positive number, parameter, or variable that
               specifies the scale parameter for the first Weibull
               component;
          <gamma1> is a positive number, parameter, or variable that
               specifies the shape parameter for the first Weibull
               component;
          <loc2> is a positive number, parameter, or variable that
               specifies the location parameter for the second Weibull
               component;
          <scale2> is a positive number, parameter, or variable that
               specifies the scale parameter for the second Weibull
               component;
          <gamma2> is a positive number, parameter, or variable that
               specifies the shape parameter for the second Weibull
               component;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BWECHAZ(3,10,0.6,4,5,2.5)
    LET A = BWECHAZ(X,S1,G1,L2,S2,G2)
    PLOT BWECHAZ(X,10,0.7,4,4,3) FOR X = 0.01 0.01 15
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BWEHAZ  = Compute the Bi-Weibull hazard function.
    BWECDF  = Compute the Bi-Weibull cumulative distribution function.
    BWEPDF  = Compute the Bi-Weibull probability density function.
    BWEPPF  = Compute the Bi-Weibull percent point function.
    WEIPDF  = Compute the Weibull probability density function.
    EXPPDF  = Compute the exponential probability density function.
    LGNPDF  = Compute the lognormal probability density function.
 
Reference:
    "Statistical Distributions", Third Edition, Evans, Hastings, and
    Peacock, Wiley and Sons, 2001.
 
Applications:
    Reliability Analysis
 
Implementation Date:
    2002/5
 
Program:
    LET SCALE1 = 10
    LET GAMMA1 = 0.7
    LET LOC2 = 4
    LET SCALE2 = 4
    LET GAMMA2 = 3
    Y1LABEL CUMULATIVE HAZARD
    X1LABEL X
    TITLE BI-WEIBULL CUMULATIVE HAZARD FUNCTION CR() ...
     S1 = ^SCALE1, G1 = ^GAMMA1, LOC2 = ^LOC2, S2 = ^SCALE2, G2 = ^GAMMA2
    PLOT BWECHAZ(X,SCALE1,GAMMA1,LOC2,SCALE2,GAMMA2) FOR X = .01 .01 10
 
-----BWEHAZ (LET)--------------------------------
 
BWEHAZ
 
Name:
    BWEHAZ (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Bi-Weibull hazard function with shape parameters
    SCALE1, GAMMA1, LOC2, SCALE2, and GAMMA2.
 
Description:
    The Bi-Weibull distribution is a mixture of two Weibull
    distributions: a "burn-in" Weibull and a "wear out" Weibull.
    This makes it a very flexible distribution for reliability
    applications.

    The hazard function for the bi-Weibull distribution is:

       h(x,scale1,gamma1,loc2,scale2,gamma2) =
           (1/scale1)*gamma1*(X/scale1)**(gamma1-1)      0 < x < loc2
           (1/scale1)*gamma1*(X/scale1)**(gamma1-1) +
           (gamma2/scale2)*((x-loc2)/scale2)**(gamma2-1)   x >= loc2

           scale1, gamma1, scale2, gamma2 > 0
           loc2 >= 0

    This is a mixture of a 2-parameter Weibull (the
    burn-in) and a 3-parameter Weibull (the wear out).  This
    is related to, but slightly different than, the standard
    Weibull mixture which is simply a weighted sum of two or
    more Weibull distributions.

    Note that Evans, Hastings, and Peacock define the first
    scale parameter as the reciprocal of what we have defined
    above.

Syntax:
    LET <y> = BWEHAZ(<x>,<scale1>,<gamma>,<loc2>,<scale2>,<gamma2>)
                         <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed Bi-Weibull hazard value is stored;
          <scale1> is a positive number, parameter, or variable that
               specifies the scale parameter for the first Weibull
               component;
          <gamma1> is a positive number, parameter, or variable that
               specifies the shape parameter for the first Weibull
               component;
          <loc2> is a positive number, parameter, or variable that
               specifies the location parameter for the second Weibull
               component;
          <scale2> is a positive number, parameter, or variable that
               specifies the scale parameter for the second Weibull
               component;
          <gamma2> is a positive number, parameter, or variable that
               specifies the shape parameter for the second Weibull
               component;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BWEHAZ(3,10,0.6,4,5,2.5)
    LET A = BWEHAZ(X,S1,G1,L2,S2,G2)
    PLOT BWEHAZ(X,10,0.7,4,4,3) FOR X = 0.01 0.01 15
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BWECHAZ = Compute the Bi-Weibull cumulative hazard function.
    BWECDF  = Compute the Bi-Weibull cumulative distribution function.
    BWEPDF  = Compute the Bi-Weibull probability density function.
    BWEPPF  = Compute the Bi-Weibull percent point function.
    WEIPDF  = Compute the Weibull probability density function.
    EXPPDF  = Compute the exponential probability density function.
    LGNPDF  = Compute the lognormal probability density function.
 
Reference:
    "Statistical Distributions", Third Edition, Evans, Hastings, and
    Peacock, Wiley and Sons, 2001.
 
Applications:
    Reliability Analysis
 
Implementation Date:
    2002/5
 
Program:
    LET SCALE1 = 10
    LET GAMMA1 = 0.7
    LET LOC2 = 4
    LET SCALE2 = 4
    LET GAMMA2 = 3
    Y1LABEL HAZARD
    X1LABEL X
    TITLE BI-WEIBULL HAZARD FUNCTION CR() ...
     S1 = ^SCALE1, G1 = ^GAMMA1, LOC2 = ^LOC2, S2 = ^SCALE2, G2 = ^GAMMA2
    PLOT BWEHAZ(X,SCALE1,GAMMA1,LOC2,SCALE2,GAMMA2) FOR X = .01 .01 10

-----BWEPDF (LET)--------------------------------
 
BWEPDF
 
Name:
    BWEPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Bi-Weibull probability density function with shape
    parameters SCALE1, GAMMA1, LOC2, SCALE2, and GAMMA2.
 
Description:
    The Bi-Weibull distribution is a mixture of two Weibull
    distributions: a "burn-in" Weibull and a "wear out" Weibull.
    This makes it a very flexible distribution for reliability
    applications.

    The probability density function for the bi-Weibull distribution
    is computed as:

       f(x,scale1,gamma1,loc2,scale2,gamma2) =
           h(x,scale1,gamma1,loc2,scale2,gamma2)*
           (1 - F(x,scale1,gamma1,loc2,scale2,gamma2))

           scale1, gamma1, scale2, gamma2 > 0
           loc2 >= 0

    with F denoting the cumulative distribution function and h
    the hazard function of the Bi-Weibull distribution.  The
    formulas for the cumulative distribution and hazard functions
    can be obtained from HELP BWECDF and HELP BWEHAZ, respectively.

    This is a mixture of a 2-parameter Weibull (the
    burn-in) and a 3-parameter Weibull (the wear out).  This
    is related to, but slightly different than, the standard
    Weibull mixture which is simply a weighted sum of two or
    more Weibull distributions.

    Note that Evans, Hastings, and Peacock define the first
    scale parameter as the reciprocal of what we have defined
    above.

Syntax:
    LET <y> = BWEPDF(<x>,<scale1>,<gamma>,<loc2>,<scale2>,<gamma2>)
                         <SUBSET/EXCEPT/FOR qualification>
    where <x> is a variable, number, or parameter;
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed Bi-Weibull pdf value is stored;
          <scale1> is a positive number, parameter, or variable that
               specifies the scale parameter for the first Weibull
               component;
          <gamma1> is a positive number, parameter, or variable that
               specifies the shape parameter for the first Weibull
               component;
          <loc2> is a positive number, parameter, or variable that
               specifies the location parameter for the second Weibull
               component;
          <scale2> is a positive number, parameter, or variable that
               specifies the scale parameter for the second Weibull
               component;
          <gamma2> is a positive number, parameter, or variable that
               specifies the shape parameter for the second Weibull
               component;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BWEPDF(3,10,0.6,4,5,2.5)
    LET A = BWEPDF(X,S1,G1,L2,S2,G2)
    PLOT BWEPDF(X,10,0.7,4,4,3) FOR X = 0.01 0.01 15
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BWEHAZ  = Compute the Bi-Weibull hazard function.
    BWECHAZ = Compute the Bi-Weibull cumulative hazard function.
    BWECDF  = Compute the Bi-Weibull cumulative distribution function.
    BWEPPF  = Compute the Bi-Weibull percent point function.
    WEIPDF  = Compute the Weibull probability density function.
    EXPPDF  = Compute the exponential probability density function.
    LGNPDF  = Compute the lognormal probability density function.
 
Reference:
    "Statistical Distributions", Third Edition, Evans, Hastings, and
    Peacock, Wiley and Sons, 2001.
 
Applications:
    Reliability Analysis
 
Implementation Date:
    2002/5
 
Program:
    LET SCALE1 = 10
    LET GAMMA1 = 0.7
    LET LOC2 = 4
    LET SCALE2 = 4
    LET GAMMA2 = 3
    Y1LABEL CUMULATIVE HAZARD
    X1LABEL X
    TITLE BI-WEIBULL PROBABILITY DENSITY FUNCTION CR() ...
     S1 = ^SCALE1, G1 = ^GAMMA1, LOC2 = ^LOC2, S2 = ^SCALE2, G2 = ^GAMMA2
    PLOT BWEPDF(X,SCALE1,GAMMA1,LOC2,SCALE2,GAMMA2) FOR X = .01 .01 10
 
-----BWEPPF (LET)--------------------------------
 
BWEPPF
 
Name:
    BWEPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Bi-Weibull percent point function with shape
    parameters SCALE1, GAMMA1, LOC2, SCALE2, and GAMMA2.
 
Description:
    The Bi-Weibull distribution is a mixture of two Weibull
    distributions: a "burn-in" Weibull and a "wear out" Weibull.
    This makes it a very flexible distribution for reliability
    applications.

    For p <= BWECDF(mu2), the percent point function for the
    bi-Weibull distribution is computed as:

       G(p,scale1,gamma1,loc2,scale2,gamma2) =
           scale1*(LOG(1/(1-p)))**(1/g1)

           scale1, gamma1, scale2, gamma2 > 0
           loc2 >= 0

    For p > BWECDF(mu2), the percent point function for the
    bi-Weibull distribution is computed numerically using a
    bisection method.

    This is a mixture of a 2-parameter Weibull (the
    burn-in) and a 3-parameter Weibull (the wear out).  This
    is related to, but slightly different than, the standard
    Weibull mixture which is simply a weighted sum of two or
    more Weibull distributions.

    Note that Evans, Hastings, and Peacock define the first
    scale parameter as the reciprocal of what we have defined
    above.

Syntax:
    LET <y> = BWEPPF(<p>,<scale1>,<gamma>,<loc2>,<scale2>,<gamma2>)
                         <SUBSET/EXCEPT/FOR qualification>
    where <p> is a variable, number, or parameter in the interval
               (0,1);
          <y> is a variable or a parameter (depending on what <x> is)
               where the computed Bi-Weibull ppf value is stored;
          <scale1> is a positive number, parameter, or variable that
               specifies the scale parameter for the first Weibull
               component;
          <gamma1> is a positive number, parameter, or variable that
               specifies the shape parameter for the first Weibull
               component;
          <loc2> is a positive number, parameter, or variable that
               specifies the location parameter for the second Weibull
               component;
          <scale2> is a positive number, parameter, or variable that
               specifies the scale parameter for the second Weibull
               component;
          <gamma2> is a positive number, parameter, or variable that
               specifies the shape parameter for the second Weibull
               component;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = BWEPPF(3,10,0.6,4,5,2.5)
    LET A = BWEPPF(P,S1,G1,L2,S2,G2)
    PLOT BWEPPF(P,10,0.7,4,4,3) FOR P = 0.01 0.01 0.99
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BWEHAZ  = Compute the Bi-Weibull hazard function.
    BWECHAZ = Compute the Bi-Weibull cumulative hazard function.
    BWECDF  = Compute the Bi-Weibull cumulative distribution function.
    BWEPDF  = Compute the Bi-Weibull probability density function.
    WEIPDF  = Compute the Weibull probability density function.
    EXPPDF  = Compute the exponential probability density function.
    LGNPDF  = Compute the lognormal probability density function.
 
Reference:
    "Statistical Distributions", Third Edition, Evans, Hastings, and
    Peacock, Wiley and Sons, 2001.
 
Applications:
    Reliability Analysis
 
Implementation Date:
    2002/5
 
Program:
    LET SCALE1 = 10
    LET GAMMA1 = 0.7
    LET LOC2 = 4
    LET SCALE2 = 4
    LET GAMMA2 = 3
    Y1LABEL X
    X1LABEL PROBABILITY
    TITLE BI-WEIBULL PERCENT POINT FUNCTION CR() ...
     S1 = ^SCALE1, G1 = ^GAMMA1, LOC2 = ^LOC2, S2 = ^SCALE2, G2 = ^GAMMA2
    PLOT BWEPPF(P,SCALE1,GAMMA1,LOC2,SCALE2,GAMMA2) FOR P = 0.01 0.01 0.99

-----B10CDF (LET)--------------------------------
 
B10CDF
 
Name:
    B10CDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 10 cumulative distribution function
    with shape parameter r.
 
Description:
    The standard Burr type 10 distribution has the following
    cumulative distribution function:

       F(x;r) = (1 - EXP(-x**2))**r   x >  0; r > 0
 
    with r denoting the shape parameter.

    This distribution can be generalized with location and
    scale parameters in the usual way using the relation

       F(x;r,loc,scale) = F((x-loc)/scale;r,0,1)

    This distribution is also referred to as the
    generalized Rayleigh distribution.  It has found
    use in reliability applications. 

Syntax:
    LET <y> = B10CDF(<x>,<r>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed Burr type 10 cdf value
              is stored;
          <r> is a positive number, parameter, or variable that
              specifies the shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = B10CDF(0.3,0.2)
    LET Y = B10CDF(X,0.5,0,5)
    PLOT B10CDF(X,2,0,3) FOR X = 0  0.01  5
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE X is a synonym for BURR TYPE 10.
 
Related Commands:
    B10PDF = Compute the Burr type 10 probability density
             function.
    B10PPF = Compute the Burr type 10 percent point function.
    BU2PDF = Compute the Burr type 2 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU5PDF = Compute the Burr type 6 probability density function.
    BU7PDF = Compute the Burr type 7 probability density function.
    BU8PDF = Compute the Burr type 8 probability density function.
    BU9PDF = Compute the Burr type 9 probability density function.
    B11PDF = Compute the Burr type 11 probability density function.
    B12PDF = Compute the Burr type 12 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Raqab and Kundu (2006), "Burr Type X Distributions:
    Revisited", Journal of Probability and Statistical Sciences,
    Vol. 4, No. 2, pp. 179-193.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    LET R  = 0.5
    TITLE R = ^r
    PLOT B10CDF(X,R) FOR X = 0.01  0.01  5
    .
    LET R  = 1
    TITLE R = ^r
    PLOT B10CDF(X,R) FOR X = 0.01  0.01  5
    .
    LET R  = 2
    TITLE R = ^r
    PLOT B10CDF(X,R) FOR X = 0.01  0.01  5
    .
    LET R  = 5
    TITLE R = ^r
    PLOT B10CDF(X,R) FOR X = 0.01  0.01  5
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 10 Cumulative Distribution Functions
 
-----B10PDF (LET)--------------------------------
 
B10PDF
 
Name:
    B10PDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 10 probability density function
    with shape parameter r.
 
Description:
    The standard Burr type 10 distribution has the following
    probability density function:

       f(x;r) = 2*r*x*(1 - EXP(-x**2)**(r-1)/EXP(x^2)
                x >  0; r > 0
 
    with r denoting the shape parameter.

    This distribution can be generalized with location and
    scale parameters in the usual way using the relation

       f(x;r,loc,scale) = (1/scale)*f((x-loc)/scale;r,0,1)

    This distribution is also referred to as the
    generalized Rayleigh distribution.  It has found
    use in reliability applications. 

Syntax:
    LET <y> = B10PDF(<x>,<r>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed Burr type 10 pdf value
              is stored;
          <r> is a positive number, parameter, or variable that
              specifies the shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = B10PDF(0.3,0.2)
    LET Y = B10PDF(X,0.5,0,5)
    PLOT B10PDF(X,2,0,3) FOR X = 0  0.01  5
 
Note:
    Burr type 10 random numbers, probability plots, and goodness
    of fit tests can be generated with the commands:

       LET R = <value>
       LET Y = BURR TYPE 10 RANDOM NUMBERS FOR I = 1 1 N
       BURR TYPE 10 PROBABILITY PLOT Y
       BURR TYPE 10 PROBABILITY PLOT Y2 X2
       BURR TYPE 10 PROBABILITY PLOT Y3 XLOW XHIGH
       BURR TYPE 10 KOLMOGOROV SMIRNOV GOODNESS OF FIT Y
       BURR TYPE 10 CHI-SQUARE GOODNESS OF FIT Y2 X2
       BURR TYPE 10 CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    The following commands can be used to estimate the r
    shape parameter for the Burr type 10 distribution:

       LET R1 = <value>
       LET R2 = <value>
       BURR TYPE 10 PPCC PLOT Y
       BURR TYPE 10 PPCC PLOT Y2 X2
       BURR TYPE 10 PPCC PLOT Y3 XLOW XHIGH
       BURR TYPE 10 KS PLOT Y
       BURR TYPE 10 KS PLOT Y2 X2
       BURR TYPE 10 KS PLOT Y3 XLOW XHIGH

    The default values for R1 and R2 are 0.5 and 10.

    The probability plot can then be used to estimate the
    location and scale (location = PPA0, scale = PPA1).

    The 2-parameter Burr type 10 maximum likelihood estimates
    can be obtained using the command

       BURR TYPE 10 MAXIMUM LIKELIHOOD Y

    The maximum likelihood estimates are obtained as the
    solution of the following simultaneous equations (from
    Raqab and Kundu):

       (n/r) + SUM[i=1 to n][LN(1 - EXP(-(s*x(i))**2)] = 0

       (2*n/s) - 2*s*SUM[i=1 to n][x(i)**2] +
       2*s*(r-1)*SUM[i=1 to n][x(i)^2*EXP(-(s*x(i))**2)/
       1 - EXP(-(s*x(i))**2))] = 0

    If the maximum likelihood estimates do not converge to
    reasonable values, you can try specifying starting values
    with the commands

        LET RSV = <value>
        LET SCALESV = <value>

    For example, the estimates obtained from the ppcc plot or
    ks plot method can be used as starting values for the
    maximum likelihood.

    The BOOTSTRAP DISTRIBUTION command can be used to find
    uncertainty intervals for the ppcc plot, the ks plot,
    and the maximum likelihood estimates.
       
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE X is a synonym for BURR TYPE 10.
 
Related Commands:
    B10CDF = Compute the Burr type 10 cumulative distribution
             function.
    B10PPF = Compute the Burr type 10 percent point function.
    BU2PDF = Compute the Burr type 2 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU5PDF = Compute the Burr type 6 probability density function.
    BU7PDF = Compute the Burr type 7 probability density function.
    BU8PDF = Compute the Burr type 8 probability density function.
    BU9PDF = Compute the Burr type 9 probability density function.
    B11PDF = Compute the Burr type 11 probability density function.
    B12PDF = Compute the Burr type 12 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Raqab and Kundu (2006), "Burr Type X Distributions:
    Revisited", Journal of Probability and Statistical Sciences,
    Vol. 4, No. 2, pp. 179-193.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program 1:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    LET R  = 0.5
    TITLE R = ^r
    PLOT B10PDF(X,R) FOR X = 0.01  0.01  5
    .
    LET R  = 1
    TITLE R = ^r
    PLOT B10PDF(X,R) FOR X = 0.01  0.01  5
    .
    LET R  = 2
    TITLE R = ^r
    PLOT B10PDF(X,R) FOR X = 0.01  0.01  5
    .
    LET R  = 5
    TITLE R = ^r
    PLOT B10PDF(X,R) FOR X = 0.01  0.01  5
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 10 Probability Density Functions
 
Program 2:
   let r = 2.1
   let rsav = r
   .
   let y = burr type 10 random numbers for i = 1 1 200
   let y = 10*y
   let amax = maximum y
   .
   burr type 10 ppcc plot y
   let rtemp = shape - 2
   let r1 = max(rtemp,0.05)
   let r2 = shape + 2
   y1label Correlation Coefficient
   x1label R
   burr type 10 ppcc plot y
   let r = shape
   justification center
   move 50 6
   text Rhat = ^r (R = ^rsav)
   move 50 2
   text Maximum PPCC = ^maxppcc
   .
   y1label Data
   x1label Theoretical
   char x
   line bl
   burr type 10 prob plot y1
   move 50 6
   text Location = ^ppa0, Scale = ^ppa1
   char bl
   line so
   .
   y1label Relative Frequency
   x1label
   relative hist y
   limits freeze
   pre-erase off
   plot b10pdf(x,r,ppa0,ppa1) for x = 0.01 .01 amax
   limits 
   pre-erase on
   .
   let ksloc = ppa0
   let ksscale = ppa1
   burr type 10 kolmogorov smirnov goodness of fit y
   .
   burr type 10 mle y
   let ksloc = 0
   let ksscale = scaleml
   let r = rml
   burr type 10 kolmogorov smirnov goodness of fit y

-----B10PPF (LET)--------------------------------
 
B10PPF
 
Name:
    B10PPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 10 percent point function
    with shape parameter r.
 
Description:
    The standard Burr type 10 distribution has the following
    percent point function:

       G(p;r) = SQRT(-LOG(1 - p**(1/r)))    0 < p < 1; r > 0
 
    with r denoting the shape parameter.

    This distribution can be generalized with location and
    scale parameters in the usual way using the relation

       G(p;r,loc,scale) = loc + scale*G(p;r,0,1)

    This distribution is also referred to as the
    generalized Rayleigh distribution.  It has found
    use in reliability applications. 

Syntax:
    LET <y> = B10PPF(<p>,<r>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or variable in the
              interval (0,1);
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed Burr type 10 ppf value
              is stored;
          <r> is a positive number, parameter, or variable that
              specifies the shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = B10PPF(0.95,0.8)
    LET Y = B10PPF(P,1.6,0,5)
    PLOT B10PPF(P,2,0,3) FOR P = 0.01  0.01  0.99
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE X is a synonym for BURR TYPE 10.
 
Related Commands:
    B10CDF = Compute the Burr type 10 cumulative distribution
             function.
    B10PDF = Compute the Burr type 10 probability density
             function.
    BU2PDF = Compute the Burr type 2 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU5PDF = Compute the Burr type 6 probability density function.
    BU7PDF = Compute the Burr type 7 probability density function.
    BU8PDF = Compute the Burr type 8 probability density function.
    BU9PDF = Compute the Burr type 9 probability density function.
    B11PDF = Compute the Burr type 11 probability density function.
    B12PDF = Compute the Burr type 12 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Raqab and Kundu (2006), "Burr Type X Distributions:
    Revisited", Journal of Probability and Statistical Sciences,
    Vol. 4, No. 2, pp. 179-193.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    LET R  = 0.5
    TITLE R = ^r
    PLOT B10PPF(P,R) FOR P = 0.01  0.01  0.99
    .
    LET R  = 1
    TITLE R = ^r
    PLOT B10PPF(P,R) FOR P = 0.01  0.01  0.99
    .
    LET R  = 2
    TITLE R = ^r
    PLOT B10PPF(P,R) FOR P = 0.01  0.01  0.99
    .
    LET R  = 5
    TITLE R = ^r
    PLOT B10PPF(P,R) FOR P = 0.01  0.01  0.99
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 10 Percent Point Functions
 
-----B11CDF (LET)--------------------------------
 
B11CDF
 
Name:
    B11CDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 11 cumulative distribution function
    with shape parameter r.
 
Description:
    The standard Burr type 11 distribution has the following
    cumulative distribution function:

       F(x;r) = [x - (1/(2*PI))*SIN(2*PI*x)]**r
                0 <  x <  1; r > 0
 
    with r denoting the shape parameter.

    This distribution can be generalized with lower and upper
    bound parameters.  If a and b denote the lower and upper
    bound parameters, respectively, then the location and
    scale parameters are

        location = a
        scale    = b - a

    The generalized form of the distribution can then be computed
    using the relation

       F(x;r,a,b) = F((x-a)/(b-a);r,0,1)

Syntax:
    LET <y> = B11CDF(<x>,<r>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed Burr type 11 cdf value
              is stored;
          <r> is a positive number, parameter, or variable that
              specifies the shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = B11CDF(0.3,0.2)
    LET Y = B11CDF(X,0.5,0,5)
    PLOT B11CDF(X,2,0,3) FOR X = 0.01  0.01  2.99
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE XI is a synonym for BURR TYPE 11.
 
Related Commands:
    B11PDF = Compute the Burr type 11 probability density
             function.
    B11PPF = Compute the Burr type 11 percent point function.
    BU2PDF = Compute the Burr type 2 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU6PDF = Compute the Burr type 6 probability density function.
    BU7PDF = Compute the Burr type 7 probability density function.
    BU8PDF = Compute the Burr type 8 probability density function.
    BU9PDF = Compute the Burr type 9 probability density function.
    B10PDF = Compute the Burr type 10 probability density function.
    B12PDF = Compute the Burr type 12 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Burr (1942), "Cumulative Frequency Functions", Annals of
    Mathematical Statistics, 13, pp. 215-232.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    LET R  = 0.5
    TITLE R = ^r
    PLOT B11CDF(X,R) FOR X = 0.01  0.01  0.99
    .
    LET R  = 1
    TITLE R = ^r
    PLOT B11CDF(X,R) FOR X = 0.01  0.01  0.99
    .
    LET R  = 2
    TITLE R = ^r
    PLOT B11CDF(X,R) FOR X = 0.01  0.01  0.99
    .
    LET R  = 5
    TITLE R = ^r
    PLOT B11CDF(X,R) FOR X = 0.01  0.01  0.99
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 11 Cumulative Distribution Functions
 
-----B11PDF (LET)--------------------------------
 
B11PDF
 
Name:
    B11PDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 11 probability density function
    with shape parameter r.
 
Description:
    The standard Burr type 11 distribution has the following
    probability density function:

       f(x;r) = r*{1 - COS(2*PI*x)*
                (x - SIN(2*PI*x)/(2*PI)}**(r-1)
                0 <  x <  1; r > 0
 
    with r denoting the shape parameter.

    This distribution can be generalized with lower and upper
    bound parameters.  If a and b denote the lower and upper
    bound parameters, respectively, then the location and
    scale parameters are

        location = a
        scale    = b - a

    The generalized form of the distribution can then be computed
    using the relation

       f(x;r,a,b) = (1/(b-a))*f((x-a)/(b-a);r,0,1)

Syntax:
    LET <y> = B11PDF(<x>,<r>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed Burr type 11 pdf value
              is stored;
          <r> is a positive number, parameter, or variable that
              specifies the shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = B11PDF(0.3,0.2)
    LET Y = B11PDF(X,0.5,0,5)
    PLOT B11PDF(X,2,0,3) FOR X = 0.01  0.01  2.99
 
Note:
    Burr type 11 random numbers, probability plots, and
    goodness of fit tests can be generated with the commands:

       LET R = <value>
       LET Y = BURR TYPE 11 RANDOM NUMBERS FOR I = 1 1 N
       BURR TYPE 11 PROBABILITY PLOT Y
       BURR TYPE 11 PROBABILITY PLOT Y2 X2
       BURR TYPE 11 PROBABILITY PLOT Y3 XLOW XHIGH
       BURR TYPE 11 KOLMOGOROV SMIRNOV GOODNESS OF FIT Y
       BURR TYPE 11 CHI-SQUARE GOODNESS OF FIT Y2 X2
       BURR TYPE 11 CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    The following commands can be used to estimate the r
    shape parameter for the Burr type 11 distribution:

       LET R1 = <value>
       LET R2 = <value>
       BURR TYPE 11 PPCC PLOT Y
       BURR TYPE 11 PPCC PLOT Y2 X2
       BURR TYPE 11 PPCC PLOT Y3 XLOW XHIGH
       BURR TYPE 11 KS PLOT Y
       BURR TYPE 11 KS PLOT Y2 X2
       BURR TYPE 11 KS PLOT Y3 XLOW XHIGH

    The default values for R1 and R2 are 0.5 and 10.

    The probability plot can then be used to estimate the
    location and scale (location = PPA0, scale = PPA1).

    The BOOTSTRAP DISTRIBUTION command can be used to find
    uncertainty intervals for the ppcc plot and ks plot.
       
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE XI is a synonym for BURR TYPE 11.
 
Related Commands:
    B11CDF = Compute the Burr type 11 cumulative distribution
             function.
    B11PPF = Compute the Burr type 11 percent point function.
    BU2PDF = Compute the Burr type 2 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU6PDF = Compute the Burr type 6 probability density function.
    BU7PDF = Compute the Burr type 7 probability density function.
    BU8PDF = Compute the Burr type 8 probability density function.
    BU9PDF = Compute the Burr type 9 probability density function.
    B10PDF = Compute the Burr type 10 probability density function.
    B12PDF = Compute the Burr type 12 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Burr (1942), "Cumulative Frequency Functions", Annals of
    Mathematical Statistics, 13, pp. 215-232.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program 1:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    LET R  = 0.5
    TITLE R = ^r
    PLOT B11PDF(X,R) FOR X = 0.01  0.01  0.99
    .
    LET R  = 1
    TITLE R = ^r
    PLOT B11PDF(X,R) FOR X = 0.01  0.01  0.99
    .
    LET R  = 2
    TITLE R = ^r
    PLOT B11PDF(X,R) FOR X = 0.01  0.01  0.99
    .
    LET R  = 5
    TITLE R = ^r
    PLOT B11PDF(X,R) FOR X = 0.01  0.01  0.99
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 11 Probability Density Functions
 
Program 2:
   let r = 2.1
   let rsav = r
   .
   let y = burr type 11 random numbers for i = 1 1 200
   let y = 10*y
   let amax = maximum y
   let amin = minimum y
   .
   burr type 11 ppcc plot y
   let rtemp = shape - 2
   let r1 = max(rtemp,0.05)
   let r2 = shape + 2
   y1label Correlation Coefficient
   x1label R
   burr type 11 ppcc plot y
   let r = shape
   justification center
   move 50 6
   text Rhat = ^r (R = ^rsav)
   move 50 2
   text Maximum PPCC = ^maxppcc
   .
   y1label Data
   x1label Theoretical
   char x
   line bl
   burr type 11 prob plot y
   move 50 6
   text Location = ^ppa0, Scale = ^ppa1
   char bl
   line so
   .
   y1label Relative Frequency
   x1label
   relative hist y
   limits freeze
   pre-erase off
   plot b11pdf(x,r,ppa0,ppa1) for x = amin  0.01  amax
   limits 
   pre-erase on
   .
   let ksloc = ppa0
   let ksscale = ppa1
   burr type 11 kolmogorov smirnov goodness of fit y

-----B11PPF (LET)--------------------------------
 
B11PPF
 
Name:
    B11PPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 11 percent point function
    with shape parameter r.
 
Description:
    The standard Burr type 11 distribution has the following
    cumulative distribution function:

       F(x;r) = [x - (1/(2*PI))*SIN(2*PI*x)]**r
                0 <  x <  1; r > 0
 
    with r denoting the shape parameter.

    The percent point function is computed by numerically
    inverting the cumulative distribution function.

    This distribution can be generalized with location and
    scale parameters in the usual way using the relation

       G(p;r,loc,scale) = loc + scale*G(p;r,0,1)

Syntax:
    LET <y> = B11PPF(<p>,<r>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or variable in the
              interval (0,1);
          <y> is a variable or a parameter (depending on what
              <p> is) where the computed Burr type 11 ppf value
              is stored;
          <r> is a positive number, parameter, or variable that
              specifies the shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = B11PPF(0.95,0.2)
    LET Y = B11PPF(P,0.5,0,5)
    PLOT B11PPF(X,2,0,3) FOR X = 0.01  0.01  0.99
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE XI is a synonym for BURR TYPE 11.
 
Related Commands:
    B11PDF = Compute the Burr type 11 probability density
             function.
    B11CDF = Compute the Burr type 11 cumulative distribution
             function.
    BU2PDF = Compute the Burr type 2 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU6PDF = Compute the Burr type 6 probability density function.
    BU7PDF = Compute the Burr type 7 probability density function.
    BU8PDF = Compute the Burr type 8 probability density function.
    BU9PDF = Compute the Burr type 9 probability density function.
    B10PDF = Compute the Burr type 10 probability density function.
    B12PDF = Compute the Burr type 12 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Burr (1942), "Cumulative Frequency Functions", Annals of
    Mathematical Statistics, 13, pp. 215-232.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 2
    .
    LET R  = 0.5
    TITLE R = ^r
    PLOT B11PPF(P,R) FOR X = 0.01  0.01  0.99
    .
    LET R  = 1
    TITLE R = ^r
    PLOT B11PPF(P,R) FOR X = 0.01  0.01  0.99
    .
    LET R  = 2
    TITLE R = ^r
    PLOT B11PPF(P,R) FOR X = 0.01  0.01  0.99
    .
    LET R  = 5
    TITLE R = ^r
    PLOT B11PPF(P,R) FOR X = 0.01  0.01  0.99
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 11 Percent Point Functions
 
-----B12CDF (LET)--------------------------------
 
B12CDF
 
Name:
    B12CDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 12 cumulative distribution function
    with shape parameters c and k.
 
Description:
    The Burr type 12 distribution is typically defined in terms
    of its cumulative distribution function:

       F(x;c,k,l,s) = 1 - (1+((x-l)/s)**c)**(-k)
                      x >= 0;  c, k, s > 0
 
    with c, k, l, and s denoting the two shape parameters, the
    location parameter, and the scale parameter, respectively.

    The case where l = 0 and s = 1 is referred to as the standard
    Burr type 12 distribution.

    The Burr type 12 distribution is also sometimes referred to
    as the Singh-Maddala distribution.

Syntax:
    LET <y> = B12CDF(<x>,<c>,<k>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed Burr type 12 cdf value
              is stored;
          <c> is a positive number, parameter, or variable that
              specifies the first shape parameter;
          <k> is a positive number, parameter, or variable that
              specifies the second shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = B12CDF(0.3,0.2,1.7)
    LET Y = B12CDF(X,0.5,2,2,0,5)
    PLOT B12CDF(X,2,0,3) FOR X = 0  0.01  5
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE XII is a synonym for BURR TYPE 12.
 
Related Commands:
    B12PDF = Compute the Burr type 12 probability density function.
    B12PPF = Compute the Burr type 12 percent point function.
    BU2PDF = Compute the Burr type 2 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU5PDF = Compute the Burr type 6 probability density function.
    BU7PDF = Compute the Burr type 7 probability density function.
    BU8PDF = Compute the Burr type 8 probability density function.
    BU9PDF = Compute the Burr type 9 probability density function.
    B10PDF = Compute the Burr type 10 probability density function.
    B11PDF = Compute the Burr type 11 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Burr (1942), "Cumulative Frequency Functions", Annals of
    Mathematical Statistics, 13, pp. 215-232.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 4 4
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 4
    .
    LET CVAL = DATA 0.5  1  2  5
    LET KVAL = DATA 0.5  1  2  5
    .
    LOOP FOR IROW = 1 1 4
        LOOP FOR ICOL = 1 1 4
            LET C  = CVAL(IROW)
            LET K = KVAL(ICOL)
            TITLE C = ^c, K = ^k
            PLOT B12CDF(X,C,K) FOR X = 0.01  0.01  5
        END OF LOOP
    END OF LOOP
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 12 Cumulative Distribution Functions
 
-----B12PDF (LET)--------------------------------
 
B12PDF
 
Name:
    B12PDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 12 probability density function
    with shape parameters c and k.
 
Description:
    The standard Burr type 12 distribution has the following
    probability density function:
 
       f(x;c,k) = c*k*x**(c-1)*(1 + x**c)**(-k-1)
                  x > 0;  c, k > 0

    with c and k denoting the shape parameters.

    This distribution can be generalized with location and
    scale parameters in the usual way using the relation

       f(x;c,k,loc,scale) = (1/scale)*f((x-loc)/scale;c,k,0,1)

    The Burr type 12 distribution is also sometimes referred to as
    the Singh-Maddala distribution.

Syntax:
    LET <y> = B12PDF(<x>,<c>,<k>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable;
          <y> is a variable or a parameter (depending on what
              <x> is) where the computed Burr type 12 pdf value
              is stored;
          <c> is a positive number, parameter, or variable that
              specifies the first shape parameter;
          <k> is a positive number, parameter, or variable that
              specifies the second shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = B12PDF(0.3,0.2,1.7)
    LET Y = B12PDF(X,0.5,2.2,0,5)
    PLOT B12PDF(X,2.3,1.4) FOR X = 0.01  0.01  5
 
Note:
    Burr type 12 random numbers, probability plots, and
    goodness of fit tests can be generated with the commands:

       LET C = <value>
       LET K = <value>
       LET Y = BURR TYPE 12 RANDOM NUMBERS FOR I = 1 1 N
       BURR TYPE 12 PROBABILITY PLOT Y
       BURR TYPE 12 PROBABILITY PLOT Y2 X2
       BURR TYPE 12 PROBABILITY PLOT Y3 XLOW XHIGH
       BURR TYPE 12 KOLMOGOROV SMIRNOV GOODNESS OF FIT Y
       BURR TYPE 12 CHI-SQUARE GOODNESS OF FIT Y2 X2
       BURR TYPE 12 CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    The following commands can be used to estimate the r
    shape parameter for the Burr type 12 distribution:

       LET C1 = <value>
       LET C2 = <value>
       LET K1 = <value>
       LET K2 = <value>
       BURR TYPE 12 PPCC PLOT Y
       BURR TYPE 12 PPCC PLOT Y2 X2
       BURR TYPE 12 PPCC PLOT Y3 XLOW XHIGH
       BURR TYPE 12 KS PLOT Y
       BURR TYPE 12 KS PLOT Y2 X2
       BURR TYPE 12 KS PLOT Y3 XLOW XHIGH

    The default values for C1 and C2 are 0.5 and 10.  The
    default values for K1 and K2 are 0.5 and 10, respectively.

    The probability plot can then be used to estimate the
    location and scale (location = PPA0, scale = PPA1).

    The BOOTSTRAP DISTRIBUTION command can be used to find
    uncertainty intervals for the ppcc plot and ks plot.
       
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE XII is a synonym for BURR TYPE 12.
 
Related Commands:
    B12CDF = Compute the Burr type 12 cumulative distribution
             function.
    B12PPF = Compute the Burr type 12 percent point function.
    BU2PDF = Compute the Burr type 2 probability density function.
    B13PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU5PDF = Compute the Burr type 6 probability density function.
    BU7PDF = Compute the Burr type 7 probability density function.
    BU8PDF = Compute the Burr type 8 probability density function.
    BU9PDF = Compute the Burr type 9 probability density function.
    B10PDF = Compute the Burr type 10 probability density function.
    B11PDF = Compute the Burr type 11 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Burr (1942), "Cumulative Frequency Functions", Annals of
    Mathematical Statistics, 13, pp. 215-232.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program 1:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 4 4
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 4
    .
    LET CVAL = DATA 0.5  1  2  5
    LET KVAL = DATA 0.5  1  2  5
    .
    LOOP FOR IROW = 1 1 4
        LOOP FOR ICOL = 1 1 4
            LET C  = CVAL(IROW)
            LET K = KVAL(ICOL)
            TITLE C = ^c, K = ^k
            PLOT B12PDF(X,C,K) FOR X = 0.01  0.01  5
        END OF LOOP
    END OF LOOP
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 12 Probability Density Functions
 
Program 2:
    let c = 2.1
    let k = 1.3
    let csav = c
    let ksav = k
    .
    let y = burr type 12 random numbers for i = 1 1 200
    let y = 10*y
    let amin = minimum y
    let amax = maximum y
    .
    y1label KS Value
    x1label K (Curves Represent Values of C)
    let c1 = 0.5
    let c2 = 5
    let k1 = 0.5
    let k2 = 3
    burr type 12 ks plot y
    let c = shape1
    let k = shape2
    justification center
    move 50 6
    text Chat = ^c (C = ^csav), Khat = ^k (K = ^ksav)
    move 50 2
    text Minimum KS = ^minks
    .
    y1label Data
    x1label Theoretical
    char x
    line bl
    burr type 12 prob plot y
    move 50 6
    text Location = ^ppa0, Scale = ^ppa1
    char bl
    line so
    .
    let loc = min(ppa0,amin)
    let scale = ppa1
    .
    y1label Relative Frequency
    x1label
    relative hist y
    limits freeze
    pre-erase off
    line color blue
    plot b12pdf(x,c,k,loc,scale) for x = amin .01 amax
    line color black
    limits 
    pre-erase on
    .
    let ksloc = loc
    let ksscale = scale
    burr type 12 kolmogorov smirnov goodness of fit y

-----B12PPF (LET)--------------------------------
 
B12PPF
 
Name:
    B12PPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Burr type 12 percent point function
    with shape parameters c and k.
 
Description:
    The standard Burr type 12 distribution has the following
    percent point function:

       G(p;c,k) = [(1-p)**(-1/k)-1]**(1/c)
                  0 <= p < 1; c, k > 0
 
    with c and k denoting the shape parameters.

    This distribution can be generalized with location and
    scale parameters in the usual way using the relation

       G(p;c,k,loc,scale) = loc + scale*G(p;c,k,0,1)

    The Burr type 12 distribution is also sometimes referred to
    as the Singh-Maddala distribution.

Syntax:
    LET <y> = B12PPF(<p>,<c>,<k>,<loc>,<scale>) 
              <SUBSET/EXCEPT/FOR qualification>
    where <p> is a number, parameter, or variable in the
              interval (0,1);
          <y> is a variable or a parameter (depending on what
              <p> is) where the computed Burr type 12 ppf value
              is stored;
          <c> is a positive number, parameter, or variable that
              specifies the first shape parameter;
          <k> is a positive number, parameter, or variable that
              specifies the second shape parameter;
          <loc> is a number, parameter, or variable that
              specifies the location parameter;
          <scale> is a positive number, parameter, or variable
              that specifies the scale parameter;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    If <loc> and <scale> are omitted, they default to 0 and 1,
    respectively.

Examples:
    LET A = B12PPF(0.95,0.2,1.7)
    LET Y = B12PPF(X,0.5,2.2,0,5)
    PLOT B12PPF(P,2.3,1.4) FOR P = 0.01  0.01  0.99
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    BURR TYPE XII is a synonym for BURR TYPE 12.
 
Related Commands:
    B12CDF = Compute the Burr type 12 cumulative distribution
             function.
    B12PDF = Compute the Burr type 12 probability density function.
    BU2PDF = Compute the Burr type 2 probability density function.
    BU3PDF = Compute the Burr type 3 probability density function.
    BU4PDF = Compute the Burr type 4 probability density function.
    BU5PDF = Compute the Burr type 5 probability density function.
    BU5PDF = Compute the Burr type 6 probability density function.
    BU7PDF = Compute the Burr type 7 probability density function.
    BU8PDF = Compute the Burr type 8 probability density function.
    BU9PDF = Compute the Burr type 9 probability density function.
    B10PDF = Compute the Burr type 10 probability density function.
    B11PDF = Compute the Burr type 11 probability density function.
    RAYPDF = Compute the Rayleigh probability density function.
    WEIPDF = Compute the Weibull probability density function.
    EWEPDF = Compute the exponentiated Weibull probability density
             function.
 
Reference:
    Burr (1942), "Cumulative Frequency Functions", Annals of
    Mathematical Statistics, 13, pp. 215-232.

    Johnson, Kotz, and Balakrishnan (1994), "Contiunuous
    Univariate Distributions--Volume 1", Second Edition,
    Wiley, pp. 53-54.

    Devroye (1986), "Non-Uniform Random Variate Generation",
    Springer-Verlang, pp. 476-477.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2007/10
 
Program:
    LABEL CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT 4 4
    MULTIPLOT CORNER COORDINATES 0 0 100 95
    MULTIPLOT SCALE FACTOR 4
    .
    LET CVAL = DATA 0.5  1  2  5
    LET KVAL = DATA 0.5  1  2  5
    .
    LOOP FOR IROW = 1 1 4
        LOOP FOR ICOL = 1 1 4
            LET C = CVAL(IROW)
            LET K = KVAL(ICOL)
            TITLE C = ^c, K = ^k
            PLOT B12PPF(P,C,K) FOR P = 0.01  0.01  0.99
        END OF LOOP
    END OF LOOP
    .
    END OF MULTIPLOT
    .
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Burr Type 12 Percent Point Functions
 
-------------------------------------------------------------













































































-------------------------  *C*  ZZZZZ--------------------

-----C CHART-----------------------------------------------------
 
C CHART
 
Name:
    C CHART
 
Type:
    Graphics Command
 
Purpose:
    Generates a (Poisson) counts control chart.
 
Description:
    A C chart is a data analysis analysis technique for determining if
    a measurement process has gone out of statistical control.  The C
    chart is sensitive to changes in the number of defective items in
    the measurement process.  The "C" in C chart stands for "counts" as
    in defectives per lot.  The C control chart consists of:
       Vertical   axis = the number defective for each sub-group;
       Horizontal axis = sub-group designation.
    The C chart assumes that each sub-group has an equal size (this
    size does not need to be specified).  A sub-group is typically a
    time sequence (e.g., the number of defectives in a daily production
    run where each day is considered a sub-group).  If the times are
    equally spaced, the horizontal axis variable can be generated as a
    sequence (e.g., LET X = SEQUENCE 1 1 N where N is the number of
    sub-groups).
 
    In addition, horizontal lines are drawn at the mean number of
    defectives and at the upper and lower control limits.  The control
    limits are calculated as:
         UCL = cbar + 3*sqrt(cbar)
         LCL = cbar - 3*sqrt(cbar)
    where cbar is the mean number of defectives.  Also, zero serves as
    a lower bound on the LCL.
 
Syntax:
    C CONTROL CHART   <y1>   <x>   <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable containing the number of defective items
               in each sub-group;
          <x>  is a variable containing the sub-group identifier
               (usually 1, 2, 3, ...);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    C CONTROL CHART Y X
    C CONTROL CHART D X
 
Note:
    The distribution of defective items is assumed to be Poisson.
    This assumption is the basis for calculating the upper and lower
    control limits.
 
Note:
    The U chart and C chart are related to one another. The distinction
    is that the C chart is used when material being measured is
    constant in area and the sub-groups have equal size.  The U chart
    is used when either of these assumptions is not valid.
 
Note:
    The attributes of the 4 traces that make up the C control chart are
    controlled by the standard LINES, CHARACTERS, SPIKES, and BAR
    commands.  Trace 1 is the response variable, trace 2 is the mean
    line, and traces 3 and 4 are the upper and lower control limits.
    Some analysts prefer to draw the response variable as a character
    or spike rather than a connected line.
 
Default:
    None
 
Synonyms:
    C CHART for C CONTROL CHART
 
Related Commands:
    U CHART             = Generates a U control chart.
    P CHART             = Generates a P control chart.
    NP CHART            = Generates an Np control chart.
    XBAR CHART          = Generates an xbar control chart.
    R CHART             = Generates a range control chart.
    S CHART             = Generates a standard deviation control chart.
 
    CHARACTERS          = Sets the types for plot characters.
    LINES               = Sets the types for plot lines.
    SPIKES              = Sets the on/off switches for plot spikes.
    BARS                = Sets the on/off switches for plot bars.
    PLOT                = Generates a data or function plot.
    LAG PLOT            = Generates a lag plot.
    4-PLOT              = Generates a 4-plot for univariate analysis.
    ANOP PLOT           = Generates an ANOP plot.
 
Reference:
    "Guide to Quality Control", Karou Ishikawa, Asian Productivity
    Organization, 1982 (Chapter 8).
 
Applications:
    Quality Control
 
Implementation Date:
    88/2
 
Program:
    LET Y1 = DATA 4 3 6 2 5 7 6 8 3 4
    LET X = SEQUENCE 1 1 10
    PLOT Y1 X
    C CHART Y1 X
 
-----CABS (LET)---------------------------------------
 
CABS
 
Name:
    CABS (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the absolute value for a complex number.
 
Description:
    The absolute value of a complex number is defined to be:
       CABS(x + i*y) = SQRT(x**2 + y**2)

Syntax:
    LET <y> = CABS(<xr>,<xc>)  <SUBSET/EXCEPT/FOR qualification>
    where <xr> is a number, parameter, or variable that specifies the
               real component of the the complex number;
          <xc> is a number, parameter, or variable that specifies the
               complex component of the the complex number;
          <y> is a variable or a parameter (depending on what <xr> and
               <xc> are) where the computed absolute value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CABS(-2,1)
    LET A = CABS(-2,-1)
    LET X2 = ABS(XR,XC)
    LET X2 = ABS(0,XC)
 
Note:
    DATAPLOT uses the Fortran intrinsic function CABS to compute this
    function.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ABS    = Compute the absolute value of a real number.
    CCOS   = Compute the real component of the cosine of a complex
             number.
    CCOSI  = Compute the complex component of the cosine of a complex
             number.
    CEXP   = Compute the real component of the exponential of a complex
             number.
    CEXPI  = Compute the complex component of the exponential of a
             complex number.
    CLOG   = Compute the real component of the logarithm of a complex
             number.
    CLOGI  = Compute the complex component of the logarithm of a
             complex number.
    CSIN   = Compute the real component of the sine of a complex
             number.
    CSINI  = Compute the complex component of the sine of a complex
             number.
    CSQRT  = Compute the real component of the square root of a complex
             number.
    CSQRTI = Compute the complex component of the square root of a
             complex number.
 
Applications:
    XX
 
Implementation Date:
    94/10
 
Program:
    TITLE AUTOMATIC
    PLOT CABS(XR,2) FOR XR = -5 .1 5
 
-----CAIRO-------------------------------------------------------
 
CAIRO
 
Name:
    CAIRO
 
Type:
    Output Device Command
 
Purpose:
    Direct graphical output to a CAIRO device.
 
Description:
    The following description of Cairo is taken from the
    Cairo web page

        Cairo is a 2D graphics library with support for multiple output
        devices. Currently supported output targets include the X Window
        System (via both Xlib and XCB), quartz, win32, and image buffers,
        as well as PDF, PostScript, and SVG file output. Experimental
        backends include OpenGL, BeOS, OS/2, and DirectFB.
    
        Cairo is designed to produce consistent output on all output media
        while taking advantage of display hardware acceleration when
        available (for example, through the X Render Extension).
    
        The cairo API provides operations similar to the drawing operators
        of PostScript and PDF. Operations in cairo include stroking and
        filling cubic Bézier splines, transforming and compositing
        translucent images, and antialiased text rendering. All drawing
        operations can be transformed by any affine transformation (scale,
        rotation, shear, etc.).
    
        Cairo has been designed to let you draw anything you want in a
        modern 2D graphical user interface.  At the same time, the cairo
        API has been designed to be as fun and easy to learn as possible.

    Dataplot currently supports Cairo for the Unix/Linux environment.
    The following Cairo devices are supported

        X11
        Postscript
        Encapsulated Postscript
        PDF (Portable Document Format)
        SVG (Scalable Vector Graphics)
        PNG (Portable Network Graphics)

    Note that with the exception of the PDF device, Dataplot
    has native support for these devices.  One advantage
    of using Cairo is that the output is more consistent across
    the various devices.  Specifically, using Cairo the output
    generated to the screen via X11 will be more consistent with the
    output generated to Postscript or PDF.  This is particularly
    the case for hardware text.  Also, the Cairo PNG device generates
    better output than the GD PNG device.

    The Quartz device for the Mac OS X environment and the WIN32
    device for the Windows environment are currently under
    development.

Syntax 1:
    DEVICE 1 CAIRO X11
 
    This form designates device 1 (the terminal) as a X11 device.
    Currently, only the X11 device supports graphics to the
    terminal.  An error message is generated if you specify one
    of the other supported Cairo devices for DEVICE 1.
 
Syntax 2:
    DEVICE <2/3> CAIRO <device>
    where <device> is one of POSTSCRIPT, ENCAPSULATED POSTSCRIPT,
          PDF, SVG, or PNG.
 
    DEVICE 2 and DEVICE 3 generate graphics to a file.  This command
    is most typically used for DEVICE 2.

    X11 is not supported for DEVICE 2 or DEVICE 3.

Examples:
    DEVICE 1 CAIRO X11
    DEVICE 2 CAIRO POSTSCRIPT
    DEVICE 2 CAIRO SVG
    DEVICE 3 CAIRO PDF
    DEVICE 2 CAIRO POSTSCRIPT ENCAPSULATED
 
Note:
    The Cairo X11 device supports the use of the CROSS HAIR
    command.  The Cairo X11 device can also be manually
    resized (the new size does not take effect until the
    next screen erase).

Note:
    The SVG, PNG, and ecapsulated Postscript devices expect only a
    single plot for each file.  This can be accomplished using
    something like the following

        SET IPL1NA PLOT1.PNG
        DEVICE 2 CAIRO PNG
             ...  Generate first plot ..
        DEVICE 2 CLOSE
        .
        SET IPL1NA PLOT2.PNG
        DEVICE 2 CAIRO PNG
             ...  Generate second plot ..
        DEVICE 2 CLOSE

    The SET IPL1NA command is used to give the plot file a unique name.
    This basic sequence can be repeated as often as needed.

    If you try to generate multiple plots for these devices, the
    results will not be good (basically, the plots will be
    overlaid on a single page).

    The Postscript and PDF devices support multiple plots per
    file.

Note:
    There are several commands for supporting text with the
    Cairo devices.

    To specify the font for the Cairo device, enter the command

        SET CAIRO FONT <name>

    where <name> specifies the desired font.  Up to 32 characters are
    allowed for the font name.  The available fonts will vary on
    a specific platform, so no listing (or checking within Dataplot)
    is provided.  The basic fonts such as Sans or Serif should be
    available on just about all installations.  If you use a common
    font name such as Arial or Helvetica (or Courier for when you
    need a fixed space font), it should be available on most
    installations.

    The following additional font related commands are supported

        SET CAIRO FONT WEIGHT <NORMAL/BOLD>
        SET CAIRO FONT SLANT  <NORMAL/ITALIC>

    These commands allow you to specify bold or italic text.
    NORMAL is the default for both of these commands.

    The following commands are used to specify characteristics
    for drawing lines

        SET CAIRO CAP  <BUTT/ROUND/SQUARE/NONE>
        SET CAIRO JOIN <MITER/ROUND/BEVEL/NONE>

    BUTT and MITER are the defaults.

    By default, region fills are performed in hardware (i.e.,
    by Cairo).  Although this is generally faster, hardware fills
    can occassionally generate unintended results.  To specify
    region fills be generated in software, use the command

         SET CAIRO HARDWARE FILL OFF

Note:
    Cairo supports a number of features that are not currently
    supported in Dataplot.

Default:
    Off
 
Synonyms:
    None

Related Commands:
    LIBPLOT               = Generate graphics using the LIBPLOT
                            library.
    GD                    = Generate graphics using the GD library.
    POSTSCRIPT            = Generate Postscript output.
    SVG                   = Generate SVG output.
    X11                   = Direct graphical output to an X11 device.

Applications:
    Graphics Output
 
Implementation Date:
    2017/11
    2023/11: Made several bug fixes to the driver
 
Program:
    SET IPL1NA PLOT1.PDF
    DEVICE 2 CAIRO PDF
    PLOT X**2 FOR X = 1 1 9
    DEVICE 2 CLOSE
    SET IPL1NA PLOT2.PDF
    DEVICE 2 CAIRO PDF
    PLOT X**3 FOR X = 1 1 9
    DEVICE 2 CLOSE
 
-----CALCOMP-------------------------------------------------------
 
CALCOMP
 
Name:
    CALCOMP
 
Type:
    Output Device Command
 
Purpose:
    Direct graphical output to a CALCOMP device.
 
Description:
    Note: This is essentially an obsolete device.  However, this may
          still find occassional use with Calcomp emulation libraries.

    There are a large number of Calcomp devices (although most are
    penplotters or film recorders) models.  Calcomp typically
    supports their devices through a software library called the
    Calcomp library.  DATAPLOT supports the various Calcomp devices
    through calls to this library.  This library contains a core set of
    modules that should be common to all Calcomp devices.  In addition,
    it may contain a few routines that are specific to that device.
    DATAPLOT is restricted to using the following routines in this
    library:
        PLOTS
        PLOT
        NEWPEN
        SYMBOL
        DASHS
    Note that many penplotter vendors provide a Calcomp compatible
    library for their devices.  The Calcomp driver in DATAPLOT should
    support these devices as well.
 
Syntax 1:
    CALCOMP
    This form designates device 1 as a Calcomp device.  Although device
    1 is normally reserved for the terminal screen, in the Calcomp case
    the graphics output is typically sent to a file.
 
Syntax 2:
    DEVICE <1/2/3> CALCOMP
    This form designates one of DATAPLOT's 3 devices (it will typically
    be device 2) to be a Calcomp device.
 
Examples:
    CALCOMP ON
    DEVICE 2 CALCOMP
    DEVICE 3 CALCOMP
 
Note:
    In order for this command to be operational, the local DATAPLOT
    installer must link the local Calcomp library with DATAPLOT.  Also,
    local sites may have code to select different papers, pen types,
    colors, and other similar things.  Contact the local installer if
    more information is needed about this.
 
Note:
    In order to accommodate different models, two SET commands are
    available.  SET CALCOMP COLORS <number> identifies the number of
    colors available on the local CALCOMP device.  SET CALCOMP WIDTH
    <num> (in DATAPLOT 0 to 100 units) sets the line width for drawing
    thick lines and fills of solid regions.  Enter HELP COLOR TYPES to
    see the default slot to color mapping DATAPLOT assumes.  Enter the
    command HELP PEN MAP to see how to change this default mapping.
 
Default:
    Device 1 is a Tektronix 4014, device 2 is off, and device 3 is a
    Postscript printer.
 
Synonyms:
    None
DEVICE NOTES
    1) HARDWARE TEXT - Calcomp hardware characters can be scaled to any
       size.  Vertical strings are rotated 90 degrees.  The appearance
       of hardware characters varies depending on the particular model.
    2) COLOR - The number of colors varies depending on the particular
       model you are using.  By default, DATAPLOT assumes 8 pen slots.
       If you have less (or more) than 8, use the command SET CALCOMP
       COLORS to specify the number you have.  For more than 8 slots,
       use the CALCOMP PEN MAP command for slot numbers greater than 8.
       This command can also be used to override the default color to
       slot number mapping.
    3) HARDWARE FILL - All area fills in software.
    4) DASH PATTERNS - Currently, the Calcomp device is limited to one
       dash pattern.
 
       This limitation is due simply to the fact that we tested the
       driver on a Zeta device which uses a different dash scheme than
       the Calcomp.  Any site with an actual Calcomp device that would
       like to cooperate with us on extending this should contact us
       (see your local site installer).
    5) LINE WIDTH - The Calcomp device uses a default line width of
       0.1 (in DATAPLOT 0 to 100 coordinate units).  If this is not a
       good value, use the SET CALCOMP WIDTH command to specify a
       better value.  The best value may vary with the types of pens
       used as well.
    6) GRAPHICS INPUT - The CROSS-HAIR command is ignored for this
       device.
 
Related Commands:
    ZETA                  = Direct graphical output to a Zeta device.
    POSTSCRIPT            = Direct graphical output to a Postscript
                            device.
    TEKTRONIX             = Direct graphical output to a Tektronix
                            device.
    DEVICE                = Specify certain actions for the graphics
                            output.
    CALCOMP PEN MAP       = Specify the pen slot to color mapping for
                            the Calcomp device.
    SHOW CALCOMP COLORS   = Show the available colors on the Calcomp
                            device.
    SET CALCOMP COLORS    = Specify the number of colors available on
                            the Calcomp device.
    SET CALCOMP WIDTH     = Specify the width of a single line on the
                            Calcomp device.
 
Applications:
    Graphics Output
 
Implementation Date:
    89/2
 
Program:
    XX
 
-----CALIBRATION --------------------------------------------

CALIBRATION
 
Name:
    CALIBRATION
 
Type:
    Analysis Command
 
Purpose:
    Compute a linear or quadratic calibration using multiple
    methods.
 
Description:
    The goal of calibration is to quantitatively convert measurements
    made on one of two measurement scales to the other measurement
    scale.  There is also a model that describes the relationship
    between the two measurement scales.

    The primary measurement scale is usually the scientifically
    relevant scale and measurements on this scale are typically
    more precise (relatively) than measurements on the secondary
    scale.  However, the secondary scale is typically the easier
    measurement to obtain (i.e., it is typically cheaper or faster
    or more readily available).

    So given a measurement on the secondary scale, we want to convert
    that to an estimate of the measurement on the primary scale. The
    steps involved are:

       1) We start with a series of points that have been measured
          on both scales.  The secondary measurement is treated
          as the response variable, Y, and the primary measurement
          is treated as the independent variable, X.

       2) We perform a fit of Y and X.  Currently, Dataplot supports
          calibration for the case where Y and X can be fit with
          either a linear fit

             Y = A0 + A1*X

          or a quadratic fit

             Y = A0 + A1*X + A2 *X**2

          This is typically referred to as the calibration curve.

          Although these are the most common calibration models in
          practice, other calibration models are also used.  For example,
          the fit could be multi-linear (i.e., more than one X variable),
          a higher order polynomial, or non-linear.  These cases are not
          supported directly.  However, you can use a bootstrap approach
          for many of these problems.

       3) We then have one or more points measured on the secondary
          scale with no corresponding measurement on the primary
          scale.

          We use the calibration curve to estimate the value of
          the measurement on the primary scale.  In addition, we
          estimate a confidence interval for the estimated value
          on the primary scale.

          The calibration problem has recieved significant
          attention and a number of different methods have
          been proposed for the calibration estimates.  Most of
          these methods return the same value for the point
          estimate.  However, the method for obtaining the
          confidence interval is typically different.
          
    Given that in the calibration problem the primary measurement (the
    higher quality measurement) is assigned to the independent variable(s)
    (x axis) and the secondary measurement is assigned to the dependent
    (y axis) variable, a reasonable question is why don't we simply switch
    the axes and assign the secondary measurement to the independent
    variable?  The reason is that least squares fitting assumes that
    the values for the indpendent variable are fixed (i.e., there is no
    error).  In order to satisfy this assumption, we need to assign the
    higher quality measurement to the independent variable.

    When Dataplot performs a calibration, it first prints out a
    summary of the initial fit.  It then loops through each point
    being calibrated and prints the estimate for the primary
    scale and the corresponding confidence limits.

    Calibration is discussed in the NIST/SEMATECH e-Handbook of
    Statistical Methods:

        http://www.itl.nist.gov/div898/handbook/pmd/section5/pmd521.htm

Description of Methods:
    In this section, we only give the final computational formulas.  A
    reference is given for most methods that discusses the derivation
    and justification of these formulas.

    The following are some quantities that are used by several methods:

        ybar    = mean of the Y (secondary measurement) values
        xbar    = mean of the X (primary measurement) values
        ssx     = SUM[i=1 to n][X(i)**2]
        ssdx    = SUM[i=1 to n][(X(i) - xbar)**2]
        ssdy    = SUM[i=1 to n][(Y(i) - ybar)**2]
        ssdx    = SUM[i=1 to n][(X(i) - xbar)**2]
        s       = the residual standard deviation

     For most of these methods, given a calibration point, Y0, the
     X0 is estimated from the original fit by

           X0 = (Y0 - A0)/A1

     with A0 and A1 denoting the coefficients from the original fit:

          Y = A0 + A1*X

    Dataplot generates the linear calibration using the
    following methods:

    1) Inverse Prediction Limits (Eisenhart)

       This method was originally recommended by Churchill
       Eisenhart and is based on inverting the prediction limits
       for Y given X0.  The prediction interval is

           Y = Ybar + A1*X +/- t(alpha/2,N-2)*
               s*SQRT(1 + (1/N) + X0**2/ssdx)

       to the linear calibration problem.

       The uncertainty is obtained from the linear regression
       prediction interval

          Yhat +/- t(1-alpha/2,nu)*sigmahat(p)

       with sigmahat(p) denoting the standard deviation of the
       predicted value.  The formula for sigmahat(p) is

           sigmahat(p) = SQRT(sigmahat**2 + sigmahat(f)**2)

       with 

           sigmahat**2    = variance of the residuals
                          = SUM(Y-Yhat)**2/(N-2)

           sigmahat(f)**2 = variance of the predicted values

                          = 

       To find the confidence limits for X0 (X0L and X0U),
       we solve

           X0L = (A0 + A1*X0) - t(1-alpha/2,nu)*sigmahat(p)
           X0U = (A0 + A1*X0) + t(1-alpha/2,nu)*sigmahat(p)

    2) Graybill-Iyer

       This method is described on pages 427-431 of the Graybill
       and Iyer textbook (see the Reference section below).

       Although this uses a different computational formula than
       the inverse prediction limits method, they appear to be
       equivalent.

    3) Neter-Wasserman-Kutner

       This method is described on pages 135-137 of the Neter,
       Wasserman, and Kutner textbook (see the Reference section
       below).

       Although this method uses a different computational formula,
       it appears to be equivalent to the propogation of error as
       given in the e-Handbook (see the Reference section below).

    4) Propogation of Error

       The propogation error formulas here are different than those
       given in the e-Handbook.  If you want to use a propogation
       of error method, we recommend the method used in the
       e-Handbook.

    5) Propogation of Error (as given in the e-Handbook)

       The propogation of error formula used here is from the
       NIST/SEMATECH e-Handbook of Statistical Methods

         http://www.itl.nist.gov/div898/handbook/mpc/section3/mpc3673.htm

    6) Inverse (Krutchkoff)

       This method is described in the Krutchkoff paper (see the
       Reference Section below).  Note that this method gives a
       different value for the estimate of the calibrated value
       than do the other methods.  This method is not often used.

    7) Maximum Likelihood

       This method is from a private communication with Andrew Rukhin.

       The basic algorithm used is

          a) Subtract out the mean from the X variable and perform
             the linear fit.  Save the standard deviations of the
             A0 and A1 coefficients.

          b) Generate two sets of 10,000 standard normal random numbers.

          c) For each simulation, generate values for A0 and A1 by adding
             the normal random numbers (use one set for A0 and the other
             set for A1) multiplied by the standard deviations of A0 and
             A1 respectively.  Then invert the linear fit to obtain the
             point estimate of the calibrated value.  Note that the A1
             coefficient is multiplied by the mean of the X values to
             restore the original scale.

          d) The confidence interval for the calibrated value is
             obtained from the appropriate percentiles of the 10,000
             estimates of the calibrated value.

    8) Bootstrap

       For this method, the confidence limits are obtained by
       generating bootstrap samples, obtaining the point estimate
       for each bootstrap sample, and then computing a confidence
       interval based on the percentiles of these bootstrap point
       estimates.  For example, a 95% confidence interval would be
       obtained from the 2.5 and 97.5 percentiles.

       There are two methods for generating the bootstrap samples.

           a) In the first approach, the least squares fit is computed
              from the original data.  The residuals are then resampled.
              The residuals are added to the predicted values of the
              original fit to obtain a new Y vector.  This new Y vector
              is then fit against the original X variable and the point
              estimate for the calibration is obtained from these Y and
              X.  We call this approach residual resampling (or the
              Efron approach).
 
           b) In the second approach, rows of the original data (both
              the Y vector and the corresponding rows of the X variables)
              are resampled.  The resampled data are then fit.  We call
              this approach data resampling (or the Wu approach).

       Hamilton (see Reference below) gives some guidance on the
       contrasts between these approaches.
 
           a) Residual resampling assumes fixed X values and
              independent and identically distributed residuals.
 
           b) Data resampling does not assume independent and
              identically distributed residuals.
 
       Given the above, if the assumption of fixed X is realistic
       (that is, we could readily collect new Y's with the same
       X values), then residual resampling is justified.  For example,
       this would be the case in a designed experiment.  However,
       if this assumption is not realistic (i.e., the X values
       vary randomly as well as the Y's), then data resampling is
       preferred.

       The CALIBRATION command will generate estimates for both
       types of bootstrap sampling.

    9) Fieller Method

       The derivation and computational details for this method can
       be found in chapter 5 of Miller.  Both a bias corrected (equation
       5.32 in Miller) and the uncorrected interval (equation 5.35 in
       Miller) will be printed. 

       In addition, a simultaneous interval for the case when there
       more than one calibration points is given.

    Dataplot generates the quadratic calibration using the
    following methods:

    1) Inverse Prediction Limits (Eisenhart)

       This uses the same idea as the linear calibration inverse
       prediction limits.  That is, we invert the quadratic regression
       equation to obtain the point estimates and the confidence
       intervals are based on inverting the quadratic prediction limits.
       The algebraic details are not given here.

    2) Propogation of Error

       The propogation of error formula used here is from the
       NIST/SEMATECH e-Handbook of Statistical Methods

         http://www.itl.nist.gov/div898/handbook/mpc/section3/mpc3671.htm

    3) Bootstrap

       See the comments above for the bootstrap using linear
       calibration.  The same basic ideas apply except that we
       perform a quadratic rather than a linear fit.

Syntax 1:
    LINEAR CALIBRATION  <y>  <x> <y0>
                        <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable (secondary measurements);
          <x> is the independent variable (primary measurements);
          <y0> is a number, parameter, or variable containing the
              secondary measurements where the calibration is to
              be performed;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax computes a linear calibration analysis.

Syntax 2:
    QUADRATIC CALIBRATION  <y>  <x> <y0>
                        <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable (secondary measurements);
          <x> is the independent variable (primary measurements);
          <y0> is a number, parameter, or variable containing the
              secondary measurements where the calibration is to
              be performed;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax computes a quadratic calibration analysis.

Examples:
    LINEAR CALIBRATION Y  X Y0
    QUADRATIC CALIBRATION Y  X Y0
    LINEAR CALIBRATION Y  X  Y0   SUBSET X > 2
 
Note:
    To simplify the generation of additional plots and analysis, a
    number of results are written to external files.

    The following variables are written to the file
    dpst1f.dat.

       Column 1 - method id
       Column 2 - Y0 (i.e., calibration point on secondary scale)
       Column 3 - X0 (i.e., for Y0, the estimate on the primary scale)
       Column 4 - lower confidence limit
       Column 5 - upper confidence limit

    The following variables are written to the file dpst2f.dat.

       Column 1         - Y0
       Columns 2 thru 9 - X0 for each of the 8 methods (only 3
                          methods for quadratic calibration)

    The following variables are written to the file dpst3f.dat.

       Column 1         - Y0
       Columns 2 thru 9 - lower limit for X0 for each of the 8
                          methods (only 3 methods for quadratic
                          calibration)

    The following variables are written to the file dpst4f.dat.

       Column 1         - Y0
       Columns 2 thru 9 - upper limit for X0 for each of the 8
                          methods (only 3 methods for quadratic
                          calibration)

Note:
    The default confidence limits are for a 95% confidence interval
    (i.e., alpha = 0.05).  To use a different alpha, enter the
    command (before entering the CALIBRATION command):

       LET ALPHA = <value>

    For example, to generate 90% confidence intervals, enter

       LET ALPHA = 0.10

Note:
    If you want the fit to be generated without a constant term, enter
    the command

        SET FIT ADDITIVE CONSTANT OFF

Note:
    Although linear and quadratic calibrations are often sufficient, for
    some applications more complicated calibration curves may be required.
    In these cases, inverting the prediction limits or computing the
    propogation of error formulas may become difficult.  The bootstrap
    can be used for these applications.  This is demonstrated in the
    Program 3 example.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FIT                 = Perform a fit.
    BOOTSTRAP PLOT      = Generate a bootstrap plot.
 
References:
    Churchill Eisenhart (1939),  "The Interpretation of Certain
    Regression Methods and Their Use in Biological and Industrial
    Research", Annals of Mathematical Statistics, Vol. 10,
    pp. 162-182.

    F. Graybill and H. Iyer, "Regression Anaysis", First Edition,
    Duxbury Press, pp. 427-431.

    NIST/SEMATECH e-Handbook of Statistical Methods,
    http://www.itl.nist.gov/div898/handbook/, 2012.

    Neter, Wasserman, and Kuttner (1990), "Applied Linear Statistical
    Models", Third Edition, Irwin, pp. 173-175.

    Miller (1997), "Beyond ANOVA: Basics of Applied Statistics",
    Chapman & Hall/CRC, pp. 177-181.

    Fieler (1954), "Some Problems in Interval Estimation",
    Journal of the Royal Statistical Society, Series B,
    Vol.16, pp. 175-185.

    R. G. Krutchkoff (1967).  "Classical and Inverse Methods of
    Calibration", Technometrics, Vol. 9, pp. 425-439.

    B. Hoadley (1970).  "A Bayesian Look at Inverse Linear
    Regresssion", JASA, Vol. 65, pp. 356-369.

    H. Scheffe (1973).  "A Statistical Theory of Calibration",
    Annals of Statistics, Vol. 1, pp. 1-37.

    P. J. Brown (1982).  "Multivariate Calibration", (with
    discussion), JRSBB, Vol. 44, pp. 287-321.

    A. Racine-Poon (1988).  "A Bayesian Approach to Nonlinear
    Calibration Problems", JASA, Vol. 83, pp. 650-656.

    C. Osborne (1991).  "Statistical Calibration: A Review",
    International Statistical Review, Vol. 59, pp. 309-336.

    Hamilton (1992).  "Regression with Graphics: A Second Course
    in Applied Statistics", Duxbury Press.

Applications:
    Calibration
 
Implementation Date:
    2003/07
    2011/07: Support for Fieler methods
    2016/11: Support fit with no intercept term
    2016/11: Support for propogation of error methods given in
             NIST/SEMATECH Engineering Statistics Handbook
    2017/11: Add coverage factor and expanded error columns to output
 
Program 1:
    SKIP 25
    READ NATR533.DAT Y X
    LET Y0 = DATA 150 200 250 300
    .
    SET WRITE DECIMALS 4
    LINEAR CALIBRATION Y X Y0

Program 2:
    skip 25
    read loadcell.dat x y
    .
    let y0 = sequence 2 0.1 5
    set write decimals -7
    quadratic calibration y x y0

Program 3:
    .  Step 1: Read the data
    .
    dimension 20 columns
    .  x = Dose
    .  y = Response
    .
    read  x y
    1     0.4148
    1     0.4173
    1     0.4141
    1     0.4156
    2     0.8321
    2     0.8315
    2     0.8317
    2     0.8285
    3     1.2396
    3     1.2367
    3     1.2356
    3     1.2343
    5     2.0127
    5     2.0281
    5     2.0321
    5     2.0260
    7     2.7950
    7     2.7948
    7     2.7962
    7     2.8022
    10     3.8656
    10     3.8625
    10     3.8695
    10     3.8668
    20     7.1166
    20     7.1236
    20     7.1132
    20     7.1079
    30     9.8641
    30     9.8512
    30     9.8558
    30     9.8498
    50     14.0724
    50     14.0646
    50     14.0644
    50     14.0801
    70     17.0616
    70     17.0760
    70     17.0488
    70     17.1096
    100     20.3078
    100     20.2990
    100     20.3642
    100     20.3210
    end of data
    .
    let n = number y
    .
    .  Step 2: Perform initial fit.  Save parameter estimates
    .          to use as starting values for bootstrap fits.
    .
    fit y = a*(1-exp((-x)/b))
    let astart = a
    let bstart = b
    .
    .  Step 3: Save predicted and residual values from initial fit.
    .
    .          The "y0" identifies the distinct points in predicted
    .          values.  These are the calibration points.
    .
    let res2 = res
    let pred2 = pred
    let y0 = distinct pred2
    let ndist = size y0
    let xtag = sequence 1 1 ndist
    .
    .  Step 4: Perform first bootstrap sample
    .
    .          Note that bootstrap sample is drawn from
    .          the residuals of the fit, not the original
    .          observations.  Add the bootstrapped residuals
    .          to the predicted values to obtain the new
    .          set of observations.
    .
    .          The "x0" points are the inverse calibration points.
    .
    let a = astart
    let b = bstart
    let ind = bootstrap index for i = 1 1 n
    let res3 = bootstrap sample res2 ind
    let y3 = pred2+res3
    fit y3 = a*(1-exp((-x)/b))
    let x0 = (-b)*log(1-(y0/a))
    let tag = xtag
    .
    .  Step 5: Now generate the remaining bootstrap
    .          samples.
    .
    let numboot = 500
    loop for k = 2 1 numboot
        let a = astart
        let b = bstart
        let ind = bootstrap index for i = 1 1 n
        let res3 = bootstrap sample res2 ind
        let y3 = pred2+res3
        fit y3 = a*(1-exp((-x)/b))
        let xtemp = (-b)*log(1-(y0/a))
        extend tag xtag
        extend x0  xtemp
    end of loop
    .
    .  Step 6: Now compute the mean and standard deviation
    .          of each of the calibration points.
    .
    skip 1
    tabulate standard deviation x0 tag
    read dpst1f.dat junk sb
    tabulate mean x0 tag
    read dpst1f.dat junk mb
    let rb = (sb/mb)*100
    .
    write y0 mb sb rb

-----CALL-------------------------------------------------------
 
CALL
 
Name:
    CALL
 
Type:
    Support Command
 
Purpose:
    Accesses and executes the specified DATAPLOT macro (= subroutine)
    stored on mass storage file.  CALL is identical to ADD.  CALL is
    the preferred command to use.
 
Description:
    DATAPLOT macros are files containing DATAPLOT commands.  These are
    ASCII text files that can be created and edited with any standard
    text editor available on your system.  The CREATE command can be a
    convenient way to generate a macro file (it simply echoes commands
    entered interactively to a file).
 
    Macros have several uses:

      1) The same set of commands can be used with different data sets.
         Common analyses can be stored for repeated use.
      2) An analysis can be archived for later reference.
      3) A complicated analysis can be broken down into smaller, more
         manageable steps.
      4) Analysis techniques not supported directly by DATAPLOT can be
         coded in a macro that can be made available to other users.
 
Syntax:
    CALL    <file name>
    where <file name> is the name of a file containing DATAPLOT
    commands.  If the file name does not contain a period, place a
    period (no spaces) at the end of the file name.
 
Examples:
    CALL PLOTCALIB.
    CALL PROG.PLOTLAB
 
Note:
    DATAPLOT has no restrictions on the file name other than it be a
    valid file name on the local operating system and that it contain
    a period "." in the file name itself or as a trailing character.
    DATAPLOT strips off trailing periods on those systems where it is
    appropriate to do so.  On systems where trailing periods can be a
    valid file name (e.g., Unix), DATAPLOT tries to open the file with
    the trailing period.  If this fails, it then tries to open the file
    with the trailing period stripped off.
 
    Some users prefer to give all macro files a ".DP" or ".dp"
    extension.  Although this is a useful method for keeping track of
    macro files, it is strictly a user convention and is not enforced
    by DATAPLOT in any way.
 
Note:
    File names are case sensitive on Unix file systems.  For Unix,
    DATAPLOT attempts to open the file as given.  If this fails, it
    attempts to open the file as all upper case characters.  If this
    fails, it attempts to open the file as all lower case characters.
    All other currently supported systems are not case sensitive
    regarding file names.
 
    As a further caution for Unix hosts, certain expansion characters
    (specifically ~ to refer to your home directory) are interperted
    by the shell and are not recognized by the Fortran compiler.  These
    expansion characters are interperted as literal characters and do
    not yield the intended file name.
 
Note:
    A large number of sample macros are provided with the DATAPLOT
    installation.  Print the on-line directory file for a list of these
    macros (they are not documented in HELP).  See your local site
    installer if you do not have a copy of this file.
 
    If DATAPLOT can not open a macro file as given, it looks for it in
    the directory where the DATAPLOT reference files are stored.  This
    means that you can run the sample macros by simply typing the name
    of the file (i.e., no directory name is required).  However, be
    aware that the file extensions can vary on some operating systems.
 
Note:
    All variables are global in DATAPLOT.  This means that the macro
    file can use any parameters or variables defined in the calling
    program.  There is no mechanism for passing arguments to the macro.
    However, the use of the NAME command or the substitute character
    can be used to mimic this capability.  For example, the calling
    program can enter LET STRING VAR1 = PRESSURE while in the macro
    you do something like PLOT ^VAR1.
 
Note:
    The ability to pass arguments to macros was implemented
    11/2005.  Enter

        HELP MACRO SUBSTITUTION CHARACTER

    for details.

Note:
    Starting with the 07/2010 version of Dataplot, if a file name
    is given as the first argument on the command, then this file
    will be run as a macro.

Note:
    The following commands were implemented 03/2015:

        CALL EXIT
        CALL EXIT ALL

    The CALL EXIT command will exit the currently running macro.  The
    CALL EXIT ALL command will exit all currently running macros and
    return control to the keyboard.

    These commands are typically used in error checking sections of
    macros.  That is, if a sufficiently serious error is detected, the
    macro can essentially be terminated with these commands without
    exiting Dataplot.

Note:
    The command

        PROBE MACRO SWITCH

    can be used to determine the current setting of the macro switch.
    It can have one of the following values

        OFF   - no macro is currently running
        EXEC  - a macro is currently executing
        ON    - the CREATE command has been entered
        EOF   - a CALL EXIT command has been entered or an EOF has been
                encountered in the macro file

    Most typically, this command would be entered to determine if we are
    currently running a macro (i.e., checking for either OFF or EXEC).

    If you are running nested macros, you can determine the current
    nesting level with the command

        PROBE MACRO LEVEL

    A value of 0 means that no macro is currently running.

Default:
    None
 
Synonyms:
    ADD, RUN, EXECUTE
 
Related Commands:
    CREATE        = Starts copying commands to macro file.
    END OF CREATE = Stops copying commands to macro file.
    LIST          = Lists the contents of a file (including macro and
                    data files).
 
Applications:
    Program Control
 
Implementation Date:
    Pre-1987
    2005/11: Support for arguments added
    2010/07: If file name given as command, run it as a macro
    2014/10: Maximum number of arguments to CALL increased from 10 to 50
    2015/03: CALL EXIT and CALL EXIT ALL added
 
Program:
    CALL MINITEST.DP
 
-----CANBERRA DISTANCE (LET)-------------------------------------
 
CANBERRA DISTANCE
 
Name:
    CANBERRA DISTANCE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the Canberra distance between two variables.
 
Description:
    The Canberra distance between two variabes X and Y is
    defined as
 
        D = SUM[i=1 to n][|X(i) - Y(i)|/(|X(i)| + |Y(i)|)]

    The Canberra distance is a weighted version of the Manhattan
    distance.

Syntax:
    LET <par> = CANBERRA DISTANCE <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Canberra distance
              is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Examples:
    LET A = CANBERRA DISTANCE Y1 Y2
    LET A = CANBERRA DISTANCE Y1 Y2  SUBSET Y1 > 0 SUBSET Y2 > 0

Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    MANHATTAN DISTANCE      = Compute the Manhattan distance.
    COSINE DISTANCE         = Compute the cosine distance.
    EUCLIDEAN DISTANCE      = Compute the Euclidean distance.
    MATRIX DISTANCE         = Compute various distance metrics for
                              a matrix.

Applications:
    Mathematics
 
Implementation Date:
    2018/08
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET DIST  = CANBERRA DISTANCE Y1 Y2
    SET WRITE DECIMALS 4
    TABULATE CANBERRA DISTANCE Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    LET NDIST = UNIQUE X
    XLIMITS 1 NDIST
    MAJOR X1TIC MARK NUMBER NDIST
    MINOR X1TIC MARK NUMBER 0
    CHAR X
    LINE BLANK
    LABEL CASE ASIS
    CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    TITLE Canberra Distance (IRIS.DAT)
    Y1LABEL Canberra Distance
    CANBERRA DISTANCE PLOT Y1 Y2 X

-----CANTOR NUMBERS (LET)-----------------------------------------
 
CANTOR NUMBERS
 
Name:
    CANTOR NUMBERS (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Generate a sequence of Cantor numbers.
 
Description:
    Cantor numbers are derived from Cantor sets.  A cantor set is
    formed by representing the numbers from 0 to 1 as a line segment.
    You remove the middle third which leaves 2 line segments.  These
    2 line segments have their middle third removed which leaves 4
    line segments.  This procedure is duplicated an infinite number of
    times.
 
    The Cantor numbers are the starting points of the removed segments
    generated at each step (starting points of blank segments created
    at prior steps are not duplicated).
 
Syntax:
    LET <resp> = CANTOR NUMBERS FOR I = <start> <inc> <stop>
    where <resp> s a variable where the Cantor numbers are stored;
          <start>, <inc>, and <stop> identify the start, increment, and
              stop points of the Cantor sequence.  The <start> and
              <inc> values are almost always 1.  If they are not,
              <resp> will still contain <stop> elements, but the
              skipped elements will contain zeros.
 
Examples:
    LET YCANT = CANTOR NUMBERS FOR I = 1 1 100
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SEQUENCE       = Generate a sequence of numbers.
    PATTERN        = Generate numbers with a specific pattern.
 
Reference:
    "Chaos", James Gleick, Penguin Press, 1987 (pp. 91-94).
 
Applications:
    Chaos, fractals
 
Implementation Date:
    XX
 
Program:
    LET YCANT = CANTOR NUMBERS FOR I = 1 1 100
 
-----CAPABILITY ANALYSIS----------------------------------------------
 
CAPABILITY ANALYSIS
 
Name:
    CAPABILITY ANALYSIS
 
Type:
    Analysis Command
 
Purpose:
    Generates a table of capability analysis statistics.
 
Description:
    The Cp, Cpk, percent defective, and expected loss statistics are
    printed in a table.  These statistics are computed for the full
    sample.  See the documentation for CP, CPK, PERCENT DEFECTIVE, and
    EXPECTED LOSS for the details on how these statistics are
    calculated.
 
Syntax:
    CAPABILITY ANALYSIS   <y>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response (= dependent) variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    CAPABILITY ANALYSIS Y
    CAPABILITY ANALYSIS Y SUBSET GROUP = 1 TO 6
 
Note:
    The upper and lower specification limits, the target value, and the
    cost value must be specified by the user as follows:
        LET LSL = <value>
        LET USL = <value>
        LET TARGET = <value>
        LET USLCOST = <value>
 
Note:
    The following enhancements were made 4/2001.

    1) The following statistics were added:

       CPL, CPU, CNPK, CPM, CC

       Enter 

          HELP CPL
          HELP CPU
          HELP CNPK
          HELP CPM
          HELP CC

       for details on how these statistics are computed.

    2) The mean and standard deviation are printed.

    3) Confidence intervals (95% level) are printed for the CP,
       CPK, CPM, CPL, and CPU statistics.

       a) The confidence interval for the CP statistic is:

             CPHAT*SQRT(CHSPPF(N-1,1-alpha/2)/(N-1)) <= CP <=
                   CPHAT*SQRT(CHSPPF(N-1,alpha/2)/(N-1)),
             
          where CPHAT is the estimated CP statistic ad N is
          the sample size.

       b) The confidence interval for the CPM statistic is:

             CPMHAT*SQRT(CHSPPF(N-1,1-alpha/2)/(N-1)) <= CPM <=
                   CPMHAT*SQRT(CHSPPF(N-1,alpha/2)/(N-1)),
             
          where CPMHAT is the estimated CPM statistic ad N is
          the sample size.

       b) The confidence interval for the CPU, CPL, and CPK
          statistics are:

             CHAT +/-  NORPPF(alpha/2)*SQRT(1/(9*N) + CHAT**2/(2*(N-1))

          where CHAT is the estimated CPK, CPL, or CPU statistic
          and N is the sample size.

    4) For the percent defective statistic, values are printed
       for the actual and expected number of defectives
       below and above the lower and upper specification limits.

    5) The following internal parameters are saved after the
       CAPABILITY ANALYSIS command:

          CPSTAT   - the value of the CP statistic
          CPLL     - the value of the lower confidence limit 
                     for CP
          CPUL     - the value of the upper confidence limit 
                     for CP
          CPKSTAT  - the value of the CPK statistic
          CPKLL    - the value of the lower confidence limit 
                     for CPK
          CPKUL    - the value of the upper confidence limit 
                     for CPK
          CPLSTAT  - the value of the CPL statistic
          CPLLL    - the value of the lower confidence limit 
                     for CPL
          CPLUL    - the value of the upper confidence limit 
                     for CPL
          CPUSTAT  - the value of the CPU statistic
          CPULL    - the value of the lower confidence limit 
                     for CPU
          CPUUL    - the value of the upper confidence limit 
                     for CPU
          CNPKSTAT - the value of the CNPK statistic
          CNPKLL   - the value of the lower confidence limit 
                     for CNPK
          CNPKUL   - the value of the upper confidence limit 
                     for CNPK
          CPMSTAT  - the value of the CPM statistic
          CPMLL    - the value of the lower confidence limit 
                     for CPM
          CPMUL    - the value of the upper confidence limit 
                     for CPM
          CCSTAT   - the value of the CCC statistic
          ACTUALPD - the value of the actual percent defective
                     statistic
          THEORPD  - the value of the theoretical percent defective
                     statistic
          ACTUALLL - the value of the actual percent defective
                     below the lower spec limit statistic
          THEORLL  - the value of the theoretical percent defective
                     below the lower spec limit statistic
          ACTUALUL - the value of the actual percent defective
                     above the lower spec limit statistic
          THEORUL  - the value of the theoretical percent defective
                     above the lower spec limit statistic

    These parameters can be used in subsequent Dataplot
    computations like any user created parameter.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CP                      = Computes the Cp statistic.
    CPK                     = Computes the Cpk statistic.
    PRECENT DEFECTIVE       = Computes the percent defective statistic.
    EXPECTED LOSS           = Computes the expected loss statistic.
    CP PLOT                 = Generates a Cp plot.
    CPK PLOT                = Generates a Cpk plot.
    EXPECTED LOSS PLOT      = Generates an expected loss plot.
    PERCENT DEFECTIVE PLOT  = Generates a percent defective plot.
    BOX PLOT                = Generates a box plot.
    XBAR CHART              = Generates an xbar control chart.
    PLOT                    = Generates a data or function plot.
 
Applications:
    Quality Control
 
Implementation Date:
    90/10

    Some additions made 2001/4.
 
Program:
    SKIP 25
    READ GEAR.DAT DIAMETER BATCH
    .
    LET LSL = 0.99
    LET USL = 1.01
    LET TARGET = 1.00
    LET USLCOST = 10
    .
    CAPABILITY ANALYSIS DIAMETER
 
-----CAPACITOR-------------------------------------------------------
 
CAPACITOR
 
Name:
    CAPACITOR
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Draws a (fixed value) capacitor (a component used in electronic
    circuit diagrams).
 
Description:
    The 2 pairs of coordinates define the (x,y) values for the
    start point and the end point respectively of the capacitor.
 
Syntax:
    CAPACITOR   <x1>   <y1>   <x2>   <y2>
    where <x1> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for the start point of
               the capacitor;
          <y1> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for the start point of
               the capacitor;
          <x2> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for the stop point of
               the capacitor;
    and   <y2> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for the stop point of
               the capacitor.
 
Examples:
    CAPACITOR 50 50 60 60
    CAPACITOR 50 50 60 60
    CAPACITOR 20 40 20 60
    CAPACITOR 40 80 60 80
    CAPACITOR 60 20 60 40
 
Note:
    The line style (i.e., solid, dash), color, and thickness are
    controlled by the LINE, LINE COLOR, and LINE THICKNESS commands.
 
Note:
    The keywords DATA and RELATIVE were added to the TRIANGLE
    command 7/1997.  These keywords are independent and can
    be used separately or together.  For example, 
    TRIANGLE DATA, TRIANGLE RELATIVE, or TRIANGLE DATA RELATIVE.
    The word DATA should come before the word RELATIVE if both
    appear.

    DATA means that the coordinates are specified in terms of
    the data units of the most recent plot rather than Dataplot
    0 to 100 screen units.

    RELATIVE means that the coordinates of the first point
    are drawn in absolute coordinates an all subsequent points
    in the figure are relative to that first point.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    AMPLIFIER        = Draws an amplifier.
    GROUND           = Draws a ground.
    INDUCTOR         = Draws an inductor.
    RESISTOR         = Draws a resistor.
    MOVE             = Moves to a point.
    DRAW             = Draws a line.
    LINES            = Sets the line type for figures and plot lines.
    LINE THICKNESSES = Sets the line thickness for figures and  plot
                       lines.
    LINE COLOR       = Sets the line colors for figures and plot lines.
    CROSS-HAIR       = Activates and reads the cross-hair.
    TEXT             = Writes a text string.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    Pre-1987
 
Program:
    LINE SOLID
    LINE COLOR BLACK
    LINE THICKNESS 0.2
    CAPACITOR 20 70 50 70
 
-----CAPTURE-------------------------------------------------------
 
CAPTURE
 
Name:
    CAPTURE
 
Type:
    Support Command
 
Purpose:
    Redirects DATAPLOT alphanumeric output to the specified file rather
    than to the screen.  The END OF CAPTURE command reverts
    alphanumeric output back to the screen.
 
Description:
    The CAPTURE command is useful for adding DATAPLOT output from FITS
    into reports, printing out debugging information, and generally
    saving DATAPLOT output for future use.
 
Syntax 1:
    CAPTURE    <file name>
    where <file name> is the name of a file where alphanumeric output
    is written.  If the file name does not contain a period, place a
    period (no spaces) at the end of the file name.
 
    This is the standard form of the CAPTURE command.

Syntax 2:
    CAPTURE  FLUSH
 
    This command closes the current capture file, issues an
    ERASE command to the open graphics devices, and then prints
    the contents of the capture output on the graphics devices
    using the TEXT command (i.e., each line of the capture
    command is printed using a distinct TEXT command).  The
    capture file is then re-opened (it will start at the beginning).

Syntax 3:
    CAPTURE HTML <file name>
    where <file name> is the name of a file where alphanumeric output
    is written.  If the file name does not contain a period, place a
    period (no spaces) at the end of the file name.
 
    This syntax writes the output in HTML format.
 
Examples:
    CAPTURE FITOUT.DAT
        ... DATAPLOT COMMANDS ....
    END OF CAPTURE
 
Note:
    DATAPLOT has the following restrictions on the file name:

       1) The file name should be a valid file name on the local
          operating system.

       2) It must contain a period "." in the file name itself or as a
          trailing character.  DATAPLOT strips off trailing periods on
          those systems where it is appropriate to do so.  On systems
          where trailing periods can be a valid file name (e.g., Unix),
          DATAPLOT opens the file with the trailing period.
 
       3) On systems where file names are case sensitive (i.e., Unix),
          the case is preserved as entered on the CAPTURE command.

       4) The file name cannot contain more than 80 characters.

       5) If the file name contains a space, then use the SET FILE
          NAME QUOTE command and enclose the file name in quotes.
          For example,

             SET FILE NAME QUOTE ON
             CAPTURE "junk temp.out"

Note:
    The capture command can be toggled on and off (END OF CAPTURE
    redirects alphanumeric output to the screen).  However, a new file
    name should be used each time since invoking a new CAPTURE command
    overwrites any existing file (END OF CAPTURE automatically closes
    the file).
 
Note:
    The CAPTURE command does not affect graphics output to the screen
    (unless a CAPTURE FLUSH command is issued).
 
Note:
    It is often helpful to turn both the feedback and echo on when
    CAPTURE is used in order to identify the command that generates the
    output.
 
Note:
    It is currently not possible to direct the output to both the
    screen and to a remote file.  However, the LIST command can be used
    after the END OF CAPTURE to print the contents of captured file.
 
    NOTE: The capability to do this is now available.  To
          specify that the output will be sent to both the capture
          file and the screen, enter the command

             CAPTURE SCREEN ON

          To restore the default that the ouput is sent only to
          the capture file, enter

             CAPTURE SCREEN OFF

Note:
    Sometimes it may be useful to selectively send output to the
    CAPTURE file.  You can do this with the following commands:

        CAPTURE SUSPEND
        CAPTURE RESUME

    where SUSPEND specifies that output will be sent to the
    screen rather than the CAPTURE file (note that the CAPTURE
    file remains open) and RESUME will send the output to
    the currently open CAPTURE file.  You can enter as many
    CAPTURE SUSPEND/CAPTURE RESUME sequences as you like
    between a CAPTURE/END OF CAPTURE session.

    Note that OFF is a synonym for SUSPEND and ON is a
    synonym for RESUME.

Note:
    The April, 2012 version of Dataplot added the command

        CAPTURE SCRIPT <filename>

    This command saves the subsequent commands to a file without executing
    them.  The intended purpose of this is to allow scripts for external
    programs (e.g., Python, Perl, and so on) to be created within a
    Dataplot macro.  You can subsequently use the SYSTEM command to execute
    the script.

    This command was updated 2016/12 in the following two ways.

        1. Changes were made so that the CAPTURE SCRIPT would work
           correctly when embedded within a LOOP/END OF LOOP sequence.

        2. Added the command

              SET CAPTURE SCRIPT LOOP SUBSTITUTION <ON/OFF>

           If ON, then substitutions denoted by the "^" character will be
           performed before writing the line to the CAPTURE file.  If OFF,
           no substitution will be performed.  ON is the default.  The OFF
           is typically only needed if the "^" character is used and has
           a specific meaning you want to preserve (e.g., "^" is the
           exponentiation symbol in many scripting languages).

Note:
    The purpose of CAPTURE FLUSH command is to allow Dataplot text
    output to be written to the graphics output file.  This can be
    useful when you are writing a macro and you want the analytic
    output (for example, the output from a fit) to be included with
    the graphics output.  The following shows a sample of how this
    command is used:

       device 1 x11
       device 2 postscript
       .
       title automatic
       skip 25
       read gear.dat y x
       .
       mean plot y x
       .
       move 5 95
       margin 5
       capture junk.dat
       tabulate mean y x
       capture flush
       end of capture
       .
       device 2 close
       system lpr dppl1f.dat

    The initial CAPTURE command directs text output to the
    file "junk.dat".  When the CAPTURE FLUSH command is
    encountered, the capture file is closed, an ERASE command
    is generated for the  graphics devices, the contents of
    the capture file are printed on the graphics devices using
    the TEXT command (i.e., each line of the file generates a
    distinct TEXT command), and then the capture file is re-opened
    (it will start at the beginning).

    Since the lines are generated with the TEXT command, the
    appearance of the text can be controlled with the various
    TEXT attribute commands.  Also, it is recommended that
    CRLF be set to ON (the default), a MOVE command be given to
    set the position for the first line of the text, and a MARGIN
    command be entered to set the beginning x-coordinate for the
    line.

    Some output may be too long to display on one page.  You
    can control the number of lines printed per page with the
    following command:

        SET CAPTURE LINES <value1>  ... <value5>

    Up to 5 values may be entered.  The first value is for the
    first page of output, the second value is for the second
    page of output, and so on.  If more than 5 values are
    entered, then the page limits start over (i.e., page 6 uses
    the value for page 1, page 7 uses the value for page 2, and
    so on).  The default is 25 lines for all pages.

    If the MULTIPLOT switch is ON, the initial page erase is
    suppressed.  The following example shows how this feature
    can be used:

       .
       device 1 x11
       device 2 ps
       device 1 font simplex
       .
       title automatic
       skip 25
       read gear.dat y x
       .
       multiplot 2 2
       multiplot corner coordinates 0 0 100 100
       multiplot scale factor 2
       .
       mean plot y x
       sd plot y x
       .
       move 5 98
       margin 5
       plot
       capture junk.dat
       tabulate mean y x
       capture flush
       end of capture
       move 5 98
       plot
       capture junk.dat
       tabulate sd y x
       capture flush
       end of capture
       .
       end of multiplot
       .

    Note that the null PLOT command is used to move to the
    next plot area without actually generating a plot.

    This example draws a mean and standard deviation plot
    on the first row and then suplements that with the numeric
    values generated using the TABULATE command on the second
    row.

    The following two commands are also available.

        SET CAPTURE NUMBER  <ON/OFF>
        SET CAPTURE BOX   <ON/OFF>

    If SET CAPTURE NUMBER ON is entered, the output lines are
    numbered.  This is primarily a convenience function to help
    determine what values to enter for the SET CAPTURE LINES command
    in order to generate breaks at the appropriate spots.

    If SET CAPTURE BOX ON is entered, a box will be drawn for each
    page of the output.  Use the BOX 1 CORNER COORDINATES command,
    before the CAPTURE FLUSH, to specify the cooridinates of the
    box.  Use the various BOX attribute commands to set the
    properties of the box.

Note:
    The April, 2012 version of Dataplot added the following command

        SET CAPTURE FLUSH ERASE <ON/OFF>

    This controls whether the CAPTURE FLUSH command performs the initial
    screen erase.  The ON setting specifies the default of performing this
    screen erase while the OFF setting suppresses this screen erase.

    This command does not apply when the MULTIPLOT switch is active.

Note:
    The December, 2015 version of Dataplot added the following commands

        SET CAPTURE CUMULATIVE <ON/OFF>
        SET CAPTURE SPLIT <ON/OFF>

    These commands are primarily used when Dataplot is being
    controlled by an external program (e.g., Python).

    When the SET CAPTURE CUMULATIVE switch is ON, Dataplot will
    close the capture file at the end of an Analysis command
    and then re-open the capture file in append mode.  This allows
    the external file to maintain a "cumulative" capture file
    without the Dataplot session manually closing and re-opening
    the capture file.

    If the SET CAPTURE SPLIT ON switch is given, then Dataplot
    will create a separate capture file each time an Analysis
    command is entered.  Note that this is in addition to the
    specified capture file.  For example, if the commands

        SET CAPTURE FILE SPLIT ON
        CAPTURE CUMCAP.OUT

    commands are given, then the file CUMCAP.OUT will contain all the
    alphanumeric output.  In addition, the files

        CUMCAP_1.OUT
        CUMCAP_2.OUT
             ...

    will also be generated.  The split occurs whenever an Analysis
    command is entered.  This command makes it easier for an
    external program to extract a desired subset of the output.

    The default is for both of these switches to be OFF.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CAPTURE HTML        = Write Dataplot output to an external file in
                          HTML format.
    CAPTURE LATEX       = Write Dataplot output to an external file in
                          LATEX format.
    CAPTURE RTF         = Write Dataplot output to an external file in
                          RTF format.
    END OF CAPTURE      = Revert alphanumeric output back to the screen.
    LIST                = Lists the contents of a file.
    CALL                = Execute commands stored in a file.
    CREATE              = Echo entered commands to a file.
    POSTSCRIPT CONVERT  = Automatically generate JPEG, PDF, TIFF, PBM,
                          PGM, PPM, or PNM from postscript output.
 
Applications:
    Saving Alphanumeric Output
 
Implementation Date:
    Pre-1987
    2002/07: CAPTURE FLUSH feature added
    2002/08: CAPTURE HTML and CAPTURE LATEX feature added
    2002/11: CAPTURE HTML support for PNG, JPEG, and SVG
    2003/01: CAPTURE HTML support for Postscript and PDF
    2006/01: CAPTURE SCREEN ON/OFF added
    2006/01: CAPTURE SUSPEND/RESUME added
    2012/04: CAPTURE SCRIPT added
    2015/12: SET CAPTURE CUMULATIVE added
    2015/12: SET CAPTURE SPLIT added
    2016/12: CAPTURE SCRIPT corrected to work within a loop
    2016/12: SET CAPTURE SCRIPT LOOP SUBSTITUTION added
 
Program:
    ECHO ON
    FEEDBACK ON
    CAPTURE FITOUT.DAT
    FIT Y X1 X2
    END OF CAPTURE

-----CAPTURE HTML--------------------------------------------------

CAPTURE HTML

Name:
    CAPTURE HTML

Type:
    Support Command

Purpose:
    The CAPTURE HTML command redirects Dataplot alphanumeric output
    from the screen to the specified file and formats using
    HTML syntax.  The END OF CAPTURE command reverts alphanumeric
    output back to the screen.

Description:
    The CAPTURE HTML command is useful for generating Dataplot
    output in a format suitable for viewing by a web browser
    such as Netscape or Internet Explorer.

    As of the 2013/12 version of Dataplot, most of the Analysis commands
    support HTML formatted output.  The following are the Analysis
    commands that do not yet support HTML formatted output (these commands
    use the <PRE> ... </PRE> syntax, that is, an "asis" format).

        ARMA
        DDS
        ORTHOGONAL DISTANCE FIT
        PRE-FIT
        RECIPE
        SEASONAL LOWESS
        SIMCOV
        SMOOTH

    In addition, WRITE HTML can be used to generate 1-way
    tables in HTML format.  This is described in more detail
    in a Note below.

    The CAPTURE HTML option can be used in conjunction with the WEB
    command.  For example,

       SKIP 25
       READ RIPKEN.DAT Y X1 X2
       ECHO ON
       CAPTURE HTML C:\TABLE.HTM
       TABULATE MEAN Y X1
       CROSS TABULATE MEAN Y X1 X2
       END OF CAPTURE
       WEB file://C:\TABLE.HTM

    In addition, if DEVICE 2 is set to PNG, JPEG, SVG, or Postscript,
    Dataplot will incorporate the graphics into the web page using the
    IMG tag (the SVG device uses the EMBED tag).  This is demonstrated
    in the sample program below.

    For Postscript graphics, Dataplot uses the Ghostscript command
    to convert the output to JPEG.  A couple of points to note on
    this:

    1. This assumes that Ghostscript is installed on your
       system.  For Unix platforms, Ghostscript is launched with
       a "gs" command.  On Windows platforms, Ghostscript is
       launched with "C:\GS\GS704\GS\BIN\GSWIN32C.EXE".

       If you need to change the path for the Ghostscript command,
       enter the following command:

           SET GHOSTSCRIPT PATH  <path-name>

       For example, on my Windows system, I use

           SET GHOSTSCRIPT PATH F:\GS\GS704\GS\BIN\

       We suggest that you add this command to your Dataplot
       startup file "dplogf.tex".

    2. We suggest using either the ORIENTATION PORTRAIT or the
       ORIENTATION LANDSCAPE WORDPERFECT command to set the
       orientation.  Plots with a landscape orientation are
       rotated in the Dataplot Postscript output (in order to
       make full use of the page).  Currently, Ghostscript does
       not support a command line switch to rotate the graph.
       This means that landscape plots will be rotated vertically
       on the web page (you can use external programs to rotate
       the JPEG files if you like).

    The SET POSTSCRIPT CONVERT command can be used to automatically
    convert the Postscript output to one of several formats (JPEG,
    PDF, TIFF, PBM, PGM, PPM, PNM).  If the output is set to PDF
    (Portable Document Format), the CAPTURE HTML command will
    incorporate the PDF (rather than the Postscript) file into the
    web page.  For PDF files, Dataplot builds a link to the PDF file.
    The advantage of using PDF files is that they are typically of
    higher quality than the corresponding JPEG files.  The
    disadvantage is that you have to link to the file rather than
    having it directly in the page.

Syntax:
    CAPTURE HTML <file name>
    where <file name> is the name of a file where alphanumeric output
    is written.  If the file name does not contain a period, place a
    period (no spaces) at the end of the file name.
 
Examples:
    CAPTURE HTML  FITOUT.HTM
        ... DATAPLOT COMMANDS ....
    END OF CAPTURE
 
Note:
    DATAPLOT has the following restrictions on the file name:

       1) The file name should be a valid file name on the local
          operating system.

       2) It must contain a period "." in the file name itself or as a
          trailing character.  DATAPLOT strips off trailing periods on
          those systems where it is appropriate to do so.  On systems
          where trailing periods can be a valid file name (e.g., Unix),
          DATAPLOT opens the file with the trailing period.
 
       3) On systems where file names are case sensitive (i.e., Unix),
          the case is preserved as entered on the CAPTURE command.

       4) The file name cannot contain more than 80 characters.

       5) If the file name contains a space, then use the SET FILE
          NAME QUOTE command and enclose the file name in quotes.
          For example,

             SET FILE NAME QUOTE ON
             CAPTURE "junk temp.out"

Note:
    The capture command can be toggled on and off (END OF CAPTURE
    redirects alphanumeric output to the screen).  However, a new file
    name should be used each time since invoking a new CAPTURE command
    overwrites any existing file (END OF CAPTURE automatically closes
    the file).
 
Note:
    Dataplot provides the following switches for controlling
    what output Datplot generates:

       FEEDBACK <ON/OFF>
       PRINT <ON/OFF>

   The PRINT command controls most of the output generated by
   the Analysis category commands.  Output from most other commands
   is controlled by the FEEDBACK command.  The purpose of this
   distinction is to allow you to generate the output from
   commands such as FIT while suppressing most of the other
   output.

   When generating HTML format output, a common choice is

       PRINT ON
       FEEDBACK OFF

Note:
    You can create one-way tables using the command

        WRITE HTML <var-list>

    where <var-list> is a list of variables to print in an HTML
    table format.  Note that this command is typically entered
    after a CAPTURE HTML command.

    The following commands can be used to control the appearance
    of the HTML table:

        SET TABLE TITLE <text>              - allows you to specify a
                                              title for the generated
                                              table
        SET TABLE BORDER <ON/OFF/RULE/COLS> - specify what type of
                                              border the table will
                                              have
        SET TABLE SPACING <value>           - specify a value for
                                              the CELLSPACING option
                                              in the <TABLE> element
        SET TABLE WIDTH <value>             - specify the width of
                                              table columns in pixels

    The SET WRITE DECIMALS command can be used to specify how many
    digits after the decimal point will be printed (this will apply
    to all of the columns, currently there is no way to specify a
    different value for different columns).

    By default, the column headers will simply be the variable
    names.  However, if you have entered a VARIABLE LABEL command
    for a given variable, the label specified for that variable
    will be used instead of the variable name.

Note:
    By default, Dataplot generates a fairly minimal header and
    footer for the HMTL output.  You can specify your own
    header and footer files with the comamnds

      SET HTML HEADER FILE <file-name>
      SET HTML FOOTER FILE <file-name>

   Enter HELP HTML HEADER FILE or HELP HTML FOOTER FILE for details.

Note:
    Dataplot is not a word processor.  The HTML code generated is
    fairly basic.  That is, Dataplot creates the basic table or
    list structure for the output.  However, it does not give you
    control over font sizes, colors, and so on.  We have written
    the HTML in a style which we believe is human readable/editable.

    If you want to modify the appearance of the HTML output, our
    recommendation is to either edit the file using an ASCII editor
    or use one of the HTML editors (we have no particular
    recommendations on the advantages/disadvantages of the various
    editors).

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CAPTURE             = Redirect alphanumeric output to a file.
    CAPTURE LATEX       = Redirect alphanumeric output to a file in
                          Latex format.
    END OF CAPTURE      = Revert alphanumeric output back to the screen.
    LIST                = Lists the contents of a file.
    CALL                = Execute commands stored in a file.
    CREATE              = Echo entered commands to a file.
    POSTSCRIPT CONVERT  = Automatically generate JPEG, PDF, TIFF, PBM,
                          PGM, PPM, or PNM from postscript output.
    HTML HEADER FILE    = Specify a file to use for the header of
                          the HTML output.
    HTML FOOTER FILE    = Specify a file to use for the footer of
                          the HTML output.
 
Applications:
    Web Output
 
Implementation Date:
    1/2004
 
Program:
    skip 25
    read gear.dat y x
    .
    line blank solid
    character x blank
    feedback off
    .
    capture html tabulate.htm
    .
    summary y
    tabulate mean y x
    tabulate sd y x
    .
    set ipl1na meanplot.jpg
    device 2 gd jpeg
    title mean plot
    y1label diameter
    x1label batch
    mean plot y x
    device 2 close
    end of capture
    .
    . file name below needs to be modified for your local system
    web file:///home/heckert/dataplot/solaris/tabulate.htm

-----CAPTURE LATEX--------------------------------------------------

CAPTURE LATEX

Name:
    CAPTURE LATEX

Type:
    Support Command

Purpose:
    The CAPTURE LATEX command redirects Dataplot alphanumeric output
    from the screen to the specified file and formats it using
    Latex syntax.  The END OF CAPTURE command reverts alphanumeric
    output back to the screen.

Description:
    Latex is a popular text processing system.  Although developed
    originally on Unix platforms, versions of Latex are available
    for Windows platforms as well.

    The CAPTURE LATEX command is useful for generating Dataplot
    output in a format suitable for inclusion into publications
    and reports.

    As of the 2013/12 version of Dataplot, most of the Analysis
    commands support LaTeX formatted output.  The following are
    the Analysis commands that do not yet support LaTeX formatted
    output (th output from these commands will be enclosed in a
    {\verbatim} ... {\verbatim} block (that is, an "asis" format).

        ARMA
        DDS
        ORTHOGONAL DISTANCE FIT
        PRE-FIT
        RECIPE
        SEASONAL LOWESS
        SIMCOV
        SMOOTH

    In addition, WRITE LATEX can be used to generate 1-way
    tables in Latex format.  This is described in more detail
    in a Note below.

    Dataplot generates a LaTeX file.  The LaTeX file is then
    typically processed by the "latex" command to create a
    Device Independent (DVI) file.  The DVI file is then processed
    by a command that converts the DVI output to a device specific
    format.  The following block of code uses the system command
    to process the LaTeX output to a Postscript format and then
    view it with Ghostview from within Dataplot (the names
    of the Latex/Ghostview commands may be different on your system).

       SKIP 25
       READ RIPKEN.DAT Y X1 X2
       CAPTURE LATEX table.tex
       TABULATE MEAN Y X1
       CROSS TABULATE MEAN Y X1 X2
       END OF CAPTURE
       .
       .  Following code invokes Latex/Ghostview commands.  It is
       . assumed that these programs are available on your system.
       . You may need to check how these commands are invoked on
       . your local system.
       .
       system latex table.tex
       system dvips table.dvi  > table.ps
       system ghostview  table.ps
       .

    In addition, if DEVICE 2 is set to Postscript, Dataplot will
    incorporate the graphics output into the Latex file.  Dataplot
    defines the commands LGRAPHIC and PGRAPHIC for importing
    Postscript commands into the Latex file in landscape and
    portrait mode, respectively.

Syntax:
    CAPTURE LATEX <file name>
    where <file name> is the name of a file where alphanumeric output
    is written.  If the file name does not contain a period, place a
    period (no spaces) at the end of the file name.
 
Examples:
    CAPTURE LATEX  FITOUT.TEX
        ... DATAPLOT COMMANDS ....
    END OF CAPTURE
 
Note:
    DATAPLOT has the following restrictions on the file name:

       1) The file name should be a valid file name on the local
          operating system.

       2) It must contain a period "." in the file name itself or as a
          trailing character.  DATAPLOT strips off trailing periods on
          those systems where it is appropriate to do so.  On systems
          where trailing periods can be a valid file name (e.g., Unix),
          DATAPLOT opens the file with the trailing period.
 
       3) On systems where file names are case sensitive (i.e., Unix),
          the case is preserved as entered on the CAPTURE command.

       4) The file name cannot contain more than 80 characters.

       5) If the file name contains a space, then use the SET FILE
          NAME QUOTE command and enclose the file name in quotes.
          For example,

             SET FILE NAME QUOTE ON
             CAPTURE "junk temp.out"

Note:
    The capture command can be toggled on and off (END OF CAPTURE
    redirects alphanumeric output to the screen).  However, a new file
    name should be used each time since invoking a new CAPTURE command
    overwrites any existing file (END OF CAPTURE automatically closes
    the file).
 
Note:
    Dataplot provides the following switches for controlling
    what output Datplot generates:

       FEEDBACK <ON/OFF>
       PRINT <ON/OFF>

   The PRINT command controls most of the output generated by
   the Analysis category commands.  Output from most other commands
   is controlled by the FEEDBACK command.  The purpose of this
   distinction is to allow you to generate the output from
   commands such as FIT while suppressing most of the other
   output.

   When generating LaTeX formatted output, a common choice is

       PRINT ON
       FEEDBACK OFF

Note:
    You can create one-way tables using the command

        WRITE LATEX <var-list>

    where <var-list> is a list of variables to print in a LaTeX
    table format.  Note that this command is typically entered
    after a CAPTURE LATEX command.

    The following commands can be used to control the appearance
    of the LaTeX table:

        SET TABLE TITLE <text>              - allows you to specify a
                                              title for the generated
                                              table
        SET TABLE BORDER <ON/OFF/RULE/COLS> - specify what type of
                                              border the table will
                                              have

    The SET WRITE DECIMALS command can be used to specify how many
    digits after the decimal point will be printed (this will apply
    to all of the columns, currently there is no way to specify a
    different value for different columns).

    By default, the column headers will simply be the variable
    names.  However, if you have entered a VARIABLE LABEL command
    for a given variable, the label specified for that variable
    will be used instead of the variable name.

Note:
    By default, Dataplot generates the folllowing code at the
    beginning of the LaTeX file:

        \documentclass[12pt]{article}
         
        \usepackage{epsfig}
         
        \setlength{\textwidth}{6.25in}
        \setlength{\textheight}{9in}
        \setlength{\oddsidemargin}{0.25in}
        \setlength{\evensidemargin}{0in}
        \setlength{\headheight}{0.5in}
        \setlength{\headsep}{0.5in}
        \setlength{\topmargin}{-1in}
        \setlength{\parindent}{0in}
        \setlength{\parskip}{10pt}
        \setlength{\textfloatsep}{4ex}
        \addtolength{\footskip}{0.25in}
        \overfullrule=0pt
        \baselineskip=12pt
         
        \newcommand{\PGRAPHIC}[1]{\begin{figure}[h]
                               \epsfig{file=#1,width=6.0in}
                               \end{figure}}
        \newcommand{\LGRAPHIC}[1]{\begin{figure}[h]
                               \epsfig{file=#1,angle=-90,width=6.0in}
                               \end{figure}}
         
        \begin{document}
         
        \begin{verbatim}

    and the following Latex code at the end of the file:

       \end{verbatim}

       \end{document}

    You can specify files containing what LaTeX code goes at
    the beginning and end of the LaTeX file with the commands

      SET LATEX HEADER FILE <file-name>
      SET LATEX FOOTER FILE <file-name>

    If you are going to incorporate Postscript graphics, be sure
    to include a PGRAPHIC and LGRAPHIC (for portrait and landscape
    orientation graphs, respectively).  You can edit the defintions
    given above, but you should have some definition for these
    since Dataplot uses PGRAPHIC and LGRAPHIC to insert the
    Postscript graphs.

    In particular, if you are going to insert the Dataplot generated
    LaTeX into a larger file, you might want to specify files that
    contain no active LaTeX code.

Note:
    Dataplot is not a word processor.  The LaTeX code generated is
    fairly basic.  That is, Dataplot creates the basic table or
    list structure for the output.  However, it does not give you
    control over font sizes, colors, and so on.

    If you want to modify the appearance of the LaTeX output,
    edit the generated LaTeX output using the ASCII editor of your
    choice.  We have written the LaTeX in a style which we believe
    is relatively easy to read and edit.

Note:
    The February, 2006 version of Dataplot added the capability to
    generate graphics in LaTeX format.  Enter HELP LATEX for details.

Note:
    The August 2014 version of Dataplot added the command

        SET LATEX RESIZE <ON/OFF>

    If this switch is set to ON, Dataplot will add the line

        \resizebox{\linewidth{{!} {

    to the beginning of LaTex tables.  This is useful for tables with
    a large number of columns.  This LaTex command automatically resizes
    the text size if needed when there are a large number of columns.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CAPTURE             = Redirect alphanumeric output to a file.
    CAPTURE HTML        = Redirect alphanumeric output to a file in
                          HTML format.
    END OF CAPTURE      = Revert alphanumeric output back to the screen.
    LIST                = Lists the contents of a file.
    CALL                = Execute commands stored in a file.
    CREATE              = Echo entered commands to a file.
    POSTSCRIPT CONVERT  = Automatically generate JPEG, PDF, TIFF, PBM,
                          PGM, PPM, or PNM from postscript output.
    LATEX HEADER FILE   = Specify a file to use for the header of
                          the LaTeX output.
    LATEX FOOTER FILE   = Specify a file to use for the footer of
                          the LaTeX output.
 
Applications:
    Web Output
 
Implementation Date:
    2003/10
    2014/08 Added SET LATEX RESIZE command

    Support for LaTex formatted output added for various Analysis
    commands over the years
 
Program:
    skip 25
    read gear.dat y x
    .
    line blank solid
    character x blank
    feedback off
    .
    capture latex tabulate.htm
    .
    summary y
    tabulate mean y x
    tabulate sd y x
    .
    set ipl1na meanplot.eps
    device 2 postscript encapsulated
    orientation landscape wordperfect
    title mean plot
    y1label diameter
    x1label batch
    mean plot y x
    device 2 close
    end of capture

-----CAPTURE RTF--------------------------------------------------

CAPTURE RTF

Name:
    CAPTURE RTF

Type:
    Support Command

Purpose:
    The CAPTURE RTF command redirects Dataplot alphanumeric output
    from the screen to the specified file and formats it using
    Rich Text Format (RTF) syntax.  The END OF CAPTURE command reverts
    alphanumeric output back to the screen.

Description:
    RTF is a protocal developed by Microsoft for importing text into word
    processors.  Specifically, it is supported by the Microsoft Word and
    Wordpad programs.

    Dataplot generated in RTF format will contain a certain
    amount of formatting information in addition to the text.
    The CAPTURE RTF command is useful for generating Dataplot
    output in a format suitable for inclusion into publications
    and reports.

    As of the 2013/12 version of Dataplot, most of the Analysis
    commands support RTF formatted output.  The following are
    the Analysis commands that do not yet support RTF formatted
    output (these commands use an "asis" format).

        ARMA
        DDS
        ORTHOGONAL DISTANCE FIT
        PRE-FIT
        RECIPE
        SEASONAL LOWESS
        SIMCOV
        SMOOTH

Syntax:
    CAPTURE RTF <file name>
    where <file name> is the name of a file where alphanumeric output
    is written.  If the file name does not contain a period, place a
    period (no spaces) at the end of the file name.
 
Examples:
    CAPTURE RTF  SAMPLE.RTF
        ... DATAPLOT COMMANDS ....
    END OF CAPTURE
 
Note:
    RTF is a public protocol that other vendors are free to implement.
    Although a number of non-Microsoft vendors support the importing of
    RTF files, our experience is that most of them do not successfully
    display the Dataplot RTF files.  The one exception is the ABIWORD
    program.  We have only tested a limited set of word processors, so
    you are free to test this with software other than Word or Wordpad.
    However, we caution you that it may not be successful.

    In summary, the Dataplot RTF files should display correctly in
    Microsoft Word, Microsoft WordPad, and ABIWORD.  If your Dataplot RTF
    file does not display correctly in Microsoft Word, Microsoft WordPad,
    or ABIWORD, then feel free to report this to the Dataplot support team
    (alan.heckert@nist.gov) as a potential bug.  If the Dataplot RTF file
    displays incorrectly in any other program, we will not investigate this
    as a potential Dataplot bug.

Note:
    Note that the current default document format in Microsoft Word is an
    XML-based standard.  In addition, there is an ISO standard for
    text documents (used by Open Office and Libre Office).  These formats
    are not currently supported.  As these formats probably have a longer
    future than RTF, we are considering adding one of these formats
    (translators are available for converting between these two formats,
    so we will only support one of them) as an alternative to RTF
    formatted output.

Note:
    Dataplot does not currently generate graphics in RTF format.  If
    you want to incorporate graphics into your RTF document, then
    generate them separately and then use the graphics file import
    capability in your word processor.

Note:
    Dataplot is not a word processor.  The RTF code generated is
    fairly basic.  That is, Dataplot creates the basic table or
    list structure for the output.  In addition, you can use
    the following commands

         SET RTF FIXED FONT  <font name>
         SET RTF PROPORTIONAL FONT  <font name>

    For the fixed fonts, you can specify one of
    following (COURIER NEW is the default)

         LUCINDA CONSOLE
         COURIER NEW

    For the proportioanl fonts, you can specify one of the
    following (TIMES NEW ROMAN is the default)

         LUCINDA SANS
         ARIAL
         TIMES NEW ROMAN
         BOOKMAN
         GEORGIA
         TAHOMA
         VERDANA

    If you want to make additional modifications to the appearance
    of the RTF output, you can do this once you import the RTF file
    into Word.

Note:
    DATAPLOT has the following restrictions on the file name:

       1) The file name should be a valid file name on the local
          operating system.

       2) It must contain a period "." in the file name itself or as a
          trailing character.  DATAPLOT strips off trailing periods on
          those systems where it is appropriate to do so.  On systems
          where trailing periods can be a valid file name (e.g., Unix),
          DATAPLOT opens the file with the trailing period.
 
       3) On systems where file names are case sensitive (i.e., Unix),
          the case is preserved as entered on the CAPTURE command.

       4) The file name cannot contain more than 80 characters.

       5) If the file name contains a space, then use the SET FILE
          NAME QUOTE command and enclose the file name in quotes.
          For example,

             SET FILE NAME QUOTE ON
             CAPTURE "junk temp.out"

Note:
    The capture command can be toggled on and off (END OF CAPTURE
    redirects alphanumeric output to the screen).  However, a new file
    name should be used each time since invoking a new CAPTURE command
    overwrites any existing file (END OF CAPTURE automatically closes
    the file).
 
Note:
    Dataplot provides the following switches for controlling
    what output Datplot generates:

       FEEDBACK
       PRINT

    The PRINT command controls most of the output generated by
    the Analysis category commands.  Output from most other commands
    is controlled by the FEEDBACK command.  The purpose of this
    distinction is to allow you to generate the output from
    commands such as FIT while suppressing most of the other
    output.

    When generating RTF format output, a common choice is

       PRINT ON
       FEEDBACK OFF

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CAPTURE             = Redirect alphanumeric output to a file.
    CAPTURE HTML        = Redirect alphanumeric output to a file in
                          HTML format.
    CAPTURE LATEX       = Redirect alphanumeric output to a file in
                          Latex format.
    END OF CAPTURE      = Revert alphanumeric output back to the screen.
 
Applications:
    Presentation Output
 
Implementation Date:
    1/2005
 
Program:
    SKIP 25
    READ STUTZ86.DAT ALITE JUNK2 JUNK3 JUNK4 JUNK5 LABID
    .
    CAPTURE RTF CONSMEAN.RTF
    CONSENSUS MEANS ALITE LABID
    END OF CAPTURE

-----CARRIAGE RETURN GAP (SET)-----------------------------------
 
CARRIAGE RETURN GAP
 
Name:
    CARRIAGE RETURN GAP (SET)
 
Type:
    Set Subcommand
 
Purpose:
    For multiline text written on a plot (TEXT, LEGEND, TITLE, LABEL,
    TIC MARK LABEL CONTENT commands), specify a "fudge" factor to add
    to the distance between the lines.
 
Description:
    In Dataplot you can specify multiple lines by using the "CR()"
    sequence.  For example, to create a multiline title, do something
    like

         TITLE This is Line Onecr()and This is Line Two

    The gap between the first line and the second line is based on the
    requested character size.  In some cases, you may want to increase
    the distance between the two lines.  The SET CARRIAGE RETURN GAP
    command can be used to add a fudge factor to the default distance.
    This fudge factor is specified in 0 to 100 screen units.

    Multiline text is most commonly used with the TITLE, TEXT, and
    TIC MARK LABEL commands.  When alphabetic tic mark labels are used,
    multiline labels can be a useful way to avoid overlap while still
    retaining meaningful labels.  The SET CARRIAGE RETURN GAP can be
    particularly useful when using the MULTIPLOT command.

Syntax:
    SET CARRIAGE RETURN GAP <value>
    where <value> is a number or parameter in the range -5 to 5.

    Typical values are in the range 0 to 1.  Although negative values
    are allowed (these actually decrease the default distance between
    lines), they are rarely used.

Examples:
    SET CARRIAGE RETURN GAP 0
    SET CARRIAGE RETURN GAP 0.1
    SET CARRIAGE RETURN GAP 0.5
 
Default:
    The default value is 0.1.
 
Synonyms:
    None
 
Related Commands:
    TEXT                    = Write a text string immediately.
    TITLE                   = Specify the title for a plot.
    LEGEND                  = Specify text to be generated on subsequent
                              plots.
    LABEL                   = Specify an x- or y-axis label for a plot.
    TIC MARK LABEL CONTENT  = Specify the content for alphabetic tic
                              mark labels.
 
Applications:
    Annotating Plots
 
Implementation Date:
    2019/02
 
Program 1:
    . Step 1:   Read the data and generate a fit
    .
    skip 25
    read berger1.dat y x batch
    skip 0
    .
    fit y x
    let a0 = round(a0,2)
    let a1 = round(a1,2)
    let cc = corr y x
    let cc = round(cc,2)
    .
    . Step 2:   Generate the plot
    .
    title offset 2
    title case asis
    label case asis
    legend case asis
    character case asis
    case asis
    .
    title Fit for Alaska Pipeline Data (File: BERGER1.DAT)
    x1label Lab Defect Size
    y1label Field Defect Size
    .
    line blank
    character X
    .
    plot y x
    .
    . Step 3:   Annotate the plot
    .
    set tab horizontal position 1 25
    set tab horizontal position 2 35
    set tab justification 1 right
    set tab justification 2 left
    set tab size  1 3
    .
    justification left
    move 17 85
    text a0:tab()^a0 tab()Intercept
    .
    move 17 82
    text a1:tab()^a1 tab()Slope
    .
    set carriage return gap 0.2
    set tab color 1 red
    set tab color 2 blue
    move 17 79
    text Corr:tab()^cc tab()Linearcr()Correlation

Program 2:
    skip 25
    read nor.dat      y1
    read exp.dat      y2
    read weibbury.dat y3
    read lgn.dat      y4
    read gamma.dat    y5
    read frechet.dat  y6
    let y x = stack y1 y2 y3 y4 y5 y6
    skip 0
    .
    case asis
    label case asis
    title case asis
    title offset 2
    multiplot corner coordinates 2 2 98 98
    multiplot scale factor 2
    set carriage return gap 0.5
    .
    . Step 2:   Plot normal a-d statistic
    .
    multiplot 2 2
    y1label Anderson-Darling Statistic
    x3label Datasets
    xlimits 1 6
    major xtic mark number 6
    minor xtic mark number 0
    x1tic mark offset 0.5 0.5
    x1tic mark label format alpha
    x1tic mark label content NOR.DAT sp()cr()sp()cr()EXP.DAT WEIBBURY.DAT ...
          sp()cr()sp()cr()LGN.DAT GAMMA.DAT sp()cr()sp()cr()FRECHET.DAT
    x1tic mark label size 1.2
    y1label displacement 12
    ylimits 0 1
    character X
    line blank
    .
    title Normal AD
    normal anderson darling plot y x
    .
    ylimits
    y1label Location
    title Normal AD Location
    normal anderson darling location plot y x
    .
    y1label Scale
    title Normal AD Scale
    normal anderson darling scale plot y x
    .
    end of multiplot
    .
    justification center
    move 50 3
    text Datasets

-----CASE-------------------------------------------------------
 
CASE
 
Name:
    CASE
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Specifies the case (upper versus lower) of:
    1) script (resulting from the TEXT command) to appear on diagrams;
    2) script appearing in titles, labels, and legends (resulting from
       TITLE, LABEL, and LEGEND) to appear on subsequent plots.
 
Description:
    DATAPLOT converts all command strings to upper case.  This means
    that entering text in upper or lower case is not sufficient to
    make it appear that way in subsequent plots or diagrams.  In order
    to get case sensitive text, use the CASE command to set the default
    case and then use the UC() and LC() character sequences within a
    text string to switch the case.
 
Syntax:
    CASE   <LOWER or UPPER>
    where LOWER specifies lower case and UPPER specifies upper case.
 
Examples:
    CASE UPPER
    CASE LOWER
    CASE
 
Note:
    The CASE command with no arguments sets the case to default.
 
Note:
    The CASE command sets the default case.  Case changes signified by
    the LC() and UC() character sequences within text strings are
    still honored.  The UC() and LC() case shifts are supported for
    text drawn with hardware characters as well as text drawn with
    software characters.
 
Note:
    The CASE command applies to all text.  There are CASE commands that
    set the case for particular elements of a plot (e.g., LEGEND CASE).
 
Default:
    All text is upper case.
 
Synonyms:
    None
 
Related Commands:
    LEGEND CASE        = Sets the case for plot legends.
    LABEL CASE         = Sets the case for plot labels.
    CHARACTER CASE     = Sets the case for plot characters.
    TITLE CASE         = Sets the case for the plot title.
    TEXT               = Writes a text string.
    FONT               = Sets the font for TEXT characters.
    HEIGHT             = Sets the height for TEXT characters.
    WIDTH              = Sets the width for TEXT characters.
    HW                 = Sets the height and width for TEXT characters.
    VERTICAL SPACING   = Sets the vertical spacing between text lines.
    HORIZONTAL SPACING = Sets the horizontal spacing between text
                         characters.
    THICKNESS          = Sets the thickness of TEXT characters.
    COLOR              = Sets the color for TEXT characters.
    JUSTIFICATION      = Sets the justification for TEXT.
    CR                 = Sets the carriage return after text.
    LF                 = Sets the line feed after text.
    CRLF               = Sets the carriage return/line feed after text.
    MARGIN             = Sets the carriage return column after text.
    ()                 = Allows math and Greek characters in text.
    MOVE               = Moves to a point.
    CROSS-HAIR (or CH) = Activates and reads the cross-hair.
    ERASE              = Erases the screen (immediately).
    COPY               = Copies the screen (immediately).
 
Applications:
    Presentation Graphics
 
Implementation Date:
    Pre-1987
 
Program:
    VERTICAL SPACING 6
    CRLF ON
    MARGIN 10
    FONT DUPLEX
    .
    HW 4 2
    MOVE 5 95
    TEXT JAPAN's 6-POINT PROGRAM FOR
    MOVE 5 89
    TEXT QUALITY MANUFACTURING
    MOVE 10 80
    CASE LOWER
    HW 2.6 1.3
    TEXT CIRC() QUALITY AUDITS
    TEXT CIRC() COMPANY-WIDE QUALITY CONTROL (CWQC)
    TEXT CIRC() QUALITY TRAINING AND EDUCATION
    TEXT CIRC() APPLICATION OF STATISTICAL METHODS
    TEXT CIRC() QUALITY CIRCLE ACTIVITIES
    TEXT CIRC() NATION-WIDE QUALITY CONTROL PROMOTIONAL ACTIVITIES
    CASE UPPER
    HW 2 1
    MOVE 5 10
    TEXT SOURCE: Q.C. TRENDS WINTER 1985, PAGES 22-23.
 
-----CAT---------------------------------------------------

CAT

Name:
    CAT
 
Type:
    Support Command
 
Purpose:
    This command lists the contents of a file.
 
Description:
    This command uses an operating system command to list the
    contents a file.

    For Unix/Linux/MacOS systems, the CAT command issues a

        cat ....

    command to the operating system.

    For Windows systems, the CAT command issues a

        TYPE ....

    command to the operating system.

    The string that follows the CAT on the command line
    is passed to the operating system as is.  Dataplot does no
    error checking of this string.

    This is a system dependent command.  It is currently supported
    for Unix/Linux/MacOS and Windows platforms.

Syntax:
    CAT <file-list>
    where <file-list> is a string containing the name of a file.

Examples:
    CAT FIT.DP
    CAT FIT.OUT
 
Note:
    The CAT capability can be implemented by direct use of the
    SYSTEM command.  For example, under Linux do something like

         system cat  fit.dp

    The motivation for adding this as a separate command is to
    allow the capability to be implemented in an operating
    system independent way.  This can be useful when writing
    general purpose macros that may be used on different
    operating systems.

Note:
    The Dataplot LIST command can also list the contents of a
    file.  However, there are some distinctions in how they
    work.  The LIST command explicitly opens the file and
    reads each line of the file and then prints it (a maximum
    of 240 characters per line will be read).  The CAT command
    issues an operating system command to display the file.

    One advantage of the LIST command is that the Dataplot
    directories will be searched if the file is not found in
    the current directory.  The CAT command will simply pass the
    file name to the operating system as entered.  The CAT command
    is not limited to 240 characters per line.  Also, the CAT
    command supports the use of wild cards in specifying the
    file name.

Note:
    By default, the output will be displayed one screen at a
    time.  If you want to suppress this pause, enter the command

         SET CAT MORE OFF

    To reset the default

         SET CAT MORE ON

Note:
    File names are case sensitive on Unix/Linux/MacOS file
    systems.  For this reason, case is preserved in passing the
    file name to the operating system.

Note:
    On Windows platforms, this command will be issued in "persistent"
    mode.  That is, the command prompt window that is initiated to run
    the command will remain up until you explicitly close it.  Enter
    HELP SYSTEM for more information on the persistent mode.

Default:
    None
 
Synonyms:
    TYPE is a synonym for CAT

Related Commands:
    SYSTEM      = Enter an operating system command within a
                  Dataplot session.
    LIST        = List the contents of a file.
    CD          = Change the current working directory.
    PWD         = Retrieve the current working directory.
    MKDIR       = Create a new directory.
    RM          = Delete one or more files.
    DIR         = List the contents of a directory.
 
Applications:
    Interactive Usage
 
Implementation Date:
    2019/09
 
Program:
    SKIP 25
    READ BERGER1.DAT Y X
    .
    CAPTURE FIT.OUT
    FIT Y X
    END OF CAPTURE
    .
    CAT FIT.OUT
 
-----CATCHER MATRIX (LET)----------------------------------------
 
CATCHER MATRIX
 
Name:
    CATCHER MATRIX (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the catcher matrix.
 
Description:
    The catcher matrix is defined as:

        C = X(X'X)**(-1)

    The X matrix is typically a design matrix for a multiple
    linear regression.

    The catcher matrix is useful for many regression diagnostic
    computations.  For example, the help for the FIT command
    describes the use of the catcher matrix in generating
    partial regression plots, partial leverage plots, and
    variance inflation factors.

    This command simplifies writing macros to compute these,
    as well as other, regression diagnostics.  Although this
    matrix can also be computed using Dataplot matrix commands,
    this requires the creation of a large number of data columns.
 
Syntax:
    LET <mat2> = CATCHER MATRIX <mat1>
               <SUBSET/EXCEPT/FOR qualification>
    where <mat1> is the design matrix for which the catcher matrix
                is to be computed;
          <mat2> is a matrix where the resulting catcher matrix
                is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional (and
                 rarely used in this context).
 
Examples:
    LET C = CATCHER MATRIX X
 
Note:
    Matrices are created with either the READ MATRIX command or the
    MATRIX DEFINITION command.  Enter HELP MATRIX DEFINITION and HELP
    READ MATRIX for details.
 
Note:
    The columns of a matrix are accessible as variables by appending an
    index to the matrix name.  For example, the 4x4 matrix C has
    columns C1, C2, C3, and C4.  These columns can be operated on like
    any other DATAPLOT variable.
 
Note:
    The maximum size matrix that DATAPLOT can handle is set when
    DATAPLOT is built on a particular site.  Enter the command
    HELP MATRIX DIMENSION for details on the maximum size matrix
    that can be accomodated.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FIT                  = Perform a least squares fit.
    MATRIX ADDITION      = Perform a matrix addition.
    MATRIX EIGENVALUES   = Compute the matrix eigenvalues.
    MATRIX EIGENVECTORS  = Compute the matrix eigenvectors.
    MATRIX EUCLID NORM   = Compute the matrix Euclidean norm.
    MATRIX MULTIPLICAT   = Perform a matrix multiplication.
    MATRIX SOLUTION      = Solve a system of linear equations.
    MATRIX INVERSE       = Compute a the inverse of a matrix.
    CORRELATION MATRIX   = Compute the correlation matrix of a matrix.
    VARIANCE-COVA MATRIX = Compute the variance-covariance matrix of a
                           matrix.
    PRINCIPLE COMPONENTS = Compute the principle components of a
                           matrix.
    SINGULAR VALUE DECOM = Compute the singular value decomposition of
                           a matrix.
 
Reference:
    "Applied Linear Statistical Models", 3rd ed., Neter, Wasserman, and
    Kunter, 1990, Irwin.
 
    "Applied Regression Analysis", 2nd ed., Draper and Smith, John
    Wiley, 1981.
 
    "Residuals and Influence in Regression", Cook and Weisberg, Chapman
    and Hall, 1982.
 
    "Regression Diagnostics", Belsley, Kuh, and Welsch, John Wiley,
    1980.
 
Applications:
    Regression Diagnostics
 
Implementation Date:
    2002/6
 
Program:
    DIMENSION 100 COLUMNS
    SKIP 25
    READ HALD647.DAT Y X1 X2 X3 X4
    SKIP 0
    LET N = SIZE X1
    LET X0 = SEQUENCE 1 1 N
    LET Z = CREATE MATRIX X0 X1 X2 X3 X4
    LET C = CATCHER MATRIX Z
    PRINT C
 
-----CATLAN (LET)--------------------------------
 
CATLAN
 
Name:
    CATLAN (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Catlan beta function.
 
Description:
    The Catlan beta function is defined as:

        B(s) = SUM((-1)**(k-1)/(2*k+1)**s,      s >= 1

    where the summation is for k = 0 to infinity.

    For better numerical stability, Dataplot actually
    computes B(s) - 1.

    Dataplot uses a Fortran translation of a C routine
    given in "Atlas For Computing Mathematical Functions"
    (see the Reference section below).
 
Syntax:
    LET <y> = CATLAN(<x>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, variable, or parameter (> 1);
          <y> is a variable or a parameter (depending on what <x> 
               is) where the computed Catlan beta - 1 values are
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CATLAN(2)
    LET A = CATLAN(X) 
    LET X2 = CATLAN(X) FOR X = 0.1 0.1 3.0
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ETA        = Compute the eta function.
    ZETA       = Compute the Riemann Zeta function.
    LAMBDA     = Compute the lambda function.
 
Reference:
    "Atlas For Computing Mathematical Functions",
    William J. Thompson, John wiley & Sons, 1997, pp. 147-151.
 
Applications:
    Special Functions
 
Implementation Date:
    1997/12
 
Program:
    TITLE AUTOMATIC
    PLOT CATLAN(X) FOR X = 1.01 0.01 5
 
-----CAUCDF (LET)--------------------------------
 
CAUCDF
 
Name:
    CAUCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard Cauchy (i.e, median=0, 75% point at 1)
    cumulative distribution function.
 
Description:
    The Cauchy distribution has the following probability density
    function:
       f(x) = 1/(PI*(1+x**2))
    The cumulative distribution is the area from negative infinity to x
    (i.e., the integral of the above function).  It has the formula:
       cdf(x) = 0.5 + arctan(x)/PI
 
    The input value can be any real number.  Since this is a
    probability function, the returned value will be between 0 and 1.
 
Syntax:
    LET <y2> = CAUCDF(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, a number, or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed Cauchy cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CAUCDF(3)
    LET A = CAUCDF(A1)
    LET X2 = CAUCDF(X1)
 
Note:
    The general form of the Cauchy pdf is:
       f(x) = S/(PI*(S**2+(x-T)**2))
    To find the cdf value for the general Cauchy distribution, do the
    following:
        LET T = <value>
        LET S = <value>
        LET PT = <value>
        LET NEWPT = (PT - T)/S
        LET CDFPT = CAUCDF(NEWPT)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CAUPDF = Compute the Cauchy probability density function.
    CAUPPF = Compute the Cauchy percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    TCDF   = Compute the T cumulative distribution function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, 1970.
 
Applications:
    XX
 
Implementation Date:
    94/4
 
Program:
    YLIMITS 0 1
    MAJOR YTIC NUMBER 6
    MINOR YTIC NUMBER 1
    YTIC DECIMAL 1
    XLIMITS -5 5
    XTIC OFFSET 0.6 0.6
    TITLE AUTOMATIC
    PLOT CAUCDF(X) FOR X = -5.5 0.01 5.5
 
-----CAUPDF (LET)--------------------------------
 
CAUPDF
 
Name:
    CAUPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard Cauchy (i.e, median=0, 75% point at 1)
    probability density function.
 
Description:
    The Cauchy distribution has the following probability density
    function:
       f(x) = 1/(PI*(1+x**2))
    The input value can be any real number.
 
Syntax:
    LET <y2> = CAUPDF(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, a number, or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed Cauchy pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CAUPDF(3)
    LET A = CAUPDF(A1)
    LET X2 = CAUPDF(X1)
 
Note:
    The general form of the Cauchy pdf is:
       f(x) = S/(PI*(S**2+(x-T)**2))
    To find the pdf value for the general Cauchy distribution, do the
    following:
        LET T = <value>
        LET S = <value>
        LET PT = <value>
        LET NEWPT = (PT - T)/S
        LET PDFPT = CAUPDF(NEWPT)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CAUCDF = Compute the Cauchy cumulative distribution function.
    CAUPPF = Compute the Cauchy percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    TCDF   = Compute the T cumulative distribution function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, 1970.
 
Applications:
    XX
 
Implementation Date:
    94/4
 
Program:
    YLIMITS 0 0.3
    YTIC OFFSET 0 0.03
    MAJOR YTIC NUMBER 4
    MINOR YTIC NUMBER 1
    YTIC DECIMAL 1
    XLIMITS -5 5
    XTIC OFFSET 0.6 0.6
    PLOT CAUPDF(X) FOR X = -5.5 0.01 5.5
 
-----CAUPPF (LET)--------------------------------
 
CAUPPF
 
Name:
    CAUPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard Cauchy (i.e, median=0, 75% point at 1) percent
    point function.
 
Description:
    The Cauchy distribution has the following probability density
    function:
       f(x) = 1/(PI*(1+x**2))
    The percent point function is the inverse of the cumulative
    distribution function.  The cumulative distribution sums the
    probability from 0 to the given x value (i.e., the integral of the
    above function).  The percent point function takes a cumulative
    probability value and computes the corresponding x value.
 
    The input value is a real number between 0 and 1 (since it
    corresponds to a probability).  The output value can be any real
    number.
 
Syntax:
    LET <y2> = CAUPPF(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, a number, or a parameter in the range 0
               to 1;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed Cauchy ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CAUPPF(0.9)
    LET X2 = CAUPPF(X1)
 
Note:
    The general form of the Cauchy pdf is:
       f(x) = S/(PI*(S**2+(x-T)**2))
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CAUCDF = Compute the Cauchy cumulative distribution function.
    CAUPDF = Compute the Cauchy probability density function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    TCDF   = Compute the T cumulative distribution function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, 1970.
 
Applications:
    XX
 
Implementation Date:
    94/4
 
Program:
    XLIMITS 0 1
    MAJOR XTIC NUMBER 6
    MINOR XTIC NUMBER 1
    XTIC DECIMAL 1
    TITLE AUTOMATIC
    PLOT CAUPPF(X) FOR X = 0.01 .01 0.99
 
-----CAUSF (LET)--------------------------------
 
CAUSF
 
Name:
    CAUSF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the standard Cauchy (i.e, median=0, 75% point at 1)
    sparsity function.
 
Description:
    The standard form of the Cauchy distribution has the following
    probability density function:
       f(x) = 1/(PI*(1+x**2))
    The sparsity function is the derivative of the percent point
    function, which is the inverse of the cumulative distribution
    function.  The cumulative distribution sums the probability from 0
    to the given x value (i.e., the integral of the above function).
    The percent point function takes a cumulative probability value and
    computes the corresponding x value.
 
    The input value is a real number between 0 and 1 (since it
    corresponds to a probability).  The output value can be any real
    number.
 
Syntax:
    LET <y2> = CAUSF(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable, a number, or a parameter in the range 0
               to 1;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed Cauchy sf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CAUSF(0.9)
    LET X2 = CAUSF(X1)
 
Note:
    The general form of the Cauchy pdf is:
       f(x) = S/(PI*(S**2+(x-T)**2))
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CAUCDF = Compute the Cauchy cumulative distribution function.
    CAUPDF = Compute the Cauchy probability density function.
    CAUPPF = Compute the Cauchy percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    TCDF   = Compute the T cumulative distribution function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, Houghton
    Mifflin, 1970 (chapter 16).
 
Applications:
    Probability Modeling
 
Implementation Date:
    94/4
 
Program:
    XLIMITS 0 1
    MAJOR XTIC NUMBER 6
    MINOR XTIC NUMBER 1
    XTIC DECIMAL 1
    TITLE AUTOMATIC
    PLOT CAUSF(X) FOR X = 0.01 .01 0.99
 
-----CBESSII (LET)--------------------------------
 
CBESSII
 
Name:
    CBESSII (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the complex component of the modified Bessel function of
    the first kind and order v for a complex argument where v is a
    non-negative real number.
 
Description:
    The modified Bessel function of the first kind with order v (v is a
    non-negative real number) can be defined as:

        Iv(z) = (z/2)**v*SUM((z**2/4)**k/(k!*GAMMA(v+k+1)))

    where the sum is for k from zero to infinity, GAMMA is the 
    Gamma function, and ! is the factorial function.
 
    The real part of the input argument must be less than the
    logarithm of the largest single precision number on the given 
    computer.  In addition, the input number times its complex 
    conjugate cannot be zero.

    The order is restricted to values between 0 and 100.

Syntax:
    LET <y2> = CBESSII(<r1>,<i1>,<v>) <SUBSET/EXCEPT/FOR qualification>
    where <r1> is the real component of a number, variable or
               parameter;
          <i1> is the complex component of a number, variable or
               parameter;
          <v> is a non-negative number, variable, or parameter that
               specifies the order of the Bessel function;
          <y2> is a variable or a parameter (depending on what
               <r1> and <i1> are) where the computed Bessel value is
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET X2 = CBESSII(2,1,2)
    LET A = CBESSII(2,2.5.5)
    LET A = CBESSII(R1,C1,3)
    LET A = CBESSII(R1,C1,ORDER)
 
Note:
    DATAPLOT uses the routine BESICF from the BESPAK library.  This
    library was written by David Sagin (Sookne), Computer Center, Tel
    Aviv University.

Note:
    DATAPLOT does not calculate this function for negative orders.
    However, the following relation can be used:

       I(-v)(z) = I(v)(z) + (2/PI)*SIN(v*PI)*K(v)(z)

    where z is a complex number and K(v) is the modified Bessel function
    of the third kind.  The functions CBESSIR, CBESSII, CBESSKR, and
    CBESSKI can be used to compute the relevant Bessel functions.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BESSIN  = Compute the modified Bessel function of order N and real
              argument.
    CBESSIR = Compute the real component of the modified Bessel
              function of order N and complex argument.
    CBESSJR = Compute the real component of the Bessel function of
              the first kind, order N, and complex argument.
    CBESSJI = Compute the complex component of the Bessel function of
              the first kind, order N, and complex argument.
    CBESSYR = Compute the real component of the Bessel function of
              the second kind, order N, and complex argument.
    CBESSYI = Compute the complex component of the Bessel function of
              the second kind, order N, and complex argument.
    CBESSKR = Compute the real component of the modified Bessel
              function of the third kind, order N, and complex
              argument.
    CBESSKI = Compute the complex component of the modified Bessel
              function of the third kind, order N, and complex
              argument.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (pages 355-433).
 
    "Note on Backward Recurrence Algorithms", Olver and Sookne,
    Mathematics of Computation, Volume 26, October 1972.

    "Recurrence Techniques for the Calculation of Bessel Functions",
    Goldstein and Thaler, Mathematics of Computation, Volume 13,
    April 1959.

    "Bessel Functions of Complex Argument and Integer Order", Sookne,
    Journal of Research of the National Bureau of Standards, Series B,
    Volume 77A, July-December, 1973.

Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    LET XR = SEQUENCE .1 .1 5
    LET XC = SEQUENCE .1 .1 5
    LET ORDER = 2
    LET YR = CBESSIR(XR,XC,ORDER)
    LET YI = CBESSII(XR,XC,ORDER)
 
-----CBESSIR (LET)--------------------------------
 
CBESSIR
 
Name:
    CBESSIR (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the real component of the modified Bessel function of the
    first kind and order v for a complex argument where v is a
    non-negative real number.
 
Description:
    The modified Bessel function of the first kind with order v (v is a
    non-negative real number) can be defined as:

        Iv(z) = (z/2)**v*SUM((z**2/4)**k/(k!*GAMMA(v+k+1)))

    where the sum is for k from zero to infinity, GAMMA is the 
    Gamma function, and ! is the factorial function.
 
    The real part of the input argument must be less than the
    logarithm of the largest single precision number on the given 
    computer.  In addition, the input number times its complex 
    conjugate cannot be zero.

    The order is restricted to values between 0 and 100.

Syntax:
    LET <y2> = CBESSIR(<r1>,<i1>,<v>) <SUBSET/EXCEPT/FOR qualification>
    where <r1> is the real component of a number, variable or
               parameter;
          <i1> is the complex component of a number, variable or
               parameter;
          <v> is a non-negative number, variable, or parameter that
               specifies the order of the Bessel function;
          <y2> is a variable or a parameter (depending on what
               <r1> and <i1> are) where the computed Bessel value is
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET X2 = CBESSIR(2,1,2)
    LET A = CBESSIR(2,2.5.5)
    LET A = CBESSIR(R1,C1,3)
    LET A = CBESSIR(R1,C1,ORDER)
 
Note:
    DATAPLOT uses the routine BESICF from the BESPAK library.  This
    library was written by David Sagin (Sookne), Computer Center, Tel
    Aviv University.

Note:
    DATAPLOT does not calculate this function for negative orders.
    However, the following relation can be used:

       I(-v)(z) = I(v)(z) + (2/PI)*SIN(v*PI)*K(v)(z)

    where z is a complex number and K(v) is the modified Bessel function
    of the third kind.  The functions CBESSIR, CBESSII, CBESSKR, and
    CBESSKI can be used to compute the relevant Bessel functions.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BESSIN  = Compute the modified Bessel function of order N and real
              argument.
    CBESSII = Compute the complex component of the modified Bessel
              function of order N and complex argument.
    CBESSJR = Compute the real component of the Bessel function of
              the first kind, order N, and complex argument.
    CBESSJI = Compute the complex component of the Bessel function of
              the first kind, order N, and complex argument.
    CBESSYR = Compute the real component of the Bessel function of
              the second kind, order N, and complex argument.
    CBESSYI = Compute the complex component of the Bessel function of
              the second kind, order N, and complex argument.
    CBESSKR = Compute the real component of the modified Bessel
              function of the third kind, order N, and complex
              argument.
    CBESSKI = Compute the complex component of the modified Bessel
              function of the third kind, order N, and complex
              argument.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (pages 355-433).
 
    "Note on Backward Recurrence Algorithms", Olver and Sookne,
    Mathematics of Computation, Volume 26, October 1972.

    "Recurrence Techniques for the Calculation of Bessel Functions",
    Goldstein and Thaler, Mathematics of Computation, Volume 13,
    April 1959.

    "Bessel Functions of Complex Argument and Integer Order", Sookne,
    Journal of Research of the National Bureau of Standards, Series B,
    Volume 77A, July-December, 1973.

Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    LET XR = SEQUENCE .1 .1 5
    LET XC = SEQUENCE .1 .1 5
    LET ORDER = 2
    LET YR = CBESSIR(XR,XC,ORDER)
    LET YI = CBESSII(XR,XC,ORDER)
 
-----CBESSJI (LET)--------------------------------
 
CBESSJI
 
Name:
    CBESSJI (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the complex component of the Bessel function of the first
    kind and order v for a complex argument where v is a non-negative
    real number.
 
Description:
    The Bessel function of the first kind with order v (v is a
    non-negative real number) can be defined as:

        Jv(z) = (z/2)**v*SUM((-z**2/4)**k/(k!*GAMMA(v+k+1)))

    where the sum is for k from zero to infinity, GAMMA is the 
    Gamma function, and ! is the factorial function.
 
    The imaginary part of the input argument must be less than the
    logarithm of the largest single precision number on the given 
    computer.  In addition, the input number times its complex 
    conjugate cannot be zero.

    The order is restricted to values between 0 and 100.

Syntax:
    LET <y2> = CBESSJI(<r1>,<i1>,<v>) <SUBSET/EXCEPT/FOR qualification>
    where <r1> is the real component of a number, variable or
               parameter;
          <i1> is the complex component of a number, variable or
               parameter;
          <v> is a non-negative number, variable, or parameter that
               specifies the order of the Bessel function;
          <y2> is a variable or a parameter (depending on what
               <r1> and <i1> are) where the computed Bessel value is
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET X2 = CBESSJI(2,1,2)
    LET AI = CBESSJI(2,2.5.5)
    LET AI = CBESSJI(R1,C1,3)
    LET AI = CBESSJI(R1,C1,ORDER)
 
Note:
    DATAPLOT uses the routine BESJCF from the BESPAK library.  This
    library was written by David Sagin (Sookne), Computer Center, Tel
    Aviv University.

Note:
    DATAPLOT does not calculate this function for negative orders.
    However, the following relation can be used:

       J(-v)(z) = COS(v*PI)*J(v)(z) - SIN(v*PI)*Y(v)(z)

    where z is a complex number and Y(v) is the Bessel function of the
    second kind.  The functions CBESSJR, CBESSJI, CBESSYR, and CBESSYI
    can be used to compute the relevant Bessel functions.

Note:
    The Kelvin functions of the first kind are defined as follows:
  
       ber(v)(x) + i*bei(v)(x) = J(v)(x*exp(3*pi*i/4)
    
    The CEXP and CEXPI functions can be used to compute the arguments
    to the CBESSJR and CBESSJI functions.  The Program  example below
    demonstrates this for Kelvin functions of order 0 and 1.

Note:
    The Hankel functions of the first and second kind are defined as:

       H1(z) = J(v)(z) + i*Y(v)(z)
       H2(z) = J(v)(z) - i*Y(v)(z)

    where J(v) is the Bessel function of the first kind and Y(v) is
    the Bessel function of the second kind.  The DATAPLOT functions
    CBESSJR, CBESSJI, CBESSYR, and CBESSYI can be used to compute the
    various components of the Hankel functions.  The COMPLEX ADDITION
    and COMPLEX SUBTRACTION commands can be used for complex addition
    and subtraction to combine terms.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BESSJN  = Compute the Bessel function of the first kind, order N,
              and real argument.
    CBESSJR = Compute the real component of the Bessel function of
              the first kind, order N, and complex argument.
    CBESSYR = Compute the real component of the Bessel function of
              the second kind, order N, and complex argument.
    CBESSYI = Compute the complex component of the Bessel function of
              the second kind, order N, and complex argument.
    CBESSIR = Compute the real component of the modified Bessel
              function of order N and complex argument.
    CBESSII = Compute the complex component of the modified Bessel
              function of order N and complex argument.
    CBESSKR = Compute the real component of the modified Bessel
              function of the third kind, order N, and complex
              argument.
    CBESSKI = Compute the complex component of the modified Bessel
              function of the third kind, order N, and complex
              argument.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (pages 355-433).
 
    "Note on Backward Recurrence Algorithms", Olver and Sookne,
    Mathematics of Computation, Volume 26, October 1972.

    "Recurrence Techniques for the Calculation of Bessel Functions",
    Goldstein and Thaler, Mathematics of Computation, Volume 13,
    April 1959.

    "Bessel Functions of Complex Argument and Integer Order", Sookne,
    Journal of Research of the National Bureau of Standards, Series B,
    Volume 77A, July-December, 1973.

Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    .
    . Compute Kelvin functions of type 1 and order 0 and 1
    .
    LET X = SEQUENCE 0.2 0.2 10
    LET N = SIZE X
    LET XI = 0 FOR I = 1 1 N
    LET CONST = 3*PI/4
    LET AR = CEXP(0,CONST)
    LET AI = CEXPI(0,CONST)
    LET CR = AR FOR I = 1 1 N
    LET CI = AI FOR I = 1 1 N
    LET YR YC = COMPLEX MULTIPLICATION X XI CR CI
    LET ORDER = 0
    LET BER0 = CBESSJR(YR,YC,ORDER)
    LET BEI0 = CBESSJI(YR,YC,ORDER)
    LET ORDER = 1
    LET BER1 = CBESSJR(YR,YC,ORDER)
    LET BEI1 = CBESSJI(YR,YC,ORDER)
    LINE SOLID DASH DOT DOT
    TITLE KELVIN FUNCTIONS OF ORDER 0 AND 1
    PLOT BER0 BEI0 BER1 BEI1 VS X
 
-----CBESSJR (LET)--------------------------------
 
CBESSJR
 
Name:
    CBESSJR (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the real component of the Bessel function of the first
    kind and order v for a complex argument where v is a non-negative
    real number.
 
Description:
    The Bessel function of the first kind with order v (v is a
    non-negative real number) can be defined as:

        Jv(z) = (z/2)**v*SUM((-z**2/4)**k/(k!*GAMMA(v+k+1)))

    where the sum is for k from zero to infinity, GAMMA is the 
    Gamma function, and ! is the factorial function.
 
    The imaginary part of the input argument must be less than the
    logarithm of the largest single precision number on the given 
    computer.  In addition, the input number times its complex 
    conjugate cannot be zero.

    The order is restricted to values between 0 and 100.

Syntax:
    LET <y2> = CBESSJR(<r1>,<i1>,<v>) <SUBSET/EXCEPT/FOR qualification>
    where <r1> is the real component of a number, variable or
               parameter;
          <i1> is the complex component of a number, variable or
               parameter;
          <v> is a non-negative number, variable, or parameter that
               specifies the order of the Bessel function;
          <y2> is a variable or a parameter (depending on what
               <r1> and <i1> are) where the computed Bessel value is
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET X2 = CBESSJR(2,1,2)
    LET A = CBESSJR(2,2.5.5)
    LET A = CBESSJR(R1,C1,3)
    LET A = CBESSJR(R1,C1,ORDER)
 
Note:
    DATAPLOT uses the routine BESJCF from the BESPAK library.  This
    library was written by David Sagin (Sookne), Computer Center, Tel
    Aviv University.

Note:
    DATAPLOT does not calculate this function for negative orders.
    However, the following relation can be used:

       J(-v)(z) = COS(v*PI)*J(v)(z) - SIN(v*PI)*Y(v)(z)

    where z is a complex number and Y(v) is the Bessel function of the
    second kind.  The functions CBESSJR, CBESSJI, CBESSYR, and CBESSYI
    can be used to compute the relevant Bessel functions.

Note:
    The Kelvin functions of the first kind are defined as follows:
  
       ber(v)(x) + i*bei(v)(x) = J(v)(x*exp(3*pi*i/4)
    
    The CEXP and CEXPI functions can be used to compute the arguments
    to the CBESSJR and CBESSJI functions.  The Program  example below
    demonstrates this for Kelvin functions of order 0 and 1.

Note:
    The Hankel functions of the first and second kind are defined as:

       H1(z) = J(v)(z) + i*Y(v)(z)
       H2(z) = J(v)(z) - i*Y(v)(z)

    where J(v) is the Bessel function of the first kind and Y(v) is
    the Bessel function of the second kind.  The DATAPLOT functions
    CBESSJR, CBESSJI, CBESSYR, and CBESSYI can be used to compute the
    various components of the Hankel functions.  The COMPLEX ADDITION
    and COMPLEX SUBTRACTION commands can be used for complex addition
    and subtraction to combine terms.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BESSJN  = Compute the Bessel function of the first kind, order N,
              and real argument.
    CBESSJI = Compute the complex component of the Bessel function of
              the first kind, order N, and complex argument.
    CBESSYR = Compute the real component of the Bessel function of
              the second kind, order N, and complex argument.
    CBESSYI = Compute the complex component of the Bessel function of
              the second kind, order N, and complex argument.
    CBESSIR = Compute the real component of the modified Bessel
              function of order N and complex argument.
    CBESSII = Compute the complex component of the modified Bessel
              function of order N and complex argument.
    CBESSKR = Compute the real component of the modified Bessel
              function of the third kind, order N, and complex
              argument.
    CBESSKI = Compute the complex component of the modified Bessel
              function of the third kind, order N, and complex
              argument.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (pages 355-433).
 
    "Note on Backward Recurrence Algorithms", Olver and Sookne,
    Mathematics of Computation, Volume 26, October 1972.

    "Recurrence Techniques for the Calculation of Bessel Functions",
    Goldstein and Thaler, Mathematics of Computation, Volume 13,
    April 1959.

    "Bessel Functions of Complex Argument and Integer Order", Sookne,
    Journal of Research of the National Bureau of Standards, Series B,
    Volume 77A, July-December, 1973.

Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    .
    . Compute Kelvin functions of type 1 and order 0 and 1
    .
    LET X = SEQUENCE 0.2 0.2 10
    LET N = SIZE X
    LET XI = 0 FOR I = 1 1 N
    LET CONST = 3*PI/4
    LET AR = CEXP(0,CONST)
    LET AI = CEXPI(0,CONST)
    LET CR = AR FOR I = 1 1 N
    LET CI = AI FOR I = 1 1 N
    LET YR YC = COMPLEX MULTIPLICATION X XI CR CI
    LET ORDER = 0
    LET BER0 = CBESSJR(YR,YC,ORDER)
    LET BEI0 = CBESSJI(YR,YC,ORDER)
    LET ORDER = 1
    LET BER1 = CBESSJR(YR,YC,ORDER)
    LET BEI1 = CBESSJI(YR,YC,ORDER)
    LINE SOLID DASH DOT DOT
    TITLE KELVIN FUNCTIONS OF ORDER 0 AND 1
    PLOT BER0 BEI0 BER1 BEI1 VS X
 
-----CBESSKI (LET)--------------------------------
 
CBESSKI
 
Name:
    CBESSKI (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the complex component of the modified Bessel function of
    the third kind and order v for a complex argument where v is a
    non-negative real number.
 
Description:
    The modified Bessel function of the third kind with order v (v is a
    non-negative real number) can be defined as:

        K(v)(z) = (PI/2)*(I(-v)(z) - I(v)(z))/SIN(PI*v)

    where I(v) is the modified Bessel function of the first kind.  See
    the documentation for BESSIN for details on the I(v) function.

    The real part of the input argument must be less than the
    logarithm of the largest single precision number on the given 
    computer.

    The order is restricted to values between 0 and 100.

Syntax:
    LET <y2> = CBESSKI(<r1>,<i1>,<v>) <SUBSET/EXCEPT/FOR qualification>
    where <r1> is the real component of a number, variable or
               parameter;
          <i1> is the complex component of a number, variable or
               parameter;
          <v> is a non-negative number, variable, or parameter that
               specifies the order of the Bessel function;
          <y2> is a variable or a parameter (depending on what
               <r1> and <i1> are) where the computed Bessel value is
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET X2 = CBESSKI(2,1,2)
    LET A = CBESSKI(2,2.5.5)
    LET A = CBESSKI(R1,C1,3)
    LET A = CBESSKI(R1,C1,ORDER)
 
Note:
    DATAPLOT uses the routine BESKCF from the BESPAK library.  This
    library was written by David Sagin (Sookne), Computer Center, Tel
    Aviv University.

Note:
    DATAPLOT does not calculate this function for negative orders.
    However, the following relation can be used:

       K(-v)(z) = K(v)(z)

    where z is a complex number.

Note:
    The Kelvin functions of the second kind are defined as follows:
  
       ker(v)(x) + i*kei(v)(x) = EXP(-PI*v*i/2)*K(v)(x*EXP(PI*i/4))
    
    The CEXP and CEXPI functions can be used to compute the arguments
    to the CBESSKR and CBESSKI functions.  The Program  example below
    demonstrates this for Kelvin functions of order 0 and 1.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BESSKN  = Compute the modified Bessel function of the third kind,
              order N and real argument.
    CBESSKR = Compute the real component of the modified Bessel
              function of the third kind, order N, and complex
              argument.
    CBESSIR = Compute the real component of the modified Bessel
              function of order N and complex argument.
    CBESSII = Compute the complex component of the modified Bessel
              function of order N and complex argument.
    CBESSJR = Compute the real component of the Bessel function of
              the first kind, order N, and complex argument.
    CBESSJI = Compute the complex component of the Bessel function of
              the first kind, order N, and complex argument.
    CBESSYR = Compute the real component of the Bessel function of
              the second kind, order N, and complex argument.
    CBESSYI = Compute the complex component of the Bessel function of
              the second kind, order N, and complex argument.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (pages 355-433).
 
    "Note on Backward Recurrence Algorithms", Olver and Sookne,
    Mathematics of Computation, Volume 26, October 1972.

    "Recurrence Techniques for the Calculation of Bessel Functions",
    Goldstein and Thaler, Mathematics of Computation, Volume 13,
    April 1959.

    "Bessel Functions of Complex Argument and Integer Order", Sookne,
    Journal of Research of the National Bureau of Standards, Series B,
    Volume 77A, July-December, 1973.

Applications:
    Special Functions
 
Implementation Date:
    94/10
 
Program:
    .
    .  Kelvin functions of the second kind
    .
    DIMENSION 20 COLUMNS
    LET X = SEQUENCE 0.2 0.2 10
    LET N = SIZE X
    LET XI = 0 FOR I = 1 1 N
    LET ORDER = 0
    LET CONST1 = PI/4
    LET AR = CEXP(0,CONST1)
    LET AI = CEXPI(0,CONST1)
    LET CONST2 = -PI*ORDER/2
    LET BR = CEXP(0,CONST2)
    LET BI = CEXPI(0,CONST2)
    LET CR = AR FOR I = 1 1 N
    LET CI = AI FOR I = 1 1 N
    LET DR = BR FOR I = 1 1 N
    LET DI = BI FOR I = 1 1 N
    LET YR YC = COMPLEX MULTIPLICATION X XI CR CI
    LET KER0 = CBESSKR(YR,YC,ORDER)
    LET KEI0 = CBESSKI(YR,YC,ORDER)
    LET KER0 KEI0 = COMPLEX MULTIPLICATION DR DI KER0 KEI0
    LET ORDER = 1
    LET CONST2 = -PI*ORDER/2
    LET BR = CEXP(0,CONST2)
    LET BI = CEXPI(0,CONST2)
    LET DR = BR FOR I = 1 1 N
    LET DI = BI FOR I = 1 1 N
    LET KER1 = CBESSKR(YR,YC,ORDER)
    LET KEI1 = CBESSKI(YR,YC,ORDER)
    LET KER1 KEI1 = COMPLEX MULTIPLICATION DR DI KER1 KEI1
    YLIMITS -0.5 0.5
    LINE SOLID DASH DOT DOT
    TITLE KELVIN FUNCTIONS OF THE SECOND KIND AND ORDER 0 AND 1
    PLOT KER0 KEI0 KER1 KEI1 VS X
 
-----CBESSKR (LET)--------------------------------
 
CBESSKR
 
Name:
    CBESSKR (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the real component of the modified Bessel function of the
    third kind and order v for a complex argument where v is a
    non-negative real number.
 
Description:
    The modified Bessel function of the third kind with order v (v is a
    non-negative real number) can be defined as:

        K(v)(z) = (PI/2)*(I(-v)(z) - I(v)(z))/SIN(PI*v)

    where I(v) is the modified Bessel function of the first kind.  See
    the documentation for BESSIN for details on the I(v) function.

    The real part of the input argument must be less than the
    logarithm of the largest single precision number on the given 
    computer.

    The order is restricted to values between 0 and 100.

Syntax:
    LET <y2> = CBESSKR(<r1>,<i1>,<v>) <SUBSET/EXCEPT/FOR qualification>
    where <r1> is the real component of a number, variable or
               parameter;
          <i1> is the complex component of a number, variable or
               parameter;
          <v> is a non-negative number, variable, or parameter that
               specifies the order of the Bessel function;
          <y2> is a variable or a parameter (depending on what
               <r1> and <i1> are) where the computed Bessel value is
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET X2 = CBESSKR(2,1,2)
    LET A = CBESSKR(2,2.5.5)
    LET A = CBESSKR(R1,C1,3)
    LET A = CBESSKR(R1,C1,ORDER)
 
Note:
    DATAPLOT uses the routine BESKCF from the BESPAK library.  This
    library was written by David Sagin (Sookne), Computer Center, Tel
    Aviv University.

Note:
    DATAPLOT does not calculate this function for negative orders.
    However, the following relation can be used:

       K(-v)(z) = K(v)(z)

    where z is a complex number.

Note:
    The Kelvin functions of the second kind are defined as follows:
  
       ker(v)(x) + i*kei(v)(x) = EXP(-PI*v*i/2)*K(v)(x*EXP(PI*i/4))
    
    The CEXP and CEXPI functions can be used to compute the arguments
    to the CBESSKR and CBESSKI functions.  The Program  example below
    demonstrates this for Kelvin functions of order 0 and 1.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BESSKN  = Compute the modified Bessel function of the third kind,
              order N and real argument.
    CBESSKI = Compute the complex component of the modified Bessel
              function of the third kind, order N, and complex
              argument.
    CBESSIR = Compute the real component of the modified Bessel
              function of order N and complex argument.
    CBESSII = Compute the complex component of the modified Bessel
              function of order N and complex argument.
    CBESSJR = Compute the real component of the Bessel function of
              the first kind, order N, and complex argument.
    CBESSJI = Compute the complex component of the Bessel function of
              the first kind, order N, and complex argument.
    CBESSYR = Compute the real component of the Bessel function of
              the second kind, order N, and complex argument.
    CBESSYI = Compute the complex component of the Bessel function of
              the second kind, order N, and complex argument.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (pages 355-433).
 
    "Note on Backward Recurrence Algorithms", Olver and Sookne,
    Mathematics of Computation, Volume 26, October 1972.

    "Recurrence Techniques for the Calculation of Bessel Functions",
    Goldstein and Thaler, Mathematics of Computation, Volume 13,
    April 1959.

    "Bessel Functions of Complex Argument and Integer Order", Sookne,
    Journal of Research of the National Bureau of Standards, Series B,
    Volume 77A, July-December, 1973.

Applications:
    Special Functions
 
Implementation Date:
    94/10
 
Program:
    .
    .  Kelvin functions of the second kind
    .
    DIMENSION 20 COLUMNS
    LET X = SEQUENCE 0.2 0.2 10
    LET N = SIZE X
    LET XI = 0 FOR I = 1 1 N
    LET ORDER = 0
    LET CONST1 = PI/4
    LET AR = CEXP(0,CONST1)
    LET AI = CEXPI(0,CONST1)
    LET CONST2 = -PI*ORDER/2
    LET BR = CEXP(0,CONST2)
    LET BI = CEXPI(0,CONST2)
    LET CR = AR FOR I = 1 1 N
    LET CI = AI FOR I = 1 1 N
    LET DR = BR FOR I = 1 1 N
    LET DI = BI FOR I = 1 1 N
    LET YR YC = COMPLEX MULTIPLICATION X XI CR CI
    LET KER0 = CBESSKR(YR,YC,ORDER)
    LET KEI0 = CBESSKI(YR,YC,ORDER)
    LET KER0 KEI0 = COMPLEX MULTIPLICATION DR DI KER0 KEI0
    LET ORDER = 1
    LET CONST2 = -PI*ORDER/2
    LET BR = CEXP(0,CONST2)
    LET BI = CEXPI(0,CONST2)
    LET DR = BR FOR I = 1 1 N
    LET DI = BI FOR I = 1 1 N
    LET KER1 = CBESSKR(YR,YC,ORDER)
    LET KEI1 = CBESSKI(YR,YC,ORDER)
    LET KER1 KEI1 = COMPLEX MULTIPLICATION DR DI KER1 KEI1
    YLIMITS -0.5 0.5
    LINE SOLID DASH DOT DOT
    TITLE KELVIN FUNCTIONS OF THE SECOND KIND AND ORDER 0 AND 1
    PLOT KER0 KEI0 KER1 KEI1 VS X
 
-----CBESSYI (LET)--------------------------------
 
CBESSYI
 
Name:
    CBESSYI (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the complex component of the Bessel function of the second
    kind and order v for a complex argument where v is a non-negative
    real number.
 
Description:
    The definition of Bessel functions of the second kind with order v
    (v is a non-negative real number) is:

        Yv(z) = (Jv(z)*COS(v*PI) - J-v(z))/SIN(v*PI)    X > 0

    where Jv is the Bessel function of the first kind.  See the
    documentation for BESSJN for a description of this function.
    For integer v, the above formula is the limit as v approaches 
    that integer.
 
    The order is restricted to values between 0 and 100.

Syntax:
    LET <y2> = CBESSYI(<r1>,<i1>,<v>) <SUBSET/EXCEPT/FOR qualification>
    where <r1> is the real component of a number, variable or
               parameter;
          <i1> is the complex component of a number, variable or
               parameter;
          <v> is a non-negative number, variable, or parameter that
               specifies the order of the Bessel function;
          <y2> is a variable or a parameter (depending on what
               <r1> and <i1> are) where the computed Bessel value is
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET X2 = CBESSYI(2,2,1)
    LET A = CBESSYI(1,3,2.5)
    LET A = CBESSYI(XR,XC,ORDER)

Note:
    DATAPLOT uses the routine BESYCF from the BESPAK library.  This
    library was written by David Sagin (Sookne), Computer Center, Tel
    Aviv University.

Note:
    DATAPLOT does not calculate this function for negative orders.
    However, the following relation can be used:

       Y(-v)(z) = COS(v*PI)*Y(v)(z) - SIN(v*PI)*J(v)(z)

    where z is a complex number and J(v) is the Bessel function of the
    first kind.  The functions CBESSJR, CBESSJI, CBESSYR, and CBESSYI
    can be used to compute the relevant Bessel functions.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BESSYN  = Compute the Bessel function of the second kind, order N,
              and real argument.
    CBESSYR = Compute the real component of the Bessel function of
              the second kind, order N, and complex argument.
    CBESSJR = Compute the real component of the Bessel function of
              the first kind, order N, and complex argument.
    CBESSJI = Compute the complex component of the Bessel function of
              the first kind, order N, and complex argument.
    CBESSIR = Compute the real component of the modified Bessel
              function of order N and complex argument.
    CBESSII = Compute the complex component of the modified Bessel
              function of order N and complex argument.
    CBESSKR = Compute the real component of the modified Bessel
              function of the third kind, order N, and complex
              argument.
    CBESSKI = Compute the complex component of the modified Bessel
              function of the third kind, order N, and complex
              argument.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (pages 355-433).
 
    "Note on Backward Recurrence Algorithms", Olver and Sookne,
    Mathematics of Computation, Volume 26, October 1972.

    "Recurrence Techniques for the Calculation of Bessel Functions",
    Goldstein and Thaler, Mathematics of Computation, Volume 13,
    April 1959.

    "Bessel Functions of Complex Argument and Integer Order", Sookne,
    Journal of Research of the National Bureau of Standards, Series B,
    Volume 77A, July-December, 1973.
 
Applications:
    Special Functions
 
Implementation Date:
    94/10
 
Program:
    LET XR = SEQUENCE .1 .1 5
    LET XC = .1 .1 5
    LET ORDER = 2
    LET YR = CBESSYR(XR,XC,ORDER)
    LET YI = CBESSYI(XR,XC,ORDER)

-----CBESSYR (LET)--------------------------------
 
CBESSYR
 
Name:
    CBESSYR (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the real component of the Bessel function of the second
    kind and order v for a complex argument where v is a non-negative
    real number.
 
Description:
    The definition of Bessel functions of the second kind with order v
    (v is a non-negative real number) is:

        Yv(z) = (Jv(z)*COS(v*PI) - J-v(z))/SIN(v*PI)    X > 0

    where Jv is the Bessel function of the first kind.  See the
    documentation for BESSJN for a description of this function.
    For integer v, the above formula is the limit as v approaches 
    that integer.
 
    The order is restricted to values between 0 and 100.

Syntax:
    LET <y2> = CBESSYR(<r1>,<i1>,<v>) <SUBSET/EXCEPT/FOR qualification>
    where <r1> is the real component of a number, variable or
               parameter;
          <i1> is the complex component of a number, variable or
               parameter;
          <v> is a non-negative number, variable, or parameter that
               specifies the order of the Bessel function;
          <y2> is a variable or a parameter (depending on what
               <r1> and <i1> are) where the computed Bessel value is
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET X2 = CBESSYR(2,2,1)
    LET A = CBESSYR(1,3,2.5)
    LET A = CBESSYR(XR,XC,ORDER)

Note:
    DATAPLOT uses the routine BESYCF from the BESPAK library.  This
    library was written by David Sagin (Sookne), Computer Center, Tel
    Aviv University.

Note:
    DATAPLOT does not calculate this function for negative orders.
    However, the following relation can be used:

       Y(-v)(z) = COS(v*PI)*Y(v)(z) - SIN(v*PI)*J(v)(z)

    where z is a complex number and J(v) is the Bessel function of the
    first kind.  The functions CBESSJR, CBESSJI, CBESSYR, and CBESSYI
    can be used to compute the relevant Bessel functions.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BESSYN  = Compute the Bessel function of the second kind, order N,
              and real argument.
    CBESSYI = Compute the complex component of the Bessel function of
              the second kind, order N, and complex argument.
    CBESSJR = Compute the real component of the Bessel function of
              the first kind, order N, and complex argument.
    CBESSJI = Compute the complex component of the Bessel function of
              the first kind, order N, and complex argument.
    CBESSIR = Compute the real component of the modified Bessel
              function of order N and complex argument.
    CBESSII = Compute the complex component of the modified Bessel
              function of order N and complex argument.
    CBESSKR = Compute the real component of the modified Bessel
              function of the third kind, order N, and complex
              argument.
    CBESSKI = Compute the complex component of the modified Bessel
              function of the third kind, order N, and complex
              argument.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (pages 355-433).
 
    "Note on Backward Recurrence Algorithms", Olver and Sookne,
    Mathematics of Computation, Volume 26, October 1972.

    "Recurrence Techniques for the Calculation of Bessel Functions",
    Goldstein and Thaler, Mathematics of Computation, Volume 13,
    April 1959.

    "Bessel Functions of Complex Argument and Integer Order", Sookne,
    Journal of Research of the National Bureau of Standards, Series B,
    Volume 77A, July-December, 1973.
 
Applications:
    Special Functions
 
Implementation Date:
    94/10
 
Program:
    LET XR = SEQUENCE .1 .1 5
    LET XC = .1 .1 5
    LET ORDER = 2
    LET YR = CBESSYR(XR,XC,ORDER)
    LET YI = CBESSYI(XR,XC,ORDER)

-----CBETA (LET)--------------------------------
 
CBETA
 
Name:
    CBETA (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the beta function with complex arguments.
 
Description:
    The complex beta function is defined as:

        B(p,q) = INTEGRAL(x**(p-1)*(1-x)**(q-1)dx

    where p and q are complex numbers with positive real
    components and the integral is taken from 0 to 1.
 
    Dataplot computes this function using routines from
    "Computation of Special Functions" (see the References
    section below).
 
Syntax 1:
    LET <yr> = CBETA(<pr>,<pc>,<qr>,<qc>)
                               <SUBSET/EXCEPT/FOR qualification>
    where <pr> is a variable, number, or parameter containing
               positive values;
          <pc> is a variable, number, or parameter;
               positive values;
          <qr> is a variable, number, or parameter containing
               positive values;
          <qc> is a variable, number, or parameter;
               positive values;
          <yr> is a variable or a parameter (depending on what
               <xr> and <xc> are) where the computed beta values
               are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the real component of the complex
    beta function.  The <pr> and <pc> values are the real and
    complex components of the first input argument respectively
    and the <qr> and <qc> values are the real and
    complex components of the second input argument respectively.

Syntax 2:
    LET <yc> = CBETA(<pr>,<pc>,<qr>,<qc>)
                               <SUBSET/EXCEPT/FOR qualification>
    where <pr> is a variable, number, or parameter containing
               positive values;
          <pc> is a variable, number, or parameter;
               positive values;
          <qr> is a variable, number, or parameter containing
               positive values;
          <qc> is a variable, number, or parameter;
               positive values;
          <yr> is a variable or a parameter (depending on what
               <xr> and <xc> are) where the computed beta values
               are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the complex component of the complex
    beta function.  The <pr> and <pc> values are the real and
    complex components of the first input argument respectively
    and the <qr> and <qc> values are the real and
    complex components of the second input argument respectively.

Examples:
    LET A = CBETA(1,2)
    LET A = CBETAI(1,2)

    LET YR = CBETA(XR,2)
    LET YC = CBETAI(XR,2)
 
    LET YR = CBETA(XR,XC)
    LET YC = CBETAI(XR,XC)

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CLNBETA    = Compute the complex log beta function.
    CLNGAM     = Compute the complex log gamma function.
    BETA       = Compute the beta function.
    GAMMA      = Compute the Gamma function.
    GAMMAI     = Compute the incomplete Gamma function.
 
Reference:
    "Computation of Special Functions", Shanjie Zhang and Jianming
    Jin, John Wiley and Sons, 1996, chapter 1.
 
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    1997/12
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES
    TITLE AUTOMATIC
    PLOT CBETA(XR,2,1,0) FOR XR = 0.1 0.1 5
    PLOT CBETA(XR,5,1,0) FOR XR = 0.1 0.1 5
    PLOT CBETAI(XR,2,1,1) FOR XR = 0.1 0.1 5
    PLOT CBETAI(XR,5,1,1) FOR XR = 0.1 0.1 5
    END OF MULTIPLOT
 
-----CC (LET)----------------------------------------------------
 
CC
 
Name:
    CC (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the process capability index (CC) for a variable.
 
Description:
    The process capability index measure the performance (i.e., the
    capability) of an industrial process. The CC is a variant of
    the CP and CPK capability indices.

      CC = MAX((TARGET-XBAR)/(TARGET-LSL),(XBAR-TARGET)/USL)


    where USL and LSL are user specified upper and lower
    specification limits, TARGET is the target engineering limit,
    XBAR is the sample mean of the data.  For this statistic,
    smaller is better.

    The specification limits define the range within which a
    product is considered acceptable (values outside this range
    indicate that a product is defective).
 
Syntax:
    LET <par> = CC <y>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the computed CC is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CC Y1
    LET A = CC Y1 SUBSET TAG > 2
 
Note:
    The upper and lower specification limits and target value
    must be specified by the user as follows:

        LET LSL = <value>
        LET USL = <value>
        LET TARGET = <value>
 
Note:
    This statistic is also supported for the following plots:

        CC PLOT Y X
        CROSS TABULATE CC PLOT Y X
        DEX CC PLOT Y X1 ... Xk

    You need to specify the LSL, USL, and TARGET values (see
    above) before entering these commands.  For more information
    on these plots, enter 

        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP DEX PLOT

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CONTROL CHART             = Generate a control chart.
    STATISTIC PLOT            = Generate a statistic versus subset
                                plot.
    DEX PLOT                  = Generate a dex <statistic> plot.
    CP (LET)                  = Compute the process capability index.
    CPK (LET)                 = Compute the process capability index.
    CPNK (LET)                = Compute the process capability index.
    CPM (LET)                 = Compute the process capability index.
    PERCENT DEFECTIVE (LET)   = Compute the percentage of defectives in
                                a sample.
    EXPECTED LOSS (LET)       = Compute the expected loss of a sample.
 
Reference:
    "Guide to Quality Control", Kaoru Ishikawa, Asian Productivity
    Organization, 1982 (chapter 13).
 
Applications:
    Quality Control
 
Implementation Date:
    1998/12
 
Program:
    SKIP 25
    READ GEAR.DAT Y X
    LET USL = 0.995
    LET USL = 1.005
    LET TARGET = 1.0
    CHARACTER X BLANK
    LINE BLANK SOLID
    TITLE AUTOMATIC
    XTIC OFFSET 0.5 0.5
    TIC OFFSET UNITS DATA
    CC PLOT Y X
 
-----CCOS (LET)---------------------------------------------------
 
CCOS
 
Name:
    CCOS (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the real component of the cosine of a complex number.
 
Syntax:
    LET <yr> = CCOS(<xr>,<xc>)  <SUBSET/EXCEPT/FOR qualification>
    where <xr> is a number, parameter, or variable that specifies the
               real component of the the complex number;
          <xc> is a number, parameter, or variable that specifies the
               complex component of the the complex number;
          <yr> is a variable or a parameter (depending on what <xr> and
               <xc> are) where the real component of the computed
               cosine value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CCOS(-2,1)
    LET A = CCOS(A1,-2)
    LET X2 = CCOS(XR,XC)
    LET X2 = CCOS(PI/2,-PI/4)
 
Note:
    DATAPLOT uses the Fortran intrinsic function CCOS to compute this
    function.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COS    = Compute the cosine of a real number.
    CABS   = Compute the absolute value of a complex number.
    CCOSI  = Compute the complex component of the cosine of a complex
             number.
    CEXP   = Compute the real component of the exponential of a complex
             number.
    CEXPI  = Compute the complex component of the exponential of a
             complex number.
    CLOG   = Compute the real component of the logarithm of a complex
             number.
    CLOGI  = Compute the complex component of the logarithm of a
             complex number.
    CSIN   = Compute the real component of the sine of a complex
             number.
    CSINI  = Compute the complex component of the sine of a complex
             number.
    CSQRT  = Compute the real component of the square root of a complex
             number.
    CSQRTI = Compute the complex component of the square root of a
             complex number.
 
Applications:
    XX
 
Implementation Date:
    94/10
 
Program:
    LINE SOLID DASH
    PLOT CCOS(X,-PI/2) FOR X = -10 0.1 10 AND
    PLOT CCOSI(X,-PI/2) FOR X = -10 0.1 10
 
-----CCOSI (LET)---------------------------------------------------
 
CCOSI
 
Name:
    CCOSI (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the complex component of the cosine of a complex number.
 
Syntax:
    LET <yr> = CCOSI(<xr>,<xc>)  <SUBSET/EXCEPT/FOR qualification>
    where <xr> is a number, parameter, or variable that specifies the
               real component of the the complex number;
          <xc> is a number, parameter, or variable that specifies the
               complex component of the the complex number;
          <yr> is a variable or a parameter (depending on what <xr> and
               <xc> are) where the complex component of the computed
               cosine value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CCOSI(-2,1)
    LET A = CCOSI(A1,-2)
    LET X2 = CCOSI(XR,XC)
    LET X2 = CCOSI(PI/2,-PI/4)
 
Note:
    DATAPLOT uses the Fortran intrinsic function CCOS to compute this
    function.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COS    = Compute the cosine of a real number.
    CABS   = Compute the absolute value of a complex number.
    CCOS   = Compute the real component of the cosine of a complex
             number.
    CEXP   = Compute the real component of the exponential of a complex
             number.
    CEXPI  = Compute the complex component of the exponential of a
             complex number.
    CLOG   = Compute the real component of the logarithm of a complex
             number.
    CLOGI  = Compute the complex component of the logarithm of a
             complex number.
    CSIN   = Compute the real component of the sine of a complex
             number.
    CSINI  = Compute the complex component of the sine of a complex
             number.
    CSQRT  = Compute the real component of the square root of a complex
             number.
    CSQRTI = Compute the complex component of the square root of a
             complex number.
 
Applications:
    XX
 
Implementation Date:
    94/10
 
Program:
    LINE SOLID DASH
    PLOT CCOS(X,-PI/2) FOR X = -10 0.1 10 AND
    PLOT CCOSI(X,-PI/2) FOR X = -10 0.1 10
 
-----CCPR PLOT--------------------------------------

CCPR PLOT

Name:
    CCPR PLOT

Type:
    Graphics Command

Purpose:
    Generate a CCPR (component and component-plus-residual) plot.

Description:
    When performing a linear regression with a single independent
    variable, a scatter plot of the response variable against
    the independent variable provides a good indication of
    the nature of the relationship.  If there is more than one
    independent variable, things become more complicated.
    Although it can still be useful to generate scatter plots
    of the response variable against each of the independent
    variables, this does not take into account the effect of the
    other independent variables in the model.

    Partial residual plots attempt to show the relationship between
    a given independent variable and the response variable given
    that other independent variables are also in the model.

    Partial residual plots are formed as:

       Res + Betahat(i)*X(i) versus X(i)

    where

       Res = residuals from the full model
       Betahat(i) = regression coefficient from the ith
                    independent variable in the full model
       X(i) = the ith independent variable

    Partial residual plots are widely discussed in the regression
    diagnostics literature (e.g., see the References section below).
    Although they can often be useful, be aware that they can
    also fail to indicate the proper relationship.  In
    particular, if X(i) is highly correlated with any of the
    other independent variables, the variance indicated by the
    partial residual plot can be much less than the actual
    variance.  These issues are discussed in more detail in the
    references given below.

    The CCPR plot is a refinement of the partial residual
    plot.  It generates a partial residual plot but also
    adds

         Betahat(i)X(i) versus X(i)

    This is the "component" part of the plot and is intended to
    show where the "fitted line" would lie.

    Dataplot provides two forms for the CCPR plot.  You can generate
    either a single CCPR plot or you can generate a matrix of CCPR
    plots (one plot for each independent variable in the model).

    For the matrix form of the command, a number of SET FACTOR PLOT
    options can be used to control the appearance of the plot
    (not all of the SET FACTOR PLOT options apply).  These are
    discussed in the Notes section below.

Syntax 1:
    CCPR PLOT  <y> <x1> ... <xk>  <xi>
                           <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <x1> ... <xk> are the independent variables;
          <xi> is the independent variable for which the
              CCPR plot is being generated (note that <xi> must be
              one of the variables listed in <x1> ... <xk>;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This is the syntax for generating a single CCPR plot.

Syntax 2:
    MATRIX CCPR PLOT  <y> <x1> ... <xk>
                           <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <x1> ... <xk> are the independent variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used to generate a matrix of CCPR plots.

Examples:
    CCPR PLOT Y X1 X2 X3 X4 X2

    MATRIX CCPR PLOT Y X1 X2 X3 X4

    CCPR PLOT Y X1 X2 X3 X4 X2 SUBSET TAG > 2
    MATRIX CCPR PLOT Y X1 X2 X3 X4 SUBSET TAG > 2

Note:
    The following option controls which axis tic marks, tic mark
    labels, and axis labels are plotted.
 
        SET FACTOR PLOT LABELS <ON/OFF/XON/YON/BOX>

    OFF means that all axis labels are suppressed (this can be
    useful if a large number of variables are being plotted).  ON
    means that both X and Y axis labels are printed.  XON only
    plots the x axis labels and YON only plots the y axis labels.

    BOX is a special option that creates an extra column on the
    left and an extra row on the bottom.  The axis label is
    printed in this box.  BOX is typically reserved for the plot
    types that plot the variable names in the axes labels.

    The default is ON (both x and y axis labels are printed).

Note:
    The following option controls where the x axis tic marks,
    tic mark labels, and axis label are printed.
 
        SET FACTOR PLOT X AXIS <BOTTOM/TOP/ALTERNATE>

    BOTTOM specifies that the x axis labels are printed on the
    bottom axis (on the last row only).  TOP specifies that
    the x axis labels are printed on the top axis (first row
    only).  ALTERNATE specifies that the x axis labels alternate
    between the top (first row) and bottom axis (last row).
    We recommend using the TIC OFFSET command to avoid overlap
    of axis labels and tic marks.

    The default is ALTERNATE.

Note:
    The following option controls where the y axis tic marks,
    tic mark labels, and axis label are printed.

        SET FACTOR PLOT Y AXIS <LEFT/RIGHT/ALTERNATE>

    LEFT specifies that the y axis labels are printed on the
    left axis (on the first column only).  RIGHT specifies that
    the y axis labels are printed on the right axis (last column
    only).  ALTERNATE specifies that the y axis labels alternate
    between the left (first column) and right axis (last column).
    We recommend using the TIC OFFSET command to avoid overlap
    of axis labels and tic marks.

    The default is ALTERNATE.

Note:
    Users have different preferences in terms of whether the
    plot frames for neighboring plots are connected or not.
    This is controlled with the following option.
 
        SET FACTOR PLOT FRAME <DEFAULT/CONNECTED/USER>

    DEFAULT connects neighboring frames (i.e., the FRAME CORNER
    COORDINATES are set to 0 0 100 100).  USER uses whatever
    frame coordinates are currently set (15 20 85 90 by default)
    and makes no special provisions for axis labels and tic marks
    (i.e., you set them as you normally would, each plot uses 
    whatever you have set).  CONNECTED uses whatever frame
    coordinates have been set by the user, but it draws the axis
    labels and tic marks as if DEFAULT were being used (that is, as
    determined by the SET FACTOR PLOT <LABELS/X AXIS/Y AXIS>
    commands described above).  Typically, CONNECTED is used to
    put a small bit of space between plots.  For example, you
    might use FRAME CORNER COORDINATES  3 3 97 97 before the
    PARTIAL RESIDUAL PLOT command.
 
    Since the plots can often have different limits for the axes,
    the default is USER.

Note:
    When the tic marks and tic mark labels are all plotted on the
    same side (i.e., SET FACTOR PLOT Y AXIS is
    set to LEFT or RIGHT or SET PARTIAL RESIDUAL PLOT X AXIS is
    set to BOTTOM or TOP), then overlap between plots is possible.
    The TIC OFFSET command can be used to avoid this.  In addition,
    you can stagger the tic labels with the following command:
 
        SET FACTOR PLOT LABEL DISPLACEMENT <NORMAL/STAGGERED/VALUE>
 
    NORMAL means that all tic labels are plotted at a distance
    determined by the TIC LABEL DISPLACEMENT command.  STAGGERED
    means that alternating plots will be staggered.  That is, one
    will use the standard displacement while the next uses a
    staggered value.  Entering this command with a numeric value
    specifies the amount of the displacement for the staggered
    tic labels.  For example,

        TIC MARK LABEL DISPLACEMENT 10
        SET FACTOR PLOT LABEL DISPLACEMENT STAGGERED
        SET FACTOR PLOT LABEL DISPLACEMENT 25

    These commands specify that the default tic label displacement
    is 10 and the staggered tic mark label displacement is 25.

Note:
    It is often helpful on scatter plot matrices to overlay a
    fitted line on the plots.  The following command is used
    to specify the type of fit.

        SET FACTOR PLOT FIT <NONE/LOWESS/LINE/QUAD/SMOOTH>

    NONE means that no fitted line is plotted.  LOWESS means
    that a locally weighted least squares line will be overlaid.
    LINE means that a linear fit (Y = A0 + A1*X) will be overlaid.
    QUAD means that a quadratic fit (Y = A0 + A1*X + A2*X**2) will
    be overlaid.  SMOOTH means that a least squares smoothing will
    be overlaid.

    For LOWESS, it is recommended that the lowess fraction be set
    fairly high (e.g., LOWESS FRACTION 0.6).

    The fitted line is currently only generated if the factor plot
    type is PLOT.

    The default is for no fitted line to be overlaid on the plot.
    If a overlaid fit is desired, the most common choice is to use
    LOWESS.

Note:
    Dataplot allows you to set axis limits with the LIMITS command.
    For the factor plot, it is often desirable to set
    the axis limits for each plot.  This can be done with the
    command
 
        SET FACTOR PLOT YLIMITS <LOW1> <UPP1> <LOW2> <UPP2> ...
        SET FACTOR PLOT XLIMITS <LOW1> <UPP1> <LOW2> <UPP2> ...

    The default is to allow the axis limits to float with the data.

Note:
    You can use standard plot control commands to control the
    appearance of the factor plot.

    For example,

       MULTIPLOT CORNER COORDINATES 5 5 95 95
       MULTIPLOT SCALE FACTOR 3
       TIC OFFSET UNITS SCREEN
       TIC OFFSET 5 5

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FIT                      = Perform a multi-linear fit.
    PARTIAL RESIDUAL PLOT    = Generates a partial residual plot.
    PARTIAL REGRESSION PLOT  = Generates a partial regression plot.
    PARTIAL LEVERAGE PLOT    = Generates a partial leverage plot.
    VIF                      = Compute variance inflation factors
                               for a multi-linear fit.
    CONDITION INDICES        = Compute condition indices for a design
                               matrix.
    SCATTER PLOT MATIRX      = Generate a factor plot.
    FACTOR PLOT              = Generate a plot for a response
                               against a number of different
                               independent variables.
    CONDITIONAL PLOT         = Generate a conditional (subset) plot.
 
Reference:
    "Modern Regression Methods", Tom Ryan, John Wiley, 1997.
 
    "Applied Linear Statistical Models", 3rd ed., Neter, Wasserman,
    and Kunter, 1990, Irwin.
 
    "Applied Regression Analysis", 3rd. ed., Draper and Smith, John
    Wiley, 1998.
 
    "Residuals and Influence in Regression", Cook and Weisberg,
    Chapman and Hall, 1982.
 
    "Regression Diagnostics", Belsley, Kuh, and Welsch, John Wiley,
    1980.
 
    "Efficient Computing of Regression Diagnostiocs",
    Paul Velleman and Roy Welsch, The American Statistician,
    November, 1981, Vol. 35, No. 4, pp. 234-242.
 
Applications:
    Multi-linear Regression
 
Implementation Date:
    2002/6
 
Program:
    SKIP 25
    READ HALD647.DAT Y X1 X2 X3 X4
    .
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT SCALE FACTOR 2
    LINE BLANK
    CHARACTER X
    .
    MATRIX CCPR PLOT Y X1 X2 X3 X4

-----CD-------------------------------------------------------
 
CD
 
Name:
    CD
 
Type:
    Support Command
 
Purpose:
    This command changes the current working directory.
 
Description:
    It is often convenient to able to modify the current working
    directory (e.g., to shorten file names that need to be entered).
    Using the SYSTEM command does not typically work since the 
    directory change does not persist after the SYSTEM command
    is entered.  The CD command allows you to change the working
    directory in a way that persists.
 
    This is a system dependent command.  It is currently
    supported for Unix and Windows 95/98/NT.

Syntax:
    CD <path name>
    where <path name> is the directory name.
 
Examples:
    CD  /home/heckert/datafiles
    READ SAMPLE.DAT
 
Default:
    On most implementations, the default working directory
    is the current directory when the Dataplot session was
    iniiated.  If you execute Dataplot from a shortcut
    on Windows 95/98/NT, the default working directory can
    be set under the Properties menu by changing the 
    "Start In" directory.
 
Synonyms:
    None
 
Note:
    Dataplot does no checking to ensure that a valid path
    name was specified.  The working directory is simply
    passed as entered.

Note:
    File names are case sensitive on Unix file systems.  For this
    reason, case is preserved in passing the path name to the 
    CD command.
 
Related Commands:
    SYSTEM        = Enter an operating system command within a
                    Dataplot session.
 
Applications:
    Interactive Usage
 
Implementation Date:
    1997/9
 
Program:
    CD  /usr/local/lib/dataplot/data
    READ BERGER1.DAT Y X
    FIT Y X
 
-----CEIL (LET)--------------------------------
 
CEIL
 
Name:
    CEIL (LET)
 
Type:
    Library Function
 
Purpose:
    Return the integer portion of a number or variable rounded to
    positive inifinity.
 
Syntax:
    LET <y2> = CEIL(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1>
               is) where the computed integer values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CEIL(2.83)
    LET A = CEIL(A1)
    LET X2 = CEIL(X1)
    LET X2 = CEIL(X1-4.2)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FLOOR  = Compute the integer value rounded to negative infinity.
    INT    = Compute the integer value rounded to zero.
    SIGN   = Compute the sign of a number.
    FRACT  = Compute the fractional portion of number.
    MSD    = Compute the most significant digit of a number.
    ROUND  = Round to the closest integer of a number.
 
Applications:
    Elementary function
 
Implementation Date:
    95/4
 
Program:
    LET Y1 = SEQUENCE -5 0.1 5
    LET Y2 = CEIL(Y1)
    PRINT Y1 Y2
 
-----CELL MATCH (LET)-----------------------------------------------
 
CELL MATCH
 
Name:
    CELL MATCH (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Return the index in an array where the array value matches a
    scalar value.
 
Description:
    Given a scalar value, VAL, and an array, X, sort the values in X and
    then find the index, IVAL, such that

            X(I) <= VAL < X(I+1)

    If VAL < X(1), set IVAL to 0.  If VAL > X(N), set IVAL to N+1.

    The CELL MATCH command will do this for an array of values.

    This command was motivated in the implementation of the P-square
    algorithm for one-pass estimation of percentiles.

Syntax:
    LET <index> = CELL MATCH  <x>  <value>
                  <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <xseq> is a variable that defines the sequence number for
              the response variable;
          <x1> ... <x6> is a list of one to six group-id variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional and rarely
    used in this context.

    Neither the <x> nor the <value> variables need to be pre-sorted.  The
    output variable <index> will be the same length as <value>.

Examples:
    LET IINDX = CELL MATCH X VAL

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    MATCH        = Match a column of values to another column of numbers
                   and return the index of the matching value. 
    SORT         = Sort the elements of a variable.
    CODE         = Generate a coded variable.
    SEQUENCE     = Generate a sequence of numbers.
 
References:
    Jain and Chlamtac (1985), "The P^2 Algorithm for Dynamic Calculation
    of Quantiles and Histograms without Storing Observations,"
    Communications of the ACM, 28, No. 10, pp. 1076-1085.

    Raatikanien (1987), "Simultaneous Estimation of Several Percentiles,"
    Simulation, pp. 159-164.
 
Applications:
    Data Management
 
Implementation Date:
    2018/08
 
Program:
    . Purpose:  Demonstrate P-square algorithm for one-pass
    .           estimation of percentiles.
    .
    dimension 40 columns
    read y
     0.02
     0.5
     0.74
     3.39
     0.83
    22.37
    10.15
    15.43
    38.62
    15.92
    34.60
    10.28
     1.47
     0.40
     0.05
    11.39
     0.27
     0.42
     0.09
    11.37
    end of data
    let ny = size y
    .
    . Step 2:   Initializations based on first 2*m + 3 data points.
    .
    let p = data 0.1 0.5 0.9
    let m = size p
    let ninit = 2*m + 3
    let q = y
    retain q for i = 1 1 ninit
    let q = sort q
    let n = sequence 1 1 ninit
    let f = 0 for i = 1 1 ninit
    let f(ninit) = 1
    loop for k = 1 1 m
        let iindx = 2*k + 1
        let f(iindx) = p(k)
    end of loop
    let mp1 = m + 1
    loop for k = 1 1 mp1
        let iindx1 = 2*k - 1
        let iindx2 = 2*k + 1
        let iindx3 = 2*k
        let aval1 = f(iindx1)
        let aval2 = f(iindx2)
        let aval3 = (aval1 + aval2)/2
        let f(iindx3) = aval3
    end of loop
    let d = 1 + 2*(m+1)*f
    .
    . Step 3:   Now loop through remaining points
    .
    let nstrt = ninit + 1
    delete k
    .
    loop for k = nstrt 1 ny
        let ynew = y(k)
        let qmin = q(1)
        let qmax = q(ninit)
        if ynew < q1
           let ak = 1
           let q(1) = ynew
        else if ynew > qmax
           let ak = ninit
           let q(ninit) = qmax
        else
           let val = combine ynew
           let iindx = cell match q val
           let ak = iindx(1)
           delete val iindx
        end of if
        .
        let start = ak + 1
        let n = n + 1 for i = start 1 ninit
        let d = d + f
        .
        let mstop = 2*m + 2
        loop for l = 2 1 mstop
            let lm1 = l - 1
            let lp1 = l + 1
            .
            let aval1  = d(l)
            let aval2  = n(l)
            let di = aval1 - aval2
            .
            let aval1  = n(lp1)
            let dp = aval1 - aval2
            .
            let aval1  = n(lm1)
            let dm = aval1 - aval2
            .
            let aval1 = q(lp1)
            let aval2 = q(l)
            let qp = (aval1 - aval2)/dp
            .
            let aval1 = q(lm1)
            let qm = (aval1 - aval2)/dm
            .
            let nl   = n(l)
            let ql   = q(l)
            let qlm1 = q(lm1)
            let qlp1 = q(lp1)
            .
            if di >= 1 and dp > 1
               let qt = ql + ((1 - dm)*qp + (dp -1)*qm)/(dp-dm)
               if qlm1 < qt and qt < qlp1 then
                  let q(l) = qt
               else
                  let q(l) = ql + qp
               end of if
               let n(l) = nl + 1
            else if di <= 1 and dm < -1
               let qt = ql - ((1 + dp)*qm - (dm +1)*qp)/(dp-dm)
               if qlm1 < qt and qt < qlp1 then
                  let q(l) = qt
               else
                  let q(l) = ql - qm
               end of if
               let n(l) = nl - 1
            end of if
            .
        end of loop
        .
    end of loop
    .
    set write decimals 4
    loop for k = 1 1 m
        let iindx1 = 1 + 2*k
        let aval = q(iindx1)
        let qsave(k) = aval
    end of loop
    print "Estimated 0.10, 0.50, 0.90 quantiles"
    print " "
    print qsave

-----CEXP (LET)--------------------------------
 
CEXP
 
Name:
    CEXP (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the real component of the exponential function for a
    complex number.
 
Syntax:
    LET <yr> = CEXP(<xr>,<xc>)  <SUBSET/EXCEPT/FOR qualification>
    where <xr> is a number, parameter, or variable that specifies the
               real component of the the complex number;
          <xc> is a number, parameter, or variable that specifies the
               complex component of the the complex number;
          <yr> is a variable or a parameter (depending on what <xr> and
               <xc> are) where the computed exponential value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CEXP(14,-2)
    LET A = CEXP(A1,4)
    LET X2 = CEXP(XR,XC)
    LET X2 = CEXP(XR,6)
 
Note:
    DATAPLOT uses the Fortran intrinsic function CEXP to compute this
    function.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EXP    = Compute the exponential of a real number.
    CEXPI  = Compute the complex component of the exponential of a
             complex number.
    CCOS   = Compute the real component of the cosine of a complex
             number.
    CCOSI  = Compute the complex component of the cosine of a complex
             number.
    CLOG   = Compute the real component of the logarithm of a complex
             number.
    CLOGI  = Compute the complex component of the logarithm of a
             complex number.
    CSIN   = Compute the real component of the sine of a complex
             number.
    CSINI  = Compute the complex component of the sine of a complex
             number.
    CSQRT  = Compute the real component of the square root of a complex
             number.
    CSQRTI = Compute the complex component of the square root of a
             complex number.
 
Applications:
    XX
 
Implementation Date:
    94/10
 
Program:
    LINE SOLID DASH
    PLOT CEXP(X,-1) FOR X = -3 .01 3 AND
    PLOT CEXPI(X,-1) FOR X = -3 .01 3
 
-----CEXPI (LET)--------------------------------
 
CEXPI
 
Name:
    CEXPI (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the complex component of the exponential function for a
    complex number.
 
Syntax:
    LET <yc> = CEXPI(<xr>,<xc>)  <SUBSET/EXCEPT/FOR qualification>
    where <xr> is a number, parameter, or variable that specifies the
               real component of the the complex number;
          <xc> is a number, parameter, or variable that specifies the
               complex component of the the complex number;
          <yc> is a variable or a parameter (depending on what <xr> and
               <xc> are) where the computed exponential value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CEXPI(14,-2)
    LET A = CEXPI(A1,4)
    LET X2 = CEXPI(XR,XC)
    LET X2 = CEXPI(XR,6)
 
Note:
    DATAPLOT uses the Fortran intrinsic function CEXP to compute this
    function.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EXP    = Compute the exponential of a real number.
    CEXP   = Compute the real component of the exponential of a
             complex number.
    CCOS   = Compute the real component of the cosine of a complex
             number.
    CCOSI  = Compute the complex component of the cosine of a complex
             number.
    CLOG   = Compute the real component of the logarithm of a complex
             number.
    CLOGI  = Compute the complex component of the logarithm of a
             complex number.
    CSIN   = Compute the real component of the sine of a complex
             number.
    CSINI  = Compute the complex component of the sine of a complex
             number.
    CSQRT  = Compute the real component of the square root of a complex
             number.
    CSQRTI = Compute the complex component of the square root of a
             complex number.
 
Applications:
    XX
 
Implementation Date:
    94/10
 
Program:
    LINE SOLID DASH
    PLOT CEXP(X,-1) FOR X = -3 .01 3 AND
    PLOT CEXPI(X,-1) FOR X = -3 .01 3
 
-----CGAMMA (LET)--------------------------------
 
CGAMMA
 
Name:
    CGAMMA (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the gamma function with complex arguments.
 
Description:
    The complex gamma function is defined as:

        GAMMA(z) = INTEGRAL(t**(z-1)*EXP(-t)dt)

    where z is a complex number with a positive real component
    and the integral is taken from 0 to infinity.
 
    Dataplot computes this function using the CGAMMA routines
    from "Computation of Special Functions" (see the References
    section below).
 
Syntax 1:
    LET <yr> = CGAMMA(<xr>,<xc>)  <SUBSET/EXCEPT/FOR qualification>
    where <xr> is a variable, number, or parameter containing
               positive values;
          <xc> is a variable, number, or parameter;
               positive values;
          <yr> is a variable or a parameter (depending on what
               <xr> and <xc> are) where the computed gamma values
               are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the real component of the complex
    gamma function.  The <xr> and <xc> values are the real and
    complex components of the input argument respectively.

Syntax 2:
    LET <yc> = CGAMMAI(<xr>,<xc>)  <SUBSET/EXCEPT/FOR qualification>
    where <xr> is a variable, number, or parameter containing
               positive values;
          <xc> is a variable, number, or parameter;
               positive values;
          <yr> is a variable or a parameter (depending on what
               <xr> and <xc> are) where the computed gamma values
               are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the complex component of the complex
    gamma function.  The <xr> and <xc> values are the real and
    complex components of the input argument respectively.

Examples:
    LET A = CGAMMA(1,2)
    LET A = CGAMMAI(1,2)

    LET YR = CGAMMA(XR,2)
    LET YC = CGAMMAI(XR,2)
 
    LET YR = CGAMMA(XR,XC)
    LET YC = CGAMMAI(XR,XC)

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CLNGAM     = Compute the complex log gamma function.
    CBETA      = Compute the complex beta function.
    CLNBETA    = Compute the complex log beta function.
    GAMMA      = Compute the Gamma function.
    GAMMAI     = Compute the incomplete Gamma function.
    DIGAMMA    = Compute the digamma function.
 
Reference:
    "Computation of Special Functions", Shanjie Zhang and Jianming
    Jin, John Wiley and Sons, 1996, chapter 1.
 
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    1997/12
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES
    TITLE AUTOMATIC
    PLOT CGAMMA(XR,2) FOR XR = 0.1 0.1 5
    PLOT CGAMMA(XR,5) FOR XR = 0.1 0.1 5
    PLOT CGAMMAI(XR,2) FOR XR = 0.1 0.1 5
    PLOT CGAMMAI(XR,5) FOR XR = 0.1 0.1 5
    END OF MULTIPLOT
 
-----CGM-----------------------------------------------------------
 
CGM
 
Name:
    CGM
 
Type:
    Output Device Command
 
Purpose:
    Direct graphical output to a CGM device.
 
Description:
    CGM is the ANSI standard for Computer Graphics Metafiles and was
    developed to allow different graphics packages to exchange graphics
    files in a standard format.
 
    CGM supports three formats.  The binary format is the most compact,
    but is not necessarily transferrable across networks and hosts.
    The character format is less compact than binary, but it is
    transferrable across networks and hosts.  The clear text format is
    an ASCII text format.  Although it is the least compact, it has the
    advantage that it can be read and edited with standard text
    editors.  Currently, DATAPLOT only supports the clear text format.
 
    The CGM files are typically used as input to post processor
    programs to generate plots on a device not supported by DATAPLOT.
    In addition, many word processors and text publishing systems can
    import CGM files.
 
Syntax 1:
    CGM
    This form designates device 1 (the screen) as a CGM device.  This
    form is rare since CGM output is usually sent to a file.
 
Syntax 2:
    DEVICE <1/2/3> CGM
    This form designates one of DATAPLOT's 3 devices (it will typically
    be device 2) to be a CGM device.
 
Examples:
    DEVICE 2 CGM
    DEVICE 3 CGM
 
Note:
    Several SET commands are available to control the output produced
    by the metafiles.
 
    SET GENERAL REGION FILL [ON/OFF] - if OFF, region fills are
      generated with move and draw commands.  If ON, a pattern
      identifier is specified and the post processor generates the
      region fill.
 
    SET GENERAL PEN WIDTH [OFF/ON] - if OFF, a line width parameter is
      specified and the line is drawn once (i.e., the post processor
      draws the wide lines).  If ON, the line is drawn multiple times
      when wide lines are requested.
 
    SET GENERAL PEN THICKNESS [width] - sets the line width (in
    DATAPLOT 0. to 100. coordinates) to use when multiple lines are
    used to draw wide lines.
 
Note:
    Be aware that many CGM based post processors only accept binary
    encoded CGM files.  A binary CGM driver is planned for a future
    release, but it is not available yet.
 
    If your local post processor or text processor can only handle
    binary CGM files, check to see if it can handle HP-GL, Tektronix,
    or Postscript files instead (DATAPLOT can generate all of these
    formats).
 
Default:
    Device 1 is a Tektronix 4014, device 2 is off, and device 3 is a
    Postscript printer.
 
Synonyms:
    GENERAL CGM is a synonym for CGM.
DEVICE NOTES
    The following notes apply to how attributes are stored in the CGM
    file.  Be aware that a post processor can do things differently
    when drawing the CGM file on a specific device (e.g., it may draw
    area fills in software even though the CGM file specifies a
    hardware fill).
    1) HARDWARE TEXT - CGM hardware characters can be scaled to any
       size.  Vertical strings are rotated 90 degrees.
    2) COLOR - The CGM driver supports the full range of DATAPLOT
       colors.
    3) HARDWARE FILL - The CGM file specifies the boundary of the
       region and an index identifying the type of fill.  See the
       SET GENERAL REGION FILL note above for instructions on how to
       generate software fills directly in the CGM file.
    4) DASH PATTERNS - The CGM file identifies the dash pattern with
       an index.  There is a unique index for each dash pattern
       supported by DATAPLOT.
    5) LINE WIDTH - The CGM device draws thick lines by drawing one
       line and specifying a width parameter.  See the SET GENERAL
       PEN WIDTH note above for instructions on how to draw thick
       lines by drawing multiple lines instead.
    6) GRAPHICS INPUT - The CROSS-HAIR command is ignored for this
       device.
 
Related Commands:
    GENERAL               = Direct graphical output to a DATAPLOT
                            specific metafile.
    CALCOMP               = Direct graphical output to a Calcomp
                            device.
    POSTSCRIPT            = Direct graphical output to a Postscript
                            device.
    TEKTRONIX             = Direct graphical output to a Tektronix
                            device.
    DEVICE                = Specify certain actions for the graphics
                            output.
    SET GENE REGION FILL  = Specify whether region fills are done in
                            hardware or software.
    SET GENERAL PEN WIDTH = Specify whether wide lines are drawn in
                            hardware or software.
    SET GENERAL PEN THICK = Specify the width of a single line when
                            drawing wide lines.
 
Applications:
    Graphics Metafile
 
Implementation Date:
    90/3
 
Program:
    XX
 
-----CHARACTERS-------------------------------------------------------
 
CHARACTERS
 
Name:
    CHARACTERS
 
Type:
    Plot Control Command
 
Purpose:
    Specifies character types (A, B, ..., Z, 1, 2, 3, ..., circle,
    square, triangle, diamond, star, etc.) to appear at the plot points
    of each trace on subsequent plots.
 
Syntax 1:
    CHARACTERS  <type 1>  <type 2>  <type 3>  etc.
    where <type> specifies the desired character symbol.  Up to 100
    character symbols can be listed.   Enter HELP CHARACTER TYPES for a
    list of available plot symbols.
 
Syntax 2:
    CHARACTER SAVE

    This syntax saves the current settings of the CHARACTER
    command.

Syntax 3:
    CHARACTER RESTORE

    This syntax restores the settings of the CHARACTER command
    saved by a prior CHARACTER SAVE command.

Examples:
    CHARACTERS X BLANK STAR
    CHARACTERS A B C D E
    CHARACTERS STAR CIRCLE SQUARE DIAMOND
    CHARACTERS STAR ALL
    CHARACTERS ALL STAR
    CHARACTERS
 
Note:
    Characters are specified by trace.  All characters belonging to the
    same trace are plotted with the same plot symbol.
 
Note:
    The BAR, SPIKE, CHARACTER, and LINE switch all work independently
    of each other.  That is, a plot point can be a line, a character, a
    spike or a bar or any combination of the above.
 
Note:
    There are approximately 10 commands for controlling the attributes
    of the plotted character.  See the RELATED COMMANDS section below.
 
Note:
    User's sometimes wish to draw a plot symbol at every N points on a
    trace.  This is handled in DATAPLOT through the creation of a tag
    variable.  For example, to plot every fifth point do something like
    the following:

       LET NINC = 5
       LET N = SIZE Y
       LET TAG = SEQUENCE 1 1 N
       LET TAG = MOD(TAG,NINC)
       LET TAG = -1 SUBSET TAG <> 1
       LINE BLANK SOLID
       CHARACTER CIRCLE BLANK
       PLOT Y X SUBSET TAG = 1 AND
       PLOT Y X

    More complex patterns are also possible (all values with the same
    value for the tag variable are plotted with the same character
    attributes).
 
Note:
    The CHARACTER <SAVE/RESTORE> was motivated for use by the
    Tcl/Tk graphical interface.  However, it can also be used
    directly by the user.  A typical use would be to save the
    current settings before a command, such as the box plot,
    that requires special settings for the CHARACTER command.
    The settings could then be easily restored after the special
    plot.

    This feature was implemented 1998/5.

Note:
    The CHARACTERS command with no arguments sets the character type to
    blank for all traces.  The CHARACTERS command with the word ALL
    before or after the specified type assigns that character type to
    all traces; thus CHARACTER X ALL or CHARACTER ALL X assigns the
    character X to all traces.
 
Note:
    The following special settings for CHARACTER were implemented
    2000/1.

    ROWID     - uses the row number as the plot character
    ROWLABEL  - uses the row label as the plot character
    XVALUE    - uses the x-coordinate of the point as the plot
                character
    YVALUE    - uses the y-coordinate of the point as the plot
                character
    XYVALUE   - uses (x-coor,y-coor) as the plot character
    TVALUE    - uses the tag value as the plot character (Dataplot
                assigns a curve-id, the tag, to each point)
    ZVALUE    - this is a special form that is specific to certain
                commands.  For a few commands (currently the
                DEX CONTOUR PLOT and the CROSS TABULATE PLOT, but we
                expect a few additional plots to support this form in
                future releases), Dataplot writes a numeric value into
                an internal array.  The value in this array is
                used as the plot symbol.  Using this with
                unsupported plot types may have unpredictable
                results (it will depend on what is stored in
                the internal array).  This option is typically
                set automatically by Dataplot in the
                background, so currently users should not
                set this directly.

    The ROWID and ROWLABEL are typically only used for the
    PLOT command (i.e., not for HISTOGRAM, etc.).  This option
    keeps track of any subsetting (i.e., SUBSET/FOR/EXCEPT
    clauses on the plot command) when identifying the point.
    However, the results may be unpredictable for graphics other
    than the PLOT command.

    The most common use of this command is to identify specific
    points on the plot (typically with the ROWLABEL option).
    A typical sequence would be

         CHARACTER X
         PLOT Y X
         PRE-ERASE OFF
         LIMITS FREEZE
         CHARACTER ROWLABEL
         PLOT Y X SUBSET Y > 90

Note:
   The following special forms of the command can be used to
   set the character settings for specific graph types

      CHARACTER BOX PLOT
      CHARACTER TUFTE BOX PLOT
      CHARACTER VIOLIN PLOT
      CHARACTER I PLOT
      CHARACTER CONTROL CHART
      CHARACTER ERROR BAR PLOT

Note:
    Dataplot currently allows for 100 settings of the CHARACTER
    command.  There are situations where more than 100 traces
    are used on a plot.  For example, with the syntax

        PLOT Y X X

    the number of traces for the plot will equal the number of
    unique values for X.

    When the number of traces exceeds 100, Dataplot will repeat
    the character settings.  That is, trace 101 will use setting 1,
    trace 102 will use setting 2, and so on.

    There may be cases where you want to reserve the first few
    settings and start the repeat for later settings.  You can
    use the command

        SET CHARACTER REPEAT OFFSET <value>

    to specify an offset for the repeat.  For example, if you enter

        SET CHARACTER REPEAT OFFSET 2
 
    then trace 101 will use character setting 3, traces 102 will
    use character setting 4, and so on.

    An example of this would be

        CHARACTER X ALL
        CHARACTER BLANK
        LINE BLANK ALL
        LINE SOLID
        .
        SET CHARACTER REPEAT OFFSET 1
        PLOT Y2 X2 AND
        PLOT Y X X

    Here character setting 1 is reserved for the plot of Y2 versus X2
    and the character settings for PLOT Y X X will all be set to
    X.

Default:
    All characters are blank.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
 
    CHARACTERS          = Sets the types for plot characters.
    CHARACTER ANGLE     = Sets the angles for plot characters.
    CHARACTER AUTOMATIC = Specifies a variable to be used as the
                          arguments to the CHARACTER command.
    CHARACTER CASE      = Sets the cases for plot characters.
    CHARACTERS COLORS   = Sets the colors for plot characters.
    CHARACTER FILL      = Sets the fill switches for plot characters.
    CHARACTER FONT      = Sets the fonts for plot characters.
    CHARACTER HW        = Sets the heights and widths for plot
                          characters.
    CHARACTER JUST      = Sets the justifications for plot characters.
    CHARACTER OFFSET    = Sets the offsets for plot characters.
    CHARACTERS SIZES    = Sets the sizes for plot characters.
    CHARACTER THICKNESS = Sets the thicknesses for plot characters.
    CHARACTER WIDTH     = Sets the widths for plot characters.
 
    LINES               = Sets the types for plot lines.
    SPIKES              = Sets the on/off switches for plot spikes.
    BARS                = Sets the on/off switches for plot bars.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    Pre-1987
    1988/11: CHARACTER ERROR BAR PLOT
    1998/02: CHARACTER <SAVE/RESTORE>
    2000/01: CHARACTER ROWID, CHARACTER ROWLABEL
    2000/01: CHARACTER XVALUE, CHARACTER YVALUE, CHARACTER XYVALUE
    2000/01: CHARACTER TVALUE, CHARACTER ZVALUE
    2003/02: CHARACTER VIOLIN PLOT
    2010/06: Allow 16 characters for CHARACTER settings
 
Program:
    . POLLUTION SOURCE ANALYSIS, LLOYD CURRIE, DATE--1990
    . SUBSET OF CURRIE.DAT REFERENCE FILE
    .
    LET ID2 = DATA 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2
    SERIAL READ LEAD
    164 426 59 98 312 263 607 497 213 54 160 262 547 325 419 94 70
    END OF DATA
    SERIAL READ POT
    106 175 61 79 94 121 424 328 107 218 140 179 246 231 245 339 99
    END OF DATA
    .
    CHARACTER X1 X2 Y1 Y2
    LINE BLANK ALL
    LEGEND 1 X - POTASSIUM
    LEGEND 2 Y - LEAD
    .
    TITLE DEMONSTRATE CHARACTER COMMAND
    LET X = SEQUENCE 1 1 17
    PLOT POT X ID2 AND
    PLOT LEAD X ID2
 
-----CHARACTER------------------------------------------------
 
CHARACTER (LET)
 
Name:
    CHARACTER
 
Type:
    Let Subcommand
 
Purpose:
    Convert a parameter or a variable to a string based on the
    ASCII collating sequence.
 
Description:
    Most modern computer platforms use the ASCII collating sequence
    to code characters.  In the ASCII collating sequence, the
    integers 0 to 255 are used to represent specific characters.
    Specifically

        1) 48 - 57  denote the digits 0 to 9
        2) 65 - 90  denote the upper case characters A to Z
        3) 97 - 122 denote the lower case characters a to z

    The other values represent special characters such as quotes
    and ampersands or non-printing characters such as tabs, 
    carriage returns, or line feeds.

    This command allows you to create a string based on the
    ASCII collating sequence.  For example, you can use this
    to insert a non-printing character (e.g., a tab or a
    carriage return) into a string.

Syntax:
    LET <sout> = CHARACTER  <val>
    where <val> is a parameter or variable containing the ASCII
             collating sequence index values;
    and   <sout> is a string.
 
    The values in <val> should be in the range 0 to 255 (real
    numbers will be rounded to the nearest integer).  If any
    values outside this range are detected, an error message
    is printed and <sout> is not created.

Examples:
    LET SOUT = CHARACTER IVAL
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ICHAR               = Convert a string to numeric values based on
                          the ASCII collating sequence.
    LET FUNCTION        = Defines a function.
    LET STRING          = Defines a string.
    READ STRING         = Reads a string from a file.
    SUBSTITUTE CHARACTE = Substitute the value of a string or parameter.
    &                   = Concatenate two strings.
    SUBTRING            = Extract a substring from an existing string.
    STRING LENGTH       = Return the length of a string.
    STRING INDEX        = Return the start and stop positions of a 
                          substring within a string.
    STRING CONCATENATE  = Concatenate one or more previously defined
                          strings.
    STRING EDIT         = Edit a string.
    STRING MERGE        = Insert a string into another string without
                          overwrite.
    STRING REPLACE      = Insert a string into another string with
                          overwrite.
    LOWER CASE          = Convert a string to lower case.
    UPPER CASE          = Convert a string to upper case.
    GROUP LABEL         = Define the text for group labels.
 
Applications:
    Data Management
 
Implementation Date:
    11/2008
 
Program:
    LET IVAL = DATA 102 105 108 101 50 51 46 100 97 116
    LET STRING SOUT = CHARACTER IVAL

    The resulting value of SOUT is file23.dat.

-----CHARACTER ANGLE---------------------------------------------------
 
CHARACTER ANGLE
 
Name:
    CHARACTER ANGLE
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the angle of the characters to appear at the plot points
    of each trace on subsequent plots.
 
Description:
    Plot symbols are not normally drawn at an angle.  This command is
    typically used with the CHARACTER OFFSET command when the CHARACTER
    command is used to label one or more points on the plot.
 
    The angle is specified in degree units.  There is no way to specify
    radian units (the ANGLE UNITS command does not apply here).
 
Syntax:
    CHARACTER ANGLES  <angle>  <angle>  <angle>  etc.
    where <angle> is a number or parameter that specifies the desired
    angle.  Up to 100 angles can be specified.
 
Examples:
    CHARACTER ANGLES 45. 90. 50.
    CHARACTER ANGLES 0. 90. 90. 45.
    CHARACTER ANGLES ALL 45.
    CHARACTER ANGLES 90. ALL
    CHARACTERS ANGLES
 
Note:
    Character angles are specified by trace.  All characters belonging
    to the same trace are plotted with the same character angle.
 
Note:
    The BAR, SPIKE, CHARACTER, and LINE switch all work independently
    of each other.  That is, a plot point can be a line, a character, a
    spike or a bar or any combination of the above.
 
Note:
    This command is typically used with the FONT or CHARCTER FONT
    command since hardware characters can only be drawn an angle of 0
    or 90 (i.e., horizontal or vertical).  Software fonts can draw the
    character at any arbitrary angle.
 
Note:
    Although the CHARACTER command can be used to label plot points, be
    aware that it has some serious limitations in this regard.  The
    most important limitation is that character labels are limited to 4
    characters.  If you need more than 4 characters, you have to use
    the TEXT or LEGEND command.  However, this is more difficult since
    the coordinates are given in DATAPLOT 0 to 100 screen units rather
    than the data units.  The MOVEDATA command can be used with the
    TEXT command (MOVEDATA is an alternate version of MOVE that uses
    the coordinates from the most recent plot).
 
Note:
    The CHARACTER ANGLE command with no arguments sets the character
    angle to default for all traces.  The CHARACTER ANGLE command with
    the word ALL before or after the specified angle assigns that angle
    to the characters on all traces; thus CHARACTER ANGLE 45. ALL or
    CHARACTER ANGLE ALL 45. assigns the angle 45. to the characters on
    all traces.
 
Default:
    All plot characters are plotted with an angle of 0.0 (i.e.,
    horizontal characters).
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
 
    CHARACTERS          = Sets the types for plot characters.
    CHARACTER AUTOMATIC = Specifies a variable to be used as the
                          arguments to the CHARACTER command.
    CHARACTER CASE      = Sets the cases for plot characters.
    CHARACTERS COLORS   = Sets the colors for plot characters.
    CHARACTER FILL      = Sets the fill switches for plot characters.
    CHARACTER FONT      = Sets the fonts for plot characters.
    CHARACTER HW        = Sets the heights and widths for plot
                          characters.
    CHARACTER JUST      = Sets the justifications for plot characters.
    CHARACTER OFFSET    = Sets the offsets for plot characters.
    CHARACTERS SIZES    = Sets the sizes for plot characters.
    CHARACTER THICKNESS = Sets the thicknesses for plot characters.
    CHARACTER WIDTH     = Sets the widths for plot characters.
 
    LINES               = Sets the types for plot lines.
    SPIKES              = Sets the on/off switches for plot spikes.
    BARS                = Sets the on/off switches for plot bars.
    ANGLE               = Sets the angle for plotting characters with
                          the text command.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    XX
 
Program:
    LEGEND 1 PRESENTATION GRAPHICS
    LEGEND 2 3-D BAR HISTOGRAM
    .
    LET Y = DATA 392 341 307 203 115 59 38 32 29 28
    .
    LET N = NUMBER Y
    LET X = SEQUENCE 1 1 N
    .
    LINES BLANK ALL
    BAR ON ALL
    BAR WIDTH .5 ALL
    BAR DIMENSION 3 ALL
    BAR FILL ONTS ALL
    CHARACTER FONT DUPLEX ALL
    CHARACTERS APOL SUN HP DEC SYM SG IBM DG TI XER
    CHARACTER ANGLE 45 ALL
    CHARACTER OFFSET  4 9 ALL
    CHARACTER SIZE 3.5 ALL
    YMAX 600
    XMAX 12
    TITLE DEMONSTRATE CHARACTER ANGLE
    PLOT Y X X
 
-----CHARACTER AUTOMATIC---------------------------------------------
 
CHARACTER AUTOMATIC
 
Name:
    CHARACTER AUTOMATIC
 
Type:
    Plot Control Command
 
Purpose:
    Specifies a variable that is to be used as the arguments to the
    CHARACTER command.
 
Description:
    This command allows a variable to be used as the arguments to the
    CHARACTERS command.  It is typically used with the CHARACTER OFFSET
    or CHARACTER ANGLE command to label plot points.  One application is
    labeling bar charts with the data value.  However, it can be used in
    other ways.
 
    This command is restricted to numeric values (it does not allow you
    to specify alphabetic strings).  Also, the CHARACTER command is
    limited to 4 characters, which means that only the first 4
    significant digits of the numeric values are printed (it is most
    typically used with integer values).

    The limit for the number of characters in the CHARACTER command
    was increased from 4 to 16 in the June, 2010 version of Dataplot.
 
Syntax 1:
    CHARACTER AUTOMATIC  <variable> <SUBSET/EXCEPT/FOR qualification>
    where the first element of <variable> specifies the character for
          trace 1, the second element specifies the character for
          trace 2, and so on up to 100 traces;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    CHARACTER AUTOMATIC DISTINCT <variable>
                                 <SUBSET/EXCEPT/FOR qualification>
    where the first distinct element of <variable> specifies the
          character for trace 1, the second distinct element
          specifies the character for trace 2, and so on up to
          100 traces;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    The distinction with this syntax is that only the distinct
    elements of <variable> are used.

Syntax 3:
    CHARACTER AUTOMATIC SIGN <variable>
                             <SUBSET/EXCEPT/FOR qualification>
    where the first element of <variable> specifies the character for
          trace 1, the second element specifies the character for
          trace 2, and so on up to 100 traces;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    The distinction with this syntax is that the sign of the
    elements of <variable> are determined.  Positive values
    of <variable> result in a character of "+", negative values
    of <variable> result in a character of "-", and zero values
    of <variable> result in a character of "0".

    This syntax was implemented 2001/1.

Examples:
    CHARACTER AUTOMATIC X1
    CHARACTER AUTOMATIC DISTINCT Y1
    CHARACTER AUTOMATIC SIGN Y1
 
Note:
    The BAR, SPIKE, CHARACTER, and LINE switch all work independently
    of each other.  That is, a plot point can be a line, a character, a
    spike or a bar or any combination of the above.
 
Note:
    Although the CHARACTER command can be used to label plot points, be
    aware that it has some serious limitations in this regard.  The
    most important limitation is that character labels are limited to 4
    characters.  If you need more than 4 characters, you have to use
    the TEXT or LEGEND command.  However, this is more difficult since
    the coordinates are given in Dataplot 0 to 100 screen units rather
    than the data units.  The MOVEDATA command can be used with the
    TEXT command (MOVEDATA is an alternate version of MOVE that uses
    the coordinates from the most recent plot).
 
    The number of characters allowed was increased from 4 to 16 in
    the June, 2010 version of Dataplot.

Note:
    The CHARACTER AUTOMATIC command with no arguments sets all
    characters to X.

Note:
    In some cases, you may not want to start with the first
    CHARACTER setting.  To specify an offset for the
    CHARACTER AUTOMATIC command, enter the command

        SET CHARACTER AUTOMATIC OFFSET <value>

    where <value> is a non-negative integer (the default is 0).

    For example,

        CHARACTER AUTOMATIC Y
        SET CHARACTER AUTOMATIC OFFSET 3

    means that Y(1) will be used for the fourth setting of the
    CHARACTER command, Y(2) will be used for the fifth setting of
    the character command, and so on.

    This can be useful if your plot needs to reserve the first
    few character settings for other plot elements.

Note:
    By default, when you enter the CHARACTER AUTOMATIC command, the
    character settings are extracted immediately from the specified
    variable.  However, there may be situations where you want to defer
    the extraction until the plot is generated.  To specify that
    the character settings will be extracted when the plot is
    generated, enter the command

        SET CHARACTER AUTOMATIC DYNAMIC ON

    To reset the default that the character settings will be extracted
    when the CHARACTER AUTOMATIC command is entered, use the command
 
        SET CHARACTER AUTOMATIC DYNAMIC OFF

Default:
    No automatic plot characters are used.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
 
    CHARACTERS          = Sets the types for plot characters.
    CHARACTER CASE      = Sets the cases for plot characters.
    CHARACTERS COLORS   = Sets the colors for plot characters.
    CHARACTER FILL      = Sets the fill switches for plot characters.
    CHARACTER FONT      = Sets the fonts for plot characters.
    CHARACTER HW        = Sets the heights and widths for plot
                          characters.
    CHARACTER JUST      = Sets the justifications for plot characters.
    CHARACTER OFFSET    = Sets the offsets for plot characters.
    CHARACTERS SIZES    = Sets the sizes for plot characters.
    CHARACTER THICKNESS = Sets the thicknesses for plot characters.
    CHARACTER WIDTH     = Sets the widths for plot characters.
 
    LINES               = Sets the types for plot lines.
    SPIKES              = Sets the on/off switches for plot spikes.
    BARS                = Sets the on/off switches for plot bars.
    ANGLE               = Sets the angle for plotting characters with
                          the text command.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    Pre-1987
    2010/06: Support for 16 characters in CHARACTER settings
    2011/12: SET CHARACTER AUTOMATIC OFFSET added
    2012/07: SET CHARACTER AUTOMATIC DYNAMIC added
 
Program:
    LEGEND 1 PRESENTATION GRAPHICS
    LEGEND 2 3-D BAR HISTOGRAM
    .
    LET Y = DATA 392 341 307 203 115 59 38 32 29 28
    .
    LET N = NUMBER Y
    LET X = SEQUENCE 1 1 N
    .
    LINES BLANK ALL
    BAR ON ALL
    BAR WIDTH .5 ALL
    BAR DIMENSION 3 ALL
    BAR FILL ONTS ALL
    CHARACTER OFFSET  0 4 ALL
    CHARACTER AUTOMATIC Y
    YMAX 600
    XMAX 12
    TITLE DEMONSTRATE CHARACTER AUTOMATIC
    PLOT Y X X
 
-----CHARACTER CASE---------------------------------------------------
 
CHARACTER CASE
 
Name:
    CHARACTER CASE
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the cases (upper/lower) of the characters to appear at
    the plot points of each trace on subsequent plots.
 
Syntax:
    CHARACTER CASE  <case>  <case>  <case>  etc.
    where <case> specifies the desired cases.  A value of UPPER means
    the character trace is plotted in upper case while a value of LOWER
    means the character trace is plotted in lower case.  Up to 100
    character cases can be specified.
 
Examples:
    CHARACTER CASE UPPER LOWER UPPER
    CHARACTER CASE LOWER LOWER UPPER UPPER
    CHARACTER CASE ALL UPPER
    CHARACTER CASE LOWER ALL
    CHARACTER CASE
 
Note:
    Characters are specified by trace.  All characters belonging to the
    same trace are plotted with the same plot symbol.
 
Note:
    The BAR, SPIKE, CHARACTER, and LINE switch all work independently
    of each other.  That is, a plot point can be a line, a character, a
    spike or a bar or any combination of the above.
 
Note:
    The CHARACTER CASE command with no arguments sets the character
    case to default for all traces.  The CHARACTER CASE command with
    the word ALL before or after the specified case assigns that case
    to the characters on all traces; thus CHARACTER CASE LOWER ALL or
    CHARACTER CASE ALL LOWER assigns the case lower to the characters`
    on all traces.
 
Default:
    All characters are drawn in upper case.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
 
    CHARACTERS          = Sets the types for plot characters.
    CHARACTER ANGLE     = Sets the angles for plot characters.
    CHARACTER AUTOMATIC = Specifies a variable to be used as the
                          arguments to the CHARACTER command.
    CHARACTERS COLORS   = Sets the colors for plot characters.
    CHARACTER FILL      = Sets the fill switches for plot characters.
    CHARACTER FONT      = Sets the fonts for plot characters.
    CHARACTER HW        = Sets the heights and widths for plot
                          characters.
    CHARACTER JUST      = Sets the justifications for plot characters.
    CHARACTER OFFSET    = Sets the offsets for plot characters.
    CHARACTERS SIZES    = Sets the sizes for plot characters.
    CHARACTER THICKNESS = Sets the thicknesses for plot characters.
    CHARACTER WIDTH     = Sets the widths for plot characters.
 
    LINES               = Sets the types for plot lines.
    SPIKES              = Sets the on/off switches for plot spikes.
    BARS                = Sets the on/off switches for plot bars.
    CASE                = Sets the case for characters plotted with the
                          TEXT command.
 
Applications:
    XX
 
Implementation Date:
    89/2
 
Program:
    . POLLUTION SOURCE ANALYSIS, LLOYD CURRIE, DATE--1990
    . SUBSET OF CURRIE.DAT REFERENCE FILE
    .
    LET ID2 = DATA 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2
    SERIAL READ LEAD
    164 426 59 98 312 263 607 497 213 54 160 262 547 325 419 94 70
    END OF DATA
    SERIAL READ POT
    106 175 61 79 94 121 424 328 107 218 140 179 246 231 245 339 99
    END OF DATA
    .
    CHARACTER X X Y Y
    CHARACTER CASE LOWER UPPER LOWER UPPER
    LINE BLANK ALL
    LEGEND 1 X - POTASSIUM
    LEGEND 2 Y - LEAD
    .
    TITLE DEMONSTRATE CHARACTER CASE COMMAND
    LET X = SEQUENCE 1 1 17
    PLOT POT X ID2 AND
    PLOT LEAD X ID2
 
-----CHARACTER CODE STRING---------------------------------------------
 
CHARACTER CODE STRING
 
Name:
    CHARACTER CODE STRING (LET)
 
Type:
    Subcommand under LET
 
Purpose:
    Converts previously read character data to strings.
 
Description:
    Dataplot can now read character data using the
 
        SET CONVERT CHARACTER ON

    command.  This command stores the character fields in the
    file "dpchzf.dat".
 
    The two primary uses of character data are:

       1) Provide a row identifier for the data.

       2) Define a group (or factor) variable.  For example, we
          can identify sex by coding males as M and females as F.

    The command GROUP LABEL can be used to create a group label
    variable.  However, in some contexts we may want more flexibility
    with the character data than provided by the GROUP LABEL command.
    The CHARACTER CODE STRING command can be used in this case to
    create explicit character strings.

    The CHARACTER CODE STRING command identifies the unique rows in the
    character variable (Dataplot checks for exact matches, it
    does not try to guess if a typo has occurred, etc.).  If
    there are K unique rows, Dataplot will generate K character strings.
    The command defines a base name for the string and the appropriate
    index number will be appended to the string names.

    The CHARACTER CODE STRING extracts the index number for the string
    name  in the order that the unique rows are encoutered in the file.

Syntax 1:
    LET <sbase> = CHARACTER CODE STRING <ix>
    where <ix> specifies the name of the character variable in
               the file dpzchf.dat;
    and   <sbase> specifies the base name for the strings to be generated.

    The character variable is originally created with a READ
    command where the SET CONVERT CHARACTER ON was entered prior
    to the READ.

Examples:
    SET CONVERT CHARACTER ON
    READ TEST.DAT  Y X IX
    LET SLAB = CHARACTER CODE STRING IX
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    READ                        = Carries out a column-wise input of
                                  data.
    CONVERT CHARACTER           = Specify how Dataplot will handle
                                  character data.
    CHARACTER CODE              = Convert previously read character
                                  data to a coded numerical variable.
    GROUP LABEL                 = Converts character data to a group
                                  label variable.
    GROUP LABEL TO STRINGS      = Converts a previously created group
                                  label variable to strings.
    ROWLABELS                   = Define row labels from character
                                  data.
 
Applications:
    Input/Output
 
Implementation Date:
    2011/10
 
Program:
    set convert character on
    skip 25
    read draft69c.dat rank day month
    .
    .  Add cr() to alternating strings
    .
    let ig = character code string month
    let string cr = sp()cr()
    loop for k = 2 2 12
        let ig^k = string concatenate cr ig^k
    end of loop
    let ignew = group label ig1 to ig12
    x1tic mark label format group label
    x1tic mark label content ignew
    let xcode = character code month
    .
    major xtic mark number 12
    minor xtic mark number 0
    xlimits 1 12
    xtic offset 0.5 0.5
    .
    char box plot
    line box plot
    fences on
    .
    box plot rank xcode

-----CHARACTER CODE---------------------------------------------
 
CHARACTER CODE
 
Name:
    CHARACTER CODE (LET)
 
Type:
    Subcommand under LET
 
Purpose:
    Converts previously read character data to a coded numeric variable.
 
Description:
    Dataplot can read character data using the
 
        SET CONVERT CHARACTER ON

    command.  This command stores the character fields in the
    file "dpchzf.dat".
 
    The two primary uses of character data are:

       1) Provide a row identifier for the data.

       2) Define a group (or factor) variable.  For example, we
          can identify sex by coding males as M and females as F.

    In the context of Dataplot, we can use groups in two contexts.

       1) The group variable can be used in a numerical context.
          For example,

              BOX PLOT Y X

          Here, X is the group-id variable.

          The command CHARACTER CODE (or ALPHABETIC CHARACTER CODE or
          REFERENCE CHARACTER CODE) can be used to create a coded numeric
          variable from a character variable saved in the file dpchzf.dat.

       2) We can use the group label for labeling.  In this case, we
          typically want to use the character coding.

          The GROUP LABEL command is used to create character group labels
          from a character variable saved in the file dpchzf.dat.

          The GROUP LABEL will extract and save the unique rows for
          the specified character variable.

    The CHARACTER CODE command identifies the unique rows in the
    character variable (Dataplot checks for exact matches, it
    does not try to guess if a typo has occurred, etc.).  If
    there are K unique rows, Dataplot will generate coded values
    as the integer values from 1 to K.  The CHARACTER CODE performs
    the coding in the order that the unique rows are encoutered in
    the file.

    The ALPHABETIC CHARACTER CODE is a variant of the CHARACTER CODE
    command that sorts the unique character rows and assigns the
    code based on the alphabetic order of the character rows.

    There may be some cases where we want to control the mapping from
    the character variable to the coded numeric variable.  The
    REFERENCE CHARACTER CODE can be used in this case.  We define a group
    label variable that defines the desired ordering.  The numeric coding
    is then based on the ordering given with the group label variable.
    This is demonstrated in the Program 2 example below.

Syntax 1:
    LET <y> = CHARACTER CODE <ix>
    where <ix> specifies the name of the character variable in
               the file dpzchf.dat;
    and   <y> specifies the name for the coded numberic variable
               to be saved.

    The character variable is originally created with a READ
    command where the SET CONVERT CHARACTER ON was entered prior
    to the READ.

Syntax 2:
    LET <y> = ALPHABETIC CHARACTER CODE <ix>
    where <ix> specifies the name of the character variable in
               the file dpzchf.dat;
    and   <y> specifies the name for the coded numberic variable
               to be saved.

    The character variable is originally created with a READ
    command where the SET CONVERT CHARACTER ON was entered prior
    to the READ.

    This syntax assigns the codes based on the alphabetic order
    of the character variable.

Syntax 3:
    LET <y> = REFERENCE CHARACTER CODE <ix>  <ig>
    where <ix> specifies the name of the character variable in
               the file dpzchf.dat;
          <ig> specifies the name of a previously created group
               label variable;
    and   <y> specifies the name for the coded numberic variable
               to be saved.

    The character variable is originally created with a READ
    command where the SET CONVERT CHARACTER ON was entered prior
    to the READ.

    This syntax assigns the codes based on the ordering in the group
    label variable.

Examples:
    SET CONVERT CHARACTER ON
    READ TEST.DAT  Y X IX
    LET Y = CHARACTER CODE IX
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    READ                        = Carries out a column-wise input of data.
    CONVERT CHARACTER           = Specify how Dataplot will handle
                                  character data.
    GROUP LABEL                 = Converts character data to a group
                                  label variable.
    ROW LABEL                   = Define row labels from character data.
 
Applications:
    Input/Output
 
Implementation Date:
    2004/01
    2018/06: Support for the REFERENCE CHARACTER CODE case
 
Program 1:
    set convert character on
    skip 25
    read draft69c.dat rank day month
    .
    let ig = group label month
    x1tic mark label format group label
    x1tic mark label content ig
    x1tic mark label font simplex
    x1tic mark label angle 45
    x1tic mark label displacement 10
    let xcode = character code month
    .
    major xtic mark number 12
    minor xtic mark number 0
    xlimits 1 12
    xtic offset 0.5 0.5
    .
    char box plot
    line box plot
    fences on
    .
    box plot rank xcode

Program 2:
    skip 1
    set convert character on
    read refcode.txt comp method lab ymean ysd ni
    set convert character off
    skip 0
    .
    . Step 2: Create coded values
    .
    let string l1 = NIST
    let string l2 = CTL
    let il = group label l1 l2
    .
    let string m1 = XRF
    let string m2 = TGA
    let string m3 = ISE
    let string m4 = GRAV
    let string m5 = ICP
    let im = group label m1 to m5
    .
    let string c1 = ZnO
    let string c2 = Cl
    let string c3 = LOI220
    let string c4 = LOI550
    let string c5 = LOI950
    let string c6 = Na2O
    let string c7 = MgO 
    let string c8 = Al2O3
    let string c9 = K2O
    let string c10 = TiO2
    let string c11 = Cr2O3
    let string c12 = Mn2O3
    let string c13 = Fe2O3
    let string c14 = SO3
    let string c15 = SiO2
    let string c16 = P2O5
    let string c17 = CaO
    let string c18 = SrO
    let string c19 = BaO
    let ic = group label c1 to c19
    .
    let ycomp = reference character code comp   ic
    let ymeth = reference character code method im
    let ylab  = reference character code lab    il
    status f
    print il im ic
    .
    set write decimals 0
    print ycomp ymeth ylab

-----CHARACTER COLORS--------------------------------------------------
 
CHARACTER COLORS
 
Name:
    CHARACTER COLORS
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the colors of the characters to appear at the plot points
    of each trace on subsequent plots.

Description:
    Dataplot defines the points on a plot by "traces".  A trace is a set
    of points that are drawn with the same attributes.  For example,

        PLOT Y1 X1 AND
        PLOT Y2 X2

    has two traces.  The first is the points defined by Y1 and X1 and the
    second is the points defined by Y2 and X2.  Attributes can be set for
    up to 100 traces.

    Dataplot provides two methods for specifying colors.

        1. Colors can be defined by name (or by the corresponding index).
           Dataplot adopted it's named colors from the X11 project.
           Currently, 162 named colors and 100 levels of grayscale are
           supported.  Grayscale can be specified with either G0, G1, ...,
           G100 (or -1, -2, ..., -100).  Many older devices support only a
           limited number of colors.  For these devices, unsupported colors
           will be mapped to one of the available colors.  To specify a
           named color, see Syntax 1.

        2. Most modern graphics devices support full RGB (RedBlueGreen)
           color.  You can alternatively specify RGB colors by entering
           three integer values to represent the Red, Green and Blue
           components, respectively.  These values should be in the range
           0 to 255.

    When setting the character color, Dataplot first checks if the device
    supports RGB colors. If not, the named color will be used.  If the
    device does support RGB color, Dataplot will check if an RGB color
    has been specified.  If yes, then that RGB color is used.  If not,
    the named color will be used.

    To see the list of supported named colors (with the associated index
    number), see

    https://www.itl.nist.gov/div898/software/dataplot/refman1/ch11/homepage.htm

Syntax 1:
    CHARACTER COLORS <color1> <color2>  ... <colorn>
    where <color1>, <color2>, ..., <colorn> specifies the desired colors.

    Up to 100 character colors can be specifed.
 
Syntax 2:
    CHARACTER RGB COLORS <red-1> <green-1> <blue-1> ...
                    <red-n> <green-n> <red-n>
    where <red-1>, <green-1>, <blue-1>, ..., <red-n>, <green-n>, <blue-n>
    is a list of integer values that specify the desired RGB character
    colors.

    Up to 100 such triplets of color values can be specified.

    To turn off the RGB color, set the values to -1 (any negative value
    will work).  Values greater than 255 will be set to 255.
 
Examples:
    CHARACTER COLORS RED BLUE RED
    CHARACTER COLORS RED RED BLUE BLUE
    CHARACTER COLORS ALL YELLOW
    CHARACTER COLORS YELLOW ALL
    CHARACTER COLORS
    CHARACTER RGB COLORS 220 109 88 240 220 160
    CHARACTER RGB COLORS 220 109 88 ALL

Note:
    The CHARACTER COLORS command with no arguments sets the character
    color to default for all traces.  The CHARACTER COLORS command with
    the word ALL before or after the specified color assigns that color
    to the characters on all traces; thus CHARACTER COLOR GREEN ALL or
    CHARACTER COLOR ALL GREEN assigns the color green to the characters
    on all traces.
 
Default:
    All character colors are set to black and RGB colors are off.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
 
    CHARACTERS          = Sets the types for plot characters.
    CHARACTER ANGLE     = Sets the angles for plot characters.
    CHARACTER AUTOMATIC = Specifies a variable to be used as the
                          arguments to the CHARACTER command.
    CHARACTER CASE      = Sets the cases for plot characters.
    CHARACTER FILL      = Sets the fill switches for plot characters.
    CHARACTER FONT      = Sets the fonts for plot characters.
    CHARACTER HW        = Sets the heights and widths for plot
                          characters.
    CHARACTER JUST      = Sets the justifications for plot characters.
    CHARACTER OFFSET    = Sets the offsets for plot characters.
    CHARACTERS SIZES    = Sets the sizes for plot characters.
    CHARACTER THICKNESS = Sets the thicknesses for plot characters.
    CHARACTER WIDTH     = Sets the widths for plot characters.
 
    LINE COLORS         = Sets the colors for plot lines.
    SPIKE COLORS        = Sets the colors for plot spikes.
    BAR FILL COLORS     = Sets the colors for plot bar fills.
    BAR PATTERN COLORS  = Sets the colors for plot bar patterns.
    BAR BORDER COLORS   = Sets the colors for plot bar borders.
 
    TITLE COLOR         = Sets the color for the plot title.
    LABEL COLOR         = Sets the color for plot labels.
    LEGEND COLOR        = Sets the color for plot legends.
    BOX COLOR           = Sets the color for plot boxes.
    ARROW COLOR         = Sets the color for plot arrows.
    SEGMENT COLOR       = Sets the color for plot segments.
 
    FRAME COLOR         = Sets the color for the plot frame.
    GRID COLOR          = Sets the color for plot grids.
    TIC COLOR           = Sets the color for plot tics.
    TIC LABEL COLOR     = Sets the color for plot tic labels.
    MARGIN COLOR        = Sets the color for the plot margin.
    BACKGROUND COLOR    = Sets the color for the plot background.
 
    COLOR               = Sets the color for TEXT characters.
 
Applications:
    Graphics
 
Implementation Date:
    Pre-1987
    2020/11: Support for RGB colors
 
Program:
    . POLLUTION SOURCE ANALYSIS, LLOYD CURRIE, DATE--1990
    . SUBSET OF CURRIE.DAT REFERENCE FILE
    .
    LET ID2 = DATA 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2
    SERIAL READ LEAD
    164 426 59 98 312 263 607 497 213 54 160 262 547 325 419 94 70
    END OF DATA
    SERIAL READ POT
    106 175 61 79 94 121 424 328 107 218 140 179 246 231 245 339 99
    END OF DATA
    LET X = SEQUENCE 1 1 17
    .
    CHARACTER CIRCLE CIRCLE SQUARE SQUARE
    CHARACTER FILL ON ALL
    LINE BLANK ALL
    LEGEND FONT SIMPLEX
    LEGEND 1 CIRC() - POTASSIUM
    LEGEND 2 SQUA() - LEAD
    .
    CHARACTER COLOR G10 G90 G10 G90
    TITLE DEMONSTRATE GRAYSCALE CHARACTER COLOR COMMAND
    PLOT POT X ID2 AND
    PLOT LEAD X ID2
    .
    CHARACTER COLOR RED BLUE RED BLUE
    TITLE DEMONSTRATE CHARACTER COLOR COMMAND
    PLOT POT X ID2 AND
    PLOT LEAD X ID2
    .
    CHARACTER RGB COLOR 175 238 238 220 20 60 175 238 238 220 20 60
    TITLE DEMONSTRATE CHARACTER RGB COLOR COMMAND
    PLOT POT X ID2 AND
    PLOT LEAD X ID2
 
-----CHARACTER FILL----------------------------------------------------
 
CHARACTER FILL
 
Name:
    CHARACTER FILL
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the fill switches (on/off) of the characters to appear at
    the plot points of each trace on subsequent plots.
 
Description:
    Only certain plot symbols have the option of being filled.  Enter
    HELP CHARACTER TYPES for a list of available plot symbols.  The
    following is a list of symbols that can be filled:
        CIRCLE
        SQUARE
        DIAMOND
        TRIANGLE
        REVTRI
        PYRAMID
        CUBE
    The character fill request is ignored for symbols not listed above.
 
Syntax:
    CHARACTER FILL  <ON/OFF>  <ON/OFF>  <ON/OFF>  etc.
    where ON specifies that the character is to be filled and OFF
    specifies that it is not to be filled.  Up to 100 fill switches can
    be specified.
 
Examples:
    CHARACTER FILL ON ON OFF OFF
    CHARACTER FILL ON ON ON ON ON ON
    CHARACTER FILL ALL ON
    CHARACTER FILL ON ALL
    CHARACTERS FILL
 
Note:
    This command is most typically used to produce presentation quality
    graphics.
 
Note:
    Characters are specified by trace.  All characters belonging to the
    same trace are plotted with the same plot symbol.
 
Note:
    The BAR, SPIKE, CHARACTER, and LINE switch all work independently
    of each other.  That is, a plot point can be a line, a character, a
    spike or a bar or any combination of the above.
 
Note:
    The CHARACTER FILL command with no arguments sets the character
    fill to default for all traces.  The CHARACTER FILL command with
    the word ALL before or after the specified fill assigns that fill
    to the characters on all traces; thus CHARACTER FILL ON ALL or
    CHARACTER FILL ALL ON turns the fill on for the characters on all
    traces.
    PLOT Y1 Y2 VS X
 
Default:
    All off
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
 
    CHARACTERS          = Sets the types for plot characters.
    CHARACTER ANGLE     = Sets the angles for plot characters.
    CHARACTER AUTOMATIC = Specifies a variable to be used as the
                          arguments to the CHARACTER command.
    CHARACTER CASE      = Sets the cases for plot characters.
    CHARACTERS COLORS   = Sets the colors for plot characters.
    CHARACTER FONT      = Sets the fonts for plot characters.
    CHARACTER HW        = Sets the heights and widths for plot
                          characters.
    CHARACTER JUST      = Sets the justifications for plot characters.
    CHARACTER OFFSET    = Sets the offsets for plot characters.
    CHARACTERS SIZES    = Sets the sizes for plot characters.
    CHARACTER THICKNESS = Sets the thicknesses for plot characters.
    CHARACTER WIDTH     = Sets the widths for plot characters.
 
    LINES               = Sets the types for plot lines.
    SPIKES              = Sets the on/off switches for plot spikes.
    BARS                = Sets the on/off switches for plot bars.
    BAR FILL            = Sets the fill switches for plot bars.
 
Applications:
    Presentation quality graphics
 
Implementation Date:
    XX
 
Program:
    CHARACTER CIRCLE SQUARE
    LET X = SEQUENCE 1 1 9
    LET Y1 = X**2
    LET Y2 = X**1.5
    CHARACTER FILL ON ON
 
-----CHARACTER FONT---------------------------------------------------
 
CHARACTER FONT
 
Name:
    CHARACTER FONT
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the fonts of the characters to appear at the plot points
    of each trace on subsequent plots.
 
Description:
    The following fonts are available:
       TEKTRONIX
       SIMPLEX
       DUPLEX
       TRIPLEX
       COMPLEX
       TRIPLEX ITALIC
       SIMPLEX SCRIPT
       COMPLEX SCRIPT
    The TEKTRONIX font specifies the use of hardware characters while
    the remaining 7 fonts are Hershey stroked fonts.
 
Syntax:
    CHARACTER FONT  <font>  <font>  <font>  etc.
    where <font> specifies the desired font.  Up to 100 fonts can be
    listed.
 
Examples:
    CHARACTER FONT SIMPLEX TEKTRONIX DUPLEX
    CHARACTER FONT COMPLEX SIMPLEX
    CHARACTER FONT ALL SIMPLEX
    CHARACTER FONT SIMPLEX ALL
    CHARACTERS FONT
 
Note:
    The FONT command sets the default font for the plot.  The CHARACTER
    FONT command is typically used to override the default font for the
    characters only.
 
Note:
    Characters are specified by trace.  All characters belonging to the
    same trace are plotted with the same plot symbol.
 
Note:
    The BAR, SPIKE, CHARACTER, and LINE switch all work independently
    of each other.  That is, a plot point can be a line, a character, a
    spike or a bar or any combination of the above.
 
Note:
    The CHARACTER FONT command with no arguments sets the character
    font to default for all traces.  The CHARACTER FONT command with
    the word ALL before or after the specified font assigns that font
    to the characters on all traces; thus CHARACTER FONT SIMPLEX ALL or
    CHARACTER FONT ALL SIMPLEX assigns the font simplex to the
    characters on all traces.
 
Default:
    All characters are drawn with a tektronix (i.e., hardware) font.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
 
    CHARACTERS          = Sets the types for plot characters.
    CHARACTER ANGLE     = Sets the angles for plot characters.
    CHARACTER AUTOMATIC = Specifies a variable to be used as the
                          arguments to the CHARACTER command.
    CHARACTER CASE      = Sets the cases for plot characters.
    CHARACTERS COLORS   = Sets the colors for plot characters.
    CHARACTER FILL      = Sets the fill switches for plot characters.
    CHARACTER FONT      = Sets the fonts for plot characters.
    CHARACTER HW        = Sets the heights and widths for plot
                          characters.
    CHARACTER JUST      = Sets the justifications for plot characters.
    CHARACTER OFFSET    = Sets the offsets for plot characters.
    CHARACTERS SIZES    = Sets the sizes for plot characters.
    CHARACTER THICKNESS = Sets the thicknesses for plot characters.
    CHARACTER WIDTH     = Sets the widths for plot characters.
 
    LINES               = Sets the types for plot lines.
    SPIKES              = Sets the on/off switches for plot spikes.
    BARS                = Sets the on/off switches for plot bars.
    FONT                = Sets the font for the plot.
 
Applications:
    XX
 
Implementation Date:
    89/2
 
Program:
    . POLLUTION SOURCE ANALYSIS, LLOYD CURRIE, DATE--1990
    . SUBSET OF CURRIE.DAT REFERENCE FILE
    .
    LET ID2 = DATA 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2
    SERIAL READ LEAD
    164 426 59 98 312 263 607 497 213 54 160 262 547 325 419 94 70
    END OF DATA
    SERIAL READ POT
    106 175 61 79 94 121 424 328 107 218 140 179 246 231 245 339 99
    END OF DATA
    .
    CHARACTER X X Y Y
    CHARACTER SIZE 3.0
    CHARACTER FONT SIMPLEX COMPLEX SIMPLEX COMPLEX
    LINE BLANK ALL
    LEGEND 1 X - POTASSIUM
    LEGEND 2 Y - LEAD
    .
    TITLE DEMONSTRATE CHARACTER FONT COMMAND
    LET X = SEQUENCE 1 1 17
    PLOT POT X ID2 AND
    PLOT LEAD X ID2
 
-----CHARACTER HW------------------------------------------------------
 
CHARACTER HW
 
Name:
    CHARACTER HW
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the height and width of the characters to appear at the
    plot points of each trace on subsequent plots.
 
Syntax:
    CHARACTER HW  <height> <width> <height> <width> etc.
    where <height> is a number or parameter in the decimal range 0 to
    100 that specifies the character height and <width> is a number or
    parameter in the decimal range that specifies the character width.
    Up to 100 pairs of heights and widths can be specified.
 
Examples:
    CHARACTER HW 1.0 .75 1.0 .75
    CHARACTER HW 2.0 1.5 1.0 .75
    CHARACTER HW ALL 1.0 .75
    CHARACTER HW 1.0 .75 ALL
    CHARACTERS HW
 
Note:
    This command is typically used to compensate for distortion
    produced by an aspect ratio of the device not being 1 (i.e., a
    different number of picture points in the x and y directions).  For
    example, circles look like ellipses rather than circles.  This
    distortion can also occur with the MULTIPLOT command when the
    number of rows and columns are not the same.  For a Tektronix 4014
    terminal, a height to width ratio of 1.0 to 0.75 is a good choice.
 
Note:
    Characters are specified by trace.  All characters belonging to the
    same trace are plotted with the same plot symbol.
 
Note:
    The BAR, SPIKE, CHARACTER, and LINE switch all work independently
    of each other.  That is, a plot point can be a line, a character, a
    spike or a bar or any combination of the above.
 
Note:
    The CHARACTER HW command with no arguments sets the character
    height and width to defaults for all traces.  The CHARACTER HW
    command with the word ALL before or after the specified hw pair
    assigns that hw pair to the characters on all traces; thus
    CHARACTER HW 1.0 .75 ALL or CHARACTER HW ALL 1.0 .75 sets the
    height to 1.0 and the width to .75 for the characters on all
    traces.
 
Default:
    Characters are drawn with the default character size (height 2,
    width 1).
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
 
    CHARACTERS          = Sets the types for plot characters.
    CHARACTER ANGLE     = Sets the angles for plot characters.
    CHARACTER AUTOMATIC = Specifies a variable to be used as the
                          arguments to the CHARACTER command.
    CHARACTER CASE      = Sets the cases for plot characters.
    CHARACTERS COLORS   = Sets the colors for plot characters.
    CHARACTER FILL      = Sets the fill switches for plot characters.
    CHARACTER FONT      = Sets the fonts for plot characters.
    CHARACTER JUST      = Sets the justifications for plot characters.
    CHARACTER OFFSET    = Sets the offsets for plot characters.
    CHARACTERS SIZES    = Sets the sizes for plot characters.
    CHARACTER THICKNESS = Sets the thicknesses for plot characters.
    CHARACTER WIDTH     = Sets the widths for plot characters.
 
    LINES               = Sets the types for plot lines.
    SPIKES              = Sets the on/off switches for plot spikes.
    BARS                = Sets the on/off switches for plot bars.
    HW                  = Sets the height and width for the TEXT
                          command.
 
Applications:
    Presentation quality graphics, multiplots
 
Implementation Date:
    XX
 
Program:
    CHARACTER CIRCLE SQUARE
    LET X = SEQUENCE 1 1 9
    LET Y1 = X**2
    LET Y2 = X**1.5
    CHARACTER HW 1.0 .75 1.0 .75
    PLOT Y1 Y2 VS X
 
-----CHARACTER JUSTIFICATION------------------------------------------
 
CHARACTER JUSTIFICATION
 
Name:
    CHARACTER JUSTIFICATICION
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the justification of the characters to appear at the
    plot points of each trace on subsequent plots.
 
Description:
    The following justifications are available:
       LEFT     - left horizontally, bottom vertically
       CENTER   - center horizontally, bottom vertically
       RIGHT    - right horizontally, bottom vertically
       LECE     - left horizontally, center vertically
       CECE     - center horizontally, center vertically
       RICE     - right horizontally, center vertically
       LETO     - left horizontally, top vertically
       CETO     - center horizontally, top vertically
       RITO     - right horizontally, top vertically
 
Syntax:
    CHARACTER JUSTIFICATION  <justification>  <justification> etc.
    where <justification> specifies the desired justification.  Up to
    100 justifications can be listed.
 
Examples:
    CHARACTER JUSTIFICATION CECE CECE LEFT LEFT
    CHARACTER JUSTIFICATION CECE CECE CECE CECE CECE CECE
    CHARACTER JUSTIFICATION ALL CECE
    CHARACTER JUSTIFICATION CECE ALL
    CHARACTERS JUSTIFICATION
 
Note:
    Characters are specified by trace.  All characters belonging to
    the same trace are plotted with the same plot symbol.
 
Note:
    The BAR, SPIKE, CHARACTER, and LINE switch all work independently
    of each other.  That is, a plot point can be a line, a character,
    a spike or a bar or any combination of the above.
 
Note:
    Although the CHARACTER command can be used to label plot points, be
    aware that it has some serious limitations in this regard.  The
    most important limitation is that character labels are limited to 4
    characters.  If you need more than 4 characters, you have to use
    the TEXT or LEGEND command.  However, this is more difficult since
    the coordinates are given in DATAPLOT 0 to 100 screen units rather
    than the data units.  The MOVEDATA command can be used with the
    TEXT command (MOVEDATA is an alternate version of MOVE that uses
    the coordinates from the most recent plot).
 
Note:
    The CHARACTER JUSTIFICATION command with no arguments sets the
    character justification to default for all traces.  The CHARACTER
    JUSTIFICATION command with the word ALL before or after the
    specified justification assigns that justification to the
    characters on all traces; thus CHARACTER JUSTIFICATION CECE ALL or
    CHARACTER JUSTIFICATION ALL CECE specifies center justification
    both horizontally and vertically for the characters on all traces.
 
Default:
    All characters are center justified both horizontally and
    vertically (i.e., CECE).
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
 
    CHARACTERS          = Sets the types for plot characters.
    CHARACTER ANGLE     = Sets the angles for plot characters.
    CHARACTER AUTOMATIC = Specifies a variable to be used as the
                          arguments to the CHARACTER command.
    CHARACTER CASE      = Sets the cases for plot characters.
    CHARACTERS COLORS   = Sets the colors for plot characters.
    CHARACTER FILL      = Sets the fill switches for plot characters.
    CHARACTER FONT      = Sets the fonts for plot characters.
    CHARACTER HW        = Sets the heights and widths for plot
                          characters.
    CHARACTER OFFSET    = Sets the offsets for plot characters.
    CHARACTERS SIZES    = Sets the sizes for plot characters.
    CHARACTER THICKNESS = Sets the thicknesses for plot characters.
    CHARACTER WIDTH     = Sets the widths for plot characters.
 
    LINES               = Sets the types for plot lines.
    SPIKES              = Sets the on/off switches for plot spikes.
    BARS                = Sets the on/off switches for plot bars.
    JUSTIFICATION       = Sets the justification for the TEXT command.
 
Applications:
    Presentation quality graphics
 
Implementation Date:
    XX
 
Program:
    LEGEND 1 PRESENTATION GRAPHICS
    LEGEND 2 3-D BAR HISTOGRAM
    .
    LET Y = DATA 392 341 307 203 115 59 38 32 29 28
    .
    LET N = NUMBER Y
    LET X = SEQUENCE 1 1 N
    .
    LINES BLANK ALL
    BAR ON ALL
    BAR WIDTH .5 ALL
    BAR DIMENSION 3 ALL
    BAR FILL ONTS ALL
    CHARACTER JUSTIFICATION CEBO ALL
    CHARACTERS APOL SUN HP DEC SYM SG IBM DG TI XER
    CHARACTER OFFSET  0 2 ALL
    CHARACTER SIZE 3.5 ALL
    YMAX 600
    XMAX 12
    TITLE DEMONSTRATE CHARACTER JUSTIFICATION
    PLOT Y X X
 
-----CHARACTER MAPPING---------------------------------------------
 
CHARACTER MAPPING
 
Name:
    CHARACTER MAPPING
 
Type:
    Plot Control Command
 
Purpose:
    When a tag variable is used to identify traces, specify whether
    the index into the CHARACTER setting is based on the rank or the
    exact value of the tag variable.
 
Description:
    Given the following DATAPLOT commands:
        LET X = DATA   1 1 2 2 3 3
        LET Y = DATA   1 2 3 4 5 6
        LET TAG = DATA 1 1 3 3 5 5
        CHARACTER 1 2 3 4 5
        LINE BLANK ALL
        PLOT Y X TAG
    The resulting plot would show the 3 traces labeled with the plot
    symbols 1, 2, and 3.  The index into the CHARACTER settings is
    based on the rank of the tag variable.  That is, the smallest
    value of the tag variable yields the first setting from the
    CHARACTER command, the second smallest value of the tag variable
    yields the second setting from the CHARACTER command, and so on.
    However, if the command
        CHARACTER MAPPING EXACT
    is entered before the PLOT command, then the resulting plot would
    show the 3 traces labeled with the plot symbols 1, 3, and 5.  The
    index into the CHARACTER settings is based on the exact value,
    rounded to an integer, of the tag variable. In the above example,
    where the tag variable is 1, the first setting of the CHARACTER
    command is used.  Where the tag variable is 2, the second setting
    of the CHARACTER command is used.  Where the tag variable is 5,
    the fifth setting of the CHARACTER command is used.
 
Syntax:
    CHARACTER MAPPING <RANK/EXACT>
    where <RANK> bases the index into the CHARACTER setting on the
           rank of the tag variable and <EXACT> bases the index on the
           on the exact value of the tag variable.
 
Examples:
    CHARACTER MAPPING RANK
    CHARACTER MAPPING EXACT
 
Note:
    The BAR, SPIKE, CHARACTER, and LINE switch all work independently
    of each other.  That is, a plot point can be a line, a character, a
    spike or a bar or any combination of the above.
 
Note:
    The CHARACTER command allows up to 100 settings.  If CHARACTER
    MAPPING EXACT is used, the values of the tag variable should be
    integers in the range 1 to 100.  Real values are rounded to the
    nearest integer (.5 is rounded up).  Values outside the range 1
    to 100 result in no character being plotted.
 
Default:
    Character mapping by rank is used.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
 
    CHARACTERS          = Sets the types for plot characters.
    CHARACTER AUTOMATIC = Specifies a variable to be used as the
                          arguments to the CHARACTER command.
    CHARACTER CASE      = Sets the cases for plot characters.
    CHARACTERS COLORS   = Sets the colors for plot characters.
    CHARACTER FILL      = Sets the fill switches for plot characters.
    CHARACTER FONT      = Sets the fonts for plot characters.
    CHARACTER HW        = Sets the heights and widths for plot
                          characters.
    CHARACTER JUST      = Sets the justifications for plot characters.
    CHARACTER OFFSET    = Sets the offsets for plot characters.
    CHARACTERS SIZES    = Sets the sizes for plot characters.
    CHARACTER THICKNESS = Sets the thicknesses for plot characters.
    CHARACTER WIDTH     = Sets the widths for plot characters.
 
    LINES               = Sets the types for plot lines.
    SPIKES              = Sets the on/off switches for plot spikes.
    BARS                = Sets the on/off switches for plot bars.
 
Applications:
    Youden plots
 
Implementation Date:
    94/12
 
Program:
    SKIP 25
    READ UGIANSKY.DAT Y1 Y2 LAB
    .
    CHARACTER 1 2 3 4 5 6 7
    LINES BLANK ALL
    .
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE THIS PLOT IS WITH ALL THE LABS--IT IS CORRECT
    PLOT Y1 Y2 LAB
    TITLE THIS IS A SUBSET PLOT--IT IS NOT CORRECT
    PLOT Y1 Y2 LAB SUBSET LAB 3 TO 7
    TITLE THIS IS A SUBSET PLOT--IT IS CORRECT
    CHARACTER MAPPING EXACT
    PLOT Y1 Y2 LAB SUBSET LAB 3 TO 7
    END OF MULTIPLOT
 
-----CHARACTER OFFSET------------------------------------------------
 
CHARACTER OFFSET
 
Name:
    CHARACTER OFFSET
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the offset (i.e., displacement) of the characters to
    appear at the plot points of each trace on subsequent plots.
 
Description:
    Positive values for the horizontal offset move the plot character
    to the right while negative values move them to the left.  Positive
    values for the vertical offset move the plot character up while
    negative values move it down.
 
Syntax:
    CHARACTER OFFSET  <x offset> <y offset> <x offset> <y offset> etc.
    where <x offset> is a number or parameter in the decimal range 0 to
    100 that specifies the horizontal offset and <y offset> is a number
    or parameter in the decimal range 0 to 100 that specifies the
    vertical offset.  Up to 100 pairs of offsets can be specified.
 
Examples:
    CHARACTER OFFSET 2.0 2.0 3.0 3.0
    CHARACTER OFFSET 2.0 3.0 2.0 3.0 2.0 3.0
    CHARACTER OFFSET ALL 2.0 3.0
    CHARACTER OFFSET 2.0 3.0  ALL
    CHARACTERS OFFSET
 
Note:
    Characters are specified by trace.  All characters belonging to the
    same trace are plotted with the same plot symbol.
 
Note:
    The BAR, SPIKE, CHARACTER, and LINE switch all work independently
    of each other.  That is, a plot point can be a line, a character, a
    spike or a bar or any combination of the above.
 
Note:
    Although the CHARACTER command can be used to label plot points, be
    aware that it has some serious limitations in this regard.  The
    most important limitation is that character labels are limited to 4
    characters.  If you need more than 4 characters, you have to use
    the TEXT or LEGEND command.  However, this is more difficult since
    the coordinates are given in DATAPLOT 0 to 100 screen units rather
    than the data units.  The MOVEDATA command can be used with the
    TEXT command (MOVEDATA is an alternate version of MOVE that uses
    the coordinates from the most recent plot).
 
Note:
    The CHARACTER OFFSET command with no arguments sets the character
    offsets to default for all traces.  The CHARACTER OFFSET command
    with the word ALL before or after the specified offsets assigns
    those offsets to the characters on all traces; thus CHARACTER
    OFFSET 2.0 3.0 ALL or CHARACTER OFFSET ALL 2.0 3.0 plots characters
    2.0 units to the right and 3.0 units above their normal position
    for the characters on all traces.
 
Default:
    Characters are plotted with an offset of 0. in both directions.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
 
    CHARACTERS          = Sets the types for plot characters.
    CHARACTER ANGLE     = Sets the angles for plot characters.
    CHARACTER AUTOMATIC = Specifies a variable to be used as the
                          arguments to the CHARACTER command.
    CHARACTER CASE      = Sets the cases for plot characters.
    CHARACTERS COLORS   = Sets the colors for plot characters.
    CHARACTER FILL      = Sets the fill switches for plot characters.
    CHARACTER FONT      = Sets the fonts for plot characters.
    CHARACTER HW        = Sets the heights and widths for plot
                          characters.
    CHARACTER JUST      = Sets the justifications for plot characters.
    CHARACTERS SIZES    = Sets the sizes for plot characters.
    CHARACTER THICKNESS = Sets the thicknesses for plot characters.
    CHARACTER WIDTH     = Sets the widths for plot characters.
 
    LINES               = Sets the types for plot lines.
    SPIKES              = Sets the on/off switches for plot spikes.
    BARS                = Sets the on/off switches for plot bars.
 
Applications:
    Presentation quality graphics
 
Implementation Date:
    XX
 
Program:
    LEGEND 1 PRESENTATION GRAPHICS
    LEGEND 2 3-D BAR HISTOGRAM
    .
    LET Y = DATA 392 341 307 203 115 59 38 32 29 28
    .
    LET N = NUMBER Y
    LET X = SEQUENCE 1 1 N
    .
    LINES BLANK ALL
    BAR ON ALL
    BAR WIDTH .5 ALL
    BAR DIMENSION 3 ALL
    BAR FILL ONTS ALL
    CHARACTERS APOL SUN HP DEC SYM SG IBM DG TI XER
    CHARACTER OFFSET  2 6 ALL
    YMAX 600
    XMAX 12
    TITLE DEMONSTRATE CHARACTER OFFSET
    PLOT Y X X
 
-----CHARACTER SIZES--------------------------------------------------
 
CHARACTER SIZES
 
Name:
    CHARACTER SIZES
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the sizes of the characters to appear at the plot points
    of each trace on subsequent plots.
 
Description:
    The size is the height of the character (not counting vertical
    spacing).  The size is in decimal units of 0 to 100.  The width of
    the character is automatically set to one half the character
    height (use the CHARACTER HW command to specify the width
    independently).
 
Syntax:
    CHARACTER SIZES  <size>  <size>  <size>  etc.
    where <size> is a number or a parameter is in the decimal range 0
    to 100 that specifies the desired character size.  Up to 100
    character sizes can be specified.
 
Examples:
    CHARACTER SIZES 2 2 2.4 2.4
    CHARACTER SIZES 3 3 1 1 1 1.5
    CHARACTERS SIZES 3 ALL
    CHARACTERS SIZES ALL 3
    CHARACTERS SIZES
 
Note:
    Characters are specified by trace.  All characters belonging to the
    same trace are plotted with the same plot symbol.
 
Note:
    The BAR, SPIKE, CHARACTER, and LINE switch all work independently
    of each other.  That is, a plot point can be a line, a character, a
    spike or a bar or any combination of the above.
 
Note:
    The CHARACTER SIZES command with no arguments sets the character
    size to default for all traces.  The CHARACTER SIZES command with
    the word ALL before or after the specified size assigns that size
    to the characters on all traces; thus CHARACTER SIZES 2.5 ALL or
    CHARACTER SIZES ALL 2.5 assigns the size 2.5 to the characters on
    all traces.
 
Default:
    All character sizes are 2.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
 
    CHARACTERS          = Sets the types for plot characters.
    CHARACTER ANGLE     = Sets the angles for plot characters.
    CHARACTER AUTOMATIC = Specifies a variable to be used as the
                          arguments to the CHARACTER command.
    CHARACTER CASE      = Sets the cases for plot characters.
    CHARACTERS COLORS   = Sets the colors for plot characters.
    CHARACTER FILL      = Sets the fill switches for plot characters.
    CHARACTER FONT      = Sets the fonts for plot characters.
    CHARACTER HW        = Sets the heights and widths for plot
                          characters.
    CHARACTER JUST      = Sets the justifications for plot characters.
    CHARACTER OFFSET    = Sets the offsets for plot characters.
    CHARACTER THICKNESS = Sets the thicknesses for plot characters.
    CHARACTER WIDTH     = Sets the widths for plot characters.
 
    LINES               = Sets the types for plot lines.
    SPIKES              = Sets the on/off switches for plot spikes.
    BARS                = Sets the on/off switches for plot bars.
 
    TITLE SIZE          = Sets the size for the plot title.
    LABEL SIZE          = Sets the size for plot labels.
    LEGEND SIZE         = Sets the size for plot legends.
 
    TIC SIZE            = Sets the size of plot tic marks.
    TIC LABEL SIZE      = Sets the size for plot tic mark labels.
 
    HEIGHT              = Sets the height for TEXT characters.
    WIDTH               = Sets the width for TEXT characters.
    HW                  = Sets the height and width for TEXT
                          characters.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    . POLLUTION SOURCE ANALYSIS, LLOYD CURRIE, DATE--1990
    . SUBSET OF CURRIE.DAT REFERENCE FILE
    .
    LET ID2 = DATA 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2
    SERIAL READ LEAD
    164 426 59 98 312 263 607 497 213 54 160 262 547 325 419 94 70
    END OF DATA
    SERIAL READ POT
    106 175 61 79 94 121 424 328 107 218 140 179 246 231 245 339 99
    END OF DATA
    .
    CHARACTER CIRCLE CIRCLE SQUARE SQUARE
    CHARACTER SIZE 1.0 3.0 1.0 3.0
    LINE BLANK ALL
    LEGEND FONT SIMPLEX
    LEGEND 1 CIRC() - POTASSIUM
    LEGEND 2 SQUA() - LEAD
    .
    TITLE DEMONSTRATE CHARACTER SIZE COMMAND
    LET X = SEQUENCE 1 1 17
    PLOT POT X ID2 AND
    PLOT LEAD X ID2
 
-----CHARACTER THICKNESS-----------------------------------------------
 
CHARACTER THICKNESS
 
Name:
    CHARACTER THICKNESS
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the thicknesses of the line used to draw the characters
    to appear at the plot points of each trace on subsequent plots.
 
Description:
    This command only applies if the character is drawn with a software
    font.  It is ignored when they are drawn with hardware characters
    (i.e., the TEKTRONIX font).
 
Syntax:
    CHARACTER THICKNESS  <thick>  <thick>  <thick>  etc.
    where <thick> is a number or parameter in the decimal range 0 to
    100 that specifies the desired thickness.  Up to 100 thicknesses
    can be specified.  Values are typically between 0.1 and 0.3.
 
Examples:
    CHARACTER THICKNESS 0.1 0.2 0.3
    CHARACTER THICKNESS 0.2 0.2 0.2
    CHARACTER THICKNESS ALL 0.2
    CHARACTER THICKNESS 0.2 ALL
    CHARACTERS THICKNESS
 
Note:
    Characters are specified by trace.  All characters belonging to the
    same trace are plotted with the same plot symbol.
 
Note:
    The BAR, SPIKE, CHARACTER, and LINE switch all work independently
    of each other.  That is, a plot point can be a line, a character, a
    spike or a bar or any combination of the above.
 
Note:
    The THICKNESS command sets the default thickness for the plot.  The
    CHARACTER THICKNESS command is typically used to override the
    default thickness for the characters only.
 
Note:
    The thickness command can be used in conjunction with the font to
    produce better text.  For example, a thickness of 0.2 used with a
    simplex font can be used to generate more readable text when making
    transparencies.
 
Note:
    The CHARACTER THICKNESS command with no arguments sets the
    character thickness to default for all traces.  The CHARACTER
    THICKNESS command with the word ALL before or after the specified
    thickness assigns that thickness to the characters on all traces;
    thus CHARACTER FONT 0.2 ALL or CHARACTER FONT ALL 0.2 assigns the
    thickness 0.2 to the characters on all traces.
 
Default:
    All characters are drawn with a line thickness of 0.1.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
 
    CHARACTERS          = Sets the types for plot characters.
    CHARACTER ANGLE     = Sets the angles for plot characters.
    CHARACTER AUTOMATIC = Specifies a variable to be used as the
                          arguments to the CHARACTER command.
    CHARACTER CASE      = Sets the cases for plot characters.
    CHARACTERS COLORS   = Sets the colors for plot characters.
    CHARACTER FILL      = Sets the fill switches for plot characters.
    CHARACTER FONT      = Sets the fonts for plot characters.
    CHARACTER HW        = Sets the heights and widths for plot
                          characters.
    CHARACTER JUST      = Sets the justifications for plot characters.
    CHARACTER OFFSET    = Sets the offsets for plot characters.
    CHARACTERS SIZES    = Sets the sizes for plot characters.
    CHARACTER WIDTH     = Sets the widths for plot characters.
 
    LINES               = Sets the types for plot lines.
    SPIKES              = Sets the on/off switches for plot spikes.
    BARS                = Sets the on/off switches for plot bars.
 
    THICKNESS           = Sets all line thicknesses.
    LINE THICKNESS      = Sets the line thicknesses for plot lines.
 
Applications:
    89/2
 
Implementation Date:
    XX
 
Program:
    . POLLUTION SOURCE ANALYSIS, LLOYD CURRIE, DATE--1990
    . SUBSET OF CURRIE.DAT REFERENCE FILE
    .
    LET ID2 = DATA 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2
    SERIAL READ LEAD
    164 426 59 98 312 263 607 497 213 54 160 262 547 325 419 94 70
    END OF DATA
    SERIAL READ POT
    106 175 61 79 94 121 424 328 107 218 140 179 246 231 245 339 99
    END OF DATA
    .
    CHARACTER CIRCLE CIRCLE SQUARE SQUARE
    CHARACTER THICKNESS 0.1 0.7 0.1 0.7
    CHARACTER SIZE 3.0 2.7 3.0 2.7
    LINE BLANK ALL
    LEGEND FONT SIMPLEX
    LEGEND 1 CIRC() - POTASSIUM
    LEGEND 2 SQUA() - LEAD
    .
    TITLE DEMONSTRATE CHARACTER THICKNESS COMMAND
    LET X = SEQUENCE 1 1 17
    PLOT POT X ID2 AND
    PLOT LEAD X ID2
 
-----CHARACTER UNITS---------------------------------------------------
 
CHARACTER UNITS
 
Name:
    CHARACTER UNITS
 
Type:
    Plot Control Command
 
Purpose:
    Specifies whether the x and y coordinate positions for plot
    characters are in units of the current plot or in screeen units
    (0 to 100).

Description:
    By default, when a plot is generated the coordinates for the plot
    characters are assumed to be in units of the current plot (referred
    to as data units).

    There may be occassions where it is useful to have the coordinates
    specify screen units (i.e., 0 to 100).  This is most likely when the
    plot character is being used in a labeling context.  For example, it
    can sometimes be more efficient from a performance context to use the
    CHARACTER command rather than using a series of MOVE and TEXT commands
    to generate the labels.

    The CHARACTER UNITS command can be used to specify whether data units
    or screen units will be used.  Specifically,

        DD - data units will be used for both the x and y coordinates
        DS - data units will be used for the x coordinate and screen units
             will be used for the y coordinate
        SD - screen units will be used for the x coordinate and data units
             will be used for the y coordinate
        SS - screen units will be used for both the x and y coordinates
 
Syntax:
    CHARACTER UNITS  <val>  <val>  <val>  ...
    where <val> specifies the desired units.

    Up to 100 character unit values can be specified.
 
Examples:
    CHARACTER UNITS SD DS
    CHARACTER UNITS SD ALL
 
Note:
    This command was motivated by the desire to improve the performance
    of DEXODP.DP of the macros for the 10-step analysis of 2-level full
    and fractional factorial designs.  However, it can have utility
    outside of that application.

Note:
    Characters are specified by trace.  All characters belonging to the
    same trace are plotted using the same character units.
 
Note:
    The BAR, SPIKE, CHARACTER, and LINE switch all work independently
    of each other.  That is, a plot point can be a line, a character, a
    spike or a bar or any combination of the above.
 
Note:
    The CHARACTER UNITS command with no arguments sets the character
    units to default for all traces.  The CHARACTER UNITS command with
    the word ALL before or after the specified unit assigns that unit
    to the characters on all traces; thus CHARACTER UNIT SS ALL or
    CHARACTER UNIT ALL SS specifies screen units for both the x and y
    coordinates on all traces.

Default:
    DD for all character traces
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    CHARACTERS          = Sets the types for plot characters.
    CHARACTER ANGLE     = Sets the angles for plot characters.
    CHARACTER AUTOMATIC = Specifies a variable to be used as the
                          arguments to the CHARACTER command.
    CHARACTERS COLORS   = Sets the colors for plot characters.
    CHARACTER FILL      = Sets the fill switches for plot characters.
    CHARACTER FONT      = Sets the fonts for plot characters.
    CHARACTER HW        = Sets the heights and widths for plot
                          characters.
    CHARACTER JUST      = Sets the justifications for plot characters.
    CHARACTER OFFSET    = Sets the offsets for plot characters.
    CHARACTERS SIZES    = Sets the sizes for plot characters.
    CHARACTER THICKNESS = Sets the thicknesses for plot characters.
    CHARACTER WIDTH     = Sets the widths for plot characters.
    LINES               = Sets the types for plot lines.
    SPIKES              = Sets the on/off switches for plot spikes.
    BARS                = Sets the on/off switches for plot bars.
 
Applications:
    Presentaion Graphics
 
Implementation Date:
    2018/02
 
Program:
    . Step 1:   Read the data
    .
    dimension 200 columns
    skip 25
    read scott_8_16.dat y x1 to x8
    skip 0
    let n = size y
    .
    . Step 2:   Set plot control features
    .
    case asis
    title case asis
    label case asis
    tic mark label case asis
    .
    xlimits 1 n
    major x1tic mark number n
    minor x1tic mark number 0
    x1tic mark offset 0.5 0.5
    x1tic mark labels off
    .
    ylimits -0.75 1
    major y1tic mark number 8
    y1tic mark label decimal 2
    .
    title Ordered Dex Plot
    .
    line blank
    character circle
    character hw 1 0.75 all
    character fill on
    .
    . Step 3:   Generate the plot
    .
    set dex pareto plot order ascending
    set dex ordered plot identification on
    dex ordered plot y x1 to x8
    .
    . Step 4:   Plot the "-" and "+"
    .
    read dpst1f.dat zx zfact zcode
    let zcode = code zcode
    .
    line blank blank
    character - +
    character size 1.5 all
    .
    let zfacts = zfact
    let zfacts = 16   subset zfact = 1
    let zfacts = 14.5 subset zfact = 2
    let zfacts = 13   subset zfact = 3
    let zfacts = 11.5 subset zfact = 4
    let zfacts = 10   subset zfact = 5
    let zfacts =  8.5 subset zfact = 6
    let zfacts =  7   subset zfact = 7
    let zfacts =  5.5 subset zfact = 8
    .
    tic marks off
    tic mark labels off
    label
    title
    pre-erase off
    .
    character units ds all
    plot zfacts zx zcode
 
-----CHARACTER VARIABLE (SET)-------------------------------------------
 
CHARACTER VARIABLE (SET)
 
Name:
    CHARACTER VARIABLE (SET)
 
Type:
    Subcommand under SET
 
Purpose:
    Specify whether the READ command and the LET ... = STRING VARIABLE
    command will overwrite the contents of the "dpzchf.dat" file or
    append new character variables to the current contents of
    "dpzchf.dat".
 
Description:
    Dataplot primarily works with numeric data.  However, there is
    limited support for character variables.  Note that since character
    variables have limited use in Dataplot, they are not saved in memory
    as are numeric variables.  Instead, they are written to the file
    "dpzchf.dat".

    Dataplot has two commands for creating character variables.  If
    the SET CONVERT CHARACTER command is set to ON or CATEGORICAL, then
    the READ command will parse character variables and save them to the
    file "dpzchf.dat".  The LET ... = STRING VARIABLE command can create
    a character variable from a list of pre-defined strings (or literal
    text enclosed in quotes).  This command will also save the character
    variable to "dpzchf.dat".

    By default, either of these commands will overwrite the current
    contents of "dpzchf.dat".  However, you can request that the new
    character variables be appended to the current contents of
    "dpzchf.dat" instead.

    Typically, the append option is most likely to be used with the
    LET ... = STRING VARIABLE command.

Syntax:
    SET CHARACTER VARIABLE   <OVERWRITE/APPEND>
    where OVERWRITE specifies that the current contents of "dpzchf.dat"
    will be overwritten and APPEND specifies that the new character
    variables will be appended to the current contetns of "dpzchf.dat".
 
Examples:
    SET CHARACTER VARIABLE OVERWRITE
    SET CHARACTER VARIABLE APPEND
 
Note:
    The "dpzchf.dat" file is simply an ASCII file.  Its contents look
    something like (this is the file created in the Program example
    below)

              3
       IX               3
       IY               3
       IW               4
       Row_1                    xxxxx                    aaaa
       Row_2                    yyyyy                    bbbb
       Row_3                    zzzzz                    cccc
                                                         dddd

    The first row specifies the number of character variables in the
    file.  The next several rows identify the variable name and the
    number of rows for that character variable.  The remaining rows
    contain the contents for the character variables.  Character
    variables currently have a maximum length of 24 characters.

Default:
    OVERWRITE
 
Synonyms:
    None
 
Related Commands:
    READ             = Carries out a column-wise input of data.
    STRING VARIABLE  = Create a character variable from a list of
                       previously defined strings.
 
Applications:
    Input/Output
 
Implementation Date:
    2020/01
 
Program:
    rm dpzchf.dat
    set convert character on
    read ix iy
    Row_1   xxxxx
    Row_2   yyyyy
    Row_3   zzzzz
    end of data
    list dpzchf.dat
    pause
    .
    set character variable append
    read iw
    aaaa
    bbbb
    cccc
    dddd
    end of data
    list dpzchf.dat
 
-----CHARACTER WIDTH---------------------------------------------------
 
CHARACTER WIDTH
 
Name:
    CHARACTER WIDTH
 
Type:
    Plot Control Command
 
Purpose:
    Specifies the width of the characters to appear at the plot points
    of each trace on subsequent plots.
 
Description:
    Character sizes are normally specified by height (and the width is
    then set to one half the height).  This command is typically used
    to compensate for distortions caused by devices with unequal aspect
    ratios (e.g., circles and squares come out as ellipses and
    rectangles) and multiplots with an unequal number of rows and
    columns.
 
Syntax:
    CHARACTER WIDTH  <size>  <size>  <size>  etc.
    where <size> is a number or a parameter in the decimal range 0 to
    100 that specifies the desired width.  Up to 100 character widths
    can be specified.
 
Examples:
    CHARACTER WIDTH 2 2 2.4 2.4
    CHARACTER WIDTH 3 3 1 1 1 1.5
    CHARACTERS WIDTH 3 ALL
    CHARACTERS WIDTH ALL 3
    CHARACTERS WIDTH
 
Note:
    Characters are specified by trace.  All characters belonging to the
    same trace are plotted with the same plot symbol.
 
Note:
    The BAR, SPIKE, CHARACTER, and LINE switch all work independently
    of each other.  That is, a plot point can be a line, a character, a
    spike or a bar or any combination of the above.
 
Note:
    The CHARACTER WIDTH command with no arguments sets the character
    width to default for all traces.  The CHARACTER WIDTH command with
    the word ALL before or after the specified width assigns that width
    to the characters on all traces; thus CHARACTER WIDTH 2.5 ALL or
    CHARACTER WIDTH ALL 2.5 assigns the width 2.5 to the characters on
    all traces.
 
Default:
    The default character width is one half the character height (the
    default height is 2 so the default width is 1).
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
 
    CHARACTERS          = Sets the types for plot characters.
    CHARACTER ANGLE     = Sets the angles for plot characters.
    CHARACTER AUTOMATIC = Specifies a variable to be used as the
                          arguments to the CHARACTER command.
    CHARACTER CASE      = Sets the cases for plot characters.
    CHARACTERS COLORS   = Sets the colors for plot characters.
    CHARACTER FILL      = Sets the fill switches for plot characters.
    CHARACTER FONT      = Sets the fonts for plot characters.
    CHARACTER HW        = Sets the heights and widths for plot
                          characters.
    CHARACTER JUST      = Sets the justifications for plot characters.
    CHARACTER OFFSET    = Sets the offsets for plot characters.
    CHARACTERS SIZES    = Sets the sizes for plot characters.
    CHARACTER THICKNESS = Sets the thicknesses for plot characters.
 
    LINES               = Sets the types for plot lines.
    SPIKES              = Sets the on/off switches for plot spikes.
    BARS                = Sets the on/off switches for plot bars.
 
    TITLE SIZE          = Sets the size for the plot title.
    LABEL SIZE          = Sets the size for plot labels.
    LEGEND SIZE         = Sets the size for plot legends.
 
    TIC SIZE            = Sets the size of plot tic marks.
    TIC LABEL SIZE      = Sets the size for plot tic mark labels.
 
    HEIGHT              = Sets the height for TEXT characters.
    WIDTH               = Sets the width for TEXT characters.
    HW                  = Sets the height and width for TEXT
                          characters.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    . POLLUTION SOURCE ANALYSIS, LLOYD CURRIE, DATE--1990
    . SUBSET OF CURRIE.DAT REFERENCE FILE
    .
    LET ID2 = DATA 1 1 1 1 1 2 2 2 2 2 2 2 2 2 2 2 2
    SERIAL READ LEAD
    164 426 59 98 312 263 607 497 213 54 160 262 547 325 419 94 70
    END OF DATA
    SERIAL READ POT
    106 175 61 79 94 121 424 328 107 218 140 179 246 231 245 339 99
    END OF DATA
    .
    CHARACTER CIRCLE CIRCLE SQUARE SQUARE
    CHARACTER SIZE 1 3 1 3
    CHARACTER WIDTH .75 2.25 .75 2.25
    LINE BLANK ALL
    LEGEND FONT SIMPLEX
    LEGEND 1 CIRC() - POTASSIUM
    LEGEND 2 SQUA() - LEAD
    .
    TITLE DEMONSTRATE CHARACTER WIDTH COMMAND
    LET X = SEQUENCE 1 1 17
    PLOT POT X ID2 AND
    PLOT LEAD X ID2
 
-----CHCDF (LET)--------------------------------
 
CHCDF

Name:
    CHCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the chi cumulative distribution function with degrees of
    freedom parameter v.
 
Description:
    The distribution of the positive square root of a variable having
    a chi-square distribution is a chi-distribution.  The
    chi-distribution has the following probability density function:
       f(x,v)=EXP(-x**2)*x**(v-1)/[2**((v/2)-1)*GAMMA(v/2)]
    where GAMMA is the gamma function.  The input value and the
    degrees of freedom should both be positive real numbers.

    The cumulative distribution is the area under the curve from
    0 to x (i.e., the integral of the above function).  It has the
    formula:
       F(x,v) = GAMMAI(v/2,v**2/2)/GAMMA(v/2)       x > 0, v > 0
    where GAMMAI is the incomplete gamma function and GAMMA is the
    complete gamma function.

Syntax:
    LET <y2> = CHCDF(<y1>,<v>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a positive number, parameter, or variable;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed chi cdf value is stored;
          <v> is a positive number, parameter, or variable that 
               specifies the degrees of freedom;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CHCDF(3,10)
    LET A = CHCDF(A1,10)
    LET X2 = CHCDF(X1,10)
 
Note:
    The chi-distribution includes several distributions as special
    cases.  If v is 1, the chi-distribution reduces to the
    half-normal distribution.  If v is 2, the chi-distribution
    is a Rayleigh distribution.  If v is 3, the chi-distribution
    is a Maxwell-Boltzmann distribution.

    A generalized Rayleigh distribution is a chi-distribution with
    a scale parameter equal to 1.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHPDF  = Compute the chi probability density function.
    CHPPF  = Compute the chi percent point function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson, Kotz, and
    Balakrishnan, John Wiley and Sons, 1994, (chapter 18).
 
    "Statistical Distributions", 2nd ed., Evans, Hastings, and
    Peacock, John Wiley and Sons, 1993, (chapters 8 and 34).

Applications:
    Reliability
 
Implementation Date:
    95/4
 
Program:
    LET STRING S1 = HALF-NORMAL DISTRIBUTION
    LET STRING S2 = RAYLEIGH DISTRIBUTION
    LET STRING S3 = MAXWELL-BOTZMAN DISTRIBUTION
    LET STRING S4 = V=4
    LET STRING S5 = V=5
    LET STRING S6 = V=6
    LET STRING S7 = V=7
    LET STRING S8 = V=8
    LET STRING S9 = V=9
    MULTIPLOT 3 3; MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LOOP FOR K = 1 1 9
       X1LABEL ^S^K
       PLOT CHCDF(X,K) FOR X = 0.01 0.01 5
    END OF LOOP
    END OF MULTIPLOT
 
-----CHPDF (LET)--------------------------------
 
CHPDF

Name:
    CHPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the chi probability density function with degrees of
    freedom parameter v.
 
Description:
    The distribution of the positive square root of a variable having
    a chi-square distribution is a chi-distribution.  The
    chi-distribution has the following probability density function:
       f(x,v)=EXP(-x**2)*x**(v-1)/[2**((v/2)-1)*GAMMA(v/2)]
    where GAMMA is the gamma function.  The input value and the
    degrees of freedom should both be positive real numbers.

Syntax:
    LET <y2> = CHPDF(<y1>,<v>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a positive number, parameter, or variable;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed chi pdf value is stored;
          <v> is a positive number, parameter, or variable that 
               specifies the degrees of freedom;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CHPDF(3,10)
    LET A = CHPDF(A1,10)
    LET X2 = CHPDF(X1,10)
 
Note:
    The chi-distribution includes several distributions as special
    cases.  If v is 1, the chi-distribution reduces to the
    half-normal distribution.  If v is 2, the chi-distribution
    is a Rayleigh distribution.  If v is 3, the chi-distribution
    is a Maxwell-Boltzmann distribution.

    A generalized Rayleigh distribution is a chi-distribution with
    a scale parameter equal to 1.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHCDF  = Compute the chi cumulative distribution function.
    CHPPF  = Compute the chi percent point function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson, Kotz, and
    Balakrishnan, John Wiley and Sons, 1994, (chapter 18).
 
    "Statistical Distributions", 2nd ed., Evans, Hastings, and
    Peacock, John Wiley and Sons, 1993, (chapters 8 and 34).

Applications:
    Reliability
 
Implementation Date:
    95/4
 
Program:
    LET STRING S1 = HALF-NORMAL DISTRIBUTION
    LET STRING S2 = RAYLEIGH DISTRIBUTION
    LET STRING S3 = MAXWELL-BOTZMAN DISTRIBUTION
    LET STRING S4 = V=4
    LET STRING S5 = V=5
    LET STRING S6 = V=6
    LET STRING S7 = V=7
    LET STRING S8 = V=8
    LET STRING S9 = V=9
    MULTIPLOT 3 3; MULTIPLOT CORNER COORDINATES 0 0 100 100
    TITLE AUTOMATIC
    LOOP FOR K = 1 1 9
      	X1LABEL ^S^K
      	PLOT CHPDF(X,K) FOR X = 0.01 0.01 5
    END OF LOOP
    END OF MULTIPLOT
 
-----CHPPF (LET)--------------------------------
 
CHPPF
 
Name:
    CHPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the chi percent point function with degrees of freedom
    parameter v.
 
Description:
    The distribution of the positive square root of a variable having
    a chi-square distribution is a chi-distribution.  The
    chi-distribution has the following probability density function:
       f(x,v)=EXP(-x**2)*x**(v-1)/[2**((v/2)-1)*GAMMA(v/2)]
    where GAMMA is the gamma function.

    The percent point function is the inverse of the cumulative
    distribution function.  The cumulative distribution sums the
    probability from 0 to the given x value.  The percent point
    function takes a cumulative probability value and computes the
    corresponding x value.  The input value should be between 0 and 1
    and the degrees of freedom should be a positive real number.

Syntax:
    LET <y2> = CHPPF(<y1>,<v>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a positive number, parameter, or variable in the
               range 0 to 1;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed chi ppf value is stored;
          <v> is a positive number, parameter, or variable that 
               specifies the degrees of freedom;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CHPPF(0.9,10)
    LET A = CHPPF(A1,10)
    LET X2 = CHPPF(X1,10)
 
Note:
    The chi-distribution includes several distributions as special
    cases.  If v is 1, the chi-distribution reduces to the
    half-normal distribution.  If v is 2, the chi-distribution
    is a Rayleigh distribution.  If v is 3, the chi-distribution
    is a Maxwell-Boltzmann distribution.

    A generalized Rayleigh distribution is a chi-distribution with
    a scale parameter equal to 1.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHCDF  = Compute the chi cumulative distribution function.
    CHPDF  = Compute the chi probability density function.
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson, Kotz, and
    Balakrishnan, John Wiley and Sons, 1994, (chapter 18).
 
    "Statistical Distributions", 2nd ed., Evans, Hastings, and
    Peacock, John Wiley and Sons, 1993, (chapters 8 and 34).

Applications:
    Reliability
 
Implementation Date:
    95/4
 
Program:
    LET STRING S1 = HALF-NORMAL DISTRIBUTION
    LET STRING S2 = RAYLEIGH DISTRIBUTION
    LET STRING S3 = MAXWELL-BOTZMAN DISTRIBUTION
    LET STRING S4 = V=4
    LET STRING S5 = V=5
    LET STRING S6 = V=6
    LET STRING S7 = V=7
    LET STRING S8 = V=8
    LET STRING S9 = V=9
    TITLE AUTOMATIC
    .
    MULTIPLOT 3 3
    LOOP FOR K = 1 1 9
       X1LABEL ^S^K
       PLOT CHPPF(P,K) FOR P = 0.01 0.01 0.99
    END OF LOOP
    END OF MULTIPLOT
 
-----CHEBT (LET)--------------------------------
 
CHEBT
 
Name:
    CHEBT (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Chebychev polynomial of the first kind and order N.
 
Description:
    From Abramowitz and Stegum (see Reference below), a system of
    nth degree polynomials f(x,n) is called orthogonal on the
    interval a<=x<=b with respect to a weight function w(x) if it
    satisfies the equation:
        INTEGRAL[w(x)*f(x,n)*f(x,m)]dx = 0   m<>n, (m,n = 0, 1, 2, ...

    Chebychev polynomials of the first kind use the weight function
    (1-x**2)**(-1/2) and are orthogonal for the interval -1 to 1.
    Chebychev polynomials of the first kind can also be are defined by
    the following equation:
        Tn(x) = COS(n*ARCCOS(x))

    DATAPLOT calculates the  Chebychev polynomials using the following
    recurrence relation:
        T(x,n) = 2*x*T(x,n-1)-T(x,n-2)
    where the first few terms for the recuurence were obtained from
    the Handbook of Mathematical Functions (see the REFERENCE below).
 
Syntax:
    LET <y> = CHEBT(<x>,<n>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable in the range (-1,1);
          <n> is a non-negative integer number, parameter, or variable
              that specifies the order of the Chebychev polynomial;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed Chebychev polynomial value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CHEBT(-1,4)
    LET X2 = CHEBT(X1,10)
    LET X2 = CHEBT(X1-0.2,N)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHEBU    = Compute Chebychev polynomial second kind, order N.
    CHEB0    = Compute Chebychev polynomial first kind, order 0.
    CHEB1    = Compute Chebychev polynomial first kind, order 1.
    CHEB2    = Compute Chebychev polynomial first kind, order 2.
    CHEB3    = Compute Chebychev polynomial first kind, order 3.
    CHEB4    = Compute Chebychev polynomial first kind, order 4.
    CHEB5    = Compute Chebychev polynomial first kind, order 5.
    CHEB6    = Compute Chebychev polynomial first kind, order 6.
    CHEB7    = Compute Chebychev polynomial first kind, order 7.
    CHEB8    = Compute Chebychev polynomial first kind, order 8.
    CHEB9    = Compute Chebychev polynomial first kind, order 9.
    CHEB10   = Compute Chebychev polynomial first kind, order 10.
    HERMITE  = Compute Hermite polynomial of order N.
    JACOBIP  = Compute Jacobi polynomial of order N.
    LAGUERRE = Compute Laguerre polynomial of order N.
    ULTRASPH = Compute ultrasperical polynomial of order N.
    LEGENDRE = Compute Legendre polynomial of order N.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 22).
 
Applications:
    Function approximation
 
Implementation Date:
    95/7
 
Program:
    XLIMITS -1 1; XTIC OFFSET 0.1 0.1
    YLIMITS -1 1; YTIC OFFSET 0.1 0.1
    LABEL CASE ASIS
    TITLE AUTOMATIC
    Y1LABEL Tn(X)
    X1LABEL X
    MULTIPLOT 2 2;;MULTIPLOT CORNER COORDINATES 0 0 100 100
    PLOT CHEBT(X,4) FOR X = -1 0.01 1
    PLOT CHEBT(X,10) FOR X = -1 0.01 1
    PLOT CHEBT(X,20) FOR X = -1 0.01 1
    PLOT CHEBT(X,50) FOR X = -1 0.01 1
    END OF MULTIPLOT
 
-----CHEBU (LET)--------------------------------
 
CHEBU
 
Name:
    CHEBU (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Chebychev polynomial of the second kind and order N.
 
Description:
    From Abramowitz and Stegum (see Reference below), a system of
    nth degree polynomials f(x,n) is called orthogonal on the
    interval a<=x<=b with respect to a weight function w(x) if it
    satisfies the equation:
        INTEGRAL[w(x)*f(x,n)*f(x,m)]dx = 0   m<>n, (m,n = 0, 1, 2, ...

    Chebychev polynomials of the second kind use the weight function
    (1-x**2)**(-1/2) and are orthogonal for the interval -1 to 1.
    Chebychev polynomials of the second kind can also be are defined by
    the following equation:
        Un(x) = SIN((n+1)*ARCCOS(x))/SIN(ARCCOS(x))     -1 < x < 1

    DATAPLOT calculates the  Chebychev polynomials using the following
    recurrence relation:
        U(x,n) = 2*x*T(x,x-1)-T(x,n-2)
    where the first few terms for the recuurence were obtained from
    the Handbook of Mathematical Functions (see the REFERENCE below).
 
Syntax:
    LET <y> = CHEBU(<x>,<n>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a number, parameter, or variable in the range (-1,1);
          <n> is a non-negative integer number, parameter, or variable
              that specifies the order of the Chebychev polynomial;
          <y> is a variable or a parameter (depending on what <x> is)
              where the computed Chebychev polynomial value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CHEBU(-1,4)
    LET X2 = CHEBU(X1,10)
    LET X2 = CHEBU(X1-0.2,N)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHEBT    = Compute Chebychev polynomial first kind, order N.
    CHEB0    = Compute Chebychev polynomial first kind, order 0.
    CHEB1    = Compute Chebychev polynomial first kind, order 1.
    CHEB2    = Compute Chebychev polynomial first kind, order 2.
    CHEB3    = Compute Chebychev polynomial first kind, order 3.
    CHEB4    = Compute Chebychev polynomial first kind, order 4.
    CHEB5    = Compute Chebychev polynomial first kind, order 5.
    CHEB6    = Compute Chebychev polynomial first kind, order 6.
    CHEB7    = Compute Chebychev polynomial first kind, order 7.
    CHEB8    = Compute Chebychev polynomial first kind, order 8.
    CHEB9    = Compute Chebychev polynomial first kind, order 9.
    CHEB10   = Compute Chebychev polynomial first kind, order 10.
    HERMITE  = Compute Hermite polynomial of order N.
    JACOBIP  = Compute Jacobi polynomial of order N.
    LAGUERRE = Compute Laguerre polynomial of order N.
    ULTRASPH = Compute ultrasperical polynomial of order N.
    LEGENDRE = Compute Legendre polynomial of order N.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 22).
 
Applications:
    Function approximation
 
Implementation Date:
    95/7
 
Program:
    XLIMITS -1 1; XTIC OFFSET 0.1 0.1
    YLIMITS -1 1; YTIC OFFSET 0.1 0.1
    LABEL CASE ASIS
    TITLE AUTOMATIC
    Y1LABEL Tn(X)
    X1LABEL X
    MULTIPLOT 2 2;;MULTIPLOT CORNER COORDINATES 0 0 100 100
    PLOT CHEBU(X,4) FOR X = -1 0.01 1
    PLOT CHEBU(X,10) FOR X = -1 0.01 1
    PLOT CHEBU(X,20) FOR X = -1 0.01 1
    PLOT CHEBU(X,50) FOR X = -1 0.01 1
    END OF MULTIPLOT
 
-----CHEBYSHEV DISTANCE (LET)-------------------------------------

CHEBYSHEV DISTANCE

Name:
    CHEBYSHEV DISTANCE (LET)

Type:
    Let Subcommand

Purpose:
    Compute the Chebyshev distance between two variables.

Description:
    The Chebyshev distance between two variabes X and Y is
    defined as

        d = MAX[i=1 to n][|X(i) - Y(i)|]

Syntax:
    LET <par> = CHEBYSHEV DISTANCE <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Chebyshev distance
              is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Examples:
    LET A = CHEBYSHEV DISTANCE Y1 Y2
    LET A = CHEBYSHEV DISTANCE Y1 Y2  SUBSET Y1 > 0 SUBSET Y2 > 0

Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COSINE DISTANCE         = Compute the cosine distance.
    MANHATTAN DISTANCE      = Compute the Euclidean distance.
    EUCLIDEAN DISTANCE      = Compute the Euclidean distance.
    MATRIX DISTANCE         = Compute various distance metrics for
                              a matrix.
    GENERATE MATRIX <stat>  = Compute a matrix of pairwise statistic
                              values.

Applications:
    Mathematics
 
Implementation Date:
    2017/08
 
Program 1:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET DIST  = CHEBYSHEV DISTANCE Y1 Y2
    SET WRITE DECIMALS 4
    TABULATE CHEBYSHEV DISTANCE Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    LET NDIST = UNIQUE X
    XLIMITS 1 NDIST
    MAJOR X1TIC MARK NUMBER NDIST
    MINOR X1TIC MARK NUMBER 0
    CHAR X
    LINE BLANK
    LABEL CASE ASIS
    CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    TITLE Chebyshev Distance (IRIS.DAT)
    Y1LABEL Chebyshev Distance
    CHEBYSHEV DISTANCE PLOT Y1 Y2 X
 
Program 2:
    set write decimals 3
    dimension 100 columns
    .
    skip 25
    read iris.dat y1 y2 y3 y4
    skip 0
    .
    let z = generate matrix chebyshev distance y1 y2 y3 y4
    print z

-----CHEB0 (LET)--------------------------------
 
CHEB0
 
Name:
    CHEB0 (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Chebychev polynomial of the first kind and order 0.
 
Description:
    Chebychev polynomials belong to the family of orthogonal
    polynomials and are defined by the following equation (the value
    of n specifies the order):
        Tn(x) = cos(n*arccos(x))
    In practice, Chebychev polynomials are calculated from the
    following series approximation:
        Cn(x) = SUM CmX**n
    where the summation goes from m = 0 to n.  The Cm coefficients are
    tabulated on page 797 of the Handbook of Mathematical Functions
    (see the REFERENCE below).  DATAPLOT uses these tabulated
    coefficients to compute the Chebychev polynomial for a given value
    of x.
 
Syntax:
    LET <y2> = CHEB0(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed Chebychev polynomial value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CHEB0(-2)
    LET A = CHEB0(A1)
    LET X2 = CHEB0(X1)
    LET X2 = CHEB0(X1-4)
 
Note:
    For order 0 (i.e., n=0), T0(x) = cos(0) = 1.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHEB1  = Compute Chebychev polynomial first kind, order 1.
    CHEB2  = Compute Chebychev polynomial first kind, order 2.
    CHEB3  = Compute Chebychev polynomial first kind, order 3.
    CHEB4  = Compute Chebychev polynomial first kind, order 4.
    CHEB5  = Compute Chebychev polynomial first kind, order 5.
    CHEB6  = Compute Chebychev polynomial first kind, order 6.
    CHEB7  = Compute Chebychev polynomial first kind, order 7.
    CHEB8  = Compute Chebychev polynomial first kind, order 8.
    CHEB9  = Compute Chebychev polynomial first kind, order 9.
    CHEB10 = Compute Chebychev polynomial first kind, order 10.
 
Reference:
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", Press, Flannery, Teukolsky, and Vetterling.  Cambridge
    University Press, 1989 (pages 147-151).
 
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 22).
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XLIMITS -1 1; XTIC OFFSET 0.1 0.1
    YLIMITS -1 1; YTIC OFFSET 0.1 0.1
    TITLE CHEBYCHEV POLYNOMIALS (ORDERS 0 TO 2)
    LINES SOLID DASH DASH
    PLOT CHEB0(X) FOR X = -1 .05 1 AND
    PLOT CHEB1(X) FOR X = -1 .05 1 AND
    PLOT CHEB2(X) FOR X = -1 .05 1
 
-----CHEB1 (LET)--------------------------------
 
CHEB1
 
Name:
    CHEB1 (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Chebychev polynomial of the first kind and order 1.
 
Description:
    Chebychev polynomials belong to the family of orthogonal
    polynomials and are defined by the following equation (the value
    of n specifies the order):
        Tn(x) = cos(n*arccos(x))
    In practice, Chebychev polynomials are calculated from the
    following series approximation:
        Cn(x) = SUM CmX**n
    where the summation goes from m = 0 to n.  The Cm coefficients are
    tabulated on page 797 of the Handbook of Mathematical Functions
    (see the REFERENCE below).  DATAPLOT uses these tabulated
    coefficients to compute the Chebychev polynomial for a given value
    of x.
 
Syntax:
    LET <y2> = CHEB1(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed Chebychev polynomial value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CHEB1(-2)
    LET A = CHEB1(A1)
    LET X2 = CHEB1(X1)
    LET X2 = CHEB1(X1-4)
 
Note:
    For order 1 (i.e., n = 1), T1(x) = cos(arccos(x)) = x.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHEB0  = Compute Chebychev polynomial first kind, order 0.
    CHEB2  = Compute Chebychev polynomial first kind, order 2.
    CHEB3  = Compute Chebychev polynomial first kind, order 3.
    CHEB4  = Compute Chebychev polynomial first kind, order 4.
    CHEB5  = Compute Chebychev polynomial first kind, order 5.
    CHEB6  = Compute Chebychev polynomial first kind, order 6.
    CHEB7  = Compute Chebychev polynomial first kind, order 7.
    CHEB8  = Compute Chebychev polynomial first kind, order 8.
    CHEB9  = Compute Chebychev polynomial first kind, order 9.
    CHEB10 = Compute Chebychev polynomial first kind, order 10.
 
Reference:
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", Press, Flannery, Teukolsky, and Vetterling.  Cambridge
    University Press, 1989 (pages 147-151).
 
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 22).
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XLIMITS -1 1; XTIC OFFSET 0.1 0.1
    YLIMITS -1 1; YTIC OFFSET 0.1 0.1
    TITLE CHEBYCHEV POLYNOMIALS (ORDERS 0 TO 2)
    LINES DASH SOLID DASH
    PLOT CHEB0(X) FOR X = -1 .05 1 AND
    PLOT CHEB1(X) FOR X = -1 .05 1 AND
    PLOT CHEB2(X) FOR X = -1 .05 1
 
-----CHEB2 (LET)--------------------------------
 
CHEB2
 
Name:
    CHEB2 (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Chebychev polynomial of the first kind and order 2.
 
Description:
    Chebychev polynomials belong to the family of orthogonal
    polynomials and are defined by the following equation (the value
    of n specifies the order):
        Tn(x) = cos(n*arccos(x))
    In practice, Chebychev polynomials are calculated from the
    following series approximation:
        Cn(x) = SUM CmX**n
    where the summation goes from m = 0 to n.  The Cm coefficients are
    tabulated on page 797 of the Handbook of Mathematical Functions
    (see the REFERENCE below).  DATAPLOT uses these tabulated
    coefficients to compute the Chebychev polynomial for a given value
    of x.
 
Syntax:
    LET <y2> = CHEB2(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed Chebychev polynomial value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CHEB2(-2)
    LET A = CHEB2(A1)
    LET X2 = CHEB2(X1)
    LET X2 = CHEB2(X1-4)
 
Note:
    For order 2 (i.e., n = 2), T2(x) = cos(2arccos(x)) = 2x**2 - 1.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHEB0  = Compute Chebychev polynomial first kind, order 0.
    CHEB1  = Compute Chebychev polynomial first kind, order 1.
    CHEB3  = Compute Chebychev polynomial first kind, order 3.
    CHEB4  = Compute Chebychev polynomial first kind, order 4.
    CHEB5  = Compute Chebychev polynomial first kind, order 5.
    CHEB6  = Compute Chebychev polynomial first kind, order 6.
    CHEB7  = Compute Chebychev polynomial first kind, order 7.
    CHEB8  = Compute Chebychev polynomial first kind, order 8.
    CHEB9  = Compute Chebychev polynomial first kind, order 9.
    CHEB10 = Compute Chebychev polynomial first kind, order 10.
 
Reference:
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", Press, Flannery, Teukolsky, and Vetterling.  Cambridge
    University Press, 1989 (pages 147-151).
 
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 22).
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XLIMITS -1 1; XTIC OFFSET 0.1 0.1
    YLIMITS -1 1; YTIC OFFSET 0.1 0.1
    TITLE CHEBYCHEV POLYNOMIALS (ORDERS 1 TO 3)
    LINES DASH SOLID DASH
    PLOT CHEB1(X) FOR X = -1 .05 1 AND
    PLOT CHEB2(X) FOR X = -1 .05 1 AND
    PLOT CHEB3(X) FOR X = -1 .05 1
 
-----CHEB3 (LET)--------------------------------
 
CHEB3
 
Name:
    CHEB3 (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Chebychev polynomial of the first kind and order 3.
 
Description:
    Chebychev polynomials belong to the family of orthogonal
    polynomials and are defined by the following equation (the value
    of n specifies the order):
        Tn(x) = cos(n*arccos(x))
    In practice, Chebychev polynomials are calculated from the
    following series approximation:
        Cn(x) = SUM CmX**n
    where the summation goes from m = 0 to n.  The Cm coefficients are
    tabulated on page 797 of the Handbook of Mathematical Functions
    (see the REFERENCE below).  DATAPLOT uses these tabulated
    coefficients to compute the Chebychev polynomial for a given value
    of x.
 
Syntax:
    LET <y2> = CHEB3(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed Chebychev polynomial value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CHEB3(-2)
    LET A = CHEB3(A1)
    LET X2 = CHEB3(X1)
    LET X2 = CHEB3(X1-4)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHEB0  = Compute Chebychev polynomial first kind, order 0.
    CHEB1  = Compute Chebychev polynomial first kind, order 1.
    CHEB2  = Compute Chebychev polynomial first kind, order 2.
    CHEB4  = Compute Chebychev polynomial first kind, order 4.
    CHEB5  = Compute Chebychev polynomial first kind, order 5.
    CHEB6  = Compute Chebychev polynomial first kind, order 6.
    CHEB7  = Compute Chebychev polynomial first kind, order 7.
    CHEB8  = Compute Chebychev polynomial first kind, order 8.
    CHEB9  = Compute Chebychev polynomial first kind, order 9.
    CHEB10 = Compute Chebychev polynomial first kind, order 10.
 
Reference:
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", Press, Flannery, Teukolsky, and Vetterling.  Cambridge
    University Press, 1989 (pages 147-151).
 
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 22).
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XLIMITS -1 1; XTIC OFFSET 0.1 0.1
    YLIMITS -1 1; YTIC OFFSET 0.1 0.1
    TITLE CHEBYCHEV POLYNOMIALS (ORDERS 2 TO 4)
    LINES DASH SOLID DASH
    PLOT CHEB2(X) FOR X = -1 .05 1 AND
    PLOT CHEB3(X) FOR X = -1 .05 1 AND
    PLOT CHEB4(X) FOR X = -1 .05 1
 
-----CHEB4 (LET)--------------------------------
 
CHEB4
 
Name:
    CHEB4 (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Chebychev polynomial of the first kind and order 4.
 
Description:
    Chebychev polynomials belong to the family of orthogonal
    polynomials and are defined by the following equation (the value
    of n specifies the order):
        Tn(x) = cos(n*arccos(x))
    In practice, Chebychev polynomials are calculated from the
    following series approximation:
        Cn(x) = SUM CmX**n
    where the summation goes from m = 0 to n.  The Cm coefficients are
    tabulated on page 797 of the Handbook of Mathematical Functions
    (see the REFERENCE below).  DATAPLOT uses these tabulated
    coefficients to compute the Chebychev polynomial for a given value
    of x.
 
Syntax:
    LET <y2> = CHEB4(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed Chebychev polynomial value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CHEB4(-2)
    LET A = CHEB4(A1)
    LET X2 = CHEB4(X1)
    LET X2 = CHEB4(X1-4)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHEB0  = Compute Chebychev polynomial first kind, order 0.
    CHEB1  = Compute Chebychev polynomial first kind, order 1.
    CHEB2  = Compute Chebychev polynomial first kind, order 2.
    CHEB3  = Compute Chebychev polynomial first kind, order 3.
    CHEB5  = Compute Chebychev polynomial first kind, order 5.
    CHEB6  = Compute Chebychev polynomial first kind, order 6.
    CHEB7  = Compute Chebychev polynomial first kind, order 7.
    CHEB8  = Compute Chebychev polynomial first kind, order 8.
    CHEB9  = Compute Chebychev polynomial first kind, order 9.
    CHEB10 = Compute Chebychev polynomial first kind, order 10.
 
Reference:
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", Press, Flannery, Teukolsky, and Vetterling.  Cambridge
    University Press, 1989 (pages 147-151).
 
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 22).
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XLIMITS -1 1; XTIC OFFSET 0.1 0.1
    YLIMITS -1 1; YTIC OFFSET 0.1 0.1
    TITLE CHEBYCHEV POLYNOMIALS (ORDERS 3 TO 5)
    LINES DASH SOLID DASH
    PLOT CHEB3(X) FOR X = -1 .05 1 AND
    PLOT CHEB4(X) FOR X = -1 .05 1 AND
    PLOT CHEB5(X) FOR X = -1 .05 1
 
-----CHEB5 (LET)--------------------------------
 
CHEB5
 
Name:
    CHEB5 (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Chebychev polynomial of the first kind and order 5.
 
Description:
    Chebychev polynomials belong to the family of orthogonal
    polynomials and are defined by the following equation (the value
    of n specifies the order):
        Tn(x) = cos(n*arccos(x))
    In practice, Chebychev polynomials are calculated from the
    following series approximation:
        Cn(x) = SUM CmX**n
    where the summation goes from m = 0 to n.  The Cm coefficients are
    tabulated on page 797 of the Handbook of Mathematical Functions
    (see the REFERENCE below).  DATAPLOT uses these tabulated
    coefficients to compute the Chebychev polynomial for a given value
    of x.
 
Syntax:
    LET <y2> = CHEB5(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed Chebychev polynomial value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CHEB5(-2)
    LET A = CHEB5(A1)
    LET X2 = CHEB5(X1)
    LET X2 = CHEB5(X1-4)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHEB0  = Compute Chebychev polynomial first kind, order 0.
    CHEB1  = Compute Chebychev polynomial first kind, order 1.
    CHEB2  = Compute Chebychev polynomial first kind, order 2.
    CHEB3  = Compute Chebychev polynomial first kind, order 3.
    CHEB4  = Compute Chebychev polynomial first kind, order 4.
    CHEB6  = Compute Chebychev polynomial first kind, order 6.
    CHEB7  = Compute Chebychev polynomial first kind, order 7.
    CHEB8  = Compute Chebychev polynomial first kind, order 8.
    CHEB9  = Compute Chebychev polynomial first kind, order 9.
    CHEB10 = Compute Chebychev polynomial first kind, order 10.
 
Reference:
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", Press, Flannery, Teukolsky, and Vetterling.  Cambridge
    University Press, 1989 (pages 147-151).
 
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 22).
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XLIMITS -1 1; XTIC OFFSET 0.1 0.1
    YLIMITS -1 1; YTIC OFFSET 0.1 0.1
    TITLE CHEBYCHEV POLYNOMIALS (ORDERS 4 TO 6)
    LINES DASH SOLID DASH
    PLOT CHEB4(X) FOR X = -1 .05 1 AND
    PLOT CHEB5(X) FOR X = -1 .05 1 AND
    PLOT CHEB6(X) FOR X = -1 .05 1
 
-----CHEB6 (LET)--------------------------------
 
CHEB6
 
Name:
    CHEB6 (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Chebychev polynomial of the first kind and order 6.
 
Description:
    Chebychev polynomials belong to the family of orthogonal
    polynomials and are defined by the following equation (the value
    of n specifies the order):
        Tn(x) = cos(n*arccos(x))
    In practice, Chebychev polynomials are calculated from the
    following series approximation:
        Cn(x) = SUM CmX**n
    where the summation goes from m = 0 to n.  The Cm coefficients are
    tabulated on page 797 of the Handbook of Mathematical Functions
    (see the REFERENCE below).  DATAPLOT uses these tabulated
    coefficients to compute the Chebychev polynomial for a given value
    of x.
 
Syntax:
    LET <y2> = CHEB6(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed Chebychev polynomial value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CHEB6(-2)
    LET A = CHEB6(A1)
    LET X2 = CHEB6(X1)
    LET X2 = CHEB6(X1-4)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHEB0  = Compute Chebychev polynomial first kind, order 0.
    CHEB1  = Compute Chebychev polynomial first kind, order 1.
    CHEB2  = Compute Chebychev polynomial first kind, order 2.
    CHEB3  = Compute Chebychev polynomial first kind, order 3.
    CHEB4  = Compute Chebychev polynomial first kind, order 4.
    CHEB5  = Compute Chebychev polynomial first kind, order 5.
    CHEB7  = Compute Chebychev polynomial first kind, order 7.
    CHEB8  = Compute Chebychev polynomial first kind, order 8.
    CHEB9  = Compute Chebychev polynomial first kind, order 9.
    CHEB10 = Compute Chebychev polynomial first kind, order 10.
 
Reference:
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", Press, Flannery, Teukolsky, and Vetterling.  Cambridge
    University Press, 1989 (pages 147-151).
 
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 22).
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XLIMITS -1 1; XTIC OFFSET 0.1 0.1
    YLIMITS -1 1; YTIC OFFSET 0.1 0.1
    TITLE CHEBYCHEV POLYNOMIALS (ORDERS 5 TO 7)
    LINES DASH SOLID DASH
    PLOT CHEB5(X) FOR X = -1 .05 1 AND
    PLOT CHEB6(X) FOR X = -1 .05 1 AND
    PLOT CHEB7(X) FOR X = -1 .05 1
 
-----CHEB7 (LET)--------------------------------
 
CHEB7
 
Name:
    CHEB7 (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Chebychev polynomial of the first kind and order 7.
 
Description:
    Chebychev polynomials belong to the family of orthogonal
    polynomials and are defined by the following equation (the value
    of n specifies the order):
        Tn(x) = cos(n*arccos(x))
    In practice, Chebychev polynomials are calculated from the
    following series approximation:
        Cn(x) = SUM CmX**n
    where the summation goes from m = 0 to n.  The Cm coefficients are
    tabulated on page 797 of the Handbook of Mathematical Functions
    (see the REFERENCE below).  DATAPLOT uses these tabulated
    coefficients to compute the Chebychev polynomial for a given value
    of x.
 
Syntax:
    LET <y2> = CHEB7(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed Chebychev polynomial value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CHEB7(-2)
    LET A = CHEB7(A1)
    LET X2 = CHEB7(X1)
    LET X2 = CHEB7(X1-4)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHEB0  = Compute Chebychev polynomial first kind, order 0.
    CHEB1  = Compute Chebychev polynomial first kind, order 1.
    CHEB2  = Compute Chebychev polynomial first kind, order 2.
    CHEB3  = Compute Chebychev polynomial first kind, order 3.
    CHEB4  = Compute Chebychev polynomial first kind, order 4.
    CHEB5  = Compute Chebychev polynomial first kind, order 5.
    CHEB6  = Compute Chebychev polynomial first kind, order 6.
    CHEB8  = Compute Chebychev polynomial first kind, order 8.
    CHEB9  = Compute Chebychev polynomial first kind, order 9.
    CHEB10 = Compute Chebychev polynomial first kind, order 10.
 
Reference:
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", Press, Flannery, Teukolsky, and Vetterling.  Cambridge
    University Press, 1989 (pages 147-151).
 
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 22).
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XLIMITS -1 1; XTIC OFFSET 0.1 0.1
    YLIMITS -1 1; YTIC OFFSET 0.1 0.1
    TITLE CHEBYCHEV POLYNOMIALS (ORDERS 6 TO 8)
    LINES DASH SOLID DASH
    PLOT CHEB6(X) FOR X = -1 .05 1 AND
    PLOT CHEB7(X) FOR X = -1 .05 1 AND
    PLOT CHEB8(X) FOR X = -1 .05 1
 
-----CHEB8 (LET)--------------------------------
 
CHEB8
 
Name:
    CHEB8 (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Chebychev polynomial of the first kind and order 8.
 
Description:
    Chebychev polynomials belong to the family of orthogonal
    polynomials and are defined by the following equation (the value
    of n specifies the order):
        Tn(x) = cos(n*arccos(x))
    In practice, Chebychev polynomials are calculated from the
    following series approximation:
        Cn(x) = SUM CmX**n
    where the summation goes from m = 0 to n.  The Cm coefficients are
    tabulated on page 797 of the Handbook of Mathematical Functions
    (see the REFERENCE below).  DATAPLOT uses these tabulated
    coefficients to compute the Chebychev polynomial for a given value
    of x.
 
Syntax:
    LET <y2> = CHEB8(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed Chebychev polynomial value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CHEB8(-2)
    LET A = CHEB8(A1)
    LET X2 = CHEB8(X1)
    LET X2 = CHEB8(X1-4)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHEB0  = Compute Chebychev polynomial first kind, order 0.
    CHEB1  = Compute Chebychev polynomial first kind, order 1.
    CHEB2  = Compute Chebychev polynomial first kind, order 2.
    CHEB3  = Compute Chebychev polynomial first kind, order 3.
    CHEB4  = Compute Chebychev polynomial first kind, order 4.
    CHEB5  = Compute Chebychev polynomial first kind, order 5.
    CHEB6  = Compute Chebychev polynomial first kind, order 6.
    CHEB7  = Compute Chebychev polynomial first kind, order 7.
    CHEB9  = Compute Chebychev polynomial first kind, order 9.
    CHEB10 = Compute Chebychev polynomial first kind, order 10.
 
Reference:
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", Press, Flannery, Teukolsky, and Vetterling.  Cambridge
    University Press, 1989 (pages 147-151).
 
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 22).
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XLIMITS -1 1; XTIC OFFSET 0.1 0.1
    YLIMITS -1 1; YTIC OFFSET 0.1 0.1
    TITLE CHEBYCHEV POLYNOMIALS (ORDERS 7 TO 9)
    LINES DASH SOLID DASH
    PLOT CHEB7(X) FOR X = -1 .05 1 AND
    PLOT CHEB8(X) FOR X = -1 .05 1 AND
    PLOT CHEB9(X) FOR X = -1 .05 1
 
-----CHEB9 (LET)--------------------------------
 
CHEB9
 
Name:
    CHEB9 (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Chebychev polynomial of the first kind and order 9.
 
Description:
    Chebychev polynomials belong to the family of orthogonal
    polynomials and are defined by the following equation (the value
    of n specifies the order):
        Tn(x) = cos(n*arccos(x))
    In practice, Chebychev polynomials are calculated from the
    following series approximation:
        Cn(x) = SUM CmX**n
    where the summation goes from m = 0 to n.  The Cm coefficients are
    tabulated on page 797 of the Handbook of Mathematical Functions
    (see the REFERENCE below).  DATAPLOT uses these tabulated
    coefficients to compute the Chebychev polynomial for a given value
    of x.
 
Syntax:
    LET <y2> = CHEB9(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed Chebychev polynomial value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CHEB9(-2)
    LET A = CHEB9(A1)
    LET X2 = CHEB9(X1)
    LET X2 = CHEB9(X1-4)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHEB0  = Compute Chebychev polynomial first kind, order 0.
    CHEB1  = Compute Chebychev polynomial first kind, order 1.
    CHEB2  = Compute Chebychev polynomial first kind, order 2.
    CHEB3  = Compute Chebychev polynomial first kind, order 3.
    CHEB4  = Compute Chebychev polynomial first kind, order 4.
    CHEB5  = Compute Chebychev polynomial first kind, order 5.
    CHEB6  = Compute Chebychev polynomial first kind, order 6.
    CHEB7  = Compute Chebychev polynomial first kind, order 7.
    CHEB8  = Compute Chebychev polynomial first kind, order 8.
    CHEB10 = Compute Chebychev polynomial first kind, order 10.
 
Reference:
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", Press, Flannery, Teukolsky, and Vetterling.  Cambridge
    University Press, 1989 (pages 147-151).
 
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 22).
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XLIMITS -1 1; XTIC OFFSET 0.1 0.1
    YLIMITS -1 1; YTIC OFFSET 0.1 0.1
    TITLE CHEBYCHEV POLYNOMIALS (ORDERS 8 TO 10)
    LINES DASH SOLID DASH
    PLOT CHEB8(X) FOR X = -1 .05 1 AND
    PLOT CHEB9(X) FOR X = -1 .05 1 AND
    PLOT CHEB10(X) FOR X = -1 .05 1
 
-----CHEB10 (LET)--------------------------------
 
CHEB10
 
Name:
    CHEB10 (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Chebychev polynomial of the first kind and order 10.
 
Description:
    Chebychev polynomials belong to the family of orthogonal
    polynomials and are defined by the following equation (the value
    of n specifies the order):
        Tn(x) = cos(n*arccos(x))
    In practice, Chebychev polynomials are calculated from the
    following series approximation:
        Cn(x) = SUM CmX**n
    where the summation goes from m = 0 to n.  The Cm coefficients are
    tabulated on page 797 of the Handbook of Mathematical Functions
    (see the REFERENCE below).  DATAPLOT uses these tabulated
    coefficients to compute the Chebychev polynomial for a given value
    of x.
 
Syntax:
    LET <y2> = CHEB10(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed Chebychev polynomial value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CHEB10(-2)
    LET A = CHEB10(A1)
    LET X2 = CHEB10(X1)
    LET X2 = CHEB10(X1-4)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHEB0  = Compute Chebychev polynomial first kind, order 0.
    CHEB1  = Compute Chebychev polynomial first kind, order 1.
    CHEB2  = Compute Chebychev polynomial first kind, order 2.
    CHEB3  = Compute Chebychev polynomial first kind, order 3.
    CHEB4  = Compute Chebychev polynomial first kind, order 4.
    CHEB5  = Compute Chebychev polynomial first kind, order 5.
    CHEB6  = Compute Chebychev polynomial first kind, order 6.
    CHEB7  = Compute Chebychev polynomial first kind, order 7.
    CHEB8  = Compute Chebychev polynomial first kind, order 8.
    CHEB9  = Compute Chebychev polynomial first kind, order 9.
 
Reference:
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", Press, Flannery, Teukolsky, and Vetterling.  Cambridge
    University Press, 1989 (pages 147-151).
 
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 22).
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XLIMITS -1 1; XTIC OFFSET 0.1 0.1
    YLIMITS -1 1; YTIC OFFSET 0.1 0.1
    TITLE CHEBYCHEV POLYNOMIALS (ORDERS 8 TO 10)
    LINES DASH DASH SOLID
    PLOT CHEB8(X) FOR X = -1 .05 1 AND
    PLOT CHEB9(X) FOR X = -1 .05 1 AND
    PLOT CHEB10(X) FOR X = -1 .05 1
 
-----CHECK EQUAL LENGTH----------------------------------
 
CHECK EQUAL LENGTH
 
Name:
    CHECK EQUAL LENGTH (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Given a list of names, check to see if each name is a currently
    defined variable and that all of the variables have the same
    number of elements.
 
Description:
    Sometimes when writing general purpose macros it may be useful
    to know if certain names have been defined as variables, and if so,
    do the variables have the same number of elements.

Syntax:
    LET <iflag> = CHECK EQUAL LENGTH  <name1> <name2> ... <namek>
    where <name1> <name2> ... <namek> is a list of 1 to k names;
    and   <iflag> is a parameter where the status is saved.
 
    If all names are already defined as variables with the same number
    of elements, <iflag> will be set to 1.  Otherwise <iflag> will be
    set to 0.

Examples:
    LET IFLAG = CHECK EQUAL LENGTH Y X
 
Note:
    The CALL EXIT and CALL EXIT ALL commands were added to allow you to
    exit a macro (HELP CALL for details).  The status flag from the
    CHECK EQUAL LENGTH command can be used to determine whether you want
    to exit from a macro or continue.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHECK TYPES    = Check the types for a list of names.
    CHECK NAMES    = Check whether a list of names have been previously
                     defined.
 
Applications:
    Data Management
 
Implementation Date:
    2015/06
 
Program:
    skip 25
    read berger1.dat y x bat
    let iflag = check equal length y x bat

-----CHECK NAMES-----------------------------------------
 
CHECK NAMES
 
Name:
    CHECK NAMES (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Given a list of names, check if any names are not already defined.
 
Description:
    Sometimes when writing general purpose macros it may be useful
    to know if certain names have been defined.  This can be either
    because certain variables or parameters are expected to be defined
    or because you want to use a particular name and you want to ensure
    that it is not already being used.

Syntax:
    LET <iflag> = CHECK NAMES  <name1> <name2> ... <namek>
    where <name1> <name2> ... <namek> is a list of 1 to k names;
    and   <iflag> is a parameter where the status is saved.
 
    If all names are already defined, <iflag> will be set to 1.  If one
    or more names are undefined, <iflag> will be set to 0.

Examples:
    LET IFLAG = CHECK NAMES Y X
 
Note:
    The CALL EXIT and CALL EXIT ALL commands were added to allow you to
    exit a macro (HELP CALL for details).  The status flag from the
    CHECK NAMES command can be used to determine whether you want to
    exit from a macro or continue.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHECK TYPES         = Check the types for a list of names.
    CHECK EQUAL LENGTH  = Check whether a list of variables have the same
                          number of elements.
 
Applications:
    Data Management
 
Implementation Date:
    2015/06
 
Program:
    skip 25
    read berger1.dat y x bat
    let iflag = check names y x bat s

-----CHECK TYPES-----------------------------------------
 
CHECK TYPES
 
Name:
    CHECK TYPES (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Given a list of names, check whether the types of all listed names
    are the same.
 
Description:
    Sometimes when writing general purpose macros it may be useful to know
    if certain names have been defined, and if so, what type they have.

Syntax 1:
    LET <iflag> = CHECK TYPES <type>  <name1> <name2> ... <namek>
    where <type> is one of VARIABLE, STRING, PARAMETER, or MATRIX;
          <name1> <name2> ... <namek> is a list of 1 to k names;
    and   <iflag> is a parameter where the status is saved.
 
    The <type> argument specifies what type will be checked.  If all names
    are of the specified type, <iflag> will be set to 1.  Otherwise <iflag>
    will be set to 0.

Syntax 2:
    LET <iflag> = CHECK TYPES  <name1> <name2> ... <namek>
    where <name1> <name2> ... <namek> is a list of 1 to k names;
    and   <iflag> is a parameter where the status is saved.
 
    With this syntax, the type of the first name listed will be determined
    and all subsequent names will be checked against this type.

    If all names are of the same type, <iflag> will be set to 1.
    Otherwise <iflag> will be set to 0.

Examples:
    LET IFLAG = CHECK TYPES VARIABLE  Y X
    LET IFLAG = CHECK TYPES STRING  STIN STOUD
    LET IFLAG = CHECK TYPES Y X
 
Note:
    The CALL EXIT and CALL EXIT ALL commands were added to allow you to
    exit a macro (HELP CALL for details).  The status flag from the
    CHECK TYPES command can be used to determine whether you want to
    exit from a macro or continue.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHECK NAMES         = Check the types for a list of names.
    CHECK EQUAL LENGTH  = Check whether a list of names have been
                          previously defined.
 
Applications:
    Data Management
 
Implementation Date:
    2015/06
 
Program:
    skip 25
    read berger1.dat y x bat
    let iflag = check types y x bat

-----CHI-SQUARE INDEPENDENCE TEST (LET)--------------------------------
 
CHI-SQUARE INDEPENDENCE TEST
 
Name:
    CHI-SQUARE INDEPENDENCE TEST (LET)
 
Type:
    Analysis Command
 
Purpose:
    Perform a chi-square test of independence for a two-way
    contingency table.

Description:
    If we have N observations with two variables where each
    observation can be classified into one of R mutually exclusive
    categories for variable one and one of C mutually exclusive
    categories for variable two, then a cross-tabulation of the
    data results in a two-way contingency table (also referred to
    as an RxC contingency table).  The resulting contingency table
    has R rows and C columns.

    A common question with regards to a two-way contingency
    table is whether we have independence.  By independence, we
    mean that the row and column variables are unassociated
    (i.e., knowing the value of the row variable will not
    help us predict the value of column variable and likewise
    knowing the value of the column variable will not help us
    predict the value of the row variable).

    A more technical definition for independence is that

        P(row i, column j) = P(row i)*P(column j)   for all i,j

    One such test is the chi-square test for independence.

       H0: The two-way table is independent
       Ha: The two-way table is not independent
       Test Statistic:  The chi-square independence test
                        statistic is:

               T = SUM[i=1 to r][j=1 to c][(O(ij) - E(ij)**2/E(ij)]

            where

               r     = the number of rows in the contingency table
               c     = the number of columns in the contingency table
               O(ij) = the observed frequency of the ith row and
                       jth column
               E(ij) = the expected frequency of the ith row and
                       jth column
                     = R(i)*C(j)/N
               R(i)  = the sum of the observed frequencies for row i
               C(j)  = the sum of the observed frequencies for column j
               N     = the total sample size

       Significance Level:  alpha
       Critical Region: T > CHSPPF(alpha,(r-1)*(c-1))

             where CHSPPF is the percent point function of the
             chi-square distribution and (r-1)*(c-1) is the
             degrees of freedom
       Conclusion: Reject the independence hypothesis if the value
                   of the test statistic is greater than the
                   chi-square value.

    This test statistic can also be formulated as 

       T = SUM[i=1 to r][j=1 to c][d(ij)**2]

    where

       dij = (O(ij) - E(ij))/SQRT(E(ij))

    The dij are referred to as the standardized residuals and they
    show the contribution to the chi-square test statistic of each
    cell.

Syntax 1:
    CHI-SQUARE INDEPENDENCE TEST <y1> <y2>
                                 <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax is used for the case where you have raw data (i.e.,
    the data has not yet been cross tabulated into a two-way table).

Syntax 2:
    CHI-SQUARE INDEPENDENCE TEST <m>    <SUBSET/EXCEPT/FOR qualification>
    where <m> is a matrix containing the two-way table;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax is used for the case where we the data have already
    been cross-tabulated into a two-way contingency table.

Syntax 3:
    CHI-SQUARE INDEPENDENCE TEST <n11> <n12> <n21> <n22>
    where <n11> is a parameter containing the value for row 1,
                column 1 of a 2x2 table;
          <n12> is a parameter containing the value for row 1,
                column 2 of a 2x2 table;
          <n21> is a parameter containing the value for row 2,
                column 1 of a 2x2 table;
          <n22> is a parameter containing the value for row 2,
                column 2 of a 2x2 table.

    This syntax is used for the special case where you have a
    2x2 table.  In this case, you can enter the 4 values directly,
    although you do need to be careful that the parameters are
    entered in the order expected above.

Examples:
    CHI-SQUARE INDEPENDENCE TEST Y1 Y2
    CHI-SQUARE INDEPENDENCE TEST M
    CHI-SQUARE INDEPENDENCE TEST N11 N12 N21 N22

Note:
    The chi-square approximation is asymptotic.  This means that
    the critical values may not be valid if the expected frequencies
    are too small.

    Cochran suggests that if the minimum expected frequency is less
    than 1 or if 20% of the expected frequencies are less than 5,
    the approximation may be poor.  However, Conover suggests that
    this is probably too conservative, particularly if r and c
    are not too small.  He suggests that the minimum expected frequency
    should be 0.5 and at least half the expected frequencies should be
    greater than 1.

    In any event, if there are too many low expected frequencies,
    you can do one of the following:

       1) If rows or columns with small expected frequencies can
          be intelligently combined, then this may result in expected
          frequencies that are sufficiently large.

       2) Use Fisher's exact test.

Note:
    Conover points out that there are really 3 distinct tests:

       1) Only N is fixed.  The row and column totals are not fixed
          (i.e., they are random).

       2) Either the row totals or the column totals are fixed
          beforehand.

       3) Both the row totals and the column totals are fixed
          beforehand.

    Note that in all three cases, the test statistic and the
    chi-square approximation are the same.  What differs is the
    exact distribution of the test statistic.  When either the
    row or column totals (or both) are fixed, the possible number
    of contingency tables is reduced.

    As long as the expected frequencies are sufficiently large, the
    chi-square approximation should be adequate for practical purposes.

Note:
    Some authors recommend using a continuity correction for this
    test.  In this case, 0.5 is added to the observed frequency
    in each cell.  Dataplot performs this test both with the
    continuity correction and without the continuity correction.

Note:
    The following information is written to the file dpst1f.dat
    (in the current directory):

        Column 1   - row id
        Column 2   - column id
        Column 3   - row total
        Column 4   - column total
        Column 5   - expected frequency (E(ij))
        Column 6   - observed frequency (O(ij))

     To read this information into Dataplot, enter

        SKIP 1
        READ DPST1F.DAT ROWID COLID ROWTOT COLTOT EXPFREQ OBSFREQ

Note:
    The ASSOCIATION PLOT command can be used to plot the
    standardized residuals of the chi-square analysis.

    The ODDS RATIO INDEPDNENCE TEST is an alternative test for
    independence based on the LOG(odds ratio).

Default:
    None
 
Synonyms:
    None

Related Commands:
    ODDS RATIO INDEPENDENCE TEST  = Perform a log(odds ratio) test for
                                    independence.
    FISHER EXACT TEST             = Perform Fisher's exact test.
    ASSOCIATION PLOT              = Generate an association plot.
    SIEVE PLOT                    = Generate a sieve plot.
    ROSE PLOT                     = Generate a Rose plot.
    BINARY TABULATION PLOT        = Generate a binary tabulation plot.
    ROC CURVE                     = Generate a ROC curve.
    ODDS RATIO                    = Compute the bias corrected odds ratio.
    LOG ODDS RATIO                = Compute the bias corrected
                                    log(odds ratio).

Reference:
    Conover (1999), "Practical Nonparametric Statistics", Third Edition,
    Wiley, pp. 204-216.

    Friendly (2000), "Visualizing Categorical Data", SAS Institute
    Inc., p. 90.

    Cochran (1952), "The Chi-Square Test of Goodness of Fit",
    Annals of Mathematical Statistics, 23, pp. 315-345.

Applications:
    Categorical Data Analysis
 
Implementation Date:
    2007/3
 
Program:
    . Example from page 61 of Friendly
    read matrix m
     5  29 14 16
    15  54 14 10
    20  84 17 94
    68 119 26 7
    end of data
    .
    chi-square independence test m

------CHI-SQUARE TEST--------------------------------------
 
CHI SQUARE TEST
 
Name:
    CHI-SQUARE TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform a one sample chi-square test that the standard deviation is
    equal to a user specified value.
 
Description:
    The hypothesis test is:
       H0: sigma = sigma0
       Ha: sigma < sigma0     (lower one tail test)
           sigma = sigma0     (two tailed test)
           sigma > sigma0     (upper one tail test)
       Test Statistic:
             T = (N-1)*(sample standard deviation/sigma0)**2
           where N is the sample size.
       Alpha: Typically set to .05
       Critical Region:
              T < 0.95            (lower one tail test)
              0.025 < T < 0.975   (two tailed test)
              T > 0.05            (upper one tail test)
            where the critical region is determined from the chi-square
            cumulative distribution function with (N-1) degrees of
            freedom and an alpha of 0.05.
       Conclusion: Reject null hypothesis if T in critical region
 
    The standard output generates the test for all 3 cases (two tailed,
    lower one tail, upper one tail).
 
    DATAPLOT tests the hypothesis that the standard deviation is equal
    to a given value.  Be aware that many statistical textbooks state
    the hypothesis test in terms of the variance.  These tests are
    equivalent, just be sure to specify the sigma0 value in terms of
    the standard deviation for DATAPLOT purposes.
 
Syntax 1:
    CHI-SQUARE TEST  <y>  sigma0>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <sigma0> is a number or parameter that is the value to test
               against;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    CHI-SQUARE TEST  <sigma0>  <y>  <SUBSET/EXCEPT/FOR qualification>
    where <sigma0> is a number or parameter that is the value to test
               against;
          <y> is a response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    CHI-SQUARE TEST Y1  8.5
    CHI-SQUARE TEST Y1  A
    CHI-SQUARE TEST Y1  A  SUBSET Y > 0
 
Note:
    To use an alternate value of alpha, simply compare the value on the
    line labeled CHI-SQUARED CDF VALUE to the proper acceptance
    interval.  For example, for alpha = .10, the acceptance intervals
    are:
           (0.000,0.900)    - lower one tail case
           (0.050,0.950)    - two tail case
           (0.100,1.000)    - upper one tail case
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CONFIDENCE LIMITS  = Compute the confidence limits for the mean of
                         a sample.
    T TEST             = Performs a two-sample t test.
    F TEST             = Performs an F test for the ratio of 2
                         variances.
    STANDARD DEVIATION = Computes the standard deviation of a variable.
 
Reference:
    Chi-square tests are discussed in most introductory statistics
    books.
 
Applications:
    Confirmatory Data Analysis
 
Implementation Date:
    94/2
 
Program:
    SKIP 25
    READ GEAR.DAT DIAMETER BATCH
    LET A = 0.1
    CHI-SQUARE TEST DIAMETER A
 
-----CHI SQUARE GOODNESS OF FIT TEST -------------------------------
 
CHI SQUARE GOODNESS FIT
 
Name:
    ... CHI SQUARE GOODNESS OF FIT TEST
 
    NOTE: This command has been replaced with the unified
          GOODNESS OF FIT command (enter HELP GOODNESS OF FIT
          for details).

Type:
    Analysis Command
 
Purpose:
    Perform a chi-square goodness of fit test that a set of
    data come from a hypothesized distributuion.  Dataplot
    currently supports the chi-square goodness of fit test
    for 70+ distributions.
 
Description:
    The basic idea behind the chi-square goodness of fit test
    is to divide the range of the data into a number of
    intervals.  Then the number of points that fall into each
    interval is compared to expected number of points for that
    interval if the data in fact come from the hypothesized
    distribution.  More formally, the chi-square goodness of fit
    test statistic can be defined as follows.

        H0:          The data follow a specified distribution.
        Ha:          The data do not follow the specified distribution.

        Test         For the chi-square goodness of fit, the data is
        Statistic:   divided into k bins and the test statistic is
                     defined as

                       Chi-Square = SUM(O(i) - E(i))**2/E(i)

                     where the summation is for bin 1 to k, O(i) is the
                     observed frequency for bin i, and E(i) is the
                     expected frequency for bin i.  The expected frequency
                     is calculated by

                        E(i) = F(Y(u)) - F(Y(l))

                     where F is the cumulative distribution function
                     for the distribution being tested, Y(u) is the upper
                     limit for class i, and Y(l) is the lower limit for
                     class i.

                     This test is sensitive to the choice of bins.  There
                     is no optimal choice for the bin width (since the 
                     optimal bin width depends on the distribution).
                     Most reasonable choices should produce similar, but
                     not identical, results.  Dataplot uses 0.3*s,
                     where s is the sample standard deviation, for the
                     class width.  The lower and upper bins are at the
                     sample mean plus and minus 6.0*s respectively.  For
                     the chi-square approximation to be valid, the
                     expected frequency should be at least 5.  This test
                     is not valid for small samples, and if some of the
                     counts are less than five, you may need to combine
                     some bins in the tails.

        Significance alpha
        Level:

        Critical     The test statistic follows, approximately, a
        Region:      chi-square distribution with (k - c) degrees of
                     freedom where k is the number of non-empty cells and
                     c = the number of parameters (including location and
                     scale parameters and shape parameters) for the
                     distribution + 1.  For example, for a 3-parameter
                     Weibull distribution, c = 4.

                     Therefore, the hypothesis that the distribution is
                     from the specified distribution is rejected if

                        Chi-Square > CHSPPF(1-alpha,k-c)

                     where CHSPPF is the chi-square percent point function
                     with k - c degrees of freedom and a significance
                     level of alpha.

    The primary advantage of the chi square goodnes of fit test is that
    it is quite general.  It can be applied for any distribution, either
    discrete or continuous, for which the cumulative distribution function
    can be computed.  Dataplot supports the chi-square goodness of fit
    test for all distributions for which it supports a CDF function.

    There are two primary disadvantages:

       1) The test is sensitive to how the binning of the
          data is performed.

       2) It requires sufficient sample size so that the minimum
          expected frequency is five.
       
    In order to apply the chi-square goodness of fit test, any shape
    parameters must be specified.  For example,

       LET GAMMA = 5.3
       WEIBULL CHI-SQUARE GOODNESS OF FIT TEST Y

    The name of the distributional parameter for families is given in
    the list below.
 
    Location and scale parameters can be specified generically with
    the following commands:

        LET CHSLOC = <value>
        LET CHSSCALE = <value>

    The location and scale parameters default to 0 and 1 if not
    specified.

    Dataplot supports the chi-square goodness of fit test for either
    binned or unbinned data.

    For unbinned data, Dataplot automatically generates binned data
    using the same rule as for histograms.  That is, the class width
    is 0.3*s where s is the sample standard deviation.  The upper and
    lower limits are the mean plus or minus 6 times the sample
    standard deviation (any zero frequency bins in the tails are
    omitted).  As with the HISTOGRAM command, you can
    override these defaults using the CLASS WIDTH, CLASS UPPER,
    and CLASS LOWER commands.

    Pre-binned data can be specicied in two ways.  If your bins are
    of equal size, then you specify a single X variable that contains
    the mid-points of the bins.  If your bins may be of unequal
    size, then two X variables are given.  The first contains the
    lower limit of each bin and the second contains the upper limit
    of each bin.  Unequal bin sizes usually result from combining
    classes with small (less than 5) expected frequency.

Syntax 1:
    <dist>  CHI-SQUARE GOODNESS OF FIT TEST  <y> 
                                <SUBSET/EXCEPT/FOR/qualification>
    where <y> is a response variable;
          <dist> is one of the following distributions:
            1) NORMAL
            2) HALFNORMAL
            3) SLASH
            4) COSINE
            5) LOGISTIC
            6) HALF LOGISTIC
            7) HYPERBOLIC SECANT
            8) CAUCHY
            9) HALF CAUCHY
           10) DOUBLE EXPONENTIAL
           11) EXPONENTIAL
           12) EXTREME VALUE TYPE 1  (or GUMBEL)
           13) UNIFORM
           14) SEMI-CIRCULAR
           15) ANGLIT
           16) ARCSIN
           17) RAYLEIGH

           18) MAXWELL                     (SIGMA)
           19) WEIBULL                     (GAMMA)
           20) DOUBLE WEIBULL              (GAMMA)
           21) INVERTED WEIBULL            (GAMMA)
           22) GAMMA                       (GAMMA)
           23) LOG GAMMA                   (GAMMA)
           24) DOUBLE GAMMA                (GAMMA)
           25) INVERTED GAMMA              (GAMMA)
           26) WALD                        (GAMMA)
           27) FATIGUE LIFE                (GAMMA)
           28) EXTREME VALUE TYPE 2        (GAMMA)
           29) GENERALIZED EXTREME VALUE   (GAMMA)
           30) PARETO                      (GAMMA)
           31) PARETO SECOND KIND          (GAMMA)
           32) GENERALIZED PARETO          (GAMMA)
           33) GENERALIZED HALF LOGISTIC   (GAMMA)
           34) TUKEY LAMBDA                (LAMBDA)
           35) SKEWED NORMAL               (LAMBDA)
           36) SKEW DOUBLE EXPONENTIAL     (LAMBDA)
           37) POISSON                     (LAMBDA)
           38) T                           (NU)
           39) FOLDED T                    (NU)
           40) CHI-SQUARED                 (NU)
           41) CHI                         (NU)
           42) LOGNORMAL                   (SD)
           43) LOG DOUBLE EXPONENTIAL      (ALPHA)
           44) ERROR                       (ALPHA)
           45) GENERALIZED LOGISTIC        (ALPHA)
           46) GENERALIZED LOGISTIC TYPE 2 (ALPHA)
           47) GENERALIZED LOGISTIC TYPE 3 (ALPHA)
           48) GENERALIZED LOGISTIC TYPE 5 (ALPHA)
           49) MCLEISH                     (ALPHA)
           50) ZETA                        (ALPHA)
           51) WRAPPED CAUCHY              (C)
           52) POWER FUNCTION              (C)
           53) TRIANGULAR                  (C)
           54) LOG LOGISTIC                (DELTA)
           55) VON-MISES                   (B)
           56) DISCRETE UNIFORM            (N)
           57) LEADS IN COIN TOSSING       (N)
           58) GEOMETRIC                   (P)
           59) YULE                        (P)
           60) LOGARITHMIC SERIES          (THETA)
           61) RECIPROCAL                  (B)
           62) BRADFORD                    (BETA)
           63) TOPP AND LEONE              (BETA)
           64) ASYMMETRIC DOUBLE EXPO      (K)
           65) CLASSICAL MATCHING          (K)

           66) POWER-NORMAL                (P, SD)
           67) POWER-LOGNORMAL             (P, SD)
           68) FOLDED NORMAL               (M, SD)
           69) FOLDED CAUCHY               (M, SD)
           70) SKEWED T                    (LAMBDA, NU)
           71) NONCENTRAL T                (NU, LAMBDA)
           72) NONCENTRAL CHISQUARE        (NU, LAMBDA)
           73) LOG SKEWED NORMAL           (LAMBDA, SD)
           74) BOREL TANNER                (LAMBDA, K)
           75) LAGRANGE POISSON            (LAMBDA, THETA)
           76) BETA                        (ALPHA, BETA)
           77) INVERTED BETA               (ALPHA, BETA)
           78) BETA BINOMIAL               (ALPHA, BETA)
           79) HERMITE                     (ALPHA, BETA)
           80) EXPONENTIAL POWER           (ALPHA, BETA)
           81) BETA NORMAL                 (ALPHA, BETA)
           82) ASYMMETRIC LOG DOUBLE EXPO  (ALPHA, BETA)
           83) BETA GEOMETRIC              (ALPHA, BETA)
           84) ALPHA                       (ALPHA, BETA)
           85) KATZ                        (ALPHA, BETA)
           86) GENERALIZED TOPP AND LEONE  (ALPHA, BETA)
           87) REFLECTED GENE TOPP LEONE   (ALPHA, BETA)
           88) G AND H                     (G, H)
           89) JOHNSON SB                  (ALPHA1, ALPHA2)
           90) JOHNSON SU                  (ALPHA1, ALPHA2)
           91) EXPONENTIATED WEIBULL       (GAMMA, THETA)
           92) GENERALIZED GAMMA           (GAMMA, C)
           93) INVERSE GAUSSIAN            (GAMMA, MU)
           94) RECIPROCAL INVERSE GAUSSIAN (GAMMA, MU)
           95) F                           (NU1, NU2)
           96) TWO-SIDED POWER             (THETA, N)
           97) POLYA AEPPLI                (THETA, P)
           98) GENERALIZED LOGA SERIES     (THETA, BETA)
           99) GEETA                       (THETA, BETA or MU, BETA)
          100) CONSUL                      (THETA, BETA or MU, BETA)
          101) BINOMIAL                    (N, P)
          102) WARING                      (A, C)
          103) GOMPERTZ                    (C, B)
          104) GENERALIZED MCLEISH         (ALPHA, A)
          105) ZIPF                        (ALPHA, N)
          106) NEGATIVE BINOMIAL           (K, P)
          107) GENERALIZED LOGISTIC TYPE 4 (P, Q)
          108) LOST GAMES                  (P, R)
          109) DISCRETE WEIBULL            (BETA, Q)

          110) LOG SKEWED T                (LAMBDA, NU, SD)
          111) DOUBLY NONCENTRAL T         (NU, LAMBDA1, LAMBDA2)
          112) NONCENTRAL F                (NU1, NU2, LAMBDA)
          113) NONCENTRAL BETA             (ALPHA, BETA, LAMBDA)
          114) TRUNCATED EXPONENTIAL       (X0, M, SD)
          115) GENERALIZED EXPONENTIAL     (LAMBDA1, LAMBDA2, S)
          116) GOMPERTZ-MAKEHAM            (XI, LAMBDA, THETA)
          117) MIELKE BETA-KAPPA           (BETA, THETA, K)
          118) HYPERGEOMETRIC              (K, N, M)
          119) GENERALIZED INVERSE GAUSS   (CHI, LAMBDA, THETA)
          120) BESSEL I                    (SIGMA1SQ, SIGMA2SQ, NU)
                                           (B, C, M)
          121) BESSEL K                    (SIGMA1SQ, SIGMA2SQ, NU)
                                           (B, C, M)
          122) WAKEBY                      (GAMMA, BETA, DELTA)
          123) BETA-NEGATIVE BINOMIAL      (ALPHA, BETA, K)
          124) GENERALIZED NEGATIVE BINO   (THETA, BETA, M)
          125) QUASI BINOMIAL TYPE I       (P, M, PHI)
          126) GENERALIZED LOST GAMES      (P, A, J)

          127) DOUBLY NONCENTRAL F         (NU1, NU2, LAMBDA1, LAMBDA2)
          128) TRUNCATED NORMAL            (A, B, M, SD)
          129) TRAPEZOID                   (A, B, C, D)
          130) LOG BETA                    (ALPHA, BETA, C, D)
          131) TRUNCATED GENE NEGA BINO    (THETA, BETA, M, N)

          132) NORMAL MIXTURE              (MU1, SD1, MU2, SD2, P)
          133) BI-WEIBULL                  (SCALE1, GAMMA1, LOC2, SCALE2,
                                           GAMMA2)

          134) GENERALZIED TRAPEZOID       (A, B, C, D, NU1, NU3, ALPHA)

    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for the case where you have unbinned data.

Syntax 2:
    <dist> CHI-SQUARE GOODNESS OF FIT TEST <y> <x>
                      <SUBSET/EXCEPT/FOR/qualification>
    where <y> is a variable of pre-computed frequencies;
          <x> is a variable containing the mid-points of the bins;
          <dist> is as above;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for the case where you have binned data with
    equal size bins.

Syntax 3:
    <dist> CHI-SQUARE GOODNESS OF FIT TEST <y> <x1> <x2>
                      <SUBSET/EXCEPT/FOR/qualification>
    where <y> is a variable of pre-computed frequencies;
          <x1> is a variable containing the lower limits of the bins;
          <x2> is a variable containing the upper limits of the bins;
          <dist> is as above;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for the case where you have binned data with
    unequal size bins.

Examples:
    NORMAL CHI-SQUARE GOODNESS OF FIT TEST Y
    NORMAL CHI-SQUARE GOODNESS OF FIT TEST Y  SUBSET GROUP > 1
    CAUCHY CHI-SQUARE GOODNESS OF FIT TEST Y
    LOGNORMAL CHI-SQUARE GOODNESS OF FIT TEST X
    EXTREME VALUE TYPE 1 CHI-SQUARE GOODNESS OF FIT TEST X

    LET LAMBDA = 0.2
    TUKEY LAMBDA CHI-SQUARE GOODNESS OF FIT TEST X

    SET MINMAX = 1
    LET GAMMA = 2.0
    WEIBULL CHI-SQUARE GOODNESS OF FIT TEST X

    LET LAMBDA = 3
    POISSON CHI-SQUARE GOODNESS OF FIT TEST X

    NORMAL CHI-SQUARE GOODNESS OF FIT TEST Y X
    NORMAL CHI-SQUARE GOODNESS OF FIT TEST Y X1 X2

Note:
    There are several approaches for estimating the parameters of a
    distribution before applying the goodness of fit test.  PPCC plots
    combined with probability plots are an effective graphical approach
    if there are zero or one shape parameters.  Maximum likelihood 
    estimation is available for several distributions.  Least squares
    estimation can be applied for distributions for which maximum
    likelihood estimation is not available.
 
Note:
    The bin number, bin mid-point, observed frequency, and expected
    frequency are written to the file DPST1F.DAT (dpst1f.dat under
    Unix) in the current directory.

Note:
    The CHI-SQUARE GOODNESS OF FIT command automatically saves the
    following parameters.
 
        STATVAL   - value of the chi-square goodness of fit statistic
        STATNU    - degrees of freedom for the chi-square goodness of
                    fit test
        STATCDF   - cdf value for the chi-square goodness of fit test
                    statistic
        CUTUPP90  - 90% critical value (alpha = 0.10) for the chi-square
                    goodness of fit test statistic
        CUTUPP95  - 95% critical value (alpha = 0.05) for the chi-square
                    goodness of fit test statistic
        CUTUPP99  - 99% critical value (alpha = 0.01) for the chi-square
                    goodness of fit test statistic

    These parameters can be used in subsequent analysis.

Default:
    Location and scale parameters default to zero and one.  Shape
    parameters must be explicitly specified.  There is no default
    distribution.
 
Synonyms:
    EV2 and FRECHET are synonyms for EXTREME VALUE TYPE 2.
    EV1 and GUMBEL are synonyms for EXTREME VALUE TYPE 1.
    FATIGUE LIFE is a synonym for FL.
    RECIPROCAL INVERSE GAUSSIAN is a synonym for RIG.
    IG is a synonym for INVERSE GAUSSIAN.
    SKEW LAPLACE is a synonym for SKEW DOUBLE EXPONENTIAL
    ASYMMETRIC LAPLACE is a synonym for ASYMMETRIC DOUBLE EXPONENTIAL
 
    The word TEST is optional.

    CHI-SQUARE, CHISQUARE, and CHI SQUARE can all be used.

Related Commands:
    ANDERSON-DARLING TEST   = Perform Anderson-Darling test for goodness
                              of fit.
    KOLMOGOROV-SMIRNOV TEST = Perform Kolmogorov-Smirnov test for goodness
                              of fit.
    WILK-SHAPIRO TEST       = Perform Wilk-Shapiro test for normality.
    MAXIMUM LIKELIHOOD      = Perform maximum likelihood estimation for
                              several distributions.
    FIT                     = Perform least squares fitting.

    PROBABILITY PLOT        = Generates a probability plot.
    HISTOGRAM               = Generates a histogram.
    PPCC PLOT               = Generates probability plot correlation
                              coefficient plot.

    CLASS WIDTH             = Specify the class width.
    CLASS UPPER             = Specify the upper limit for classes.
    CLASS LOWER             = Specify the lower limit for classes.
 
Reference:
    "Statistical Methods", Eight Edition, Snedecor and Cochran,
    Iowa State, 1989, pp. 76-79.

Applications:
    Distributional Analysis
 
Implementation Date:
    1998/12
    2001/10: GENERALIZED LAMBDA, JOHNSON SU,
             JOHNSON SB, INVERTED WEIBULL,
             LOG DOUBLE EXPONENTIAL
    2002/5: TWO-SIDED POWER, BI-WEIBULL
    2003/5: ERROR
    2004/1: TRAPEZOID, GENERALIZED TRAPEZOID, FOLDED T,
            SKEWED T, SKEWED NORMAL, SLASH, INVERTED BETA,
            G AND H
    2004/5: Implemented the automatic computation of the
            biweight fit (PPA0BW and PPA1BW)
    2004/5: LOG SKEW NORMAL, LOG SKEW T, HERMITE, YULE
    2004/5: Fixed a number of bugs for various distributions
    2004/6: SKEW DOUBLE EXPONENTIAL, ASYMMETRIC DOUBLE EXPONENTIAL
 
Program:
    skip 25
    read zarr13.dat y
    .
    let m = mean y
    let s = standard deviation y
    let chsloc = m
    let chsscale = s
    normal chi-square goodness of fit test y
 
    The following output is generated.

           ************************************************
           **  normal chi-square goodness of fit test y  **
           ************************************************
      
      
                       CHI-SQUARED GOODNESS OF FIT TEST
      
     NULL HYPOTHESIS H0:      DISTRIBUTION FITS THE DATA
     ALTERNATE HYPOTHESIS HA: DISTRIBUTION DOES NOT FIT THE DATA
     DISTRIBUTION:            NORMAL
      
     SAMPLE:
        NUMBER OF OBSERVATIONS      =      195
        NUMBER OF NON-EMPTY CELLS   =       20
        NUMBER OF PARAMETERS USED   =        2
      
     TEST:
     CHI-SQUARED TEST STATISTIC     =    5.506083
        DEGREES OF FREEDOM          =       17
        CHI-SQUARED CDF VALUE       =    0.004063
      
        ALPHA LEVEL         CUTOFF              CONCLUSION
                10%       24.76903               ACCEPT H0
                 5%       27.58711               ACCEPT H0
                 1%       33.40867               ACCEPT H0
      
           CELL NUMBER, BIN MIDPOINT, OBSERVED FREQUENCY, AND EXPECTED FRQUENCY
           WRITTEN TO FILE DPST1F.DAT
  

-----CHI-SQUARE TWO SAMPLE TEST ---------------------------
 
CHI SQUARE TWO SAMPLE
 
Name:
    ... CHI SQUARE TWO SAMPLE TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform a chi-square two sample test that two data samples
    come from the same distribution.  Note that we are not specifying
    what that common distribution is.
 
Description:
    The chi-square two sample test is based on binned data.  Note
    that the binning for both data sets should be the same.  The
    basic idea behind the chi-square two sample test is that the
    observed number of points in each bin (this is scaled for unequal
    sample sized) should be similar if the two data samples come from
    common distributions.  More formally, the chi-square two sample
    test statistic can be defined as follows.

        H0:          The two data samples come from a common
                     distribution.
        Ha:          The two data samples do not come from a common
                     distribution.

        Test         For the chi-square two sample test, the data is
        Statistic:   divided into k bins and the test statistic is
                     defined as

                       C = SUM(K1*R(i) - K2*S(i))**2/(R(i) + S(i))

                     where the summation is for bin 1 to k, R(i) is the
                     observed frequency for bin i for sample 1, and S(i)
                     is the observed frequency for bin i for sample 2.
                     K1 and K2 are scaling constants that are used to
                     adjust for unequal sample sizes.  Specifically,

                        K1 = SQRT(SUM(R(i))/SUM(S(i)))
                        K2 = SQRT(SUM(S(i))/SUM(R(i)))

                     where the summation is over the k bins.

                     This test is sensitive to the choice of bins.
                     Most reasonable choices should produce similar, but
                     not identical, results.

        Significance alpha
        Level:

        Critical     The test statistic follows, approximately, a
        Region:      chi-square distribution with (k - c) degrees of
                     freedom where k is the number of non-empty bins and
                     c = 1 if the sample sizes are equal and c = 0 if
                     they are not equal.

                     Therefore, the hypothesis that the distribution is
                     from the specified distribution is rejected if

                        C > CHSPPF(1-alpha,k-c)

                     where CHSPPF is the chi-square percent point function
                     with k - c degrees of freedom and a significance
                     level of alpha.

    Dataplot supports the chi-square two sample test for either
    binned or unbinned data.

    For unbinned data, Dataplot automatically generates binned data
    using the same rule as for histograms.  That is, the class width
    is 0.3*s where s is the sample standard deviation.  The upper and
    lower limits are the mean plus or minus 6 times the sample
    standard deviation (any zero frequency bins in the tails are
    omitted).  Note that the binning computations are performed with
    the combined data set.  As with the HISTOGRAM command, you can
    override these defaults using the CLASS WIDTH, CLASS UPPER,
    and CLASS LOWER commands.  

    The quantile-quantile plot, bihistogram, and Tukey mean-difference
    plot are graphical alternatives.

Syntax 1:
    CHI SQUARE TWO SAMPLE TEST  <y1>  <y2>
                                <SUBSET/EXCEPT/FOR/qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax is used for unbinned data.

Syntax 2:
    CHI SQUARE TWO SAMPLE TEST  <y1>  <y2> <x>
                                <SUBSET/EXCEPT/FOR/qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <x> is a variable containing the mid-points of the bins;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax is used for binned data.  The <y1> and <y2> variables
    contain bin frequencies and <x> contains the bin midpoints.

Examples:
    CHI-SQUARE TWO SAMPLE TEST Y1 Y2
    CHI-SQUARE TWO SAMPLE TEST Y1 Y2 X
    CHI-SQUARE TWO SAMPLE TEST Y1 Y2 X  SUBSET Y2 > 0

Note:
    The CHI-SQUARE TWO SAMPLE TEST command automatically saves the
    following parameters.
 
        STATVAL   - value of the chi-square two sample test statistic
        STATNU    - degrees of freedom for the chi-square two sample
                    test
        STATCDF   - cdf value for the chi-square two sample test
                    statistic
        CUTUPP90  - 90% critical value (alpha = 0.10) for the chi-square
                    two sample test statistic
        CUTUPP95  - 95% critical value (alpha = 0.05) for the chi-square
                    two sample test statistic
        CUTUPP99  - 99% critical value (alpha = 0.01) for the chi-square
                    two sample test statistic

    These parameters can be used in subsequent analysis.

Note:
    The following statistics are also supported:

        LET A = TWO SAMPLE CHI SQUARE TEST        Y1 Y2
        LET A = TWO SAMPLE CHI SQUARE TEST CDF    Y1 Y2
        LET A = TWO SAMPLE CHI SQUARE TEST PVALUE Y1 Y2

    In addition to the above LET command, built-in statistics are
    supported for about 20+ different commands (enter HELP STATISTICS
    for details).

Default:
    None
 
Synonyms:
    The following forms of the command are accepted.

        CHI SQUARE TWO SAMPLE TEST
        CHISQUARE TWO SAMPLE TEST
        CHI SQUARE 2 SAMPLE TEST
        CHISQUARE 2 SAMPLE TEST
        TWO SAMPLE CHI SQUARE TEST
        TWO SAMPLE CHISQUARE TEST
        2 SAMPLE CHI SQUARE TEST
        2 SAMPLE CHISQUARE TEST

    The word TEST in the above commands is optional.

Related Commands:
    CHI SQUARE GOODNESS        = Perform chi-square goodness of fit test.
        OF FIT TEST 
    KOLMOGOROV SMIRNOV TWO     = Perform Kolmogorov-Smirnov two sample
       SAMPLE TEST               test.

    BIHISTOGRAM                = Generates a bihistogram.
    QUANTILE-QUANTILE PLOT     = Generates a quantile-quantile plot.
    TUKEY MEAN DIFFERENCE PLOT = Generates a Tukey mean difference plot.

Reference:
    "Numerical Recipes in Fortan: The Art of Scientific Computing",
    Second Edition, Press, Teukolsky, Vetterlling, and Flannery, 
    Cambridge University Press, 1992, pp. 614-622.

Applications:
    Distributional Analysis
 
Implementation Date:
    1998/12
 
Program:
    SKIP 25
    READ AUTO83B.DAT Y1 Y2
    .
    DELETE Y2 SUBSET Y2 < 0
    CHI SQUARE TWO SAMPLE TEST Y1 Y2
 
    The following output is generated.

  
           ****************************************
           **  CHI-SQUARE TWO SAMPLE TEST Y1 Y2  **
           ****************************************
      
      
                       CHI-SQUARED TWO SAMPLE TEST
      
     NULL HYPOTHESIS H0:      TWO SAMPLES COME FROM THE SAME (UNSPECIFIED)
                              DISTRIBUTION
     ALTERNATE HYPOTHESIS HA: TWO SAMPLES COME FROM DIFFERENT DISTRIBUTIONS
      
     SAMPLE:
        NUMBER OF OBSERVATIONS FOR SAMPLE 1 =      249
        NUMBER OF OBSERVATIONS FOR SAMPLE 2 =       79
        NUMBER OF NON-EMPTY CELLS           =       17
        CLASS WIDTH FOR BINS                =   0.1832313E+01
        CLASS LOWER FOR BINS                =  -0.1834362E+02
        CLASS UPPER FOR BINS                =   0.5863277E+02
      
     TEST:
     CHI-SQUARED TEST STATISTIC     =    35.33751
        DEGREES OF FREEDOM          =       17
        CHI-SQUARED CDF VALUE       =    0.994384
      
        ALPHA LEVEL         CUTOFF              CONCLUSION
                10%       24.76903               REJECT H0
                 5%       27.58711               REJECT H0
                 1%       33.40867               REJECT H0

-----CHM (LET)----------------------------------------------
 
CHM
 
Name:
    CHM (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the confluent hypergeometric M function with
    shape parameters A and B.
 
Description:
    The Handbook of Mathematical Functions (see the REFERENCE section
    below) defines 2 confluent hypergeometric functions: M and U.  This
    command computes the M function.  See the Handbook for the
    definition of these functions.  Note that although the Handbook
    defines this function for both real and complex values, DATAPLOT
    only computes it for real values.

    Many common functions can be defined as special cases of this
    function (see table 13.6 in the Handbook of Mathematical
    Functions).

    The input value must be a positive real number.  The B shape
    parameter should not be 0 or a negative integer.

    Dataplot computes these function using the CHGM routine from
    "Computation of Special Functions" (see the References section
    below).
 
Syntax:
    LET <y2> = CHM(<x>,<a>,<b>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a positive number, variable, or parameter;
          <a> is a number, variable, or parameter;
          <b> is a number, variable, or parameter;
          <y2> is a variable or a parameter (depending on what <a> and
               <b> are) where the computed values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Z = CHM(0.01,0.1,0.2)
    LET Z = CHM(1,0.1,0.2)
    LET Z = CHM(0.1,-1.3,0.1)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHU        = Compute the confluent hypergeometric U function.
    BETA       = Compute the complete Beta function.
    BETAI      = Compute the incomplete Beta function.
    GAMMA      = Compute the gamma function.
    LOGGAMMA   = Compute the log gamma function.
 
Reference:
    "Computation of Special Functions", Shanjie Zhang and Jianming
    Jin, John Wiley and Sons, 1996, chapter 12.
 
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964.
 
Applications:
    Special Functions
 
Implementation Date:
    1997/12
 
Program:
    TITLE AUTOMATIC
    PLOT CHM(X,0.1,0.2) FOR X = 0.1 0.1 10
 
-----CHOLESKY DECOMPOSITION (LET)--------------------------------
 
CHOLESKY DECOMPOSITION
 
Name:
    CHOLESKY DECOMPOSITION (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the Cholesky decomposition of a matrix.
 
Description:
    If X is a positive definite matrix with row and column dimensions
    n, then X can be factored into an upper diagonal matrix R (also of
    dimension n) such that:
           X = R'R
    where R' refers to the transpose of R.  Examples of positive
    definite matrices in statistical applications include the variance-
    covariance matrix, the correlation matrix, and the X'X matrix in
    regression.  The Cholesky decomposition is essentially the square
    root matrix (and the inverse square root matrix is the inverse of
    R).  For this reason, it is sometimes referred to as the Cholesky
    square root.  The Cholesky decomposition is typically used in
    intermediate calculations rather than being of interest in itself.
    It can also be used to solve some systems of linear equations and
    in least squares fits (although DATAPLOT uses different techniques
    for these problems).
 
Syntax:
    LET <r> = CHOLESKY DECOMPOSITION <mat1>
               <SUBSET/EXCEPT/FOR qualification>
    where <mat1> is a matrix for which the Cholesky decomposition is to
                 be computed;
          <r> is a matrix where the Cholesky decomposition is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional (and
                 rarely used in this context).
 
Examples:
    LET R  = CHOLESKY DECOMPOSITION A
 
Note:
    A real matrix A is positive definite if and only if it is symmetric
    and the quadratic xA'x is positive for all non-zero vectors x.
    DATAPLOT only uses the upper half of the original matrix, so no
    test is made for symmetry.  An error message is generated if a
    non-positive definite matrix is detected.
 
Note:
    DATAPLOT uses the LINPACK routine SPOCO to compute the Cholesky
    decomposition.  The reciprocal of the condition number is printed.
    This number gives an approximation of the numerical accuracy that
    was obtained when calculating the Cholesky decomposition.  If this
    number is approximately 10**(-d), then the elements of the
    decomposed matrix generally have d fewer significant digits than
    the original matrix.
 
Note:
    Matrices are created with either the READ MATRIX command or the
    MATRIX DEFINITION command.  Enter HELP MATRIX DEFINITION and HELP
    READ MATRIX for details.
 
Note:
    The columns of a matrix are accessible as variables by appending an
    index to the matrix name.  For example, the 4x4 matrix C has
    columns C1, C2, C3, and C4.  These columns can be operated on like
    any other DATAPLOT variable.
 
Note:
    The maximum size matrix that DATAPLOT can handle is set when
    DATAPLOT is built on a particular site.  The default maximums are
    100 columns and 500 rows.  Earlier versions may be 20 rows and 20
    columns or 100 rows and 100 columns.
 
Default:
    None
 
Synonyms:
    MATRIX CHOLESKY DECOMPOSITION
    MATRIX CHOLESKY
    CHOLESKY
 
Related Commands:
    MATRIX ADDITION      = Perform a matrix addition.
    MATRIX ADJOINT       = Compute the adjoint matrix of a matrix.
    MATRIX COFACTOR      = Compute a matrix cofactor.
    MATRIX DEFINITION    = Set a matrix definition.
    MATRIX DETERMINANT   = Compute a matrix determinant.
    MATRIX EIGENVALUES   = Compute the matrix eigenvalues.
    MATRIX EIGENVECTORS  = Compute the matrix eigenvectors.
    MATRIX EUCLID NORM   = Compute the matrix Euclidean norm.
    MATRIX INVERSE       = Compute a matrix inverse.
    MATRIX MINOR         = Compute a matrix minor.
    MATRIX MULTIPLICAT   = Perform a matrix multiplication.
    MATRIX NUMB OF COLU  = Compute the number of columns in a matrix.
    MATRIX NUMB OF ROWS  = Compute the number of rows in a matrix.
    MATRIX RANK          = Compute the rank of a matrix.
    MATRIX SIMPLEX SOLU  = Compute a matrix simplex solution.
    MATRIX SOLUTION      = Solve a system of linear equations.
    MATRIX SPECTRAL NORM = Compute the matrix spectral norm.
    MATRIX SPECTRAL RADI = Compute the matrix spectral radius.
    MATRIX SUBMATRIX     = Define a matrix submatrix.
    MATRIX SUBTRACTION   = Perform a matrix subtraction.
    MATRIX TRACE         = Compute a matrix trace.
    MATRIX TRANSPOSE     = Compute a matrix transpose.
    CORRELATION MATRIX   = Compute the correlation matrix of a matrix.
    VARIANCE-COVA MATRIX = Compute the variance-covariance matrix of a
                           matrix.
    PRINCIPLE COMPONENTS = Compute the principle components of a
                           matrix.
    SINGULAR VALUES      = Compute the singular values of a matrix.
    SINGULAR VALUE FACT  = Compute the singular value factorization of
                           a matrix.
    SINGULAR VALUE DECOM = Compute the singular value decomposition of
                           a matrix.
    TRIANGULAR SOLVE     = Solve an upper (or lower) triangular system
                           of linear equations.
    TRIANGULAR INVERSE   = Compute the inverse of an upper (or lower)
                           triangular matrix.
    MATRIX DIAGONAL      = Extract the diagonal of a matrix.
 
Reference:
    "LINPACK User's Guide", Dongarra, Bunch, Moler, Stewart.  Siam,
    1979.
 
Applications:
    Linear Algebra, Multivariate Analysis
 
Implementation Date:
    93/10
 
Program:
    READ MATRIX CORR
     1.0000  0.1839  0.0489  0.0186  0.0782  0.1147
     0.1839  1.0000  0.2220  0.1861  0.3355  0.1021
     0.0489  0.2220  1.0000  0.2707  0.2302  0.0931
     0.0186  0.1861  0.2707  1.0000  0.2950 -0.0438
     0.0782  0.3355  0.2302  0.2950  1.0000  0.2087
     0.1147  0.1021  0.0931 -0.0438  0.2087  1.0000
    END OF DATA
    LET RA = CHOLESKY DECOMP SA
    PRINT RA
 
-----CHSCDF (LET)--------------------------------
 
CHSCDF
 
Name:
    CHSCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the chi-square cumulative distribution function with degree
    of freedom parameter NU.
 
Description:
    The input value should be greater than 0 and the degrees of freedom
    should be a positive integer.  The chi-square distribution has the
    following probability density function:
       f(x)=(1/(2**NU/2*GAMMA(NU/2)))x**(NU/2-1)e**(-x/2), x > 0
    The cumulative distribution is the area from 0 to x (i.e., the
    integral of the above function).  Since this is a probability
    function, the returned value will be between 0 and 1.
 
Syntax:
    LET <y2> = CHSCDF(<y1>,NU)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed chi-square cdf value is stored;
          <NU> is a positive integer (the degrees of freedom);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CHSCDF(3,10)
    LET A = CHSCDF(A1,10)
    LET X2 = CHSCDF(X1,10)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHSPDF = Compute the chi-square probability density function.
    CHSPPF = Compute the chi-square percent point function.
    FCDF   = Compute the F cumulative distribution function.
    FPDF   = Compute the F probability density function.
    FPPF   = Compute the F percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    TCDF   = Compute the T cumulative distribution function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, 1970.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    TITLE PLOT CHSCDF FOR VARIOUS VALUES OF NU
    SEGMENT 1 COORDINATES 16 88 21 88; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 16 84 21 84; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 16 80 21 80; SEGMENT 3 PATTERN DOT
    SEGMENT 4 COORDINATES 16 76 21 76; SEGMENT 4 PATTERN DASH2
    LEGEND 1 NU = 5; LEGEND 1 COORDINATES 22 87
    LEGEND 2 NU = 10; LEGEND 2 COORDINATES 22 83
    LEGEND 3 NU = 20; LEGEND 3 COORDINATES 22 79
    LEGEND 4 NU = 30; LEGEND 4 COORDINATES 22 75
    YLIMITS 0 1; MAJOR YTIC NUMBER 6
    MINOR YTIC NUMBER 1; YTIC DECIMAL 1
    LINES SOLID DASH DOT DASH2
    PLOT CHSCDF(X,5) FOR X = 0 .1 30 AND
    PLOT CHSCDF(X,10) FOR X = 0 .1 30 AND
    PLOT CHSCDF(X,20) FOR X = 0 .1 30 AND
    PLOT CHSCDF(X,30) FOR X = 0 .1 30
 
-----CHSPDF (LET)--------------------------------
 
 
Name:
    CHSPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the chi-square probability density function with degrees of
    freedom parameter NU.
 
Description:
    The input value should be greater than 0 and the degrees of freedom
    should be a positive integer.  The chi-square distribution has the
    following probability density function:
       f(x)=(1/(2**NU/2*GAMMA(NU/2)))x**(NU/2-1)e**(-x/2), x > 0
    The CHSPDF function evaluates this function for a given x value.
 
Syntax:
    LET <y2> = CHSPDF(<y1>,NU)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed chi-square pdf value is stored;
          <NU> is a positive integer (the degrees of freedom);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CHSPDF(3,10)
    LET A = CHSPDF(A1,10)
    LET X2 = CHSPDF(X1,10)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPPF = Compute the chi-square percent point function.
    FCDF   = Compute the F cumulative distribution function.
    FPDF   = Compute the F probability density function.
    FPPF   = Compute the F percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    TCDF   = Compute the T cumulative distribution function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, 1970.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    TITLE PLOT CHSPDF FOR VARIOUS VALUES OF NU
    SEGMENT 1 COORDINATES 71 88 76 88; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 71 84 76 84; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 71 80 76 80; SEGMENT 3 PATTERN DOT
    SEGMENT 4 COORDINATES 71 76 76 76; SEGMENT 4 PATTERN DASH2
    LEGEND 1 NU = 5; LEGEND 1 COORDINATES 77 87
    LEGEND 2 NU = 10; LEGEND 2 COORDINATES 77 83
    LEGEND 3 NU = 20; LEGEND 3 COORDINATES 77 79
    LEGEND 4 NU = 30; LEGEND 4 COORDINATES 77 75
    YLIMITS 0 0.2; MAJOR YTIC NUMBER 5
    MINOR YTIC NUMBER 1; YTIC DECIMAL 2
    LINES SOLID DASH DOT DASH2
    PLOT CHSPDF(X,5) FOR X = 0 .1 30 AND
    PLOT CHSPDF(X,10) FOR X = 0 .1 30 AND
    PLOT CHSPDF(X,20) FOR X = 0 .1 30 AND
    PLOT CHSPDF(X,30) FOR X = 0 .1 30
 
-----CHSPPF (LET)--------------------------------
 
CHSPPF
 
Name:
    CHSPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the chi-square percent point function with degrees of
    freedom parameter NU.
 
Description:
    The input value should be between 0 and 1 and the degrees of
    freedom should be a positive integer.  The chi-square distribution
    has the following probability density function:
       f(x)=(1/(2**NU/2*GAMMA(NU/2)))x**(NU/2-1)e**(-x/2), x > 0
    The percent point function is the inverse of the cumulative
    distribution function.  The cumulative distribution sums the
    probability from 0 to the given x value.  The percent point
    function takes a cumulative probability value and computes the
    corresponding x value.
 
Syntax:
    LET <y2> = CHSPPF(<y1>,NU)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter in the range 0 to 1;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed chi-square ppf value is stored;
          <NU> is a positive integer (the degrees of freedom);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CHSPPF(0.9,10)
    LET A = CHSPPF(A1,10)
    LET X2 = CHSPPF(X1,10)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHSCDF = Compute the chi-square cumulative distribution function.
    CHSPDF = Compute the chi-square probability density function.
    FCDF   = Compute the F cumulative distribution function.
    FPDF   = Compute the F probability density function.
    FPPF   = Compute the F percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    TCDF   = Compute the T cumulative distribution function.
    TPDF   = Compute the T probability density function.
    TPPF   = Compute the T percent point function.
    WEICDF = Compute the Weibull cumulative distribution function.
    WEIPDF = Compute the Weibull probability density function.
    WEIPPF = Compute the Weibull percent point function.
 
Reference:
    "Continuous Univariate Distributions", Johnson and Kotz, 1970.
 
Applications:
    XX
 
Implementation Date:
    Pre-1987
 
Program:
    TITLE PLOT CHSPPF FOR VARIOUS VALUES OF NU
    SEGMENT 1 COORDINATES 16 88 21 88; SEGMENT 1 PATTERN SOLID
    SEGMENT 2 COORDINATES 16 84 21 84; SEGMENT 2 PATTERN DASH
    SEGMENT 3 COORDINATES 16 80 21 80; SEGMENT 3 PATTERN DOT
    SEGMENT 4 COORDINATES 16 76 21 76; SEGMENT 4 PATTERN DASH2
    LEGEND 1 NU = 5; LEGEND 1 COORDINATES 22 87
    LEGEND 2 NU = 10; LEGEND 2 COORDINATES 22 83
    LEGEND 3 NU = 20; LEGEND 3 COORDINATES 22 79
    LEGEND 4 NU = 30; LEGEND 4 COORDINATES 22 75
    XLIMITS 0 1; MAJOR XTIC NUMBER 6
    MINOR XTIC NUMBER 1; XTIC DECIMAL 1
    LINES SOLID DASH DOT DASH2
    PLOT CHSPPF(X,5) FOR X = 0.01 .01 0.95 AND
    PLOT CHSPPF(X,10) FOR X = 0.01 .01 0.95 AND
    PLOT CHSPPF(X,20) FOR X = 0.01 .01 0.95 AND
    PLOT CHSPPF(X,30) FOR X = 0.01 .01 0.95
 
-----CHU (LET)----------------------------------------------
 
CHU
 
Name:
    CHU (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the logarithmic confluent hypergeometric function with
    shape parameters A and B.
 
Description:
    The Handbook of Mathematical Functions (see the REFERENCE section
    below) defines 2 confluent hypergeometric functions M and U.  This
    command computes the U function.  See the Handbook for the
    definition of these functions.  Note that although the Handbook
    defines this function for both real and complex values, DATAPLOT
    only computes it for real values.

    Many common functions can be defined as special cases of this
    function (see table 13.6 in the Handbook of Mathematical Functions).

    The input value must be a positive real number.

Syntax:
    LET <y2> = CHU(<x>,<a>,<b>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a positive number, variable, or parameter;
          <a> is a number, variable, or parameter;
          <b> is a number, variable, or parameter;
          <y2> is a variable or a parameter (depending on what <a> and
               <b> are) where the computed values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Z = CHU(0.01,0.1,0.2)
    LET Z = CHU(1,0.1,0.2)
    LET Z = CHU(0.1,-1.3,0.1)
 
Note:
    DATAPLOT uses the routine DCHU from the SLATEC Common Mathematical
    Library to compute this function.  SLATEC is a large set of high
    quality, portable, public domain Fortran routines for various
    mathematical capabilities maintained by seven federal laboratories.

Note:
    This function returns an error message if 1+A-B is close to zero
    and X is small.  It also returns an error message if X is zero or
    negative.
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    BETA       = Compute the complete Beta function.
    BETAI      = Compute the incomplete Beta function.
    GAMMA      = Compute the gamma function.
    LOGGAMMA   = Compute the log gamma function.
    BESSJN     = Compute the Bessel function of the first kind and
                 order N.
    BESSYN     = Compute the Bessel function of the second kind and
                 order N.
    BESSIN     = Compute the modified Bessel function of order N.
    BESSKN     = Compute the modified Bessel function of the third kind
                 and order N.
    EXPINTN    = Compute the exponential integral.
    SININT     = Compute the sine integral.
    COSINT     = Compute the cosine integral.
 
Reference:
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 13).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE AUTOMATIC
    PLOT CHU(X,0.1,0.2) FOR X = 0.1 0.1 10
 
-----CIRCULAR SHIFT (LET)-------------------------------------
 
CIRCULAR SHIFT
 
Name:
    CIRCULAR SHIFT (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Perform a circular shift of the contents of a variable in either
    an up or down direction.
 
Description:
    It is sometimes convenient to move the elements of a
    variable either up or down.  Given a vector of n elements,
    one question is how to handle the elements when the index
    is less than 1 or greater than n.  For the circular shift,
    elements greater than n go to the beginning of the vector
    and elements less than 1 go to the end of the vector.

    For example, to circular shift the contents of the variable Y
    that contains 5 elements up (or right) by one element into the
    output vector Y2, we mean

       Y(1)    =>     Y2(2)
       Y(2)    =>     Y2(3)
       Y(3)    =>     Y2(4)
       Y(4)    =>     Y2(5)
       Y(5)    =>     Y2(1)

    To shift the contents of Y down (or left) by one element, we mean

       Y(1)    =>     Y2(5)
       Y(2)    =>     Y2(1)
       Y(3)    =>     Y2(2)
       Y(4)    =>     Y2(3)
       Y(5)    =>     Y2(4)

    The SHIFT command is similar to the CIRCULAR SHIFT, but it handles
    the end points differently.

Syntax:
    LET <y> = CIRCULAR SHIFT <x>  <nshift>
    where <x> is a response variable;
          <nshift> is a number or parameter that specifies how
              how many elements to shift;
    and   <y> is a variable that contains the shifted values.
 
    The sign of NSHIFT specifies the direction.  If NSHIFT is
    negative, the shift is down (or left) and if NSHIFT is positive
    the shift is up (or right).  If NHIFT is zero, then Y = X.

Examples:
    LET Y = CIRCULAR SHIFT X NSHIFT

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SHIFT              = Perform a shift of a variable.
    SCATTER            = Save data from a variable to specified
                         rows of another variable based on an
                         index variable.
    SEQUENCE           = Generate a patterned sequence of values.
    SORT               = Sort a column of numbers.
    RANK               = Rank a column of numbers.
    CODE               = Code a column of numbers.
    SUBSET             = Specifies a subset to be included in a plot,
                         analysis, or LET command.
    RETAIN             = Retain specified rows or a subset of a
                         variable.
 
Applications:
    Data Transformation
 
Implementation Date:
    2009/2
 
Program:
    let y = normal random numbers for i = 1 1 10
    let nshift = 3
    let y2 = circular shift y nshift
    let nshift = -3
    let y3 = circular shift y nshift
    set write decimals 3
    print y y2 y3

-----CIRCLE-------------------------------------------------------
 
CIRCLE
 
Name:
    CIRCLE
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Draws a circle.
 
Description:
    The 2 pairs of coordinates define the (x,y) values for the two
    ends of the diameter of the circle.

    Coordinates for the circle can be specified in the following ways:

      1. Screen units mean that the coordinates are specified in 0 to
         100 screen units (Dataplot defines a 0 to 100 coordinate
         system for the output device in both the horizontal and vertical
         directions).

         Data units mean that the coordinates are specified in units of
         the most recent plot.

      2. Absolute units means that the coordinates for both points are
         given in absolute units (either screen or data units).  Relative
         units mean that the coordinates of the first point are given in
         absolute coordinates.  The coordinates for the second point are
         then relative to the first point rather than being absolute
         coordinates.

Syntax 1:
    CIRCLE   <x1>   <y1>   <x2>   <y2>
    where <x1> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for one end of the
               diameter of the circle;
          <y1> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for one end of the
               diameter of the circle;
          <x2> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for the other end of the
               diameter of the circle;
    and   <y2> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for the other end of the
               diameter of the circle.

    This syntax is used for absolute screen units.
 
Syntax 2:
    CIRCLE DATA  <x1>   <y1>   <x2>   <y2>
    where <x1> is a number or parameter that specifies the x coordinate for
               one end of the diameter of the circle;
          <y1> is a number or parameter that specifies the y coordinate for
               one end of the diameter of the circle;
          <x2> is a number or parameter that specifies the x coordinate for
               the other end of the diameter of the circle;
    and   <y2> is a number or parameter that specifies the y coordinate for
               the other end of the diameter of the circle.
 
    This syntax is used for absolute data units.
 
Syntax 3:
    CIRCLE RELATIVE  <x1>   <y1>   <x2>   <y2>
    where <x1> is a number or parameter that specifies the x coordinate for
               one end of the diameter of the circle;
          <y1> is a number or parameter that specifies the y coordinate for
               one end of the diameter of the circle;
          <x2> is a number or parameter that specifies the x coordinate for
               the other end of the diameter of the circle;
    and   <y2> is a number or parameter that specifies the y coordinate for
               the other end of the diameter of the circle.
 
    This syntax is used for relative screen units.
 
Syntax 4:
    CIRCLE DATA RELATIVE <x1>   <y1>   <x2>   <y2>
    where <x1> is a number or parameter that specifies the x coordinate for
               one end of the diameter of the circle;
          <y1> is a number or parameter that specifies the y coordinate for
               one end of the diameter of the circle;
          <x2> is a number or parameter that specifies the x coordinate for
               the other end of the diameter of the circle;
    and   <y2> is a number or parameter that specifies the y coordinate for
               the other end of the diameter of the circle.
 
    This syntax is used for relative data units.
 
Examples:
    CIRCLE 50 50 60 60
    CIRCLE 50 50 60 50
    CIRCLE 20 20 30 30
    CIRCLE 50 50 10 10
    CIRCLE RELATIVE 50 50 10 10
    CIRCLE DATA 250 125 345 420
 
Note:
    The line style (i.e., solid, dash), color, and thickness are
    controlled by the LINE, LINE COLOR, and LINE THICKNESS commands.
    The REGION FILL command can be used to generate solid filled
    circles (circles can not currently be filled with hatch patterns).
 
Note:
    If you use a software font, circles can be embedded in text (e.g.,
    the LEGEND or TEXT command) by entering the string CIRC().  To get
    filled circles, enter LEGEND FILL SOLID (for legends) or FILL ON
    (for TEXT).  Circles can also be used as plot characters (e.g.,
    CHARACTERS CIRCLE), in which case the attributes are set with the
    various CHARACTER commands.
 
Note:
    By default, Dataplot applies a correction factor to circles based on
    the ratio of vertical pixels to horizontal pixels.  When the number of
    pixels is not equal in the horizontal and vertical directions, this has
    the advantage of maintaining the circular appearance of the circle.
    However, the disadvantage is that the coordinates of the circle may
    not be as expected.

    If this correction is not applied, the coordinates of the circle will
    be as expected.  However, the circle may have an elliptic rather than
    than circular shape.

    You can turn off this correction with the command

        SET CIRCLE CORRECTION OFF

    To turn the correction back on, enter

        SET CIRCLE CORRECTION ON

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    POINT            = Draws a point.
    ARROW            = Draws an arrow.
    TRIANGLE         = Draws a triangle.
    BOX              = Draws a box.
    HEXAGON          = Draws a hexagon.
    SEMI-CIRCLE      = Draws a semi-circle.
    ARC              = Draws an arc.
    ELLIPSE          = Draws an ellipse.
    OVAL             = Draws an oval.
    DIAMOND          = Draws a diamond.
    DRAW             = Draws a line.
    MOVE             = Moves to a point.
    LINES            = Sets the line type for figures and plot lines.
    LINE THICKNESSES = Sets the line thickness for figures and  plot
                       lines.
    LINE COLOR       = Sets the line colors for figures and plot lines.
    CROSS-HAIR       = Activates and reads the cross-hair.
    TEXT             = Writes a text string.
 
Applications:
    Presentation Graphics
 
Implementation Date:
    Pre-1987
    1997/07: Added support for data units
    2014/08: Added support for SET CIRCLE CORRECTION command
 
Program 1:
    ERASE
    CIRCLE 10 10 20 20
    CIRCLE 60 10 80 30
    .
    THICKNESS 0.7
    CIRCLE 10 30 20 40
    THICKNESS 0.2
    .
    LINE DASH
    CIRCLE 10 50 20 60
    LINE SOLID
    .
    LINE COLOR BLUE
    CIRCLE 10 80 20 90
    LINE COLOR BLACK
    .
    REGION FILL ON
    CIRCLE 30 30 35 35
    REGION FILL COLOR RED
    CIRCLE RELATIVE 40 40 20 20
    .
    FILL ON
    FONT SIMPLEX
    MOVE 40 80
    TEXT CIRC() DRAW A CIRCLE WITH THE TEXT COMMAND
 
Program 2:
    .
    . Step 1:   Read the data
    .
    skip 25
    read circle.dat x1 y1 x2 y2 x3 y3 x4 y4
    skip 0
    .
    let x1=x1/1000
    let y1=y1/1000
    let x2=x2/1000
    let y2=y2/1000
    let x3=x3/1000
    let y3=y3/1000
    let x4=x4/1000
    let y4=y4/1000
    .
    . Step 2:   Plot points
    .
    xgrid
    ygrid
    title Overlapping Plot Circles
    x1Label X
    y1Label Y
    
    xlimits  322  335
    ylimits  6389 6404
    .
    characters . . * *
    character color black black red blue
    lines blank blank blank
    pre-sort off
    .
    retain x3 y3 subset x3 > -100 subset y3 > -100
    retain x4 y4 subset x4 > -100 subset y4 > -100
    .
    plot y1 x1 and
    plot y2 x2 and
    plot y3 x3 and
    plot y4 x4
    .
    . Step 3:   Draw circles on plot, note the elliptical
    .           shape of the circles
    .
    set circle correction off
    thickness 0.1
    character blank
    line solid
    .
    . Center_1 327.4122 6397.1038
    .
    line color red
    circle data 322.4122 6397.1038 332.4122 6397.1038
    .
    . Center_2 328.4241 6395.2006
    
    line color blue
    circle data 323.4241 6395.2006 333.421 6395.2006
 
-----CLASS LOWER-------------------------------------------------------
 
CLASS LOWER
 
NAME:
    CLASS LOWER
 
TYPE:
    Support Command
 
Purpose:
    Specifies the lower limit of the left-most class to be included in
    subsequent histograms, frequency plots, and pie charts.
 
Syntax:
    CLASS LOWER   <x>
    where <x>  is a number or parameter that specifies the desired
    limit in units of the horizontal axis data.
 
Examples:
    CLASS LOWER 0.5
    CLASS LOWER 15
 
Note:
    DATAPLOT's default class width algorithm tends to leave a lot of
    empty classes at the extremes of the distribution.  Using the CLASS
    LOWER and CLASS UPPER commands provides a simple way to avoid this
    problem.
 
Default:
    The default lower limit is the sample mean minus 6 times the
    sample standard deviation.
 
Synonyms:
    None
 
Related Commands:
    CLASS UPPER     = Sets the upper class maximum for histograms,
                      frequency plots, and pie charts.
    CLASS WIDTH     = Sets the width for histograms, frequency plots,
                      and pie charts.
    MINIMUM         = Sets the frame minimum for all plots.
    MAXIMUM         = Sets the frame maximum for all plots.
    LIMITS          = Sets the frame limits for all plots.
    HISTOGRAM       = Generate a histogram.
    FREQUENCY PLOT  = Generate a frequency plot.
    PIE CHART       = Generate a pie chart.
    PLOT            = Generates a plot (including bar plots).
    BARS            = Sets on/off switches for plot bars.
    BAR WIDTH       = Sets widths for plot bars.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    LET Y = NORMAL RANDOM NUMBERS FOR I = 1 1 1000
    CLASS LOWER = -3.5
    HISTOGRAM Y
 
-----CLASSIFICATION SCATTER PLOT--------------------------------------
 
CLASSIFICATION SCATTER PLOT
 
Name:
    CLASSIFICATION SCATTER PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a classification scatter plot.
 
Description:
    This plot is a variant of the dex scatter plot.  For the dex scatter
    plot, the first variable is a response variable and the remaining
    variables are factor variables.  The factor variables are typically
    qualitative variables (this plot is most typically used in the
    context of 2-level designed experiments, but it can be used for the
    case when there are more than two levels for some factors).  For the
    dex scatter plot, a separate subplot is drawn for each factor with the
    subplot for factor k centered horizontally at x=k.  Each subplot has a
    given horizontal width (defined by the DEX WIDTH command, defaults to
    0.5).  For example, the subplot for factor 2 ranges from 1.8 to 2.2 on
    the horizontal axis.  The levels of the factor are assigned an x
    coordinate within this range (from lowest to highest).  Then within
    each subplot:

       Vertical   axis = value of the response variable;
       Horizontal axis = value of the level of a given factor.

    The classification scatter plot reverses the role of the reponse
    variable and the factor variables.  For the classification scatter
    plot, the Y axis variable is assumed to be qualitative (i.e., a
    specific number of levels) and the factor variables are assumed
    to be continuous (the plot will still work if some of the factor
    variables are also qualitative).  The context is the common
    classification problem where we use the values of the factor
    variables to classify which group an observation belongs to.

    For this plot, the subplots are based on the distinct levels of
    the response variable.  For example, suppose the Y axis variable (Y)
    has two possible values.  Then for the first factor variable (X1),
    we plot the values of X1 corresponding to Y = 1 with x-coordinate
    0.8 and the we plot the values of X1 corresponding to Y = 2 with
    x-coordinate 1.2.  A similar subplot is created for each factor
    variable.

Syntax:
    CLASSIFICATION SCATTER PLOT <y> <x1> ... <xk>
                                <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable (qualitative);
          <x1> ... <xk> is a sequence of variables (either continuous
               or qualitative);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    CLASSIFICATION SCATTER PLOT Y X1 X2
    CLASSIFICATION SCATTER PLOT Y X1 X2 X3
    CLASSIFICATION SCATTER PLOT Y X1 X2 X3 X4
    CLASSIFICATION SCATTER PLOT Y X1 TO X4
 
Note:
    The TO syntax is allowed for the list of factor variables (see the
    EXAMPLES above).

Note:
    The CHARACTER and LINE settings can be used to control the
    appearance of the plot.  If there are m levels for the response
    variable and k factor variables, the first m*k traces define the
    values corresponding to each response/factor variable combination
    (i.e., each column of the plot is assigned a different trace where
    the numbering is from left to right on the plot).  This can be useful
    if would like to color code the levels of the response variable or
    give them some other identifying value.  The m*k + 1 trace draws a
    reference line.  In this case, the reference line is the mean y value
    for the points on the plot.  This is demonstrated in the Program
    example below.
 
    For each trace, the mean, standard deviation, minimum, and maximum
    value for that trace is written to the file dpst4f.dat.  This can be
    useful for annotating the plot 

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CLASSIFICATION STATISTIC PLOT  = Generate a classification plot for a
                                     statistic.
    DEX SCATTER PLOT               = Generates a dex scatter plot.
    DEX ... PLOT                   = Generates a dex plot for a
                                     statistic.
    DEX WIDTH                      = Specifies the width of levels in a
                                     dex plot.
    LINES                          = Sets the type for plot lines.
    CHARACTER                      = Sets the type for plot characters

Applications:
    Classification
 
Implementation Date:
    2019/03
 
Program:
    . Step 1:   Read the data
    .
    SET WRITE DECIMALS 3
    DIMENSION 40 COLUMNS
    SKIP 25
    READ IRIS.DAT X1 TO X4 Y
    SKIP 0
    .
    LET NFACT = 4
    LET STRING T1 = Sepal Length
    LET STRING T2 = Sepal Width
    LET STRING T3 = Petal Length
    LET STRING T4 = Petal Width
    .
    LOOP FOR K = 1 1 NFACT
        LET MEAN^K = MEAN X^K; LET MEAN^K = ROUND(MEAN^K,3)
        LET SD^K = SD X^K; LET SD^K = ROUND(SD^K,3)
    END OF LOOP
    .
    . Step 2:   Set plot control features
    .
    CASE ASIS
    TITLE CASE ASIS
    LABEL CASE ASIS
    TIC MARK LABEL CASE ASIS
    TITLE OFFSET 2
    .
    CHARACTERS 1 2 3 1 2 3 1 2 3 1 2 3 BLANK
    CHARACTER COLOR BLUE RED GREEN BLUE RED GREEN BLUE RED GREEN BLUE RED GREEN
    LINES COLOR BLUE RED GREEN BLUE RED GREEN BLUE RED GREEN BLUE RED GREEN
    LET PLOT LINE 13 = BLANK
    XLIMITS 1 NFACT
    MAJOR XTIC MARK NUMBER NFACT
    MINOR XTIC MARK NUMBER 0
    TIC MARK OFFSET UNITS DATA
    XTIC OFFSET 1 1
    XTIC LABEL FORMAT ALPHA
    XTIC LABEL CONTENT F1:sp()Sepalcr()Length F2:sp()Sepalcr()Width ...
                       F3:sp()Petalcr()Length F4:sp()Petalcr()Width
    Y1LABEL Standardized Feature
    X1LABEL Features
    X1LABEL DISPLACEMENT 12
    YLIMITS -4 4
    .
    LET X1 = STANDARDIZE X1
    LET X2 = STANDARDIZE X2
    LET X3 = STANDARDIZE X3
    LET X4 = STANDARDIZE X4
    .
    . Step 3:   Generate plots
    .
    TITLE Classification Scatter Plot: Standardized Units
    CLASSIFICATION SCATTER PLOT Y X1 X2 X3 X4
    .
    TITLE IRIS Classification Analysis Based on Standardized Data
    .
    CLASSIFICATION SCATTER PLOT Y X1 X2 X3 X4
    .
    LET XCOOR1 = 86
    LET XCOOR2 = 88
    LET YCOOR  = 89
    LET YINC   = 2.5
    JUSTIFICATION LEFT
    COLOR BLACK
    HEIGHT 2
    .
    LOOP FOR K = 1 1 NFACT
        MOVE XCOOR1 YCOOR
        TEXT F^K: ^T^K
        LET YCOOR = YCOOR - YINC
        MOVE XCOOR2 YCOOR
        TEXT Mean = ^MEAN^K
        LET YCOOR = YCOOR - YINC
        MOVE XCOOR2 YCOOR
        TEXT SD   = ^SD^K
        LET YCOOR = YCOOR - YINC
    END OF LOOP
    .
    COLOR BLUE
    MOVE XCOOR1 45
    TEXT Cat1: Setosa
    .
    COLOR RED
    MOVE XCOOR1 42.5
    TEXT Cat2: Versicolor
    .
    COLOR GREEN
    MOVE XCOOR1 40
    TEXT Cat3: Virginica
    .
    skip 1
    read dpst4f.dat ymean ysd ymin ymax
    skip 0
    let ymean = round(ymean,1)
    let ysd   = round(ysd,1)
    let ymin  = round(ymin,1)
    let ymax  = round(ymax,1)
    .
    character blank all
    character size 1.5 all
    character just right all
    character color blue blue blue blue red red red red green green green green
    let nlen = 1
    let sblank = blank string nlen
    .
    set substitute format f4.1
    loop for l = 1 1 nfact
        loop for k = 1 1 3
            let k2 = (l-1)*3 + k
            let aval = ymax(k2)
            let bval = ymean(k2)
            let cval = ymin(k2)
            let dval = ysd(k2)
            let string s2 = ^aval ^bval ^cval ^dval
            if k = 1
               let string s = ^s2
            else
               let s = string concatenate s sblank s2
            end of if
        end of loop
        character ^s
        let xpos = sequence 0.8 4 0.2 1.21
        let xpos = (l - 1) + xpos
        let ypos = sequence 26 -1.5 21 for i = 1 1 12
        let tag = sequence 1 1 12
        drawds symbol xpos ypos tag
        delete s s2
    end of loop
    .
    color black
    height 1.5
    justification left
    move xcoor1 25.5
    text Max
    move xcoor1 24
    text Mean
    move xcoor1 22.5
    text Min
    move xcoor1 21
    text SD
    .
    height 2
    just left
    move 2 7.5
    text if F3 <= -0.7, then cat = 1
    move 2 5
    text if F4 >=  0.4, then cat = 3
    move 2 2.5
    text else                cat = 2
    .
    line color black
    line dotted
    drawsdsd 15 0.4 85 0.4
    drawsdsd 15 -0.7 85 -0.7

-----CLASSIFICATION STATISTIC PLOT-----------------------------------
 
CLASSIFICATION STATISTIC PLOT
 
Name:
    CLASSIFICATION <statistic> PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a classification plot for a given statistic.
 
Description:
    A dex statistic plot is a graphical method for representing a
    design of experiment problem.  The first variable is a response
    variable while the remaining variables (must be at least one)
    represent levels of factors.  A separate subplot is drawn for each
    factor with the subplot for factor k centered horizontally at x=k.
    Each subplot has a given horizontal width (defined by the DEX WIDTH
    command, defaults to 0.5).  For example, the subplot for factor 2
    ranges from 1.75 to 2.25 on the horizontal axis.  The levels of the
    factor are assigned an x coordinate within this range (from lowest
    to highest).  Then within each subplot:

       Vertical   axis = value of the computed statistic from the
                         response variable (i.e., compute the statistic
                         for all values with the same level for a given
                         factor);
       Horizontal axis = value of the level of a given factor.

    The classification statistic plot reverses the role of the reponse
    variable and the factor variables.  For the classification statistic
    plot, the Y axis variable is assumed to be qualitative (i.e., a
    specific number of levels) and the factor variables are assumed
    to be continuous (the plot will still work if some of the factor
    variables are also qualitative).  The context is the common
    classification problem where we use the values of the factor
    variables to classify which group an observation belongs to.
    <P>
    For this plot, the subplots are based on the distinct levels of
    the response variable.  For example, suppose the Y axis variable (Y)
    has two possible values.  Then for the first factor variable (X1),
    we plot the values of X1 corresponding to Y = 1 with x-coordinate
    0.8 and the we plot the values of X1 corresponding to Y = 2 with
    x-coordinate 1.2.  A similar subplot is created for each factor
    variable.

    Although this plot can be generated with any univariate statistic
    supported by Dataplot, it is most typically used for a location
    statistic such as the mean or the median.

    This plot graphically shows the following:

       1) How the statistic for the factor variable varies with the
          level of the response variable.

       2) How the statistic for the levels of the response variable
          varies between the factor variables.
 
Syntax:
    CLASSIFICATION <stat> PLOT <y> <x1> ... <xk>
                               <SUBSET/EXCEPT/FOR qualification>
    where <y> is the (qualitative) response variable;
          <x1> ... <xk> is a list of 1 to k factor variables;
          <stat> is the desired statistic;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    CLASSIFICATION MEAN PLOT Y X1 X2
    CLASSIFICATION MEAN PLOT Y X1 TO X8
    CLASSIFICATION MEDIAN PLOT Y X1 X2
    CLASSIFICATION SD PLOT Y X1 X2 X3

Note:
    For a list of the supported statistics enter

         HELP STATISTICS

    Only statistics based on a single response variable are available
    with the CLASSIFICATIONS STATISTIC PLOT.

Note:
    The TO syntax is allowed for the list of factor variables (see the
    EXAMPLES above).
 
Note:
    The CHARACTER and LINE settings can be used to control the
    appearance of the plot.  The first trace is typically drawn with a
    blank line and some type of character set (the choice of character
    is a matter of user preference).  The second trace draws a
    horizontal line at the value for the specified statistic for the
    entire response variable.  This is typically drawn with a blank
    character and a solid line (some analysts may prefer a dashed or
    dotted line).  In any event, the user must explicitly set character
    and line settings (they default to all lines solid and all
    characters blank).
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CLASSIFICATION SCATTER PLOT  = Generates a classification scatter plot.
    DEX ... PLOT                 = Generates a dex plot for a statistic.
    LINES                        = Sets the type for plot lines.
    CHARACTER                    = Sets the type for plot characters.
    DEX WIDTH                    = Specifies the width of levels in a
                                   dex plot.

Applications:
    Classification
 
Implementation Date:
    2019/03
 
Program:
    case asis
    title case asis
    label case asis
    title offset 2
    set write decimals 3
    .
    . Step 1:   Read the data
    .
    SKIP 25
    READ IRIS.DAT X1 TO X4 Y
    SKIP 0
    .
    . Step 2:   Set plot control features
    .
    CHARACTERS X BLANK
    LINES SOLID SOLID
    LET NFACT = 4
    XLIMITS 1 NFACT
    MAJOR XTIC MARK NUMBER NFACT
    MINOR XTIC MARK NUMBER 0
    TIC MARK OFFSET UNITS DATA
    XTIC OFFSET 1 1
    XTIC LABEL FORMAT ALPHA
    XTIC LABEL CONTENT 1sp()2sp()3cr()Sepalcr()Length 1sp()2sp()3cr()Sepalcr()Width ...
                       1sp()2sp()3cr()Petalcr()Length 1sp()2sp()3cr()Petalcr()Width
    X1LABEL DISPLACEMENT 15
    X1LABEL FACTORS
    .
    . Step 3:   Generate plots
    .
    TITLE Classification Mean Plot
    CLASSIFICATION MEAN PLOT Y X1 X2 X3 X4
 
-----CLASS UPPER-------------------------------------------------------
 
CLASS UPPER
 
Name:
    CLASS UPPER
 
Type:
    Support Command
 
Purpose:
    Specifies the upper limit of the right-most class to be included in
    subsequent histograms, frequency plots, and pie charts.
 
Syntax:
    CLASS UPPER   <x>
    where <x> is a number or parameter that specifies the desired limit
    in units of the horizontal axis data.
 
Examples:
    CLASS UPPER 0.5
    CLASS UPPER 15
 
Note:
    DATAPLOT's default class width algorithm tends to leave a lot of
    empty classes at the extremes of the distribution.  Using the CLASS
    LOWER and CLASS UPPER commands provides a simple way to avoid this
    problem.
 
Default:
    The default lower limit is the sample mean plus 6 times the
    sample standard deviation.
 
Synonyms:
    None
 
Related Commands:
    CLASS LOWER     = Sets the lower class maximum for histograms,
                      frequency plots, and pie charts.
    CLASS WIDTH     = Sets the width for histograms, frequency plots,
                      and pie charts.
    MINIMUM         = Sets the frame minimum for all plots.
    MAXIMUM         = Sets the frame maximum for all plots.
    LIMITS          = Sets the frame limits for all plots.
    HISTOGRAM       = Generate a histogram.
    FREQUENCY PLOT  = Generate a frequency plot.
    PIE CHART       = Generate a pie chart.
    PLOT            = Generates a plot (including bar plots).
    BARS            = Sets on/off switches for plot bars.
    BAR WIDTH       = Sets widths for plot bars.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    LET Y = NORMAL RANDOM NUMBERS FOR I = 1 1 1000
    CLASS UPPER = 3.5
    HISTOGRAM Y
 
-----CLASS WIDTH-------------------------------------------------------
 
CLASS WIDTH
 
Name:
    CLASS WIDTH
 
Type:
    Support Command
 
Purpose:
    Specifies the class width in subsequent histograms, frequency
    plots, and pie charts.
 
Syntax:
    CLASS WIDTH   <x>
    where <x> is a number or parameter that specifies the desired width
    in units of the horizontal axis data.
 
Examples:
    CLASS WIDTH 1
    CLASS WIDTH 10
 
Default:
    The default class width is 0.3 times the sample standard deviation.
 
Synonyms:
    None
 
Related Commands:
    CLASS LOWER     = Sets the lower class maximum for histograms,
                      frequency plots, and pie charts.
    CLASS UPPER     = Sets the upper class maximum for histograms,
                      frequency plots, and pie charts.
    MINIMUM         = Sets the frame minimum for all plots.
    MAXIMUM         = Sets the frame maximum for all plots.
    LIMITS          = Sets the frame limits for all plots.
    HISTOGRAM       = Generate a histogram.
    FREQUENCY PLOT  = Generate a frequency plot.
    PIE CHART       = Generate a pie chart.
    PLOT            = Generates a plot (including bar plots).
    BARS            = Sets on/off switches for plot bars.
    BAR WIDTH       = Sets widths for plot bars.
 
Applications:
    Distributional Plots
 
Implementation Date:
    Pre-1987
 
Program:
    LET Y = NORMAL RANDOM NUMBERS FOR I = 1 1 1000
    CLASS WIDTH = 0.5
    HISTOGRAM Y
 
-----CLAUSN (LET)--------------------------------
 
CLAUSN
 
Name:
    CLAUSN (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Clausen integral.
 
Description:
    The Clausen integral is defined as:

        f(x) = INTEGRAL[LN(ABS(2*SIN(t/2)))dt],   x >= 0

    where the integral is defined from 0 to x.

    Dataplot computes this function using ACM Algorithm 757 (see
    Reference: below).
 
Syntax:
    LET <y> = CLAUSN(<x>)    <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-negative number, variable or parameter;
          <y> is a variable or a parameter (depending on what <x> 
               is) where the computed Clausen integral values are
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CLAUSN(2)
    LET A = CLAUSN(X) 
    LET X2 = CLAUSN(X) FOR X1 = 0.1 0.1 3.0
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ABRAM      = Compute the Abramowitz integral.
    DEBYE      = Compute the Debye function.
    EXP3       = Compute the cubic exponential integral.
    GOODST     = Compute the Goodwin and Stanton integral.
    LOBACH     = Compute the Lobachevski integral.
    SYNCH1     = Compute the synchrotron radiation function.
    SYNCH2     = Compute the synchrotron radiation function.
    STROM      = Compute the Stromgren integral.
    TRAN       = Compute the transport integral.
 
Reference:
    "ACM Transactions of Mathematical Software", Allan MacLead,
    Vol. 22, No. 3, September, 1996, pp. 288-301.
 
Applications:
    Special Functions
 
Implementation Date:
    1999/6
 
Program:
    TITLE AUTOMATIC
    PLOT CLAUSN(X) FOR X = 0 0.01 10
 
-----CLIPBOARD-------------------------------------------------------
 
CLIPBOARD
 
Name:
    READ CLIPBOARD
    READ STRING CLIPBOARD
    SET CLIPBOARD SKIP
    WRITE CLIPBOARD

    CLIPBOARD RUN
    CLIPBOARD PAUSE
    CLIPBOARD RESUME
    SET CLIPBOARD RUN CLEAR

    CLIPBOARD CLEAR
    LIST CLIPBOARD
    COPY CLIPBOARD <file>
    COPY <file> CLIPBOARD
    PROBE CLIPBOARD LINES

    CLIPBOARD LOOP
    CLIPBOARD LOOP END
    SET CLIPBOARD LOOP LINES
    SET CLIPBOARD DELAY
 
Type:
    Support and I/O Commands
 
Purpose:
    Read variables, strings, and commands from the system clipboard or
    write parameters, strings, or variables to the system clipboard.
 
Description:
    It is sometimes convenient to read data (or commands) from the
    system clipboard.  Dataplot has implemented a number of commands
    to access data from the clipboard.  Note that this capability is
    operating system and compiler dependent.  These commands are currently
    supported for the Windows operating system for Dataplot executables
    built with the Intel Fortran compiler.  Support for the X11 clipboard
    under Linux operating systems is anticipated for subsequent releases.

    Potential uses for the clipboard include:

       1. Dataplot does not read data from spreadsheets (e.g., Excel)
          directly.  Copying data from the spreadsheet to the system
          clipboard and then reading the clipboard from Dataplot can
          provide a relatively easy way to extract data from the
          spreadsheet.

       2. The clipboard can provide a method for passing data between
          Dataplot and an external application.

    SYSTEM CLIPBOARD

    Operating systems typically use the clipboard to implement cut and
    paste operations.  These can sometimes be used with Dataplot.

    For example, to read data from the clipboard you can do something
    like the following

        READ  Y X1 X2
          <perform system paste operation>
        END OF DATA

    Note that this works for Linux systems where Dataplot is built with
    the gfortran compiler.  However, it does not work with the Windows
    version of Dataplot built with the current version of the Intel
    Fortran compiler (it did work with some earlier versions of the Intel
    compiler).

    Likewise, if you have Dataplot commands stored in the clipboard, then
    you can paste into the current Dataplot terminal window.  Again this
    works under Linux systems.  However it does not work under Windows
    with the Intel compiler.

    DATAPLOT CLIPBOARD COMMANDS

    Although system cut and paste operations can be adequate for many
    purposes, it can also be useful to have programatic access to the
    clipboard.  For example, the system cut and paste does not work
    correctly for the Windows version of Dataplot.  In addition,
    programatic access can be useful for communicating with non-Dataplot
    applications.

    The commands above can be divided into several categories:

       1. The READ CLIPBOARD, READ STRING CLIPBOARD, and SET CLIPBOARD SKIP
          are used to read data or strings from the clipboard.

          The WRITE CLIPBOARD command can be used to write strings, 
          parameters, or variables to the the clipboard.

       2. The CLIPBOARD RUN command is used to run the contents of the
          clipboard as a Dataplot macro.  If the command CLIPBOARD PAUSE
          is encountered while executing the CLIPBOARD RUN command, then
          Dataplot will revert to reading commands from the terminal until
          a CLIPBOARD RESUME command is entered.  At that point, Dataplot
          will revert back to reading commands from the clipboard.  The
          SET CLIPBOARD RUN CLEAR <ON/OFF> command specifies whether the
          clipboard is cleared (ON) or not cleared (OFF) after a
          CLIPBOARD RUN command (the default is OFF).

       3. The CLIPBOARD CLEAR is used to clear the current contents of the
          clipboard.  The LIST CLIPBOARD command is used to list the
          current contents of the clipboard.  The CLIPBOARD COPY command
          is used to copy the contents of the clipboard to a user-specified
          file or to copy the contents of a user-specified file to the
          clipboard.  The PROBE CLIPBOARD LINES returns the number of lines
          currently in the clipboard.

       4. The CLIPBOARD LOOP command is used to interogate the clipboard.
          That is, the clipboard will be continuously checked until it
          is not empty.  If the clipboard is not empty, then the contents
          of the clipboard are executed as a Dataplot macro (when the end
          of the clipboard is reached, the clipboard is cleared).  The
          CLIPBOARD LOOP END command is used terminate the CLIPBOARD LOOP
          command.

          The CLIPBOARD LOOP capability is primarily intended to allow an
          external application to interactively send commands to a Dataplot
          session.  This is a feature that most Dataplot user's will
          typically not use directly.

Syntax 1:
    READ  CLIPBOARD  <x1>   <x2>   ... <xk>
    where <x1>, <x2>, ... <xk> are the desired names for the variables
                 into which the data are read.

    This syntax is used to read numeric variables from the clipboard.

    Note that the clipboard should contain only numeric variables.  If a
    non-numeric character is encountered, an error will be generated and
    the READ will not be performed.

    This capability is useful for accessing parts of a spreadsheet.  For
    example, many spreadsheets will contain summary tables and graphs.
    Writing these types of spreadsheets to ASCII files tends to result in
    files that need substantial clean-up before they can be read by
    Dataplot.  Alternatively, you can copy the relevant data from the
    spreadsheet to the clipboard and then use the READ CLIPBOARD command
    to read that data into Dataplot.

    Generally, this command works best when rectangular areas (i.e.,
    the variables do not contain missing cells).  Missing cells denoted
    by commas will be read correctly.  However, spreadsheets will typically
    separate values with tabs rather than commas when copying to the
    clipboard.  In this case, missing data will not be handled correctly.
    If you have spreadsheet columns of unequal length, you may need to copy
    and read the columns individually.

    The SET READ FORMAT and ROW LIMITS commands are not used when reading
    variables from the clipboard.  By default the SKIP command is ignored.
    If you would like the SKIP command to be honored, enter the command

         SET CLIPBOARD SKIP ON

    To revert to ignoring the SKIP command, enter the command

         SET CLIPBOARD SKIP OFF

Syntax 2:
    READ  STRING CLIPBOARD  <str1>   <str2>   ... <strk>
    where <str1>, <str2>, ... <strk> is a list of strings to be read.

    This syntax is used to read strings into Dataplot from the clipboard.

    String one is read from the first line of the clipboard, string two is
    read from the second line of the clipboard, and so on.

    Individual strings are limited to a maximum of 255 characters.

    By default the SKIP command is ignored.  If you would like the SKIP
    command to be honored, enter the command

         SET CLIPBOARD SKIP ON

    To revert to ignoring the SKIP command, enter the command

         SET CLIPBOARD SKIP OFF

Syntax 3:
    WRITE CLIPBOARD  <st1>   <st2>   ... <stk>
    where <st1>, <st2>, ... <stk> is a list of one or more strings and
          parameters to be written.

    This syntax is used to write strings and/or parameters to the clipboard.

    Dataplot will first print all specified strings.  It will then print all
    specified parameters.  Each string or parameter will be printed on a
    separate line.  Parameters are printed using an E15.7 format.

    The total number of characters written to the clipboard is currently
    limited to 4096 characters.  Dataplot will automatically add CR/LF to
    the end of each line written to the clipboard and an ending null byte.
    These Dataplot inserted characters count against the total character
    count.

    Note that this command will erase the current contents of the clipboard
    before writing the new strings and parameters.

    Writing strings and parameters cannot be mixed with writing variables
    to the clipboard.  If the list of names includes both
    strings/parameters and variables, the variables will overwrite the
    strings and parameters.

Syntax 4:
    WRITE CLIPBOARD  <st1>   <st2>   ... <stk>
    where <st1>, <st2>, ... <stk> is a list of one or more variables.

    This syntax is used to write variables to the clipboard.

    Numeric values are written using an E15.7 format.  The SET WRITE
    FORMAT and SET WRITE DECIMALS commands are ignored when writing to
    the clipboard.

    The total number of characters written to the clipboard is currently
    limited to 5000000 characters.  Dataplot will automatically add CR/LF to
    the end of each line written to the clipboard and an ending null byte.
    These Dataplot inserted characters count against the total character
    count.

    Note that this command will erase the current contents of the clipboard
    before writing the new strings and parameters.

    Writing strings and parameters cannot be mixed with writing variables
    to the clipboard.  If the list of names includes both
    strings/parameters and variables, the variables will overwrite the
    strings and parameters.

    Matrices are not currently written to the clipboard.

Syntax 5:
    CLIPBOARD CLEAR

    If this command is entered, the current contents of the clipboard will
    be deleted.

Syntax 6:
    LIST CLIPBOARD

    If this command is entered, the current contents of the clipboard will
    be listed to the screen.  A maximum of 240 characters for a given line
    will be printed.

    The SET HELP LINES command can be used to specify how many lines are
    printed at once.  Enter HELP HELP LINES for details.  The default is
    20 lines.

Syntax 7:
    COPY CLIPBOARD <file>
    where <file> specifies the name of the file where the clipboard
                 contents will be copied.

    If this command is entered, the current contents of the clipboard will
    be copied to the the specified file.  Individual lines will be
    truncated at 255 characters.

Syntax 8:
    COPY <file> CLIPBOARD
    where <file> specifies the name of the file which will be copied to the
                 clipboard.

    If this command is entered, the contents of the specified file will be
    copied to the clipboard.  Individual lines will be truncated at 255
    characters.

Syntax 9:
    PROBE CLIPBOARD LINES

    This command will return the number of lines in the clipboard.  The
    result will be saved in the parameter PROBEVAL.

Syntax 9:
    CLIPBOARD RUN

    If this command is entered, Dataplot will execute each line in the
    clipboard as a Dataplot command.

    If this command is called from within a Dataplot macro (i.e., from a
    CALL <file> command), it will only be honored if the macro is a first
    level macro.  That is, if you have nested CALL commands, CLIPBOARD RUN
    must be in the first macro called.

Syntax 10:
    CLIPBOARD PAUSE

    If Dataplot is executing commands from the clipboard, this command is
    used to revert reading commands from the terminal (or from a macro).

Syntax 11:
    CLIPBOARD RESUME

    If a CLIPBOARD PAUSE command was entered from the clipboard to revert
    to reading commands from the terminal, then this command can be used
    to resume executing the commands in the clipboard.

Syntax 12:
    CLIPBOARD LOOP

    If the CLIPBOARD LOOP command is entered, then the following algorithm
    is used:

       1. If the clipboard is currently active, then retrieve commands from
          the clipboard.

       2. If the clipboard is not currently active, then pause and check if
          anything is in the clipboard.  The length of the pause is
          controlled by the SET CLIPBOARD DELAY command.

       3. If the clipboard is empty, restart the process.  If the clipboard
          is not empty, then begin processing the contents of the clipboard
          as Dataplot commands.

Syntax 13:
    CLIPBOARD LOOP END

    This command is used to exit the CLIPBOARD LOOP command.

Syntax 14:
    SET CLIPBOARD LOOP LINES <value>
    where <value> is a number or parameter.

    This command specifies the maximum number of iterations for the
    CLIPBOARD LOOP.  That is, it specifies the maximum number
    of times the clipboard will be interogated.  If this maximum
    is reached, the CLIPBOARD LOOP command will be ended (it can
    be explicitly ended with the CLIPBOARD LOOP END command).

Syntax 15:
    SET CLIPBOARD DELAY <value>
    where <value> is a number or parameter.

    If a CLIPBOARD LOOP command was previously entered, this command
    specifies the length of the delay when interogating the clipboard.
    That is, if the clipboard is empty, wait the specified length of time
    before checking the clipboard again.  The delay is specified in
    seconds.
  
Syntax 16:
    SET CLIPBOARD RUN CLEAR <ON/OFF>
    where ON specifies that the clipboard will be cleared after a
    CLIPBOARD RUN command and OFF specifies that the clipboard will not
    be cleared after a CLIPBOARD RUN command.

    The default is OFF.
  
Examples:
    READ CLIPBOARD PRES TEMP TIME
    READ STRING CLIPBOARD STCLIP1

Note:
    These commands have been implented for the Windows version of Dataplot
    built using the Intel compiler.

    Extending this support to Unix/Linux and Mac OS X implementations is
    currently being investigated.

    2020/06: Support has been extended to Unix/Linux platforms via the
             xclip program.  The xclip program is an X11 based command
             line program for accessing either the clipboard, the primary
             selection or the secondary selection.  To specify which
             of these is accessed when a CLIPBOARD command is entered,
             use the command

                 SET X11 SELECTION <CLIPBOARD/PRIMARY/SECONDARY>

             The default is CLIPBOARD and for Dataplot purposes this is what
             will typically be used.

             The CLIPBOARD commands work differently under Linux than
             under Windows.  Under Windows, Dataplot uses library
             routines to access the clipboard directly.  Under Linux,
             the xclip command is used to access the contents of the
             clipboard.  Specifically (in the following, the
             "-selection clipboard" is replaced with "-selection primary"
             or "-selection secondary" depending on the value for the
             SET X11 SELECTION command)

                 LIST CLIPBOARD - the following command is issued

                     xclip -o -selection clipboard

                 COPY CLIPBOARD <file>- the following command is issued

                     xclip -o -selection clipboard > <file>

                 COPY <file> CLIPBOARD - the following command is issued

                     xclip -i -selection clipboard < <file>

                 CLEAR CLIPBOARD - the following command is issued

                     echo -n | xclip -selection clipboard

                 READ CLIPBOARD - the xclip command is used to copy the
                                  contents of the clipboard to the
                                  temporary file "dpst5f.dat".  Then the
                                  READ command reads the file
                                  "dpst5f.dat".

                 WRITE CLIPBOARD - the WRITE command writes to the
                                   temporary file "dpst5f.dat".  Then the
                                   xclip command is used to copy the
                                   contents of "dpst5f.dat" to the
                                   clipboard.

                 CALL CLIPBOARD - the xclip command is used to copy the
                                  contents of the clipboard to the
                                  temporary file "zzzz_clipboard.dp".
                                  Then a "call zzzz_clipboard.dp" command
                                  is issued.

             The commands CLIPBOARD LOOP, CLIPBOARD PAUSE,
             CLIPBOARD RESUME and SET CLIPBOARD SKIP are not currently
             supported for Linux.

             The xclip command is not typically installed by default.
             However, package files are available for most common Linux
             installations.  For example

               sudo dnf --install xclip - systems that use the Red Hat
                                          package manager (Fedora)

               sudo apt install xclip - systems that use the apt package
                                        manager (Ubuntu)

               sudo pacman -S xclip     - systems that use the pacman
                                          package manager (arch, Manjaro)

             If xclip is not available with your package manager, it can
             be built from source.  The xclip program is lightweight, so
             the source build should be quick if you have the gcc
             compiler installed.

Note:
    Dataplot only supports text for clipboard operations.  If the clipboard
    contains binary data (e.g., image data), then the results for reading
    the clipboard may be unpredictable.

    Extending Dataplot support for the clipboard to include binary data is
    not anticipated.

Default:
    None
 
Synonyms:
    CLIPBOARD is a synonym for CLIPBOARD CLIPBOARD RUN
    RUN CLIPBOARD is a synonym for CLIPBOARD RUN
    CLEAR CLIPBOARD is a synonym for CLIPBOARD CLEAR
    CLIPBOARD END LOOP is a synonym for CLIPBOARD LOOP END
    CLIPBOARD END OF LOOP is a synonym for CLIPBOARD LOOP END
    CALL CLIPBOARD is a synonym for CLIPBOARD RUN
    CB is a synonym for CLIPBOARD RUN
 
Related Commands:
    CALL           = Execute Dataplot commands stored in an ASCII file.
    READ           = Read data from an ASCII file.
 
Applications:
    Data I/O, Program Execution
 
Implementation Date:
    2014/12
    2019/03: Added SET CLIPBOARD RUN CLEAR
    2019/03: Added CALL CLIPBOARD and CB as synonyms for CLIPBOARD RUN
    2020/06: Added clipboard support for Linux via the xclip program
 
Program:
    COPY BERGER1.DAT CLIPBOARD
    SET CLIPBOARD SKIP ON
    SKIP 25
    READ CLIPBOARD  Y X BAT
    CLIPBOARD CLEAR

-----CLNBETA (LET)--------------------------------
 
CLNBETA
 
Name:
    CLNBETA (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the log beta function with complex arguments.
 
Description:
    The complex beta function is defined as:

        B(p,q) = INTEGRAL(x**(p-1)*(1-x)**(q-1)dx

    where p and q are complex numbers with positive real
    components and the integral is taken from 0 to 1.
 
    The complex beta function is simply the natural log of the
    above function.

    Dataplot computes this function using routines from
    "Computation of Special Functions" (see the References
    section below).
 
Syntax 1:
    LET <yr> = CLNBETA(<pr>,<pc>,<qr>,<qc>)
                               <SUBSET/EXCEPT/FOR qualification>
    where <pr> is a variable, number, or parameter containing
               positive values;
          <pc> is a variable, number, or parameter;
               positive values;
          <qr> is a variable, number, or parameter containing
               positive values;
          <qc> is a variable, number, or parameter;
               positive values;
          <yr> is a variable or a parameter (depending on what
               <xr> and <xc> are) where the computed log beta
               values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the real component of the complex
    log beta function.  The <pr> and <pc> values are the real and
    complex components of the first input argument respectively
    and the <qr> and <qc> values are the real and
    complex components of the second input argument respectively.

Syntax 2:
    LET <yc> = CLNBETA(<pr>,<pc>,<qr>,<qc>)
                               <SUBSET/EXCEPT/FOR qualification>
    where <pr> is a variable, number, or parameter containing
               positive values;
          <pc> is a variable, number, or parameter;
               positive values;
          <qr> is a variable, number, or parameter containing
               positive values;
          <qc> is a variable, number, or parameter;
               positive values;
          <yr> is a variable or a parameter (depending on what
               <xr> and <xc> are) where the computed log beta
               values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the complex component of the complex
    log beta function.  The <pr> and <pc> values are the real and
    complex components of the first input argument respectively
    and the <qr> and <qc> values are the real and
    complex components of the second input argument respectively.

Examples:
    LET A = CLNBETA(1,2)
    LET A = CLNBETAI(1,2)

    LET YR = CLNBETA(XR,2)
    LET YC = CLNBETAI(XR,2)
 
    LET YR = CLNBETA(XR,XC)
    LET YC = CLNBETAI(XR,XC)

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CBETA      = Compute the complex beta function.
    CGAMMA     = Compute the complex gamma function.
    CLNGAM     = Compute the complex log gamma function.
    BETA       = Compute the beta function.
    GAMMA      = Compute the Gamma function.
    GAMMAI     = Compute the incomplete Gamma function.
 
Reference:
    "Computation of Special Functions", Shanjie Zhang and Jianming
    Jin, John Wiley and Sons, 1996, chapter 1.
 
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    1997/12
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES
    TITLE AUTOMATIC
    PLOT CLNBETA(XR,2,1,0) FOR XR = 0.1 0.1 5
    PLOT CLNBETA(XR,5,1,0) FOR XR = 0.1 0.1 5
    PLOT CLNBETAI(XR,2,1,1) FOR XR = 0.1 0.1 5
    PLOT CLNBETAI(XR,5,1,1) FOR XR = 0.1 0.1 5
    END OF MULTIPLOT
 
-----CLNGAM (LET)--------------------------------
 
CLNGAM
 
Name:
    CLNGAM (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the log gamma function with complex arguments.
 
Description:
    The complex gamma function is defined as:

        GAMMA(z) = INTEGRAL(t**(z-1)*EXP(-t)dt)

    where z is a complex number with a positive real component
    and the integral is taken from 0 to infinity.
 
    The log gamma function is simply the natural logarithm
    of the above function.  It is frequently used in computations
    instead of the complex gamma function because it is less
    subject to overflow problems.

    Dataplot computes this function using the CLNGAM routines
    from "Computation of Special Functions" (see the References
    section below).
 
Syntax 1:
    LET <yr> = CLNGAM(<xr>,<xc>)  <SUBSET/EXCEPT/FOR qualification>
    where <xr> is a variable, number, or parameter containing
               positive values;
          <xc> is a variable, number, or parameter;
               positive values;
          <yr> is a variable or a parameter (depending on what
               <xr> and <xc> are) where the computed log gamma
               values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the real component of the complex
    log gamma function.  The <xr> and <xc> values are the real and
    complex components of the input argument respectively.

Syntax 2:
    LET <yc> = CLNGAMI(<xr>,<xc>)  <SUBSET/EXCEPT/FOR qualification>
    where <xr> is a variable, number, or parameter containing
               positive values;
          <xc> is a variable, number, or parameter;
               positive values;
          <yr> is a variable or a parameter (depending on what
               <xr> and <xc> are) where the computed log gamma
               values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the complex component of the complex
    log gamma function.  The <xr> and <xc> values are the real and
    complex components of the input argument respectively.

Examples:
    LET A = CLNGAM(1,2)
    LET A = CLNGAMI(1,2)

    LET YR = CLNGAM(XR,2)
    LET YC = CLNGAMI(XR,2)
 
    LET YR = CLNGAM(XR,XC)
    LET YC = CLNGAMI(XR,XC)

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CGAMMA     = Compute the complex gamma function.
    CBETA      = Compute the complex beta function.
    CLNBETA    = Compute the complex log beta function.
    GAMMA      = Compute the Gamma function.
    GAMMAI     = Compute the incomplete Gamma function.
    DIGAMMA    = Compute the digamma function.
 
Reference:
    "Computation of Special Functions", Shanjie Zhang and Jianming
    Jin, John Wiley and Sons, 1996, chapter 1.
 
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    1997/12
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES
    TITLE AUTOMATIC
    PLOT CLNGAM(XR,2) FOR XR = 0.1 0.1 5
    PLOT CLNGAM(XR,5) FOR XR = 0.1 0.1 5
    PLOT CLNGAMI(XR,2) FOR XR = 0.1 0.1 5
    PLOT CLNGAMI(XR,5) FOR XR = 0.1 0.1 5
    END OF MULTIPLOT
 
-----CLOG (LET)--------------------------------
 
CLOG
 
Name:
    CLOG (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the real component of the natural logarithmic function for
    a complex number.
 
Syntax:
    LET <yr> = CLOG(<xr>,<xc>)  <SUBSET/EXCEPT/FOR qualification>
    where <xr> is a number, parameter, or variable that specifies the
               real component of the the complex number;
          <xc> is a number, parameter, or variable that specifies the
               complex component of the the complex number;
          <yr> is a variable or a parameter (depending on what <xr> and
               <xc> are) where the computed logarithmic value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CLOG(14,-2)
    LET A = CLOG(A1,4)
    LET X2 = CLOG(XR,XC)
    LET X2 = CLOG(XR,6)
 
Note:
    DATAPLOT uses the Fortran intrinsic function CLOG to compute this
    function.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LOG    = Compute the natural logarithm of a real number.
    CLOGI  = Compute the complex component of the logarithm of a
             complex number.
    CEXP   = Compute the real component of the exponential of a
             complex number.
    CEXPI  = Compute the complex component of the exponential of a
             complex number.
    CCOS   = Compute the real component of the cosine of a complex
             number.
    CCOSI  = Compute the complex component of the cosine of a complex
             number.
    CSIN   = Compute the real component of the sine of a complex
             number.
    CSINI  = Compute the complex component of the sine of a complex
             number.
    CSQRT  = Compute the real component of the square root of a complex
             number.
    CSQRTI = Compute the complex component of the square root of a
             complex number.
 
Applications:
    XX
 
Implementation Date:
    94/10
 
Program:
    LINE SOLID DASH
    PLOT CLOG(X,-1) FOR X = 0.1 0.01 3 AND
    PLOT CLOGI(X,-1) FOR X = 0.1 0.01 3
 
-----CLOGI (LET)--------------------------------
 
CLOGI
 
Name:
    CLOGI (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the complex component of the natural logarithmic function
    for a complex number.
 
Syntax:
    LET <yc> = CLOGI(<xr>,<xc>)  <SUBSET/EXCEPT/FOR qualification>
    where <xr> is a number, parameter, or variable that specifies the
               real component of the the complex number;
          <xc> is a number, parameter, or variable that specifies the
               complex component of the the complex number;
          <yc> is a variable or a parameter (depending on what <xr> and
               <xc> are) where the computed logarithmic value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CLOGI(14,-2)
    LET A = CLOGI(A1,4)
    LET X2 = CLOGI(XR,XC)
    LET X2 = CLOGI(XR,6)
 
Note:
    DATAPLOT uses the Fortran intrinsic function CLOG to compute this
    function.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LOG    = Compute the natural logarithm of a real number.
    CLOG   = Compute the real component of the logarithm of a
             complex number.
    CEXP   = Compute the real component of the exponential of a
             complex number.
    CEXPI  = Compute the complex component of the exponential of a
             complex number.
    CCOS   = Compute the real component of the cosine of a complex
             number.
    CCOSI  = Compute the complex component of the cosine of a complex
             number.
    CSIN   = Compute the real component of the sine of a complex
             number.
    CSINI  = Compute the complex component of the sine of a complex
             number.
    CSQRT  = Compute the real component of the square root of a complex
             number.
    CSQRTI = Compute the complex component of the square root of a
             complex number.
 
Applications:
    XX
 
Implementation Date:
    94/10
 
Program:
    LINE SOLID DASH
    PLOT CLOG(X,-1) FOR X = 0.1 0.01 3 AND
    PLOT CLOGI(X,-1) FOR X = 0.1 0.01 3
 
-----CLOSE (LET)---------------------------------------------------
 
CLOSE
 
Name:
    CLOSE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Close a file associated with a given unit number.
 
Description:
    When Dataplot opens a file, it will be attached to a specific unit
    number between 1 and 99.  This command can be used to close a
    currently open file based on its associated unit number.  This syntax
    is typically used by Dataplot developers for debugging purposes.

    Enter HELP FILE SWITCHES to see a list of files that can be opened by
    Dataplot.  See the Program example for an example of using the PROBE
    command to obtain the relevant unit number.

Syntax 1:
    LET <iflag> = CLOSE <unit>
    where <unit> is an numeric value between 1 and 99;
    and   <iflag> is a parameter that contains the status value from the
          close.

    This syntax closes the file associated with the specified unit number.
    The status from the CLOSE command is saved in <iflag>.

    If the specified unit is not attached to a file, <iflag> will typically
    have a value of 0.
 
Syntax 2:
    LET <iflag> = CLOSE DELETE <unit>
    where <unit> is an numeric value between 1 and 99;
    and   <iflag> is a parameter that contains the status value from the
          close.

    This syntax closes the file associated with the specified unit number.
    The status from the CLOSE command is saved in <iflag>.  In addition,
    this syntax will delete the file when it is closed.
 
    If the specified unit is not attached to a file, <iflag> will
    typically have a value of 0.
 
Examples:
    LET IFLAG = CLOSE 44
    LET IFLAG = CLOSE DELETE 44
 
Note:
    The unit number should be entered as a literal number.  If you have
    the unit number stored as a parameter, you can use the "^" character
    as in

        LET IFLAG = CLOSE ^IVAL

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    INQUIRE        = Inquire whether the specified file exists.
    FILE SWITCHES  = Probe for unit numbers associated with certain files.
 
Applications:
    Debugginh
 
Implementation Date:
    2016/06
 
Program 1:
    PROBE IWRINU
    LET UNIT = PROBEVAL
    LET IFLAG = CLOSE ^UNIT
 
-----CLUSTER --------------------------------------------

CLUSTER
 
Name:
    K MEANS CLUSTER
    NORMAL MIXTURE CLUSTER
    K MEDOIDS CLUSTER
    FUZZY CLUSTER
    AGNES CLUSTER
    DIANA CLUSTER
 
Type:
    Analysis Command
 
Purpose:
    Perform a cluster analysis.
 
Description:
    The goal of cluster analysis is to find groups in data.  There are
    many approaches to this task.  We can divide this into two primary
    approaches.

        1. Partitioning Methods

           Given p variables each with n observations, we create k clusters
           and assign each of the n observations to one of these clusters.

           For these methods, the number of clusters typically has to be
           specified in advance.  In Dataplot, to specify the number of
           clusters, enter the command

                LET NCLUSTER = <value>

           It is typical to run the cluster analysis for several different
           values of NCLUSTER.

           Dataplot implements the following partition based methods.

           a. K-MEANS

              K-means is the workhorse method for clustering.  The
              k-means critierion is to minimize the within cluster sum of
              squares based on Euclidean distances between the
              observations.  That is, minimize

                 SUM[i=1 to k][W(C(k))] = SUM[i=1 to k][SUM[x(i) element C(k)]
                                          [(x(i) - mu(k))**2]]

              with C(k), x(i), and mu(k) denoting the k-th cluster, an
              observation belonging to cluster k, and the mean value of
              the observations belonging to C(k), respectively.

              Dataplot implements k- means using the Hartigan-Wong
              algorithm.  This algorithm finds a local minimum, so
              different results can be obtained based on the initial
              assignment to clusters.  The first method is to randomly
              select observations to use as initial cluster centers.
              The second method is suggested by Hartigan and Wong.  First
              order the observations by their distances to the overall
              mean.  Then for cluster L (L = 1, 2, ... k), use row
              {1 + (L-1)*[p/k]} as the initial cluster center.

              To specify the initialization method, enter

                 SET K MEANS INITIAL <RANDOM/DISTANCE>

              The default is RANDOM.

           b. K-MEDOIDS

              The k-medoids method was proposed by Kaufman and Rousseeuw. 
              In k-medoids clustering, each cluster is represented by one
              observation in the cluster.  These observations are called
              the cluster medoids.  The cluster medoids correspond to the
              most centrally located observations in the cluster.  The
              k-medoids method is more robust to outliers and noise than
              the k-means method.  The mathematical details of the method
              are given in the Kaufman and Rousseeuw book (see References
              below).

              The k-medoids method can start either with the original
              measurement data or a distance matrix (this matrix will have
              dimension nxn).

              Kaufman and Rousseeuw provided two algorithms for k-medoid
              clustering.

              Partioning around medoids (PAM) is used when the number of
              observations is small (up to 100 observations in the
              original Kaufman and Rousseeuw code).  All of the
              observations are used to determine the clusters.

              When the number of observations is larger, the CLARA
              algorithm is used.  In CLARA, a number of random samples of
              the full data set are generated and the PAM algorithm is
              applied to them.  The random sample that generates the
              best clustering is used to assign the unsampled observations
              to a cluster.

              In Dataplot, you can specify the cut-off between switching
              from PAM to CLARA with the command

                   SET K MEDOID CLUSTER PAM MAXIMUM SIZE <value>

              where <value> is between 100 and 500.

              You can also specify the number of samples drawn and the
              sample size for each sample with the commands

                   SET K MEDOID CLUSTER NUMBER OF SAMPLES <value>
                   SET K MEDOID CLUSTER NUMBER OF SAMPLES <value>

              The default is to draw 5 samples with
              40 + 2*(number of clusters) observations per sample.  For
              most applications, these defaults should be sufficient.

              The PAM and CLARA algorithms can be based on either
              Euclidean distances or Manhattan (city block) distances.
              To specify which to use, enter

                   SET K MEDOID CLUSTER DISTANCE <EUCLIDEAN/MANHATTAN>

              The default is to use euclidean distances.

              Dataplot assumes if the number of rows and columns are
              equal that a distance matrix is being input.  In the
              unlikely case where the they are equal for measurement
              data, you can enter the command

                   SET K MEDOID CLUSTER TYPE MEASUREMENT

              To restore the default, enter

                   SET K MEDOID CLUSTER TYPE DISSIMILARITY

              For the random sampling, Dataplot uses its own random
              number generator routines by default.  You can request the
              genrator used by Kaufman and Rousseeuw by entering the
              command (this option is intended primarily to allow
              validating the Dataplot results against the results given
              by running the Kaufman and Rousseeuw codes directly)

                   SET K MEDOID CLUSTER RANDOM NUMBER GENERATOR ROUSSEEUW

              To reset the default, enter

                   SET K MEDOID CLUSTER RANDOM NUMBER GENERATOR DATAPLOT

              You can request that only the final results be printed by
              entering the command

                   SET K MEDOID CLUSTER PRINT FINAL

              To rese the default where results for the individual
              samples are printed, enter

                   SET K MEDOID CLUSTER PRINT ALL

           c. FUZZY CLUSTERING (FANNY)

              Partioning algorithms typically assign each observation to a
              single cluster.  Fuzzy clustering assigns each observation
              to every cluster with a probability for being in that
              cluster.  Kaufman and Rousseeuw provide an algorithm, FANNY,
              to generate a fuzzy clustering.  The details for FANNY are
              given in the Kaufman and Rousseeuw book.

              The following commands can be used with fanny clustering.

                  SET FANNY CLUSTER DISTANCE <EUCLIDEAN/MANHATTAN>
                  SET FANNY CLUSTER PRINT <ALL/FINAL>
                  SET FANNY CLUSTER TYPE <MEASUREMENT/DISSIMILARITY>
                  SET FANNY CLUSTER MAXIMUM SIZE <value>

              These options are similar to the options for k-medoids
              clustering.  As with PAM, a maximum of 500 observations
              can be set.

              The primary advantage of this approach is that it gives
              some indication of the uncertainty of the cluster
              assignments.  The algorithm does return the "most likely"
              cluster assignment which can be used in visualizing the
              results of the cluster analysis.  The drawback is that
              interpretion can become difficult as the number of 
              observations increases.

           d. NORMAL MIXTURES

              This implements Hartigan's MIX algorithm.  This is similar
              to FANNY in that it assigns probabilities for the cluster
              assignments.  This method is based on the model that the
              observations is selected at random from one of k (where k
              is the number of clusters) multivariate normal populations.
              The mathematical details are given in Hartigan's book.

        2. Hierchial Clustering

           Hierchial clustering typically starts with a distance or
           dissimilarity matrix.

           Hierchial clustering can be divided into agglomerative
           algorithms and divisive algorithms.

           With agglomerative algorithms, we start with each object in a
           separate cluster.  Then at each step, the two "closest"
           clusters are merged.  This process is repeated until all
           objects are in a single cluster.

           Divisive algorithms work in the opposite direction.  That is,
           it starts with all objects in a single cluster.  Then at each
           step, a cluster is split into two clusters.  This is repeated
           until all objects are in their own cluster.

           a. AGGLOMERATIVE NESTING (AGNES)

              Dataplot implements the AGNES algorithm given in the Kaufman
              and Rousseeuw book.

              The AGNES algorithm can start either with measurement data
              (i.e., p variables with n observations) or with a previously
              created dissimilarity matrix.  For measurement data, the
              first step is to create a dissimilarity matrix.  You can
              request that either Euclidean distances or Manhattan
              distances be used to create the dissimilarity matrix.  To
              specify which distance measure to use, enter the command

                  SET AGNES CLUSTER DISTANCE <EUCLIDEAN/MANHATTAN>

              The default is to use the Manhattan distance.  If you want
              to use some other distance metric, see the Note section
              below which describes the use of the GENERATE MATRIX command
              with a number of different distance metrics.

              The link function defines the critierion that will be used
              to decide which two clusters are "closest" and will
              therefore be joined at each step.  The supported link
              functions are

                  i. Average Linkage - The distance between two clusters,
                     A and B, is defined as the average distance between
                     the elements in cluster A and the elements in
                     cluster B.

                     This is the recommended choice of Kaufman and
                     Rousseeuw and is the default used by Dataplot.

                 ii. Complete Linkage - The distance between two clusters,
                     A and B, is defined as the maximum distance of all
                     pairwise distances between the elements in cluster A
                     and the elements in cluster B.

                iii. Single Linkage - The distance between two clusters,
                     A and B, is defined as the minimum distance of all
                     pairwise distances between the elements in cluster A
                     and the elements in cluster B.  Single linkage
                     clustering is also referred to as "nearest neighbor"
                     clustering.

                 iv. Centroid Linkage - The distance between two clusters,
                     A and B, is defined as the distance between the
                     centroid for cluster A and the centroid for
                     cluster B.

                     This method should be restricted to the case where
                     the dissimilarity matrix is defined by Euclidean
                     distances.  Another drawback is that the
                     dissimilarities between clusters are no longer
                     monotone which makes visualizing the results
                     problematic.  For these reasons, average linkage
                     is typically preferred to centroid linkage.

                  v. Ward's Linkage - This method minimizes the total
                     within-cluster variance.  At each step, the pair of
                     clusters with minimum between-cluster distance are
                     merged.

                     As with centroid linkage, Ward's linkage is intended
                     for the case where Euclidean distances are used.
                     According to Kaufman and Rousseeuw, this method
                     only performs well if an approximately equal number
                     of objects is drawn from each population and it has
                     problems with clusters of unequal diameter.  Also, it
                     may have problems when the clusters are ellipsoidal
                     (i.e., variables are correlated within clusters) rather
                     than spherical.

                 vi. Weighted Average Linkage - This method is a variant
                     of average linkage.  This method was proposed by
                     Sokal and Sneath.  See Kaufman and Rousseeuw for
                     details.

                vii. Gower's Linkage - This is a variant of the centroid
                     method and should also be restricted to the case of
                     Euclidean distances.  See Kaufman and Rousseeus for
                     details.

              In practice, average linkage, complete linkage, and single
              linkage are the methods most commonly used.  Kaufman and
              Rousseeuw review the properties of various linkage methods
              and reference several other studies.  In summary, although
              no method is best in all cases, they find that average
              linkage typically performs well in practice and is
              reasonably robust to slight distortions.  Studies they
              cite indicate that single linkage, although easy to
              implement and understand, typically does not perform as
              well as average linkage or complete linkage.

              To specify the linkage method to use, enter one of the
              following commands

                 SET AGNES CLUSTER METHOD AVERAGE LINKAGE
                 SET AGNES CLUSTER METHOD COMPLETE LINKAGE
                 SET AGNES CLUSTER METHOD SINGLE LINKAGE
                 SET AGNES CLUSTER METHOD WEIGHTED AVERAGE LINKAGE
                 SET AGNES CLUSTER METHOD WARD
                 SET AGNES CLUSTER METHOD CENTROID
                 SET AGNES CLUSTER METHOD GOWER

              You can specify the maximum number of rows/columns in the
              distance matrix (if you start with measurement data, this
              is the number of columns) with the command

                   SET AGNES CLUSTER MAXIMUM SIZE <value>

              where <value> is between 100 and 500 (the default is 100).

              You can control the amount of output generated by agnes
              clustering with the command

                  SET AGNES CLUSTER PRINT <ALL/FINAL>

              Using FINAL omits the printing of the distance matrix.

              Dataplot assumes if the number of rows and columns are
              equal that a distance matrix is being input.  In the
              unlikely case where the they are equal for measurement
              data, you can enter the command

                   SET AGNES CLUSTER TYPE MEASUREMENT

              To restore the default, enter

                   SET AGNES CLUSTER TYPE DISSIMILARITY

           b. DIVISIVE (DIANA)

              Dataplot implements the DIANA algorithm given in the Kaufman
              and Rousseeuw book.  The details of the algorithm are given
              there.  DIANA is currently limited to using average
              distances between clusters.

              The options used for agnes clustering also apply to
              diana clustering.  The exception is that diana only supports
              the average linkage method.

    The traditional clustering methods described above are heuristic
    methods and are intented for small to moderate size data sets.
    These methods tend to work reasonably well for spherical shaped or
    convex clusters.  If clusters are not compact and well separated,
    these methods may not be effective.  The k-means algorithm is
    sensitive to noise and outliers (the k-medoids method may work better
    in these cases).

    Dataplot does not currently support model-based clustering or some of
    the newer cluster methods such as DBSCAN that can work better for
    non-spherical shapes in the presence of significant noise.

Syntax 1:
    K MEANS CLUSTER  <y1> ... <yk>
                     <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax performs Hartigan's k-means clustering.

Syntax 2:
    NORMAL MIXTURE CLUSTER  <y1> ... <yk>
                            <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax performs Hartigan's normal mixture clustering.

Syntax 3:
    K MEDIODS CLUSTER  <y1> ... <yk>
                       <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax performs Kaufman and Rousseeuw k-medoids clustering.
    The use of PAM or CLARA will be determined based on the number of
    objects to be clustered.

Syntax 4:
    FANNY CLUSTER  <y1> ... <yk>
                   <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax performs Kaufman and Rousseeuw fuzzy clustering using
    the FANNY algorithm.

Syntax 5:
    AGNES CLUSTER  <y1> ... <yk>
                   <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax performs Kaufman and Rousseeuw agglomerative nesting
    clustering using the AGNES algorithm.

    By default, this algoritm uses the average distance linking
    critierion.  However, it can also be used for single linkage (nearest
    neighbor), complete linkage, Ward's method, the centroid method,
    and Gower's method.  See above for details.

Syntax 6:
    DIANA CLUSTER  <y1> ... <yk>
                   <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax performs Kaufman and Rousseeuw divisive clustering
    using the DIANA algorithm.

Examples:
    K MEANS CLUSTERING Y1 Y2 Y3 Y4 Y5 Y6
    K MEANS CLUSTERING Y1 TO Y6
    K MEDOIDS CLUSTERING Y1 TO Y6
    AGNES CLUSTERING M
 
Note:
    When starting with measurement data, if the variables being clustered
    use different measurement scales, it may be desirable to standardize
    the data before applying the clustering algorithm.  Standardization
    creates unitless variables.

    The desirability of standardization will depend on the specific data
    set.  Kaufman and Rousseeuw (pp. 8-11) discuss some of the issues in
    deciding whether or not to standardize.  By default, Dataplot will
    standardize the variables.

    The following commands can be used to specify whether or not you want
    the variables to be standardized

          SET K MEANS SCALE <ON/OFF>
          SET NORMAL MIXTURE SCALE <ON/OFF>
          SET K MEDOIDS SCALE <ON/OFF>
          SET FANNY SCALE <ON/OFF>
          SET AGNES SCALE <ON/OFF>

    The SET AGNES SCALE command also applies to the DIANA CLUSTER
    command.

    If you choose to standardize, the basic formula is

        Y(i) = (X(i) - loc)/scale

    where loc and scale denote the desired location and scale parameters.

    To specify the location statistic, enter

        SET LOCATION STATISTIC <stat>

    where <stat> is one of: MEAN, MEDIAN, MIDMEAN. HARMONIC MEAN,
    GEOMETRIC MEAN, BIWEIGHT LOCATION, H10, H12, H15, H17, or H20.

    To specify the scale statistic, enter

        SET SCALE STATISTIC <stat>

    where <stat> is one of: STANDARD DEVIATION, H10, H12, H15, H17, H20,
    BIWEIGHT SCALE, MEDIAN ABSOLUTE DEVIATION, SCALED MEDIAN ABSOLUTE
    DEVIATION, AVERAGE ABSOLUTE DEVIATION, INTERQUARTILE RANGE,
    NORMALIZED INTERQUARTILE RANGE, SN SCALE, or RANGE.

    The default is to use the mean for the location statistic and the
    standard deviation for the scale statistic.  Rousseeuw recommends
    using the mean for the location statistic and the average absolute
    deviation for the scale statistic.

Note:
    Several of the clustering algorithms can start with a distance
    matrix.  Dataplot offers a number of commands for converting
    measurement data to distances or dissimilarities.  Note that the
    GENERATE MATRIX command can be used to convert measurement data
    to a distance matrix for a specified statistic.  For example,

       LET M = GENERATE MATRIX COSINE DISTANCE X1 X2 X3 X4

    The COSINE DISTANCE can be replaced with a number of other distance
    measures.

       1. For continuous data, the following distance measures are
          supported

            EUCLIDEAN DISTANCE       - Euclidean distance
            MANHATTAN DISTANCE       - Manhattan (city block) distance
            MINKOWSKI DISTANCE       - Minkowski distance
            CHEBYCHEV DISTANCE       - Chebyshev distance
            COSINE DISTANCE          - cosine distance
            ANGULAR COSINE DISTANCE  - angular cosine distance

       2. For binary data, a number of distance measures are available.
          Enter HELP BINARY MATCH DISSIMILARITIES for details.

       3. For correlation type measures (often used when clustering
          variables rather than observations), the following are supported

            PEARSON DISSIMILARITY     - (1 - r)/2 where r is the Pearson
                                        correlation coefficient
            SPEARMAN DISSIMILARITY    - (1 - r)/2 where r is the Spearman
                                        rank correlation coefficient
            KENDALL TAU DISSIMILARITY - (1 - r)/2 where r is the Kendall tau
                                        correlation coefficient

Note:
    One issue with clustering is how to visualize the results.  The
    Dataplot clustering commands do not generate any graphics directly.
    Instead, Dataplot writes information to files that allow several
    different approaches to visualization.  Different graphical approaches
    are typically used for partitioning and hierchial methods, so we will
    discuss these separately.

       1. Partion Methods

          a. Dataplot writes the cluster id for each observation to the
             file dpst1f.dat.  So one visualization approach is to
             generate a scatter plot matrix of the variables and use the
             cluster id to identify the different clusters in the plots.
             This is demonstrated in Program examples 1 and 2 below.

          b. Another approach is to plot the first two principal
             components.  Again, the cluster id can be used to identify
             the clusters.  This is demonstrated in Program examples 1
             and 2 below.

          c. Rousseeuw advocated the silhouette plot.  For each
             observation, compute

                s(i) = (b(i) - a(i))/max{a(i),b(i)}

             where

                a(i)   = the average dissimilarity of the i-th point with
                         all other points in the cluster to which it
                         belongs

                b(i)   = the lowest average dissimilarity of the i-th
                         point with all other clusters.  The b(i) value
                         can be considered the second best choice for
                         observation i.

             The s(i) values will be between -1 and 1.  A value near 0
             indicates that a(i) and b(i) are nearly equal and thus
             indicating the choice between assigning object i to A or
             B is ambiguous.  On the other hand, when s(i) is close
             to 1, this indicates that the within dissimilarity is much
             smaller than the smallest between dissimilarity.  This
             indicates good clustering.  Negative values of s(i) indicate
             that B may in fact be a better choice than A, so the
             observation may be misclassified.

             The average s(i) for each cluster and the average s(i) for
             all observations can be computed.  These provide a measure
             of the quality of the clustering.  In particular, they can
             be used to pick appropriate number of clusters to use (i.e.,
             the number of clusters which results in the highest average
             for all the s(i) values).

             Dataplot writes the s(i) values (with the cluser id values)
             to dpst4f.dat.  This is demonstrated in the Program 1, 2, and
             3 examples below.

       2. Hierchial Methods

          a. Kaufman and Rousseeuw provide a line printer "banner"
             plot for their AGNES and DIANA algorithms.  To include
             this plot in the clustering output, enter the command

                 SET AGNES CLUSTERING BANNER PLOT ON

             The default is OFF.

          b. The most commonly used visualization technique for
             hierchial clustering is the dendogram.  Dataplot writes
             the plot coordinates for the dendogram to dpst3f.dat.
             The ordering of the clusters is written to dpst1f.dat.
             Program examples 4 and 5 demonstrate how to plot the
             dendogram from the information in these files.  The
             Program 4 example generates a horizontal dendogram and
             the Program 5 example generates a vertical dendogram.

             The dendogram is basically a variant of a tree diagram.
             It shows the order the clusters were joined as well as
             the distance between clusters.  One axis contains the
             objects to be clustered in a sorted order while the
             other axis is distance.  The dendogram shows which
             clusters were connected at each step and shows the distance
             between these clusters.

          c. Another popular technique is the icicle plot introduced
             by Kruskal and Landwehr (1983).  Although the original
             article introduced this as a line printer graphic,
             it can be adapted for modern graphical displays.  The
             Program 4 and Program 5 examples demonstrate how to
             generate an icicle plot from the information written to
             files dpst1f.dat and dpst2f.dat.

             Many different variants of the icicle plot are shown in the
             literature.  But the basic idea is that one axis contains
             the number of clusters while the other axis shows the objects
             being clustered.  For each object, two rows (or columns)
             are drawn (the last object only has a single row).  The
             coordinate for one row (or column) shows where the object
             joined the cluster from one direction (i.e., top or left)
             while the coordinate for the second row (or column) shows
             where the object joined the cluster from the other
             direction.  If you scan down the "number of cluster" axis,
             contiguous rows (or columns) indicate objects that belong
             to the same cluster.  Note that the icicle plot does not
             give any indication of the distance.  The banner plot of
             Kaufman and Rousseeuw is similar to the icicle plot
             although they do show distances (on a 0 to 100 percentage
             scale rather than in raw distance units).

             The Program examples below show the icicle plots as simple
             bar graphs that are read from left to right (or bottom to
             top).  Variants of the icicle plot often show these as rows
             (or columns) of asterisks or use a right to left (or top
             to bottom) orientation.  These variants are a matter of
             taste and can be generated from the information written
             to files dpst1f.dat and dpst2f.dat.

Default:
    None
 
Synonyms:
    K MEANS is a synonym for K MEANS CLUSTER
    K MEDOIDS is a synonym for K MEDOIDS CLUSTER
    FANNY is a synonym for FANNY CLUSTER
    AGNES is a synonym for AGNES CLUSTER
    DIANA is a synonym for DIANA CLUSTER
 
Related Commands:
    GENERATE MATRIX <stat>  = Compute a matrix of pairwise statistic
                              values (specifically distance metrics).
    MANHATTAN DISTANCE      = Compute the Euclidean distance.
    EUCLIDEAN DISTANCE      = Compute the Euclidean distance.
    COSINE DISTANCE         = Compute the cosine distance.
    MATRIX DISTANCE         = Compute various distance metrics for
                              a matrix.
 
References:
    Hartigan and Wong (1979), "Algorithm AS 136: A K-Means Clustering
    Algorithm", Applied Statistics, Vol. 28, No. 1.

    Hartigan (1975), "Clustering Algorithms", Wiley.

    Kaufman and Rousseeuw (1990), "Finding Groups in Data: An
    Introduction To Cluster Analysis", Wiley.

    Rousseeuw (1987), "Silhouettes: A Graphical Aid to the Interpretation
    and Validation of Cluster Analysis", Journal of Computational and
    Applied Mathematics, North Holland, Vol. 20, pp. 53-65.

    Kruskal and Landwehr (1983), "Icicle Plots: Better Displays for
    Hierarchial Clustering", The American Statistician, Vol. 37, No. 2,
    pp. 168.

Applications:
    Multivariate Analysis, Exploratory Data Analysis
 
Implementation Date:
    2017/09
    2017/11: Changed the default for standardization to be ON
             rather than OFF.  Fixed a bug where the k-means
             method always performed standardization.  For
             k-means, the cluster centers written to dpst3f.dat
             were modified to write the unstandardized values
             rather than the standardized values.
 
Program 1:
    case asis
    label case asis
    title case asis
    title offset 2
    .
    . Step 1:   Read the data
    .
    dimension 100 columns
    skip 25
    read iris.dat y1 y2 y3 y4 x
    skip 0
    set write decimals 3
    .
    . Step 2:   Perform the k-means cluster analysis with 3 clusters
    .
    set random number generator fibbonacci congruential
    seed 45617
    let ncluster = 3
    set k means initial distance
    set k means silhouette on
    feedback off
    k-means y1 y2 y3 y4
    read dpst4f.dat clustid si
    .
    . Step 3:   Scatter plot matrix with clusters identified
    .
    line blank all
    char 1 2 3
    char color blue red green
    frame corner coordinates 5 5 95 95
    multiplot scale factor 4
    tic offset units screen
    tic offset 5 5
    .
    set scatter plot matrix tag on
    scatter plot matrix y1 y2 y3 y4 clustid
    .
    justification center
    move 50 97
    text K-Means Clusters for IRIS.DAT
    .
    . Step 4:   Silhouette Plot
    .
    .           For better resolution, show the results for
    .           each cluster separately
    .
    let ntemp = size clustid
    let indx = sequence 1 1 ntemp
    let clustid = sortc clustid si indx
    let x = sequence 1 1 ntemp
    loop for k = 1 1 ntemp
        let itemp = indx(k)
        let string t^k = ^itemp
    end of loop
    .
    orientation portrait
    device 2 color on
    frame corner coordinates 15 20 85 90
    tic offset units data
    horizontal switch on
    .
    spike on
    char blank all
    line blank all
    .
    label size 1.7
    xlimits 0 1
    xtic mark offset 0 0
    x1label S(i)
    x1tic mark label size 1.7
    y1tic mark offset 0.8 0.8
    minor y1tic mark number 0
    y1tic mark label format group label
    y1tic mark label size 1.2
    y1tic mark size 0.8
    y1label Sequence Number
    .
    let simean  = mean si
    let simean  = round(simean,2)
    x3label Mean of All s(i) values: ^simean
    .
    loop for k = 1 1 ncluster
        .
        orientation portait
        device 2 color on
        .
        let sit = si
        let xt  = x
        retain sit xt subset clustid = k
        let ntemp2 = size sit
        let y1min = minimum xt
        let y1max = maximum xt
        y1limits y1min y1max
        major y1tic mark number ntemp2
        let ig = group label t^y1min to t^y1max
        y1tic mark label content ig
        title Silhouette Plot for Cluster ^k Based on K-Means Clustering
        .
        let simean^k = mean si subset clustid = k
        let simean^k = round(simean^k,2)
        x2label Mean of s(i) values for cluster ^k: ^simean^k
        .
        plot si x subset clustid = k
    end of loop
    .
    label
    ylimits
    major y1tic mark number
    minor y1tic mark number
    y1tic mark label format numeric
    y1tic mark label content
    y1tic mark label size
    .
    . Step 5:   Display clusters in terms of first 2 principal components
    .
    orientation landscape
    device 2 color on
    .
    let ym = create matrix y1 y2 y3 y4
    let pc = principal components ym
    read dpst1f.dat clustid
    spike blank all
    character 1 2 3
    character color red blue green
    horizontal switch off
    tic mark offset 0 0
    limits
    title Clusters for First Two Principal Components
    y1label First Principal Component
    x1label Second Principal Component
    x2label
    .
    plot pc1 pc2 clustid

Program 2:
    case asis
    label case asis
    title case asis
    title offset 2
    .
    . Step 1:   Read the data
    .
    dimension 100 columns
    skip 25
    read iris.dat y1 y2 y3 y4 x
    skip 0
    set write decimals 3
    .
    . Step 2:   Perform the k-medoids cluster analysis with 3 clusters
    .
    set random number generator fibbonacci congruential
    seed 45617
    let ncluster = 3
    set k medoids cluster distance manhattan
    k medoids y1 y2 y3 y4
    skip 1
    read dpst4f.dat clustid si
    skip 0
    .
    . Step 3:   Scatter plot matrix with clusters identified
    .
    line blank all
    char 1 2 3
    char color blue red green
    frame corner coordinates 5 5 95 95
    multiplot scale factor 4
    tic offset units screen
    tic offset 5 5
    .
    set scatter plot matrix tag on
    scatter plot matrix y1 y2 y3 y4 clustid
    .
    justification center
    move 50 97
    text K Medoids Clusters for IRIS.DAT
    .
    . Step 4:   Silhouette Plot
    .
    .           For better resolution, show the results for
    .           each cluster separately
    .
    let ntemp = size clustid
    let indx = sequence 1 1 ntemp
    let clustid = sortc clustid si indx
    let x = sequence 1 1 ntemp
    loop for k = 1 1 ntemp
        let itemp = indx(k)
        let string t^k = ^itemp
    end of loop
    .
    orientation portrait
    device 2 color on
    frame corner coordinates 15 20 85 90
    tic offset units data
    horizontal switch on
    .
    spike on
    char blank all
    line blank all
    .
    label size 1.7
    xlimits 0 1
    xtic mark offset 0 0
    x1label S(i)
    x1tic mark label size 1.7
    y1tic mark offset 0.8 0.8
    minor y1tic mark number 0
    y1tic mark label format group label
    y1tic mark label size 1.2
    y1tic mark size 0.8
    y1label Sequence Number
    .
    let simean  = mean si
    let simean  = round(simean,2)
    x3label Mean of All s(i) values: ^simean
    .
    orientation portait
    device 2 color on
    loop for k = 1 1 ncluster
        .
        .
        let sit = si
        let xt  = x
        retain sit xt subset clustid = k
        let ntemp2 = size sit
        let y1min = minimum xt
        let y1max = maximum xt
        y1limits y1min y1max
        major y1tic mark number ntemp2
        let ig = group label t^y1min to t^y1max
        y1tic mark label content ig
        title Silhouette Plot for Cluster ^k Based on K-Medoids Clustering
        .
        let simean^k = mean si subset clustid = k
        let simean^k = round(simean^k,2)
        x2label Mean of s(i) values for cluster ^k: ^simean^k
        .
        plot si x subset clustid = k
    end of loop
    .
    label
    ylimits
    major y1tic mark number
    minor y1tic mark number
    y1tic mark label format numeric
    y1tic mark label content
    y1tic mark label size
    .
    . Step 5:   Display clusters in terms of first 2 principal components
    .
    orientation landscape
    device 2 color on
    .
    let ym = create matrix y1 y2 y3 y4
    let pc = principal components ym
    read dpst1f.dat clustid
    spike blank all
    character 1 2 3
    character color red blue green
    horizontal switch off
    tic mark offset 0 0
    limits
    title Clusters for First Two Principal Components
    y1label First Principal Component
    x1label Second Principal Component
    x2label
    .
    plot pc1 pc2 clustid

Program 3:
    orientation portait
    .
    case asis
    label case asis
    title case asis
    title offset 2
    .
    . Step 1:   Read the data
    .
    set write decimals 3
    dimension 100 columns
    .
    skip 25
    read matrix rouss1.dat y
    skip 0
    .
    let string s1  = Belgium
    let string s2  = Brazil
    let string s3  = China
    let string s4  = Cuba
    let string s5  = Egypt
    let string s6  = France
    let string s7  = India
    let string s8  = Israel
    let string s9  = USA
    let string s10 = USSR
    let string s11 = Yugoslavia
    let string s12 = Zaire
    .
    . Step 2:   Perform the k-mediods cluster analysis with 3 clusters
    .
    let ncluster = 3
    .
    k medioids y
    skip 1
    read dpst4f.dat indx clustid si neighbor
    skip 0
    .
    . Step 3:   Silhouette Plot
    .
    .           Create axis label
    .
    .           First sort by cluster and then sort by
    .           silhouette within cluster (this second step
    .           is a bit convoluted)
    .
    let simean = mean si
    let simean = round(simean,2)
    .
    let ntemp = size indx
    let clustid = sortc clustid si indx neighbor
    .
    loop for k = 1 1 ncluster
        .
        let simean^k = mean si subset clustid = ^k
        let simean^k = round(simean^k,2)
        .
        let clustidt = clustid
        let sit = si
        let indxt = indx
        let neight = neighbor
        retain clustidt sit indxt neight subset clustid = k
        .
        let sit = sortc sit clustidt indxt neight
        if k = 1
           let clustid2 = clustidt
           let si2 = sit
           let indx2 = indxt
           let neigh2 = neight
        else
           let clustid2 = combine clustid2 clustidt
           let si2 = combine si2 sit
           let indx2 = combine indx2 indxt
           let neigh2 = combine neigh2 neight
        end of if
    end of loop
    let clustid = clustid2
    let si = si2
    let indx = indx2
    let neighbor = neigh2
    .
    loop for k = 1 1 ntemp
        let itemp = indx(k)
        let string t^k = ^s^itemp
    end of loop
    let ig = group label t1 to t^ntemp
    .
    let x = sequence 1 1 ntemp
    .
    frame corner coordinates 15 20 85 90
    tic offset units data
    horizontal switch on
    .
    spike on all
    spike color red blue green
    char blank all
    line blank all
    .
    xlimits 0 1
    xtic mark offset 0 0
    major xtic mark number 6
    x1tic mark decimal 1
    y1limits 1 ntemp
    y1tic mark offset 1 1
    major y1tic mark number ntemp
    minor y1tic mark number 0
    y1tic mark label format group label
    y1tic mark label content ig
    y1tic mark label size 1.1
    y1tic mark size 0.1
    x1label S(i)
    x3label Mean of All s(i) values: ^simean
    title Silhouette Plot Based on K-Medoids Clustering
    .
    plot si x clustid
    .
    height 1.0
    justification left
    movesd 87 3
    text Mean s(i): ^simean1
    movesd 87 7
    text Mean s(i): ^simean2
    movesd 87 10.5
    text Mean s(i): ^simean3
    height 2
    .
    print indx clustid neighbor si
 
Program 4:
    . Step 1:   Read the data - a dissimilarity matrix
    .
    dimension 100 columns
    set write decimals 3
    .
    skip 25
    read matrix rouss1.dat y
    skip 0
    .
    let string s1  = Belgium
    let string s2  = Brazil
    let string s3  = China
    let string s4  = Cuba
    let string s5  = Egypt
    let string s6  = France
    let string s7  = India
    let string s8  = Israel
    let string s9  = USA
    let string s10 = USSR
    let string s11 = Yugoslavia
    let string s12 = Zaire
    .
    . Step 2:   Perform the agnes cluster analysis
    .
    set agnes cluster banner plot on
    agnes y
    .
    . Step 3:   Generate dendogram from dpst3f.dat file
    .
    skip 0
    read dpst1f.dat indx
    read dpst3f.dat xd yd tag
    .
    orientation portrait
    case asis
    label case asis
    title case asis
    title offset 2
    label size 1.5
    tic mark label size 1.5
    title size 1.5
    tic mark offset units data
    .
    let ntemp = size indx
    loop for k = 1 1 ntemp
        let itemp = indx(k)
        let string t^k = ^s^itemp
    end of loop
    let ig = group label t1 to t^ntemp
    .
    x1label Distance
    ylimits 1 12
    major ytic mark number 12
    minor ytic mark number 0
    y1tic mark label format group label
    y1tic mark label content ig
    ytic mark offset 0.9 0.9
    frame corner coordinates 15 20 95 90
    .
    pre-sort off
    horizontal switch on
    title Dendogram of Kauffman and Rousseeuw Data Set (Average Linkage)
    plot yd xd tag
    .
    . Step 4:   Generate icicle plot from dpst2f.dat file
    .
    delete xd yd tag
    skip 0
    read dpst1f.dat indx
    read dpst2f.dat xd yd tag
    .
    set string space ignore
    let ntemp = size indx
    let ntic = 2*ntemp - 1
    let string tcr = sp()cr()
    loop for k = 1 1 ntemp
        let itemp = indx(k)
        let ktemp1 = (k-1)*2 + 1
        let ktemp2 = ktemp1 + 1
        let string t^ktemp1 = ^s^itemp
        if k < ntemp
           let string t^ktemp2 = sp()
        end of if
    end of loop
    let ig = group label t1 to t^ntic
    .
    ylimits 1 ntic
    major ytic mark number ntic
    minor ytic mark number 0
    y1tic mark label format group label
    y1tic mark label content ig
    ytic mark offset 0.9 0.9
    frame corner coordinates 15 20 95 90
    .
    xlimits 0 12
    major x1tic mark number 13
    minor x1tic mark number 0
    .
    line blank all
    character blank all
    bar on all
    bar fill on all
    bar fill color blue all
    .
    x1label Number of Clusters
    title Icicle Plot of Kauffman and Rousseeuw Data Set (Average Linkage)
    plot yd xd tag

Program 5:
    case asis
    label case asis
    title case asis
    title offset 2
    .
    . Step 1:   Read the data - a dissimilarity matrix
    .
    dimension 100 columns
    set write decimals 3
    .
    skip 25
    read matrix rouss1.dat y
    skip 0
    .
    let string s1  = Belgium
    let string s2  = Brazil
    let string s3  = China
    let string s4  = Cuba
    let string s5  = Egypt
    let string s6  = France
    let string s7  = India
    let string s8  = Israel
    let string s9  = USA
    let string s10 = USSR
    let string s11 = Yugoslavia
    let string s12 = Zaire
    .
    . Step 2:   Perform the agnes cluster analysis
    .
    set agnes cluster banner plot on
    set agnes cluster method average linkage
    agnes y
    .
    . Step 3:   Generate dendogram from dpst3f.dat file
    .
    skip 0
    read dpst1f.dat indx
    read dpst3f.dat xd yd tag
    .
    let ntemp = size indx
    let string tcr = sp()cr()
    loop for k = 1 1 ntemp
        let itemp = indx(k)
        let string t^k = ^s^itemp
        let ival1 = mod(k,2)
        if ival1 = 0
           let t^k = string concatenate tcr t^k
        end of if
    end of loop
    let ig = group label t1 to t^ntemp
    .
    xlimits 1 12
    major xtic mark number 12
    minor xtic mark number 0
    x1tic mark label format group label
    x1tic mark label content ig
    xtic mark offset 0.9 0.9
    frame corner coordinates 15 20 95 90
    .
    y1label Distance
    title Dendogram of Kauffman and Rousseeuw Data Set (Average Linkage)
    plot yd xd tag
    .
    . Step 4:   Generate icicle plot from dpst2f.dat file
    .
    delete xd yd tag
    skip 0
    read dpst1f.dat indx
    read dpst2f.dat xd yd tag
    .
    set string space ignore
    let ntemp = size indx
    let ntic = 2*ntemp - 1
    let string tcr = sp()cr()
    loop for k = 1 1 ntemp
        let itemp = indx(k)
        let ktemp1 = (k-1)*2 + 1
        let ktemp2 = ktemp1 + 1
        let string t^ktemp1 = ^s^itemp
        if k < ntemp
           let string t^ktemp2 = sp()
        end of if
        let ival1 = mod(k,2)
        if ival1 = 0
           let t^ktemp1 = string concatenate tcr t^ktemp1
        end of if
    end of loop
    let ig = group label t1 to t^ntic
    .
    xlimits 1 ntic
    major xtic mark number ntic
    minor xtic mark number 0
    x1tic mark label format group label
    x1tic mark label content ig
    xtic mark offset 0.9 0.9
    frame corner coordinates 15 20 95 90
    .
    ylimits 0 12
    major y1tic mark number 13
    minor y1tic mark number 0
    .
    line blank all
    character blank all
    bar on all
    bar fill on all
    bar fill color blue all
    .
    y1label Number of Clusters
    title Icicle Plot of Kauffman and Rousseeuw Data Set (Average Linkage)
    plot yd xd tag

-----CME---------------------------------
 
CME
 
Name:
    CME MLE
 
Type:
    Analysis Command
 
Purpose:
    Estimate the parameters of a generalized Pareto distribution
    using the conditional mean exceedance (CME) method.

Description:
    The generalized Pareto distribution (GPD) is an asymptotic
    distribution developed by using the fact that exceedances
    of a sufficiently high threshold are rare events to which the
    Poisson distribution applies.

    The cumulative distribution function of the generalized
    Pareto distribution is

       G(y) = 1 - {[1 + (c*y/a)]**(-1/k)}    a > 0,
                                             [1 + (c*y/a)] > 0

    Here, c is the shape parameter and a is the scale parameter.

    This equation can be used to represent the conditional 
    cumulative distribution of the excess Y = X - u of the
    variate X over the threshold u, given X > u for u
    sufficiently large.

    The cases c > 0, c = 0, and c < 0 correspond respectively
    to the extreme value type II (Frechet), extreme value 
    type I (Gumbel), and reverse Weibull domains of attraction.

    Given the mean E(Y) and standard deviation s(Y) of the
    variate Y, then

        a = 0.5*E(Y)*{1 + [E(Y)/s(Y)]**2}
        c = 0.5*{1 - [E(Y)/s(Y)]**2}

    The CME, or mean residual life (MRL), is the expectation of
    the amount by which a value exceeds a threshold u, conditional
    on that threshold being attained.

    If the exceedance data are fitted by the GPD model and
    c < 1, u > 0, and (a + u*c) > 0, then a plot of CME versus
    u should follow a line with intercept a/(1-c) and slope
    c/(1-c).  The linearity of the CME plot can thus be used
    as an indicator of the appropriateness of the GPD model and
    both c and a can be estimated.

    Note that for the case where c < 0, then gamma = -1/c is
    the estimate of the shape parameter for the reverse Weibull
    distribution.

    The CME command performs a least squares fit of the CME
    versus u data points.  It does this as follows:

       1) All points above the user specified threshold are
          saved and sorted.

       2) Loop through the sorted points from smallest to
          largest.

       3) For a given point in the loop, set the threshold u
          equal to that point.  Then compute the CME.  The
          CME is simply the sum of the points minus the threshold
          for those points greater than the threshold divided by
          the number of points greater than the threshold.

    The formulas for estimating the standard deviation of c are
    given in NISTIR 5531 (see the Reference section below).

Syntax:
    CME MLE <y>       <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    CME MLE Y
    CME MLE Y SUBSET TAG > 0
 
Note:
    The user specified threshold is determined by entering the
    following command before the CME command:

        LET THRESHOL = <value>

    If no threshold is specified, then the minimum data value is
    used as the threshold.

Note:
    The following internal parameters will be saved.

        GAMMA   = shape parameter for generalized Pareto
                  distribution
        A       = scale parameter for generalized Pareto
                  distribution
        SDGAMMA = standard deviation of GAMMA

    If GAMMA is within a user-specified tolerance of zero, then the
    following are also saved.

        LOC     = location parameter for Gumbel distribution.
        SCALE   = scale parameter for Gumbel distribution.

    To specify the tolerance, enter the command

       SET PEAKS OVER THRESHOLD TOLERANCE <value>

    If GAMMA is less than zero with an absolute value greater than the
    above tolerance, then the following are also saved.

        GAMMA2  = shape parameter for reverse Weibull
                  distribution.
        LOC     = location parameter for reverse Weibull
                  distribution.
        SCALE   = scale parameter for reverse Weibull
                  distribution.

    These estimates for the reverse Weibull and Gumbel distributions
    are based on moment estimators.  Currently, no estimates for the
    Frechet case (GAMMA > 0) are saved.

Note:
    The May, 2005 version added support for generating the output in
    Latex or HTML.  Enter

       HELP CAPTURE HTML
       HELP CAPTURE LATEX

    for details.

    The ASCII output was also modified somewhat.  This was a
    cosemetic change to make the output clearer.

Note:
    The PEAKS OVER THRESHOLD PLOT was added in the 5/2005 version.
    This plot shows how the estimate of the shape parameter changes
    as the the threshold changes.

Default:
    None.
 
Synonyms:
    None
 
Related Commands:
    DEHAAN                     = Compute the Dehaan estimates for the
                                 generalized Pareto distribution.
    CME PLOT                   = Generate a CME plot.
    GEPPDF                     = Compute the probability density
                                 function for the generalized Pareto
                                 distribution.
    PEAKS OVER THRESHOLD PLOT  = Generate a peaks over threshold plot.
 
Reference:
    "Continuous Univariate Distributions: Volume I", 2nd. ed.,
    Johnson, Kotz, and Balakrishnan, John Wiley and Sons, 1994.

    "Estimates of Hurricane Wind Speeds by the "Peaks Over
    Threshold" Approach", Alan Heckert, Emil Simiu, and Tim Whalen,
    Journal of Structural Engineering, April, 1998.

    "Extreme Wind Distribution Tails: A "Peaks Over Threshold"
    Approach", Simiu and Heckert, Journal of Structural Engineering,
    May, 1996.

    "Assessment of 'peak over threshold' Methods for Estimating
    Extreme Value Distribution Tails", J. A. Lechner, E. Simiu,
    N. A. Heckert, Structural Safety, 1993.

    "Estimates of Hurricane Wind Speeds by the 'Peaks Over
    Threshold' Method", E. Simiu, N. A. Heckert, T. Whalen,
    NIST Technical Note 1416, February, 1996.

    "Extreme Wind Estimates by the Conditional Mean Exceedance
    Procedure", J. L. Gross, E. Simiu, N. A. Heckert, J. A. Lechner,
    NISTIR 5531, April, 1995.


    "Extreme Wind Distribution Tails: A 'Peaks Over Threshold'
    Approach", E. Simiu, N. A. Heckert, NIST Building Science
    Series 174, March, 1995

Applications:
    Extreme Value Analysis
 
Implementation Date:
    1998/5
    2005/5: Modified the output format.
    2005/5: Added support for HTML and Latex output.
    2005/5: Added support for the CME standard deviation.
 
Program:
    SKIP 25
    READ MPOST550.DAT Y
    LET Y2 = SORT Y
    LET THRESHOL = Y2(900)
    SET WRITE DECIMALS 5
    CME Y

-----CME PLOT--------------------------------------
 
CME PLOT
 
Name:
    CME PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a conditional mean exceedance plot (also known as the
    mean residual life plot, the mean life expectancy plot, or the
    Yang plot).
 
Description:
    The conditional mean exceedance function (also referred to as
    the mean residual life function or the expectation of life at t) is
    defined for a non-negative random variable X as:
        CME(x) = E(X-x | X>=x)
    It can be interpreted as the expected remaining life after time t
    given that a unit or individual is of age t.
 
    An exact functional form for the CME function can often be
    obtained if the distribution function of the original variable is
    known.  However, what DATAPLOT calculates is the empirical CME
    function.  Given a variable, the following steps are performed:
        1) the data are sorted into ascending order;
        2) at a given data point, subtract that value from the
           remaining data points and then calculate their mean.
    The paper by Guess and Proschan (see the REFERENCE section below)
    gives the mathematical formulas.
 
    DATAPLOT supports several variations of this plot.  The median or
    midmean can be substituted for the mean.  The other variation is to
    plot the data values after subtracting off the current data value
    (i.e., don't calculate a summary statistic).
 
Syntax 1:
    CME PLOT   <x>     <SUBSET/EXCEPT/FOR qualification>
    where <x> is a response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    CONDITIONAL MEDIAN EXCEEDANCE PLOT <x>
               <SUBSET/EXCEPT/FOR qualification>
    where <x> is a response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the median rather than the mean.
 
Syntax 3:
    CONDITIONAL MIDMEAN EXCEEDANCE PLOT <x>
               <SUBSET/EXCEPT/FOR qualification>
    where <x> is a response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the midmean rather than the mean.
 
Syntax 4:
    CONDITIONAL EXCEEDANCE PLOT <x>  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the raw data values (after subtracting off the
    current value) rather than a summary statistic.
 
Examples:
    CME PLOT Y1
    CME PLOT Y1 SUBSET TAG > 1
    CONDITIONAL MEDIAN EXCEEDANCE PLOT Y1
 
Note:
    DATAPLOT internally fits a line to the resulting plot and saves the
    following internal parameters:
       CMECC    - the correlation coefficient of the fitted line
       CMEA0    - the intercept term
       CMEA1    - the slope term
       SDCMEA0  - the standard deviation of the intercept term
       SDCMEA1  - the standard deviation of the slope term
       CMERESSD - the residual standard deviation
       CMERESDF - the residual degrees of freedom
    Entering STATUS PARAMETERS is a quick way to see the values of all
    of these parameters.  This is a linear fit, so these parameters
    may not be meaningful if a straight line is not a good fit to the
    data.
 
Default:
    None
 
Synonyms:
    The following are synonyms for CME PLOT:
       CONDITIONAL MEAN EXCEEDANCE PLOT
       LIFE EXPECTANCY PLOT
       MEAN LIFE EXPECTANCY PLOT
       MEAN RESIDUAL LIFE PLOT
       YANG PLOT
 
    CONDITIONAL SCATTER EXCEEDANCE PLOT is a synonym for CONDITIONAL
    EXCEEDANCE PLOT.
 
Related Commands:
    LINES             = Sets the type for plot lines.
    CHARACTERS        = Sets the type for plot characters.
    TAIL AREA PLOT    = Generates a tail area plot.
    PLOT              = Generates a data or function plot.
 
Reference:
    "Handbook of Statistics, Vol. 7", Krishnaiah and Rao, eds.
    Elsevier Science Publishers B. V., 1988, pp. 215-224.
    Specifically, the article is "Mean Residual Life: Theory and
    Applications", Frank Guess and Frank Proschan.
 
Applications:
    Reliability, Extreme Value Analysis
 
Implementation Date:
    94.2
 
Program:
    SKIP 25
    READ WASHDC.DAT Y
    .
    TITLE AUTOMATIC
    LINES BLANK ALL
    CHARACTER X ALL
    MULTIPLOT 2 2; MULTIPLOT CORNER COORD 0 0 100 100
    CONDITIONAL EXCEEDANCE PLOT Y
    CME PLOT Y
    CONDITIONAL MEDIAN EXCEEDANCE PLOT Y
    CONDITIONAL MIDMEAN EXCEEDANCE PLOT Y
    END OF MULTIPLOT
 
-----CN (LET)----------------------------------------------
 
CN
 
Name:
    CN (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Jacobi elliptic function cn.
 
Description:
    The Jacobi elliptic function cn is defined as:
        cn(u,k)=COS(phi)
    where phi is the amplitude and is defined as:
        u = INTEGRAL(1./SQRT(1-k*sin(theta)*sin(theta)))dtheta
    where INTEGRAL is the integral from 0 to phi.

    The algorithm DATAPLOT uses takes MC=1-k**2 as its second
    argument rather than k.  Be aware that other routines take k**2
    as the second argument (e.g., IMSL, NAG, and mathematica).  If
    you want to use k**2, enter something like the following:
        LET K2 = <value>
        LET MC = 1 - K2

Syntax:
    LET <a> = CN(<u>,<mc>)  <SUBSET/EXCEPT/FOR qualification>
    where <u> is a number, parameter, or variable;
          <mc> is a number, parameter, or variable;
          <a> is a variable or a parameter (depending on what <u>
               and <mc> are) where the computed values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CN(2,1)
    LET A = CN(X,0.5)
    LET X2 = CN(9,0)
 
Note:
    The Jacobi elliptic functions are computed using a Fortran
    translation of the Algol-60 procedure given by Bulirsch (see the
    REFERENCE section below).

Note:
    DATAPLOT computes the Jacobi elliptic functions sn, cn, and dn.
    An additional 9 functions can be computed from these:
        cd(u,k) = cn(u,k)/dn(u,k)
        sd(u,k) = sn(u,k)/dn(u,k)
        nd(u,k) = 1/dn(u,k)
        dc(u,k) = dn(u,k)/cn(u,k)
        nc(u,k) = 1/cn(u,k)
        sc(u,k) = sn(u,k)/cn(u,k)
        ns(u,k) = 1/sn(u,k)
        ds(u,k) = dn(u,k)/sn(u,k)
        cs(u,k) = cn(u,k)/sn(u,k)

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SN      = Compute the Jacobi elliptic function sn.
    DN      = Compute the Jacobi elliptic function dn.
    PEQ     = Compute the real component of the Weirstrass elliptic
              function (equianharmonic case).
    PEQI    = Compute the complex component of the Weirstrass elliptic
              function (equianharmonic case).
    PLEM    = Compute the real component of the Weirstrass elliptic
              function (lemniscatic case).
    PLEMI   = Compute the complex component of the Weirstrass elliptic
              function (lemniscatic case).
    RC      = Compute the Carlson degenerate elliptic integral.
    RF      = Compute the Carlson elliptic integral of the first kind.
    RD      = Compute the Carlson elliptic integral of the second kind.
    RJ      = Compute the Carlson elliptic integral of the third kind.
    ELLIPC1 = Compute the Legendre complete elliptic integral of the
              first kind.
    ELLIPC2 = Compute the Legendre complete elliptic integral of the
              second kind.
    ELLIP1  = Compute the Legendre elliptic integral of the first
              kind.
    ELLIP2  = Compute the Legendre elliptic integral of the second
              kind.
    ELLIP3  = Compute the Legendre's elliptic integral of the third
              kind.
 
Reference:
    "Numerical Calculation of Elliptic Integrals and Elliptic
    Functions", Bulirsch, Numerische Mathematik, vol. 7, 1965 
    (pp. 78-90).

    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 16).

Applications:
    Special Functions
 
Implementation Date:
    94/11
 
Program:
    TITLE JACOBI ELLIPTIC FUNCTIONS
    LET MC = 0.5
    LINE SOLID DASH DOT
    PLOT CN(X,MC) FOR X = -10 0.1 10 AND
    PLOT SN(X,MC) FOR X = -10 0.1 10 AND
    PLOT DN(X,MC) FOR X = -10 0.1 10
 
-----CNP (LET)-------------------------------------------------------
 
CNP
 
Name:
    CNP (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the Cnp process capability index for a variable.
 
Description:
    This statistic computes the sample Cnp process capability
    index of an industrial process and is defined as follows:

       CNP = (ENGUSL -ENGLSL)/(P(.99865) - P(0.00135))

    with P(x), ENGLSL and ENGUSL denoting the percentile function, lower
    engineering specification limit and the upper engineering
    specification limit, respectively.  This statistic has coverage
    comparable to the normal-based Cp statistic for +/- 3*sigma.  An
    alternative definition has 99% coverage and
    is defined as

       CNP = (ENGUSL -ENGLSL)/(P(.995) - P(0.005))

    This is a non-parametric alternative to the normal-based
    Cp process capability index.

    The specification limits define the range within which a product is
    considered acceptable (values outside this range indicate that a
    product is defective).

Syntax:
    LET <par> = CNP <y>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the computed CNP is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CNP Y1
    LET A = CNP Y1 SUBSET TAG > 2
 
Note:
    The upper and lower specification limits must be specified by the
    user as follows:
        LET LSL = <value>
        LET USL = <value>
 
Note:
    To use the alternative definition, enter the command

        SET CNPK DEFINITION AIRFORCE

    To reset the default, enter

        SET CNPK DEFINITION PEARN

Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CAPABILITY ANALYSIS  = Perform a capability analysis.
    CP                   = Compute a Cp process capability index.
    CPK                  = Compute a Cpk process capability index.
    CNPK                 = Compute a Cnpk process capability index.
    CPM                  = Compute a Cpm process capability index.
    CC                   = Compute a Cc process capability index.
    CPL                  = Compute a Cpl process capability index.
    CPU                  = Compute a Cpu process capability index.
    CNPM                 = Compute a Cnpm process capability index.
    CNPKM                = Compute a Cnpkm process capability index.
    CPMK                 = Compute a Cpmk process capability index.
    PERCENT DEFECTIVE    = Compute the percentage of defectives in a
                           sample.
    EXPECTED LOSS        = Compute the expected loss of a sample.
 
Reference:
    Kotz and Johnson (1993), "Process Capability Indices,"
    Chapman & Hall (chapter 2).

    Chen and Ding (2001), "A New Process Capability Index for Non-Normal
    Distributions," International Journal of Quality & Reliability
    Management, Vol. 18, No. 7, pp. 762-770.
 
Applications:
    Quality Control
 
Implementation Date:
    2015/04
 
Program:
    SKIP 25
    READ FURNACE.DAT X1 X2 X3 Y
    LET LSL = 460
    LET USL = 660
    LET A = CNP Y 
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT 2 2
    MULTIPLOT SCALE FACTOR 2
    TITLE AUTOMATIC
    CNP PLOT Y X1
    CNP PLOT Y X2
    CNP PLOT Y X3
    END OF MULTIPLOT
 
-----CNPK (LET)----------------------------------------------------
 
CNPK
 
Name:
    CNPK (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the process capability index (CNPK) for a variable.
 
Description:
    The process capability index measure the performance (i.e., the
    capability) of an industrial process. The CNPK is a variant of
    the CPK capability indices used for non-normal data and is
    defined as:

      CNPK = MIN(A,B)

    where

        A = (USL-MEDIAN)/(P(.995)-MEDIAN)
        B = (MEDIAN-LSL)/(MEDIAN-P(0.005))

    where USL and LSL are user specified upper and lower
    specification limits, MEDIAN is the median of the data
    values, and P(0.995) and P(0.0050) are the 99.5 and 0.5
    percentiles of the data respectively.

    The specification limits define the range within which a
    product is considered acceptable (values outside this range
    indicate that a product is defective).
 
Syntax:
    LET <param> = CNPK <y> <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <param> is a parameter where the computed CNPK is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CNPK Y1
    LET A = CNPK Y1 SUBSET TAG > 2
 
Note:
    The upper and lower specification limits must be specified by the
    user as follows:

        LET LSL = <value>
        LET USL = <value>
 
Note:
    This statistic is also supported for the following plots:

        CNPK PLOT Y X
        DEX CNPK PLOT Y X1 ... Xk

    You need to specify the LSL and USL values (see above) before
    entering these commands.  For more information on these plots,
    enter 

        HELP STATISTIC PLOT
        HELP DEX PLOT

Note:
    Recall that Chebychev's theorem states that at least 75% of the
    variables data must fall within plus or minus 2 standard deviations
    of the mean and that at least 88% must fall within plus or minus
    3 standard deviations.  This is for any distribution.  For a normal
    distribution, these numbers are 95.4% and 99.7% respectively.
 
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CONTROL CHART             = Generate a control chart.
    CP (LET)                  = Compute the process capability index.
    CPK (LET)                 = Compute the process capability index.
    PERCENT DEFECTIVE (LET)   = Compute the percentage of defectives in
                                a sample.
    EXPECTED LOSS (LET)       = Compute the expected loss of a sample.
 
Reference:
    "Guide to Quality Control", Kaoru Ishikawa, Asian Productivity
    Organization, 1982 (chapter 13).
 
Applications:
    Quality Control
 
Implementation Date:
    2000/1
 
Program:
    SKIP 25
    READ GEAR.DAT Y X
    LET USL = 99.5
    LET USL = 100.5
    CHARACTER X BLANK
    LINE BLANK SOLID
    TITLE AUTOMATIC
    CNPK PLOT Y X
 
-----CNPM (LET)-------------------------------------------------------
 
CNPM
 
Name:
    CNPM (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the Cnpm process capability index for a variable.
 
Description:
    This statistic computes the sample Cnpm process capability
    index of an industrial process and is defined as follows:

       CNPM = (ENGUSL -ENGLSL)/
              [6*SQRT{((P(0.99865)-P(0.00135)/6)**2 + (MEDIAN - TARGET)**2}]
    with P(x), TARGET, ENGLSL, ENGUSL and MEDIAN denoting the percentile
    function, the target engineering limit, the lower engineering
    specification limit, the upper engineering specification limit and
    the sample median, respectively.  This statistic has coverage
    comparable to the normal-based Cpm statistic for +/- 3*sigma.  An
    alternative definition has 99% coverage and uses P(0.995) and
    P(0.005) in the above formula.

    This statistic is a non-parametric alternative to the normal-based
    Cpm process capability index.

    The specification limits define the range within which a product is
    considered acceptable (values outside this range indicate that a
    product is defective).

Syntax:
    LET <par> = CNPM <y>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the computed Cnpm is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CNPM Y1
    LET A = CNPM Y1 SUBSET TAG > 2
 
Note:
    The target and upper and lower specification limits must be specified
    by the user as follows:

        LET TARGET = <value>
        LET LSL = <value>
        LET USL = <value>
 
Note:
    To use the alternative definition, enter the command

        SET CNPK DEFINITION AIRFORCE

    To reset the default, enter

        SET CNPK DEFINITION PEARN

Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CAPABILITY ANALYSIS  = Perform a capability analysis.
    CP                   = Compute a Cp process capability index.
    CPK                  = Compute a Cpk process capability index.
    CNPK                 = Compute a Cnpk process capability index.
    CPM                  = Compute a Cpm process capability index.
    CC                   = Compute a Cc process capability index.
    CPL                  = Compute a Cpl process capability index.
    CPU                  = Compute a Cpu process capability index.
    CNP                  = Compute a Cnp process capability index.
    CNPKM                = Compute a Cnpkm process capability index.
    CPMK                 = Compute a Cpmk process capability index.
    PERCENT DEFECTIVE    = Compute the percentage of defectives in a
                           sample.
    EXPECTED LOSS        = Compute the expected loss of a sample.
 
Reference:
    Chen and Ding (2001), "A New Process Capability Index for Non-Normal
    Distributions," International Journal of Quality & Reliability
    Management, Vol. 18, No. 7, pp. 762-770.
 
    Kaoru Ishikawa (1982), "Guide to Quality Control,"
    Asian Productivity Organization, (chapter 13).
 
Applications:
    Quality Control
 
Implementation Date:
    2015/04
 
Program:
    SKIP 25
    READ FURNACE.DAT X1 X2 X3 Y
    LET TARGET = 550
    LET LSL = 460
    LET USL = 660
    LET A = CNPM Y 
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT 2 2
    MULTIPLOT SCALE FACTOR 2
    TITLE AUTOMATIC
    CNPM PLOT Y X1
    CNPM PLOT Y X2
    CNPM PLOT Y X3
    END OF MULTIPLOT
 
-----CNPMK (LET)-------------------------------------------------------
 
CNPMK
 
Name:
    CNPMK (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the Cnpmk process capability index for a variable.
 
Description:
    This statistic computes the sample Cnpmk process capability
    index of an industrial process and is defined as follows:

       CNPMK = MIN((ENGUSL - MED),(MED-ENGLSL))/
               [3*SQRT{((P(0.99865)-P(0.00135)/6)**2 +
               (MEDIAN - TARGET)**2}]

    with P(x), TARGET, ENGLSL, ENGUSL and MEDIAN denoting the percentile
    function, the target engineering limit, the lower engineering
    specification limit, the upper engineering specification limit and
    the sample median, respectively.  This statistic is a non-parametric
    alternative to the normal-based Cpmk statistic and has coverage
    comparable to Cpmk for +/- 3*sigma.  An alternative definition has
    99% coverage and uses P(0.995) and P(0.005) in the above formula.
    This capability index combines both precision and unbiasedness.

    The Cnpmk statistic can have values from 0 to infinity with
    values between 0.5 and 1 being typical.

    The specification limits define the range within which a product is
    considered acceptable (values outside this range indicate that a
    product is defective).

Syntax:
    LET <par> = CNPMK <y>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the computed Cnpmk is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CNPMK Y1
    LET A = CNPMK Y1 SUBSET TAG > 2
 
Note:
    The target and upper and lower specification limits must be specified
    by the user as follows:

        LET TARGET = <value>
        LET LSL = <value>
        LET USL = <value>
 
Note:
    To use the alternative definition, enter the command

        SET CNPK DEFINITION AIRFORCE

    To reset the default, enter

        SET CNPK DEFINITION PEARN

Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CAPABILITY ANALYSIS  = Perform a capability analysis.
    CP                   = Compute a Cp process capability index.
    CPK                  = Compute a Cpk process capability index.
    CNPK                 = Compute a Cnpk process capability index.
    CPM                  = Compute a Cpm process capability index.
    CC                   = Compute a Cc process capability index.
    CPL                  = Compute a Cpl process capability index.
    CPU                  = Compute a Cpu process capability index.
    CNP                  = Compute a Cnp process capability index.
    CNPKM                = Compute a Cnpkm process capability index.
    CPMK                 = Compute a Cpmk process capability index.
    PERCENT DEFECTIVE    = Compute the percentage of defectives in a
                           sample.
    EXPECTED LOSS        = Compute the expected loss of a sample.
 
Reference:
    Chen and Ding (2001), "A New Process Capability Index for Non-Normal
    Distributions," International Journal of Quality & Reliability
    Management, Vol. 18, No. 7, pp. 762-770.
 
    Kaoru Ishikawa (1982), "Guide to Quality Control,"
    Asian Productivity Organization, (chapter 13).
 
Applications:
    Quality Control
 
Implementation Date:
    2015/04
 
Program:
    SKIP 25
    READ FURNACE.DAT X1 X2 X3 Y
    LET TARGET = 550
    LET LSL = 460
    LET USL = 660
    LET A = CNPM Y 
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT 2 2
    MULTIPLOT SCALE FACTOR 2
    TITLE AUTOMATIC
    CNPMK PLOT Y X1
    CNPMK PLOT Y X2
    CNPMK PLOT Y X3
    END OF MULTIPLOT
 
-----COCHRAN VARIANCE OUTLIER TEST-----------------------------------
 
COCHRAN VARIANCE OUTLIER TEST
 
Name:
    COCHRAN VARIANCE OUTLIER TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform Cochran's variance outlier test to assess the homogeneity
    of variances in the one-factor case.
 
Description:
    Given k groups of data, some analyses assume the standard deviations
    (or equivalently, variances) are equal for the k groups.  For example,
    the F test used in the one-factor analysis of variance problem can be
    sensitive to unequal standard deviations in the k levels of the factor.

    The Levene and Bartlett tests are widely used for assessing the
    homogeneity of variances in the one-factor (with k levels)  case.  The
    Cochran variance outlier test is another alternative for assessing the
    homogeneity of variances.

    Although the Cochran test has a similar purpose to the Levene and
    Bartlett tests, it tends to be used in a somewhat different context.
    The Levene and Bartlett test are used to assess overall homogeneity
    and are typically used in the context of deciding whether a specific
    test (e.g., an F test) is appropriate for a given set of data.  These
    tests do not identify which variances are different.  On the other
    hand, the Cochran variance outlier test tends to be used in the
    context of proficiency testing.  In this case, we are primarily
    interested in identifying laboratories that are "different".  For
    example, a laboratory with an unusually large variance may indicate
    the need for close examination of that laboratory's practices.

    Cochran's test is essentially an outlier test.  Cochran's original
    test statistic is defined as

         C = largest s(i)**2/SUM[i=1 to k][s(i)**2]

    That is, it is the ratio of the largest variance to the sum of the
    variances.  This is an upper-tailed test for the maximum variance.
    The critical values can be computed from

         Cul(alpha,n,k) = 1/[1 + (k-1)/FPPF(alpha/k,(n-1),(k-1)*(n-1))]

    where

         Cul   = the upper critical value (i.e., variance is an outlier
                 if the test statistic is greater than Cul)
         alpha = the significance level
         n     = the number of observations in each group
         k     = the number of groups
         FPPF  = the percent point function of the F distribution

    Some comments on this test.

        1. It assumes that the data in each group are normally
           distributed.

        2. It assumes the sample sizes in each group are equal.

        3. It tests for the maximum variance only (i.e., no test for
           the minimum variance).

    't Lam (2009) has extended the Cochran test to support unequal sample
    sizes and tests for the minimum variance.  He refers to this as the
    G statistic.  Dataplot in fact generates the G statistic rather than
    the C statistic for this test.  When the sample sizes are in fact
    equal, the G statistic for the maximum variance is equivalent to the
    Cochran C statistic.

    The G statistic for the j-th group is

        G(j) = nu(j)*s(j)**2/SUM[i=1 to k][nu(i)*s(i)**2]

    where nu(i) = n(i) - 1 with n(i) denoting the sample size of the i-th
    group.

    The critical value for testing the maximum variance is

         Gul(alpha,nu(j),nupool,k) = 1/[1 + (nupool/nu(j) - 1)/
                                     FPPF(alpha/k,nu(j),nupool-nu(j))]

    where

        nupool   = pooled degrees of freedom
                 = SUM[i=1 to k][nu(i)]
        nu(j)    = the degrees of freedom corresponding to the maximum
                   variance

    Reject the null hypothesis that the maximum variance is an outlier if
    the test statistic is greater than the critical value.

    The critical value for testing the minimum variance is

         Gll(alpha,nu(j),nupool,k) = 1/[1 + (nupool/nu(j) - 1)/
                                     FPPF(1 - (alpha/k),nu(j),nupool-nu(j))]

    In this case, nu(j) corresponds to the minimum variance.  Reject the null
    hypothesis that the minimum variance is an outlier if the test statistic is
    less than the critical value.

    A two-sided test can also be performed.  Just use alpha/2 in place of
    alpha in the above formulas.  Although the 't Lam article provides a
    method for determining whether the maximum or minimum variance is more
    extreme, Dataplot will simply return the test statistic and critical
    values for both the maximum and the minimum cases.

    Note that with the G statistic, we are actually testing for the
    maximum (or minimum) value of the G statistic rather than the maximum
    (or minimum) variance.  If the sample sizes are equal (or at least
    approximately equal), this should be equivalent.  However, if there is
    a large difference in sample sizes, this may not be the case.  That is,
    we are testing the maximum nu(j)*s(j)**2 rather than the maximum s(j)**2.

    If there are potentially multiple outliers in the variances, the
    recommended procedure is to perform the test sequentially until all
    outlying variances are removed.  That is, if the test indicates the
    maximum variance is an outlier, remove that group of data and perform
    the test again.  Repeat until the test indicates that 

Syntax 1:
    COCHRAN VARIANCE OUTLIER TEST  <y>  <tag>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <tag> is a factor identifier variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the test for the maximum variance.

Syntax 2:
    COCHRAN MINIMUM VARIANCE OUTLIER TEST  <y>  <tag>
                             <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <tag> is a factor identifier variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the test for the minimum variance.

Syntax 3:
    COCHRAN TWO-SIDED VARIANCE OUTLIER TEST  <y>  <tag>
                               <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <tag> is a factor identifier variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the two-sided test (i.e., both the minimum
    and maximum variance).

Syntax 4:
    MULTIPLE COCHRAN VARIANCE OUTLIER TEST  <y1> ...  <yk> 
                              <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of two to 30 response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the test for the maximum variance.

Syntax 5:
    MULTIPLE COCHRAN MINIMUM VARIANCE OUTLIER TEST  <y1> ...  <yk> 
                             <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of two to 30 response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the test for the minimum variance.

Syntax 6:
    MULTIPLE COCHRAN TWO-SIDED VARIANCE OUTLIER TEST  <y1> ...  <yk> 
                               <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of two to 30 response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the two-sided test.

Examples:
    COCHRAN VARIANCE OUTLIER TEST Y X
    COCHRAN VARIANCE OUTLIER TEST Y X  SUBSET X <> 5
    COCHRAN MINIMUM VARIANCE OUTLIER TEST Y X
    COCHRAN TWO-SIDED VARIANCE OUTLIER TEST Y X
 
Note:
    The following parameters are created automatically by this command

        STATVAL   = value of test statistic for either the 
                    maximum or the minimum case
        STATCDF   = CDF of the test statistic for either the 
                    maximum or the minimum case
        PVALUE    = p-value of the test statistic for either the 
                    maximum or the minimum case

        STATVALU  = value of test statistic for the maximum variance
                    for the two-sided test
        STATVALL  = value of test statistic for the minimum variance
                    for the two-sided test

        CUTOF001   = the 0.1% critical value
        CUTOF005   = the 0.5% critical value
        CUTOFF01   = the 1% critical value
        CUTOF025   = the 2.5% critical value
        CUTOFF05   = the 5% critical value
        CUTOFF10   = the 10% critical value
        CUTOFF25   = the 25% critical value
        CUTOFF50   = the 50% critical value
        CUTOFF75   = the 75% critical value
        CUTOFF90   = the 90% critical value
        CUTOFF95   = the 95% critical value
        CUTOF975   = the 97.5% critical value
        CUTOFF99   = the 99% critical value
        CUTOF995   = the 99.5% critical value
        CUTOF999   = the 99.9% critical value

    P-values are truncated at a minimum of 0.001 and a maximum of 99.999.
    P-values and CDF statistics are not currently computed for the
    two-sided case.

Note:
    In proficiency testing, John Mandel's k consistency statistic has been
    used (specifically, the ASTM E-691 standard) to identify laboratories
    with excessively large variances.

    The ISO 5725 standard proposes Cochran's variance outlier test as an
    alternative to Mandel's k consistency statistic.

Note:
    The following statistics are also supported:

        LET C      = COCHRAN VARIANCE OUTLIER TEST Y X
        LET CV95   = COCHRAN VARIANCE OUTLIER CV95 Y X
        LET CV99   = COCHRAN VARIANCE OUTLIER CV99 Y X
        LET CCDF   = COCHRAN VARIANCE OUTLIER CDF Y X
        LET CPVAL  = COCHRAN VARIANCE OUTLIER PVALUE Y X
        LET CM     = COCHRAN MINIMUM VARIANCE OUTLIER TEST Y X
        LET CMV05  = COCHRAN MINIMUM VARIANCE OUTLIER CV05 Y X
        LET CMV01  = COCHRAN MINIMUM VARIANCE OUTLIER CV01 Y X
        LET CMCDF  = COCHRAN MINIMUM VARIANCE OUTLIER CDF Y X
        LET CMPVAL = COCHRAN MINIMUM VARIANCE OUTLIER PVALUE Y X

    Enter HELP STATISTICS to see what commands can use these
    statistics.

Default:
    If MIMIMUM or TWO-SIDED is not specified on the command, a test will be
    performed for the maximum variance.
 
Synonyms:
    COCHRAN VARIANCE OUTLIER is a synonym for
    COCHRAN VARIANCE OUTLIER TEST
 
Related Commands:
    LEVENE TEST      = Compute Levene's test for equal variances.
    BARTLETT TEST    = Compute Bartlett's test for equal variances.
    F TEST           = Performs a two-sample F test for equal variances.
    VARIANCE PLOT    = Plot variances against group-id's.
 
Reference:
    W.G. Cochran (1941), The distribution of the largest of a set
    of estimated variances as a fraction of their total,
    Annals of Human Genetics (London) 11(1), pp. 47–52.

    RUBEM U.E. 't LAM (2010), "Scrutiny of Variance Results for Outliers:
    Cochran's Test Optimized", Analytica Chimica ACTA, Vol. 659, No. 1-2,
    pp. 68-84.

    Kanji (2006), "100 Statistical Tests", SAGE Publications, p. 75.

    ISO Standard 5725–2:1994, “Accuracy (trueness and precision) of
    measurement methods and results – Part 2: Basic method for the
    determination of repeatability and reproducibility of a standard
    measurement method”, International Organization for Standardization,
    Geneva, Switzerland, 1994.
 
Applications:
    Proficiency Tests
 
Implementation Date:
    2015/04
 
Program:
    . Step 1:   Read the data
    .
    dimension 40 columns
    skip 25
    read gear.dat y x
    set write decimals 5
    .
    . Step 2:   Generate a variance plot
    .
    label case asis
    title case asis
    title offset 2
    xlimits 1 10
    major x1tic mark number 10
    x1tic mark offset 0.5 0.5
    x1label Batch
    y1label Variance
    line blank solid
    character circle blank
    character hw 1 0.75
    character fill on
    title Variance Plot for GEAR.DAT
    variance plot y x
    .
    . Step 2:   Perform the test
    .
    .
    cochran variance outlier test y x
    let c     = cochran variance outlier test y x
    let cv95  = cochran variance outlier cv95 y x
    let cv99  = cochran variance outlier cv99 y x
    let ccdf  = cochran variance outlier cdf y x
    let cpval = cochran variance outlier pvalue y x
    print c cv95 cv99 ccdf cpval
    cochran minimum variance outlier test y x
    let cm     = cochran minimum variance outlier test y x
    let cmv05  = cochran minimum variance outlier cv05 y x
    let cmv01  = cochran minimum variance outlier cv01 y x
    let cmcdf  = cochran minimum variance outlier cdf y x
    let cmpval = cochran minimum variance outlier pvalue y x
    print cm cmv05 cmv01 cmcdf cmpval
    cochran two-sided variance outlier test y x

-----COCHRAN TEST-----------------------------------------
 
COCHRAN TEST
 
Name:
    COCHRAN TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform a Cochran test that c treatments have identical effects.
 
Description:
    The Cochran test is a non-parametric test for analyzing
    randomized complete block designs where the response variable
    is a binary variable (i.e., there are only two possible outcomes,
    which are coded as 0 and 1).

    The Cochran test assumes that there are c experimental
    treatments (c >= 2).  The observations are arranged in
    r blocks, that is

                     Treatment
    Block  1    2      ...      c
      1   X11  X12     ...     X1c
      2   X21  X22     ...     X2c
      3   X31  X32     ...     X3c
     ...  ...  ...     ...     ...
      r   Xr1  Xr2     ...     Xrc

    The Friedman test is the usual non-parametric test for this
    kind of design.  The Cochran test is applied for the special
    case of a binary response variable (i.e., it can have only one
    of two possible outcomes).

    Then the Cochran test is 

        H0: The treatments are equally effective.
        HA: There is a difference in effectiveness among treatments.
        Test Statistic:
            T = c*(c-1)*SUM[i=1 to c][(C(j) - N/c)**2/
                SUM[i=1 to r][R(i)*(c - R(i))]

            with c, C(i), r, R(i), and N denoting the number of
            treatments, the column total for the ith treatment,
            the number of blocks, the row total for the ith block,
            and the grand total, respectively.
        Significance Level: ALPHA
        Critical Region:
            T > CHSPPF(1-ALPHA,c-1) where CHSPPF is the chi-square
            percent point function.

            Note that this is based on a large sample approximation.
            In particular, it assumes that r is "large".
        Conclusion: Reject the null hypothesis if the test
                    statistic is in the critical region.

Syntax:
    COCHRAN TEST  <y>  <block> <treat>
                       <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <block> is a variable that identifies the block;
          <treat> is a variable that identifies the treatment;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    COCHRAN TEST Y BLOCK TREATMENT
    COCHRAN TEST Y X1 X2
    COCHRAN TEST Y BLOCK TREATMENT  SUBSET BLOCK > 2
 
Note:
    In Dataplot, the variables should be given as:
 
        Y   BLOCK   TREAT
       X11    1      1
       X12    1      2
       ...    1     ...
       X1k    1      k 
       X21    2      1
       X22    2      2
       ...    2     ...
       X2k    2      k 
 
       ...   ...    ...
 
 
       Xb1    b      1
       Xb2    b      2
       ...    b     ...
       Xb3    b      k 
 
    If your data are in a format similar to that given in the
    DESCRIPTION section (i.e., you have colums Y1 to Yk, each
    with b rows), you can convert it to the format required by
    Dataplot with the commands:
 
       LET NTREAT = 5
       LET NBLOCK = SIZE Y1
       LET NTOTAL = K*NBLOCK
       LET BLOCK = SEQUENCE 1 1 NBLOCK FOR I = 1 1 NTOT
       LET Y2 TREAT= STACK Y1 Y2 Y3 Y4 Y5
       COCHRAN TEST Y2 BLOCK TREAT

Note:
    The Cochran test is based on the following assumptions:

       1) The blocks were randomly selected from the population of
          all possible blocks.

       2) The outcomes of the treatments can be coded as binary
          responses (i.e., a "0" or "1") in a way that is common
          to all treatments within each block.

Note:
    The case where there are exactly two treatments is equivalent
    to the McNemar test.  The McNemar test is a two-tailed sign
    test.

Note:
    If the Cochran test rejects the null hypothesis of equally
    effective treatments,  pairwise multiple comparisons can
    be made by applying the Cochran test on the two treatments
    of interest.  For example, to test treatments 3 and 5,
    you can do something like the following

       COCHRAN TEST Y BLOCK TREATMENT  SUBSET TREATMENT = 3  5

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FRIEDMAN TEST         = Perform a Friedman test.
    KRUSKAL WALLIS TEST   = Perform a Kruskal Wallis test.
    ANOVA                 = Perform an analysis of variance.
    SIGN TEST             = Perform a sign test.
    MEDIAN POLISH         = Carries out a robust ANOVA.
    T TEST                = Carries out a t test.
    RANK SUM TEST         = Perform a rank sum test.
    SIGNED RANK TEST      = Perform a signed rank test.
 
Reference:
    "Practical Nonparametric Statistics", Third Edition, Wiley,
    1999, pp. 250-256.
 
Applications:
    Analysis of Binary Two-Way Randomized Block Designs
 
Implementation Date:
    2005/12
 
Program:
    . Following example from p. 253 of Conovover
    READ Y1 Y2 Y3
    1 1 1
    1 1 1
    0 1 0
    1 1 0
    0 0 0
    1 1 1
    1 1 1
    1 1 0
    0 0 1
    0 1 0
    1 1 1
    1 1 1
    END OF DATA
    LET N1 = SIZE X1
    LET NTOT = 3*N1
    LET BLOCK = SEQUENCE 1 1 N1 FOR I = 1 1 NTOT
    LET Y TREAT = STACK Y1 Y2 Y3
    COCHRAN Y BLOCK TREAT

    This example generates the following output

        COCHRAN NON-PARAMETRIC TEST FOR RANDOMIZED COMPLETE BLOCK DESIGN
        FOR DICHOTOMOUS DATA
     
    1. STATISTICS
          NUMBER OF SUBJECTS (ROWS)           =       11
          NUMBER OF TREATMENTS                =        3
          COCHRAN TEST STATISTIC             =    2.800000
     
    2. PERCENT POINTS OF THE LARGE SAMPLE CHI-SQUARE REFERENCE DISTRIBUTION
       FOR COCHRAN TEST STATISTIC
          0          % POINT    =    0.000000
          50         % POINT    =    1.386294
          75         % POINT    =    2.772589
          90         % POINT    =    4.605170
          95         % POINT    =    5.991464
          99         % POINT    =    9.210342
          99.9       % POINT    =    13.81554
     
     
             75.34030       % Point:     2.800000
     
    3. CONCLUSION (AT THE 5% LEVEL):
          THE        3 TREATMENTS HAVE EQUAL EFFECTS

-----COCODE (LET)---------------------------------------------------
 
COCODE
 
Name:
    COCODE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Generate a coded variable based on another variable.
 
Description:
    Suppose X is the variable to be coded and XREF is the variable that
    dictates the coding.  Then all elements of X that match XREF(1) are
    coded with a 1, all elements of X that match XREF(2) are coded with
    a 2, and so on up to the last element of XREF.
 
    This command is useful for generating ordered plots for a second
    response variable based on an ordering of the horizontal axis
    elements from a preceding plot.
 
Syntax:
    LET <xprime> = COCODE <x1> <xref> <SUBSET/EXCEPT/FOR qualification>
    where <x1> is the variable to be coded;
          <xref> is a list of values that are matched against <x1> (not
               necessarily the same size as <x1>);
          <xprime> is a variable of the same length as <x1> where the
               coded values are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET XPRIME = COCODE X1 XREF
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COCOPY         = Generate a coded variable based on another
                     variable.
    CODE           = Generate a coded variable.
    CODE2          = Generate a binary coded variable.
    CODE4          = Generate a quartile coded variable.
    CODE8          = Generate an octal coded variable.
 
Applications:
    Data Tranformation
 
Implementation Date:
    92/5
 
Program:
    LET X1 = DATA 12 15 4 12 12 4 15 4 15
    LET XREF = DATA 15 4 12
    LET XPRIME = COCODE X1 XREF

    The variable XPRIME will contain the following values:
       3, 1, 2, 3, 3, 2, 1, 2, 1
 
-----COCOPY (LET)---------------------------------------------------
 
COCOPY
 
Name:
    COCOPY (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Generate a coded variable based on another variable.
 
Description:
    This command is similar to the COCODE command.  For COCODE, suppose
    X is the variable to be coded and XREF is the variable that
    dictates the coding.  Then all elements of X that match XREF(1) are
    coded with a 1, all elements of X that match XREF(2) are coded with
    a 2, and so on up to the last element of XREF.  With COCOPY,
    instead of coding the new variable as 1, 2, ... ,N, an additional
    variable YREF is used.  Elements of X matching XREF(1) are coded
    to YREF(1), elements of X matching XREF(2) are coded to YREF(2),
    and so on.
 
    This command is useful for generating ordered plots for a second
    response variable based on an ordering of the horizontal axis
    elements from a preceding plot.
 
Syntax:
    LET <xprime> = COCOPY <x1> <xref> <yref>
                  <SUBSET/EXCEPT/FOR qualification>
    where <x1> is the variableto be coded;
          <xref> is a list of values that are matched against <x1> (not
               necessarily the same size as <x1>);
          <xprime> is a variable of the same length as <x1> where the
               coded values are saved;
          <yref> is a variable of the same length as <xref> that
               defines the coded values;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET XPRIME = COCOPY X1 XREF YREF
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COCODE         = Generate a coded variable based on another
                     variable.
    CODE           = Generate a coded variable.
    CODE2          = Generate a binary coded variable.
    CODE4          = Generate a quartile coded variable.
    CODE8          = Generate an octal coded variable.
 
Applications:
    XX
 
Implementation Date:
    92/5
 
Program:
    LET X1 = DATA 12 15 4 12 12 4 15 4 15
    LET XREF = DATA 15 4 12
    LET YREF = DATA 1 4 9
    LET XPRIME = COCODE X1 XREF

    The variable XPRIME will contain the following values:
       9, 1, 4, 9, 9, 4, 1, 4, 1
 
-----CODING----------------------------------------------------------
 
CODING
The following are DATAPLOT coding commands:
    CODE       = Code data            : min => 1; next min => 2, etc.
    CODE2      = Code data into halves: below med => 1; above med => 2
    CODE4      = Code data into quartiles: output = 1, 2, 3, 4
    CODE8      = Code data into eighths  : output = 1, 2, ..., 7, 8
    COCODE     = Code data according to analyst-specified mapping
 
-----CODE (LET)---------------------------------------------------
 
CODE
 
Name:
    CODE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Generate a coded variable.
 
Description:
    If there are N unique values in a variable, give each of them an
    integer code from 1 (for the minimum) to N (for the maximum).  This
    command is useful for generating tag variables where elements of
    the variable with the same value have the same value for the tag
    variable as well.
 
Syntax:
    LET <xprime> = CODE <x1>  <SUBSET/EXCEPT/FOR qualification>
    where <x1> is the first  response variable;
          <xprime> is a variable of the same length as <x1> where the
               coded values are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET XPRIME = CODE X1
 
Default:
    None
 
Synonyms:
    CODED is a synonym for CODE.
 
Related Commands:
    COCODE         = Generate a cocoded variable.
    CODE2          = Generate a binary coded variable.
    CODE4          = Generate a quartile coded variable.
    CODE8          = Generate an octal coded variable.
    CODEH          = Generate a hinge coded variable.
 
Applications:
    Data Manipulation
 
Implementation Date:
    Pre-1987
 
Program:
    LET X1 = DATA 12 15 4 12 12 4 15 4 15
    LET XPRIME = CODE X1
    The variable XPRIME will contain the following values:
       2, 3, 1, 2, 2, 1, 3, 1, 3
 
-----CODE2 (LET)---------------------------------------------------
 
 
CODE2
 
Name:
    CODE2 (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Generate a binary coded variable.
 
Description:
    The data is split into 2 categories:  all values below the median
    are coded as 1 while all values above the median are coded as 2.
    Values exactly equal to the median are coded as 1.
 
Syntax:
    LET <xprime> = CODE2 <x1>  <SUBSET/EXCEPT/FOR qualification>
    where <x1> is the first  response variable,
          <xprime> is a variable of the same length as <x1>
              where the coded values are saved,
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET XPRIME = CODE2 X1
 
Note:
    If the response variable contains all distinct values, then half
    the values are coded as 1 and half are coded as 2.  However, if the
    response variable contains a large number of ties, this may not
    necessarily be true.  Consider the following example:
      LET X4 = DATA 1 10 1 1 1 10 10 10 10 10 1 10
      LET XPRIME = CODE2 X4
    In this case, the median is 10 (which equals the maximum), and all
    values are coded as 1 (values equal to the median are coded to 1).
    This means that data variables which have 2 valid values may not
    necessarily code all the smaller as 1 and all the larger as 2.
    Use CODE to give each distinct value a separate code.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COCODE         = Generate a cocoded variable.
    CODE           = Generate a coded variable.
    CODE4          = Generate a quartile coded variable.
    CODE8          = Generate an octal coded variable.
    CODEH          = Generate a hinge coded variable.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    LET X1 = DATA 12 15 4 12 12 4 15 4 15
    LET XPRIME = CODE2 X1
    The variable XPRIME will contain the following values:
       1, 2, 1, 1, 1, 1, 2, 1, 2
 
-----CODE4 (LET)---------------------------------------------------
 
CODE4
 
Name:
    CODE4 (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Generate a quartile coded variable.
 
Description:
    The data are coded as follows:
        PERCENTILE        CODE
        ==========        ====
         0 <= x <=  25      1
        25 <  x <=  50      2
        50 <  x <=  75      3
        75 <  x <= 100      4
 
Syntax:
    LET <xprime> = CODE4 <x1>  <SUBSET/EXCEPT/FOR qualification>
    where <x1> is a first response variable;
          <xprime> is a variable of the same length as <x1> where the
               coded values are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET XPRIME = CODE4 X1
 
Note:
    If the response variable contains all distinct values, then the
    coded values will be equally split among 1, 2, 3, and 4.  However,
    if the response variable contains a large number of ties, this may
    not be true.  For example, in the program below no values are coded
    as 3.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COCODE         = Generate a cocoded variable.
    CODE           = Generate a coded variable.
    CODE2          = Generate a binary coded variable.
    CODE8          = Generate an octal coded variable.
    CODEH          = Generate a hinge coded variable.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    LET X1 = DATA 12 15 4 12 12 4 15 4 15
    LET XPRIME = CODE4 X1
    The variable XPRIME will contain the following values:
       2, 4, 1, 2, 2, 1, 4, 1, 4
 
-----CODE8 (LET)---------------------------------------------------
 
CODE8
 
Name:
    CODE8 (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Generate an octile coded variable.
 
Description:
    The data are coded as follows:
        PERCENTILE            CODE
        ==========            ====
         0   <= x <=  12.5      1
        12.5 <  x <=  25.0      2
        25.0 <  x <=  37.5      3
        37.5 <  x <=  50.0      4
        50.0 <  x <=  62.5      5
        62.5 <  x <=  75.0      6
        75.0 <  x <=  87.5      7
        87.5 <  x <= 100.0      7
 
Syntax:
    LET <xprime> = CODE8 <x1>  <SUBSET/EXCEPT/FOR qualification>
    where <x1> is the a response variable;
          <xprime> is a variable of the same length as <x1> where the
               coded values are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET XPRIME = CODE8 X1
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COCODE         = Generate a cocoded variable.
    CODE           = Generate a coded variable.
    CODE2          = Generate a binary coded variable.
    CODE4          = Generate an quartile coded variable.
    CODEH          = Generate a hinge coded variable.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    LET X1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET XPRIME = CODE8 X1
 
-----CODE CROSS TABULATE (LET)-------------------------------------------
 
CODE CROSS TABULATE
 
Name:
    CODE CROSS TABULATE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Generate a coded group id variable.
 
Description:
    A number of Dataplot commands expect data in the form

        Y  X

    with Y denoting a response variable and X denoting a group id
    variable.

    There may be times when you want to use one of these commands
    when there are multiple group id variables.  For example, you
    may want to generate box plots, mean plots, or strip plots for
    the values withn each combination of group id's.  It can also
    be used to simplify multiple SUBSET clauses.
 
    The CODE CROSS TABULATE command can be used to generate a
    single group id variable from multiple group id variables.
    From two to six group id variables may be used.

    For example, if X1 defines 3 groups and X2 defines 4 groups,
    then the generated variable, XCODE, will be defined as

          X1    X2    XCODE
          =================
           1     1        1
           1     2        2
           1     3        3
           1     4        4
           2     1        5
           2     2        6
           2     3        7
           2     4        8
           3     1        9
           3     2       10
           3     3       11
           3     4       12
           
Syntax:
    LET <xcode> = CODE CROSS TABULATE <x1>  ... <xk>
                  <SUBSET/EXCEPT/FOR qualification>
    where <x1> is the first group id variable;
          <xk> is the kth group id variable;
          <xcode> is a variable where the coded values are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The minimum number of group id variables is two and the maximum
    number of group id variables is six.

    The variables on the right hand side of the equal sign must
    all have the same number of elements,  The <xcode> variable
    will also have this number of elements.

Examples:
    LET XCODE = CODE CROSS TABULATE X1 X2
    LET XCODE = CODE CROSS TABULATE X1 X2 X3
    LET XCODE = CODE CROSS TABULATE X1 X2 X3 X4
    LET XCODE = CODE CROSS TABULATE X1 X2 X3 X4 X5
    LET XCODE = CODE CROSS TABULATE X1 X2 X3 X4 X5 X6
 
Note:
    For plot commands, you may want to control the values of the
    coded variable.  There are two ways you can do this:

       1) You can define an initial offset with the command

              SET CROSS TABULATE OFFSET <value>

          For example, if <value> = 3, then the first value
          for the coded value will be 4 (1 + 3 = 4).

       2) You can define the spacing between groups with the
          commands

             SET CROSS TABULATE GROUP SIZE ONE   <value>
             SET CROSS TABULATE GROUP SIZE TWO   <value>
             SET CROSS TABULATE GROUP SIZE THREE <value>
             SET CROSS TABULATE GROUP SIZE FOUR  <value>
             SET CROSS TABULATE GROUP SIZE FIVE  <value>

    If OFFSET defines the offset, NGROUP1, ..., NGROUP define the
    number of distinct elements in the group variables, and
    ICCTG1, ... ICCTG5 define the values defined by the
    SET CROSS TABULATE GROUP SIZE commands, then the coded variable
    will be defined as

        For 2 group id variables:
        ICODE = OFFSET + (ISET1-1)NFACT2 + ISET2

        For 3 group id variables:
        ICODE = OFFSET + (ISET1-1)*NFACT2*NFACT3 +
                (ISET2-1)*NFACT3 + ISET3

        For 4 group id variables:
        ICODE = OFFSET + (ISET1-1)*NFACT2*NFACT3*NFACT4 +
                (ISET2-1)*NFACT3*NFACT4 +
                (ISET3-1)*NFACT + ISET4

        For 5 group id variables:
        ICODE = OFFSET +
                (ISET1-1)*NFACT2*NFACT3*NFACT4*NFACT5 +
                (ISET2-1)*NFACT3*NFACT4*NFACT5 +
                (ISET3-1)*NFACT4*NFACT5
                (ISET4-1)*NFACT5 + ISET5

        For 6 group id variables:
        ICODE = OFFSET +
                (ISET1-1)*NFACT2*NFACT3*NFACT4*NFACT5*NFACT6 +
                (ISET2-1)*NFACT3*NFACT4*NFACT5*NFACT6 +
                (ISET3-1)*NFACT4*NFACT5*NFACT6 +
                (ISET4-1)*NFACT5*NFACT6 +
                (ISET5-1)*NFACT6 + ISET6

    where ISET1, ..., ISET6 define the i-th distinct value of groups
    one to six, respectively, and

        NFACT2 = MAX(NGROUP2,ICCTG1)
        NFACT3 = MAX(NGROUP3,ICCTG2)
        NFACT4 = MAX(NGROUP4,ICCTG3)
        NFACT5 = MAX(NGROUP5,ICCTG4)
        NFACT6 = MAX(NGROUP6,ICCTG5)

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CODE           = Generate a coded variable.
    COCODE         = Generate a cocoded variable.
    CODE2          = Generate a binary coded variable.
    CODE4          = Generate a quartile coded variable.
    CODE8          = Generate an octal coded variable.
    CODEH          = Generate a hinge coded variable.
 
Applications:
    Data Manipulation
 
Implementation Date:
    2009/6
 
Program:
    SKIP 25
    READ FURNACE.DAT RUN ZONE WAFER FILMTHIC
    .
    SET CODE CROSS TABULATE OFFSET 8
    SET CODE CROSS TABULATE GROUP SIZE ONE 10
    LET IX = CODE CROSS TABULATE WAFER ZONE
    .
    FENCES ON
    CHARACTER BOX PLOT
    LINE BOX PLOT
    YLIMITS 450 650
    XLIMITS 10 20
    TIC OFFSET UNITS DATA
    XTIC MARK OFFSET 5 5
    .
    LABEL CASE ASIS
    TIC MARK LABEL CASE ASIS
    MAJOR XTIC MARK NUMBER 2
    MINOR XTIC MARK NUMBER 0
    X1TIC MARK LABEL FORMAT ALPHA
    X1TIC MARK LABEL CONTENT ...
          Zonesp()-sp()1SP()2SP()3SP()4CR()Wafersp()1 ...
          Zonesp()-sp()1SP()2SP()3SP()4CR()Wafersp()2
    Y1LABEL Film Thickness
    .
    BOX PLOT FILMTHIC IX
 
-----CODED BINNED (LET)-----------------------------------------
 
CODED BINNED
 
Name:
    CODED BINNED (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Bin (i.e., create a frequency table) a response variable and create
    an additional variable that specifies to which bin each observation
    belongs.
 
Description:
    This command is similar to the BINNED command.  However, it creates
    an additional "coded" variable that identifies the bin number of
    each observation.

    Binning a data variable means to divide it into classes
    and compute the frequency for each class.  This is the
    numerical equivalent of a histogram.  Creating the classes
    for the binning uses the same rules as the histogram.
    That is

      1) The class width is 0.3 times the sample standard
         deviation.
      2) The lower limit is the sample mean minus 6 times the
         standard deviation.
      3) The upper limit is the sample mean plus 6 times the
         standard deviation.

    As with the histogram, you can use the CLASS WIDTH, CLASS
    LOWER, and CLASS UPPER commands to override these defaults.
    Also, you can specify that relative frequencies rather than
    counts be computed.   The command
    SET RELATIVE HISTOGRAM <AREA/PERCENT> can be used to specify
    whether relative frequencies are computed so that the area
    sums to 1 or so that frequencies sum to 1.  The first option,
    which is the default, is useful for when using the relative
    binning as an estimate of a probability distribution.  The
    second option is useful when you want to see what percentage
    of the data falls in a given class.
 
Syntax 1:
    LET <y2> <x2> <ycoded> = CODED BINNED <y>
                             <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <y2> is a variable where the computed counts (or
              frequencies) are stored;
          <x2> is a variable where the computed bin mid-points
              are stored;
          <ycoded> is a variable where the bin-id's are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    LET <y2> <x2> <ycoded> = CODED RELATIVE BINNED <y>
                             <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <y2> is a variable where the computed counts (or
              frequencies) are stored;
          <x2> is a variable where the computed bin mid-points
              are stored;
          <ycoded> is a variable where the bin-id's are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax generates relative frequencies instead of counts when
    binning the data.

Examples:
    LET Y2 X YCODE = BINNED Y
    LET Y2 X YCODE = BINNED Y SUBSET TAG > 2
    LET Y2 X YCODE = RELATIVE BINNED Y
 
Default:
    None
 
Synonyms:
    CODED BINNED is a synonym for BINNED CODED.
    RELATIVE CODED BINNED is a synonym for CODED RELATIVE BINNED.
 
Related Commands:
    BINNED                   = Generate binned data from raw data.
    HISTOGRAM                = Generate a histogram.
    FREQUENCY PLOT           = Generate a frequency plot.
    FREQUENCY                = Compute frequency of occurences of specified
                               values in a variable.
    CLASS WIDTH              = Set class width for histograms.
    COMBINE FREQUENCY TABLE  = Combine low frequency classes in a frequency
                               table.
 
Applications:
    Data Analysis
 
Implementation Date:
    2012/12
 
Program:
    let y = norm rand numb for i = 1 1 50
    .
    let y2 x2 ycoded = coded binned y
    let ntemp = size y2
    let xseq = sequence 1 1 ntemp
    .
    set write decimals 3
    print x2 y2  xseq
    print y ycoded
 
-----CODE DEX (LET)---------------------------------------------------
 
CODE DEX
 
Name:
    CODE DEX (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Generate a coded variable for a factor variable used in analyzing
    a 2-level full or fractional factorial design.
 
Description:
    To analyze a 2-level full or fractional factorial design, the factor
    variable are typically coded with lower level set to -1, the upper
    level set to +1, and center points set to 0.  This will be referred
    to as classical units.

    If your factor variables are in original units of the data rather
    than classical units, you can use the CODE DEX command to convert
    them to classical units.

    This command should only be used if your data has 2 or 3 distinct
    values.  If you have more than 3 distinct values, and error message
    will be generated and the coded variable will not be created.  If
    you have only one unique value, the code variable will set all values
    to +1.

Syntax:
    LET <x> = CODE DEX <z>   <SUBSET/EXCEPT/FOR qualification>
    where <z> is the factor variable;
          <x> is a variable where the coded values are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET X2 = CODE DEX Z2

Note:
    You can use the same name for the input variable and the output
    variable.  For example

       LET X2 = CODE DEX X2

    If you want to have variables in the original units for some
    purposes, you can save the data in original units before using
    the CODE DEX command.  For example

       LOOP FOR J = 1 1 K
           LET Z^J = X^J
           LET X^J = CODE DEX Z^J
       END OF LOOP

Default:
    None
 
Synonyms:
    DEX CODE
 
Related Commands:
    DEX CHECK CLASSIC  = Determine if your factor variables are in
                         classic units.
    CODE               = Generate a coded variable based on distinct
                         values.

Applications:
    Analysis of 2-level full and fractional factorial designs
 
Implementation Date:
    2018/02
 
Program:
    SKIP 50
    READ CLAYTILE.DAT Y X1 TO X7
    LOOP FOR J = 1 1 7
        LET X^J = CODE DEX X^J
    END OF LOOP
    .
    SET WRITE DECIMALS 0
    PRINT Y X1 X2 X3 X4 X5 X6 X7
 
-----CODE DEX 2-LEVEL (LET)-------------------------------------------
 
CODE DEX 2-LEVEL
 
Name:
    CODE DEX 2-LEVEL (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Generate a coded variable for a factor variable used in analyzing
    a 2-level full or fractional factorial design.
 
Description:
    To analyze a 2-level full or fractional factorial design, the factor
    variable are typically coded with lower level set to -1, the upper
    level set to +1, and center points set to 0.  This will be referred
    to as classical units.

    If your factor variables are in original units of the data rather
    than classical units, you can use the CODE DEX 2-LEVEL command to
    convert them to classical units.

    In some cases, you may only want the minimum and maximum values
    (i.e., the "-1" and "+1" points).  For example, for the dex
    interaction effects plot in the ten step analysis we need exactly
    two levels.

    This command is similar to the CODE DEX command.  The distinction
    is that CODE DEX preserves the center points and expects a maximum
    of the 3 distinct values.  The CODE DEX 2-LEVEL command will accept
    any number of levels, but only saves the minimum and maximum levels.

Syntax:
    LET <y> = CODE DEX 2-LEVEL <x>   <SUBSET/EXCEPT/FOR qualification>
    where <x> is the factor variable;
          <y> is a variable where the coded values are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET X2OUT = CODE DEX 2-LEVEL X2

Note:
    You can use the same name for the input variable and the output
    variable.  For example

       LET X2 = CODE DEX 2-LEVEL X2

    If you want to have variables in the original units for some
    purposes, you can save the data in original units before using
    the CODE DEX 2-LEVEL command.  For example

       LOOP FOR J = 1 1 K
           LET Z^J = X^J
           LET X^J = CODE DEX 2-LEVEL Z^J
       END OF LOOP

Default:
    None
 
Synonyms:
    DEX CODE 2-LEVEL
    CODE DEX 2LEVEL
    DEX CODE 2LEVEL
 
Related Commands:
    CODE DEX           = Convert to classic units but preserve center
                         points.
    DEX CHECK CLASSIC  = Determine if your factor variables are in
                         classic units.
    CODE               = Generate a coded variable based on distinct
                         values.

Applications:
    Analysis of 2-level full and fractional factorial designs
 
Implementation Date:
    2018/10
 
Program:
    read x1
    24
    36
    24
    36
    24
    36
    24
    36
    30
    30
    end of data
    .
    set write decimals 0
    let y1 = code dex x1
    let y2 = code dex 2-level x1
    print x1 y1
    print y2

-----CODEH (LET)---------------------------------------------------
 
CODEH
 
Name:
    CODEH (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Generate a hinge coded variable.
 
Description:
    The data are coded as follows:
        PERCENTILE                       CODE
        ==========                       ====
        0           <= x <= lower hinge    1
        lower hinge <  x <= median         2
        median      <  x <= upper hinge    3
        upper hinge <  x <= 100            4
    A hinge is a slightly different way to calculate the upper and
    lower quartiles.
 
Syntax:
    LET <xprime> = CODEH <x1>  <SUBSET/EXCEPT/FOR qualification>
    where <x1> is the a response variable;
          <xprime> is a variable of the same length as <x1> where the
               coded values are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET XPRIME = CODEH X1
 
Note:
    If the response variable contains all distinct values, then the
    coded values will be equally split among 1, 2, 3, and 4.  However,
    if the response variable contains a large number of ties, this may
    not be true.  For example, in the above program no values are coded
    as 4.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COCODE         = Generate a cocoded variable.
    CODE           = Generate a coded variable.
    CODE2          = Generate a binary coded variable.
    CODE8          = Generate an octal coded variable.
    CODE4          = Generate a quartile coded variable.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    LET X1 = DATA 12 15 4 12 12 4 15 4 15
    LET XPRIME = CODEH X
    The variable XPRIME will contain the following values:
       2, 3, 1, 2, 2, 1, 3, 1, 3
 
-----CODEN (LET)---------------------------------------------------
 
CODEN
 
Name:
    CODEN (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Generate a percentile coded variable.
 
Description:
    The value of N can be 1 thru 10 (e.g., CODE1, CODE2, ... , CODE10).
    This command splits the data into N percentiles and codes the data
    according to which of those percentiles it falls into.
 
Syntax:
    LET <xprime> = CODE<N> <x1> <SUBSET/EXCEPT/FOR qualification>
    where <x1> is the a response variable;
          <xprime> is a variable of the same length as <x1> where the
               coded values are saved;
          <N> is the number of categories to use (an integer from 1 to
               10),
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET XPRIME = CODE1 X1
    LET XPRIME = CODE2 X1
    LET XPRIME = CODE3 X1
    LET XPRIME = CODE4 X1
    LET XPRIME = CODE5 X1
    LET XPRIME = CODE6 X1
    LET XPRIME = CODE7 X1
    LET XPRIME = CODE8 X1
    LET XPRIME = CODE9 X1
    LET XPRIME = CODE10 X1
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COCODE         = Generate a cocoded variable.
    CODE           = Generate a coded variable.
    CODEH          = Generate a hinge coded variable.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    LET X1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET XPRIME = CODE10 X
 
-----CODEX (LET)---------------------------------------------------
 
CODEX
 
Name:
    CODEX (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Generate a coded variable based on contiguous values of the
    response variable.
 
Description:
    In some cases, you may want to define a tag variable based on
    some condition.  That is, the tag variable will be zero when
    the condition is meet and 1 otherwise (or vice versa).  However,
    you may want to identify contiguous blocks of the response where
    the condition is met and give each of the these distinct blocks
    a unique value.  However, where the original response value is
    zero, that will always be coded as zero.

    This command is similar to the CODEZ command.  However, it treats
    the response equal to zero differently (CODEZ treats a block of
    zeros similar to any other value of the response).

    The following shows an example of the CODEZ command

         X     CODEZ
         ===========
         1         1
         1         1
         0         0
         0         0
         1         2
         1         2
         0         0
         0         0
         1         3
         1         3
         0         0
         0         0

Syntax:
    LET <y> = CODEX <x>   <SUBSET/EXCEPT/FOR qualification>
    where <x> is the response variable;
          <y> is a variable where the coded values are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y = CODEX X
    LET Y = CODEX X  FOR I = 1 1 100
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CODEZ          = Generate a coded variable based on contiguous
                     distinct values.
    CODE           = Generate a coded variable based on distinct values.
    COCODE         = Generate a cocoded variable.
 
Applications:
    Data Manipulation
 
Implementation Date:
    2017/07
 
Program:
    LET X = DATA 1 1 1 2 2 2 0 0 0 1 1 1 1 0 0 3 3 3 3 4
    LET Y = CODEX X
    .
    SET WRITE DECIMALS 0
    PRINT X Y
 
-----CODEZ (LET)---------------------------------------------------
 
CODEZ
 
Name:
    CODEZ (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Generate a coded variable based on contiguous values of the
    response variable.
 
Description:
    The CODE command codes the values in a response variable based
    on the distinct values in the response variable without regard
    to the order of the values in the response variable.

    The CODEZ command is similar to the CODE command.  However, the
    CODEZ command takes the order of the response variable into
    account.  Specifically, CODEZ changes the value of the coded
    variable whenever the response variable changes value.

    The following example shows the difference between the CODE
    and CODEZ commands.

         X      CODE       CODEZ
         =======================
         1         1           1
         1         1           1
         2         2           2
         2         2           2
         3         3           3
         3         3           3
         1         1           4
         1         1           4
         2         2           5
         2         2           5
         3         3           6
         3         3           6

Syntax:
    LET <y> = CODEZ <x>   <SUBSET/EXCEPT/FOR qualification>
    where <x> is the response variable;
          <y> is a variable where the coded values are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y = CODEZ X
    LET Y = CODEZ X  SUBSET X > 0
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CODE           = Generate a coded variable based on distinct values.
    CODEX          = Generate a coded variable based on contiguous
                     distinct values (but treat zero as special case).
    COCODE         = Generate a cocoded variable.
 
Applications:
    Data Manipulation
 
Implementation Date:
    2016/06
 
Program:
    LET X = DATA 1 1 1 2 2 2 3 3 3 1 1 1 1 2 2 3 3 3 3 4
    LET Y = CODEZ X
    .
    SET WRITE DECIMALS 0
    PRINT X Y
 
-----COEF-------------------------------------------------------
 
COEF
 
Name:
    COEF
    THIS VARIABLE IS NOT CURRENTLY RECOGNIZED!!
 
Type:
    Reserved Word
 
Purpose:
    An internal DATAPLOT variable into which computed coefficients are
    automatically placed whenever the FIT, SPLINE FIT, SMOOTH, ANOVA,
    and MEDIAN POLISH commands are executed.
 
Syntax:
    None
 
Examples:
    WRITE COEF COEFSD
    LET TRATIO=COEF/COEFSD
    WRITE CALIB. COEF COEFSD
 
Note:
    Although this variable is not currently recognized by DATAPLOT, it
    can be retrieved with the following sequence:
       FIT .....
       READ DPST1F.DAT COEF COEFSD
    Only the FIT command currently writes these values to the file
    DPPL1F.DAT (this file name may vary on some installations).
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FIT           = Carries out a least squares fit.
    SPLINE FIT    = Carries out a spline fit.
    SMOOTH        = Carries out a smoothing.
    ANOVA         = Carries out a ANOVA.
    MEDIAN POLISH = Carries out a median polish.
    COEFSD        = A variable where coefficient standard deviations
                    are stored.
    PRED          = A variable where predicted values are stored.
    RES           = A variable where residuals are stored.
    RESSD         = A parameter where the residual standard deviation
                    is stored.
    RESDF         = A parameter where the residual degrees of freedom
                    is stored.
    REPSD         = A parameter where the replication standard
                    deviation is stored.
    REPDF         = A parameter where replication degrees of freedom is
                    stored.
    LOFCDF        = A parameter where the lack of fit cdf is stored.
 
Applications:
    Regression
 
Implementation Date:
    Pre-1987
 
Program:
    XX
 
-----COEFFICIENT OF DISPERSION CONFIDENCE LIMITS--------------------------
 
COEFFICIENT OF DISPERSION CONFIDENCE LIMITS
 
Name:
    COEFFICIENT OF DISPERSION CONFIDENCE LIMITS
 
Type:
    Analysis Command
 
Purpose:
    Generates a confidence interval for the coefficient of dispersion.
 
Description:
    The sample coefficient of variation is defined as the ratio of the
    standard deviation to the mean

        cv = s/xbar

    where s and xbar denote the sample standard deviation and
    sample mean respectively.

    The coefficient of variation is sensitive to non-normality.
    An alternative statistic is the coefficient of dispersion
    which is defined as

         COD = tau/eta

    with tau and eta denoting the mean absolute difference from the
    mean and the median, respectively.

    The coefficients of variation and dispersion should typically only be
    used for ratio data.  That is, the data should be continuous and have
    a meaningful zero.  Although these statistics can be computed for data
    that is not on a ratio scale, the interpretation of them may not be
    meaningful.  Currently, this command is only supported for
    non-negative data.  If the response variable contains one or more
    negative numbers, an error message will be returned.

    The method for computing the coefficient of dispersion confidence
    limit is from the Bonett paper (see References below).  Dataplot uses
    a Fortran implementation of the R code given in the paper.  See the
    Bonett paper for the derivation and formula for this interval.

    According to simulation studies by Bonett, the confidence interval
    tends to perform as well or better as the BCa bootstrap interval
    and significantly better than the percentile bootstrap.  Bonett also
    recommends the coefficient of dispersion statistic for moderately
    non-normal data.  For more extreme non-normality, large sample sizes
    may be required for decent performance.   For the more extreme
    non-normal data sets, quartile coefficient of dispersion may be
    preferred.

Syntax 1:
    <LOWER/UPPER> COEFFICIENT OF DISPERSION CONFIDENCE LIMITS <y>
                  <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    If LOWER is specified, a one-sided lower confidence limit is
    returned.  If UPPER is specified, a one-sided upper confidence
    limit is returned.  If neither is specified, a two-sided limit
    is returned.

    This syntax supports matrix arguments for the response variable.

Syntax 2:
    MULTIPLE <LOWER/UPPER> COEFFICIENT OF DISPERSION CONFIDENCE LIMITS
                           <y1> ... <yk>
                           <SUBSET/EXCEPT/FOR qualification>
    where <y1>  .... <yk> is a list of 1 to 30 response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax will generate a confidence interval for each of
    the response variables.  The word MULTIPLE is optional.  That is,

         MULTIPLE COEFFICIENT OF DISPERSION CONFIDENCE LIMITS Y1 Y2 Y3

    is equivalent to

         COEFFICIENT OF DISPERSION CONFIDENCE LIMITS Y1 Y2 Y3

    You can also use the TO syntax as in

         COEFFICIENT OF DISPERSION CONFIDENCE LIMITS Y1 TO Y10

    If LOWER is specified, a one-sided lower confidence limit is
    returned.  If UPPER is specified, a one-sided upper confidence
    limit is returned.  If neither is specified, a two-sided limit
    is returned.

    This syntax supports matrix arguments for the response variables.

Syntax 3:
    REPLICATED <LOWER/UPPER> COEFFICIENT OF DISPERSION CONFIDENCE LIMITS
                             <y> <x1> ... <xk>
                             <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <x1>  .... <xk> is a list of 1 to 6 group-id variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax performs a cross-tabulation of the <x1> ... <xk>
    and generates a confidence interval for each unique combination
    of the cross-tabulated values.  For example, if X1 has 3 levels
    and X2 has 2 levels, six confidence intervals will be generated.

    If LOWER is specified, a one-sided lower confidence limit is
    returned.  If UPPER is specified, a one-sided upper confidence
    limit is returned.  If neither is specified, a two-sided limit
    is returned.

    This syntax does not support matrix arguments.

Examples:
    COEFFICIENT OF DISPERSION CONFIDENCE LIMITS Y1
    COEFFICIENT OF DISPERSION CONFIDENCE LIMITS Y1  SUBSET TAG > 2
    MULTIPLE COEFFICIENT OF DISPERSION CONFIDENCE LIMITS Y1 TO Y5
    REPLICATED COEFFICIENT OF DISPERSION CONFIDENCE LIMITS Y X
 
Note:
    A table of confidence limits is printed for alpha levels of 50.0,
    80.0, 90.0, 95.0, 99.0, and 99.9.
 
Note:
    In addition to the COEFFICIENT OF DISPERSION CONFIDENCE LIMIT command,
    the following commands can also be used:

        LET ALPHA = 0.05

        LET A = LOWER COEFFICIENT OF DISPERSION CONFIDENCE LIMIT Y
        LET A = UPPPER COEFFICIENT OF DISPERSION CONFIDENCE LIMIT Y
        LET A = LOWER ONESIDED COEFFICIENT OF DISPERSION CONFIDENCE LIMIT Y
        LET A = UPPER ONESIDED COEFFICIENT OF DISPERSION CONFIDENCE LIMIT Y

    In addition to the above LET commands, built-in statistics are
    supported for 20+ different commands (enter HELP STATISTICS for
    details).

Default:
    None
 
Synonyms:
    CONFIDENCE INTERVAL is a synonym for CONFIDENCE LIMITS
 
Related Commands:
    COEFFICIENT OF DISPERSION = Compute the coefficient of dispersion.
    COEFFICIENT OF VARIATION  = Compute the coefficient of variation.
    COEF OF DISP CONF LIMITS  = Compute the condidence limits for the
                                coefficient of variation.
    CONFIDENCE LIMITS         = Generate a confidence limit for the mean.
    SD CONFIDENCE LIMITS      = Generate a confidence limit for the
                                standard deviation.
    PREDICTION LIMITS         = Generate prediction limits for the mean
                                of one or more new observations.
    TOLERANCE LIMITS          = Generate a tolerance limit.
 
References:
    Bonett and Seier (2006), "Confidence Interval for a Coefficient of
    Dispersion", Biometrical Journal, Vol. 48, No. 1, PP. 144-148.

    Bonett (2006), "Confidence Interval for a Coefficient of Quartile
    Variation", Computational Statistics and Data Analysis, Vol. 50,
    pp. 2953-2957.

Applications:
    Confirmatory Data Analysis
 
Implementation Date:
    2017/11
 
Program 1:
    SKIP 25
    READ WEIBBURY.DAT Y
    .
    SET WRITE DECIMALS 5
    COEFFICIENT OF DISPERSION CONFIDENCE LIMITS Y
    .
    LET LCD  = COEFFICIENT OF DISPERSION Y
    LET LCDL = LOWER COEFFICIENT OF DISPERSION CONFIDENCE LIMIT Y
    LET UCDL = UPPER COEFFICIENT OF DISPERSION CONFIDENCE LIMIT Y
    .
    PRINT CD LCDL UCDL
 
Program 2:
    SKIP 25
    READ GEAR.DAT Y X
    .
    SET WRITE DECIMALS 5
    REPLICATED COEFFICIENT OF DISPERSION CONFIDENCE LIMITS Y X

-----COEFFICIENT OF DISPERSION (LET)----------------------------------
 
COEFFICIENT OF DISPERSION
 
Name:
    COEFFICIENT OF DISPERSION (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the coefficient of dispersion of a variable.
 
Description:
    The coefficient of dispersion is defined as

         COD = tau/eta

    with eta and tau denoting the median and mean absolute deviation
    from the median, respectively.

    This statistic has been suggested as a robust alternative to the
    coefficient of variation.

Syntax 1:
    LET <par> = COEFFICIENT OF DISPERSION <y>
                <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <par> is a parameter where the coefficient of dispersion
              value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Syntax 2:
    LET <par> = DIFFERENCE OF COEFFICIENT OF DISPERSION <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter where the difference of the coefficient
              of dispersion values is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Examples:
    LET COD = COEFFICIENT OF DISPERSION Y1
    LET COD = COEFFICIENT OF DISPERSION Y1 SUBSET TAG > 2

    LET COD = DIFFERENCE OF COEFFICIENT OF DISPERSION Y1 Y2

Note:
    Note that there are various other definitions for the coefficient
    of dispersion.

    It is sometimes defined as

        COD = VARIANCE/MEAN

    To compute this statistic in Dataplot, use the command

       LET A = INDEX OF DISPERSION Y

    Note that 11/2017 version of Dataplot modified the scale factor to
    be the average absolute deviation from the median rather than the
    median absolute deviation from the median.  This was done to be
    consistent with the Bonett paper.

    Basically, you can define a dispersion index based on a
    scale statistic (standard deviation, average absolute deviation,
    median absolute deviation, etc.) divided by a location statistic
    (mean, median, etc.).

Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COEFFICIENT OF VARIATION  = Compute the coefficient of variation of
                                a variable.
    QUARTILE COEFFICIENT OF   = Compute the quartile coefficient of
             DISPERSION         dispersion of a variable.
    INDEX OF DISPERSION       = Compute the index of dispersion of
                                a variable.
    RELATIVE STANDARD DEVI    = Compute the standard deviation of a
                                variable.
    MEDIAN                    = Compute the median of a variable.
    MEAN                      = Compute the mean of a variable.
    AVERAGE ABSOLUTE DEVI     = Compute the average absolute deviation
       FROM THE MEDIAN          from the median of a variable.
    MEDIAN ABSOLUTE DEVI      = Compute the median absolute deviation
                                of a variable.
    STANDARD DEVIATION        = Compute the standard deviation of a
                                variable.
 
Reference:
    Bonett and Seier (2005), "Confidence interval for a coefficient of
    dispersion in nonnormal distributions", Biometrical Journal,
    Vol. 48, pp. 144-148.

    Gastwirth (1982), "Statistical properties as a measure of tax
    assessment uniformity", Journal of Statistical Planning Inference,
    Vol. 6, pp. 1-12.

Applications:
    Data Analysis
 
Implementation Date:
    2017/01
    2017/06: Added DIFFERENCE OF COEFFICIENT OF DISPERSION
    2017/11: Modified the definition to use the average absolute
             deviation from the median rather than the median
             absolute deviation from the median
 
Program 1:
    SKIP 25
    READ ZARR13.DAT Y
    LET COD = COEFFICIENT OF DISPERSION Y
 
Program 2:
    . Step 1:   Create the data
    .
    skip 25
    read gear.dat y x
    skip 0
    set write decimals 6
    .
    . Step 2:   Define plot control
    .
    title case asis
    title offset 2
    label case asis
    .
    y1label Coefficient of Dispersion
    x1label Group
    title Coefficient of Dispersion for GEAR.DAT
    let ngroup = unique x
    xlimits 1 ngroup
    major x1tic mark number ngroup
    minor x1tic mark number 0
    tic mark offset units data
    x1tic mark offset 0.5 0.5
    .
    character X
    line blank
    .
    set statistic plot reference line average
    coefficient of dispersion plot y x
    .
    set write decimals 5
    tabulate coefficient of dispersion y x

Program 3:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET A = DIFFERENCE OF COEFFICIENT OF DISPERSION Y1 Y2
    SET WRITE DECIMALS 4
    TABULATE DIFFERENCE OF COEFFICIENT OF DISPERSION Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    Y1LABEL DIFFERENCE OF COEFFICIENT OF DISPERSION
    CHAR X
    LINE BLANK
    DIFFERENCE OF COEFFICIENT OF DISPERSION PLOT Y1 Y2 X
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP DIFFERENCE OF COEFFICIENT OF DISPERSION PLOT Y1 Y2 X 
 
-----COEFFICIENT OF QUARTILE DISPERSION CONFIDENCE LIMITS----------------
 
COEFFICIENT OF QUARTILE DISPERSION CONFIDENCE LIMITS
 
Name:
    COEFFICIENT OF QUARTILE DISPERSION CONFIDENCE LIMITS
 
Type:
    Analysis Command
 
Purpose:
    Generates a confidence interval for the coefficient of quartile
    dispersion.
 
Description:
    The sample coefficient of variation is defined as the ratio of the
    standard deviation to the mean

        cv = s/xbar

    where s and xbar denote the sample standard deviation and
    sample mean respectively.

    The coefficient of variation is sensitive to non-normality.
    An alternative statistic is the coefficient of dispersion
    which is defined as

         cod = tau/eta

    with tau and eta denoting the mean absolute difference from the
    mean and the median, respectively.

    Another alternative is the coefficient of quartile dispersion which
    is defined as

         cqv = (Q3 - Q1)/(Q3 + Q1)

    with Q1 denoting the lower quartile (the 25-th percentile) and Q3
    denoting the upper quartile (the 75-th percentile).

    These coefficients should typically only be used for ratio data.  That
    is, the data should be continuous and have a meaningful zero.  Although
    these statistics can be computed for data that is not on a ratio scale,
    the interpretation of them may not be meaningful.  Currently, this
    command is only supported for non-negative data.  If the response
    variable contains one or more negative numbers, an error message will
    be returned.

    The method for computing the coefficient of quartile dispersion
    confidence limit is from the Bonett paper (see References below).
    See the Bonett paper for the derivation and formula for this interval.

    Bonett recommends the coefficient of variation for normal (or
    nearly normal) data, the coefficient of dispersion for moderately
    non-normal data, and the coefficient of quartile dispersion given
    here for more extreme non-normal data.

Syntax 1:
    <LOWER/UPPER> COEFFICIENT OF QUARTILE DISPERSION CONFIDENCE LIMITS <y>
                  <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    If LOWER is specified, a one-sided lower confidence limit is
    returned.  If UPPER is specified, a one-sided upper confidence
    limit is returned.  If neither is specified, a two-sided limit
    is returned.

    This syntax supports matrix arguments for the response variable.

Syntax 2:
    MULTIPLE <LOWER/UPPER> COEFFICIENT OF QUARTILE DISPERSION CONFIDENCE
                           LIMITS <y1> ... <yk>
                           <SUBSET/EXCEPT/FOR qualification>
    where <y1>  .... <yk> is a list of 1 to 30 response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax will generate a confidence interval for each of
    the response variables.  The word MULTIPLE is optional.  That is,

         MULTIPLE COEFFICIENT OF QUARTILE DISPERSION CONFIDENCE ...
                  LIMITS Y1 Y2 Y3

    is equivalent to

         COEFFICIENT OF QUARTILE DISPERSION CONFIDENCE LIMITS Y1 Y2 Y3

    You can also use the TO syntax as in

         COEFFICIENT OF QUARTILE DISPERSION CONFIDENCE LIMITS Y1 TO Y10

    If LOWER is specified, a one-sided lower confidence limit is
    returned.  If UPPER is specified, a one-sided upper confidence
    limit is returned.  If neither is specified, a two-sided limit
    is returned.

    This syntax supports matrix arguments for the response variables.

Syntax 3:
    REPLICATED <LOWER/UPPER> COEFFICIENT OF QUARTILE DISPERSION CONFIDENCE
                             LIMITS <y> <x1> ... <xk>
                             <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <x1>  .... <xk> is a list of 1 to 6 group-id variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax performs a cross-tabulation of the <x1> ... <xk>
    and generates a confidence interval for each unique combination
    of the cross-tabulated values.  For example, if X1 has 3 levels
    and X2 has 2 levels, six confidence intervals will be generated.

    If LOWER is specified, a one-sided lower confidence limit is
    returned.  If UPPER is specified, a one-sided upper confidence
    limit is returned.  If neither is specified, a two-sided limit
    is returned.

    This syntax does not support matrix arguments.

Examples:
    COEFFICIENT OF QUARTILE DISPERSION CONFIDENCE LIMITS Y1
    COEFFICIENT OF QUARTILE DISPERSION CONFIDENCE LIMITS Y1  ...
                SUBSET TAG > 2
    MULTIPLE COEFFICIENT OF QUARTILE DISPERSION CONFIDENCE LIMITS Y1 TO Y5
    REPLICATED COEFFICIENT OF QUARTILE DISPERSION CONFIDENCE LIMITS Y X
 
Note:
    This statistic is based on the lower and upper quartiles.  Note that
    there are various methods for defining percentiles of the data.
    Using different definitions of percentiles can result in slightly
    different values of the statistic and the confidence intervals.

    Although Bonett does not specify which method he uses to compute
    the Q1 and Q3 values, it appears as if he is taking the mean of the
    two closest points.  To use this method to compute Q1 and Q3, enter
    the command

        SET QUANTILE METHOD AVERAGE

    Dataplot provides three additional methods (called R6, R7, and R8).
    Enter HELP QUANTILE for details on how these methods compute the
    quantiles.  To use one of these methods, enter one of the following
    commands

        SET QUANTILE METHOD R6
        SET QUANTILE METHOD R7
        SET QUANTILE METHOD R8

    The default method in Dataplot is R6.

    As the sample size gets larger, this should be less of an issue.

Note:
    A table of confidence limits is printed for alpha levels of 80.0,
    90.0, 95.0, 99.0, and 99.9.
 
Note:
    In addition to the COEFFICIENT OF QUARTILE DISPERSION CONFIDENCE LIMIT
    command, the following commands can also be used:

        LET ALPHA = 0.05

        LET A = LOWER COEFFICIENT OF QUARTILE DISPERSION CONFIDENCE LIMIT Y
        LET A = UPPER COEFFICIENT OF QUARTILE DISPERSION CONFIDENCE LIMIT Y

    In addition to the above LET commands, built-in statistics are
    supported for 20+ different commands (enter HELP STATISTICS for
    details).

Default:
    None
 
Synonyms:
    COEFFICIENT OF QUARTILE VARIATION CONFIDENCE LIMITS
    QUARTILE COEFFICIENT OF DISPEERSION CONFIDENCE LIMITS
    QUARTILE COEFFICIENT OF VARIATION CONFIDENCE LIMITS
 
Related Commands:
    COEFFICIENT OF DISPERSION = Compute the coefficient of dispersion.
    COEFFICIENT OF VARIATION  = Compute the coefficient of variation.
    COEF OF DISP CONF LIMITS  = Compute the condidence limits for the
                                coefficient of dispersion.
    COEF OF VARI CONF LIMITS  = Compute the condidence limits for the
                                coefficient of variation.
    CONFIDENCE LIMITS         = Generate a confidence limit for the mean.
    SD CONFIDENCE LIMITS      = Generate a confidence limit for the
                                standard deviation.
    PREDICTION LIMITS         = Generate prediction limits for the mean
                                of one or more new observations.
    TOLERANCE LIMITS          = Generate a tolerance limit.
 
References:
    Bonett (2006), "Confidence Interval for a Coefficient of Quartile
    Variation", Computational Statistics and Data Analysis, Vol. 50,
    pp. 2953-2957.

    Bonett and Seier (2006), "Confidence Interval for a Coefficient of
    Dispersion", Biometrical Journal, Vol. 48, No. 1, PP. 144-148.

Applications:
    Confirmatory Data Analysis
 
Implementation Date:
    2017/12
 
Program 1:
    . Following data from Bonett paper
    .
    LET Y = DATA 0.2 0.5 1.1 1.4 1.8 2.3 2.5 2.7 3.5 4.4 4.6 5.4 5.4 ...
            5.7 5.8 5.9 6.0 6.6 7.1 7.9
    .
    SET WRITE DECIMALS 5
    SET QUANTILE METHOD AVERAGE
    COEFFICIENT OF QUARTILE DISPERSION CONFIDENCE LIMITS Y
    .
    LET ALPHA = 0.05
    LET CQV  = COEFFICIENT OF QUARTILE DISPERSION Y
    LET LCDL = LOWER COEFFICIENT OF QUARTILE DISPERSION CONFIDENCE LIMIT Y
    LET UCDL = UPPER COEFFICIENT OF QUARTILE DISPERSION CONFIDENCE LIMIT Y
    .
    PRINT CQV LCDL UCDL
 
Program 2:
    SKIP 25
    READ GEAR.DAT Y X
    .
    SET WRITE DECIMALS 5
    SET QUANTILE METHOD AVERAGE
    REPLICATED COEFFICIENT OF QUARTILE DISPERSION CONFIDENCE LIMITS Y X

-----COEFFICIENT OF VARIATION CONFIDENCE LIMITS--------------------------
 
COEFFICIENT OF VARIATION CONFIDENCE LIMITS
 
Name:
    COEFFICIENT OF VARIATION CONFIDENCE LIMITS
 
Type:
    Analysis Command
 
Purpose:
    Generates a confidence interval for the coefficient of
    variation for normally distributed data.
 
Description:
    The coefficient of variation is defined as the ratio of the
    standard deviation to the mean

        cv = sigma/mu

    where sigma and mu denote the population standard deviation
    and population mean, respectively.  The sample coefficient
    of variation is defined as

        cv = s/xbar

    where s and xbar denote the sample standard deviation and
    sample mean respectively.

    The coefficient of variation should typically only be used
    for ratio data.  That is, the data should be continuous and
    have a meaningful zero.  Although the coefficient of variation
    statistic can be computed for data that is not on a ratio
    scale, the interpretation of the coeffcient of variation may
    not be meaningful.  Currently, this command is only supported
    for non-negative data.  If the response variable contains one
    or more negative numbers, an error message will be returned.

    For normally distributed data, a number of methods for determining
    confidence intervals for the coefficient of variation have been
    proposed.  Dataplot currently supports six different methods.

    In the following, xbar, s, n, and K denote the sample mean, sample
    standard deviation, sample size, and sample coefficient of variation,
    respectively.  CHSPPF denotes the chi-square percent point function
    and alpha denotes the significance level.

    The supported methods are

       1) The "naive" method is based on dividing the standard confidence
          limit for the standard deviation by the sample mean.

              lcl = [(s/xbar)*SQRT((n-1)/CHSPPF(1-alpha/2;n-1))]
              ucl = [(s/xbar)*SQRT((n-1)/CHSPPF(alpha/2;n-1))]

          This method is generally not as accurate as the McKay and
          modified McKay methods.  However, it is sometimes used in
          practice.

          This method can be specified with the command

          SET COEFFICIENT OF VARIAITON CONFIDENCE LIMIT METHOD NAIVE

       2) The McKay confidence limit is

              lcl = K/SQRT[(u1+2)/n - 1)*K**2 + u1/(n - 1)]
              ucl = K/SQRT[(u2+2)/n - 1)*K**2 + u2/(n - 1)]

          where

              u1 = CHSPPF((1-(alpha/2)),n-1)
              u2 = CHSPPF(alpha/2,n-1)

          McKay's approximation is asymptotically exact as n goes to
          infinity.  McKay recommends this approximation only if the
          coefficient of variation is less than 0.33.  Note that if the
          coefficient of variation is greater than 0.33, either the
          normality of the data is suspect and the probability of negative
          values in the data is non-neglible.  In this case, McKay's
          approximation may not be valid.  Also, it is generally
          recommended that the sample size should be at least 10 before
          using McKay's approximation.

          This method can be specified with the command

              SET COEFFICIENT OF VARIAITON CONFIDENCE LIMIT METHOD MCKAY

       3) Vangel proposed the following modification to McKay's method.

              lcl = K/SQRT[(u1+2)/n - 1)*K**2 + u1/(n - 1)]
              ucl = K/SQRT[(u2+2)/n - 1)*K**2 + u2/(n - 1)]

          where

              u1   = CHSPPF((1-(alpha/2)),N-1)
              u2   = CHSPPF(alpha/2,N-1)

          Vangel's modified McKay method is more accurate than the McKay
          in most cases, particilarly for small samples..  According to
          Vangel, the unmodified McKay is only more accurate when both
          the coefficient of variation and alpha are large.  However, if
          the coefficient of variation is large, then this implies either
          that the data contains negative values or the data does not
          follow a normal distribution.  In this case, neither the McKay
          or the modified McKay should be used.

          In general, the Vangel's modified McKay method is recommended
          over the McKay method.  It generally provides good
          approximations as long as the data is approximately normal
          and the coefficient of variation is less than 0.33.

          This is the default method.

          This method can be specified with the command

          SET COEFFICIENT OF VARIAITON CONFIDENCE LIMIT METHOD VANGEL

       4) Panichkitkitkosolkul proposed the maximum likelihood based
          method.  This uses Vangel's formula.  However, it replaces
          the sample coefficient of variation with the maximum 
          likelihood estimate of the coefficient of variation.
          Specifically,

              K = SQRT{SUM{i=1 to n][(X(i) - xbar)**2}/(SQRT(n)*xbar)

          That is, we use the n rathar than (n-1) in the denominator
          when computing the standard deviation.

          As with the McKay and modified McKay methods, it is
          recommended that this method only be used when the coefficient
          of variation is less than 0.33 and the data are normally
          distributed.

          This method can be specified with the command

          SET COEFFICIENT OF VARIAITON CONFIDENCE LIMIT METHOD ...
              MAXIMUM LIKELIHOOD

       5) McKay also provided an exact method.  The exact method
          involves solving a non-linear equation with the non-central
          t distribution.  The details are given in the McKay and
          Verrill papers.  Verrill also provides a Fortran code for
          implementing the exact method.  Dataplot's implementation is
          based on this code.

          Verrill gives justification for preferring the exact method
          to the McKay and modified McKay approximations.  If the
          coefficient of variation is greater than 0.33 the exact method
          is preferred to the McKay and modified McKay approximations.
          If the sample size is greater than 3,000, the exact method
          reverts to the Vangel modified McKay method.

          This method can be specified with the command

          SET COEFFICIENT OF VARIAITON CONFIDENCE LIMIT METHOD EXACT

       6) Liu proposed a generalized confidence interval approach.
          The details for this method are given in her paper.

          This method can be specified with the command

          SET COEFFICIENT OF VARIAITON CONFIDENCE LIMIT METHOD GPQ

    The default method is the Vangel method.  For most applications,
    this choice should be reasonable as long as the data are
    approximately normally distributed.

    If the data follow a lognormal distribution, then a confidence
    interval for the coefficient of variation is

           lcl = SQRT{EXP(aL) - 1}
           ucl = SQRT{EXP(aU) - 1}

    where

           aL       = (n-1)*S(n)**2/CHSPPF(n-1,1-alpha/2)
           aU       = (n-1)*S(n)**2/CHSPPF(n-1,alpha/2)
           S(n)**2  = the variance of the log of the data

    The derivation of this is given in the Koopmans, Owen and Rosenblatt
    and the Verrill papers.

Syntax 1:
    <LOWER/UPPER> <LOGNORMAL> COEFFICIENT OF VARIATION CONFIDENCE LIMITS
                              <y>     <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    If LOWER is specified, a one-sided lower confidence limit is
    returned.  If UPPER is specified, a one-sided upper confidence
    limit is returned.  If neither is specified, a two-sided limit
    is returned.

    If LOGNORMAL is specified, the formula for the log normal-based
    confidence limits are used.  If LOGNORMAL is omitted, the formulas
    for the normal-based confidence limits are used.

    This syntax supports matrix arguments for the response variable.

Syntax 2:
    MULTIPLE <LOWER/UPPER> <LOGNORMAL> COEFFICIENT OF VARIATION CONFIDENCE
                           LIMITS  <y1> ... <yk>
                           <SUBSET/EXCEPT/FOR qualification>
    where <y1>  .... <yk> is a list of 1 to 30 response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax will generate a confidence interval for each of
    the response variables.  The word MULTIPLE is optional.  That is,

         MULTIPLE COEFFICIENT OF VARIATION CONFIDENCE LIMITS Y1 Y2 Y3

    is equivalent to

         COEFFICIENT OF VARIATION CONFIDENCE LIMITS Y1 Y2 Y3

    You can also use the TO syntax as in

         COEFFICIENT OF VARIATION CONFIDENCE LIMITS Y1 TO Y10

    If LOWER is specified, a one-sided lower confidence limit is
    returned.  If UPPER is specified, a one-sided upper confidence
    limit is returned.  If neither is specified, a two-sided limit
    is returned.

    If LOGNORMAL is specified, the formula for the log normal-based
    confidence limits are used.  If LOGNORMAL is omitted, the formulas
    for the normal-based confidence limits are used.

    This syntax supports matrix arguments for the response variables.

Syntax 3:
    REPLICATED <LOWER/UPPER> <LOGNORMAL> COEFFICIENT OF VARIATION
                             CONFIDENCE LIMITS  <y> <x1> ... <xk>
                             <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <x1>  .... <xk> is a list of 1 to 6 group-id variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax performs a cross-tabulation of the <x1> ... <xk>
    and generates a confidence interval for each unique combination
    of the cross-tabulated values.  For example, if X1 has 3 levels
    and X2 has 2 levels, six confidence intervals will be generated.

    If LOWER is specified, a one-sided lower confidence limit is
    returned.  If UPPER is specified, a one-sided upper confidence
    limit is returned.  If neither is specified, a two-sided limit
    is returned.

    If LOGNORMAL is specified, the formula for the log normal-based
    confidence limits are used.  If LOGNORMAL is omitted, the formulas
    for the normal-based confidence limits are used.

    This syntax does not support matrix arguments.

Examples:
    COEFFICIENT OF VARIATION CONFIDENCE LIMITS Y1
    COEFFICIENT OF VARIATION CONFIDENCE LIMITS Y1  SUBSET TAG > 2
    MULTIPLE COEFFICIENT OF VARIATION CONFIDENCE LIMITS Y1 TO Y5
    REPLICATED COEFFICIENT OF VARIATION CONFIDENCE LIMITS Y X
 
Note:
    A table of confidence limits is printed for alpha levels of 50.0,
    80.0, 90.0, 95.0, 99.0, and 99.9.  If the exact method is specified,
    the 99.9 level is omitted.
 
Note:
    In addition to the COEFFICIENT OF VARIATION CONFIDENCE LIMIT command,
    the following commands can also be used:

        LET ALPHA = 0.05

        LET A = LOWER COEFFICIENT OF VARIATION CONFIDENCE LIMIT Y
        LET A = UPPPER COEFFICIENT OF VARIATION CONFIDENCE LIMIT Y
        LET A = LOWER ONESIDED COEFFICIENT OF VARIATION CONFIDENCE LIMIT Y
        LET A = UPPER ONESIDED COEFFICIENT OF VARIATION CONFIDENCE LIMIT Y

        LET A = SUMMARY LOWER COEFFICIENT OF VARIATION CONFIDENCE LIMIT
                YMEAN YSD N
        LET A = SUMMARY UPPPER COEFFICIENT OF VARIATION CONFIDENCE LIMIT
                YMEAN YSD N

    The first command specifies the significance level.  The next four
    commands are used when you have raw data.  The last two commands are
    used when only summary data (mean, standard deviation, sample size) is
    available.

    In addition to the above LET commands, built-in statistics are
    supported for 20+ different commands (enter HELP STATISTICS for
    details).

Default:
    None
 
Synonyms:
    CONFIDENCE INTERVAL is a synonym for CONFIDENCE LIMITS
 
Related Commands:
    COEFFICIENT OF VARIATION  = Compute the coefficient of variation.
    CONFIDENCE LIMITS         = Generate a confidence limit for the mean.
    SD CONFIDENCE LIMITS      = Generate a confidence limit for the
                                standard deviation.
    PREDICTION LIMITS         = Generate prediction limits for the mean.
    TOLERANCE LIMITS          = Generate a tolerance limit.
 
References:
     McKay (1932), "Distributions of the Coefficient of Variation and the
     Extended 't' Distribution", Journal of the Royal Statistical Society,
     Vol. 95, pp. 695-698.
 
     Koopmans, Owen, and Rosenblatt (1964), "Confidence Intervals for the
     Coefficient of Variation for the Normal and Log Normal
     Distributions", Biometrika, 51, 1, pp. 25-31.

     Mark Vangel (1996), "Confidence Intervals for a Normal Coefficient
     of Variation", American Statistician, Vol. 15, No. 1, pp. 21-26.

     Panichkitkitkosolkul (2009), "Improved Confidence Intervals for a
     Coefficient of Variation of a Normal Distribution", Thailand
     Statistician, 7(2), pp. 193-199.

     Steve Verrill (2003), "Confidence Bounds for Normal and Lognormal
     Distribution Coefficients of Variation", Research Paper 609, USDA
     Forest Products Laboratory, Madison, Wisconsin. 

     Verrill, S. and Johnson, R.A. (2007), "Confidence Bounds and
     Hypothesis Tests for Normal Distribution Coefficients of Variation",
     Communications in Statistics Theory and Methods, Volume 36,
     No. 12, pp 2187-2206.

     Liu (2012), "Confidence Interval Estimation for Coefficient of
     Variation", Thesis, Georgia State University,
     http://scholarworks.gsu.edu/math_theses/124.

Applications:
    Confirmatory Data Analysis
 
Implementation Date:
    2017/01
 
Program 1:
    SKIP 25
    READ ZARR13.DAT Y
    SET WRITE DECIMALS 5
    .
    COEFFICIENT OF VARIATION CONFIDENCE LIMITS Y
    LOWER COEFFICIENT OF VARIATION CONFIDENCE LIMITS Y
    UPPER COEFFICIENT OF VARIATION CONFIDENCE LIMITS Y
 
Program 2:
    . Step 1:   Create the data
    .
    let y = data 326 302 307 299 329
    set write decimals 4
    .
    . Step 2:   Compute the built-in intervals
    .
    let cvlow = lower coefficient of variation confidence limit y
    let cvupp = upper coefficient of variation confidence limit y
    set coefficient of variation confidence limit method mckay
    let cvlow2 = lower coefficient of variation confidence limit y
    let cvupp2 = upper coefficient of variation confidence limit y
    set coefficient of variation confidence limit method maximum likelihood
    let cvlow3 = lower coefficient of variation confidence limit y
    let cvupp3 = upper coefficient of variation confidence limit y
    set coefficient of variation confidence limit method naive
    let cvlow6 = lower coefficient of variation confidence limit y
    let cvupp6 = upper coefficient of variation confidence limit y
    set coefficient of variation confidence limit method gpq
    let cvlow7 = lower coefficient of variation confidence limit y
    let cvupp7 = upper coefficient of variation confidence limit y
    set coefficient of variation confidence limit method exact
    let cvlow8 = lower coefficient of variation confidence limit y
    let cvupp8 = upper coefficient of variation confidence limit y
    let cvlow9 = lower onesided coefficient of variation confidence limit y
    let cvupp9 = upper onesided coefficient of variation confidence limit y
    .
    print "Vangel Method"
    print cvlow cvupp
    print " "
    print "McKay Method"
    print cvlow2 cvupp2
    print " "
    print "Maximum Likelihood Method"
    print cvlow3 cvupp3
    print " "
    print "Naive Method"
    print cvlow6 cvupp6
    print " "
    print "GPQ Method"
    print cvlow7 cvupp7
    print " "
    print "Exact Method"
    print cvlow8 cvupp8
    print " "
    .
    print "Exact Method: One-Sided"
    print cvlow9 cvupp9
    print " "
    .
    set coefficient of variation confidence limit method vangel
    coefficient of variation confidence limits y
 
Program 3:
    SKIP 25
    READ GEAR.DAT Y X
    SET WRITE DECIMALS 3
    .
    REPLICATED COEFFICIENT OF VARIATION CONFIDENCE LIMITS Y X
 
Program 4:
    let sigma = 3.5
    let n = 20
    let y = lognormal random numbers for i = 1 1 n
    .
    let lcv  = lognormal coef of vari y
    let lcvl = lower lognormal coef of vari conf limit y
    let ucvl = upper lognormal coef of vari conf limit y
    .
    set write decimals -7
    print lcv lcvl ucvl
    .
    lognormal coefficient of variation confidence limits y

-----COEFFICIENT OF VARIATION TEST--------------------------
 
COEFFICIENT OF VARIATION TEST
 
Name:
    COEFFICIENT OF VARIATION TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform either a one sample coefficient of variation test or a
    two sample coefficient of variation test.
 
Description:
    The coefficient of variation is defined as the ratio of the
    standard deviation to the mean

        cv = sigma/mu

    where sigma and mu denote the population standard deviation
    and population mean, respectively.  The sample coefficient
    of variation is defined as

        cv = s/xbar

    where s and xbar denote the sample standard deviation and
    sample mean respectively.

    The coefficient of variation should typically only be used
    for ratio data.  That is, the data should be continuous and
    have a meaningful zero.  Although the coefficient of variation
    statistic can be computed for data that is not on a ratio
    scale, the interpretation of the coeffcient of variation may
    not be meaningful.  Currently, this command is only supported
    for non-negative data.  If the response variable contains one
    or more negative numbers, an error message will be returned.

    The one sample coefficient of variation tests whether the
    coefficient of variation is equal to a given value.  Note
    that this can be for either a single sample or for the
    common coefficient for multile groups of data (it is assummed
    the groups have equal population coefficient of variation
    values).

        H0: gamma =  gamma0
        Ha: gamma <> gamma0

    The test statistic is

        SUM[i=1 to k][(n(i) - 1)*u(i)/theta0]

    where

        k      = the number of groups
        u(i)   = c(i)**2/[1 + c(i)**2*(n(i) - 1)/n(i)]
        c(i)   = coefficient of variation for the i-th group
        n(i)   = sample size for the i-th group
        theta0 = gamma0**2/(1 + gamma0**2)

    where gamma is the common coefficient of variation and gamma0 is
    the hypothesized value.

    This statistic is compared to a chi-square with 
    SUM[i=1 to k][n(i)- 1] degrees of freedom.  The most common usage
    is the case for a single group (i.e., k = 1).

    The two sample coefficient of variation tests whether two
    distinct samples have equal, but unspecified, coefficients
    of variations.  As with the single sample case, each of the
    two samples can consist of either a single group or multiple
    groups of data.

        H0: gamma1 =  gamma2
        Ha: gamma1 <> gamma2

    The test statistic is

        F = num/denom

    where

        NUM   = SUM[i=1 to k1][(n1(i) - 1)*u1(i)]/
                SUM[i=1 to k1][n1(i) - 1]

        DENOM = SUM[i=1 to k2][(n2(i) - 1)*u2(i)]/
                SUM[i=1 to k2][n2(i) - 1]

    where

         k1     = the number of groups for sample one
         k2     = the number of groups for sample two
         ur(i)  = cr(i)**2/[1 + cr(i)**2*(nr(i) - 1)/nr(i)]
         cr(i)  = coefficient of variation for the i-th group and the
                  r-th sample
         nr(i)  = the sample size for the i-the group and the r-th sample
         r      = 1, 2 (i.e., the two samples)

    when k1 = k2 = 1, the test simplifies to

         F = [c1**2/(1 + c1**2*(n1-1)/n1)]/
             [c2**2/(1 + c2**2*(n2-1)/n2)]


    This statistic is compared to the F distribution with
    SUM[i=1 to k1][n1(i)- 1] AND SUM[i=1 to k2][n2(i) - 1]
    degrees of freedom.

    The test implemented here was proposed by Forkman (see the References
    below).  There are a number of alternative tests (see the paper by
    Krishnamooorthy and Lee in the References section).  Simulations by
    Forkman and also by Krishnamoorthy and Lee indicate that the Forkman
    test has good nominal coverage and reasonable power.

Syntax 1:
    ONE SAMPLE COEFFICIENT OF VARIATION TEST <y> <x> <gamma0>
                           <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <x> is the optional group-id variable;
          <gamma0> is a parameter that specifies the hypothesized value;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax performs a two-tailed test.

    If there are no groups in the data, the group-id variable can be
    omitted.

    The <gamma0> can either be given on this command or specified before
    entering this command by entering

         LET GAMMA0 = <value>

    If the <x> variable is given, it should have the same number of rows
    as the <y> variable.

Syntax 2:
    ONE SAMPLE COEFFICIENT OF VARIATION <LOWER/UPPER> TAILED TEST
                           <y> <x> <gamma0>
                           <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <x> is the optional group-id variable;
          <gamma0> is a parameter that specifies the hypothesized value;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax performs a one-tailed test.  If LOWER is entered, then
    the alternate hypothesis is

         Ha: gamma < gamma0

    If UPPER is entered, then the alternative hypothesis is

         Ha: gamma > gamma0

    If there are no groups in the data, the group-id variable can be
    omitted.

    The <gamma0> can either be given on this command or specified before
    entering this command by entering

         LET GAMMA0 = <value>

    If the <x> variable is given, it should have the same number of rows
    as the <y> variable.

Syntax 3:
    TWO SAMPLE COEFFICIENT OF VARIATION TEST <y1> <x1> <y2> <x2>
                           <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <x1> is the optional first group-id variable;
          <y2> is the second response variable;
          <x2> is the optional second group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax performs a two-tailed test.

    If there are no groups in the data, the group-id variables can be
    omitted.  However, if a group-id variable is specified for one
    response variable, it should also be specified for the second
    response variable.  If one of the response variables has groups
    but the other response variable does not, then a group-id variable
    can be created that has all values equal to 1.

    The <y1> and <x1> variables should have the same number of rows.
    Likewise the <y2> and <x2> variables should have the same number of
    rows.  However, <y1> and <y2> need not have the same number of rows.

Syntax 4:
    TWO SAMPLE COEFFICIENT OF VARIATION <LOWER/UPPER> TAILED TEST
                           <y1> <x1> <y2> <x2>
                           <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <x1> is the optional first group-id variable;
          <y2> is the second response variable;
          <x2> is the optional second group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax performs a one-tailed test.  If LOWER is entered, then
    the alternate hypothesis is

         Ha: gamma1 < gamma2

    If UPPER is entered, then the alternative hypothesis is

         Ha: gamma1 > gamma2

    If there are no groups in the data, the group-id variable can be
    omitted.

    If there are no groups in the data, the group-id variables can be
    omitted.  However, if a group-id variable is specified for one
    response variable, it should also be specified for the second
    response variable.  If one of the response variables has groups
    but the other response variable does not, then a group-id variable
    can be created that has all values equal to 1.

    The <y1> and <x1> variables should have the same number of rows.
    Likewise the <y2> and <x2> variables should have the same number of
    rows.  However, <y1> and <y2> need not have the same number of rows.

Examples:
    LET GAMMA0 = 0.1
    ONE SAMPLE COEFFICIENT OF VARIATION TEST Y GAMMA0
    ONE SAMPLE COEFFICIENT OF VARIATION TEST Y X GAMMA0
    ONE SAMPLE COEFFICIENT OF VARIATION UPPER TAILED TEST Y X GAMMA0
    ONE SAMPLE COEFFICIENT OF VARIATION TEST Y X GAMMA0  SUBSET X > 2

    TWO SAMPLE COEFFICIENT OF VARIATION TEST Y1 Y2
    TWO SAMPLE COEFFICIENT OF VARIATION TEST Y1 X1 Y2 X2
    TWO SAMPLE COEFFICIENT OF VARIATION LOWER TAILED TEST Y1 Y2
 
Note:
    A table of confidence limits is printed for alpha levels of 50.0,
    80.0, 90.0, 95.0, 99.0, and 99.9.
 
Note:
    In addition to the COEFFICIENT OF VARIATION CONFIDENCE LIMIT command,
    the following commands can also be used:

        LET A = ONE SAMPLE COEFFICIENT OF VARIATION TEST         Y  X
        LET A = ONE SAMPLE COEFFICIENT OF VARIATION TEST CDF     Y  X
        LET A = ONE SAMPLE COEFFICIENT OF VARIATION TEST PVALUE  Y  X
        LET A = ONE SAMPLE COEFFICIENT OF VARIATION LOWER PVALUE Y  X
        LET A = ONE SAMPLE COEFFICIENT OF VARIATION UPPER PVALUE Y  X

        LET A = TWO SAMPLE COEFFICIENT OF VARIATION TEST         Y1 Y2
        LET A = TWO SAMPLE COEFFICIENT OF VARIATION TEST CDF     Y1 Y2
        LET A = TWO SAMPLE COEFFICIENT OF VARIATION TEST PVALUE  Y1 Y2
        LET A = TWO SAMPLE COEFFICIENT OF VARIATION LOWER PVALUE Y1 Y2
        LET A = TWO SAMPLE COEFFICIENT OF VARIATION UPPER PVALUE Y1 Y2

    The LOWER PVALUE and UPPER PVALUE refer to the p-values based on
    lower tailed and upper tailed tests, respectively.

    For the one sample test, these statistics can be computed from
    summary data as well

        LET A = SUMMARY ONE SAMPLE COEFFICIENT OF VARIATION TEST   YMEAN YSD YN
        LET A = SUMMARY ONE SAMPLE COEFFICIENT OF VARIATION CDF    YMEAN YSD YN
        LET A = SUMMARY ONE SAMPLE COEFFICIENT OF VARIATION PVALUE YMEAN YSD YN

    where YMEAN, YSD, and YN are arrays that contain the sample means,
    sample standard deviations, and sample sizes, respectively.

    In addition to the above LET commands, built-in statistics are
    supported for 20+ different commands (enter HELP STATISTICS for
    details).

Note:
    As mentioned above, there are a number of tests that have been proposed.
    For the two sample test with no groups for the samples, Dataplot also
    supports the Miller test.  This test statistic is given by

        (C1-C2)/SQRT{C**2/(2*(N1-1)) + C**4/(N1-1) +
                     C**2/(2*(N2-1)) + C**4/(N2-1)}

    where

        N1     = the sample size for sample one
        C1     = the sample coefficient of variation for sample one
        N2     = the sample size for sample two
        C2     = the sample coefficient of variation for sample two
        C      = ((N1-1)*C1 + (N2-1)*C2)/(N1+N2-2)

    To use the Miller test, enter the command (before the TWO SAMPLE COEFFICENT
    OF VARIATION TEST command)

        SET TWO SAMPLE COEFFICIENT OF VARIATION TEST MILLER

    To reset the default Forkman test, enter

        SET TWO SAMPLE COEFFICIENT OF VARIATION TEST FORKMAN

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COEFFICIENT OF VARIATION  = Compute the coefficient of variation.
    COEF OF VARI CONF LIMITS  = Compute a confidence interval for the
                                coefficient of variation.
    COMMON COEF OF VARI CONF  = Generate a confidence interval for a
           LIMITS               common coefficient of variation.
    CONFIDENCE LIMITS         = Generate a confidence limit for the mean.
    SD CONFIDENCE LIMITS      = Generate a confidence limit for the
                                standard deviation.
    PREDICTION LIMITS         = Generate prediction limits for the mean.
    TOLERANCE LIMITS          = Generate a tolerance limit.
 
References:
     Forkman (2009), "Estimator and Tests for Common Coefficients of
     Variation in Normal Distributions", Communications in Statistics -
     Theory and Methods, Vol. 38, pp. 233-251.

     Miller (1991), "Asymptotic Test Statistics for Coefficient of
     Variation", Communications in Statistics - Theory and Methods,
     Vol. 20, pp. 3351-3363.

     McKay (1932), "Distributions of the Coefficient of Variation and the
     Extended 't' Distribution", Journal of the Royal Statistical Society,
     Vol. 95, pp. 695-698.

     Krishnamoorthy and Lee (2014), "Improved Tests for the Equality of
     Normal Coefficients of Variation", Computational Statistics, Vol. 29,
     pp. 215-232.

Applications:
    Confirmatory Data Analysis
 
Implementation Date:
    2017/06
 
Program 1:
    . Step 1:   Read the data
    .
    skip 25
    read gear.dat y x
    skip 0
    set write decimals 6
    .
    . Step 2:   Define plot control
    .
    title case asis
    title offset 2
    label case asis
    .
    y1label Coefficient of Variation
    x1label Group
    title Coefficient of Variation for GEAR.DAT
    let ngroup = unique x
    xlimits 1 ngroup
    major x1tic mark number ngroup
    minor x1tic mark number 0
    tic mark offset units data
    x1tic mark offset 0.5 0.5
    y1tic mark label decimals 3
    .
    character X
    line blank
    .
    .
    . Step 3:   Plot the coefficient of variation over the batches
    .
    set statistic plot reference line average
    coefficient of variation plot y x
    .
    . Step 4:   Demonstrate the LET commands for the test statistics
    .           using raw data
    .
    let gamma0 = 0.005
    let statval = one sample coef of variation test         y x
    let statcdf = one sample coef of variation test cdf     y x
    let pvalue  = one sample coef of variation test pvalue  y x
    let pvall   = one sample coef of variation lower pvalue y x
    let pvalu   = one sample coef of variation upper pvalue y x
    print statval statcdf pvalue pvall pvalu
    .
    . Step 4:   Demonstrate the LET commands for the test statistics
    .           using summary data
    .
    set let cross tabulate collapse
    let ymean = cross tabulate mean y x
    let ysd   = cross tabulate sd   y x
    let yn    = cross tabulate size   x
    .
    let statval2 = summary one sample coef of variation test    ymean ysd yn
    let statcdf2 = summary one sample coef of variation cdf     ymean ysd yn
    let pvalue2  = summary one sample coef of variation pvalue  ymean ysd yn
    print statval2 statcdf2 pvalue2
    .
    . Step 5:   Hypothesis test for common coefficient of variation
    .
    let gamma0 = 0.005
    one sample coefficient of variation test y x
    one sample coefficient of variation upper tail test y x
    one sample coefficient of variation lower tail test y x

Program 2:
    . Step 1:   Read the data
    .
    skip 25
    read auto83b.dat y1 y2
    skip 0
    set write decimals 6
    retain y2 subset y2 > 0
    .
    . Test for equal coefficient of variation
    .
    let statval = two sample coef of variation test         y1 y2
    let statcdf = two sample coef of variation test cdf     y1 y2
    let pvalue  = two sample coef of variation test pvalue  y1 y2
    let pvall   = two sample coef of variation lower pvalue y1 y2
    let pvalu   = two sample coef of variation upper pvalue y1 y2
    print statval statcdf pvalue pvall pvalu
    .
    . Test for equal coefficient of variation
    .
    two sample coefficient of variation test y1 y2
    two sample coefficient of variation lower tail test y1 y2
    two sample coefficient of variation upper tail test y1 y2
    set two sample coefficient of variation test miller
    two sample coefficient of variation test y1 y2
    two sample coefficient of variation lower tail test y1 y2
    two sample coefficient of variation upper tail test y1 y2

-----COEFFICIENT OF VARIATION (LET)------------------------------
 
COEFFICIENT OF VARIATION
 
Name:
    COEFFICIENT OF VARIATION (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the coefficient of variation of a variable.
 
Description:
    The sample coefficient of variation (CV) is defined as the ratio of
    the standard deviation to the mean:

         cv = s/xbar

    where s is the sample standard deviation and xbar is the sample
    mean.

    That is, it shows the variability, as defined by the standard
    deviation, relative to the mean.

    The coefficient of variation should typically only be used for
    data measured on a ratio scale.  That is, the data should be
    continuous and have a meaningful zero.  Measurement data in the
    physical sciences and engineering are often on a ratio scale.
    As an example, temperatures measured on a Kelvin scale are on a
    ratio scale while temperaturs measured on a Celcius or Farenheit
    scale are interval scales rather than ratio scales.  Given a set
    of temperature measurements, the coefficient of variation on the
    Celcius scale will be different than the coefficient of variation
    on the Farenheit scale.

    The coefficient of variation is sometimes preferred to the standard
    deviation because the value of the coefficient of variation is
    independent of the unit of measurement scale (as long as it is a
    ratio scale).  When comparing variability between data sets with
    different measurement scales or very different mean values, the
    coefficient of variation can be a useful alternative or complement
    to the standard deviation.

    However, the coefficient of variation should not be used for data
    that are not on a ratio scale.  Also, if the mean value is near
    zero, the coefficient of variation is sensitive to small changes
    in the mean.  Also, the coefficient of variation cannot be used
    to compute confidence intervals for the mean.

Syntax 1:
    LET <par> = COEFFICIENT OF VARIATION <y>
                <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <par> is a parameter where the coefficient of variation
              value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    LET <par> = UNBIASED COEFFICIENT OF VARIATION <y>
                <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <par> is a parameter where the unbiased coefficient of
              variation value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    For normally distributed data, an unbiased estimate of the coefficient
    of variation is

        cv* = (1 + 1/(4*n))*cv

    where n is the sample size and cv is s/xbar.

Syntax 3:
    LET <par> = LOGNORMAL COEFFICIENT OF VARIATION <y>
                <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <par> is a parameter where the lognormal coefficient of
              variation value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    For lognormally distributed data, a more accurate estimate for the
    coefficient of variation (based on the population mean and standard
    deviation of the lognormal distribution) is

        cv(ln) = SQRT(EXP(s(ln)^2) - 1)

    where s(ln)^2 is the variance of the log of the data.

Examples:
    LET CV = COEFFICIENT OF VARIATION Y1
    LET CV = COEFFICIENT OF VARIATION Y1  SUBSET TAG > 2
    LET CV = UNBIASED COEFFICIENT OF VARIATION Y1
    LET CV = LOGNORMAL COEFFICIENT OF VARIATION Y1
 
Note:
    Versions prior to 94/11 treated this command as a synonym for 
    RELATIVE STANDARD DEVIATION.  The relative standard deviation is:

       relsd = 100*sd/|mean|

    That is, the relative standard deviation is the coefficient of
    variation expressed in percentage units.

Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    COEFFICIENT VARIATION
 
Related Commands:
    COEF OF VARI CONF LIMI     = Compute confidence limits for the
                                 coefficient of variation.
    COEFFICIENT OF DISPERSION  = Compute the coefficient of
                                 dispersion of a variable.
    QUARTILE COEF OF DISP      = Compute the quartile coefficient of
                                 dispersion of a variable.
    RELATIVE STAND DEVI        = Compute the relative standard
                                 deviation of a variable.
    MEAN                       = Compute the mean of a variable.
    STANDARD DEVIATION         = Compute the standard deviation of a
                                 variable.
 
Applications:
    Data Analysis
 
Implementation Date:
    1994/11 (earlier versions use a different definition)
    2017/01 Added the UNBIASED COEFFICIENT OF VARIATION
    2017/01 Added the LOGNORMAL COEFFICIENT OF VARIATION
 
Program 1:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET CV = COEFFICIENT OF VARIATION Y1
 
Program 2:
    . Step 1:   Create the data
    .
    skip 25
    read gear.dat y x
    skip 0
    set write decimals 6
    .
    . Step 2:   Define plot control
    .
    title case asis
    title offset 2
    label case asis
    .
    y1label Coefficient of Variation
    x1label Group
    title Coefficient of Variation for GEAR.DAT
    let ngroup = unique x
    xlimits 1 ngroup
    major x1tic mark number ngroup
    minor x1tic mark number 0
    tic mark offset units data
    x1tic mark offset 0.5 0.5
    y1tic mark label decimals 3
    .
    character X
    line blank
    .
    set statistic plot reference line average
    .
    coefficient of variation plot y x

-----COEFSD-------------------------------------------------------
 
COEFSD
 
Name:
    COEFSD
    THIS VARIABLE IS NOT CURRENTLY RECOGNIZED!!
 
Type:
    Plot Control Command
 
Purpose:
    An internal DATAPLOT variable into which estimated standard
    deviations of the computed coefficients are automatically placed
    whenever the FIT, SPLINE FIT, SMOOTH, ANOVA, and MEDIAN POLISH
    commands are executed.
 
Syntax:
    None
 
Examples:
    WRITE COEF COEFSD
    LET TRATIO=COEF/COEFSD
    WRITE CALIB.COEF COEFSD
 
Note:
    Although this variable is not currently recognized by DATAPLOT, it
    can be retrieved with the following sequence:
       FIT .....
       READ DPST1F.DAT COEF COEFSD
    Only the FIT command currently writes these values to the file
    DPPL1F.DAT (this file name may vary on some installations).
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FIT           = Carries out a least squares fit.
    SPLINE FIT    = Carries out a spline fit.
    SMOOTH        = Carries out a smoothing.
    ANOVA         = Carries out a ANOVA.
    MEDIAN POLISH = Carries out a median polish.
    COEF          = A variable where the coefficients are stored.
    PRED          = A variable where predicted values are stored.
    RES           = A variable where residuals are stored.
    RESSD         = A parameter where the residual standard deviation
                    is stored.
    RESDF         = A parameter where the residual degrees of freedom
                    is stored.
    REPSD         = A parameter where the replication standard
                    deviation is stored.
    REPDF         = A parameter where replication degrees of freedom is
                    stored.
    LOFCDF        = A parameter where the lack of fit cdf is stored.
 
Applications:
    Fitting
 
Implementation Date:
    Pre-1987
 
Program:
    XX
 
-----COLOR-------------------------------------------------------
 
COLOR
 
Name:
    COLOR
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Specifies the color of characters resulting from subsequent
    TEXT commands.
 
Syntax:
    COLOR   <color>
    where <color> specifies the desired color.  Enter HELP COLOR TYPES
    for a list of available colors.
 
Examples:
    COLOR RED
    COLOR GREEN
 
Note:
    The available colors can be retrieved by entering HELP
    COLOR TYPES.
 
Default:
    All text is drawn in black.
 
Synonyms:
    None
 
Related Commands:
    TEXT               = Writes a text string.
    FONT               = Sets the font for TEXT characters.
    CASE               = Sets the case for TEXT characters.
    HEIGHT             = Sets the height for TEXT characters.
    WIDTH              = Sets the width for TEXT characters.
    HW                 = Sets the height and width for TEXT characters.
    VERTICAL SPACING   = Sets the vertical spacing between text lines.
    HORIZONTAL SPACING = Sets the horizontal spacing between text
                         characters.
    THICKNESS          = Sets the thickness of TEXT characters.
    JUSTIFICATION      = Sets the justification for TEXT.
    CR                 = Sets the carriage return after text.
    LF                 = Sets the line feed after text.
    CRLF               = Sets the carriage return/line feed after text.
    MARGIN             = Sets the carriage return column after text.
    ()                 = Allows math and Greek characters in text.
    MOVE               = Moves to a point.
    CROSS-HAIR (or CH) = Activates and reads the cross-hair.
    ERASE              = Erases the screen (immediately).
    COPY               = Copies the screen (immediately).
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    VERTICAL SPACING 6
    CRLF ON
    MARGIN 10
    FONT DUPLEX
    .
    HW 4 2
    MOVE 5 95
    TEXT JAPAN's 6-POINT PROGRAM FOR
    MOVE 5 89
    TEXT QUALITY MANUFACTURING
    MOVE 10 80
    COLOR G50
    HW 2.2 1.1
    TEXT CIRC() QUALITY AUDITS
    TEXT CIRC() COMPANY-WIDE QUALITY CONTROL (CWQC)
    TEXT CIRC() QUALITY TRAINING AND EDUCATION
    TEXT CIRC() APPLICATION OF STATISTICAL METHODS
    TEXT CIRC() QUALITY CIRCLE ACTIVITIES
    TEXT CIRC() NATION-WIDE QUALITY CONTROL PROMOTIONAL ACTIVITIES
    COLOR BLACK
    HW 2 1
    MOVE 5 10
    TEXT SOURCE: Q.C. TRENDS WINTER 1985, PAGES 22-23.
 
-----COLUMN LIMITS-----------------------------------------------------
 
COLUMN LIMITS
 
Name:
    COLUMN LIMITS
 
Type:
    Support Command
 
Purpose:
    Specifies the column limits in a file between which the read scan
    is restricted during subsequent READ and SERIAL READ commands.  The
    specified columns and all columns in between will be included in
    the data read.
 
Description:
    The COLUMN LIMITS command is useful for selectively reading
    variables from a file and for skipping columns containing character
    data.
 
    DATAPLOT by default performs free format reads.  The COLUMN LIMITS
    and ROW LIMITS commands provide a method for restricting DATAPLOT
    to looking at certain columns and rows.  However, within these
    limits DATAPLOT still performs free format reads.  The SET READ
    FORMAT command can be used to perform formatted reads.
 
    The COLUMN LIMITS command also accepts array arguments.  For
    example,

        COLUMN LIMITS  LOWER  UPPER

    with LOWER and UPPER denoting variables (as oppossed to
    parameters) each with N elements.  Dataplot will parse
    the data file assuming that field one of the data is in
    columns LOWER(1) to UPPER(1), field two of the data is
    in LOWER(2) to UPPER(2) and so on.  Note that only one
    numeric or character variable will be read in each field.

    Many programs, Excel for example, will write data to ASCII
    files with the data values either left or right justified
    to a given column. 

    If the ASCII file is written so that the decimal point is in
    a fixed column, then using the SET READ FORMAT is typically
    recommended rather than the COLUMN LIMITS with array
    arguments.
    
    If the data file contains columns of equal length that are
    separated by an appropriate delimiter (e.g., a space or
    comma), then using this form of the COLIMNM LIMITS command is
    not necessary.  However, there are some cases where it is useful:

       1) If you only want to read selected fields in the data
          file, then this form of the COLUMN LIMITS command
          easily allows you to do this.

       2) If the data columns are of unequal length, as ASCII
          files created from Excel often are, then this form
          of the COLUMN LIMITS allows these data files to be
          read correctly. If a given field is empty, Dataplot
          interprets it as a missing value.

          By default, Dataplot will set the missing value to 0. 
          If you would like to specify a value other than zero,
          then enter the command

             SET READ MISSING VALUE  <value>

          where <value> is the desired value.

       3) If the data columns are not separated by a delimiter
          (such as a space or a comma), then this form of the
          COLUMN LIMITS tells Dataplot how to correctly interpret
          the numbers.

       For each of these cases, you have a choice between using the
       SET READ FORMAT or the array form of the COLUMN LIMITS.  The
       location of the decimal point is the key.  If the decimal
       point is in a fixed column, then the SET READ FORMAT is
       preferred.  If the decimal point is not in a fixed column
       (i.e., the number is left or right justified), then the
       SET READ FORMAT cannot be used.  In this case, the array
       form of the COLUMN LIMITS is required.

Syntax 1:
    COLUMN LIMITS   <column 1>   <column 2>
    where  <column 1> is a number or parameter that designates the
           first column to include in the read;
    and <column 2> is a number or parameter that designates the
           last column to inclde in the read.
 
Syntax 2:
    COLUMN LIMITS   <lowlim>   <upplim>
    where <lowlim> is an array where the ith row designates the first
          column to include in the read for the ith variable;
    and   <upplim> is an array where the ith row designates the last
          column to include in the read for the ith variable.

Examples:
    COLUMN LIMITS 10 30
    COLUMN LIMITS 1 15
    COLUMN LIMITS 50 63
    COLUMN LIMITS COL1 COL2
 
Note:
    Prior to February, 2003, Dataplot would not read past column
    132 (regardless of the setting for the COLUMN LIMITS).  In
    the February, 2003 version, this limit was raised to 255
    columns.  In addition, the MAXIMUM RECORD LENGTH command
    can be used to read even longer lines.  Enter
    HELP MAXIMUM RECORD LENGTH for details.

Default:
    DATAPLOT reads columns 1 to 132.  This was changed to columns
    1 to 255 in the February, 2003 version.
 
Synonyms:
    None
 
Related Commands:
    READ                = Reads data (column-wise) into variables.
    SERIAL READ         = Reads data (row-wise) into variables.
    ROW LIMITS          = Sets file lines to be included in read.
    SKIP                = Sets the number of lines to skip over at the
                          beginning of a file in subsequent reads.
    WRITE               = Writes variables, parameters, and functions
                          to the screen or to file.
    LIST                = Lists the contents of a file or list the
                          last 20 commands.
    SET READ FORMAT     = Defines a Fortran like format to use in
                          subsequent reads.
    SET READ DELIMITER  = Define the value used for missing data in
                          array form of the COLUMN LIMITS command.
 
Applications:
    Data Input
 
Implementation Date:
    Pre-1987
    2/2003: Maximum column increased from 132.
    1/2004: Array form of COLUMN LIMITS added.
 
Program:
    SKIP 25
    COLUMN LIMITS 21 132
    READ AUTO79.DAT Y1 TO Y12
 
-----COLUMN RULER-----------------------------------------------------
 
COLUMN RULER
 
Name:
    COLUMN RULER
 
Type:
    Support Command
 
Purpose:
    Prints out a column header denoting columns 1 through 80.
 
Description:
    This command is normally used before a LIST command to determine
    how to set the COLUMN LIMITS.
 
Syntax:
    COLUMN RULER
 
Examples:
    COLUMN RULER
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COLUMN LIMITS    = Set the column limits to use for READ command.
    LIST             = Lists the contents of a file.
    SET READ FORMAT  = Set a Fortran type format for subsequent reads.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    COLUMN RULER
    LIST INPUT.DAT FOR I = 1 1 10
    COLUMN LIMITS 10 45
 
-----COMMA COMMAND LINE (SET)--------------------------------------------
 
COMMA COMMAND LINE
 
Name:
    SET COMMA COMMAND LINE
    SET EQUAL COMMAND LINE
    SET HYPHEN COMMAND LINE
 
Type:
    Set Subcommand
 
Purpose:
    Specify whether commas, equal signs, or hyphens are treated as
    word delimiters when parsing Dataplot command lines.
 
Description:
    These commands are typically used internally by Dataplot for certain
    commands (specifically, they are used to support the various syntax
    for arguments to the CALL command), but they can be explicitly set.
    However, it is not typically recommended to change the default
    settings.

    Spaces will still be treated as word delimiters regardless of how the
    comma, equal signs and hyphens are set.

Syntax 1:
    SET COMMA COMMAND LINE <ON/OFF>
    where <ON> specifies that commas will be treated as word delimiters
               while <OFF> specifies that they will not.
 
Syntax 2:
    SET EQUAL COMMAND LINE <ON/OFF>
    where <ON> specifies that equal signs ("=") will be treated as word
               delimiters while <OFF> specifies that they will not.
 
Syntax 3:
    SET HYPHEN COMMAND LINE <ON/OFF>
    where <ON> specifies that hyphens ("-") will be treated as word
               delimiters while <OFF> specifies that they will not.
 
Examples:
    SET COMMA COMMAND LINE ON
    SET COMMA COMMAND LINE OFF
    SET EQUAL COMMAND LINE ON
    SET EQUAL COMMAND LINE OFF
    SET HYPHEN COMMAND LINE ON
    SET HYPHEN COMMAND LINE OFF

Default:
    SET COMMA COMMAND LINE default is OFF
    SET HYPHEN COMMAND LINE default is ON
    SET EQUAL COMMAND LINE default is ON
 
Synonyms:
    None
 
Related Commands:
    CALL       = Execute Dataplot commands stored in a file.
 
Applications:
    Parsing command line arguments on CALL commands
 
Implementation Date:
    2018/04
 
Program:
    SET COMMA COMMAND LINE ON
    SKIP 25
    READ BERGER1.DAT Y,X
    CHARACTER X
    LINE BLANK
    PLOT Y,X
 
-----COMMANDS-------------------------------------------------------
 
COMMANDS
 
Name:
    COMMANDS
 
Type:
    Keyword
 
Purpose:
    Symbolic name for DATAPLOT's command file.  It is used with the
    SEARCH and LIST commands.
 
Description:
    DATAPLOT's command file contains an alphabetic list of all
    DATAPLOT commands with a brief (one line) description.  It is a
    subset of the dictionary file.  The dictionary file also includes
    macro files, program files, and data files.
 
Syntax:
    None
 
Examples:
    SEARCH COMMANDS PLOT
    LIST COMMANDS FOR I = 1 1 35
 
Note:
    The COMMANDS file is stored in the DATAPLOT directory.  It
    has the name COMMANDS (or commands for Unix systems).  The exact
    file name and the directory where it is stored can vary depending
    on the installation (see your local DATAPLOT implementor to find
    the exact name on your system).
 
Note:
    If DATAPLOT is unable to open the command file, it is most likely
    because the directory name is not specified correctly in the local
    DATAPLOT code.  See your local DATAPLOT implementor to have this
    corrected.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SEARCH        = Search a file for a string.
    LIST          = Lists the contents of a file.
    DIRECTORY     = Symbolic name for DATAPLOT's directory file.
    DICTIONAY     = Symbolic name for DATAPLOT's dictionary file.
    DATASETS      = Symbolic name for DATAPLOT's data sets file.
    DESIGNS       = Symbolic name for DATAPLOT's design of experiments
                    file.
    SYNTAX        = Symbolic name for DATAPLOT's syntax file.
    MACROS        = Symbolic name for DATAPLOT's macros file.
    PROGRAMS      = Symbolic name for DATAPLOT's programs file.
    DISTRIBU      = Symbolic name for DATAPLOT's distributions file.
    FUNCTION      = Symbolic name for DATAPLOT's function file.
 
Applications:
    XX
 
Implementation Date:
    93/12
 
Program:
    XX
 
-----COMMENT-------------------------------------------------------
 
COMMENT
 
Name:
    COMMENT
 
Type:
    Support Command
 
Purpose:
    Designates the current line to be a comment line (i.e., it is not
    executed).
 
Description:
    The COMMENT command is used to put descriptive remarks into a
    DATAPLOT program.  It  is equivalent to a C in FORTRAN and a REM in
    BASIC.  The COMMENT command is identical to the   .   command, with
    the latter being the preferred way to enter comment lines.  As with
    all DATAPLOT commands, the command must be separated from any other
    text on the line by at least one space.
 
Syntax:
    COMMENT   <any text>
    where <any text> can be any arbitrary character string.
 
Examples:
    COMMENT STRESS ANALYSIS
    COMMENT 10/7/79
    COMMENT ANALYSIS OF SPECIMEN 4
 
Note:
    The COMMENT CHARACTER command can be used to define an additional
    character to be used as a comment.  Although this command is
    intended primarily for data files, it applies to commands as well.
 
Default:
    None
 
Synonyms:
    .
 
Related Commands:
    COMMENT CHARACTER   = Define a character to be used as a comment
                          character.
 
Applications:
    Documenting Macros
 
Implementation Date:
    Pre-1987
 
Program:
    XX
 
-----COMMENT CHARACTER-------------------------------------------------
 
COMMENT CHARACTER
 
Name:
    COMMENT CHARACTOR
 
Type:
    Support Command
 
Purpose:
    Specifies a character that designates a command or a line in a
    data file to be a comment line.
 
Description:
    This command is intended primarily for data files.  Many operating
    systems have a default comment character (e.g., the # on Unix
    systems), so many user data files follow this convention.  This
    command provides a way for DATAPLOT to read these files without the
    user having to change them.
 
Syntax:
    COMMENT CHARACTER   <character>
    where <character> is a single character to be used as the comment
    character.  If more than one character is given, all characters
    after the first are ignored.
 
Examples:
    COMMENT CHARACTER #
    COMMENT CHARACTER \
    COMMENT CHARACTER @
 
Note:
    The COMMENT CHARACTER with no arguments sets the comment character
    to default.
 
Note:
    If a new character is defined as the comment character, the "." is
    still treated as a comment on command lines (but not in data
    files).
 
Default:
    The default comment character is a period (".").
 
Synonyms:
    None
 
Related Commands:
    SUBSTITUTE CHARACTER      = Define the substitute character.
    TERMINATOR CHARACTER      = Define the terminator character.
    CONTINUE CHARACTER        = Define the continuation character.
    COMMENT CHECK             = Specify whether data files are checked
                                for comment characters.
    COMMENT                   = Enter a comment.
    .                         = Enter a comment.
 
Applications:
    Data Input
 
Implementation Date:
    90/6
 
Program:
    XX
 
-----COMMENT CHECK-----------------------------------------------------
 
COMMENT CHECK
 
Name:
    COMMENT CHECK
 
Type:
    Support Command
 
Purpose:
    Specifies whether data files are checked for the comment character
    on subsequent reads.
 
Description:
    This command allows comment lines to be embedded in data files
    without the user having to know which lines contain them.  This
    command should not be used if there are not comment lines since
    since it slows down the read.
 
Syntax:
    COMMENT CHECK <ON/OFF>
    where ON specifies that data files are checked for comment lines
    and OFF specifies that they are not.
 
Examples:
    COMMENT CHECK ON
    COMMENT CHECK OFF
 
Note:
    Comments are only looked for in column 1.
 
Default:
    Data files are not checked for comment lines.
 
Synonyms:
    None
 
Related Commands:
    COMMENT CHARACTER    = Define a character to be used as the comment
                           character.
    SKIP                 = Skip over lines at the beginning of a file
                           on subsequent reads.
 
Applications:
    Data Input
 
Implementation Date:
    90/6
 
Program:
    XX
 
-----COMBINE FREQUENCY TABLE (LET)---------------------------------
 
COMBINE FREQUENCY TABLE
 
Name:
    COMBINE FREQUENCY TABLE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Combine low frequency bins in a frequency table.
 
Description:
    For grouped data, Dataplot typically expects equal width bins.
    However, there are occasions where you want to combine bins with
    low frequencies.  For example, for the chi-square goodness of
    fit test it is recommended that the minimum frequency be at
    least five in order for the chi-square approximation to be
    valid.  This command allows you to automatically combine
    bins that are below a specified count (5 by default).

Syntax:
    LET <y2> <xlow> <xhigh> = COMBINE FREQUENCY TABLE <y1> <xmid>
                              <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable containing the original frequencies;
          <xmid> is a variable containing the bin mid-points;
          <y2> is a variable where the combined frequencies are
              stored;
          <xlow> is a variable where the lower limits for the
              combined bins are stored;
          <xhigh> is a variable where the upper limits for the
              combined bins are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y2 XLOW XHIGH = COMBINE FREQUENCY TABLE Y XMID
 
Note:
    You can specify the minimum frequency for a bin by entering
    the command

        LET MINSIZE = <value>

    before the COMBINE FREQUENCY TABLE command.

Note:
    The following commands currently accept grouped data with
    either equal size bins or unequal size bins:

       PROBABILITY PLOT
       PPCC PLOT
       KS PLOT
       CHI-SQUARE GOODNESS OF FIT

Default:
    The minimum frequency for a bin defaults to 5.
 
Synonyms:
    None
 
Related Commands:
    BINNED                      = Convert raw data to grouped data.
    CHI SQUARE GOODNESS OF FIT  = Perform a chi-square goodness
                                  of fit test.
    PROBABILITY PLOT            = Generate a probability plot.
    PPCC PLOT                   = Generate a ppcc plot.
    KS PLOT                     = Generate a Kolmogorov-Smirnov (or
                                  chi-square) goodness of fit plot.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2004/10
 
Program:
    LET Y = LOGNORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET Y1 XMID = BINNED Y
    PRINT Y1 XMID
    LET Y2 XLOW XHIGH = COMBINE FREQUENCY TABLE Y1 XMID
    PRINT Y2 XLOW XHIGH
    LOGNORMAL PPCC PLOT Y2 XLOW XHIGH
 
-----COMBINE-------------------------------------------------------
 
COMBINE
 
Name:
    COMBINE
 
Type:
    LET Subcommand
 
Purpose:
    Combine the contents of one or more variables, parameters, or
    constants into a single variable.
 
Description:
    This command is similar to the APPEND or EXTEND commands.  However
    it provides the additional flexibility:

       1) APPEND and EXTEND only work with variables.  The COMBINE
          command also allows parameters and constants.

          The output for the COMBINE command is always a single
          variable.

       2) APPEND and EXTEND will only combine the contents of two
          variables.  The COMBINE command will accept up to 30
          variables, parameters, or constants.

    Matrices and strings are not supported by the COMBINE command.

Syntax:
    LET <y> = COMBINE <x1> ... <xk>
              <SUBSET/EXPCEPT/FOR qualification>
    where <x1> ... <xk> is a set of one or more response variables,
               parameters, or constants;
          <y> is a variable that will contain the contents of
               <x1> ... <xk> in a single response variable; 
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y = COMBINE Z1 Z2 Z3 Z4 Z5
 
Note:
    The following syntax is allowed:

        LET Y = COMBINE Y Y Y

    For example,

        LET Y = DATA 1 2 3
        LET Y = COMBINE Y Y Y

    will contain the values 1, 2, 3, 1, 2, 3, 1, 2, 3.

Note:
    The <SUBSET/EXCEPT/FOR qualification> is typically not used
    with this command.  However, if one is given, it will be applied
    individually to all the variables on the right hand side of the
    equal sign.  It will be ignored for all parameters and constants.

Default:
    None.
 
Synonyms:
    None
 
Related Commands:
    APPEND        = Append one variable to another variable.
    EXTEND        = Extends a variable by another variable.
    STACK         = Convert a set of response variables to a single
                    response variable and a group-id variable.
 
Applications:
    Data Management
 
Implementation Date:
    2010/9
 
Program:
    LET A1 = 1
    LET Y1 = DATA 1 2 3 4 5
    LET A2 = 2
    LET Y2 = DATA 1 2 3 4 5
    LET Y = COMBINE A1 Y1 A2 Y2 -99
    SET WRITE DECIMALS 0
    PRINT Y
  
-----COMMON COEFFICIENT OF VARIATION CONFIDENCE LIMITS-----------------
 
COMMON COEFFICIENT OF VARIATION CONFIDENCE LIMITS
 
Name:
    COMMON COEFFICIENT OF VARIATION CONFIDENCE LIMITS
 
Type:
    Analysis Command
 
Purpose:
    Generates a confidence interval for the common coefficient of
    variation for two or more groups for normally distributed data.
 
Description:
    The coefficient of variation is defined as the ratio of the
    standard deviation to the mean

        cv = sigma/mu

    where sigma and mu denote the population standard deviation
    and population mean, respectively.  The sample coefficient
    of variation is defined as

        cv = s/xbar

    where s and xbar denote the sample standard deviation and
    sample mean respectively.

    The coefficient of variation should typically only be used
    for ratio data.  That is, the data should be continuous and
    have a meaningful zero.  Although the coefficient of variation
    statistic can be computed for data that is not on a ratio
    scale, the interpretation of the coeffcient of variation may
    not be meaningful.  Currently, this command is only supported
    for non-negative data.  If the response variable contains one
    or more negative numbers, an error message will be returned.

    For a single sample of normally distributed data, the command

         COEFFICIENT OF VARIATION CONFIDENCE LIMITS Y

    can be used to determine a confidence interval (this command
    supports six different methods for obtaining the confidence
    interval).

    The command documented here is for the case where there are two
    or more groups of data and we want to find a confidence interval
    for the common coefficient of variation for all groups.  This
    command assumes that the data for each group is approximately
    normally distributed and that each group has the same coefficient
    of variation.  For that reason, it is desirable to plot the
    coefficient of variation for each group (see the program example
    below) to check if this is a reasonable assumption.

    The biased common coefficient of variation is

         gamma = SQRT[SUM{i=1 to k}{(N(i)-1)*C(i)**2}/
                 SUM{i=1 to k}{N(i)-1)}]

    where

         k     = the number of groups
         N(i)  = the sample size of the i-th group
         C(i)  = the sample coefficient of variation for the i-th group

    A bias correccted estimate of the common coefficient of variation is

         gamma(BC) = gamma/[1 - 1/(4*SUM{i=1 to k}{N(i) -1)}]

    The confidence limits are computed as

        Lower Limit = SQRT[SUM{i=1 to k}{(N(i)-1)*U(i)}/
                      (CHSPPF(1-ALPHA/2,DF) - SUM{i=1 to k}{(N(i)-1)*U(i)}]

        Upper Limit = SQRT[SUM{i=1 to k}{(N(i)-1)*U(i)}/
                      (CHSPPF(ALPHA/2,DF) - SUM{i=1 to k}{(N(i)-1)*U(i)}]

    where

         U(i)    = C(i)**2/(1 + C(i)**2*(N(i)-1)/N(i)
         DF      = SUM[i=1 to k][N(i) - 1]
         CHSPPF  = the percent point function of the chi-square distribution

    This confidence interval was proposed by Forkman (see References below).

Syntax 1:
    <LOWER/UPPER> COMMON COEFFICIENT OF VARIATION CONFIDENCE LIMITS <y> <x>
                  <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <x> is the group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    If LOWER is specified, a one-sided lower confidence limit is
    returned.  If UPPER is specified, a one-sided upper confidence
    limit is returned.  If neither is specified, a two-sided limit
    is returned.

    This syntax does not support matrix arguments for the response and
    group-id variables.

Syntax 2:
    MULTIPLE <LOWER/UPPER> COMMON COEFFICIENT OF VARIATION CONFIDENCE
                           LIMITS  <y1> ... <yk>
                           <SUBSET/EXCEPT/FOR qualification>
    where <y1>  .... <yk> is a list of 1 to 30 response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax can be used if the groups are in separate variables.

    You can use the TO syntax as in

         COEFFICIENT OF VARIATION CONFIDENCE LIMITS Y1 TO Y10

    If LOWER is specified, a one-sided lower confidence limit is
    returned.  If UPPER is specified, a one-sided upper confidence
    limit is returned.  If neither is specified, a two-sided limit
    is returned.

    This syntax supports matrix arguments for the response variables.

Examples:
    COMMON COEFFICIENT OF VARIATION CONFIDENCE LIMITS Y1 X1
    COMMON COEFFICIENT OF VARIATION CONFIDENCE LIMITS Y1  X1 SUBSET X1 > 2
    MULTIPLE COMMON COEFFICIENT OF VARIATION CONFIDENCE LIMITS Y1 TO Y5
 
Note:
    A table of confidence limits is printed for alpha levels of 50.0,
    80.0, 90.0, 95.0, 99.0, and 99.9.
 
Note:
    In addition to the COEFFICIENT OF VARIATION CONFIDENCE LIMIT command,
    the following commands can also be used:

        LET ALPHA = 0.05

        LET A = COMMON COEFFICIENT OF VARIATION Y X
        LET A = COMMON BIAS CORRECTED COEFFICIENT OF VARIATION Y X
        LET A = LOWER COMMON COEFFICIENT OF VARIATION CONFIDENCE LIMIT Y X
        LET A = UPPPER COMMON COEFFICIENT OF VARIATION CONFIDENCE LIMIT Y X

    The first command specifies the significance level.

    In addition to the above LET commands, built-in statistics are
    supported for 20+ different commands (enter HELP STATISTICS for
    details).

Note:
    Any groups that have only a single value or that have negative values
    will be omitted when computing the confidence interval.  After removing
    any such groups, at least two groups must be available before the
    confidence limit will be generated.

Default:
    None
 
Synonyms:
    CONFIDENCE INTERVAL is a synonym for CONFIDENCE LIMITS
 
Related Commands:
    COEFFICIENT OF VARIATION  = Compute the coefficient of variation.
    COEF OF VARI CONF LIMITS  = Compute a confidence interval for the
                                coefficient of variation.
    COEFFICIENT OF VARI TEST  = Perform a one sample or a two sample
                                coefficient of variation test.
    CONFIDENCE LIMITS         = Generate a confidence limit for the mean.
    SD CONFIDENCE LIMITS      = Generate a confidence limit for the
                                standard deviation.
    PREDICTION LIMITS         = Generate prediction limits for the mean.
    TOLERANCE LIMITS          = Generate a tolerance limit.
 
References:
     Forkman (2009), "Estimator and Tests for Common Coefficients of
     Variation in Normal Distributions", Communications in Statistics -
     Theory and Methods, Vol. 38, pp. 233-251.

     McKay (1932), "Distributions of the Coefficient of Variation and the
     Extended 't' Distribution", Journal of the Royal Statistical Society,
     Vol. 95, pp. 695-698.

Applications:
    Confirmatory Data Analysis
 
Implementation Date:
    2017/06
 
Program:
    . Step 1:   Create the data
    .
    skip 25
    read gear.dat y x
    skip 0
    set write decimals 6
    .
    . Step 2:   Define plot control settings and plot the data
    .
    title case asis
    title offset 2
    label case asis
    .
    y1label Coefficient of Variation
    x1label Group
    title Coefficient of Variation for GEAR.DAT
    let ngroup = unique x
    xlimits 1 ngroup
    major x1tic mark number ngroup
    minor x1tic mark number 0
    tic mark offset units data
    x1tic mark offset 0.5 0.5
    y1tic mark label decimals 3
    .
    character X
    line blank
    .
    set statistic plot reference line average
    .
    coefficient of variation plot y x
    .
    . Step 3:   Generate the confidence limits
    .
    common coefficient of variation confidence limits y x

-----COMMON WEIBULL SHAPE PARAMETER----------------------------------------
 
COMMON WEIBULL SHAPE PARAMETER
 
Name:
    COMMON WEIBULL SHAPE PARAMETER
 
Type:
    Analysis Command
 
Purpose:
    Test whether k samples that follow a 2-parameter Weibull distribution
    have a common shape parameter.
 
Description:
    In a number of Weibull modeling applications, it is desired to test
    whether different groups of the data follow 2-parameter Weibull
    distributions having a common shape parameter.  For example, in testing
    fiber strength, it is commonly assumed that fibers of different gauge
    length will have a common shape shape parameter but differing scale
    parameters.  This assumption can be tested using a test given by
    McCool (2012).

    Before applying the test described here, each of the samples should be
    tested to ensure that they can in fact be adequately modeled with a
    2-parameter Weibull distribution.  If not, then applying this test is
    not meaningful.

    Given k samples, the test procedure is as follows.

        1. For each sample, fit a 2-parameter Weibull distribution.
           Identify the shape parameters as Bhat(1), Bhat(2), ... ,
           Bhat(k).

        2. Determine the minimum and maximum values of the shape parameter.

        3. The test statistic is

              Bhat(maximum)/Bhat(minimum)

           If all of the shape parameters are exactly equal, then this
           test statistic would be equal to one.  Values of this test
           statistic that are significantly larger than one indicate that
           the shape parameters are not equal.

        4. Critical values are determined via simulation.  Specifically,
           generate k 2-parameter Weibull samples with a common shape
           parameter (Dataplot uses a value of 2 for the shape parameter
           and a value of 1 for the scale parameter).  The ratio above is
           computed for 10,000 simulations.

Syntax 1:
    COMMON WEIBULL SHAPE PARAMETER  <y>  <tag>
                                    <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <tag> is a group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    The response variable and the group-id variables should have the same
    number of observations.

Syntax 2:
    MULTIPLE COMMON WEIBULL SHAPE PARAMETER  <y1> ... <yk>
                                    <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of 2 to 30 response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    The response variables do not need to have equal sample sizes.

Syntax 3:
    REPLICATED COMMON WEIBULL SHAPE PARAMETER  <y> <x1> ... <xk>
                              <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <x1> ... <xk> is a list of 1 to 6 group-id variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    All variables should have the same number of observations.

Examples:
    COMMON WEIBULL SHAPE PARAMETER  Y X
    REPLICATED COMMON WEIBULL SHAPE PARAMETER  Y X1 X2
    MULTIPLE COMMON WEIBULL SHAPE PARAMETER  Y1 TO Y5
    COMMON WEIBULL SHAPE PARAMETER Y X  SUBSET X > 1
 
Note 1:
    The following parameters are saved by this command.

        STATVAL   - value of the test statistic
        STATCDF   - CDF for the test statistic
        PVALUE    - p-value for the test statistic
        CUTOFF0   - 0% critical value
        CUTOFF50  - 50% critical value
        CUTOFF75  - 75% critical value
        CUTOFF90  - 90% critical value
        CUTOFF95  - 95% critical value
        CUTOF975  - 97.5% critical value
        CUTOFF99  - 99% critical value
        CUTOF999  - 99.9% critical value
 
Note 2:
    The following statistics are also supported

        LET A = COMMON WEIBULL SHAPE TEST Y  X
        LET A = COMMON WEIBULL SHAPE TEST CDF Y  X
        LET A = COMMON WEIBULL SHAPE TEST PVALUE Y  X
        LET A = COMMON WEIBULL SHAPE TEST CV90 Y  X
        LET A = COMMON WEIBULL SHAPE TEST CV95 Y  X
        LET A = COMMON WEIBULL SHAPE TEST CV99 Y  X

    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Note 3:
    If the shape parameters are deemed to be statistically equivalent,
    then a common shape parameter will be estimated.  You can define the
    cut-off for statistical equivalence by entering the command

         LET ALPHA = <value>

    where <value> is 0.90, 0.95, or 0.99.  If this command is not
    given, the default value for alpha will be 0.95.

    The equation used to estimate the common shape parameter is given on
    page 238 of McCool.  If a common shape parameter is estimated, then
    the corresponding scale parameters for each of the groups based on
    this common shape parameter are written to the file "dpst1f.dat".

Note 4:
    McCool defines this test for either uncensored data or for type II
    censored data (i.e., there are a fixed number of failures).  McCool
    provides tables of critical values for various values of n (number
    of observations per group), r (number of failures), and k (number of
    groups).  His tables assume that n and r are the same for all k groups.
    However, the requirement for equal n and r values is for the purpose
    of creating manageable tables and is not a theoretical restriction.

    Dataplot currently only supports the uncensored data case.  Dataplot
    performs the simulations for the critical values dynamically, so it
    does not require equal sample sizes for the groups.

Note 5:
    Note the similarity of this test to the Hartley test.  For k samples
    that are normally distributed and have equal sample size, Hartley's
    test computes the ratio of the largest variance to the smallest
    variance.  Hartley's test is quite sensitive to departures from
    normality.  Likewise, the common Weibull shape parameter test is
    only meaningful if the individual samples follow 2-parameter Weibull
    distributions.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    MAXIMUM LIKELIHOOD  = Perform a distributional maximum likelihood
                          estimation.
    GOODNESS OF FIT     = Perform a distributional goodness of fit test.
 
Reference:
    McCool (2012), "Using the Weibull Distribution: Reliability, Modeling,
    and Inference", Wiley, pp.  236-238.
 
Applications:
    Distributional Modeling
 
Implementation Date:
    2014/4
 
Program:
    . Step 1:   Read the data
    .
    skip 25
    read mccool82.dat y1 y2 y3 y4 y5
    let y x = stack y1 y2 y3 y4 y5
    set write decimals 5
    set minmax 1
    .
    . Step 2:   Perform the command
    .
    common weibull shape test y x
    .
    . Step 3:   Compute the test statistic
    .
    let statval = common weibull shape test y x
    let statcdf = common weibull shape test cdf y x
    let pval    = common weibull shape test pvalue y x
    let cv90    = common weibull shape test cv90 y x
    .
    print statval statcdf pval cv90

-----COMOVEMENT (LET)--------------------------------
 
COMOVEMENT
 
Name:
    COMOVEMENT (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the Leigh-Perlman comovement coefficient for a variable.
 
Description:
    The comovement coefficient is the sum of cross products divided by
    N-1.  It is computed as:
          COMOVE = SUMXY/(SQRT(SUMX)*SQRT(SUMY))
    where
          SUMXY = SUM ((X(i)-X(i-1))*(Y(i)-Y(I-1)))
          SUMX  = SUM(X(i)-X(i-1))
          SUMY  = SUM(Y(i)-Y(i-1))
    and the summations are done from 2 to N.  The computed coefficient
    has a value between -1 and +1.
 
Syntax:
    LET <par> = COMOVEMENT <y1> <y2> <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed comovement is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = COMOVEMENT Y1 Y2
    LET A = COMOVEMENT Y1 Y2 SUBSET TAG > 2
 
Note:
    The two variables must have the same number of elements.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    RANK COMOVEMENT  = Compute the rank comovement of two variables.
    CORRELATION      = Compute the correlation of a variable.
    RANK CORRELATION = Compute the rank correlation of a variable.
    COVARIANCE       = Compute the covariance between two variables.
    VARIANCE         = Compute the variance of a variable.
 
Reference:
    "An Index for Comovement of Time Sequences with Geophysical
    Applications: A Working Paper", Penn State Interface Conference on
    Astronomy, August, 1991.
 
Applications:
    XX
 
Implementation Date:
    91/8
 
Program:
    LET Y1 = EXPONENTIAL RANDOM NUMBERS FOR I = 1 1 100
    LET Y2 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET A1 = COMOVEMENT Y1 Y2
 
-----COMOVEMENT PLOT-------------------------------------------------
 
COMOVEMENT PLOT
 
Name:
    ...COMOVEMENT PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a comovement plot.
 
Description:
    A comovement plot is a graphical data analysis technique for
    determining if comovement exists between:
       1) lags for a single time series (an autocomovement plot);
       2) lags for two time series (a cross-comovement plot).
    The comovement plot consist of:
       Vertical   axis = comovememnt coefficient (a value between -1
                         and 1);
       Horizontal axis = lag (an integer between 1 and n/4 where
                         <n> = number of observations).
 
    The Leigh-Perlman comovement coefficient is the sum of cross
    products divided by N-1.  The equation for the lag k comovement
    coefficient is:

          COMOVE(k) = SUMXY/(SQRT(SUMX)*SQRT(SUMY))

    where

          SUMXY = SUM ((X(i)-X(i-k))*(Y(i)-Y(i-k)))
          SUMX  = SUM(X(i)-X(i-k))
          SUMY  = SUM(Y(i)-Y(i-k))

    and the summations are done from k+1 to N.  The computed
    coefficient has a value between -1 and +1.
 
Syntax 1:
    AUTOCOMOVEMENT PLOT    <y>     <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    CROSS-COMOVEMENT PLOT    <y1>   <y2>
    where <y1> is the first response variable;
          <y2> is the second response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    AUTOCOMOVEMENT PLOT Y
    CROSS COMOVEMENT PLOT Y1 Y2
 
Note:
    After generating an autocomovement or cross-comovement plot, the
    variable YPLOT contains the numerical values for the correlations.
    If you need to do additional analysis, or simply wish to print the
    numeric values, copy this variable to a user variable (e.g., LET
    COMOVE = YPLOT).  The YPLOT variable is overwritten when the next
    plot is generated.
 
Note:
    The LINE, CHARACTER, SPIKE, and BAR commands can be used to control
    the appearance of the comovement plot.  For example, some analysts
    prefer to draw comovements as spikes from the zero baseline.
    Trace 1 is the comovement line and trace 2 is the line at zero.
 
Note:
    The number of lags is determined automatically.  If you want to
    override the default, enter one of the following commands:

        LET LAGS = <value>
        LET LAG = <value>
        LET NUMLAG = <value>
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COMOVEMENT          = Compute the comovement statistic.
    CORRELATION PLOT    = Generates an auto or cross correlation plot.
    SPECTRUM            = Generates a spectral plot.
    CHARACTERS          = Sets types for plot characters.
    LINES               = Sets types for plot lines.
    SPIKES              = Sets on/off switches for plot spikes.
 
Reference:
    "An Index for Comovement of Time Sequences with Geophysical
    Applications: A Working Paper", Penn State Interface Conference on
    Astronomy, August, 1991.
 
Applications:
    Time Series Analysis
 
Implementation Date:
    12/1997
 
Program 1:
    SKIP 25
    READ LEW.DAT DEFLECT
    .
    LINE BLANK SOLID
    SPIKE ON
    SPIKE BASE 0
    XLABEL LAG
    Y1LABEL COMOVEMENT
    .
    AUTOCOMOVEMENT PLOT DEFLECT
 
Program 2:
    SKIP 25
    READ HAYES1.DAT Y1 Y2
    .
    LINE BLANK SOLID
    SPIKE ON
    SPIKE BASE 0
    XLABEL LAG
    Y1LABEL COMOVEMENT
    .
    CROSS-COMOVEMENT PLOT Y1 Y2
 
-----COMPLETE SPATIAL RANDOMNESS----------------------------------------
 
COMPLETE SPATIAL RANDOMNESS
 
Name:
    COMPLETE SPATIAL RANDOMNESS
 
Type:
    Analysis Command
 
Purpose:
    Perform several tests for complete spatial randomness in the
    two-dimensional case.
 
Description:
    In spatial analysis, a common first step is to test the data
    for complete spatial randomness.  If the data exhibits complete
    spatial randomness, this implies that there is no underlying
    structure in the data and therefore little to be gained from
    further analysis.

    In the univariate case, spatial randomness implies that the
    data points can be modeled with a uniform distribution.  Likewise,
    in the two-dimensional case, spatial randomness implies that the
    data can be modeled with a bivariate uniform distribution with
    zero correlation between the two dimensions.  So a quick graphical
    assessment of spatial randomness can be obtained by simply plotting
    the points.  If there is complete spatial randomness, this plot
    should show no obvious structure.

    This command implements the following formal tests for complete
    spatial randomness:

        1) BIVARIATE CRAMER VON-MISES TEST

           The Cramer Von-Mises test is a common test for assessing
           distributional goodness of fit for a univariate dataset.
           Specifically, it can be used to test for univariate
           uniformity.

           Zimmerman (1993, see References below) describes an
           extension of the Cramer Von-Mises test for the case of
           bivariate uniformity.  He modified the bivariate Cramer
           Von-Mises test so that it is invariant to which vertex
           of the enclosing rectangle is used as the origin.

           For this test, we have a set of N points defined in (X,Y).
           We also need the coordinates of the enclosing rectangle (if
           these are not given, they will be based on the data minimum
           and maximums).  The test statistic is

              Wbar^2 = (1/(4*N))*SUM[i=1 to N]
                       [SUM[j=1 to N][(1 - |u(i) - u(j)|)*
                       (1 - |v(i) - v(j)|)]] -
                       0.5*SUM[i=1 to N][(u(i)**2 - u(i) - 0.5)*
                       (v(i)**2 - v(i) - 0.5)] + N/9

           where

                u(i) = X(i)/XMAX
                v(i) = Y(i)/YMAX

           The critical values for the test are taken from tables in
           the Zimmerman article and are provided for alpha levels
           0.50, 0.75, 0.85, 0.90, 0.95, 0.98, and 0.99.

        2) MEAN NEAREST NEIGHBORS TEST

           The mean nearest neighbor distance test was first described
           by Clark and Evans (1954, see Refereces below).  Dataplot
           implements a modified version of the Clark-Evans test
           due to Donnelly (1978) that is described in Zimmerman (1993).

           Given a set of N points (X,Y), the test statistic is

               T = (Zbar - mu(Zbar))/sigma(Zbar)

           where 

               Zbar = (1/N)*SUM[i=1 to N][Z(i)]

               Z(i) is the distance from the i=th event to it's nearest
                    neighbor

               mu(Zbar) = 0.5*N**(-1/2)  + 0.206*N**(-1) +
                          0.164*N**(-3/2)

               sigma(Zbar) = 0.070*N**(-2) + 0.148*N**(-5/2)

           When there is complete spatial randomness, this statistic
           follows an approximately standard normal distribution.

        3) POLLARD TEST

           The Pollard test is also based on nearest neighbors.  However,
           instead of the first nearest neighbor, we check the first
           through fifth nearest neighbors.  The test implemented in
           Dataplot is a modified version of Pollard's test that is
           described in Fortin and Dale (2005).

           The Pollard test statistic is

               P(j) = C1*[n*LN(C2) - C3]/C4

           where

               C1 = 12*j**2*n
               C2 = SUM[i=1 to n][X(ij)**2/n]
               C3 = SUM[i=1 to n][LN(X(ij)**2)]
               C4 = (6*j*n + n + 1)*(n-1)

           and where 

               j denotes the j-th nearest neighbor 
               X(ij) is the distance from the i-th point to it's
                     j-th nearest neighbor

               j is 1, 2, 3, 4, or 5

            Values of the test statistic near 1 indicate complete spatial
            randomness.  Values less than 1 indicate overdispersion and
            values greater than 1 indicate underdispersion.

            (n-1)*P(j) has an approximately chi-square distribution with
            (n-1) degrees of freedom.

    Note that there are many ways in which the data can be non-random.
    In particular, a broad distinction is typically made between
    1) random (i.e., complete spatial randomness); 2) underdispersed
    (clumped or aggregated); and 3) overdispersed (spaced or regular).
    In addition, non-randomness can be scale dependent.  That is,
    non-randomness may appear either "locally" or "globably".  For
    example, a set of points may appear random if examined in smaller
    subsets (i.e., local) but not if examined as a whole.

    A large number of tests have been developed to test for spatial
    randomness.  These tests vary in what types of non-randomness they
    are sensitive to.  According to Zimmerman, tests based on nearest
    neighbors tend to be sensitive to "local" non-randomness while being
    relatively insensitive to "global" characteristics.  So these tests
    are quite good at detecting aggregation and regularity but not good at
    detecting heterogeneity.  On the other hand, the bivariate Cramer
    Von Mises test is more senstive to global characteristics and
    less sensitive to local characteristics.  So it tends to be
    good at detecting heterogeneity but not as good at detecting
    aggregation and regularity.  The Pollard test expands the "local"
    neighborhood by looking at the first through fifth nearest
    neighbors rather than just the single nearest neighbor.  So taken
    together, this combination of tests should be able to detect many
    different types of non-randomness.

Syntax:
    COMPLETE SPATIAL RANDOMNESS  <x>  <y>
                                 <SUBSET/EXCEPT/FOR qualification>
    where <x> is a response variable;
          <y> is a factor identifier variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Examples:
    COMPLETE SPATIAL RANDOMNESS X Y
 
Note:
    For the bivariate Cramer Von-Mises test, the boundaries of the
    enclosing rectangle can be specified by entering the commands

       LET XMIN = <value>
       LET XMAX = <value>
       LET YMIN = <value>
       LET YMAX = <value>

Note:
    The following statistics are also supported:

        LET A = BIVARIATE CRAMER VON MISES TEST X Y
        LET A = BIVARIATE CRAMER VON MISES TEST CV95 X Y
        LET A = BIVARIATE CRAMER VON MISES TEST CV05 X Y

        LET A = MEAN NEAREST NEIGHBOR DISTANCE TEST X Y
        LET A = MEAN NEAREST NEIGHBOR DISTANCE CDF X Y
        LET A = MEAN NEAREST NEIGHBOR DISTANCE PVALUE X Y

        LET A = POLLARD <ONE/TWO/THREE/FOUR/FIVE> TEST X Y
        LET A = POLLARD <ONE/TWO/THREE/FOUR/FIVE> CDF X Y
        LET A = POLLARD <ONE/TWO/THREE/FOUR/FIVE> PVALUE X Y

    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    GOODNESS OF FIT                     = Perform a univariate goodness of
                                          fit test.
    INDEPENDENT UNIFORM RANDOM NUMBERS  = Generate multivariate uniform
                                          random numbers when there is
                                          zero correlation.
    DEPEPENDENT UNIFORM RANDOM NUMBERS  = Generate multivariate uniform
                                          random numbers when there is
                                          non-zero correlation.
 
Reference:
    Dale Zimmerman (1993), "A Bivariate Cramer-Von Mises Type of Test
    For Spatial Randomness", Journal of the Royal Statistical Society,
    Series C, Applied Statistics, Vol. 42, No. 1, pp. 43-54.

    Clark and Evans (1954), "Distance to Nearest Neighbor as a Measure
    of Spatial Relationships in Populations", Ecology, 35, pp. 23-30.

    Donnelly (1978), "Simulations to Determine the Variance and
    Edge-Effect of Total Nearest-Neighbor Distance", in Simulation
    Studies in Archaeology (ed. Hodder), pp. 91-95, London: Cambridge
    University Press.

    Fortin and Dale (2005), "Spatial Analysis: A Guide for Ecologists",
    Cambridge University Press, pp. 34-35.

    Pollard (1971), "On Distance Estimators of Density in Randomly
    Distributed Forests", Biometrics, 27, pp. 991-1002.

    Liu (2001), "A Comparison of Five Distance-Based Methods for Pattern
    Analysis", Journal of Vegetation Science, 12, pp. 411-416.

Applications:
    Spatial Analysis
 
Implementation Date:
    2014/1
 
Program:
    . Step 1:   Generate some random points.
    .
    let lowlim = data 0 0
    let upplim = data 1 1
    let n = 40
    let m = independent uniform random numbers lowlim upplim n
    let y = m1
    let x = m2
    . 
    . Step 2:   Plot the uniform random numbers
    .
    char circle
    char fill on
    char hw 0.5 0.375
    line blank
    plot y x
    .
    . Step 3:   Complete Spatial Randomness Test
    .
    set write decimals 3
    complete spatial randomness test y x
    . 
    . Step 4:   Demonstrate how to extract individual statistics
    .
    let tval  = mean nearest neighor distance test   x y
    let tcdf  = mean nearest neighor distance cdf    x y
    let tpval = mean nearest neighor distance pvalue x y
    print tval tcdf tpval
    let bval  = bivariate cramer von mises test x y
    let cv95  = bivariate cramer von mises 95 critical value x y
    let cv05  = bivariate cramer von mises 05 critical value x y
    print bval cv95 cv05
    let xmin = 0
    let xmax = 1
    let ymin = 0
    let ymax = 1
    let bval2  = bivariate cramer von mises test x y
    .
    let pol1     = pollard one test   x y
    let pol1cdf  = pollard one cdf    x y
    let pol1pval = pollard one pvalue x y
    print pol1 pol1cdf pol1pval
    .
    let pol2     = pollard two test   x y
    let pol2cdf  = pollard two cdf    x y
    let pol2pval = pollard two pvalue x y
    print pol2 pol2cdf pol2pval
    .
    let pol3     = pollard three test   x y
    let pol3cdf  = pollard three cdf    x y
    let pol3pval = pollard three pvalue x y
    print pol3 pol3cdf pol3pval
    .
    let pol4     = pollard four test   x y
    let pol4cdf  = pollard four cdf    x y
    let pol4pval = pollard four pvalue x y
    print pol4 pol4cdf pol4pval
    .
    let pol5     = pollard five test   x y
    let pol5cdf  = pollard five cdf    x y
    let pol5pval = pollard five pvalue x y
    print pol5 pol5cdf pol5pval

-----COMPLEX (LET)-----------------------------------------------------
 
COMPLEX
The following are DATAPLOT complex number commands:
    COMPLEX ADDITION (LET)    = Carries out a complex addition.
    COMPLEX SUBTRACTION (LET) = Carries out a complex subtraction.
    COMPLEX MULT  (LET)       = Carries out a complex multiplication.
    COMPLEX DIVISION (LET)    = Carries out a complex division.
    COMPLEX EXPON  (LET)      = Carries out a complex exponentiation.
    COMPLEX SQUARE ROOT (LET) = Carries out a complex square root.
    COMPLEX CONJUGATE (LET)   = Carries out a complex conjugate.
    COMPLEX ROOTS (LET)       = Computes the complex roots.
 
-----COMPLEX ADDITION (LET)--------------------------------------
 
COMPLEX ADDITION
 
Name:
    COMPLEX ADDITION (LET)
 
Type:
    Subcommand under LET
 
Purpose:
    Carry out a complex addition (element-by-element) of 2 complex
    variables.
 
Description:
    In DATAPLOT, all variables are stored as real.  Thus all complex
    variables can be referred to by the analyst as the pair of real
    variables-- the real and imaginary parts.  Hence the pair Y1,Y2 of
    real variables may be thought of by the analyst as the single
    complex variable Y1 + i*Y2 where i is the usual imaginary unit =
    sqrt(-1).
 
    Complex addition is performed by adding the two real components and
    adding the two complex components.  That is,
        (a +bi) + (c+di) = (a+c) + (b+d)i
 
Syntax:
    LET <v5> <v6> = COMPLEX ADDITION <v1> <v2> <v3> <v4>
                        <SUBSET/EXCEPT/FOR qualification>
    where <v1> and <v2> are the real and imaginary components of the
               first input variable;
          <v3> and <v4> are the real and imaginary components of the
               second input variable;
          <v5> and <v6> are the real and imaginary components of the
               output variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional (and
               rarely used in this context).
 
Examples:
    LET Y5 Y6   = COMPLEX ADDITION Y1 Y2 Y3 Y4
    LET Y3R Y3I = COMPLEX ADDITION Y1R Y1I Y2R Y2I
    LET E F   = COMPLEX ADDITION A B C D SUBSET A > 10
    LET E F   = COMPLEX ADDITION A B C D FOR I = 1 1 20
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COMPLEX SUBTRACTION (LET) = Carries out a complex subtraction.
    COMPLEX MULT  (LET)       = Carries out a complex multiplication.
    COMPLEX DIVISION (LET)    = Carries out a complex division.
    COMPLEX EXPON  (LET)      = Carries out a complex exponentiation.
    COMPLEX SQUARE ROOT (LET) = Carries out a complex square root.
    COMPLEX CONJUGATE (LET)   = Carries out a complex conjugate.
    COMPLEX ROOTS (LET)       = Computes the complex roots.
 
    POLYNOMIAL ADDITION (LET) = Carries out a polynomial addition.
    VECTOR ADDITION (LET)     = Carries out a vector addition.
    SET UNION (LET)           = Carries out a set union.
    LOGICAL AND (LET)         = Carries out a logical and.
    MATRIX ADDITION (LET)     = Carries out a matrix addition.
    FOURIER TRANSFORM (LET)   = Computes the Fourier Transform.
    INVERSE FOURIER TRAN (LET)= Computes the Inverse Fourier Transform.
    FFT (LET)                 = Computes the Fast Fourier Transform.
    INVERSE FFT (LET)         = Computes the Inverse FFT.
 
    PLOT                      = Plots data or functions.
 
Applications:
    Mathematics
 
Implementation Date:
    87/10
 
Program:
    READ X1 Y1 X2 Y2
    1 2 3 4
    3 5 2 1
    2 2 4 3
    END OF DATA
    LET X3 Y3 = COMPLEX ADDITION X1 Y1 X2 Y2
    SET WRITE DECIMALS 0
    WRITE X1 Y1 X2 Y2 X3 Y3
 
-----COMPLEX CONJUGATE (LET)-------------------------------------
 
COMPLEX CONJUGATE
 
Name:
    COMPLEX CONJUGATE (LET)
 
Type:
    Subcommand under LET
 
Purpose:
    Carry out a complex conjugation (element-by-element) of a complex
    variable.
 
Description:
    In DATAPLOT, all variables are stored as real.  Thus all complex
    variables can be referred to by the analyst as the pair of real
    variables-- the real and imaginary parts.  Hence the pair Y1,Y2 of
    real variables may be thought of by the analyst as the single
    complex variable Y1 + i*Y2 where i is the usual imaginary unit =
    sqrt(-1).
 
    The complex conjugate of a + bi is a - bi.
 
Syntax:
    LET <v3> <v4> = COMPLEX CONJUGATE <v1> <v2>
                        <SUBSET/EXCEPT/FOR qualification>
    where <v1> and <v2> are the real and imaginary components of the
               first input variable;
          <v3> and <v4> are the real and imaginary components of the
               output variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional (and
               rarely used in this context).
 
Examples:
    LET Y3 Y4   = COMPLEX CONJUGATE Y1 Y2
    LET Y2R Y2I = COMPLEX CONJUGATE Y1R Y1I
    LET Y3 Y4   = COMPLEX CONJUGATE Y1 Y2 SUBSET Y1 > 10
    LET Y3 Y4   = COMPLEX CONJUGATE Y1 Y2 FOR I = 1 1 20
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COMPLEX ADDITION (LET)    = Carries out a complex addition.
    COMPLEX SUBTRACTION (LET) = Carries out a complex subtraction.
    COMPLEX MULT  (LET)       = Carries out a complex multiplication.
    COMPLEX DIVISION (LET)    = Carries out a complex division.
    COMPLEX EXPON  (LET)      = Carries out a complex exponentiation.
    COMPLEX SQUARE ROOT (LET) = Carries out a complex square root.
    COMPLEX ROOTS (LET)       = Computes the complex roots.
 
    SET COMPLEMENT (LET)      = Computes the set complement.
    LOGICAL NOT (LET)         = Computes the logical not.
 
    FOURIER TRANSFORM (LET)   = Computes the Fourier Transform.
    INVERSE FOURIER TRAN (LET)= Computes the Inverse Fourier Transform.
    FFT (LET)                 = Computes the Fast Fourier Transform.
    INVERSE FFT (LET)         = Computes the Inverse FFT.
 
    PLOT                      = Plots data or functions.
 
Applications:
    Mathematics
 
Implementation Date:
    87/10
 
Program:
    READ X1 Y1
    1 2
    3 5
    2 2
    END OF DATA
    LET X2 Y2 = COMPLEX CONJUGATE X1 Y1
    WRITE X1 Y1 X2 Y2
 
-----COMPLEX DIVISION (LET)--------------------------------------
 
COMPLEX DIVISION
 
Name:
    COMPLEX DIVISION (LET)
 
Type:
    Subcommand under LET
 
Purpose:
    Carry out a complex division (element-by-element) of 2 complex
    variables.
 
Description:
    In DATAPLOT, all variables are stored as real.  Thus all complex
    variables can be referred to by the analyst as the pair of real
    variables-- the real and imaginary parts.  Hence the pair Y1,Y2 of
    real variables may be thought of by the analyst as the single
    complex variable Y1 + i*Y2 where i is the usual imaginary unit =
    sqrt(-1).
 
    Complex division is define by the following equation:
        (a+bi)/(c+di) = (ac+bd)/(c**2+d**2) + (bc-ad)/(c**2+d**2)*i
 
Syntax:
    LET <v5> <v6> = COMPLEX ADDITION <v1> <v2> <v3> <v4>
                        <SUBSET/EXCEPT/FOR qualification>
    where <v1> and <v2> are the real and imaginary components of the
               first input variable;
          <v3> and <v4> are the real and imaginary components of the
               second input variable;
          <v5> and <v6> are the real and imaginary components of the
               output variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional (and
               rarely used in this context).
 
Examples:
    LET Y5 Y6   = COMPLEX DIVISION Y1 Y2 Y3 Y4
    LET Y3R Y3I = COMPLEX DIVISION Y1R Y1I Y2R Y2I
    LET E F   = COMPLEX DIVISION A B C D SUBSET A > 10
    LET E F   = COMPLEX DIVISION A B C D FOR I = 1 1 20
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COMPLEX ADDITION (LET)    = Carries out a complex addition.
    COMPLEX SUBTRACTION (LET) = Carries out a complex subtraction.
    COMPLEX MULT  (LET)       = Carries out a complex multiplication.
    COMPLEX EXPON  (LET)      = Carries out a complex exponentiation.
    COMPLEX SQUARE ROOT (LET) = Carries out a complex square root.
    COMPLEX CONJUGATE (LET)   = Carries out a complex conjugate.
    COMPLEX ROOTS (LET)       = Computes the complex roots.
 
    POLYNOMIAL DIVISION (LET) = Carries out a polynomial division.
    FOURIER TRANSFORM (LET)   = Computes the Fourier Transform.
    INVERSE FOURIER TRAN (LET)= Computes the Inverse Fourier Transform.
    FFT (LET)                 = Computes the Fast Fourier Transform.
    INVERSE FFT (LET)         = Computes the Inverse FFT.
 
    PLOT                      = Plots data or functions.
 
Applications:
    Mathematics, Time Series Deconvolution
 
Implementation Date:
    87/10
 
Program:
    READ X1 Y1 X2 Y2
    1 2 3 4
    3 5 2 1
    2 2 4 3
    END OF DATA
    LET X3 Y3 = COMPLEX DIVISION X1 Y1 X2 Y2
    WRITE X1 Y1 X2 Y2 X3 Y3
 
-----COMPLEX DEMODULATION PLOT---------------------------------------
 
COMPLEX DEMODULATION PLOT
 
Name:
    COMPLEX DEMODULATION ... PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a complex demodulation plot.
 
Description:
    A complex demodulation plot is a graphical data analysis technique
    for determining if the amplitude or generating frequency changes
    over the course of a single-frequency time series.  Complex
    demodulation attempts to model a time series with the following
    equation:
        Y(t) = A(t)*sin(W0*t + phi(t))
    In this equation, A is the amplitude, phi is the phase shift, and
    W0 is the complex demodulation frequency.  Note that A and phi
    vary with time while the complex demodulation frequency is
    constant.  Since A and phi are allowed to vary, complex
    demodulation is sometimes referred to as local harmonic analysis.
    The goal of complex demodulation is to estimate approximations for
    the A(t) and phi(t).  The mathematical derivations for finding
    these estimates can be found in the books listed in the REFERENCE
    section (DATAPLOT uses the Granger and Hatanaka derivation).
 
    A complex demodulation plot consists of:
       Vertical axis   = estimated local amplitude or estimated local
                         phase;
       Horizontal axis = dummy index 1 to n where n is the  number of
                         observations.
    The following 2 types of complex demodulation plots are available:
          1) complex demodulation amplitude plot
          2) complex demodulation phase     plot
 
Syntax 1:
    COMPLEX DEMODULATION AMPLITUDE PLOT <y>
               <SUBSET/EXCEPT/FOR qualification>
    where <y> is a variable that contains the time series observations
              to be analyzed;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    COMPLEX DEMODULATION PHASE PLOT <y>
               <SUBSET/EXCEPT/FOR qualification>
    where <y> is a variable that contains the time series observations
              to be analyzed;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    COMPLEX DEMODULATION AMPLITUDE PLOT Y
    COMPLEX DEMODULATION PHASE PLOT Y
 
Note:
    Complex demodulation plots are frequently drawn with no connected
    lines and with some type of character set.  For example,
       LINES BLANK
       CHARACTER X
 
Note:
    The DEMODULATION FREQUENCY command is required before entering the
    COMPLEX DEMODULATION PLOT command.  The demodulation frequency is
    the W0 parameter.  A spectral plot is typically generated to get an
    initial estimate for the demodulation frequency.
 
Note:
    Complex demodulation frequency is typically done iteratively.  The
    phase plots are generated until an acceptable value is found for
    W0 (the plot should have a zero slope with no evident patterns).
    At this point, an amplitude plot is generated to obtain an estimate
    of A(t) or a decision is made that W0 is not constant (and thus
    complex demodulation is not appropriate).
 
Note:
    The complex demodulation plot can be used to generate a non-linear
    fit of the single cycle model.  For example:
        DEMODULATION FREQUENCY FREQ
        LET N = SIZE Y
        LET T = SEQUENCE 1 1 N
        LET CONST = MEAN Y
        COMPLEX DEMODULATION PHASE PLOT Y
        LET PHASE = YPLOT
        COMPLEX DEMODULATION AMPLITUDE PLOT Y
        LET AMP = YPLOT
        FIT Y = CONST + AMP*(SIN2*3.14159*FREQ*T + PHASE)
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DEMOD  FREQUENCY = Sets the demodulation frequency for a complex
                       demodulation plot.
    DEMODF           = A parameter where the updated demodulation
                       frequency is stored.
 
    SPECTRUM         = Generates a spectral plot.
    PERIODOGRAM      = Generates a periodogram.
    CORRELATION PLOT = Generates a correlation plot.
    LAG PLOT         = Generates a lag plot.
    PLOT             = Generates a data or function plot.
    4-PLOT           = Generates a 4-plot for univariate analysis.
 
    CHARACTERS       = Sets the types for plot characters.
    LINES            = Sets the types for plot lines.
    SPIKES           = Sets the on/off switches for plot spikes.
 
    SUMMARY          = Generates a table of summary statistics.
    LET              = Generates sine or cosine transformations (and
                       much more).
    FIT              = Carries out a least squares fit.
 
Applications:
    Frequency based time series analysis
 
Implementation Date:
    XX
 
Reference:
    "Spectral Analysis in Economic Time Series", Granger and Hatanaka,
    Princeton University Press, 1964.
 
    "Fourier Analysis of Time Series: An Introduction", Peter
    Bloomfield, John Wiley and Sons, 1976 (Chapter 6).
 
Program:
    SKIP 25
    READ LEW.DAT Y
    .
    TITLE AUTOMATIC
    MULTIPLOT 2 2; MULTIPLOT CORNER COORDINATES 0 0 100 100
    PLOT Y
    SPECTRUM Y
    DEMODULATION FREQUENCY .3
    COMPLEX DEMODULATION AMPLITUDE PLOT Y
    COMPLEX DEMODULATION PHASE PLOT Y
    END OF MULTIPLOT
 
-----COMPLEX EXPONENTIATION (LET)--------------------------------
 
COMPLEX EXPONENTATION
 
Name:
    COMPLEX EXPONENTIATION (LET)
 
Type:
    Subcommand under LET
 
Purpose:
    Carry out a complex exponentiation (element-by-element) of a
    complex variable.
 
Description:
    In DATAPLOT, all variables are stored as real.  Thus all complex
    variables can be referred to by the analyst as the pair of real
    variables-- the real and imaginary parts.  Hence the pair Y1,Y2 of
    real variables may be thought of by the analyst as the single
    complex variable Y1 + i*Y2 where i is the usual imaginary unit =
    sqrt(-1).
 
    Complex exponentiation is defined by the following equation:
        e**(a+bi) = (cos(b)e**a) + (sin(b)e**a)*i
 
Syntax:
    LET <v3> <v4> = COMPLEX EXPONENTIATION <v1> <v2>
                        <SUBSET/EXCEPT/FOR qualification>
    where <v1> and <v2> are the real and imaginary components of the
               first input variable;
          <v3> and <v4> are the real and imaginary components of the
               output variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional (and
               rarely used in this context).
 
Examples:
    LET Y3 Y4   = COMPLEX EXPONENTIATION Y1 Y2
    LET Y2R Y2I = COMPLEX EXPONENTIATION Y1R Y1I
    LET Y3 Y4   = COMPLEX EXPONENT Y1 Y2 SUBSET Y1 > 8
    LET Y3 Y4   = COMPLEX EXPONENT Y1 Y2 FOR I = 1 1 5
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COMPLEX ADDITION (LET)    = Carries out a complex addition.
    COMPLEX SUBTRACTION (LET) = Carries out a complex subtraction.
    COMPLEX MULT  (LET)       = Carries out a complex multiplication.
    COMPLEX DIVISION (LET)    = Carries out a complex division.
    COMPLEX SQUARE ROOT (LET) = Carries out a complex square root.
    COMPLEX CONJUGATE (LET)   = Carries out a complex conjugate.
    COMPLEX ROOTS (LET)       = Computes the complex roots.
 
    POLYNOMIAL SQUARE (LET)   = Carries out a polynomial squaring.
    FOURIER TRANSFORM (LET)   = Computes the Fourier Transform.
    INVERSE FOURIER TRAN (LET)= Computes the Inverse Fourier Transform.
    FFT (LET)                 = Computes the Fast Fourier Transform.
    INVERSE FFT (LET)         = Computes the Inverse FFT.
 
    PLOT                      = Plots data or functions.
 
Applications:
    Mathematics
 
Implementation Date:
    87/10
 
Program:
    READ X1 Y1
    1 2
    3 5
    2 2
    END OF DATA
    LET X2 Y2 = COMPLEX EXPONENTIATION X1 Y1
    WRITE X1 Y1 X2 Y2
 
-----COMPLEX MULTIPLICATION (LET)--------------------------------
 
COMPLEX MULTIPLICATION
 
Name:
    COMPLEX MULTIPLICATION (LET)
 
Type:
    Subcommand under LET
 
Purpose:
    Carry out a complex multiplication (element-by-element) of 2
    complex variables.
 
Description:
    In DATAPLOT, all variables are stored as real.  Thus all complex
    variables can be referred to by the analyst as the pair of real
    variables-- the real and imaginary parts.  Hence the pair Y1,Y2 of
    real variables may be thought of by the analyst as the single
    complex variable Y1 + i*Y2 where i is the usual imaginary unit =
    sqrt(-1).
 
    Complex multiplication is defined by the following equation:
        (a+bi)(c+di) = (ac-bd) + (ad+bc)i
 
Syntax:
    LET <v5> <v6> = COMPLEX MULTIPLICATION <v1> <v2> <v3> <v4>
                        <SUBSET/EXCEPT/FOR qualification>
    where <v1> and <v2> are the real and imaginary components of the
               first input variable;
          <v3> and <v4> are the real and imaginary components of the
               second input variable;
          <v5> and <v6> are the real and imaginary components of the
               output variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional (and
               rarely used in this context).
 
Examples:
    LET Y5 Y6   = COMPLEX MULTIPLICATION Y1 Y2 Y3 Y4
    LET Y3R Y3I = COMPLEX MULTIPLICATION Y1R Y1I Y2R Y2I
    LET E F   = COMPLEX MULTIPLICATION A B C D SUBSET A > 8
    LET E F   = COMPLEX MULTIPLI. A B C D FOR I = 1 1 3
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COMPLEX ADDITION (LET)    = Carries out a complex addition.
    COMPLEX SUBTRACTION (LET) = Carries out a complex subtraction.
    COMPLEX DIVISION (LET)    = Carries out a complex division.
    COMPLEX EXPON  (LET)      = Carries out a complex exponentiation.
    COMPLEX SQUARE ROOT (LET) = Carries out a complex square root.
    COMPLEX CONJUGATE (LET)   = Carries out a complex conjugate.
    COMPLEX ROOTS (LET)       = Computes the complex roots.
 
    POLYNOMIAL MULT  (LET)    = Carries out a polynomial
                                 multiplication.
    VECTOR DOT PRODUCT (LET)  = Computes the vector dot product.
    SET CARTESIAN PROD  (LET) = Carries out a set cartesian product.
    LOGICAL AND (LET)         = Carries out a logical and.
    MATRIX MULT  (LET)        = Carries out a matrix multiplication.
    FOURIER TRANSFORM (LET)   = Computes the Fourier Transform.
    INVERSE FOURIER TRAN (LET)= Computes the Inverse Fourier Transform.
    FFT (LET)                 = Computes the Fast Fourier Transform.
    INVERSE FFT (LET)         = Computes the Inverse FFT.
 
    PLOT                      = Plots data or functions.
 
Applications:
    Mathematics
 
Implementation Date:
    87/10
 
Program:
    READ X1 Y1 X2 Y2
    1 2 3 4
    3 5 2 1
    2 2 4 3
    END OF DATA
    LET X3 Y3 = COMPLEX MULTIPLICATION X1 Y1 X2 Y2
    SET WRITE DECIMALS 0
    WRITE X1 Y1 X2 Y2 X3 Y3
 
-----COMPLEX ROOTS (LET)-----------------------------------------
 
COMPLEX ROOTS
 
Name:
    COMPLEX ROOTS (LET)
 
Type:
    Subcommand under LET
 
Purpose:
    Compute complex roots of a polynomial with complex (or real)
    coefficients.
 
Description:
    In DATAPLOT, all variables are stored as real.  Thus all complex
    variables can be referred to by the analyst as the pair of real
    variables-- the real and imaginary parts.  Hence the pair Y1,Y2 of
    real variables may be thought of by the analyst as the single
    complex variable Y1 + i*Y2 where i is the usual imaginary unit =
    sqrt(-1).
 
    DATAPLOT uses the Laguerre method as documented in the Numerical
    Recipes book (see the REFERENCE below).
 
Syntax 1:
    LET <v3> <v4> = COMPLEX ROOTS <v1> <v2>
                        <SUBSET/EXCEPT/FOR qualification>
    where <v1> and <v2> are the real and imaginary components of
                the ordered polynomial coefficients--
                   element 1 is coefficients of constant term;
                   element 2 is coefficients of linear term;
                   element 3 is coefficients of quadratic term;
                   element 4 is coefficient of cubic term;
                   etc.
          <v3> and <v4> are the real and imaginary components of
                the output roots--
                   element 1 is the first root;
                   element 2 is the second root;
                   element 3 is the third root;
                   element 4 is the fourth root;
                   etc.
          <S/E/F/Q> signifies the usual SUBSET/EXCEPT/FOR
    and where the <SUBSET/EXCEPT/FOR qualification> is optional (and
 
Syntax 2:
    LET <v3> <v4> = COMPLEX ROOTS <v1>
                        <SUBSET/EXCEPT/FOR qualification>
    This is the same as syntax 1 except <v2> is omitted.  This syntax
    allows one to compute the complex roots of a polynomial with real
    coefficients.  In practice, syntax 2 is more common than syntax 1.
 
Examples:
    LET Y3 Y4   = COMPLEX ROOTS Y1 Y2
    LET Y2R Y2I = COMPLEX ROOTS Y1R Y1I
    LET Y3 Y4   = COMPLEX ROOTS Y1 Y2 SUBSET Y1 > 10
    LET Y3 Y4   = COMPLEX ROOTS Y1 Y2 FOR I = 1 1 20
    LET Y3 Y4   = COMPLEX ROOTS Y1
    LET Y2R Y2I = COMPLEX ROOTS Y1R
    LET Y3 Y4   = COMPLEX ROOTS Y1  SUBSET Y1 > 10
    LET Y3 Y4   = COMPLEX ROOTS Y1  FOR I = 1 1 20
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    ROOTS (LET)               = Computes the real roots of a function.
 
    COMPLEX ADDITION (LET)    = Carries out a complex addition.
    COMPLEX SUBTRACTION (LET) = Carries out a complex subtraction.
    COMPLEX MULT  (LET)       = Carries out a complex multiplication.
    COMPLEX DIVISION (LET)    = Carries out a complex division.
    COMPLEX EXPON  (LET)      = Carries out a complex exponentiation.
    COMPLEX SQUARE ROOT (LET) = Carries out a complex square root.
    COMPLEX CONJUGATE (LET)   = Carries out a complex conjugate.
 
    POLYNOMIAL ADDITION (LET) = Carries out a polynomial addition.
    POLYNOMIAL SUBT  (LET)    = Carries out a polynomial subtraction.
    POLYNOMIAL MULT  (LET)    = Carries out a polynomial
                                multiplication.
    POLYNOMIAL DIVISION (LET) = Carries out a polynomial division.
    POLYNOMIAL SQUARE (LET)   = Carries out a polynomial squaring.
    POLYNOMIAL EVAL  (LET)    = Carries out a polynomial evaluation.
 
    MATRIX SOLUTION (LET)     = Computes the matrix solution.
    MATRIX EIGENVALUES (LET)  = Computes the matrix eigenvalues.
    MATRIX SIMPLEX SOLU (LET) = Computes the simplex solution.
 
    FOURIER TRANSFORM (LET)   = Computes the Fourier Transform.
    INVERSE FOURIER TRAN (LET)= Computes the Inverse Fourier Transform.
    FFT (LET)                 = Computes the Fast Fourier Transform.
    INVERSE FFT (LET)         = Computes the Inverse FFT.
 
    PLOT                      = Plots data or functions.
 
Reference:
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", Press, Flannery, Teukolsky, and Vetterling.
 
Applications:
    Mathematics, Digital Filter Design
 
Implementation Date:
    87/10
 
Program:
DIMENSION 20 VARIABLES
    . PLOT ROOTS FOR: K + X + X**2 (FOR K = 1 1 10)
    LET P = DATA 1 1 1
    LET X2 = DATA -999 -999
    LET Y2 = DATA -999 -999
    LET D2 = DATA -999 -999
    LOOP FOR K = 1 1 10
       LET P(1) = K
       LET X Y = COMPLEX ROOTS P
       LET D = K FOR I = 1 1 2
       APPEND X X2
       APPEND Y Y2
       APPEND D D2
    END OF LOOP
    CHAR 1 2 3 4 5 6 7 8 9 0
    LINES BLANK ALL
    X1LABEL REAL COMPONENT
    Y1LABEL COMPLEX COMPONENT
    PLOT Y2 X2 D2 EXCEPT D2 = -999
    X1LABEL VALUE FOR K
    XTIC OFFSET 0.5 0.5
    PLOT Y2 D2 D2 EXCEPT D2 = -999
 
-----COMPLEX SQUARE ROOT (LET)-----------------------------------
 
COMPLEX SQUARE ROOT
 
Name:
    COMPLEX SQUARE ROOT (LET)
 
Type:
    Subcommand under LET
 
Purpose:
    Carry out a complex square root (element-by-element) of a complex
    variable.
 
Description:
    In DATAPLOT, all variables are stored as real.  Thus all complex
    variables can be referred to by the analyst as the pair of real
    variables-- the real and imaginary parts.  Hence the pair Y1,Y2 of
    real variables may be thought of by the analyst as the single
    complex variable Y1 + i*Y2 where i is the usual imaginary unit =
    sqrt(-1).
 
    DATAPLOT uses the Fortran intrinsic CSQRT to calculate the complex
    square root.
 
Syntax:
    LET <v3> <v4> = COMPLEX SQUARE ROOT <v1> <v2>
                        <SUBSET/EXCEPT/FOR qualification>
    where <v1> and <v2> are the real and imaginary components of the
               first input variable;
          <v3> and <v4> are the real and imaginary components of the
               output variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional (and
               rarely used in this context).
 
Examples:
    LET Y3 Y4   = COMPLEX SQUARE ROOT Y1 Y2
    LET Y2R Y2I = COMPLEX SQUARE ROOT Y1R Y1I
    LET Y3 Y4   = COMPLEX SQUARE ROOT Y1 Y2 SUBSET Y1 > 10
    LET Y3 Y4   = COMPLEX SQUARE ROOT Y1 Y2 FOR I = 1 1 20
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COMPLEX ADDITION (LET)    = Carries out a complex addition.
    COMPLEX SUBTRACTION (LET) = Carries out a complex subtraction.
    COMPLEX MULT  (LET)       = Carries out a complex multiplication.
    COMPLEX DIVISION (LET)    = Carries out a complex division.
    COMPLEX EXPON  (LET)      = Carries out a complex exponentiation.
    COMPLEX CONJUGATE (LET)   = Carries out a complex conjugate.
    COMPLEX ROOTS (LET)       = Computes the complex roots.
 
    FOURIER TRANSFORM (LET)   = Computes the Fourier Transform.
    INVERSE FOURIER TRAN (LET)= Computes the Inverse Fourier Transform.
    FFT (LET)                 = Computes the Fast Fourier Transform.
    INVERSE FFT (LET)         = Computes the Inverse FFT.
 
    PLOT                      = Plots data or functions.
 
Applications:
    Mathematics
 
Implementation Date:
    87/10
 
Program:
    READ X1 Y1
    1 2
    3 5
    2 2
    END OF DATA
    LET X2 Y2 = COMPLEX SQUARE ROOT X1 Y1
    WRITE X1 Y1 X2 Y2
 
-----COMPLEX SUBTRACTION (LET)-----------------------------------
 
COMPLEX SUBTRACTION
 
Name:
    COMPLEX SUBTRACTION (LET)
 
Type:
    Subcommand under LET
 
Purpose:
    Carry out a complex subtraction (element-by-element) of 2 complex
    variables.
 
Description:
    In DATAPLOT, all variables are stored as real.  Thus all complex
    variables can be referred to by the analyst as the pair of real
    variables-- the real and imaginary parts.  Hence the pair Y1,Y2 of
    real variables may be thought of by the analyst as the single
    complex variable Y1 + i*Y2 where i is the usual imaginary unit =
    sqrt(-1).
 
    Complex subtraction is defined by the following equation:
        (a+bi) - (c+di) = (a-c) + (b-d)*i
 
Syntax:
    LET <v5> <v6> = COMPLEX SUBTRACTION <v1> <v2> <v3> <v4>
                        <SUBSET/EXCEPT/FOR qualification>
    where <v1> and <v2> are the real and imaginary components of the
               first input variable;
          <v3> and <v4> are the real and imaginary components of the
               second input variable;
          <v5> and <v6> are the real and imaginary components of the
               output variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional (and
               rarely used in this context).
 
Examples:
    LET Y5 Y6   = COMPLEX SUBTRACTION Y1 Y2 Y3 Y4
    LET Y3R Y3I = COMPLEX SUBTRACTION Y1R Y1I Y2R Y2I
    LET E F   = COMPLEX SUBTRACTION A B C D SUBSET A > 10
    LET E F   = COMPLEX SUBTRACTION A B C D FOR I = 1 1 20
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COMPLEX ADDITION (LET)    = Carries out a complex addition.
    COMPLEX MULT  (LET)       = Carries out a complex multiplication.
    COMPLEX DIVISION (LET)    = Carries out a complex division.
    COMPLEX EXPON  (LET)      = Carries out a complex exponentiation.
    COMPLEX SQUARE ROOT (LET) = Carries out a complex square root.
    COMPLEX CONJUGATE (LET)   = Carries out a complex conjugate.
    COMPLEX ROOTS (LET)       = Computes the complex roots.
 
    POLYNOMIAL SUBT  (LET)    = Carries out a polynomial subtraction.
    VECTOR SUBT  (LET)        = Carries out a vector subtraction.
    SET INTERSECTION (LET)    = Carries out a set intersection.
    LOGICAL OR (LET)          = Carries out a logical or.
    MATRIX SUBTRACTION (LET)  = Carries out a matrix subtraction.
    FOURIER TRANSFORM (LET)   = Computes the Fourier Transform.
    INVERSE FOURIER TRAN (LET)= Computes the Inverse Fourier Transform.
    FFT (LET)                 = Computes the Fast Fourier Transform.
    INVERSE FFT (LET)         = Computes the Inverse FFT.
 
    PLOT                      = Plots data or functions.
 
Applications:
    Mathematics
 
Implementation Date:
    87/10
 
Program:
    READ X1 Y1 X2 Y2
    1 2 3 4
    3 5 2 1
    2 2 4 3
    END OF DATA
    LET X3 Y3 = COMPLEX SUBTRACTION X1 Y1 X2 Y2
    SET WRITE DECIMALS 0
    WRITE X1 Y1 X2 Y2 X3 Y3
 
-----CONCDF (LET)--------------------------------
 
CONCDF
 
Name:
    CONCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Consul probability mass function.
 
Description:
    The Consul distribution has the following probability
    mass function:

       p(x;theta,m)=(m*x  x-1)*theta**(x-1)*(1-theta)**(m*x-x+1)/x
                     x = 1, 2, 3, ,...
                     0 < theta < 1; 1 <= m < 1/theta

    with theta and m denoting the shape parameters.
 
    The Consul distribution is sometimes parameterized in terms
    of its mean, mu, instead of theta.  This results in the
    following probability mass function:

        p(x;mu,m)=(m*x  x-1)*((mu-1)/(m*mu))**(x-1)*
                  (1 - (m-1)/(m*mu))**(m*x-x+1)/x
                  x = 1, 2, 3, ,...
                  mu >= 1; m > 1

    Theta can be expressed in terms of mu:

        theta = (mu-1)/(m*mu)
        
    Dataplot supports both parameterizations (see the Note
    section below).

    Dataplot computes the cumulative distribution function
    using the following recurrence relation given on page 320
    of Consul and Famoye:

       p(x;theta,m) = {(m-1)*(x-1)+1}/(x-1)}*
                      theta*(1-theta)**(m-1)*
                      PROD[i=1 to x-2][(1 + m/(m*x-m-i)]*
                      p(x-1;theta,m)

    where 

       P(1) = (1-theta)**m

    If the mu parameterization is used, it is converted to
    the theta parameterization and the above recurrence relation
    is applied.

Syntax:
    LET <y> = CONCDF(<x>,<shape>,<m>) 
               <SUBSET/EXCEPT/FOR qualification>
    where <x> is a positive integer variable, number, or parameter;
          <shape> is a number, parameter, or variable that specifies
               the valuie of theta (or mu);
          <m> is a number, parameter, or variable that specifies
               the second shape parameter;
          <y> is a variable or a parameter (depending on what <x>
               is) where the computed Consul pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CONCDF(3,0.5,1.4)
    LET Y = CONCDF(X,0.3,1.6)
    PLOT CONCDF(X,0.3,1.6) FOR X = 1  1  20

Note:
    To use the MU parameterization, enter the command

       SET CONSUL DEFINITION MU

    To restore the THETA parameterization, enter the command

       SET CONSUL DEFINITION THETA

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CONPDF                   = Compute the Consul probability mass
                               function.
    CONPPF                   = Compute the Consul percent point
                               function.
    GEOPDF                   = Compute the geometric probability mass
                               function.
    GETPDF                   = Compute the Geeta probability mass
                               function.
    GLSPDF                   = Compute the generalized logarithmic
                               series probability mass function.
    DLGPDF                   = Compute the logarithmic series
                               probability mass function.
    YULPDF                   = Compute the Yule probability
                               mass function.
    ZETPDF                   = Compute the Zeta probability
                               mass function.
    BGEPDF                   = Compute the beta geometric
                               probability mass function.
    POIPDF                   = Compute the Poisson probability
                               mass function.
    BINPDF                   = Compute the binomial probability
                               mass function.
 
Reference:
    Consul and Famoye (2006), "Lagrangian Probability
    Distribution", Birkhauser, chapter 8.

    Famoye (1997), "Generalized Geometric and Some of its
    Applications", Journal of Mathematical Sciences, 8,
    pp. 1-13.

    Consul (1990), "New Class of Location-Parameter Discrete
    Probability Distributions and Their Chaacterizations",
    Communications in Statistics--Theory and Methods, 19,
    pp. 4653-4666.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/8
 
Program:
    set consul definition theta
    title size 3
    tic label size 3
    label size 3
    legend size 3
    height 3
    x1label displacement 12
    y1label displacement 15
    .
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    label case asis
    title case asis
    case asis
    tic offset units screen
    tic offset 3 3
    title displacement 2
    y1label Probability
    x1label X
    .
    ylimits 0 1
    major ytic mark number 6
    minor ytic mark number 3
    xlimits 0 20
    line blank
    spike on
    .
    multiplot 2 2
    .
    title Theta = 0.3, M = 1.8
    plot concdf(x,0.3,1.8) for x = 1 1 20
    .
    title Theta = 0.5, M = 1.5
    plot concdf(x,0.5,1.5) for x = 1 1 20
    .
    title Theta = 0.7, M = 1.2
    plot concdf(x,0.7,1.2) for x = 1 1 20
    .
    title Theta = 0.9, M = 1.1
    plot concdf(x,0.9,1.1) for x = 1 1 20
    .
    end of multiplot
    .
    justification center
    move 50 97
    text Cumulative Distribution Functions for Consul

-----CONOVER SCORES (LET)---------------------------------------
 
CONOVER SCORES
 
Name:
    CONOVER SCORES (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the Conover scores of a variable.
 
Description:
    The Conover scores for a response variable and a group-id variable
    are defined as follows

        s(j) = (R(U(j)))**2

    where

        U(j) =  ABS(Y(j)(i) - YBAR(i))
        
    with Y(j)(i) denoting the j-th observation belonging to the i-th group
    and YBAR(i) denoting the mean of the i-th group.

    Conover scores are the squared ranks of the absolute deviations from
    the sample group means.  They are used in the SQUARED RANKS command
    to compare the variances of k samples.

Syntax:
    LET <s> = CONOVER SCORES <y> <x>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <x> is the group-id variable;
          <s> is a variable where the computed Conover scores are
             saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    The response variable and the group-id variable must have the same
    number of observations.
 
Examples:
    LET CSCORE = CONOVER SCORE Y X
 
Note:
    Ties are assigned an average rank.  For example, if the 2nd and 3rd
    highest values are equal, each is assigned a rank of 2.5.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SQUARED RANKS TEST      = Perform a squared ranks test.
    SIEGEL TUKEY TEST       = Perform a Siegel-Tukey test.
    ANOVA                   = Perform a fixed effects analysis of variance.
    KLOTZ SCORES            = Generate Klotz scores.
    MOOD SCORES             = Generate Mood scores.
    VAN DER WAERDEN SCORES  = Generate Van Der Waerden scores.
    MEDIAN SCORES           = Generate median scores.
    SAVAGE SCORES           = Generate Savage scores.
    PLACEMENT SCORES        = Generate placement scores.
    RANK                    = Generate the ranks of a variable. 
 
Reference:
    Conover (1999), "Practical Nonparametric Statisitcs," Third Edition,
    Wiley, p. 401.

Applications:
    Nonparametric statistics
 
Implementation Date:
    2023/06
 
Program:
    . Step 1:   Define the data
    .
    let y1 = data 16.55 15.36 15.94 16.43 16.01
    let y2 = data 16.05 15.98 16.10 15.88 15.91
    let n1 = size y1
    let n2 = size y2
    let n = n1 + n2
    .
    . Step 2:   Combine into single array
    .
    let y tag = stack y1 y2
    if n1 <= n2
       let tag = tag - 1
       let n1t = n1
    else
       let tag = 0 subset tag = 2
       let n1t = n2
    end of if
    .
    . Step 3:   Compute the Conover scores
    .
    let cscore = conover scores y tag
    .
    . Step 4:   Two-Sample Linear Rank Test
    .
    let temp = tag*cscore
    let s = sum temp
    .
    let aval = sum cscore
    let smean = (n1t/n)*aval
    let meanrank = mean cscore
    let temp = (cscore - meanrank)**2
    let aval = sum temp
    let svar = ((n1*n2)/(n*(n-1)))*aval
    let statval = (s - smean)/sqrt(svar)
    let statval = round(statval,3)
    let cv = norppf(0.975)
    let upplim = round(cv,2)
    let lowlim = -upplim
    feedback off
    print "Two Sample Linear Rank Sum Test Based on Conover Scores"
    print "H0: Variances are Equal"
    print "Ha: Variances are Not Equal"
    print "alpha: 0.05"
    print "Test Statistic: ^statval"
    print "Lower Critical Value: ^lowlim"
    print "Upper Critical Value: ^upplim"
    if statval < cv
       print "Conclusion: Accept H0"
    else
       print "Conclusion: Reject H0"
    end of if
 
-----CONPDF (LET)--------------------------------
 
CONPDF
 
Name:
    CONPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Consul probability mass function.
 
Description:
    The Consul distribution has the following probability
    mass function:

       p(x;theta,m)=(m*x  x-1)*theta**(x-1)*(1-theta)**(m*x-x+1)/x
                     x = 1, 2, 3, ,...
                     0 < theta < 1; 1 <= m < 1/theta

    with theta and m denoting the shape parameters.
 
    The mean and variance of the Consul distribution are:

        mu       = 1/(1 - theta*m)
        sigma**2 = m*theta*(1 - theta)/(1 - theta*m)**3

    The Consul distribution is sometimes parameterized in terms
    of its mean, mu, instead of theta.  This results in the
    following probability mass function:

        p(x;mu,m)=(m*x  x-1)*((mu-1)/(m*mu))**(x-1)*
                  (1 - (m-1)/(m*mu))**(m*x-x+1)/x
                  x = 1, 2, 3, ,...
                  mu >= 1; m > 1

    Theta can be expressed in terms of mu:

        theta = (mu-1)/(m*mu)
        
    The mean and variance become:

        mean     = mu
        sigma**2 = mu*(mu-1)*(m*mu-mu+1)/m

    Dataplot supports both parameterizations (see the Note
    section below).

    The Consul distribution reduces to the geometric distribution
    when m = 1 and is also referred to as the generalized geometric
    distribution.

Syntax:
    LET <y> = CONPDF(<x>,<shape>,<m>) 
               <SUBSET/EXCEPT/FOR qualification>
    where <x> is a positive integer variable, number, or parameter;
          <shape> is a number, parameter, or variable that specifies
               the valuie of theta (or mu);
          <m> is a number, parameter, or variable that specifies
               the second shape parameter;
          <y> is a variable or a parameter (depending on what <x>
               is) where the computed Consul pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CONPDF(3,0.5,1.4)
    LET Y = CONPDF(X,0.3,1.6)
    PLOT CONPDF(X,0.3,1.6) FOR X = 1  1  20

Note:
    For a number of commands utilizing the Consul distribution,
    it is convenient to bin the data.  There are two basic ways
    of binning the data.

      1) For some commands (histograms, maximum likelihood
         estimation), bins with equal size widths are
         required.  This can be accomplished with the
         following commands:

            LET AMIN = MINIMUM Y
            LET AMAX = MAXIMUM Y
            LET AMIN2 = AMIN - 0.5
            LET AMAX2 = AMAX + 0.5
            CLASS MINIMUM AMIN2
            CLASS MAXIMUM AMAX2
            CLASS WIDTH 1
            LET Y2 X2 = BINNED

      2) For some commands, unequal width bins may be
         helpful.  In particular, for the chi-square goodness
         of fit, it is typically recommended that the minimum
         class frequency be at least 5.  In this case, it may
         be helpful to combine small frequencies in the tails.
         Unequal class width bins can be created with the
         commands

            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = INTEGER FREQUENCY TABLE Y

         If you already have equal width bins data, you can
         use the commands
         
            LET MINSIZE = <value>
            LET Y3 XLOW XHIGH = COMBINE FREQUENCY TABLE Y2 X2

         The MINSIZE parameter defines the minimum class
         frequency.  The default value is 5.

Note:
    To use the MU parameterization, enter the command

       SET CONSUL DEFINITION MU

    To restore the THETA parameterization, enter the command

       SET CONSUL DEFINITION THETA

Note:
    You can generate Consul random numbers, probability plots,
    and chi-square goodness of fit tests with the following
    commands:

       LET N = VALUE
       LET THETA = <value>  (or LET MU = <value>)
       LET M = <value>
       LET Y = CONSUL RANDOM NUMBERS FOR I = 1 1 N

       CONSUL PROBABILITY PLOT Y
       CONSUL PROBABILITY PLOT Y2 X2
       CONSUL PROBABILITY PLOT Y3 XLOW XHIGH

       CONSUL CHI-SQUARE GOODNESS OF FIT Y
       CONSUL CHI-SQUARE GOODNESS OF FIT Y2 X2
       CONSUL CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH

    To obtain the method of moment estimates, the mean and
    ones frequency estimates, and the maximum likelihood
    estimates of mu and beta, enter the command

        CONSUL MAXIMUM LIKELIHOOD Y
        CONSUL MAXIMUM LIKELIHOOD Y2 X2

    The moment estimates of mu and m are:

        muhat = xbar
        mhat  = xbar*(xbar - 1)**2/[xbar**2*(xbar-1)-s**2}

    Note that if the moment estimate of m is less than 1,
    then the moment estimates do not exist.

    The mean and ones frequency estimate of mu is:

        muhat = xbar

    The estimate of m is then the solution of the equation

        m*LOG(1 - (xbar-1)/(m*xbar)) - LOG(n1/n) = 0

    The maximum likelihood frequency estimate of mu is:

        muhat = xbar

    The estimate of m is then the solution of the equation

        LOG(1 - (xbar-1)/(m*xbar)) + (1/(n*xbar))*
        SUM[x=2 to k][SUM[i=0 to x-2][x*n(x)/(m*x-i)]] = 0

    You can generate estimates of theta (or mu) and m based
    on the maximum ppcc value or the minimum chi-square goodness
    of fit with the commands

        LET THETA1 = <value>
        LET THETA2 = <value>

    or
        LET MU1    = <value>
        LET MU2    = <value>

        LET M1     = <value>
        LET M2     = <value>
        CONSUL KS PLOT Y
        CONSUL KS PLOT Y2 X2
        CONSUL KS PLOT Y3 XLOW XHIGH
        CONSUL PPCC PLOT Y
        CONSUL PPCC PLOT Y2 X2
        CONSUL PPCC PLOT Y3 XLOW XHIGH

    The default values of theta1 and theta2 are 0.05 and 0.95,
    respectively.  The default values for mu1 and mu2 are 1 and 5,
    respectively.  The default values for m1 and m2 are
    1.05 and 5, respectively.  Note that when the theta
    parameterization is used, values of m that do
    not lie in the interval 1 <= m <= 1/theta are skipped.
    Due to the discrete nature of the percent point function
    for discrete distributions, the ppcc plot will not be smooth.
    For that reason, if there is sufficient sample size the
    KS PLOT (i.e., the minimum chi-square value) is typically
    preferred.  However, it may sometimes be useful to perform
    one iteration of the PPCC PLOT to obtain a rough idea of an
    appropriate neighborhood for the shape parameters since the
    minimum chi-square statistic can generate extremely large
    values for non-optimal values of the shape parameters.
    Also, since the data is integer values, one of the binned
    forms is preferred for these commands.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CONCDF                   = Compute the Consul cumulative
                               distribution function.
    CONPPF                   = Compute the Consul percent point
                               function.
    GEOPDF                   = Compute the geometric probability mass
                               function.
    GETPDF                   = Compute the Geeta probability mass
                               function.
    GLSPDF                   = Compute the generalized logarithmic
                               series probability mass function.
    DLGPDF                   = Compute the logarithmic series
                               probability mass function.
    YULPDF                   = Compute the Yule probability
                               mass function.
    ZETPDF                   = Compute the Zeta probability
                               mass function.
    BGEPDF                   = Compute the beta geometric
                               probability mass function.
    POIPDF                   = Compute the Poisson probability
                               mass function.
    BINPDF                   = Compute the binomial probability
                               mass function.
    INTEGER FREQUENCY TABLE  = Generate a frequency table at
                               integer values with unequal bins.
    COMBINE FREQUENCY TABLE  = Convert an equal width frequency
                               table to an unequal width frequency
                               table.
    KS PLOT                  = Generate a minimum chi-square plot.
    PPCC PLOT                = Generate a ppcc plot.
    PROBABILITY PLOT         = Generate a probability plot.
    MAXIMUM LIKELIHOOD       = Perform maximum likelihood
                               estimation for a distribution.
 
Reference:
    Consul and Famoye (2006), "Lagrangian Probability
    Distribution", Birkhauser, chapter 8.

    Famoye (1997), "Generalized Geometric and Some of its
    Applications", Journal of Mathematical Sciences, 8,
    pp. 1-13.

    Consul (1990), "New Class of Location-Parameter Discrete
    Probability Distributions and Their Chaacterizations",
    Communications in Statistics--Theory and Methods, 19,
    pp. 4653-4666.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/8
 
Program 1:
    set consul definition theta
    title size 3
    tic label size 3
    label size 3
    legend size 3
    height 3
    x1label displacement 12
    y1label displacement 15
    .
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    label case asis
    title case asis
    case asis
    tic offset units screen
    tic offset 3 3
    title displacement 2
    y1label Probability Mass
    x1label X
    .
    ylimits 0 1
    major ytic mark number 6
    minor ytic mark number 3
    xlimits 0 20
    line blank
    spike on
    .
    multiplot 2 2
    .
    title Theta = 0.3, M = 1.8
    plot conpdf(x,0.3,1.8) for x = 1 1 20
    .
    title Theta = 0.5, M = 1.5
    plot conpdf(x,0.5,1.5) for x = 1 1 20
    .
    title Theta = 0.7, M = 1.2
    plot conpdf(x,0.7,1.2) for x = 1 1 20
    .
    title Theta = 0.9, M = 1.1
    plot conpdf(x,0.9,1.1) for x = 1 1 20
    .
    end of multiplot
    .
    justification center
    move 50 97
    text Probability Mass Functions for Consul Distribution

Program 2:
    SET CONSUL DEFINITION MU
    LET MU   = 4.2
    LET M = 2.2
    LET Y = CONSUL RANDOM NUMBERS FOR I = 1 1 500
    .
    LET Y3 XLOW XHIGH = INTEGER FREQUENCY TABLE Y
    CLASS LOWER 0.5
    CLASS WIDTH 1
    LET AMAX = MAXIMUM Y
    LET AMAX2 = AMAX + 0.5
    CLASS UPPER AMAX2
    LET Y2 X2 = BINNED Y
    .
    CONSUL MLE Y
    RELATIVE HISTOGRAM Y2 X2
    LIMITS FREEZE
    PRE-ERASE OFF
    LINE COLOR BLUE
    PLOT CONPDF(X,MUML,MML) FOR X = 1  1  AMAX
    LIMITS
    PRE-ERASE ON
    LINE COLOR BLACK
    LET MU    = MUML
    LET M  = MML
    CONSUL CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH
    CASE ASIS
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Mu = ^MUML, M = ^MML
    MOVE 50 93
    TEXT Minimum Chi-Square = ^STATVAL, 95% CV = ^CUTUPP95
    .
    LABEL CASE ASIS
    X1LABEL Mu
    Y1LABEL Minimum Chi-Square
    CONSUL KS PLOT Y3 XLOW XHIGH
    LET MU = SHAPE1
    LET M  = SHAPE2
    CONSUL CHI-SQUARE GOODNESS OF FIT Y3 XLOW XHIGH
    JUSTIFICATION CENTER
    MOVE 50 97
    TEXT Mu = ^MU, M = ^M
    MOVE 50 93
    TEXT Minimum Chi-Square = ^MINKS, 95% CV = ^CUTUPP95

-----CONPPF (LET)--------------------------------
 
CONPPF
 
Name:
    CONPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the Consul probability mass function.
 
Description:
    The Consul distribution has the following probability
    mass function:

       p(x;theta,m)=(m*x  x-1)*theta**(x-1)*(1-theta)**(m*x-x+1)/x
                     x = 1, 2, 3, ,...
                     0 < theta < 1; 1 <= m < 1/theta

    with theta and m denoting the shape parameters.
 
    The Consul distribution is sometimes parameterized in terms
    of its mean, mu, instead of theta.  This results in the
    following probability mass function:

        p(x;mu,m)=(m*x  x-1)*((mu-1)/(m*mu))**(x-1)*
                  (1 - (m-1)/(m*mu))**(m*x-x+1)/x
                  x = 1, 2, 3, ,...
                  mu >= 1; m > 1

    Theta can be expressed in terms of mu:

        theta = (mu-1)/(m*mu)
        
    Dataplot supports both parameterizations (see the Note
    section below).

    Dataplot computes the cumulative distribution function
    using the following recurrence relation given on page 320
    of Consul and Famoye:

       p(x;theta,m) = {(m-1)*(x-1)+1}/(x-1)}*
                      theta*(1-theta)**(m-1)*
                      PROD[i=1 to x-2][(1 + m/(m*x-m-i)]*
                      p(x-1;theta,m)

    where 

       P(1) = (1-theta)**m

    If the mu parameterization is used, it is converted to
    the theta parameterization and the above recurrence relation
    is applied.

    The Consul percent point function is computed by summing
    the cumulative distribution function until the specified
    probability is obtained.

Syntax:
    LET <y> = CONPPF(<p>,<shape>,<m>) 
               <SUBSET/EXCEPT/FOR qualification>
    where <p> is a positive integer variable, number, or parameter
               in the interval (0,1);
          <shape> is a number, parameter, or variable that specifies
               the valuie of theta (or mu);
          <m> is a number, parameter, or variable that specifies
               the second shape parameter;
          <y> is a variable or a parameter (depending on what <x>
               is) where the computed Consul pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CONPPF(0.95,0.5,1.4)
    LET Y = CONPPF(P,0.3,1.6)
    PLOT CONPPF(P,0.3,1.6) FOR P = 0  0.01  0.99

Note:
    To use the MU parameterization, enter the command

       SET CONSUL DEFINITION MU

    To restore the THETA parameterization, enter the command

       SET CONSUL DEFINITION THETA

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CONCDF                   = Compute the Consul cumulative
                               distribution function.
    CONPDF                   = Compute the Consul probability mass
                               function.
    GEOPDF                   = Compute the geometric probability mass
                               function.
    GETPDF                   = Compute the Geeta probability mass
                               function.
    GLSPDF                   = Compute the generalized logarithmic
                               series probability mass function.
    DLGPDF                   = Compute the logarithmic series
                               probability mass function.
    YULPDF                   = Compute the Yule probability
                               mass function.
    ZETPDF                   = Compute the Zeta probability
                               mass function.
    BGEPDF                   = Compute the beta geometric
                               probability mass function.
    POIPDF                   = Compute the Poisson probability
                               mass function.
    BINPDF                   = Compute the binomial probability
                               mass function.
 
Reference:
    Consul and Famoye (2006), "Lagrangian Probability
    Distribution", Birkhauser, chapter 8.

    Famoye (1997), "Generalized Geometric and Some of its
    Applications", Journal of Mathematical Sciences, 8,
    pp. 1-13.

    Consul (1990), "New Class of Location-Parameter Discrete
    Probability Distributions and Their Chaacterizations",
    Communications in Statistics--Theory and Methods, 19,
    pp. 4653-4666.

Applications:
    Distributional Modeling
 
Implementation Date:
    2006/8
 
Program:
    set geeta definition theta
    title size 3
    tic label size 3
    label size 3
    legend size 3
    height 3
    x1label displacement 12
    y1label displacement 15
    .
    multiplot corner coordinates 0 0 100 95
    multiplot scale factor 2
    label case asis
    title case asis
    case asis
    tic offset units screen
    tic offset 3 3
    title displacement 2
    x1label Probability
    y1label X
    .
    xlimits 0 1
    major xtic mark number 6
    minor xtic mark number 3
    .
    multiplot 2 2
    .
    title Theta = 0.3, M = 1.8
    plot conppf(p,0.3,1.8) for p = 0  0.01  0.99
    .
    title Theta = 0.5, M = 1.5
    plot conppf(p,0.5,1.5) for p = 0  0.01  0.99
    .
    title Theta = 0.7, M = 1.2
    plot conppf(p,0.7,1.2) for p = 0  0.01  0.99
    .
    title Theta = 0.9, M = 1.1
    plot conppf(p,0.9,1.1) for p = 0  0.01  0.99
    .
    end of multiplot
    .
    justification center
    move 50 97
    text Consul Percent Point Functions

-----CONSENSUS MEANS --------------------------------------------

CONSENSUS MEAN
 
Name:
    CONSENSUS MEAN
 
Type:
    Analysis Command
 
Purpose:
    Compute an estimate of a consensus mean, and the associated
    uncertainty, based on the data from multiple laboratories
    or multiple methods.
 
Overview:
    The problem of determining a consensus mean based on data
    from two or more laboratories (or from two or more methods
    from the same laboratory) is a common one for measurement
    laboratories.  A few specific applications of consensus means
    are Standard Reference Materials (SRM's), interlaboratory
    studies, and key comparisons.

    There are a number of approaches to this problem.  The
    Dataplot CONSENSUS MEANS command computes estimates for a
    variety of methods and does not specify which is the most
    appropriate method for a given data set.  Consult with a
    statistician for guidance on which method is most appropriate
    for your data.

Grand Mean Model:
    The simplest model is to assume that there is no lab effect
    (i.e., we treat the data as if it all came from the same
    lab).

    In this case, the consensus mean is simply the grand mean
    of all the data and a confidence interval for the consensus
    mean is simply the standard t-based condidence interval:

       xbar +/- tppf(1-alpha/2,n-1)*s/sqrt(n)

    where xbar is the overall mean, tppf is the percent point
    function for the t distribution, s is the standard deviation
    of all the points, and n is the total number of points.

    The assumption of no lab effect is unrealistic in almost
    all cases.  However, we include the grand mean method as
    a reference point as it gives an indication of how including
    the lab effects changes the estimate of the consensus mean
    and its uncertainty.

Mean of Means Model:
    The mean of means model was originally recommended by
    Churchill Eisenhart and was one of the earliest methods
    used for SRM's.

    For this method, we compute the mean for each of the k
    laboratories.  Then we compute xbar and s as the mean and
    standard deviation of these k means.  The estimate of the
    consensus mean is simply xbar and we compute the following
    confidence interval for the consensus mean.

        xbar +/- tppf(1-alpha/2,k-1)*s/sqrt(k)

    The limitations of this method are discussed in the
    "An ISO GUM Approach to Combining Results from Multiple
    Methods" paper (see the Reference section).

    For this method, the consensus mean estimate is an
    equi-weighted mean with no regard to possible differences
    in within-lab variation or within-lab sample sizes.
    The advantages of this method are that it is robust and
    simple to compute.  The primary disadvantage is that
    no consideration is given to possible differences in
    the within-lab variation and sample sizes.

    If the laboratory means are not normally distributed (e.g., due
    to the presence of outliers), this can distort the mean of
    means estimates.  Two more robust procudures are available.

    The median of means estimate takes the median of the
    laboratory means.  The associated uncertainty is

         u(med(x)) = SQRT(PI/(2*k))*MADe

    with k denoting the number of laboratories and MADe denoting
    the scaled median absolute deviation (the scaled median absolute
    deviation is the median absolute deviation divided by 0.67449) of
    the laboratory means.  It is recommended that at least five
    laboratories be available for this uncertainty to be reliable.

    The Huber mean of means is based on the Huber's H15 robust mean
    of the laboratory means.  The associated uncertainty is

         u(uhat(h15)) = SQRT(1/e)*sigmahat(h15)

    with sigmahat(h15) denoting the H15 estimate of scale.  The e
    parameter is a tuning constant that is set to 0.95.  The details
    of the H15 location and scale estimators are given elsewhere (see
    the Related Commands section).

    These robust estimators are discussed in the CCQM Guidance Note
    (see References below).

    These robust estimators are more commonly used in the context of
    interlaboratory studies rather than for certifying reference
    materials.  For certified reference materials, laboratories and
    methods are carefully chosen so outliers are less often a problem.
    Interlaboratory studies typically involve a greater range of
    laboratories with a wider range of capabilities and outliers are
    more likely to be an issue.

Common Mean Model:
    Assume there are k laboratories, each measuring the unknown
    underlying (nonrandom) value mu common to all laboratories.
    The measurements x(ij), i = 1, ..., k; j = 1, ..., n(i), are
    of the form

       x(ij) = mu + e(ij)

    with independent Gaussian errors e(ij) ~ N(0,kappa(i)**2).
    All parameters mu, kappa(i)**2 (i = 1, ...., k) are unknown
    and the goal is to estimate mu, determine its standard error,
    and to provide a confidence interval for mu.

    Unbiased estimates of the within lab means and variances
    sigma(i)**2 = kappa(i)**2/n(i) are:

        x(i) = xbar(i) = SUM[j=1 to n(i)][x(ij)]/n(i)

        s(i)^2 = SUM[j=1 to n(i)][(x(ij) - x(i))^2]/(n(i)*(n(i)-1))

    When the variaces sigma(i)**2 are known, the best, in terms
    of mean squared error, unbiased estimator of the reference
    value mu is the weighted means statistics

       xtilde = SUM[i=1 to k][(w(i)x(i))/SUM(w(i))]

    with w(i) = 1/sigma(i)^2.  The formula for the variance is

       Var(xtile) = E(xtilde - mu)^2 = 1/SUM[i=1 to k][w(i)^2]

    In practice, these within lab variances are unknown and so the
    true w(i) are also unknown.

    The Graybill-Deal method is based on this model.

    In the Graybill-Deal model, the estimate of the consensus
    mean is

       xtilde = SUM[i=1 to k][x(i)*(1/s(i)**2)]/
                SUM[i=1 to k][(1/s(i)**2)]

    Dataplot supports four methods for computing the variance
    of the Graybill-Deal consensus mean.

    1) The naive estimate of the variance is obtained by
       replacing the sigma(i)^2 with the sample estimates s(i)**2

          Var[xtilede] = 1/SUM[i=1 to k][1/s(i)**2]

       Although this variance is easy to compute and widely
       used, it is known to underestimate the true variance
       (and rather badly for small sample sizes).

    2) Sinha proposed the variance estimator

          Var[xtilde] = 1/SUM[i=1 to k][1/s(i)**2]*
             [1 + 4*SUM[i=1 to k][what(i)*(1-what(i))/(n(i)-1)]

       with

          what(i) = (1/s(i)**2)/(SUM[j=1 to k][1/s(j)**2]

       Zhang performed some simulations that indicate that
       while this estimate of the variance reduces the bias,
       it still underestimates it.

    3) To reduce the bias further, Zhang proposed the following
       estimate for the variance

          Var[xtilde] = 1/SUM[i=1 to k]
                         [1/{((n(i)-3)/(n(i)-1))*s(i)**2}]

    4) Zhang proposed the following additional estimate for
       the variance

          Var[xtilde] = 1/SUM[i=1 to k]
             [1/{((n(i)-3)/(n(i)-1))*s(i)**2}]*
             [1 + 2*SUM[i=1 to k][what(i)*(1-what(i)/(n(i)-1)]

       where

           what(i) = ((n(i)-3)/(n(i)-1))*(1/s(i)**2)/
                     SUM[i=1 to k][((n(i)-3)/(n(i)-1))*(1/s(i)**2)]

    Dataplot currently generates confidence intervals for
    the Graybill-Deal method using a method proposed by
    Rukhin (private communication).  This method is conservative.

    The Graybill-Deal approach has the following limitations

        1) It does not take into account between lab effects.
           If the between lab variance is in fact significant,
           the Graybill-Deal may not provide an adequate
           approach.

        2) Labs with small variances may recieve unjustifiably
           large weights and therefore dominate the estimate
           of the consensus mean.

One Way Random Effects Model
    In order to account for between lab variance, we can define
    a one-way random effects ANOVA model which may be both
    unbalanced and heteroscedastic:

        x(ij) = u + b(i) + e(ij)

    where there are i = 1, ..., k labs and j = 1,  .... n(i)
    observations for each lab.  In this model, u is the
    consensus mean, b(i) is the lab effect and e(ij) is the
    error term.  The b(i) are distributed as N(0,sigma**2) and
    e(ij) are distributed as N(0,sigma(i)**2).  That is,
    sigma(i)**2 are the within lab variances and sigma**2
    is the between lab variance.

    For convenience, define the following terms:

        x(i)      = mean for lab i
        s(i)**2   = variance for lab i
        tau(i)**2 = sigma(i)**2/n(i) (this was s(i)**2 in the
                    common means model)
        v(i)      = n(i) - 1
        gamma(i)  = sigma**2/(sigma**2 + tau(i)**2)
        t(i)**2   = s(i)**2/n(i)  (= variance of the mean)

    The Mandel-Paule, modified Mandel-Paule, maximum likelihood
    (ML), DerSimonian-Laird, and generalized confidence interval
    methods are based on this model.  We will discuss each of these
    in turn.

    1) Mandel-Paule/Modified Mandel-Paule

       The Mandel-Paule estimate of the consensus mean is
       defined as

           xtilde = SUM[i=1 to k][w(i)*x(i)]/SUM[i=1 to k][w(i)]

       with w(i) denoting the weight function

           w(i) = 1/(y + t(i)**2)

       where y is an estimate of the between lab variance and
       t(i)**2 = s(i)**2/n(i).  s(i)**2 is the variance of the
       ith lab and n(i) is the number of observations for the
       ith lab.

       The between lab variance is estimated by iteratively
       solving the following equation:

          SUM[i=1 to k][(x(i)-xtilde)**2/(y + t(i)**2)] = k - 1

       The modified Mandel-Paule procedure uses k on the right
       hand side instead of (k-1).  

       The confidence interval for the consensus mean is
       computed as (equation 19 in the Rukhin and Vangel paper).

           xtilde +/- norppf(alpha/2)*NUM/DEN

       where

           NUM = SQRT(SUM[i=1 to k][(x(i)-xtilde)**2/(y + t(i)**2)])
           DEN = SUM[i=1 to k][1/(y + t(i)**2)]

       The Mandel-Paule estimates can be considered an approximation
       to maximum likelihood estimates, but they are computationally
       simpler.  The Mandel-Paule methods are a reasonable choice
       when the number of labs is greater than or equal to six.  For
       a smaller number of labs, the uncertainty intervals are
       generally too small.

       Dataplot uses code provided by Mark Vangel to compute the
       Mandel-Paule estimates.

    2) Rukhin-Vangel Maximum Likelihood

       The Rukhin and Vangel paper shows that the Mandel-Paule
       method can be viewed as an approximation of a maximum
       likelihood (ML) solution.

       The Rukhin-Vangel paper gives the likelihood function.
       Then the ML estimate for the consensus mean is solved
       from the equation

           xtilde = SUM[i=1 to k][gamma(i)*x(i)]/
                    SUM[i=1 to k][gamma(i)]

       The ML estimate of the between lab variance sigma**2 is
       solved from the equation

           sigma**2 = SUM[i=1 to k][gamma(i)*((x(i)-xtilde)**2 +
                      v(i)*t(i)**2/(1-gamma(i))]/(N+k)

       where the summation is from 1 to k.

       Rukhin and Vangel give a ML estimate of gamma(i).  This
       estimate is fairly complex and not repeated here.  This
       ML estimate of gamma(i) is solved numerically using an
       iterative algorithm.  The Mandel-Paule estimates are
       used as starting values for the consensus mean and
       between lab variance.

       The confidence interval for the ML estimate has the
       same form as the Mandel-Paule confidence interval.
       However, the t(i)**2 are replaced with tau(i) in the
       formula and the ML estimate of the between lab variance
       is used.

       The mathematical details of the ML procedure are given
       in the Rukhin-Vangel paper.  They also show why the
       Mandel-Paule estimates provide a good aproximation to
       the ML estimates.

       This is the recommended method of choice when the number
       of labs is large (>= 6).  As with Mandel-Paule, the
       uncertainty intervals tend to be too small when the number
       of labs is small (<= 5).

       Dataplot uses code provided by Mark Vangel to compute the
       maximum likelihood estimates.

    3) DerSimonian-Laird

       The DerSimonian-Laird procedure is as follows:

       a) Compute the Graybill-Deal estimate as an initial
          estimate of the consensus mean (see the above
          description for Graybill-Deal).

       b) Determine a non-negative estimate of the between
          lab variance from

             YDL = MAX[0,TERM1/(TERM2 - TERM3/TERM2)]

          where

             TERM1      = SUM[i=1 to k][(1/s(i)**2)*
                          (x(i) - xtilde(GD))**2 - p + 1]
             TERM2      = SUM[i=1 to k][1/s(i)**2]
             TERM3      = SUM[i=1 to k][1/s(i)**4]
             xtilde(GD) = Graybill-Deal estimate of the consensus
                          mean

        c) Estimate the Dersimonian-Laird weights and use them
           to compute the Dersimonian-Laird consensus mean

              w(i)       = (1/(YDL + s(i)**2))

              xtilde(DL) =  w(i)*x(i)/SUM[i=1 to k][w(i)]

        d) Compute the variance of the Dersimonian-Laird
           consensus mean estimate

              Var(xtilde(DL)) = SUM[i=1 to k][w(i)**2*
                                (x(i) - xtilde(DL))**2/(1 - w(i))]

           The corresponding confidence interval is

              xtilde(DSL) +/- SQRT(Var(xtilde(DSL)))*t(1-alpha/2,k-1)

           The variance can also be estimated with several other methods.
           The Horn-Horn-Duncan (HHD) and minmax variance methods are described
           in the paper

               Andrew Rukhin (2009), "Weighted Means Statistics in
               Interlaboratory Studies", Metrologia, Vol. 46, pp. 323-331.

           The HHD method in particular is recommended by Ruhkin.  It is
           conservative and should maintain the nominal coverage even when
           the sample sizes and variances for the labs vary widely.

           In addition, the variance can be estimated using a parameteric
           bootstrap.  The parametric bootstrap method used in Dataplot
           was developed by Antonio Possolo of the NIST Statistical
           Engineering Division.

           Note that 95% confidence intervals for the bootstrap method
           can be derived in 3 different ways.

                1) The 2.5 and 97.5 percentiles of the bootstrap samples
                   can be used.  Note that this interval is not symmetric.
                   This is referred to as the percentile method.

                2) The percentile method can be adjusted to create an
                   interval that is symmetric about the estimated consensus
                   mean.  Compute the distance between the consensus mean
                   and the 2.5 percentile of the bootstrap samples and also
                   the distance between the consensus mean and the 97.5
                   percentile of the bootstrap samples.  The larger of
                   these two distances is used to determine a symmetric
                   confidence interval.

                3) Compute a kernel density curve from the bootstrap
                   samples.  Determine the 2.5 percentile and 97.5
                   percentile points of this kernel density curve.
                   Similar to the percentile method, the symmetric
                   confidence interval will be determined.

    4) Iyer and Wang Generalized Confidence Intervals

       Iyer, Wang, and Matthew have applied the generalized
       confidence interval approach of Weerhandi to the problem
       of finding confidence limits for the consensus mean.

       The description of this method is rather involved and
       not given here.  See the Wang, Iyer, and Matthews article
       listed in the Reference section below.  Dataplot uses
       code provided by Jack Wang to compute the confidence
       intervals for this approach.

       The primary advantage of this method is that it can be
       applied to cases where there are a small number of labs.
       It is also more robust than the Mandel-Paule and
       maximum likelihood when the normality assumptions are
       violated.

Some Additional Methods
    1) BOB (Type B on Bias)

       This method is discussed in detail in the "An ISO GUM
       Approach to Combing Results from Multiple Methods"
       paper (see the Reference section).

       This method is only applied if there are between two
       and five methods.  It is based on the type B model of
       bias (which is where the name BOB comes from).

       BOB is based on the model

          gamma = mu + beta

       where gamma is the unknown value of the measurand,
       mu is the equally weighted mean of the population means
       of the methods, and beta is the possible bias of the mu
       as an estimate of gamma.  Both mu and beta require 
       estimates and uncertainites of the estimates.  The
       estimate of  mu is the sample mean of the set of method
       (or lab) results.

       We assume the best estimate of beta is 0, but there is
       uncertainty in this estimate.  A probability distribution
       is placed on the value of beta that best summarizes the
       available information.  A common choice is to use a
       uniform distribution (the ISO GUM paper provides the
       rationale for this choice), and that is the distributional
       model Dataplot uses.  That is, we assume a uniform
       distribution centered at zero with upper and lower
       bounds of +a and -a.  For this uniform distribution,
       the standard uncertainty is a/SQRT(3).  The choice
       for a is the difference between the minimum and
       maximum lab (or method) mean divided by 2.  This
       yields (xmax-xmin)/sqrt(12) as the uncertainty for the
       bias term.

       Dataplot combines these to get the following
       uncertainty factor:

         KU = 2*SQRT(SW**2 + SB**2)

       SW is the within lab variability

            SW**2 = SUM [s(i)**2/nlab**2] 

       where the summation is for 1 to nlab and s(i) is
       the standard deviation of the ith lab mean.

       SB is the between lab standard deviation

            SB = (xbar(max) - xbar(min)**2/12

       The ISO GUM paper discusses some variations of this
       basic technique.  For example, Dataplot uses a factor
       of 2 for the uncertainty interval.  This can be replaced
       with a t-value where the degrees of freedom are computed
       using the Welch-Saitterwaite approximation.

       The BOB method is intended for the case when the number of
       labs is small (<= 5).

       The BOB method was adapted from a Dataplot macro
       provided by Stefan Leigh of the NIST Statistical
       Engineering Division.

    2) Schiller-Eberhardt

       A number of variants of this method have been used.
       Dataplot implements the method as discussed in the
       Schiller-Eberhardt paper (see the Reference section
       below).

       The Schiller-Eberhardt estimate of the consensus mean is:

           xtilde = SUM[i=1 to k][omega(i)*x(i)]

       where x(i) is the mean of the ith lab and omega(i)
       is the weighting function

           omega(i) = w(i)/SUM[i=1 to k][w(i)]
           w(i) = (1/(s(i)**2 + sigma(b)**2)

       Here, sigma(b) is the between lab variance and s(i)**2
       is the variance of the i-th lab.  The Schiller-Eberhardt
       method uses the between lab variance computed by the
       Mandel-Paule method.

       The uncertainty interval for Schiller-Eberhardt is
       defined as

           U = t(1-alpha/2,df)*SQRT(s(xtilde)**2 + sigmah**2) +
                       bias allowance

       where s(xtilde)**2 is the variance of the consensus mean,
       sigmah**2 is the material variability variance, and
       bias allowance is defined as

            Bias allowance = MAX|x(i) - xtilde|
                              i

       The variance of the consensus mean is computed as

           x(xtilde)**2 = SUM[i=1 to k][omega(i)**2*s(i)**2]

       where

           omega(i) = w(i)/SUM[i=1 to k][w(i)]
           w(i) = 1/(s(i)**2

       Note that the weight function for s(xtilde)**2 omits the
       between lab variance term that is included in the weight
       function for the consensus mean.

       The variance of the material variability is discussed in
       the Schiller-eberhardt paper.  This is normally computed
       independently of the data given to the CONSENSUS MEAN
       command.  To specify a value for sigmah, enter the 
       following commands before entering the CONSENSUS MEAN
       command.
 
          LET SIGMAH = <value>
          LET DFH = <value>

       SIGMAH contains the value of the variance and DFH contains
       the corresponding degrees of freedom for the materials
       variance.

       The degrees of freedom for the t percent point function
       in the uncertainty is computed as

          df(effective) = (NUM**2)/(DEN**2)

       where

          NUM = SUM[i=1 to k][omega(i)**2s(i)**2 + sigmah**2]
          DEN = SUM[i=1 to k][(omega(i)**2*s(i)**2)**2/(n(i)-1) +
                     sigmah**4/df(sigmah)]

       This method is discussed in detail in the Schiller-Eberhardt
       paper (see the Reference section).

       This method has been superseeded by the BOB method.  As
       with BOB, the Schiller-Eberhardt method is intended for a
       small number of labs (<= 5).

    3) Fairweather

       This implements the method described in

           Fairweather (1972), "A Method for Obtaining an Exact
           Confidence Interval for the Common Mean of Several Normal
           Populations", Applied Statistics, Vol. 21, pp. 229-233.

       Additional information is given in

           Cox (2002), "The Evaluation of Key Comparison Data",
           Metrologia, Vol. 39, pp. 589-595.

       The Dataplot code for the Fairweather procedure was adapted from
       a Matlab script provided by Andrew Ruhkin.

    4) Bayesian Consensus Procedure

       This implements the method described in

           Hagwood and Guthrie (2006), "Combining Data in Small
           Multiple-Methods Studies", Technometrics, Vol. 48, No. 2.

       This method is an alternative to BOB for the case where there
       are a small number of labs (typically 5 or less).

    5) Linear Pool

       Stone introducd the linear pool model to aggregate the opinions
       of multiple experts to produce a consensus.  Duewer recommended
       this model in the analysis of key comparisons.  Koepke,
       Lafarge, Possolo and Toman also  discuss this method.  The
       Koepke paper was used as the basis for the Dataplot implementation
       of this method.

       Given k labs, the method is as follows

           i) Assign weights to the labs.  These weights should
              be positive and they will be normalized to sum to 1.
              If weights are not assigned, each lab will be
              assigned equal weight.  This is where the expert
              opionion comes in (i.e., labs that are viewed as
              "better" are assigned greater weight).
 
          ii) Randomly select one of the labs based on the
              assigned weights (i.e., labs with greater weight
              will have a higher probability of being selected).

         iii) If the sample size of the lab is given as zero or one,
              then generate a normal random number with the location
              parameter set to the lab mean and the scale parameter
              set to the lab standard uncertainty.

          iv) If the sample size of the lab is greater than one,
              then generate a random number from a t distribution
              with degrees of freedom equal to the sample size
              minus one, the location parameter set to the lab mean
              and the scale parameter set to the lab standard
              deviation divided by the square root of the sample
              size.

           v) Repeat steps ii - iv a large number of times (by
              default, Dataplot generates 50,000 samples).  Then
              the consensus value is the mean of these 50,000
              generated values and the associated standard
              uncertainty is the standard deviation of this
              sample.  A 95% confidence interval is obtained
              by determining the 2.5 and 97.5 percentiles of the
              sample.

       

Data Analytic Considerations:
    In determining the most appropriate estimate of the consensus
    mean, the following issues need to be addressed.

    1. What is the definition of the consensus mean.  Is this
       a lab independent number which represents an absolute
       physical truth or is this a lab-dependent "average"
       across all participating labs?

    2. How many labs are there?  Some methods are more
       appropriate for a small number of labs while others are
       based on asymptotic results and are thus more appropriate
       for a larger number of labs.

    3. Do between-lab differences (biases) exist?

    4. Are there differences in within-lab variation?

    5. Are there differences in within lab sample sizes?

    6. Does a lab with much data have such only because the
       lab's method is cheaper and thus of potentially poorer
       quality than other labs?

    7. Are all labs treated equally?

    8. Do "star" labs exist?  That is, labs that are known to
       be either super unbiased or super accurate.

    9. If an engineering equal lab tests out to be a statistically
       outlying lab, how (a prioori) is that lab to be
       weighted?

    Answers to the above questions will determine how to
    appropriately weight the labs.  The consensus mean will
    be a weighted mean of the lab means.  The weighting can
    be either fixed (i.e., equal weights) or variable where
    the variable weights can be based on both engineering and
    statistical considerations.

    If the engineering decision is made to treat all labs as
    equal in importance, then from a statistical point of view
    the analysis consists primarily of the following two steps:

    1. estimation of a consensus mean;
    2. estimation of an uncertainty limits for the consensus
       mean.

    An additional third step is to carry out formal statistical
    tests to identify potentially outlying labs.  A statistically
    unsolvable question that persists here is that just because
    a lab appears "different" does not necessarily mean that the
    lab is wrong (i.e., biased).  The spectre that all of the
    consistent labs being self-behaved but biased is a real
    possibility which can only be solved by engineering
    judgement.

Description of the Dataplot Input:
    Dataplot can accept data in either one of the following
    formats:

        1. Raw Data - there should two columns of data.  The
           first column contains the respone values and the
           second column contains the corresponding lab-id.
           The data do not need to be sorted by lab-id.

           If your data is the form where each lab is contained
           in a separate column, you can do something like the
           following

                LET Y LABID = STACK Y1 Y2 Y3 Y4 Y5 Y6
                CONSENSUS MEAN Y LABID

           This example will take the data for six labs
           stored in Y1, Y2, Y3, Y4, Y5, and Y6 and save it
           the variables Y and LABID in a format that can be
           used by the CONSENSUS MEAN command.

        2. Summary Data - there should three columns of data.
           The first column contains the sample means for the
           labs, the second column contains the sample
           standard deviations for the labs, and the third
           column contains the sample sizes for the labs.

Description of the Dataplot Output:
    Dataplot generates the following four sections of output for
    the consensus means analysis.

       1. The first section prints summary information about the
          data.  Specifically, it prints the overall mean, the
          number of observations, and the number of labs.  It also
          prints a table giving the sample size, mean, variance,
          standard deviation, and standard deviation of the mean
          for each lab.  It then prints the pooled within lab
          variance (and standard deviation).  The pooled within lab
          variance is computed as: as

             VARw = SUM[i=1 to k][(n(i)-1)*s(i)]/
                    SUM[i=1 to k][n(i)-1]

          where s(i) is the variance of the ith lab.

       2. The second section prints the detailed output for each
          method.

       3. The third section prints a summary table containing
          the 95% confidence limits for each method.

       4. The fourth section prints summary tables containing
          the uncertainty and the percent relative uncertainty.
          Separate tables are printed for standard uncertainty
          (k = 1) and expanded uncertainty (k = 2).

Syntax 1:
    CONSENSUS MEANS  <y>  <tag>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <tag> is a lab id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax computes the consensus means based on the raw data.

Syntax 2:
    CONSENSUS MEANS  <ymean>  <ysd>  <ni> 
                              <SUBSET/EXCEPT/FOR qualification>
    where <ymean> is a variable containing the means for each lab;
          <ysd> is a variable containing the standard deviations
               for each lab;
          <ni> is a variable containing the sample sizes for each
               lab;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax computes the consensus means based on the mean, standard
    deviation, and sample size for each lab.

Syntax 3:
    CONSENSUS MEANS  <ymean>  <ysd>  <ni>  <labid>
                              <SUBSET/EXCEPT/FOR qualification>
    where <ymean> is a variable containing the means for each lab;
          <ysd> is a variable containing the standard deviations
               for each lab;
          <ni> is a variable containing the sample sizes for each
               lab;
          <labid> is a variable containing the lab-id (numeric values);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax computes the consensus means based on the mean, standard
    deviation, and sample size for each lab.  The <labid> is used for
    identification purposes and is not used in the computations.

Examples:
    CONSENSUS MEANS Y1  GROUP
    CONSENSUS MEANS Y1  GROUP  SUBSET GROUP > 2
    CONSENSUS MEANS YMEAN YSD NI
 
Note:
    Variations of the above methods are commonly used.  For
    that reason, the following internal parameters are
    automatically saved when the CONSENSUS MEAN command is
    entered.  You can use these parameters to compute variations
    of the above methods.

        XGRAND    = the overall mean.
        S2POOL    = the pooled within lab variance.

        YBARSD1   = the standard deviation of the lab means.
        YBARSD2   = the standard deviation of the lab means
                    where the standard deviation is computed as
                    a deviation from the grand mean rather than
                    a deviation from the mean of the lab means.
        T1STDERR  = the standard error for the t method using
                    all the data.
        T2STDERR  = the standard error for the t method using
                    the lab means.

        SEMEAN    = the consensus mean using the
                    Schiller-Eberhardt method.
        SES2      = the variance of the consensus mean using the
                    Schiller-Eberhardt method.
        BIASALLO  = the bias allowance for the
                    Schiller-Eberhardt method.
        SEDF      = the degrees of freedom for the
                    Schiller-Eberhardt method.

        MPMEAN    = the consensus mean using the Mandel-Paule
                    method.
        MPS2      = the between lab variance using the
                    Mandel-Paule method.
        SEMP      = the standard error of the Mandel-Paule
                    method.

        MMPMEAN   = the consensus mean using the modified
                    Mandel-Paule method.
        MMPS2     = the between lab variance using the
                    modified Mandel-Paule method.
        SEMMP     = the standard error of the modified
                    Mandel-Paule method.

        MLMEAN    = the consensus mean using the Rukhin-Vangel
                    maximum likelihood method.
        MLS2      = the between lab variance using the
                    Rukhin-Vangel maximum likelihood method.
        SEML      = the standard error of the Rukhin-Vangel
                    maximum likelihood method.

        BOBMEAN   = the consensus mean for the BOB method.
        BOBS2     = the between lab variance for the BOB method.
        BOBS2W    = the within lab variance for the BOB method.
        BOBKU     = the uncertainty value for the BOB method.

        GDMEAN    = the consensus mean using the Graybill-Deal
                    method.
        GDS2      = the variance of the Graybill-Deal
                    consensus mean.

        GCIMEAN   = the consensus mean using the generalized
                    confidence interval approach.
        GCISE     = the standard error of the generalized confidence
                    interval consensus mean.

        DERSMEAN  = the consensus mean using the DerSimonian-Laird
                    approach.
        DERSVARI  = the variance of the DerSimonian-Laird
                    consensus mean.
        DERSSE    = the standard error of the DerSimonian-Laird
                    consensus mean.
        YDL       = the betweeen lab variance for the DerSimonian-Laird
                    consensus mean.
        DERS95LL  = the lower 95% confidence interval for the
                    DerSimonian-Laird consensus mean based on the
                    original formula for the variance.
        DERS95UL  = the upper 95% confidence interval for the
                    DerSimonian-Laird consensus mean based on the
                    original formula for the variance.
        DHHD95LL  = the lower 95% confidence interval for the
                    DerSimonian-Laird consensus mean based on the
                    Horn-Horn-Duncan formula for the variance.
        DHHD95UL  = the upper 95% confidence interval for the
                    DerSimonian-Laird consensus mean based on the
                    Horn-Horn-Duncan formula for the variance.
        DERSSEHD  = the standard error of the DerSimonian-Laird
                    consensus mean based on the Horn-Horn-Duncan
                    variance.
        DERSSERU  = the standard error of the DerSimonian-Laird
                    consensus mean based on the minmax variance.
        DERSSEBS  = the standard error of the DerSimonian-Laird
                    consensus mean based on the bootstrap.
        DERSBOK2  = the coverage factor for a 95% confidence interval
                    for the DerSimonian-Laird consensus mean based on the
                    percentiles of the bootstrap.
        DERSBOK2  = the coverage factor for a 95% confidence interval
                    for the DerSimonian-Laird consensus mean based on a
                    kernel density of the bootstrap.

        FAIRMEAN  = the consensus mean using the Fairweather method.
        FAIRSE    = the standard error of the Fairweather consensus mean.

        BCPMEAN   = the consensus mean using the Bayesian consensus
                    procedure method.
        BCPSE     = the standard error of the Bayesian consensus procedure
                    consensus mean.

        MEDOFMEA  = the consensus mean using the median of means method.
        MEDMEASE  = the standard error of the median of means method.

        H15OFMEA  = the consensus mean using the Huber mean (H15) of means
                    method.
        H15MEASE  = the standard error of the Huber mean of means method.
        LINPMEAN  = the consensus mean using the linear pool method.
        LINPSE    = the standard uncertainty of the linear pool
                    consensus mean.
        LINP95LL  = the lower 95% confidence limit for the linear
                    pool consensus mean.
        LINP95UL  = the upper 95% confidence limit for the linear
                    pool consensus mean.

Note:
    To allow additional analysis, a number of results are
    written to external files.

    The following variables are written to the file
    dpst1f.dat.  This is the information contained in
    Table 1 of the CONSENSUS MEAN output.

       1. Lab ID
       2. Number of Observations for Lab
       3. Mean for the Lab
       4. Variance for the Lab
       5. Standard Deviation for the Lab
       6. Standard Deviaiton of Mean of the Lab

    The following variables are written to the file dpst2f.dat.
    This is the information contained in table 2 of the
    CONSENSUS MEAN output.  These variables can be used to generate
    plots of the consensus mean results.

       1. Consensus mean for the method
       2. Lower 95% confidence limit for the method
       3. Upper 95% confidence limit for the method
       4. Method id

    The following variables are written to the file dpst3f.dat.
    This is the information contained in table 3 of the
    CONSENSUS MEAN output.  These variables can be used to generate
    plots of the consensus mean results.

       1. Consensus mean for the method
       2. Standard uncertainty (k=1) for the method
       3. Percentage relative standard uncertainty
       4. Method id

    The following variables are written to the file dpst4f.dat.
    This is the information contained in table 4 of the
    CONSENSUS MEAN output.  These variables can be used to generate
    plots of the consensus mean results.

       1. Consensus mean for the method
       2. Expanded uncertainty (k=1) for the method
       3. Percentage relative standard uncertainty
       4. Method id

    The following variables are written to the file
    dpst5f.dat.

       1. Simulated consensus means from the generalized
          confidence interval approach

Note:
    By default, the 4 tables are generated using an F15.7 format.
    This uses a column width of 15 with 7 digits to the right
    of the decimal point.  You can specify the number of digits
    to the right of the decimal point with the command

        SET WRITE DECIMALS <value>

    If you want to use an exponential format (E15.7), enter

        SET WRITE DECIMALS -7

Note:
    You can optionally generate the CONSENSUS MEANS output in
    HTML, Latex, or Rich Text Format (RTF).  Enter

        HELP CAPTURE HTML
        HELP CAPTURE LATEX

    for details.

Note:
    For the raw data case, if the number of labs is greater than 6
    the Bayesian consensus procedure method is automatically suppressed.

    Although the BOB procedure is not recommened when there are more than
    five laboratories, it is not automatically suppressed in this case.

    The Fairweather method requires that each lab have a minimum of five
    measurements.  If at least one lab has five or fewer measurements,
    then the Fairweather method is automatically suppressed.

Note:
    If you have labs with either a single observation or with a zero
    standard deviation (i.e., all measurements are the same for that lab),
    this can cause problems for some of the methods.

    If this situation is encountered, the following methods can still use
    the data from that lab

       1. grand mean
       2. mean of means
       3. BOB
       4. Bayesian consensus procedure

    For the remaining methods, these labs will be automatically omitted
    from the consensus means analysis.

Note:
    The CONSENSUS MEAN command typically works with the mean, standard
    deviation, and sample size of each lab.  If you have raw data (i.e.,
    response variable and group-id variable), these are automatically
    computed.

    If you have summary data, it may not always be available in this
    form.  Specifically, the following types of summary data are sometimes
    encountered.

       1. You may have a standard uncertainty with an associated degrees
          of freedom.  For example, the uncertainty may incorporate type B
          components.  In some cases, an associated degrees of freedom may
          not be available.

       2. In some cases, the uncertainty may be s/SQRT(n).  In theses
          cases, the value of n may or may not be available.  If it is,
          then you should convert your uncertainty to a standard deviation
          of the data and a sample size before running the CONSENSUS MEAN
          command.  However, in some cases the sample size may not be
          available.

    To address these cases, the summary data may be entered in the
    following ways.

        1. If the sample size is given as a negative value, then
           the absolute value of the sample size will be interpreted
           as the "effective degrees of freedom" and the standard
           deviation column will be interpreted as "s/n".

           If your uncertainty is equivalent to a standard deviation
           (i.e., s rather than s/n), then enter the positive value of
           the effective degrees of freedom in the sample size column.

        2. If the sample size is given as zero, this means that no
           effective degrees of freedom are available.

           Many of the formulas for consensus means contain

                n(i) - c

           terms where c denotes a constant (frequently c = 1).  Methods
           that have terms like this will not be supported.

    Your data may contain a mix of labs where some have the standard
    deviation and sample size and others where a standard uncertainty
    is provided.  This is allowed, but the following methods will be
    suppressed if any of the sample sizes has a non-positive value

          1. Vangel-Ruhkin
          2. generalized confidence intervals
          3. Schiller-Eberhardt
          4. Bayesian consensus procedure
          5. Fairweather
          6. grand mean

Note:
    The CONSENSUS MEANS command is typically used to compute Type A
    components of uncertainty.  In some cases, you may have additional
    type B components of uncertainty.  There are several ways to
    address this.

       1. You can simply add the standard type B error to the sample
          standard deviations.

       2. You can add the type B components to the type A (the
          sample standard deviation) by summing in quadrature to
          obtain a standard uncertainty.  Then enter the sample
          size as zero.  That is, the standard deviation column
          will be interpreted as s(i)/sqrt(n(i).  Although this is
          preferrable to method 1, it will restrict the methods that
          are available.

       3. You can sum in quadrature to obtain the s(i)/SQRT(n(i))
          estimate.  Instead of using zero degrees of freedom, use
          Welch-Satterthwaite to obtain an effective degrees of
          freedom.  Enter the negative of the effective degrees of
          freedom for the sample size column.  This allows all methods
          to be used.  However, in some cases insufficient information
          may be available to determine the effective degrees of
          freedom.

Note:
    In some cases, it may be convenient to extract the value
    of a particular consensus mean statistic.

    If you have raw data, you can enter one of the following

        LET A = DERSIMONIAN LAIRD Y X
        LET A = DERSIMONIAN LAIRD STANDARD ERROR Y X
        LET A = DERSIMONIAN LAIRD HHD Y X
        LET A = DERSIMONIAN LAIRD MINMAX Y X
        LET A = MANDEL PAULE Y X
        LET A = MANDEL PAULE STANDARD ERROR Y X
        LET A = MODIFIED MANDEL PAULE Y X
        LET A = MODIFIED MANDEL PAULE STANDARD ERROR Y X
        LET A = VANGEL RUKHIN Y X
        LET A = VANGEL RUKHIN STANDARD ERROR Y X
        LET A = GENERALIZED CONFIDENCE INTERVAL Y X
        LET A = GENERALIZED CONFIDENCE INTERVAL STANDARD ERROR Y X
        LET A = BOB Y X
        LET A = BOB STANDARD ERROR Y X
        LET A = BCP Y X
        LET A = BCP STANDARD ERROR Y X
        LET A = MEAN OF MEANS Y X
        LET A = MEAN OF MEANS STANDARD ERROR Y X
        LET A = FAIRWEATHER Y X
        LET A = FAIRWEATHER STANDARD ERROR Y X
        LET A = SCHILLER-EBERHARDT Y X
        LET A = SCHILLER-EBERHARDT STANDARD ERROR Y X
        LET A = GRAYBILL DEAL Y X
        LET A = GRAYBILL DEAL SINHA STANDARD ERROR Y X
        LET A = GRAYBILL DEAL NAIVE STANDARD ERROR Y X
        LET A = GRAYBILL DEAL ZHANG ONE STANDARD ERROR Y X
        LET A = GRAYBILL DEAL ZHANG TWO STANDARD ERROR Y X
        LET A = LINEAR POOL Y X
        LET A = LINEAR STANDARD ERROR Y X

    If you have summary data, you can enter one of the following

        LET A = SUMMARY DERSIMONIAN LAIRD MEAN SD N
        LET A = SUMMARY DERSIMONIAN LAIRD STANDARD ERROR MEAN SD N
        LET A = SUMMARY DERSIMONIAN LAIRD HHD MEAN SD N
        LET A = SUMMARY DERSIMONIAN LAIRD MINMAX MEAN SD N
        LET A = SUMMARY MANDEL PAULE MEAN SD N
        LET A = SUMMARY MANDEL PAULE STANDARD ERROR MEAN SD N
        LET A = SUMMARY MODIFIED MANDEL PAULE MEAN SD N
        LET A = SUMMARY MODIFIED MANDEL PAULE STANDARD ERROR MEAN SD N
        LET A = SUMMARY VANGEL RUKHIN MEAN SD N
        LET A = SUMMARY VANGEL RUKHIN STANDARD ERROR MEAN SD N
        LET A = SUMMARY GENERALIZED CONFIDENCE INTERVAL MEAN SD N
        LET A = SUMMARY GENERALIZED CONFIDENCE INTERVAL STANDARD ERROR
                MEAN SD N
        LET A = SUMMARY BOB MEAN SD N
        LET A = SUMMARY BOB STANDARD ERROR MEAN SD N
        LET A = SUMMARY BCP MEAN SD N
        LET A = SUMMARY BCP STANDARD ERROR MEAN SD N
        LET A = SUMMARY MEAN OF MEANS MEAN SD N
        LET A = SUMMARY MEAN OF MEANS STANDARD ERROR MEAN SD N
        LET A = SUMMARY FAIRWEATHER MEAN SD N
        LET A = SUMMARY FAIRWEATHER STANDARD ERROR MEAN SD N
        LET A = SUMMARY SCHILLER-EBERHARDT MEAN SD N
        LET A = SUMMARY SCHILLER-EBERHARDT STANDARD ERROR MEAN SD N
        LET A = SUMMARY GRAYBILL DEAL MEAN SD N
        LET A = SUMMARY GRAYBILL DEAL SINHA STANDARD ERROR MEAN SD N
        LET A = SUMMARY GRAYBILL DEAL NAIVE STANDARD ERROR MEAN SD N
        LET A = SUMMARY GRAYBILL DEAL ZHANG ONE STANDARD ERROR MEAN SD N
        LET A = SUMMARY GRAYBILL DEAL ZHANG TWO STANDARD ERROR MEAN SD N
        LET A = SUMMARY LINEAR POOL YMEAN YSD YN
        LET A = SUMMARY LINEAR STANDARD ERROR YMEAN YSD YN

    Dataplot statistics can be used in a number of other commands.  For
    details, enter

            HELP STATISTICS

    For the SUMMARY cases, bootstrapping is not currently supported.
    However, we anticipate adding this capability in a subsequent
    release.

Note:
    Dataplot supports a large number of methods for determining a
    consensus mean.  In most cases, you will only be interested in a
    few of these.  The following commands can be used to select which
    methods will be used on subsequent CONSENSUS MEANS commands.

        SET MANDEL PAULE <ON/OFF>                     - default is ON
        SET MODIFIED MANDEL PAULE <ON/OFF>            - default is ON
        SET VANGEL RUHKIN <ON/OFF>                    - default is ON
        SET DERSIMONIAN LAIRD <ON/OFF>                - default is ON
        SET DERSIMONIAN LAIRD HHD <ON/OFF>            - default is ON
        SET DERSIMONIAN LAIRD MINMAX <ON/OFF>         - default is OFF
        SET DERSIMONIAN LAIRD BOOTSTRAP <ON/OFF>      - default is OFF
        SET GRAYBILL DEAL <ON/OFF>                    - default is ON
        SET GENERALIZED CONFIDENCE INTERVAL <ON/OFF>  - default is ON
        SET FAIRWEATHER <ON/OFF>                      - default is OFF
        SET MEAN OF MEANS <ON/OFF>                    - default is ON
        SET GRAND MEAN <ON/OFF>                       - default is ON
        SET BOB <ON/OFF>                              - default is ON
        SET SCHILLER EBERHARDT <ON/OFF>               - default is OFF
        SET BAYESIAN CONSENSUS PROCEDURE <ON/OFF>     - default is OFF
        SET MEDIAN OF MEANS <ON/OFF>                  - default is OFF
        SET HUBER MEAN OF MEANS <ON/OFF>              - default is OFF
        SET LINEAR POOL <ON/OFF>                      - default is OFF

    The following commands are available, but are for methods that are
    still under development.  These commands should not currently be used.

        SET VANGEL RUHKIN BOOTSTRAP <ON/OFF>          - default is OFF
        SET MEDIAN OF MEANS <ON/OFF>                  - default is OFF
        SET TRIMMED MEAN OF MEANS <ON/OFF>            - default is OFF

Note:
   The linear pool method supports the following commands

        SET LINEAR POOL WEIGHTS <varname>
        SET LINEAR POOL SAMPLE SIZE <value>

    The WEIGHTS option lets you specify the name of a variable
    that contains the weights for the labs.  By default, equal
    weights are used for all labs.  Setting <varname> to OFF
    (or DEFAULT or NONE) will reset to equal weights.  The
    SAMPLE SIZE option lets you specify the number of samples
    that are drawn.  The default value is 50,000 and this value
    should typically be in the range 10,000 to 100,000.

    The linear pool sampling can sometimes result in a
    multi-modal distribution.  This may indicate that the linear
    pool method is not appropriate.  If the linear pool method
    is turned on, the sample values are written to the
    file dpst5f.dat.  Note that several methods write to this
    file.  Look for the line "VALUES FROM LINEAR POOL METHOD".
    So if this string is on line 101 of dpst5f.dat, you can
    do something like

       SKIP 101
       READ dpst5f.dat YLINPOOL
       SKIP 0
       HISTOGRAM YLINPOOL

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CONSENSUS MEAN PLOT = Generate a consensus mean plot.
    MEAN PLOT           = Generate a mean plot.
    SD PLOT             = Generate a standard deviation plot.
    YOUDEN PLOT         = Generate a Youden plot.
    ANOVA               = Perform an analysis of variance for
                          balanced data.
 
References:
    DerSimonian and Laird (1986), "Meta-analysis in Clinical
    Trials", Controlled Clinical Trials, 7, pp. 177-188.

    Graybill and Deal (1959), "Combining Unbiased Estimators",
    Biometrics, 15, pp. 543-550.

    M. S. Levenson, D. L. Banks, K. R. Eberhardt, L. M. Gill,
    W. F. Guthrie, H. K. Liu, M. G. Vangel, J. H. Yen, and
    N. F. Zhang (2000), "An ISO GUM Approach to Combining Results
    from Multiple Methods", Journal of Research of the National
    Institute of Standards and Technology, Volume 105, Number 4.

    John Mandel and Robert Paule (1970), "Interlaboratory
    Evaluation of a Material with Unequal Number of Replicates",
    Analytical Chemistry, 42, pp. 1194-1197.

    Robert Paule and John Mandel (1982), "Consensus Values and
    Weighting Factors", Journal of Research of the National
    Bureau of Standards, 87, pp. 377-385.

    Andrew Rukhin (2009), "Weighted Means Statistics in Interlaboratory
    Studies", Metrologia, Vol. 46, pp. 323-331.

    Andrew Rukhin (2003), "Two Procedures of Meta-analysis in
    Clinical Trials and Interlaboratory Studies", Tatra Mountains
    Mathematical Publications, 26, pp. 155-168.

    Andrew Rukhin and Mark Vangel (1998), "Estimation of a Common
    Mean and Weighted Means Statistics", Journal of the American 
    Statistical Association, Vol. 93, No. 441.

    Andrew Rukhin, B. Biggerstaff, and Mark Vangel (2000),
    "Restricted Maximum Likelihood Estimation of a Common Mean
    and Mandel-Paule Algorithm", Journal of Statistical Planning
    and Inference, 83, pp. 319-330.

    Mark Vangel and Andrew Rukhin (1999), "Maximum Likelihood
    Analysis for Heteroscedastic One-Way Random Effects ANOVA in
    Interlaboratory Studies", Biometrics 55, 129-136.

    Susannah Schiller and Keith Eberhardt (1991), "Combining Data
    from Independent Analysis Methods", Spectrochimica, ACTA 46 (12).

    Susannah Schiller (1996), "Standard Reference Materials:
    Statistical Aspects of the Certification of Chemical
    SRMs", NIST SP 260-125, NIST, Gaithersburg, MD.

    Bimal Kumar Sinha (1985), "Unbiased Estimation of the Variance
    of the Graybill-Deal Estimator of the Common Mean of Several
    Normal Populations", The Canadian Journal of Statistics,
    Vol. 13, No. 3, pp. 243-247.

    Nien-Fan Zhang (2006), "The Uncertainty Associated with
    The Weighted Mean of Measurement Data", Metrologia, 43,
    pp. 195-204.

    Hagwood and Guthrie (2006), "Combining Data in Small
    Multiple-Methods Studies", Technometrics, Vol. 48, No. 2.

    Iyer, Wang, and Matthew (2004), "Models and Confidence Intervals
    for True Values in Interlaboratory Trials", Journal of the American
    Statistical Association, Volume 99, No. 468, pp. 1060-1071.

    Fairweather (1972), "A Method for Obtaining an Exact Confidence
    Interval for the Common Mean of Several Normal Populations", Applied
    Statistics, Vol. 21, pp. 229-233.

    Cox (2002), "The Evaluation of Key Comparison Data", Metrologia,
    Vol. 39, pp. 589-595.

    "CCQM Guidance note: Estimation of a Consensus KCRV and associated
    Degrees of Equivalence", Version 10, 2013.

    Stone (1961), "The Opinion Pool", Annals of Mathematical
    Statistics, Vol. 32, pp. 1339-1342.

    Duewer (2004), "A Robust Approach for the determination of
    CCQM Key Comparison Reference Values and Uncertinties",
    Technical Report Consultultive Committee for Amount of
    Substance: Metrology in Chemistry (CCQM) International
    Bureau of Weights and Measures (BIPM), Sevres, France
    (9th Annual Meeting, Working Document CCQM/04-15).

    Koepke, Lafarge, Possolo and Toman (2017), "Consensus
    Building for Interlaboratory Studies, Key Comparisons, and
    Meta-Analysis", Metrologia, Vol. 54, S34-S62.

Applications:
    Interlaboratory Studies
 
Implementation Date:
    2000/10
    2002/10: Support for Latex and HTML output
    2006/03: Reformat output for consistency and clarity
             Add Tables 3 and 4 to the output
             Updated the Graybill-Deal method
             Added the DerSimonian-Laird method
             Added the generalized confidence intervals method
             Added support for Rich Text Format (RTF) output
             Added support for SET WRITE DECIMALS
    2006/04: Added the Fairweather method
    2006/06: Added the Bayesian Consensus Procedure method
    2010/06: Five methods can use labs with zero standard deviations
    2011/11: For summary data, add optional lab-id variable
    2014/10: For summary data, option to input mean and uncertainty
             (i.e., s/sqrt(n)) instead of s and n.  Not all methods
             supported for this case.
    2017/03: Added support for median of means and Huber mean of means
             methods.
    2017/07: Changed the default for Schiller-Eberhardt, Fairweather,
             and Bayesian consensus procedure to OFF.
    2023/04: Added support for linear pool method
 
Program 1:
    SKIP 25
    READ STUTZ86.DAT ALITE JUNK2 JUNK3 JUNK4 JUNK5 LABID
    .
    SET WRITE DECIMALS 5
    FEEDBACK OFF
    CONSENSUS MEANS ALITE LABID

Program 2:
    read  mx sx nx
    3.03    0.36       3
    3.27    0.33       3
    3.44    0.40      12
    1.21    0.12       3
    1.44    0.21       3
    1.18    0.30       8
    13.9    0.3        3
    13.6    0.04       3
    15.0    1.9        8
    18.1    0.7        3
    18.4    0.5        3
    19.7    2.0        8
    end of data
    .
    let n   = number mx
    let ind = sequence 1 1 n
    let tag = 1 for i = 1 1 n
    let tag = 2 for i = 4 1 6
    let tag = 3 for i = 7 1 9
    let tag = 4 for i = 10 1 12
    .
    bootstrap samples 100000
    set write decimals 5
    SET DERSIMONIAN LAIRD BOOTSTRAP ON
    SET SCHILLER EBERHARDT OFF
    SET MEAN OF MEANS OFF
    SET GRAND MEAN OFF
    SET GRAYBILL DEAL OFF
    SET GENERALIZED CONFIDENCE INTERVAL OFF
    SET BAYESIAN CONSENSUS PROCEDURE OFF
    SET FAIRWEATHER OFF
    .
    feedback off
    consensus mean mx sx nx subset tag = 1
    consensus mean mx sx nx subset tag = 2
    consensus mean mx sx nx subset tag = 3
    consensus mean mx sx nx subset tag = 4

Program 3:
    . Consensus means analysis for data in Possolo,
    . LaFarge and Koepke paper.  This example shows
    . case where the standard deviation is based on
    . an unknown degrees of freedom
    .
    . Step 1:  Read the data
    .
    read amean asd ni
    6.67248      0.00043       0
    6.6729       0.0005        0
    6.67398      0.00070       0
    6.674255     0.000092      0
    6.67559      0.00027       0
    6.67422      0.00098       0
    6.67387      0.00027       0
    6.67222      0.00087       0
    6.67425      0.00012       0
    6.67349      0.00018       0
    6.67234      0.00014       0
    6.67554      0.00016       0
    6.67191      0.00099       0
    6.67435      0.00013       0
    end of data
    .
    . Step 2:  Set options
    .
    set write decimals -7
    set modified mandel paule off
    set vangel rukhin off
    set vangel rukhin bootstrap off
    set dersimonian laird minmax off
    set dersimonian laird bootstrap off
    set schiller eberhardt off
    set mean of means on
    set grand mean off
    set graybill deal off
    set generalized confidence interval off
    set fairweather off
    set bayesian consensus procedure off
    set bob off
    set linear pool on
    set random number generator fibonacci congruential
    seed 46551
    .
    print "Possolo, LaFarge, Koepke Test Data"
    print " "
    print " "
    consensus mean amean asd ni
    .
    seed 46551
    let consval = summary linear pool                amean asd ni
    seed 46551
    let consunc = summary linear pool standard error amean asd ni
    print consval consunc

-----CONSENSUS MEAN PLOT----------------------------------------------
 
CONSENSUS MEAN PLOT
 
Name:
    CONSENSUS MEAN PLOT
 
Type:
    Graphics Command
 
Purpose:
    Compute an estimate of a consensus mean, and the associated
    uncertainty, based on the data from multiple laboratories
    or multiple methods and present the results in a graphical
    format.
 
Description:
    The problem of determining a consensus mean based on the
    data from two or more laboratories (or from using two or
    more methods from the same laboratory) is a common one at
    NIST and other measurement laboratories.  There are a number
    of approaches to this problem.  The Dataplot CONSENSUS MEANS
    command implements a number of the more commonly used
    approaches.  Note that Dataplot computes estimates for a
    variety of methods and does not specify which is the most
    appropriate method for a given data set.  Consult with a
    statistician for guidance on which method is most appropriate
    for your data.

    The CONSENSUS MEAN PLOT command performs a consensus means analysis
    and in addition to the textual output it presents the results in
    a graphical format.  The details of the consensus means analysis are
    discussed in the documentation for the CONSENSUS MEANS command (enter
    HELP CONSENSUS MEANS for details).

    The graph consists of two parts.

       1. The left hand side of the plot displays the consensus means
          estimates with the associated uncertainty obtained by the
          various methods.  You can specify the desired uncertainty to
          plot by entering one of the following command

              SET CONSENSUS MEAN PLOT ERROR ONE STANDARD ERRORS
              SET CONSENSUS MEAN PLOT ERROR TWO STANDARD ERRORS
              SET CONSENSUS MEAN PLOT ERROR CONFIDENCE INTERVAL

          The default is to use TWO STANDARD ERRORS.  If CONFIDENCE
          INTERVAL is used, then 95% confidence intervals will be
          plotted.

       2. The right hand side of the plot displays the lab means with
          their associated uncertainty.  The SET CONSENSUS MEAN PLOT ERROR
          will also specify the uncertainty to use for the lab data.

    This plot allows you to compare the consensus values and associated
    uncertainties obtained by the different methods.  It also allows you
    to compare the consensus values against the lab data.

    The methods are plotted in the following order:

        1) Mandel-Paule
        2) Modified Mandel-Paule
        3) Vangel-Rukhin
        4) DerSimonian-Laird (original variance)
        5) DerSimonian-Laird (HHD variance)
        6) DerSimonian-Laird (minmax variance)
        7) DerSimonian-Laird (bootstrap variance)
        8) Graybill-Deal
        9) Fairweather (Fairweather variance)
       10) Fairweather (Cox variance)
       11) Fairweather (minmax variance)
       12) Generalized Confidence Intervals
       13) Grand Mean
       14) Mean of Means
       15) Bounds on bias (BOB)
       16) Schiller-Eberhardt
       17) Bayesian Consensus Procedure
       18) Median of Means
       19) Huber Mean of Means

    In most cases, you will probably want only a subset of these methods.
    You can use the following commands to specify which methods to
    include in the consensus means analysis.  This is demonstrated in the
    program samples below.

        SET MANDEL PAULE <ON/OFF>                     - default is ON
        SET MODIFIED MANDEL PAULE <ON/OFF>            - default is ON
        SET VANGEL RUHKIN <ON/OFF>                    - default is ON
        SET DERSIMONIAN LAIRD <ON/OFF>                - default is ON
        SET DERSIMONIAN LAIRD HHD <ON/OFF>            - default is ON
        SET DERSIMONIAN LAIRD MINMAX <ON/OFF>         - default is OFF
        SET DERSIMONIAN LAIRD BOOTSTRAP <ON/OFF>      - default is OFF
        SET GRAYBILL DEAL <ON/OFF>                    - default is ON
        SET GENERALIZED CONFIDENCE INTERVAL <ON/OFF>  - default is ON
        SET FAIRWEATHER <ON/OFF>                      - default is OFF
        SET MEAN OF MEANS <ON/OFF>                    - default is ON
        SET GRAND MEAN <ON/OFF>                       - default is ON
        SET BOB <ON/OFF>                              - default is ON
        SET SCHILLER EBERHARDT <ON/OFF>               - default is OFF
        SET BAYESIAN CONSENSUS PROCEDURE <ON/OFF>     - default is OFF
        SET MEDIAN OF MEANS <ON/OFF>                  - default is OFF
        SET HUBER MEAN OF MEANS <ON/OFF>              - default is OFF

Syntax 1:
    CONSENSUS MEAN PLOT  <y> <tag>  <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <tag> is the group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This is used for the raw data case.

Syntax 2:
    CONSENSUS MEAN PLOT  <ymean> <ysd> <ni>
                         <SUBSET/EXCEPT/FOR qualification>
    where <ymean> is the variable containing the lab means;
          <ysd> is the variable containing the lab standard deviations;
          <ni> is the variable containing the lab sample sizes;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This is used for the summary data case.

Syntax 3:
    CONSENSUS MEAN PLOT  <ymean> <ysd> <ni> <labid>
                         <SUBSET/EXCEPT/FOR qualification>
    where <ymean> is the variable containing the lab means;
          <ysd> is the variable containing the lab standard deviations;
          <ni> is the variable containing the lab sample sizes;
          <labid> is the variable containing the lab-id's (numeric);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This is used for the summary data case.  The <labid> is used in the
    labeling of the textual output.  It is not used in the computation
    of the consensus means or in the plot.

Examples:
    CONSENSUS MEAN PLOT Y X
    CONSENSUS MEAN PLOT Y TAG
    CONSENSUS MEAN PLOT Y TAG SUBSET TAG >= 2
    CONSENSUS MEAN PLOT Y TAG SUBSET TAG = 1 TO 6
    CONSENSUS MEAN PLOT YMEAN YSD NI LABID

Note:
    You can omit the lab data portion of the plot by entering the command

        SET CONSENSUS MEAN PLOT DATA OFF

    To reset the default of showing the lab data on the plot, enter

        SET CONSENSUS MEAN PLOT DATA ON

    This is demonstrated in the Program 2 example below.

Note:
    You can optionally sort the methods by the width of the uncertainty
    interval (from smallest to largest) on the plot by entering the
    command

        SET CONSENSUS MEAN PLOT SORTED ON

    To reset the default of not sorting the methods, enter

        SET CONSENSUS MEAN PLOT SORTED OFF

    This is demonstrated in the Program 3 example below.  The program
    example shows how to read DPST3F.DAT to retrieve the sorted order
    of the methods.

Note:
    In some cases, an outlying laboratory may distort the plot (i.e.,
    you cannot distinguish the data from the other non-outlying labs).
    In these cases, you may want to omit the lab from the plot while
    including it in the analysis (you can use the SUBSET clause to omit
    the lab both from the plot and the analysis).

    In order to specify one or more labs to omit from the plot (but not
    the analysis), enter the command

        SET CONSENSUS MEAN PLOT OMIT LABS <lab1> ... <labk>

    where <lab1> ... <labk> is a list of 1 to 10 labs to be omitted from
    the plot.

    To reset the default of all labs being plotted, enter

        SET CONSENSUS MEAN PLOT OMIT LABS

    This option was added 12/2016.

    Similarly, you can omit methods from the plot (but not the
    analysis) with the commands

        SET CONSENSUS MEAN PLOT OMIT METHOD ONE    <method>
        SET CONSENSUS MEAN PLOT OMIT METHOD TWO    <method>
        SET CONSENSUS MEAN PLOT OMIT METHOD THREE  <method>

    When extreme outliers are included in the analysis, the
    results for some methods may distort the plot.

    This option was added 04/2017.

Note:
    You can use the CHARACTER and LINE commands to control the
    appearance of the plot.  Specifically,

      1) Trace 1 is a line connecting the estimated means for
         each of the methods.
      2) Traces 2, 3, and 4 are the estimated means, lower interval,
         and upper interval, respectively, within a given method.
      3) Trace 5 is line connecting the lower and upper interval
         within a single method.

    This is demonstrated in the example programs below.

Note:
    The default is to put the method results on the left side of
    the plot and the lab data results on the right side of the
    plot.  To reverse this (i.e., lab data results on the left
    and the method results on the right side), enter the command

        SET CONSENSUS MEAN PLOT DATA LEFT

    To reset the default, enter the commnd

        SET CONSENSUS MEAN PLOT DATA RIGHT

    This option is demonstrated in the Program 4 example below.

Default:
    None
 
Synonyms:
    There are no synonyms for this command.
    
Related Commands:
    CONSENSUS MEANS     = Perform a consensus means analysis.
    MEAN PLOT           = Generate a mean plot.
    SD PLOT             = Generate a standard deviation plot.
    YOUDEN PLOT         = Generate a Youden plot.
    ANOVA               = Perform an analysis of variance.
 
Reference:
    Andrew Rukhin and Mark Vangel, "Estimation of a Common
    Mean and Weighted Means Statistics", Journal of the American 
    Statistical Association, March, 1998, Vol. 93, No. 441.

    Mark Vangel and Andrew Rukhin, "Maximum Likelihjood Analysis
    for Heteroscedastic One-Way Random Effects ANOVA in
    Interlaboratory Studies", Biometrics 55, 129-136, March 1999.

    "An ISO GUM Approach to Combining Results from Multiple
    Methods", M. S. Levenson, D. L. Banks, K. R. Eberhardt,
    L. M. Gill, W. F. Guthrie, H. K. Liu, M. G. Vangel,
    J. H. Yen, and N. F. Zhang, Journal of Research of the
    National Institute of Standards and Technology, Volume 105,
    Number 4, July-August 2000.

    Susannah Schiller and Keith Eberhardt, "Combining Data from
    Independent Analysis Methods", Spectrochim, ACTA 46 (12),
    1991.

    Susannah Schiller , "Standard Reference Materials:
    Statistical Aspects of the Certification of Chemical
    SRMs", NIST SP 260-125, NIST, Gaithersburg, MD, 1996.

Applications:
    Standard Reference Materials, Interlaboratory Studies
 
Implementation Date:
    2001/08
    2011/10: Redesigned plot to incorporate the lab data
    2016/12: Support for SET CONSENSUS MEAN PLOT OMIT LABS
    2017/03: Support for SET CONSENSUS MEAN PLOT OMIT METHOD
    2017/07: Changed default for Schiller-Eberhardt, Fairweather, and
             Bayesian consensus procedure to OFF
    2019/08: Added the command SET CONSENSUS MEAN PLOT DATA
 
Program 1:
    . Step 1: Read the data
    .
    SKIP 25
    READ STUTZ86.DAT ALITE JUNK2 JUNK3 JUNK4 JUNK5 LABID
    .
    . Step 2: Specify methods to include on the plot and define
    .         strings containing method id's.  Define settings
    .         for DerSimonian-Laird bootstrap.
    .
    set write decimals 5
    set modified mandel paule off
    set schiller eberhardt off
    set mean of means off
    set grand mean off
    set graybill deal off
    set generalized confidence interval off
    set fairweather off
    set bayesian consensus procedure off
    set dersimonian laird minmax off
    set dersimonian laird bootstrap on
    .
    let string sx1 = MP
    let string sx2 = VR
    let string sx3 = DSLcr()Original
    let string sx4 = DSLcr()HHD
    let string sx5 = DSLcr()Bootstrap
    let string sx6 = BOB
    let nmeth = 6
    .
    seed 21307
    set random number generator fibonacci congruential
    bootstrap samples 100000
    .
    . Step 3: Set plot control features
    .
    .         Settings for plot characters/lines
    .
    line solid all
    character blank all
    character fill on
    character hw 1 0.75
    character circle
    line      blank
    .
    .         Settings for labels
    .
    case asis
    title asis
    title offset 2
    tic mark label case asis
    title Consensus Means Plot
    y1label Response
    .
    let nlab = unique labid
    loop for k = 1 1 nlab
         let icnt = k + nmeth
         let string sx^icnt = ^k
    end of loop
    .
    let ntot = nmeth + nlab
    xlimits 1 ntot
    major xtic mark number ntot
    minor xtic mark number 0
    tic mark offset units data
    xtic mark offset 0.5   0.5
    x1tic mark label format group label
    let igx = group label sx1 to sx^ntot
    x1tic mark label content igx
    .
    . Step 4: Generate the plot
    .
    set consensus mean plot error two standard errors
    feedback off
    capture consplo1.out
    consensus mean plot alite labid
    end of capture
    .
    . Step 5: Post plot labelling
    .
    line dotted
    drawdsds  6.5 20  6.5 90
    justification center
    moveds 3.5 5
    text Consensus Method: Two Standard Errors
    moveds 9 5
    text Laboratorycr()meansp()+/-2*sd/sqrt(n)
 
Program 2:
    . This version suppresses the lab data portion of the plot
    .
    . Step 1: Read the data
    .
    SKIP 25
    READ STUTZ86.DAT ALITE JUNK2 JUNK3 JUNK4 JUNK5 LABID
    .
    . Step 2: Specify methods to include on the plot and define
    .         strings containing method id's.  Define settings
    .         for DerSimonian-Laird bootstrap.
    .
    set write decimals 5
    set modified mandel paule off
    set schiller eberhardt off
    set mean of means off
    set grand mean off
    set graybill deal off
    set generalized confidence interval off
    set fairweather off
    set bayesian consensus procedure off
    set dersimonian laird minmax off
    set dersimonian laird bootstrap on
    .
    let string sx1 = MP
    let string sx2 = VR
    let string sx3 = DSLcr()Original
    let string sx4 = DSLcr()HHD
    let string sx5 = DSLcr()Bootstrap
    let string sx6 = BOB
    let nmeth = 6
    .
    seed 21307
    set random number generator fibonacci congruential
    bootstrap samples 100000
    .
    . Step 3: Set plot control features
    .
    .         Settings for plot characters/lines
    .
    line solid all
    character blank all
    character fill on
    character hw 1 0.75
    character circle
    line      blank
    .
    .         Settings for labels
    .
    case asis
    title asis
    title offset 2
    tic mark label case asis
    title Consensus Means Plot
    y1label Response
    .
    xlimits 1 nmeth
    major xtic mark number nmeth
    minor xtic mark number 0
    tic mark offset units data
    xtic mark offset 0.5   0.5
    x1tic mark label format group label
    let igx = group label sx1 to sx^nmeth
    x1tic mark label content igx
    x1label Consensus Method: Two Standard Errors
    x1label displacement 15
    .
    title Consensus Means Plot - Lab Data Omitted
    set consensus mean plot data off
    feedback off
    consensus mean plot alite labid

Program 3:
    . This version sorts the methods by width of uncertainty interval
    .
    . Step 1: Read the data
    .
    SKIP 25
    READ STUTZ86.DAT ALITE JUNK2 JUNK3 JUNK4 JUNK5 LABID
    .
    . Step 2: Specify methods to include on the plot and define
    .         strings containing method id's.  Define settings
    .         for DerSimonian-Laird bootstrap.
    .
    set write decimals 5
    set modified mandel paule off
    set schiller eberhardt off
    set mean of means off
    set grand mean off
    set graybill deal off
    set generalized confidence interval off
    set fairweather off
    set bayesian consensus procedure off
    set dersimonian laird minmax off
    set dersimonian laird bootstrap on
    .
    let string sx1 = MP
    let string sx2 = VR
    let string sx3 = DSLcr()Original
    let string sx4 = DSLcr()HHD
    let string sx5 = DSLcr()Boot
    let string sx6 = BOB
    let nmeth = 6
    .
    seed 21307
    set random number generator fibonacci congruential
    bootstrap samples 100000
    .
    . Step 3: Set plot control features
    .
    .         Settings for plot characters/lines
    .
    line solid all
    character blank all
    character fill on
    character hw 1 0.75
    character circle
    line      blank
    .
    .         Settings for labels
    .
    case asis
    title asis
    title offset 2
    tic mark label case asis
    y1label Response
    .
    let nlab = unique labid
    loop for k = 1 1 nlab
         let icnt = k + nmeth
         let string sx^icnt = ^k
    end of loop
    .
    let ntot = nmeth + nlab
    xlimits 1 ntot
    major xtic mark number ntot
    minor xtic mark number 0
    tic mark offset units data
    xtic mark offset 0.5   0.5
    x1tic mark label format group label
    let igx = group label sx1 to sx^ntot
    x1tic mark label content igx
    .
    . Step 4: Generate the plot
    .
    loop for k = 1 1 ntot
        let string sxnew^k = ^sx^k
    end of loop
    .
    .         Generate dummy plot, read dpst3f.dat to obtain
    .         sorted labels
    .
    set consensus mean plot sorted on
    set consensus mean plot error two standard errors
    .
    device 1 off
    device 2 off
    print off
    consensus mean plot alite labid
    skip 0
    read dpst3f.dat indx
    loop for k = 1 1 nmeth
        let icnt = indx(k)
        let string sxnew^k = ^sx^icnt
    end of loop
    let igx = group label sxnew1 to sxnew^ntot
    x1tic mark label content igx
    device 1 on
    device 2 on
    printing on
    .
    .         Now generate plot with sorted labels
    .
    title Consensus Means Plot - Method Sorted by Width of Expanded Uncertainty
    feedback off
    consensus mean plot alite labid
    .
    . Step 5: Post plot labelling
    .
    line dotted
    drawdsds  6.5 20  6.5 90
    justification center
    moveds 3.5 5
    text Consensus Method: Two Standard Errors
    moveds 9 5
    text Laboratorycr()meansp()+/-2*sd/sqrt(n)

Program 4:
    . Step 1:   Read the data
    .
    SKIP 25
    READ STUTZ86.DAT ALITE JUNK2 JUNK3 JUNK4 JUNK5 LABID
    .
    . Step 2:   Define consensus means options
    .
    set write decimals 5
    set bob on
    set dersimonian laird bootstrap on
    set dersimonian laird minmax off
    set modified mandel paule off
    set schiller eberhardt off
    set mean of means off
    set grand mean off
    set graybill deal off
    set generalized confidence interval off
    set fairweather off
    set bayesian consensus procedure off
    set random number generator fibonacci congruential
    seed 55631
    bootstrap samples 100000
    .
    .  iflagm  = 1   => 95% Confidence Interval
    .          = 2   => Two Standard Errors Confidence Interval
    .          = 3   => One Standard Errors Confidence Interval
    .
    let iflagm = 2
    if iflagm = 1
       set consensus mean plot error confidence intervals
    else if iflagm = 2
       set consensus mean plot error two standard errors
    else if iflagm = 3
       set consensus mean plot error one standard errors
    end of if
    .
    .
    . Step 3:   Define strings containing Method id's
    .
    let nlab = unique labid
    loop for k = 1 1 nlab
         let string sx^k = ^k
    end of loop
    .
    let icnt = nlab + 1
    let string sx^icnt = MP
    let icnt = icnt + 1
    let string sx^icnt = VR
    let icnt = icnt + 1
    let string sx^icnt = DSLcr()Original
    let icnt = icnt + 1
    let string sx^icnt = DSLcr()HHD
    let icnt = icnt + 1
    let string sx^icnt = DSLcr()Bootstrap
    let icnt = icnt + 1
    let string sx^icnt = BOB
    let nmeth = 6
    .
    . Step 4:   Set plot control options
    .
    line solid all
    character blank all
    character fill on
    character hw 1 0.75
    character circle
    line      blank
    .
    case asis
    title case asis
    label case asis
    tic mark label case asis
    title offset 2
    title Consensus Means Plot - With Data, Unsorted
    y1label Percentage of Alite
    .
    let ntot = nmeth + nlab
    xlimits 1 ntot
    major xtic mark number ntot
    minor xtic mark number 0
    tic mark offset units data
    xtic mark offset 0.5   0.5
    x1tic mark label format group label
    let igx = group label sx1 to sx^ntot
    x1tic mark label content igx
    .
    . Step 5:   Generate the consensus mean plot
    .
    set consensus mean plot data left
    . printing off
    capture screen on
    capture cmplot.out
    consensus mean plot alite labid
    end of capture
    . printing on
    .
    line dotted
    drawdsds  5.5 20  5.5 90
    .
    justification center
    moveds 8.5 8
    if iflagm = 1
       text Consensus Method:cr()95% Confidence Limits
    else if iflagm = 2
       text Consensus Method:cr()Two Standard Errors
    else if iflagm = 3
       text Consensus Method:cr()One Standard Error
    end of if
    moveds 2.5 8
    text Method/Laboratorycr()meansp()+/-2*sd/sqrt(n)

-----CONCLUSIONS-------------------------------------------------------
 
CONCLUSIONS
 
Name:
    CONCLUSIONS
 
Type:
    Keyword
 
Purpose:
    Symbolic name for DATAPLOT's conclusions file.  It is used by with
    the SEARCH and LIST commands.
 
Description:
    Several DATAPLOT commands write some analytical conclusions to a
    file.  Specifically, the CORRELATION PLOT and the PPCC PLOT
    commands do this.  The SEARCH and LIST commands can list this file
    or perform a search on it by referring to it as CONCLUSIONS.
 
Syntax:
    None
 
Examples:
    SEARCH CONCLUSIONS PPCC
    LIST CONCLUSIONS FOR I = 1 1 35
 
Note:
    The file DPCONF.TEX (or dpconf.tex on Unix systems) is opened in
    the current directory when DATAPLOT is executed.  However, only a
    few commands actually write anything to this file.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SEARCH            = Search a file for a string.
    LIST              = Lists the contents of a file.
    CORRELATION PLOT  = Generate an auto, cross, or partial correlation
                        plot.
    PPCC PLOT         = Generate a probability plot correlation
                        coefficient plot.
 
Applications:
    XX
 
Implementation Date:
    93/12
 
Program:
    XX
 
-----CONDITION INDICES (LET)----------------------------------------
 
CONDITION INDICES
 
Name:
    CONDITION INDICES (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute condition indices of a regression design matrix.
 
Description:
    Condition indices are a measure of the multi-colinearity in a
    regression design matrix (i.e., the independent variables).

    Multi-colinearity results when the columns of X have significant
    interdependence (i.e., one or more columns of X is close to a
    linear combination of the other columns).  Multi-colinearity
    can result in numerically unstable estimates of the regression
    coefficients (small changes in X can result in large changes
    to the estimated regression coefficients).

    Pairwise colinearity can be determined from viewing a correlation
    matrix of the independent variables.  However, correlation
    matrices will not reveal higher order colinearity.

    There are a number of approaches to dealing with
    multi-colinearity.  Some of these include:

        1) Delete one or more of the independent variables from
           the fit.
        2) Perform a principal components regression.
        3) Compute the regression using a singular value
           decomposition approach.  Note that Dataplot uses
           a modified Gram-Schmidt method (Dataplot can perform
           a singular value decomposition, however this has not
           been incorporated into the fit).

    Condition indices are one measure that can be used to
    detect multi-colinearity (variance inflation factors are
    another).  The condition indices are calculated as follows:

        1) Scale the columns of the X matrix to have unit sums of
           squares.
        2) Calculate the singular values of the scaled X matrix and
           square them.

    Condition indices between 30 and 100 indicate moderate to
    strong colinearity.

Syntax:
    LET <y1> = CONDITION INDICES <mat1>
               <SUBSET/EXCEPT/FOR qualification>
    where <mat1> is the design matrix for which the condition indices
                are to be computed;
          <y1> is a vector where the resulting condition indices are
                saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional (and
                rarely used in this context).
 
Examples:
    LET Y = CONDITION INDICES X
 
Note:
    Matrices are created with either the READ MATRIX, CREATE MATRIX,
    or MATRIX DEFINITION command.  Enter HELP MATRIX DEFINITION,
    HELP CREATE MATRIX, and HELP READ MATRIX for details.
 
Note:
    The columns of a matrix are accessible as variables by appending an
    index to the matrix name.  For example, the 4x4 matrix C has
    columns C1, C2, C3, and C4.  These columns can be operated on like
    any other DATAPLOT variable.
 
Note:
    The maximum size matrix that DATAPLOT can handle is set when
    DATAPLOT is built on a particular site.  Enter the command
    HELP MATRIX DIMENSION for details on the maximum size matrix
    that can be accomodated.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    VARIANCE INFLATION FACT  = Compute variance inflation factors.
    CREATE MATRIX            = Create a matrix from a list of
                               variables.
    FIT                      = Perform a least squares fit.
    CATCHER MATRIX           = Compute the catcher matrix.
    PARTIAL REGRESSION PLOT  = Compute the catcher matrix.
 
Reference:
    "Efficient Computing of Regression Diagnostics", Velleman and
    Welsch, American Statistician, November, 1981, Vol. 35, No. 4,
    pp. 234-242.
 
Applications:
    Regression Diagnostics
 
Implementation Date:
    2002/6
 
Program:
    DIMENSION 100 COLUMNS
    SKIP 25
    READ HALD647.DAT Y X1 X2 X3 X4
    SKIP 0
    LET N = SIZE X1
    LET X0 = SEQUENCE 1 1 N
    LET Z = CREATE MATRIX X0 X1 X2 X3 X4
    LET C = CONDITION INDICES Z
    PRINT C
 
-----CONDITION PLOT--------------------------------------
 
CONDITION PLOT
 
Name:
    CONDITION PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a condition plot.  A condition plot is a plot of

       PLOT Y X

    conditional on the value of a third variable.

    Although condition plots can be generated using the MULTIPLOT
    and SUBSET commands (and typically LOOPING), the CONDITION PLOT
    command allows some fairly involved multiplots to be generated
    with a minimum number of commands (and without looping).

Description:
    A condition plot of Y X TAG is a plot of Y versus X for
    the distinct values of TAG arranged on a single page.  That is,
    if TAG can have the value 1, 2, or 3, then

        CONDITION PLOT Y X TAG

    is equivalent to

        MULTIPLOT 2 2
        CONDITION PLOT Y X TAG SUBSET TAG = 1
        CONDITION PLOT Y X TAG SUBSET TAG = 2
        CONDITION PLOT Y X TAG SUBSET TAG = 2
        END OF MULTIPLOT

    In the above, TAG is referred to as the conditioning variable.
    Dataplot expects the conditioning variable to be a discrete
    variable (i.e., it takes on a small number of distinct values).
    If you want to condition on a continuous variable, as is often
    the case, Dataplot provides several methods for doing this.

    You can use the "CODE" commands:

        LET TAG = CODE2 Y
        LET TAG = CODE4 Y
        LET TAG = CODE8 Y
        LET TAG = CODE<n> Y  (<n> = 3, 5, 6, 7, 9, or 10)

    CODE2 codes TAG as 1 or 2 depending on whether the corresponding
    points in Y fall below or above the median.  CODE4 divides
    the data into quartiles (and code TAG as 1, 2, 3, 4 according
    to which quartile the data falls into).  Similarly, CODE8
    divides Y into octiles.  CODE<n> divides Y into <n>
    percentiles and defines TAG according to which of the percentiles
    the data falls into.

    For maximum control, you can do something like the following:

        LET N = SIZE Y
        LET TAG = 1 FOR I = 1 1 N
        LET TAG = 2 SUBSET Y = 25 TO 50
        LET TAG = 3 SUBSET Y = 51 TO 100
        LET TAG = 4 SUBSET Y = 101 TO 150

    This concept generalizes to other types of plots other than
    scatter plots.  Dataplot supports the CONDITION PLOT for a 
    number of univariate and bivariate plots.

    There are a number of alternatives for the appearance of this
    plot.  Dataplot tries to balance simplicity with flexibility
    by using default settings, but providing numerous SET commands
    to control the appearance of the plot.  These are described in
    detail in the NOTES section below.

    The CONDITION PLOT is similar to the factor plot.  A simple
    explanation of the difference is that the factor plot
    does something like

       MULTIPLOT 2 2
       PLOT Y X1
       PLOT Y X2
       PLOT Y X3
       PLOT Y X4
       END OF MULTIPLOT

    while the condition plot does something like

       MULTIPLOT 2 2
       PLOT Y X  SUBSET TAG = 1
       PLOT Y X  SUBSET TAG = 2
       PLOT Y X  SUBSET TAG = 3
       PLOT Y X  SUBSET TAG = 4
       END OF MULTIPLOT

Syntax 1:
    CONDITION PLOT Y X TAG    <SUBSET/EXCEPT/FOR qualification>
    where <Y> is the response (y axis) variable;
          <X> is the factor (x axis) variable;
          <TAG> is the conditioning variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used when generating a bivariate plot.

Syntax 2:
    CONDITION PLOT Y1 ... Yk X TAG    <SUBSET/EXCEPT/FOR qualification>
    where <Y1> ... <Yk> are the response (y axis) variables;
          <X> is the factor (x axis) variable;
          <TAG> is the conditioning variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used when generating a bivariate plot with 
    multiple response variables.  That is, we are effectively doing

       CONDITION PLOT Y1 X TAG
       CONDITION PLOT Y2 X TAG
              etc.

    where each response variable is plotted as a single row of
    plots.

Syntax 3:
    CONDITION PLOT Y X TAG1 TAG2    <SUBSET/EXCEPT/FOR qualification>
    where <Y> is the response (y axis) variable;
          <X> is the factor (x axis) variable;
          <TAG1> is the first conditioning variable;
          <TAG2> is the second conditioning variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used when generating a bivariate plot with 
    two conditioning variables.  The rows of the plot matrix
    correspond to the distinct values of the first tag variable
    while the columns correspond to the distinct values of the
    second tag variable.

    The most general case, multiple response variables with
    two conditioning variables, is still being tested.

Syntax 4:
    CONDITION PLOT Y TAG    <SUBSET/EXCEPT/FOR qualification>
    where <Y> is the response (y axis) variable;
          <TAG> is the conditioning variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used when generating a univariate plot.

Syntax 5:
    CONDITION PLOT Y1 ... Yk TAG    <SUBSET/EXCEPT/FOR qualification>
    where <Y1> ... <Yk> are the response (y axis) variables;
          <TAG> is the conditioning variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used when generating a univariate plot with 
    multiple response variables.  That is, we are effectively doing

       CONDITION PLOT Y1 TAG
       CONDITION PLOT Y2 TAG
              etc.

    where each response variable is plotted as a single row of
    plots.

Syntax 6:
    CONDITION PLOT Y TAG1 TAG2    <SUBSET/EXCEPT/FOR qualification>
    where <Y> is the response (y axis) variable;
          <TAG1> is the first conditioning variable;
          <TAG2> is the second conditioning variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used when generating a univariate plot with 
    two conditioning variables.  The rows of the plot matrix
    correspond to the distinct values of the first tag variable
    while the columns correspond to the distinct values of the
    second tag variable.

    The most general case, multiple response variables with
    two conditioning variables, is still being tested.

Examples:
    SET CONDITION PLOT TYPE HISTOGRAM
    CONDITION PLOT Y TAG

    SET CONDITION PLOT TYPE PLOT
    CONDITION PLOT Y X TAG
 
    SET CONDITION PLOT TYPE PLOT
    CONDITION PLOT Y X TAG SUBSET TAG > 2
 
Note:
    The concept of the condition plot generalizes quite nicely to any
    plot type for either one or two variables.  Dataplot supports the
    condition plot for a number of different plot types.  The type of
    plot generated is controlled by the following command:

        SET CONDITION PLOT TYPE <value>

    where <value> is one of the following.

    The folllowing plot two variables (e.g., BIHISTOGRAM Y1 Y2).
    Use either syntax 2 or syntax 3 above, depending on whether
    you have one or multiple response variables, for the
    CONDITION PLOT command.

        PLOT    - generate scatter plots (this is the default).
                  The x and y axis labels are automatically set
                  to the appropriate variable name.
 
        QUANTILE-QUANTILE - generate quantile-quantile plots.
                  The x and y axis labels are automatically set
                  to the appropriate variable name.
                  
        BIHISTOGRAM - generate relative bihistograms.  We recommend
                  that you enter SET RELATIVE HISTOGRAM PERCENT to
                  generate more consistent y-axis scales.  The
                  X1LABEL is set to the first variable name and the
                  X2LABEL is set to the second variable name.  If no
                  YLABEL is already defined, the YLABEL is set to
                  "Frequency".

        BOX-COX LINEARITY - generate Box-Cox linearity plots.
                  If not previously defined, the X1LABEL is set
                  to "Alpha" and the Y1LABEL is set to "Correlation".
                  X2LABEL is set to the appropriate variable names.
                  
 
        STATISTIC PLOT - generate a statistic plot (e.g., MEAN PLOT,
                  STANDARD DEVIATION PLOT).  To define which 
                  statistic is plotted, enter the command
                      SET CONDITION PLOT STATISTIC <name>
                  where <name> can be either one or two words.
                  The list of supported statistics is the same as
                  for the STATISTIC PLOT command.  The x and y axis
                  labels are automatically set to the appropriate
                  variable name.
 
    The folllowing plot one variables (e.g., HISTOGRAM Y1).
    Use syntax 1 above.

        HISTOGRAM - generate relative histograms.  We recommend that
                  you enter SET RELATIVE HISTOGRAM PERCENT to
                  generate more consistent y-axis scales.  The
                  X1LABEL is set to the variable name.  If no Y1LABEL
                  is already defined, the Y1LABEL is set to
                  "Frequency".

        PERCENT POINT PLOT - generate a percent point plot. The
                  X1LABEL is set to "Percentile" and the X2LABEL is
                  set to the variable name.  No Y1LABEL is
                  automatically set.

        AUTOCORRELATION - generate an autocorrelation plot. If not
                  already defined, X1LABEL is set to "Lag", Y1LABEL
                  is set to "Correlation" and the X2LABEL is
                  set to the variable name.

        SPECTRAL - generate a spectral plot. If not already defined,
                  X1LABEL is set to "Frequency", Y1LABEL
                  is set to "Power" and the X2LABEL is
                  set to the variable name.

        LAG     - generate a lag plot. If not already defined,
                  X1LABEL is set to "Frequency", Y1LABEL
                  is set to "Power" and the X2LABEL is
                  set to the variable name.

        RUN SEQUENCE PLOT - generate a run sequence plot. If not
                  already defined, X1LABEL is set to "Sequence",
                  Y1LABEL is not set, and the X2LABEL is
                  set to the variable name.

        <dist> PROBABILITY PLOT - generate a probability plot for the
                  <dist> distribution.  <dist> can be up to 5 words
                  and corresponds to the same names as supported
                  by the PROBABILITY PLOT command (70+ distributions
                  supported).  If not already defined,
                  X1LABEL is set to "Theoretical", Y1LABEL
                  is set to "Data" and the X2LABEL is
                  set to the variable name.

        <dist> PPCC PLOT - generate a ppcc plot for the
                  <dist> distribution.  <dist> can be up to 5 words
                  and corresponds to the same names as supported
                  by the PPCC PLOT command (30+ distributions
                  supported).  If not already defined,
                  X1LABEL is set to "Parameter", Y1LABEL
                  is set to "Correlation" and the X2LABEL is
                  set to the variable name.

    The plot TITLE identifies the value of the conditioning
    variable for all of the above plot types.

    Where it makes sense, Dataplot will generate a dummy plot
    of the full data set first in order to generate common x and y
    axis scales.  For some plots, this does not make sense.  For
    example, a full sample PPCC plot does not necessarily encompass
    the range of the PPCC plots generated from subsets of the data.

    Dataplot automatically defines X1LABEL, X2LABEL, and YLABEL
    commands for these plots.  You can control the attributes
    of these labels with the standard label setting commands.
    If you have defined variable labels (with the VARIABLE LABEL
    command), these will automatically be substituted for variable
    names in the labels.

    If you have defined variable labels with the VARIABLE LABEL
    command and you want to suppress the automatic expansion
    of the variable name to the variable label, enter

        SET VARIABLE LABEL EXPAND OFF

    To restore the default that variable names will be expanded to
    the corresponding variable label, enter

        SET VARIABLE LABEL EXPAND ON

Note:
    In distinguishing the different syntaxes above, Dataplot needs
    to know how many response variables and how many conditioning
    variables there are.  The presence of an x axis variable is
    automatically determined from the plot type.  The number of
    response and conditioning variables is specified with the
    commands

        SET CONDITION PLOT RESPONSE VARIABLES <value1>
        SET CONDITION PLOT CONDITION VARIABLES <value2>

    where <value1> identifies the number of response variables and
    <value2> identifies the number of conditioning variables.
    On the CONDITION PLOT command, Dataplot assummes that the 
    response variables (y axis) come first, then the factor
    variable (x axis) if needed, and then the conditioning
    variables.

    The default is one response variable and one conditioning
    variable.

Note:
    The following option controls which axis tic marks, tic mark
    labels, and axis labels are plotted.
 
        SET CONDITION PLOT LABELS <ON/OFF/XON/YON/BOX>

    OFF means that all axis labels are suppressed (this can be
    useful if a large number of variables are being plotted).  ON
    means that both X and Y axis labels are printed.  XON only
    plots the x axis labels and YON only plots the y axis labels.

    BOX is a special option that creates an extra column on the
    left and an extra row on the bottom.  The axis label is
    printed in this box.  BOX is typically reserved for the
    case where there is a natural division of rows and columns
    (i.e., either multiple response variables or two conditioning
    variables).

    The default is ON (both x and y axis labels are printed).

Note:
    The following option controls where the x axis tic marks,
    tic mark labels, and axis label are printed.
 
        SET CONDITION PLOT X AXIS <BOTTOM/TOP/ALTERNATE>

    BOTTOM specifies that the x axis labels are printed on the
    bottom axis (on the last row only).  TOP specifies that
    the x axis labels are printed on the top axis (first row
    only).  ALTERNATE specifies that the x axis labels alternate
    between the top (first row) and bottom axis (last row).
    We recommend using the TIC OFFSET command to avoid overlap
    of axis labels and tic marks.

    The default is ALTERNATE.

Note:
    The following option controls where the y axis tic marks,
    tic mark labels, and axis label are printed.
 
        SET CONDITION PLOT Y AXIS <LEFT/RIGHT/ALTERNATE>

    LEFT specifies that the y axis labels are printed on the
    left axis (on the first column only).  RIGHT specifies that
    the y axis labels are printed on the right axis (last column
    only).  ALTERNATE specifies that the y axis labels alternate
    between the left (first column) and right axis (last column).
    We recommend using the TIC OFFSET command to avoid overlap
    of axis labels and tic marks.

    The default is ALTERNATE.

Note:
    Users have different preferences in terms of whether the
    plot frames for neighboring plots are connected or not.
    This is controlled with the following option.
 
        SET CONDITION PLOT FRAME <DEFAULT/CONNECTED/USER>

    DEFAULT connects neighboring frames (i.e., the FRAME CORNER
    COORDINATES are set to 0 0 100 100).  USER uses whatever
    frame coordinates are currently set (15 20 85 90 by default)
    and makes no special provisions for axis labels and tic marks
    (i.e., you set them as you normally would, each plot uses 
    whatever you have set).  CONNECTED uses whatever frame
    coordinates have been set by the user, but it draws the axis
    labels and tic marks as if DEFAULT were being used (that is, as
    determined by the SET CONDITION PLOT <LABELS/X AXIS/Y AXIS>
    commands described above).  Typically, CONNECTED is used to
    put a small bit of space between plots.  For example, you
    might use FRAME CORNER COORDINATES  3 3 97 97 before the
    CONDITION PLOT command.
 
    The default is DEFAULT.

Note:
    When the tic marks and tic mark labels are all plotted on the
    same side (i.e., SET CONDITION PLOT Y AXIS is
    set to LEFT or RIGHT or SET CONDITION PLOT X AXIS is
    set to BOTTOM or TOP), then overlap between plots is possible.
    The TIC OFFSET command can be used to avoid this.  In addition,
    you can stagger the tic labels with the following command:
 
        SET CONDITION PLOT LABEL DISPLACEMENT
                <NORMAL/STAGGERED/VALUE>
 
    NORMAL means that all tic labels are plotted at a distance
    determined by the TIC LABEL DISPLACEMENT command.  STAGGERED
    means that alternating plots will be staggered.  That is, one
    will use the standard displacement while the next uses a
    staggered value.  Entering this command with a numeric value
    specifies the amount of the displacement for the staggered
    tic labels.  For example,

        TIC MARK LABEL DISPLACEMENT 10
        SET CONDITION PLOT LABEL DISPLACEMENT STAGGERED
        SET CONDITION PLOT LABEL DISPLACEMENT 25

    These commands specify that the default tic label displacement
    is 10 and the staggered tic mark label displacement is 25.

Note:
    It is often helpful on scatter plot matrices to overlay a
    fitted line on the plots.  The following command is used
    to specify the type of fit.

        SET CONDITION PLOT FIT <NONE/LOWESS/LINE/QUAD/SMOOTH>

    NONE means that no fitted line is plotted.  LOWESS means
    that a locally weighted least squares line will be overlaid.
    LINE means that a linear fit (Y = A0 + A1*X) will be overlaid.
    QUAD means that a quadratic fit (Y = A0 + A1*X + A2*X**2) will
    be overlaid.  SMOOTH means that a least squares smoothing will
    be overlaid.

    For LOWESS, it is recommended that the lowess fraction be set
    fairly high (e.g., LOWESS FRACTION 0.6).

    The fitted line is currently only generated if the condition plot
    type is PLOT.

    The default is for no fitted line to be overlaid on the plot.
    If a overlaid fit is desired, the most common choice is to use
    LOWESS.

Note:
    Dataplot supports a special plot type

        PLOT Y X TAG

    In this form of the plot command, TAG is a group identifier
    variable.  Points belonging to the same group are plotted with
    the same attributes (controlled by the CHARACTER and LINE commands
    and their various attribute setting commands).

    Using a tag variable has two common purposes:

    1) If your data has natural groups (e.g., batch 1 and batch 2).
    2) To identify certain points.  The most common application
       would be to flag outliers.
 
    You can specify that the condition plot use the form
    of the PLOT command by using the command

        SET CONDITION PLOT TAG <ON/OFF>

    OFF specifies that the standard plot command (PLOT Y1 Y2) will
    be used.  ON specifies that the last variable on the
    CONDITION PLOT command is a tag variable.  That is, it is
    not plotted directly, but is instead the third variable on
    all the plot commands generated by the condition plot.
    Note that this tag variable is in addition to the conditioning
    variable.

    Currently, this command only applies if the condition plot
    plot type is set to PLOT.

    In effect, you can use the SET CONDITION PLOT TAG ON to
    identify groups in the data (whether it be a natural group
    variable or a created group to idenitfy a few specific points
    such as outliers) while conditioning on another, possibly
    continuous, variable.

    The default is OFF.

Note:
    Dataplot allows you to set axis limits with the LIMITS command.
    For the condition plot, it is often desirable to set
    the axis limits for each plot.  This can be done with the
    command
 
        SET CONDITION PLOT YLIMITS <LOW1> <UPP1> <LOW2> <UPP2> ...
        SET CONDITION PLOT XLIMITS <LOW1> <UPP1> <LOW2> <UPP2> ...

    Note that the pairs of limits correspond to the variable list
    in the CONDITION PLOT command.  For univariate plot types, the 
    plot order corresponds to the variable list.  For bivariate plot
    types, the YLIMITS refer to the response variables and XLIMITS
    refer to the factor variables.  That is, Dataplot determines
    which variable is being plotted on each axis, and gets the
    corresponding limits.

    The default is to allow the axis limits to float with the data.

Note:
    Dataplot supports a subregion capability.  This is used to
    draw "engineering limits" on a plot.  For a condition plot,
    if you specify engineering limits, you typically want these
    limits to vary with each plot.  They can be specified with the
    command
 
        SET CONDITION PLOT SUBREGION XLIMITS <LOW1> <UPP1>
            <LOW2> <UPP2> ...
        SET CONDITION PLOT SUBREGION YLIMITS <LOW1> <UPP1>
            <LOW2> <UPP2> ...

    This command is similar to the SET CONDITION PLOT XLIMITS and
    SET CONDITION PLOT YLIMITS commands in that the list corresponds to
    the variables entered on the CONDITION PLOT command.

    Only one set of subregion limits can be set for each variable.

    The default is that no subregion limits are set.

Note:
    You can specify a special X2LABEL for the plots with the
    following command 
 
        SET CONDITION PLOT X2LABEL <OFF/
              CORRELATION/PERCENT CORRELATION/EFFECT/
              PERCENT ACCEPT/NUMBER ACCEPT/ACCEPT TOTAL>

    where
        OFF      - no special X2LABEL is drawn.
        CORRELATION - the correlation of the points on the plot
                   is printed with the X2LABEL.  This option
                   is typically used with the plot type PLOT.
        PERCENT CORRELATION - this is the same as CORRELATION, except
                   that the correlation is printed as a percent.
        EFFECT   - the difference between the low and high value
                   is printed.  This option is typically used with
                   the plot type DEX <stat> INTERACTION (and doesn't
                   really make any sense with the other plot types).
                   This plot type is supported for the SCATTER PLOT
                   MATRIX, but not for the CONDITION PLOT.
        PERCENT ACCEPT - this option prints the percentage of points
                   inside the first subregion.  If no subregions are
                   defined, this option makes no sense.  It is
                   typically used to specify the percentage of points
                   within engineering limits.
        NUMBER ACCEPT - this option is similar to PERCENT ACCEPT.
                   However, the number of points rather than the
                   percentage is printed.
        ACCEPT TOTAL - this option is similar to NUMBER ACCEPT.
                   However, it prints the number accepted first,
                   then the total number of points.
        ACCEPT TOTAL PERCENT - this option is similar to ACCEPT TOTAL.
                   However, after printing the number accepted and
                   the total number, it prints the percentage
                   accepted.

    The following commands can be used to add a prefix and suffix
    to the X2LABEL.  For example, you might want the PERCENT
    CORRELATION to append a "%" after the percent correlation
    and to start with "CORR = ".

        SET X2LABEL PREFIX <prefix>
        SET X2LABEL SUFFIX <suffix>
 
    The appearance and location of the X2LABEL are controlled
    with the standard X2LABEL attribute setting commands.

    There are occassions where you may want to use the values
    computed in the X2LABEL for additional numeric computations.
    These values are automatically written to the file
    "dpst5f.dat".  The values are printed in the order the plots
    are generated.

    You can control the number of digits printed with the
    SET WRITE DECIMALS command.

Note:
    You can use standard plot control commands to control the
    appearance of the condition plot.

    For example,

       MULTIPLOT CORNER COORDINATES 5 5 95 95
       MULTIPLOT SCALE FACTOR 3
       TIC OFFSET UNITS SCREEN
       TIC OFFSET 5 5

    is a fairly typical set of commands commonly used with
    condition plots.

Default:
    None
 
Synonyms:
    SUBSET PLOT is a synonym for CONDITION PLOT.
    SET SUBSET PLOT is a synonym for SET CONDITION PLOT.
 
Related Commands:
    PLOT                = Generates a data or function plot.
    SCATTER PLOT MATIRX = Generate a condition plot.
    FACTOR PLOT         = Generate a factor plot.
 
Reference:
    "Visualizing Data", Cleveland, William S., Hobart Press, 1993.
 
    "Graphical Exploratory Data Analysis", du Toit, Steyn, and Stumpf,
    Springer-Verlang, 1986.
 
Applications:
    Exploratory Data Analysis, Multivariate Data Analysis
 
Implementation Date:
    2000/1
 
Program:
    dimension 25 variables
    skip 25
    read iris.dat y1 y2 y3 y4 group
    .
    multiplot corner coordinates 10 5 90 90
    tic offset units screen
    xtic offset 5 10
    ytic offset 5 5
    char x
    line blank
    .
    condition plot y3 y4 group
 
-----CONFIDENCE LIMITS--------------------------------------
 
CONFIDENCE LIMITS
 
Name:
    CONFIDENCE LIMITS
 
Type:
    Analysis Command
 
Purpose:
    Generates a confidence interval for the mean.
 
Description:
    The confidence interval for the mean is:

       xbar +/- t(alpha/2,n-1)*s/SQRT(n)

    with xbar, s, n, and t denoting the sample mean, the sample
    standard deviation, the sample size, and the percent point
    function of the t distribution, respectively.
 
    This confidence interval is based on the assumption that
    the underlying data is approximately normally distributed.
    However, this confidence interval is fairly robust against
    non-normality unless the sample size is small or the
    departure from normality is severe (in particular, the
    data is not too skewed).

    For lognormally distributed data, the modified Cox method can be
    used to obtain a confidence interval for the mean.  In this case,
    let Y(i) denote the log of X(i) where X represents the original
    data.  The confidence interval for the mean is then

        ybar + (s**2/2) +/-
               t(1-alpha/2,n-1)*SQRT((s**2/n) + (s**4/(2*n-1))))

    with ybar and s denoting the mean and standard deviation of Y
    (i.e., the logged data) and t denotes the t percent point function.

    For confidence intervals, computing standard confidence limits for
    the logged data and then back transforming to obtain confidence
    limits for the original data does not generate accurate intervals.
    For sufficiently large samples (based on simulations, Olsson suggests
    sample sizes larger than 200), using the standard normal based
    confidence interval should give reasonable results.  Using the
    BOOTSTRAP MEAN PLOT command is an alternative method to obtain the
    confidence interval for data that is not approximately normally
    distributed.

Syntax 1:
    <LOWER/UPPER> <LOGNORMAL> CONFIDENCE LIMITS <y>
                              <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <LOGNORMAL> is optional;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    If LOWER is specified, a one-sided lower confidence limit is
    returned.  If UPPER is specified, a one-sided upper confidence
    limit is returned.  If neither is specified, a two-sided limit
    is returned.

    If LOGNORMAL is given, the confidence interval based on the lognormal
    distribution will be used.

    This syntax supports matrix arguments for the response variable.

Syntax 2:
    MULTIPLE <LOWER/UPPER> <LOGNORMAL> CONFIDENCE LIMITS  <y1> ... <yk>
                           <SUBSET/EXCEPT/FOR qualification>
    where <y1>  .... <yk> is a list of 1 to 30 response variables;
          <LOGNORMAL> is optional;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax will generate a confidence interval for each of
    the response variables.  The word MULTIPLOT is optional.  That is,

         MULTIPLE CONFIDENCE LIMITS Y1 Y2 Y3

    is equivalent to

         CONFIDENCE LIMITS Y1 Y2 Y3

    If LOWER is specified, a one-sided lower confidence limit is
    returned.  If UPPER is specified, a one-sided upper confidence
    limit is returned.  If neither is specified, a two-sided limit
    is returned.

    If LOGNORMAL is given, the confidence interval based on the lognormal
    distribution will be used.

    This syntax supports matrix arguments for the response variables.

Syntax 3:
    REPLICATED <LOWER/UPPER> <LOGNORMAL> CONFIDENCE LIMITS
                             <y> <x1> ... <xk>
                             <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <LOGNORMAL> is optional;
          <x1>  .... <xk> is a list of 1 to 6 group-id variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    If LOWER is specified, a one-sided lower confidence limit is
    returned.  If UPPER is specified, a one-sided upper confidence
    limit is returned.  If neither is specified, a two-sided limit
    is returned.

    If LOGNORMAL is given, the confidence interval based on the lognormal
    distribution will be used.

    This syntax performs a cross-tabulation of the <x1> ... <xk>
    and generates a confidence interval for each unique combination
    of the cross-tabulated values.  For example, if X1 has 3 levels
    and X2 has 2 levels, six confidence intervals will be generated.

    This syntax does not support matrix arguments.

Examples:
    CONFIDENCE LIMITS Y1
    CONFIDENCE LIMITS Y1  SUBSET TAG > 2
    MULTIPLE CONFIDENCE LIMITS Y1 TO Y5
    REPLICATED CONFIDENCE LIMITS Y X
    LOGNORMAL CONFIDENCE LIMITS Y1
 
Note:
    A table of confidence intervals is printed for alpha levels of
    50.0, 75.0, 90.0, 95.0, 99.0, 99.9, 99.99, and 99.999.  The sample
    mean, sample standard deviation, and sample standard deviation of
    the mean are also printed.  The t-value and t-value X standard
    deviation of the mean are printed in the table.  These numbers can
    be used to construct the equivalent hypothesis test if desired
    (DATAPLOT does not currently provide a hypothesis test command).
 
Note:
    In addition to the CONFIDENCE INTERVALS command, the following
    commands can also be used:

        LET ALPHA = 0.05

        LET A = LOWER CONFIDENCE LIMIT Y
        LET A = UPPPER CONFIDENCE LIMIT Y
        LET A = ONE SIDED LOWER CONFIDENCE LIMIT Y
        LET A = ONE SIDED UPPER CONFIDENCE LIMIT Y

    The LET ALPHA = command is used to specify the significance level.

    In addition to the above LET command, built-in statistics are
    supported for about 20 different commands (enter HELP STATISTICS
    for details).

Note:
    Hypothesis tests for the mean can be performed using the T TEST
    command.  Enter HELP T TEST for details.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DIFF OF MEANS CONFIDENCE INTERVAL = Generate a confidence interval
                                        for the difference of two means.
    T-TEST                            = Perform a t-test.
    PREDICTION LIMITS                 = Generate a prediction limit.
    TOLERANCE LIMITS                  = Generate a tolerance limit.
 
Reference:
    Hahn and Meeker (1991), "Statistical Intervals: A Guide for
    Practitioners", Wiley, pp. 54-55.
 
    Olsson (2005), "Confidence Intervals for the Mean of a Log-Normal
    Distribution", Journal of Statistics Education, Vol. 13, No. 1.

Applications:
    Confirmatory Data Analysis
 
Implementation Date:
    Pre-1987
    2010/03: Support for MULTIPLE and REPLICATION options
    2010/03: Support for matrix options
    2017/08: Support for lognormal confidence limits
 
Program 1:
    SKIP 25
    READ ZARR13.DAT Y
    SET WRITE DECIMALS 5
    CONFIDENCE LIMITS Y
 
Program 2:
    SKIP 25
    READ GEAR.DAT Y X
    SET WRITE DECIMALS 5
    REPLICATED CONFIDENCE LIMITS Y X
 
Program 3:
    SKIP 25
    READ LGN2.DAT Y
    SET WRITE DECIMALS 4
    LOGNORMAL CONFIDENCE LIMITS Y

-----CONTINUE CHARACTER------------------------------------------------
 
CONTINUE CHARACTER
 
Name:
    CONTINUE CHARACTOR
 
Type:
    Support Command
 
Purpose:
    Specifies the character that upon occurrence in subsequent command
    lines will continue the command onto the next command statement.
    Thus a command can be spread over 2 lines.
 
Syntax:
    CONTINUE CHARACTER   <character>
    where <character> is one or more characters.  Only the first four
    characters are significant.
 
Examples:
    CONTINUE CHARACTER #
    CONTINUE CHARACTER \
    CONTINUE CHARACTER @
 
Note:
    The CONTINUE CHARACTER with no arguments sets the terminator
    character to default.
 
Note:
    Commands are currently limited to a maximum of two lines.
 
Note:
    Loops only store the first 80 characters of a command.  Continued
    lines are treated as a single command, so only the first 80
    characters of the initial line and the continued line are stored.
 
Default:
    The default terminator character is ... (3 periods with no spaces).
 
Synonyms:
    None
 
Related Commands:
    SUBSTITUTE CHARACTER      = Define the substitute character.
    TERMINATOR CHARACTER      = Define the terminator character.
 
Applications:
    XX
 
Implementation Date:
    89/2
 
Program:
    XX
 
-----CONTINUOUS-------------------------------------------------------
 
CONTINUOUS
 
Name:
    CONTINUOUS
 
Type:
    Output Device Command
 
Purpose:
    Specifies that output device 1 (the terminal) is continuous (i.e.,
    it can produce hardware-generated lines).
 
Description:
    If a CONTINUOUS command is entered, the detailed terminal
    specifications revert to their default values.  Thus the CONTINUOUS
    command is identical to the TEKTRONIX 4014 command, or the DEVICE 1
    TEKTRONIX 4014 command.  The last 2 commands are preferred (because
    they are more specific) than simply using the CONTINUOUS command.
 
Syntax:
    CONTINUOUS   <ON or OFF>
    where ON specifies that the device is continuous while OFF
    specifies that it is not.
 
Examples:
    CONTINUOUS ON
    CONTINUOUS
    CONTINUOUS OFF
 
Default:
    Device 1 is a Tektronix terminal, device 2 is off, and device 3 is
    a Postscript printer.
 
Synonyms:
    Entering CONTINUOUS or CONTINUOUS ON is equivalent to:
       TEKTRONIX 4014
       DEVICE 1 TEKTRONIX 4014
       DISCRETE OFF
       BATCH OFF
    Entering CONTINUOUS OFF is equivalent to:
       DISCRETE
    These forms of the command are more commonly used than the
    CONTINUOUS command.
 
Related Commands:
    BATCH      = Sets the terminal to batch.
    DISCRETE   = Sets the terminal to discrete.
    TEKTRONIX  = Sets the terminal to a Tektronix model.
    HP         = Sets the terminal to an HP model.
    GENERAL    = Sets the terminal to a DATAPLOT metafile.
    DEVICE     = Sets the device manufacturer and model.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XX
 
-----CONTOUR PLOT---------------------------------------------------
 
CONTOUR PLOT
 
Name:
    CONTOUR PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a contour plot.
 
Description:
    A contour plot is a graphical technique for representing a
    3-dimensional z = f(x,y) surface by plotting constant-z "slices"
    (contours) on a 2-dimensional format.  The contour plot is used
    heavily in geographic contouring, topography, and mapping.
 
Syntax:
    CONTOUR PLOT  <z>  <x>  <y>  <z0> <SUBSET/EXCEPT/FOR qualification>
    where <z>  is the response (= dependent) variable;
          <x>  is one horizontal axis variable;
          <y>  is the other horizontal axis variable;
          <z0> is the variable of desired contour values;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    CONTOUR PLOT Z X Y Z0
    CONTOUR PLOT Z X Y Z0 SUBSET DAY 6 TO 10
    CONTOUR PLOT Z X Y Z0 SUBSET Z < 10
 
Note:
    The contour command has the following limitations:
    1) No contour level labels are automatically generated (you have to
       use the LEGEND command to provide your own).
    2) There is no capability for color or pattern filling between
       contour levels.
    3) The user must specify the desired contour levels (DATAPLOT will
       not automatically set any).
    4) DATAPLOT will not handle irregularly gridded data.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LINES              = Sets the types for plot lines.
    3D-PLOT            = Generates a 3-d data or function plot.
    PLOT               = Generates a data or function plot.
 
Reference:
    The contouring code was adapted from code provided by David
    Behringer of NOAA/AOML in Miami.  NOAA is the National Oceanic and
    Atmospheric Administration.
 
Applications:
    3-Dimensional Analysis
 
Implementation Date:
    88/9
 
Program:
    LET X = SEQUENCE -4 1 4 FOR I = 1 1 81
    LET Y = SEQUENCE -4 9 1 4
    LET Z = X**2+Y**2-X*Y
    LET Z0 = SEQEUNCE 5 5 40
    CONTOUR PLOT Z X Y Z0
 
-----CONTROL CHART-----------------------------------------------
 
CONTROL CHART
 
Name:
    ... CONTROL CHART
 
Type:
    Graphics Command
 
Purpose:
    Generates the following types of univariate control charts:

        1) Mean (or xbar)
        2) Range (or R)
        3) Standard deviation (or S)

        4) Moving average
        5) Moving range 
        6) Moving standard deviation

        7) Cumulative sum (or CUSUM)
        8) Exponentially weighted moving average (or EWMA)

        9) Binomial proportion (or P)
       10) Binomial counts (or NP)
       11) Poisson counts for constant area and equal sub-group sizes
           (or C)
       12) Poisson counts where area or sub-group sizes are not
           neccessarily equal (or U)

       13) ISO 13528

Description:
    A control chart, introduced by Walter Shewart, is a data analysis
    technique for determining if a measurement process has gone out of
    statistical control.  For continuous data, most of the standard
    control charts attempt to detect either a change in location or a
    change in variation.  The binomial and Poisson control charts have
    been developed for the cases when the data consist of proportions or
    counts rather than a continuous response variable.

    For each of the supported control charts, limits have been determined
    for signaling when a response is "out of control".  That is, if the
    points on the control chart are within the control limits, the data
    is considered "in control".  When a point is outside these control
    limits, the data is considered "out of control" and the process
    should be examined to determine the cause.

    In developing the control limits, an effort is made to balance quick
    detection while minimizing "false positives" (i.e., signaling that a
    process is out of control when it is in fact still in control).  Quick
    detection is desired to minimize the number of potentially bad units
    produced.  Minimizing false positives is desired since shutting down
    the process can result in unnecessarily lost production (and possibly
    significant cost).

    The mean control chart is the most commonly used control chart for
    detecting a change in location.  The CUSUM and EWMA charts were
    developed to detect small shifts of location.

    The standard deviation control chart and range control chart are the
    primary control charts for detecting a change in the variability of
    a process.

    Typically, the data for control charts is divided into batches
    (sub-groups) and the appropriate statistic is computed and plotted
    for each sub-group.  The MOVING control charts are used for the case
    when the data are not divided into sub-groups.

    The ISO control chart is a variant of control charts used in the
    ISO 13528 standard for proficiency studies for multiple rounds.

    There is separate documentation for the mean, standard deviation,
    range, cusum, ewma, and the various proportion and counts control
    charts.  This documentation may contain more details for that
    specific type of control chart.

    The control chart consists of:

       Vertical   axis = the mean, range, standard deviation, or other
                         appropriate statistic for each sub-group;
       Horizontal axis = sub-group designation.
 
    In addition, horizontal lines are drawn at the mean (i.e., the mean
    of the means, ranges, standard deviations, or other appropriate
    statistic) and at the upper and lower control limits.

Syntax 1:
    <MEAN/RANGE/S/CUSUM/EWMA> CONTROL CHART  <y>  <x>
                              <SUBSET/EXCEPT/FOR qualification>
    where <stat> is one of XBAR (or MEAN), R (or RANGE), S (or SD),
          CUSUM, or EWMA;
          <y> is the response variable;
          <x> is a variable containing the sub-group identifications;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    Enter one of MEAN, RANGE, S, CUSUM, or EWMA to specify what type of
    control chart to generate.
 
Syntax 2:
    MOVING <stat> CONTROL CHART <y>   <SUBSET/EXCEPT/FOR qualification>
    where <stat> is one of AVERAGE, RANGE, or STANDARD DEVIATION;
          <y> is the response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 3:
    <P/NP> CHART  <y>  <size>  <x>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable containing the number of
              defectives for each sub-group;
          <size> is a variable containing the sample size for each
              sub-group;
          <x> is a variable containing the sub-group identifications;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    If P is specified, then the percentage of defectives is plotted.  If
    NP is specified, then the number of defectives is plotted.
 
Syntax 4:
    C CHART  <y>  <x>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable containing the number of
              defectives for each sub-group;
          <x> is a variable containing the sub-group identifications;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    The C chart is used for Poisson counts.  For the Poisson counts case,
    you can have either an area of material that is being inspected or a
    sample size.   The C chart is used when the sub-groups have constant
    area (or equal sample size).

Syntax 5:
    U CHART  <y>  <area>  <x>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable containing the number of
              defectives for each sub-group;
          <area> is a variable containing the sample size or area
              adjustment for each sub-group;
          <x> is a variable containing the sub-group identifications;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    The U chart is used for Poisson counts.  For the Poisson counts case,
    you can have either an area of material that is being inspected or a
    sample size.   The U chart is used when the sub-groups have unequal
    area (or unequal sample size).

Syntax 6:
    ISO 13528 CONTROL CHART  <y>  <x>
                             <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <x> is a variable containing the sub-group identifications;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This is a variant of the mean control chart.  This chart is
    constructed as follows:

      1. Use a z-score for the response variable.  Since the ISO 13528
         standard allows several variants of the z-score (e.g., you may
         use a reference value rather than the sample mean in computing
         the z-score), it is assumed that the response variable is
         already a z-score (i.e., the z-score will not automatically be
         computed from the raw data).

      2. If there is replication, compute a mean for each group.  If there
         is no replication, just use the single data value as the estimate
         of the mean.

      3. Control limits are set at +/-2 and +/- 3.

    For the ISO 13528 control chart, the sub-groups are typically the
    different laboratories.  The ISO 13528 control chart is used to
    identify laboratories that are not consistent with the other
    laboratories in the proficiency study.

Examples:
    MEAN CONTROL CHART Y X
    RANGE CONTROL CHART Y X
    S CONTROL CHART Y X
    MOVING AVERAGE CONTROL CHART Y X
 
Note:
    Control charts were introduced as an alternative to acceptance
    sampling.  In acceptance sampling, some sample of units are inspected
    after production.  Then based on the number of defective units,
    the entire lot is either accepted or rejected.

    One of the motivations for control charts is to detect problems
    during production rather than after production.  That is, if a
    production problem can be detected early, then this can help
    minimize the number of defective units produced.

Note:
    Dataplot normally sets the control limits automatically.
    However, you can enter your own control limits if you wish.
    This is usually based on historical data or specific engineering
    requirements.  User control limits are entered with the 
    commands:

       LET TARGET = <value>
       LET USL = <value>
       LET LSL = <value>

    This sets the target value, the upper control limit, and the
    lower control limit respectively.

Note:
    For the mean, range, standard deviation, cusum, and EWMA control
    charts, the response variable is assumed to follow an approximately
    normal distribution.  This assumption is the basis for calculating
    the upper and lower control limits.
 
Note:
    You can control the appearance of this chart by setting the switches
    for the LINE, CHARACTER, SPIKE, and BAR commands appropriately.
    Specifically, for the mean, range, and standard deviation control
    charts,

         Trace 1  = the value of the statistic for each sub-group
         Trace 2  = the mean of the statistic over the sub-groups
         Trace 3  = the Dataplot calculated upper control limit
         Trace 4  = the Dataplot calculated lower control limit
         Trace 5  = the user-specified target value
         Trace 6  = the user-specified upper control limit
         Trace 7  = the user-specified lower control limit

    For example, some analysts prefer to draw the value of the statistic
    as a character or spike rather than a connected line.  If you
    include both Dataplot calculated and user-specified limits, you may
    want to draw them with different colors or different line styles.

    For the other control charts, the documentation for the specific
    control charts provides a similar listing for the mapping of
    traces to chart features.  These may vary somewhat from the
    above list.

Note:
    The control charts documented here are univariate control
    charts.  That is, they monitor a single response variable.

    The HOTELLING CONTROL CHART can be used to simultaneously
    monitor multiple response variables for a shift in location.
    Although you can monitor multiple response variables with
    individual mean control charts, this assumes that the
    response variables are independent.  The Hotelling control
    chart takes the correlation structure into account.

Note:
    There have been numerous proposals for signaling when a process is
    out of control.  For the mean, range, and standard deviation
    control charts, critierion developed by Western Electric have
    some popularity.  These rules are as follow:

        1. Any point > 3*sigma or < 3*sigma

        2. a. Two of the last threee points > 2*sigma
           b. Two of the last threee points < 2*sigma

        3. a. Four of the last five points > 1*sigma
           b. Four of the last five points < 1*sigma

        4. Eight consecutive points above the center line or eight
           consecutive points below the center line

    The command 

        SET CONTROL CHART LIMITS <DEFAULT/WECO/ISO 13528>

    can be used to specify the control limits used.  DEFAULT uses
    the standard control chart limits.  WECO uses the Western
    Electric guidlines.  ISO 13528 uses the +/-2 and +/-3 limits
    (this assumes the response variable has been transformed to a
    z-score).

    Note that the if the WECO rules are turned on, the following
    is done:

       1. The standard control limits are drawn (traces 2, 3, and 4).

       2. The individual plot points that signal an out of control
          point according to the WECO rules are drawn using trace 5.
          So you can control how these points are drawn by setting
          the attributes for trace 5.  This is demonstrated in
          the Program 3 example below.

    The WECO rules have been criticized for generating too many
    false positives.

Note:
    In some situations, you may want to highlight certain points
    on the control chart.  For example, you may want to flag
    points that are outside the control limits or you may want
    to flag a particular sub-group (e.g., if a new batch of data
    is being added to historical data, you may want to emphasize
    the new data).

    The 2012/02 version added the HIGHLIGHT option.  This is
    demonstrated in the Program 2 example below.

Default:
    None
 
Synonyms:
    XBAR CONTROL CHART for MEAN CONTROL CHART
    STANDARD DEVIATION CONTROL CHART for S CONTROL CHART
 
Related Commands:
    XBAR CHART              = Generate a mean control chart.
    R CHART                 = Generate a range control chart.
    S CHART                 = Generate a standard deviation control chart.
    CUSUM CONTROL CHART     = Generates a mean cusum control chart.
    EWMA CONTROL CHART      = Generates a ewma control chart.
    HOTELLING CONTROL CHART = Generates a Hotelling control chart.
    MOVING AVERAGE CHART    = Generates a moving average control
                              chart.
    MOVING RANGE CHART      = Generates a moving range control chart.
    MOVING SD CHART         = Generates a moving sd control chart.
    C CHART                 = Generates a C control chart.
    U CHART                 = Generates a U control chart.
    P CHART                 = Generates a P control chart.
    NP CHART                = Generates an Np control chart.
    CHARACTERS              = Sets the types for plot characters.
    LINES                   = Sets the types for plot lines.
    SPIKES                  = Sets the on/off switches for plot spikes.
    BARS                    = Sets the on/off switches for plot bars.
    PLOT                    = Generates a data or function plot.
    LAG PLOT                = Generates a lag plot.
    4-PLOT                  = Generates a 4-plot for univariate
                              analysis.
    ANOP PLOT               = Generates an ANOP plot.
 
References:
    Walter Shewart (1931), "Economic Control of Quality of Manufactured
    Product", Van Nordstrom.

    Kaoru Ishikawa (1982), "Guide to Quality Control," Asian
    Productivity Organization, (Chapter 7).

    Thomas Ryan (1989), "Statistical Methods for Quality Improvement",
    Wiley.

    Douglas Montgomery (2001), "Introduction to Statistical Quality
    Control", Fourth Edition, Wiley.

    ISO 13528 (2005), "Statistical Methods for use in proficiency
    testing by interlaboratory comparisons," First Edition,
    2005-09-01.

Applications:
    Quality Control
 
Implementation Date:
    Pre-1987
    1988/01: Support for P, PN, U, and C charts
    1990/07: Support for user specified control limits
    1997/03: Support for CUSUM and EWMA charts
    1997/03: Support for moving average, moving range and
             moving standard deviation charts
    2012/01: Support for highlighting option
    2012/01: Support for WECO and ISO 13528 control limits
    2012/02: Support for ISO 13528 control chart
 
Program 1:
    SKIP 25
    READ CROARK3.DAT Y X
    .
    MULTIPLOT CORNER COORDINATES 2 2 98 98
    MULTIPLOT SCALE FACTOR 2
    MULTIPLOT 2 2
    TITLE CASE ASIS
    CASE ASIS
    TITLE OFFSET 2
    LINE BLANK SOLID DASH DASH DOTT DOTT
    CHARACTER CIRCLE
    CHARACTER FILL ON
    CHARACTER HW 1 0.75
    .
    YLIMIT 0.5 0.6
    MAJOR YTIC MARK NUMBER 6
    Y1TIC MARK LABEL DECIMAL 2
    XLIMITS 0 100
    X1TIC MARK OFFSET 0 20
    TITLE Raw Data
    PLOT Y
    .
    YLIMIT
    MAJOR YTIC MARK NUMBER
    Y1TIC MARK LABEL DECIMAL
    XLIMITS 0 40
    X1TIC MARK OFFSET 0 0
    TITLE Mean Control Chart
    MEAN CONTROL CHART Y X
    .
    TITLE Range Control Chart
    RANGE CONTROL CHART Y X
    .
    TITLE SD Control Chart
    STANDARD DEVIATION CONTROL CHART  Y X
    .
    END OF MULTIPLOT
    MOVE 50 98
    JUSTIFICATION CENTER
    TEXT Control Charts for Magnification Standard for SEMs (CROARK3.DAT)
    MOVE 50 2
    TEXT Batch
    DIRECTION VERTICAL
    MOVE 2 50
    TEXT Distance (Micrometers)
    DIRECTION HORIZONTAL

Program 2:
    SKIP 25
    READ CROARK3.DAT Y X
    LET N = SIZE Y
    LET TAG = 0 FOR I = 1 1 N
    LET TAG = 1 SUBSET Y > 0.58
    .
    SET WRITE DECIMALS 3
    LABEL CASE ASIS
    CASE ASIS
    TITLE Magnification Standard for SEMs
    Y1LABEL Distance (Micrometers)
    XLIMITS 0 40
    X3LABEL AUTOMATIC
    LINE SOLID SOLID DASH DASH BLANK
    CHARACTER BLANK BLANK BLANK BLANK CIRCLE
    CHARACTER FILL ON ALL
    CHARACTER HW 1 0.75 ALL
    CHARACTER COLOR RED ALL
    .
    HIGHLIGHT MEAN CONTROL CHART Y X TAG
    .
    LET TAG = 0 FOR I = 1 1 N
    LET TAG = 1 SUBSET Y > 0.58
    LIMITS
    XLIMITS 0 100
    XTIC MARK OFFSET 0 10
    HIGHLIGHT MOVING MEAN CONTROL CHART Y TAG

Program 3:
    LET X = SEQUENCE 1 10 1 50
    LET Y = NORMAL RANDOM NUMBERS FOR I = 1 1 500
    LET Y2 = Y
    LET Y2 = 7*Y  FOR I = 351 1 425
    LET Y = Y2
    .
    SET WRITE DECIMALS 3
    LABEL CASE ASIS
    CASE ASIS
    Y1LABEL Normal Random Numbers
    TITLE AUTOMATIC
    LINE SOLID SOLID DASH DASH BLANK
    CHARACTER BL BL BL BL CIRCLE
    CHARACTER FILL ON ALL
    CHARACTER HW 0.5 0.375 ALL
    CHARACTER COLOR RED ALL
    XLIMITS 0 50
    XTIC MARK OFFSET 1 2
    .
    SET CONTROL CHART LIMITS WECO
    MEAN CONTROL CHART Y X
    
Program 4:
    skip 25
    read croark3.dat y roundid
    skip 0
    let n = size y
    . let z = zscore y roundid
    let z = zscore y
    let matid = sequence 1 1 3 for i = 1 1 n
    .
    label case asis
    y1label z-score
    x1label batch
    xlimits 0 35
    x1tic mark offset 0 2
    y1tic mark offset 0.2 0.2
    title case asis
    title offset 2
    title ISO 13528 Control Chart
    line      solid solid dash  dash  dash  dash  blank
    character blank blank blank blank blank blank blank
    character hw 1 0.75 all
    character fill on all
    .
    iso 13528 control chart z roundid
    .
    line      blank solid dash  dash  dash  dash  blank blank blank
    character circl blank blank blank blank blank 1     2     3
    highlight iso 13528 control chart z roundid matid

Program 5:
    . Read data: Year is essentially the round and there are 10
    .            materials.
    skip 25
    read turner.dat labid z year quart matid matave
    skip 0
    .
    . Note that we want to generate the control chart treating
    . laboratory as the "group-id" variable.  Generate a separate
    . plot for each material.
    .
    case asis
    label case asis
    title case asis
    title offset 2
    line blank solid solid solid solid solid blank
    line color black black blue blue red red black
    character circle blank blank blank blank blank blank
    character hw 1 0.75 all
    character fill on all
    .
    multiplot corner coordinates 2 2 98 98
    multiplot scale factor 3
    multiplot 3 4
    .
    xlimits 0 90
    major xtic mark number 4
    ylimits -4 4
    major ytic mark number 5
    let nmat = unique matid
    loop for k = 1 1 nmat
        title Material ^k
        iso 13528 control chart z labid subset matid k
    end of loop
    end of multiplot
    .
    justification center
    move 50 98
    text ISO 13528 Control Chart for TURNER.DAT
    move 50 2
    text Laboratory
    direction vertical
    move 2 50
    text Z-Score

Program 6:
    . Step 1:   Read the data
    .
    dimension 40 columns
    skip 25
    read turner.dat labid z year quarter matid matave
    let roundid = year
    skip 0
    .
    . Step 2:   Set plot control settings
    .
    case asis
    label case asis
    title case asis
    title offset 2
    .
    y1label z-score
    x1label Laboratory ID
    xlimits 0 90
    x1tic mark offset 2 0
    ytic mark offset 0.2 0.2
    .
    line      blank solid solid solid solid solid blank
    line color black black blue blue red red black
    character circle blank blank blank blank blank blank
    character hw 1 0.75
    character fill on
    .
    . Step 3:   Generate 13528 Control Charts
    .
    title ISO 13528 Control Chart - Combine Materials
    iso 13528 control chart z labid
    .
    line      solid solid dash  dash  dash  dash  blank
    character blank blank blank blank blank blank circle
    title ISO 13528 Control Chart - Show Individual Materials
    iso 13528 control chart z labid
    .
    line blank all
    line      solid solid dash  dash  dash  dash
    character blank blank blank blank blank blank 1 2  3 4 5 6 7 8 9 10
    title ISO 13528 Control Chart - Identify Materials
    highlight iso 13528 control chart z labid matid

-----CONVERT CHARACTER (SET)----------------------------------------
 
CONVERT CHARACTER (SET)
 
Name:
    CONVERT CHARACTER (SET)
 
Type:
    Subcommand under SET
 
Purpose:
    Specifies how Dataplot will handle character data.
 
Description:
    In versions of Dataplot prior to January, 2004, Dataplot did not
    support reading character variables in data files.  The one
    execption was the READ ROW LABELS command (HELP READ ROW LABELS
    for details).  If encountered, Dataplot would generate an error
    message and not read the data file correctly.  To address
    this, we have added the command
 
        SET CONVERT CHARACTER <ON/CATEGORICAL/IGNORE/ERROR>
 
    These options result in the following actions:

       1) Specifying ERROR continues the current Dataplot action of
          reporting an error.  This is recommended for the case
          when a file is suppossed to contain only numeric data
          and the presence of character data is in fact indicative
          of an error in the data file.

          To maintain compatibility with previous versions of
          Dataplot, this is the default setting.

       2) Specifying IGNORE instructs Dataplot to simply ignore any
          fields containing character data.  No error or warning
          messages are printed.

       3) Specifying ON instructs Dataplot to read character.
          The character fields are written to the file
          "dpzchf.dat" in the current directory.

          The first line of this file specifies the number of
          character fields.  Lines 2 thru N+1 (with N denoting
          the number of character fields) identify the names
          of the character variables.  Each of the remaining lines
          contain the character fields for one row of character
          data.  Each character variable is written as 24 
          characters (character fields with more than 24 characters
          are truncated and those with less than 24 characters
          are right-padded with spaces) followed by one space.

          As with numeric variables, character variable names can
          be up to eight characters long.  Note that Dataplot does
          not save the character variable names in its internal
          name table (they are only saved in the "dpchzf.dat"
          file).  Be aware that the "dpchzf.dat" file is overwritten
          each time a file with character data is encoutered.

       4) This is similar to SET CONVERT CHARACTER ON.  However, in
          addition to creating the character variable, it will create
          a numeric variable that converts the unique values of the
          character field to an integer code.  Currently, the code values
          are assigned in the order that the unique values are detected
          in the file.  Up to 1,000 levels are supported (if more than
          1,000 levels are required, the remaining levels are all set
          to "-1").

          Note that there will be both a numeric variable and a character
          variable (in dpzchf.dat) with the same name.  The context of
          how the variable name is used determines whether the numeric or
          character variable is being referred to (i.e., there are a
          limited number of commands that specifically refer to the
          character variables).

    There are some restrictions on when Dataplot will try to
    read character data:
 
       1) This only applies to the variable read case.  That
          is, READ PARAMETER and READ MATRIX will ignore
          character fields or treat them as an error.
 
       2) Dataplot will only try to read character data from
          a file.  When reading from the keyboard (i.e., when
          READ is specified with no file name), character data
          will be ignored when a SET CONVERT CHARACTER ON is
          specified.
 
       3) This capability is not supported for the SERIAL READ
          case.
 
       4) The SET READ FORMAT command does not accept the
          "A" format specification for reading character
          fields.

    Some of these restrictions may be addressed in subsequent
    releases of Dataplot.

Syntax:
    SET CONVERT CHARACTER  <ON/CATEGORICAL/IGNORE/ERROR>
    where <ON> specifies that character data will be read and saved in
               dpchzf.dat, CATEGORICAL is similar to ON but will also
               create a numeric categorical variable, IGNORE specifies
               that character data will be ignored, and ERROR specifies
               that character data will be treated as an error.
 
Examples:
    SET CONVERT CHARACTER ON
    SET CONVERT CHARACTER CATEGORICAL
    SET CONVERT CHARACTER IGNORE
    SET CONVERT CHARACTER ERROR
 
Note:
    If the ON or CATEGORICAL options are used, you can specify one of
    the variables to be the row label variable with the command

        SET ROW LABEL COLUMN <ival>

    where <ival> is an integer value that specifies which column of the
    data is a row label variable.  The values in this column are stored
    in the internal row label variable.  This is demonstrated in the
    Program 2 example below.  Although a row label variable is typically
    the first column, this is not required.

Note:
    In recognizing character data, Dataplot treats certain
    characters as delimiters:

       spaces    (non-printing characters, such as tabs, are treated
                 as spaces)
       commas
       : or ;
       %
       / or \
       [ or ]
       ( or)

    If Dataplot encounters one of these characters in a character
    field, it treats it as the end of the character field (the
    delimiter will not be part of the string.

    If you have character data that will contain one or more of
    these delimiters, then the character fields need to be
    enclosed in quotes (either single or double quotes may
    be used).  If the character fields may contain quotes,
    then use one type (i.e., single or double) as the delimiter
    and the other type in the character field.  At the current
    time, Dataplot will not accomodate both types of quotes
    in the character fields.

Note:
    Dataplot supports a limited number of commands that can
    utilize the character data saved in "dpchzf.dat".  As of
    the January, 2004 version, this includes

        LET Y = CHARACTER CODE IX
        LET Y = ALPHABETIC CHARACTER CODE IX
        LET IG = GROUP LABELS IX
        LET ROWLABEL = IX

    The TIC MARK LABEL FORMAT and TIC MARK LABEL CONTENT commands
    have been updated to use group labels for the tic mark labels.

    For details, enter

        HELP CHARACTER CODE
        HELP ALPHABETIC CHARACTER CODE
        HELP GROUP LABELS
        HELP ROWLABEL
        HELP TIC MARK LABEL FORMAT
        HELP TIC MARK LABEL CONTENT

    We anticipate additional use will be made of character data
    in subsequent versions of Dataplot.

Default:
    ERROR (character data will be treated as an error)
 
Synonyms:
    None
 
Related Commands:
    READ                        = Carries out a column-wise input of data.
    CHARACTER CODE              = Converts character data to a coded
                                  numeric variable.
    GROUP LABELS                = Define group labels from character data.
    ROW LABEL                   = Define row labels from character data.
 
Applications:
    Input/Output
 
Implementation Date:
    2004/01
    2018/07: Support for CATEGORICAL option
 
Program 1:
    set convert character on
    skip 25
    read draft69c.dat rank day month
    .
    let ig = group label month
    x1tic mark label format group label
    x1tic mark label content ig
    x1tic mark label font simplex
    x1tic mark label angle 45
    x1tic mark label displacement 10
    let xcode = character code month
    .
    major xtic mark number 12
    minor xtic mark number 0
    xlimits 1 12
    xtic offset 0.5 0.5
    .
    char box plot
    line box plot
    fences on
    .
    box plot rank xcode
 
Program 2:
    SET CONVERT CHARACTER CATEGORICAL
    SET ROW LABEL COLUMN 1
    READ TEST_CHAR.DAT IROW Y X1 X2
    .
    SET WRITE DECIMALS 1
    WRITE ROWLABEL Y X1 X2

-----CONVEX HULL-------------------------------------------------------
 
CONVEX HULL
 
Name:
    CONVEX HULL
 
Type:
    LET Subcommand
 
Purpose:
    Compute the 2-dimensional convex hull of a set of points.
 
Description:
    The 2-dimensional convex hull of a set of 2-dimensional
    points are the vertices that form the minimum area convex
    polygon that contains all of the points.

Syntax:
    LET <y2> <x2> = CONVEX HULL  <y>  <x>
                    <SUBSET/EXPCEPT/FOR qualification>
    where <y> is a variable containing the y-coordinates of
               the full data set;
          <x> is a variable containing the x-coordinates of
               the full data set;
          <y2> is a variable that will contain the y-coordinats
               of the returned convex hull;
          <x2> is a variable that will contain the x-coordinats
               of the returned convex hull;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y2 X2 = CONVEX HULL Y X
    LET Y2 X2 = CONVEX HULL Y X  SUBSET X > 0 SUBSET Y > 0
 
Note:
    Dataplot uses Eddy's CONVEX routine given in ACM algorithm 523 to
    compute the convex hull.  The algorithm is described in the
    references given below.

Default:
    None.
 
Synonyms:
    None
 
Related Commands:
    MINIMAL SPANNING TREE   = Determine the minimal spanning tree.
    SPAINNING FOREST        = Determine the spanning forest.
 
References:
    W. F. Eddy (1977), "A New Convex Hull Algorithm for Planar Sets",
    ACM Transactions on Mathematical Software (TOMS), Vol. 3, No. 4,
    pp. 398-403.

    W. F. Eddy (1977), "Algorithm 523: CONVEX, A New Convex Hull
    Algorithm for Planar Sets", ACM Transactions on Mathematical
    Software (TOMS), Vol. 3, No. 4, pp. 411-412.

    O'Rourke (1998), "Computational Geometry in C", Second Edition,
    Cambridge Unversity Press, Chapter 3.

Applications:
    Computational Geometry
 
Implementation Date:
    2008/4
 
Program:
    .  Following data from Eddy's ACM article
    read x y
    2.0       0.0
    1.73      -1.0
    1.0       1.73
    0.0       2.0
    0.1       0.1
    -1.0      -1.73
    0.2       -0.2
    -1.73     1.0
    -0.3      0.3
    0.0       -2.0
    -0.4      -0.4
    -2.0      0.0
    0.5       0.5
    1.73      1.0
    0.6       -0.6
    -1.0      1.73
    -0.7      0.7
    -1.73     -1.0
    -0.8      -0.8
    1.0       -1.73
    end of data
    .
    let y2 x2 = 2d convex hull y x
    let n = size y
    let id = sequence 1 1 n
    .
    title case asis
    title offset 2
    title Convex Hull
    y1label Y
    x1label X
    tic offset units screen
    tic offset 3 3
    x3label
    .
    character automatic id
    line blank all
    .
    plot y x id
    line so
    line color blue
    char blank all
    pre-erase off
    limits freeze
    pre-sort off
    let n2 = size y2
    let n2 = n2 + 1
    let y2(n2) = y2(1)
    let x2(n2) = x2(1)
    plot y2 x2
  
-----CONVOLUTION (LET)--------------------------------
 
CONVOLUTION
 
Name:
    CONVOLUTION (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the numerical convolution of two variables.
 
Description:
    Mathematically, the convolution of 2 continuous distributions g and
    h is defined as:
       g*h = Indefinite integral of g(tau)h(t-tau)dtau
    In practice, h is typically a data stream while g is a response
    function.  The response function is typically peaked function that
    goes to zero in both directions from that peak.  The effect of
    convolution is to smear the data stream with the response function.
 
    DATAPLOT computes the convolution from the functions sampled at
    discrete points (see the sample program for an example of how to
    evaluate a function at a discrete set of points).  This is referred
    to as discrete convolution.  If Y1 and Y2 are the sampled
    functions, then DATAPLOT computes the convolution as:
        Y3(1) = Y1(1)*Y2(1)
        Y3(2) = Y1(1)*Y2(2) + Y1(2)*Y2(1)
        Y3(3) = Y1(1)*Y2(3) + Y1(2)*Y2(2) + Y1(3)*Y2(1)
        etc.
 
Syntax:
    LET <y3> = CONVOLUTION <y1> <y2>  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <y3> is a variable containing the computed convolution values
              (it typically contains more points than <y1> and <y2>);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y3 = CONVOLUTION Y1 Y2
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    INTEGRAL        = Compute a numerical integral.
    ROOT            = Compute roots of an equation.
    DECONVOLVE      = Compute the discrete deconvolution of two
                      variables.
    FOURIER TRANS   = Compute the Fourier transform of two variables.
    FFT             = Compute the Fast Fourier Transform of two
                      variables.
 
Reference:
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", Press, Flannery, Teukolsky, and Vetterling.  Cambridge
    University Press, 1989 (chapter 12).
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    LET FUNCTION F1 = ((X+1)**2)/((X**2)+1)/2
    LET FUNCTION F2 = 2**((-(X+1.3/2)**2)/(A**2))- ...
       2**((-(X-1.3/2)**2)/(A**2))
    LET A = 0.85
    .
    LET XMIN = -7
    LET XINC = .1
    LET XMAX = 7
    LET X = SEQUNECE XMIN XINC XMAX
    .
    LET Y1 = F1
    LET Y2 = F2
    LET Y3 = CONVOLUTION Y1 Y2
    LET Y3 = Y3*XINC
    .
    LET X3MIN = 2*XMIN
    LET X3MAX = 2*XMAX
    LET X3 = SEQUENCE X3MIN XINC X3MAX
    .
    LINES SOLID SOLID DOTTED
    PLOT Y1 Y2 VS X AND
    PLOT Y3 VS X3
 
-----COPY-------------------------------------------------------
 
COPY
 
Name:
    COPY
 
Type:
    Support Command
 
Purpose:
    Copy all, or specified lines, of one file to another file.
 
Syntax 1:
    COPY  <file1>  <file2>
    where <file1> is the name of the file to be copied;
    and   <file2> is the name of the file to be copied to.
 
    This syntax copies all lines in <file1> to <file2>.
 
Syntax 2:
    COPY  <file1>  <file2>  FOR I = <start> <inc> <stop>
    where <file1> is the name of the file to be copied;
          <file2> is the name of the file to be copied to.
          <start> specifies the first line in <file1> to copy;
          <inc>   specifies the increment between lines in <file1> to
                  copy (this is almost always 1);
    and   <stop> specifies the last row in <file1> to copy.
 
    This syntax is useful for copying selected parts of a file.
 
Syntax 3:
    COPY  SYSTEM <file1>  <file2>
    where <file1> is the name of the file to be copied;
    and   <file2> is the name of the file to be copied to.
 
    This syntax specifies that an operating system command should be
    used to perform the copy.  Specifically, on Linux/Unix and MacOS
    platforms the "cp" command will be used and on Windows platforms
    the "COPY" command will be used.
 
Examples:
    COPY PLOTCALIB.DAT  TEMP.DAT
    COPY PLOTCALIB.DAT  TEMP.DAT  FOR I = 1 1 40
    COPY SYSTEM PLOTCALIB.DAT TEMP.DAT
 
Note:
    This command performs a line-by-line copy as oppossed to a
    an operating system command copy.  The primary implication is
    that exactly 80 columns are copied to the new file.  This means
    shorter lines are padded with blank spaces and that longer lines
    are truncated.  The advantage is that this format allows partial
    copying of files.  See Syntax 3 for invoking the appropriate
    operating system command to perform the copy.
 
Note:
    If <file2> already exists, it will be overwritten.
 
Note:
    The COPY command was re-defined 1994/06.  In earlier implementations,
    it was used to activate the Tektronix hardcopy unit.  As this
    device is now obsolete, no difficulties should be encountered
    by this re-definition.
 
Note:
    One of the files listed can be CLIPBOARD.  That is, you can copy
    a file to the clipboard or you can copy the clipboard to a file.

    The clipboard capability is currently (2019/03) only supported on
    Windows platforms.  The clipboard capability is not supported for
    the COPY SYSTEM syntax.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    LIST       = Print the contents of the file.
    SEARCH     = Search a file for a given string.
    EDIT       = Edit a file.
    SYSTEM     = Perform an operating system command.
 
Applications:
    File maintenance
 
Implementation Date:
    1994/06
    2014/12: Allow copying to or from the clipboard.
    2019/03: Added the COPY SYSTEM option
 
Program:
    XX
 
-----COPY DELAY-------------------------------------------------------
 
COPY DELAY
 
Name:
    COPY DELAY
 
Type:
    Support Command
 
Purpose:
    Specifies the number of null lines to be transmitted immediately
    after subsequent hardcopying of screen.
 
Description:
    This command is necessary only when the terminal being used has
    an inadequate buffer area.  The net effect of this is that the
    beginning portions of a plot may be destroyed in the hardcopying
    because the hardcopy takes a finite amount of time (typically about
    15 to 30 seconds), and the terminal is receiving and plotting data
    even while the hardcopying is taking place.
 
Syntax:
    COPY DELAY   <n>
    where <n> is a number or parameter that specifies the desired
    number of null lines to be sent.
 
Examples:
    COPY DELAY 50
    COPY DELAY 200
    COPY DELAY
 
Note:
    The COPY DELAY command with no arguments is equivalent to a
    COPY DELAY 1 command.
 
Note:
    Currently, the COPY command (and therefore the COPY DELAY command)
    only applies to the Tektronix 4014 and its related hardcopy unit.
    This command is now rarely used since this hardcopy device is now
    obsolete.
 
Default:
    The default is 1 null line being sent.
 
Synonyms:
    HARDCOPY DELAY
 
Related Commands:
    COPY        = Copies the screen (immediately).
    HARDCOPY    = Sets the automatic copy switch for plots.
    ERASE DELAY = Sets the delay for screen erasure.
    ERASE       = Erases the screen (immediately).
    PRE-ERASE   = Sets the automatic pre-erase switch for plots.
    BAUD        = Sets the baud rate.
 
Applications:
    Obsolete Command
 
Implementation Date:
    Pre-1987
 
Program:
    XX
 
-----CORRELATION (LET)--------------------------------
 
CORRELATION
 
Name:
    CORRELATION (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the correlation coefficient between two variables.
 
Description:
    The correlation coefficient is a measure of the linear relationship
    between two variables.  It is computed as:

         Sxx = SUM[i=1 to N][X(i)-XMEAN]
         Syy = SUM[i=1 to N][Y(i)-YMEAN]
         Sxy = SUM[i=1 to N][(X(i)-XMEAN)*(Y(i)-YMEAN)]
         r = Sxy/SQRT(Sxx*Syy)

    A perfect linear relationship yields a correlation coefficient of
    +1 (or -1 for a negative relationship) and no linear relationship
    yields a correlation coefficient of 0.
 
    It may be of interest to determine if the correlation is significantly
    different than 0.  The CDF value for this test is

         CDF = FCDF(VAL,1,N-2)

    where FCDF is the F cumulative distribution function with 1 and N - 2
    degrees of freedom (N is the number of observations) and
    VAL = ABS((N-2)*R**2/(1 - R**2)) with R denoting the computed
    correlation.  The pvalue is 1 - CDF.

Syntax 1:
    LET <par> = CORRELATION <y1> <y2> <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed correlation is
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    LET <par> = CORRELATION ABSOLUTE VALUE <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the absolute value of the computed
               correlation is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the absolute value of the correlation
    coefficient.  This is typically used in screening applications where
    there is an interest in identifying high magnitude correlations
    regardless of the direction of the correlation.

Syntax 3:
    LET <par> = CORRELATION PVALUE <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed correlation pvalue is
               saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the pvalue (described above) of the correlation.

Syntax 4:
    LET <par> = CORRELATION CDF <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed correlation
               cdf is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the cdf (described above) of the correlation.

Examples:
    LET A = CORRELATION Y1 Y2
    LET A = CORRELATION Y1 Y2 SUBSET TAG > 2
 
Note:
    The two variables must have the same number of elements.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CORRELATION MATRIX          = Generate a correlation matrix.
    RANK CORRELATION            = Compute the rank correlation of two
                                  variables.
    KENDALLS TAU                = Compute the Kendall tau correlation of
                                  two variables.
    WINSORIZED CORRELATION      = Compute the Winsorized correlation of
                                  two variables.
    BIWEIGHT MIDCORRELATION     = Compute the biweight mid-correlation of
                                  two variables.
    PERCENTAGE BEND CORRELATION = Compute the percentage bend correlation
                                  of two variables.
    COVARIANCE                  = Compute the covariance of two variables.
    PARTIAL CORRELATION         = Compute the partial correlation of
                                  three variables.
    PARTIAL CORRELATION MATRIX  = Generate the partial correlation matrix.
    CORRELATION STAT PLOT       = Generate a correlation vs. subset plot.
 
Reference:
    Consult any introductory statistics text.
 
    Peavy, Bremer, Varner, Hogben (1986), "OMNITAB 80:
    An Interpretive System for Statistical and Numerical
    Data Analysis," NBS Special Publication 701.

Applications:
    Linear Regression
 
Implementation Date:
    Pre-1987
    2011/08: CORRELATION ABSOLUTE VALUE added
    2012/06: CORRELATION PVALUE and CORRELATION CDF added
 
Program 1:
    SKIP 25
    READ BERGER1.DAT Y X
    LET CORR = CORRELATION Y X
    LET PVAL = CORRELATION PVALUE Y X
    LET CDF  = CORRELATION CDF Y X
 
Program 2:
    SKIP 25
    READ IRIS.DAT Y1 Y2 Y3 Y4 TAG
    .
    TITLE CASE ASIS
    TITLE OFFSET 2
    LABEL CASE ASIS
    TIC MARK OFFSET UNITS DATA
    Y1LABEL Correlation
    YLIMITS 0 1
    MAJOR YTIC MARK NUMBER 6
    MINOR YTIC MARK NUMBER 1
    Y1TIC MARK LABEL DECIMAL 1
    Y1LABEL DISPLACEMENT 20
    X1LABEL Species
    XLIMITS 1 3
    MAJOR XTIC MARK NUMBER 3
    MINOR XTIC MARK NUMBER 0
    XTIC MARK OFFSET 0.3 0.3
    X1LABEL DISPLACEMENT 14
    CHARACTER X BLANK
    LINES BLANK SOLID
    .
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT SCALE FACTOR 2
    MULTIPLOT 2 3
    .
    TITLE Sepal Length vs Sepal Width
    CORRELATION PLOT Y1 Y2 TAG
    .
    TITLE Sepal Length vs Petal Length
    CORRELATION PLOT Y1 Y3 TAG
    .
    TITLE Sepal Length vs Petal Width
    CORRELATION PLOT Y1 Y4 TAG
    .
    TITLE Sepal Width vs Petal Length
    CORRELATION PLOT Y2 Y3 TAG
    .
    TITLE Sepal Width vs Petal Width
    CORRELATION PLOT Y2 Y4 TAG
    .
    TITLE Petal Length vs Petal Width
    CORRELATION PLOT Y3 Y4 TAG
    .
    END OF MULTIPLOT
 
-----CORRELATION CONFIDENCE LIMITS--------------------------------------
 
CORRELATION CONFIDENCE LIMITS
 
Name:
    CORRELATION CONFIDENCE LIMITS
 
Type:
    Analysis Command
 
Purpose:
    Generates a confidence interval for the correlation between
    two response variables based on Fisher's normal approximation.
 
Description:
    The confidence interval, r, for the correlation between two response
    variables based on Fisher's normal approximation is computed as

        LCL = TANH(Z - NORPPF(1 - ALPHA/2)/SQRT(N-3))
        UCL = TANH(Z + NORPPF(1 - ALPHA/2)/SQRT(N-3))

    with TANH and NORPPF denoting the hyperbolic tangent function and
    the percent point function of the normal distribution, respectively,
    and with N and ALPHA denoting the sample size and the confidence
    level, respectively, and where

        Z = ATANH(r)
          = LOG[(1+r)/(1-r)]/2

    with ATANH denoting the inverse of the hyperbolic tangent function.

Syntax 1:
    CORRELATION CONFIDENCE LIMITS  <y1> <y2>
                                   <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    CORRELATION CONFIDENCE LIMITS  <y1> ... <yk>
                                   <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of 1 to 30 response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used to generate correlation confidence limits
    for all the pairwise combinations of <y1> to <yk>.

Examples:
    CORRELATION CONFIDENCE LIMITS Y1 Y2
    CORRELATION CONFIDENCE LIMITS Y1 TO Y10
    CORRELATION CONFIDENCE LIMITS Y1  SUBSET TAG > 2
 
Note:
    A table of confidence intervals is printed for confidence limits
    of 50.0, 75.0, 80.0, 90.0, 95.0, 99.0, and 99.9.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CORRELATION          = Compute the correlation between two
                           variables.
    CORRELATIION MATRIX  = Compute the correlation matrix of a
                           set of response variables.
    PARTIAL CORRELATION  = Compute the partial correlation between
                           two variables given the effect of a
                           third variable.
 
Reference:
    Peavy, Bremer, Varner, Hogben (1986), "OMNITAB 80:
    An Interpretive System for Statistical and Numerical
    Data Analysis," NBS Special Publication 701.

Applications:
    Linear Regression
 
Implementation Date:
    2012/06
 
Program 1:
    SKIP 25
    READ BERGER1.DAT Y X
    SET WRITE DECIMALS 4
    CORRELATION CONFIDENCE LIMITS Y X
 
Program 2:
    .  This data is from page 202 of
    .
    .  Peavy, Bremer, Varner, Hogben (1986), "OMNITAB 80:
    .  An Interpretive System for Statistical and Numerical
    .  Data Analysis," NBS Special Publication 701.
    .
    .  Original source of the data is from
    .  Draper and Smith (1981), "Applied Regression Analysis",
    .  Wiley, p. 373.
    .
    dimension 40 columns
    .
    read matrix m
    42.2  11.2  31.9  167.1
    48.6  10.6  13.2  174.4
    42.6  10.6  28.7  160.8
    39.0  10.4  26.1  162.0
    34.7   9.3  30.1  140.8
    44.5  10.8   8.5  174.6
    39.1  10.7  24.3  163.7
    40.1  10.0  18.6  174.5
    45.9  12.0  20.4  185.7
    end of data
    .
    set write decimals 4
    correlation confidence limits m1 m2 m3 m4

-----CORRELATION MATRIX (LET)----------------------------------------
 
CORRELATION MATRIX
 
Name:
    CORRELATION MATRIX (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the correlation matrix of a matrix.
 
Description:
    The correlation matrix computes the correlation coefficients of
    the columns of a matrix.  That is, row i and column j of the
    correlation matrix is the correlation between column i and column
    j of the original matrix.  Note that the diagonal elements of the
    correlation matrix will be 1 (since they are the correlation of a
    column with itself).  The correlation matrix is also symmetric
    (since the correlation of column i with column j is the same as the
    correlation of column j with column i).

    Alternatively, you can compute the CDF or the p-value for the
    correlation coefficient (i.e., to see if the correlation coefficient
    is significantly different than zero).

    To see the formulas for the correlation coefficient and the CDF and
    p-values, enter

        HELP CORRELATION

Syntax 1:
    LET <mat2> = CORRELATION MATRIX <mat1>
                 <SUBSET/EXCEPT/FOR qualification>
    where <mat1> is a matrix for which the correlations are to be
                 computed;
          <mat2> is a matrix where the resulting correlations are
                 saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional and
    rarely used in this context.
 
Syntax 2:
    LET <mat2> = CORRELATION CDF MATRIX <mat1>
                 <SUBSET/EXCEPT/FOR qualification>
    where <mat1> is a matrix for which the correlation CDF's are to be
                 computed;
          <mat2> is a matrix where the resulting correlation CDF's are
                 saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional and
    rarely used in this context.
 
    This syntax computes the CDF of the correlation coefficient.

Syntax 3:
    LET <mat2> = CORRELATION PVALUE MATRIX <mat1>
                 <SUBSET/EXCEPT/FOR qualification>
    where <mat1> is a matrix for which the correlation p-value's are to be
                 computed;
          <mat2> is a matrix where the resulting correlation p-values's
                 are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional and
    rarely used in this context.
 
    This syntax computes the p-value of the correlation coefficient.

Examples:
    LET C = CORRELATION MATRIX A
 
Note:
    By default, the correlation matrices are computed on the columns.
    That is, element (i,j) of the correlation matrix is the correlation
    between column i and column j of the input matrix.

    To specify a correlation matrix based on rows rather than columns,
    enter the command 

         SET MATRIX CORRELATION DIRECTION ROW

    To reset column based correlations, enter

         SET MATRIX CORRELATION DIRECTION COLUMN

Note:
    By default the Pearson correlation coefficient is computed.  To specify
    a different type of correlation, enter the command

        SET CORRELATION TYPE <DEFAULT/RANK/WINSORIZED/BIWEIGHT MIDCORRELATION/
                              PERCENTAGE BEND/KENDALL TAU>

    To see the definitions for these, enter

        HELP RANK CORRELATION
        HELP KENDALLS TAU
        HELP BIWEIGHT MIDCORRELATION
        HELP PERCENTAGE BEND

Note:
    Matrices are created with either the READ MATRIX command or the
    MATRIX DEFINITION command.  Enter HELP MATRIX DEFINITION and HELP
    READ MATRIX for details.
 
Note:
    The columns of a matrix are accessible as variables by appending an
    index to the matrix name.  For example, the 4x4 matrix C has
    columns C1, C2, C3, and C4.  These columns can be operated on like
    any other DATAPLOT variable.
 
Note:
    The maximum size matrix that DATAPLOT can handle is set when
    DATAPLOT is built on a particular site.  The default maximums are
    100 columns and 100 rows.
 
Note:
    The September 2016 version of Dataplot added the following commands

         SET CORRELATION ABSOLUTE VALUE <ON/OFF>
         SET CORRELATION PERCENTAGE VALUE <ON/OFF>
         SET CORRELATION DIGITS <VALUE>

    These commands are typically used when plotting the correlation values.
    Specifically, the first command allows you to specify the absolute
    value of the correlation (useful when you are trying to identify
    significant correlation regardless of whether it is a positive or a
    negative correlation).  The second command specifies the correlation
    as a percentage value (e.g., a correlation of 0.91 would be given as
    91.0).  The third command specifies how many digits to store for the
    correlation.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CORRELATION                 = Compute the correlation of two variables.
    RANK CORRELATION            = Compute the rank correlation of two
                                  variables.
    KENDALLS TAU                = Compute the Kendall tau correlation of two
                                  variables.
    WINSORIZED CORRELATION      = Compute the Winsorized correlation of two
                                  variables.
    BIWEIGHT MIDCORRELATION     = Compute the biweight mid-correlation of
                                  two variables.
    PERCENTAGE BEND CORRELATION = Compute the percentage bend correlation of
                                  two variables.
    COVARIANCE                  = Compute the covariance of two variables.
    PARTIAL CORRELATION         = Compute the partial correlation of three
                                  variables.
    PARTIAL CORRELATION MATRIX  = Generate the partial correlation matrix.
 
Applications:
    Linear Fitting
 
Implementation Date:
    87/10
    2002/07: Support for Winsorized correlation, rank correlation, and
             biweight mid-correlation
    2004/11: Support for Kendell tau correlation and for row based
             correlations
    2012/06: Added support for cdf and p-values
    2016/09: Added SET CORRELATION ABSOLUTE VALUE
    2016/09: Added SET CORRELATION PERCENTAGE VALUE
    2016/09: Added SET CORRELATION DIGITS
 
Program:
    .  This data is from page 202 of
    .
    .  Peavy, Bremer, Varner, Hogben (1986), "OMNITAB 80:
    .  An Interpretive System for Statistical and Numerical
    .  Data Analysis," NBS Special Publication 701.
    .
    .  Original source of the data is from
    .  Draper and Smith (1981), "Applied Regression Analysis",
    .  Wiley, p. 373.
    .
    dimension 40 columns
    .
    read matrix m
    42.2  11.2  31.9  167.1
    48.6  10.6  13.2  174.4
    42.6  10.6  28.7  160.8
    39.0  10.4  26.1  162.0
    34.7   9.3  30.1  140.8
    44.5  10.8   8.5  174.6
    39.1  10.7  24.3  163.7
    40.1  10.0  18.6  174.5
    45.9  12.0  20.4  185.7
    end of data
    .
    set write decimals 4
    let corr = correlation matrix m
    print corr
 
-----CORRELATION PLOT-------------------------------------------------
 
CORRELATION PLOT
 
Name:
    ...CORRELATION PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a correlation plot.
 
Description:
    A correlation plot is a graphical data analysis technique for
    determining if correlation exists between:
       1) lags for a single time series (an autocorrelation plot);
       2) lags for a single time series after removing linear
          dependence of intermediate lags (a partial autocorrelation
          plot);
       3) lags for 2 time series (a cross-correlation plot).
    The correlation plot consist of:
       Vertical   axis = correlation coefficient (a value between -1
                         and 1);
       Horizontal axis = lag (an integer between 1 and n/4 where
                         <n> = number of observations).
    In addition, vertical lines are drawn at zero and at levels
    indicating statistically significant correlation.
 
    The autocorrelation plot is used in time series modeling.  It can
    be used in conjunction with the LET and FIT commands to generate
    Box-Jenkins Auto Regressive (AR) models.  It can also be used to
    test for randomness.  The partial autocorrelation plot is used
    (typically with the autocorrelation plot as well) in the model
    identification stage when developing Box-Jenkins ARMA models.
    Cross-correlation is used for the more complex case of analyzing
    two distinct time series to see if they are related.
 
Syntax 1:
    AUTOCORRELATION PLOT    <y>     <SUBSET/EXCEPT/FOR qualification>
    where <y> is a variable that contains the time series observations
              to be analyzed;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 2:
    CROSS-CORRELATION PLOT    <y1>   <y2>
    where <y1> and <y2>  are variables that contain the 2 time series
               observations to be analyzed;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Syntax 3:
    PARTIAL AUTOCORRELATION PLOT <y> <SUBSET/EXCEPT/FOR qualification>
    where <y> is a variable that contains the time series observations
              to be analyzed;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    AUTOCORRELATION Y
    CROSS-CORRELATION Y1 Y2
 
Note:
    The partial autocorrelation of lag k is the autocorrelation between
    z(t) and z(t+k) with the linear dependence of z(t+1) thru (z(t+k-1)
    removed.
 
Note:
    DATAPLOT writes some conclusions derived from the correlation plot
    to the file DPCONF.TEX (the name may vary depending on the
    operating system).  This file is opened when DATAPLOT is initially
    started.  However, only a few commands actually write any
    information to this file.
 
Note:
    After generating an autocorrelation or cross-correlation plot, the
    variable YPLOT contains the numerical values for the correlations.
    If you need to do additional analysis, or simply wish to print the
    numeric values, copy this variable to a user variable (e.g., LET
    CORR = YPLOT).  The YPLOT variable is overwritten when the next
    plot is generated.
 
Note:
    The LINE, CHARACTER, SPIKE, and BAR commands can be used to control
    the appearance of the correlation plot.  For example, some analysts
    prefer to draw correlations as spikes from the zero baseline.
    Trace 1 is the correlation line, trace 2 is the line at zero, and
    traces 3 and 4 are the lines indicating statistical significance.
 
Note:
    The number of lags is determined automatically.  If you want to
    override the default, enter one of the following commands:
        LET LAGS = <value>
        LET LAG = <value>
        LET NUMLAG = <value>
 
Note:
    There are two types of confidence bands that can be generated
    for the autocorrelation plot.

    The first is used for testing white noise (i.e., randomness).  In
    this case, the formula is

        +/- z(1-alpha/2)/SQRT(N)

    where alpha is the desired significance level, z is
    the percent point function of the standard normal
    distribution, and N is the sample size.  In this case,
    the confidence bands have a fixed width.

    The second is used in the context of ARIMA (Box-Jenlins) modeling
    (enter HELP ARMA for information on fitting ARIMA models in
    Dataplot).  The formula is

        +/- z(1-alpha/2)*SQRT((1/N)*(1 + 2*SUM[i=1 to k][Y(i)**2]))

    where alpha is the desired significance level, z is
    the percent point function of the standard normal
    distribution, N is the sample size, and k is the
    desired lag.  In this case, the width of the confidence
    bands increases as the lag, k, increases.

    To specify which confidence limits to use, enter 

        SET AUTOCORRELATION BAND PLOT <WHITE NOISE/BOX-JENKINS>

    The default is WHITE NOISE (i.e., check for randomness).

Note:
    By default, Dataplot generates the lag 0 value for the
    autocorrelation and the partial autocorrelation plots.  Since these
    values are always 1, some users prefer not to include this on the
    plot.  To suppress the lag 0 correlation for either the
    autocorrelation plot or the partial autocorrelation plot, enter

        SET AUTOCORRELATION LAG ZERO OFF

    To restore the lag 0 value, enter

        SET AUTOCORRELATION LAG ZERO ON

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SPECTRUM            = Generates a spectral plot.
    PERIODOGRAM         = Generates a periodogram.
    CORRELATION PLOT    = Generates a correlation plot.
    COMPLEX DEMOD. PLOT = Generates a comp. demod. plot.
    LAG PLOT            = Generates a lag plot.
    PLOT                = Generates a data/function plot.
    4-PLOT              = Generates 4-plot univariate analysis.
 
    CHARACTERS          = Sets types for plot characters.
    LINES               = Sets types for plot lines.
    SPIKES              = Sets on/off switches for plot spikes.
 
    SUMMARY             = Generates table of summary statistics.
    LET                 = Generates sin/cos transf. (+ much more).
    FIT                 = Carries out least squares fit.
 
Reference:
    XX
 
Applications:
    Time Series Analysis
 
Implementation Date:
    Pre-1987
 
Program:
    .  THIS SAMPLE PROGRAM READS THE FILE LEW.DAT IN THE
    .  DATAPLOT REFERENCE DIRECTORY.  SINCE IT CONTAINS 200
    .  DATA POINTS, IT IS NOT REPRODUCED HERE.  THESE DATA ARE
    .  BEAM DEFLECTION DATA.
    .
    SKIP 25
    READ LEW.DAT DEFLECT
    .
    LINE BLANK SOLID DOT DOT
    SPIKE ON
    SPIKE BASE 0
    XLABEL LAG
    Y1LABEL AUTOCORRELATION
    .
    AUTOCORRELATION PLOT DEFLECT
 
-----COS (LET)---------------------------------------------------
 
COS
 
Name:
    COS (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the cosine for a variable or parameter.
 
Description:
    The cosine is defined for all real numbers and the returned value
    will be between -1 and 1.  By default, the angle is specified in
    radian units.  To use degree values, enter the command ANGLE UNITS
    DEGREES (ANGLE UNITS RADIANS resets it).
 
Syntax:
    LET <y2> = COS(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed cosine value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = COS(-2)
    LET A = COS(A1)
    LET X2 = COS(X1)
    LET X2 = COS(PI/2)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SIN      = Compute the sine.
    TAN      = Compute the tangent.
    COT      = Compute the cotangent.
    SEC      = Compute the secant.
    CSC      = Compute the cosecant.
    ARCCOS   = Compute the arccosine.
    ARCSIN   = Compute the arcsine.
    ARCTAN   = Compute the arctangent.
    ARCCOT   = Compute the arccotangent.
    ARCSEC   = Compute the arcsecant.
    ARCCSC   = Compute the arcsecant.
 
Reference:
    Consult any standard trigonometry or pre-calculus textbook.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    X1LABEL ANGLE VALUES (RADIANS)
    Y1LABEL COSINE VALUE
    YLIMITS -1 1
    YTIC OFFSET 0.2 0.2
    PLOT COS(X) FOR X = -3.1 .05 3.1
 
-----COSCDF (LET)--------------------------------
 
COSCDF
 
Name:
    COSCDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the cosine cumulative distribution function.
 
Description:
    The cosine distribution has the following probability density
    function:
       f(x)=(1+COS(x))/(2*PI)     -PI <= x <= PI
    The cumulative distribution is the area under the curve from
    -PI to x (i.e., the integral of the above function).  It has the
    formula:
       F(x) = (PI + x + SIN(x))/(2*PI)   -PI <= x <= PI
 
Syntax:
    LET <y2> = COSCDF(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a number, parameter or variable;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed cosine cdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = COSCDF(3)
    LET A = COSCDF(A1)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COSPDF = Compute the cosine probability density function.
    COSPPF = Compute the cosine percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    UNICDF = Compute the uniform cumulative distribution function.
    UNIPDF = Compute the uniform probability density function.
    UNIPPF = Compute the uniform percent point function.
 
Reference:
    "Some Useful Alternatives to the Normal Distribution", Chew, 
    The American Statistician, June, 1968.
 
Applications:
    XX
 
Implementation Date:
    95/4
 
Program:
    TITLE AUTOMATIC
    XLIMITS -3 3
    XTIC OFFSET 0.2 0.2
    LET LOWER = -PI
    LET UPPER = PI
    PLOT COSCDF(X) FOR X = LOWER 0.01 UPPER
 
-----COSH (LET)---------------------------------------------------
 
COSH
 
Name:
    COSH (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the hyperbolic cosine for a variable or parameter.
 
Description:
    The formula for the hyperbolic cosine is:
        cosh(x) = (e**x + e**-x)/2
    This function is defined for all real x.  The range is 1 to
    positive infinity.
 
Syntax:
    LET <y2> = COSH(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed hyperbolic cosine value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = COSH(-2)
    LET A = COSH(A1)
    LET X2 = COSH(X1)
    LET X2 = COSH(PI/2)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SIN      = Compute the sine.
    COS      = Compute the cosine.
    TAN      = Compute the tangent.
    COT      = Compute the cotangent.
    SEC      = Compute the secant.
    CSC      = Compute the cosecant.
    ARCCOS   = Compute the arccosine.
    ARCSIN   = Compute the arcsine.
    ARCTAN   = Compute the arctangent.
    ARCCOT   = Compute the arccotangent.
    ARCSEC   = Compute the arcsecant.
    ARCCSC   = Compute the arcsecant.
    SINH     = Compute the hyperbolic sine.
    TANH     = Compute the hyperbolic tangent.
    COTH     = Compute the hyperbolic cotangent.
    SECH     = Compute the hyperbolic secant.
    CSCH     = Compute the hyperbolic cosecant.
    ARCCOSH  = Compute hyperbolic arccosine.
    ARCCOTH  = Compute hyperbolic arccotangent.
    ARCCSCH  = Compute hyperbolic arccosecant.
    ARCSECH  = Compute hyperbolic arcsecant.
    ARCSINH  = Compute hyperbolic arcsine.
    ARCTANH  = Compute hyperbolic arctangent.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    Y1LABEL HYPERBOLIC COSINE VALUE
    YLIMITS 0 10
    PLOT COSH(X) FOR X = -3 .05 3
 
-----COSHINT (LET)--------------------------------
 
COSHINT
 
Name:
    COSHINT (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the hyperbolic cosine integral.
 
Description:
    The hyperbolic cosine integral is defined as:
        Chi(X) = EULER + LN(x) + INTEGRAL((COSH(t) - 1)/t)dt
    where the integral is taken from 0 to x, COSH is the hyperbolic 
    cosine function,  and EULER is Euler's constant (approximately
    0.5772...).

    This integral is undefined for zero and it is typically defined 
    only for positive x since
       Chi(-x) = Chi(x) - i*PI
    Note that the imaginary part is constant for all negative values.
    For negative x, DATAPLOT returns the value for the corresponding
    positive x.  An error message is printed if the input value is
    zero.

Syntax:
    LET <y2> = COSHINT(<x>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-zero number, variable, or parameter;
          <y2> is a variable or a parameter (depending on what <x> is
               where the computed hyperbolic cosine integral values
               are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = COSHINT(0.1)
    LET A = COSHINT(-0.1)
    LET X2 = COSHINT(X
 
Note:
    DATAPLOT uses the routine SICIEI written by Irene Stegum and
    Ruth Zucker of NIST (see the REFERENCE section below).

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COSINT     = Compute the hyperbolic cosine integral.
    SININT     = Compute the sine integral.
    SINHINT    = Compute the hyperbolic sine integral.
    EXPINTN    = Compute the exponential integral of order N.
    LOGINT     = Compute the logarithmic integral.
    DAWSON     = Compute Dawson's integral.
 
Reference:
    "SICIEI: Automatic Computing Methods for Special FUnctions.  Part
    III. The Sine, Cosine, Exponential Integrals and Related
    Functions", Stegum and Zucker, Journal of Research of the National
    Bureau of Standards, 80B(2), 1976.

    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 5).
 
Applications:
    Special Functions
 
Implementation Date:
    1994/09
 
Program:
    TITLE AUTOMATIC
    PLOT COSHINT(X) FOR X = .01 .01 10
 
-----COSINE DISTANCE (LET)-----------------------------------------
 
COSINE DISTANCE
 
Name:
    COSINE DISTANCE (LET)
    COSINE SIMILARITY (LET)
    ANGULAR COSINE DISTANCE (LET)
    ANGULAR COSINE SIMILARITY (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the cosine distance (or cosine similarity, angular
    cosine distance, angular cosine similarity) between two variables.
 
Description:
    The cosine similarity is defined as
 
        Cosine Similarity = SUM[i=1 to n][X(i)*Y(i)]/
                            {SQRT(SUM{i=1 to n][X(i)**2])*
                            SQRT(SUM{i=1 to n][Y(i)**2])}

    The cosine distance is then defined as

        Cosine Distance = 1 - Cosine Similarity

    The cosine distance above is defined for positive values
    only.  It is also not a proper distance in that the Schwartz
    inequality does not hold.  However, the following angular
    definitions are proper distances:

       angular cosine distance = (1/cosine similarity)/PI
       angular cosine similarty = 1 - angular cosine distance

    If negative values are encountered in the input, the
    cosine distances will not be computed.  However, the
    cosine similarities will be computed.

    NOTE: The 2018/08 version of Dataplot updated the definition
          for the angular cosine distance to

             angular cosine distance = fact*ACOS(cosine similarity)/PI

          with ACOS designating the arccosine function and where
          fact = 2 if there are no negative values and fact = 1 if
          there are negative values.

Syntax 1:
    LET <par> = COSINE DISTANCE <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed cosine distance
              is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Syntax 2:
    LET <par> = COSINE SIMILARITY <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed cosine similarity
              is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Syntax 3:
    LET <par> = ANGULAR COSINE DISTANCE <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed angular cosine
              distance is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Syntax 4:
    LET <par> = ANGULAR COSINE SIMILARITY <y1> <y2>
                <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed angular cosine
              similarity is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Examples:
    LET A = COSINE DISTANCE Y1 Y2
    LET A = COSINE SIMILARITY Y1 Y2
    LET A = ANGULAR COSINE DISTANCE Y1 Y2
    LET A = ANGULAR COSINE SIMILARITY Y1 Y2
    LET A = SHORTEST HALF MIDMEAN Y1 SUBSET TAG > 2

    LET A = COSINE DISTANCE Y1 Y2  SUBSET Y1 > 0 SUBSET Y2 > 0

Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    EUCLIDEAN DISTANCE      = Compute the Euclidean distance.
    MANHATTAN DISTANCE      = Compute the Manhattan distance.
    MATRIX DISTANCE         = Compute various distance metrics for
                              a matrix.
    CORRELATION             = Compute the correlation between two
                              variables.
 
Reference:
    John Foreman (2014), "Data Smart", Wiley.

Applications:
    Robust Clustering
 
Implementation Date:
    2017/03
    2018/08: Modified formula for angular cosine distance
 
Program:
    SKIP 25
    READ IRIS.DAT Y1 TO Y4 X
    .
    LET COSDIST  = COSINE DISTANCE Y1 Y2
    LET COSADIST = ANGULAR COSINE DISTANCE Y1 Y2
    LET COSSIMI  = COSINE SIMILARITY Y1 Y2
    LET COSASIMI = ANGULAR COSINE SIMILARITY Y1 Y2
    SET WRITE DECIMALS 4
    TABULATE COSINE DISTANCE Y1 Y2 X
    .
    XTIC OFFSET 0.2 0.2
    X1LABEL GROUP ID
    LET NDIST = UNIQUE X
    XLIMITS 1 NDIST
    MAJOR X1TIC MARK NUMBER NDIST
    MINOR X1TIC MARK NUMBER 0
    CHAR X
    LINE BLANK
    LABEL CASE ASIS
    CASE ASIS
    TITLE CASE ASIS
    TITLE OFFSET 2
    .
    MULTIPLOT CORNER COORDIANTES 5 5 95 95
    MULTIPLOT SCALE FACTOR 2
    MULTIPLOT 2 2
    .
    Y1LABEL Cosine Distance
    TITLE Cosine Distance (Sepal Length and Sepal Width)
    COSINE DISTANCE PLOT Y1 Y2 X
    .
    Y1LABEL Cosine Similarity
    TITLE Cosine Similarity (Sepal Length and Sepal Width)
    COSINE SIMILARITY PLOT Y1 Y2 X
    .
    Y1LABEL Angular Cosine Distance
    TITLE Angular Cosine Distance (Sepal Length and Sepal Width)
    COSINE ANGULAR DISTANCE PLOT Y1 Y2 X
    .
    Y1LABEL Angular Cosine Similarity
    TITLE Angular Cosine Similarity (Sepal Length and Sepal Width)
    ANGULAR COSINE SIMILARITY PLOT Y1 Y2 X
    .
    END OF MULTIPLOT
    JUSTIFICATION CENTER
    MOVE 50 98
    TEXT Distance/Similarity Measures (IRIS.DAT)
    .
    BOOTSTRAP SAMPLES 1000
    CHAR X ALL
    LINE BLANK ALL
    BOOTSTRAP COSINE DISTANCES PLOT Y1 Y2 X 
 
-----COSINE TRANSFORM (LET)------------------------------------------
 
COSINE TRANSFORM
 
Name:
    COSINE TRANSFORM (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the cosine transform of a variable.
 
Description:
    The cosine transform converts a time domain function into a
    frequency domain function.  In practice, functions are sampled at
    equally spaced discrete points.  The discrete cosine transform is:
        F(k) = SUM(j=0 to N-1) [f(j)sin(PI*j*k/N)]
    where f(j) is the data array for j = 0, 1, ... , N-1.
 
    DATAPLOT calculates the discrete cosine transform.  If you wish to
    calculate these transforms for a function, then evaluate this
    function at a series of points.
 
    See the REFERENCE section below for references which give a more
    detailed explanation of cosine transforms.
 
Syntax:
    LET <r1> = COSINE TRANSFORM <y1> <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a response variable for which the cosine transform is
               to be computed;
          <r1> is a variable containing the computed cosine transform;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET RPART = COSINE TRANSFORM Y1
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FOURIER TRANSFORM  = Compute the Fourier transform.
    INVERSE FOUR TRANS = Compute the inverse cosine transform.
    FFT                = Compute the fast cosine transform.
    INVERSE FFT        = Compute the inverse FFT.
    SINE TRANS         = Compute the sine transformation.
    SPECTRAL PLOT      = Generate a spectral plot.
 
Reference:
    "Numerical Recipes: The Art of Scientific Computing (FORTRAN
    Version)", Press, Flannery, Teukolsky, and Vetterling.  Cambridge
    University Press, 1989 (chapter 12).
 
    "Fourier Analysis of Time Series: An Introduction", Peter
    Bloomfield, John Wiley and Sons, 1976.
 
Applications:
    Frequency analysis of time series, signal processing
 
Implementation Date:
    87/5
 
Program:
    TITLE COSINE TRANSFORM
    LEGEND 1 TIME SERIES SMOOTHING
    .
    LET X = SEQUENCE 0 .1 25.55
    LET YS = SIN(X)
    LET YN = NORMAL RANDOM NUMBERS FOR I = 1 1 256
    LET YN = YN/10
    LET Y = YS+YN
    .
    LET U  = COSINE TRANSFORM Y
    LET NU = NUMBER U
    LET XU = SEQUENCE 1 1 NU
    LET XU = XU+50
    .
    LET U = 2.5*U
    PLOT U VS XU
 
-----COSINT (LET)--------------------------------
 
COSINT
 
Name:
    COSINT (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the cosine integral.
 
Description:
    The cosine integral is defined as:
        Ci(X) = EULER + LN(x) + INTEGRAL((COS(t) - 1)/t)dt
    where the integral is taken from 0 to x and EULER is Euler's 
    constant (approximately 0.5772...).

    This integral is undefined for zero and it is typically defined 
    only for positive x since
       Ci(-x) = Ci(x) - i*PI
    Note that the imaginary part is constant for all negative values.
    For negative x, DATAPLOT returns the value for the corresponding
    positive x.  An error message is printed if the input value is
    zero.

Syntax:
    LET <y2> = COSINT(<x>)  <SUBSET/EXCEPT/FOR qualification>
    where <x> is a non-zero number, variable, or parameter;
          <y2> is a variable or a parameter (depending on what <x> is
               where the computed cosine integral values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = COSINT(0.1)
    LET A = COSINT(-0.1)
    LET X2 = COSINT(X
 
Note:
    DATAPLOT uses the routine SICIEI written by Irene Stegum and
    Ruth Zucker of NIST (see the REFERENCE section below).

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COSHINT    = Compute the hyperbolic cosine integral.
    SININT     = Compute the sine integral.
    SINHINT    = Compute the hyperbolic sine integral.
    EXPINTN    = Compute the exponential integral of order N.
    LOGINT     = Compute the logarithmic integral.
    DAWSON     = Compute Dawson's integral.
 
Reference:
    "SICIEI: Automatic Computing Methods for Special FUnctions.  Part
    III. The Sine, Cosine, Exponential Integrals and Related
    Functions", Stegum and Zucker, Journal of Research of the National
    Bureau of Standards, 80B(2), 1976.

    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 5).
 
Applications:
    Special Functions
 
Implementation Date:
    94/9
 
Program:
    TITLE AUTOMATIC
    PLOT COSINT(X) FOR X = .01 .01 10
 
-----COSPDF (LET)--------------------------------
 
COSPDF
 
Name:
    COSPDF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the cosine probability density function.
 
Description:
    The cosine distribution has the following probability density
    function:
       f(x)=(1+COS(x))/(2*PI)     -PI <= x <= PI
 
Syntax:
    LET <y2> = COSPDF(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a number, parameter, or variable;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed cosine pdf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = COSPDF(3)
    LET A = COSPDF(A1)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COSCDF = Compute the cosine cumulative distribution function.
    COSPPF = Compute the cosine percent point function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    UNICDF = Compute the uniform cumulative distribution function.
    UNIPDF = Compute the uniform probability density function.
    UNIPPF = Compute the uniform percent point function.
 
Reference:
    "Some Useful Alternatives to the Normal Distribution", Chew, 
    The American Statistician, June, 1968.
 
Applications:
    XX
 
Implementation Date:
    95/4
 
Program:
    TITLE AUTOMATIC
    XLIMITS -3 3
    XTIC OFFSET 0.2 0.2
    LET LOWER = -PI
    LET UPPER = PI
    PLOT COSPDF(X) FOR X = LOWER 0.01 UPPER
 
-----COSPPF (LET)--------------------------------
 
COSPPF
 
Name:
    COSPPF (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the cosine percent point function.
 
Description:
    The cosine distribution has the following probability density
    function:
       f(x)=(1+COS(x))/(2*PI)     -PI <= x <= PI
    The percent point function is the inverse of the cumulative
    distribution function.  The cumulative distribution sums the
    probability from 0 to the given x value (i.e., the integral of the
    above function).  The percent point function takes a cumulative
    probability value and computes the corresponding x value.
 
    The input value is a real number between 0 and 1 (since it
    corresponds to a probability).
 
Syntax:
    LET <y2> = COSPPF(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a number, parameter, or variable in the range 0
               to 1;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed cosine ppf value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = COSPPF(0.9)
    LET A = COSPPF(A1)
 
Note:
    DATAPLOT uses a bisection method to compute the cosine ppf value.
    The algorithm for the beta distribution is given in the Kennedy
    and Gentle book (see the Reference section below).  The algorithm
    for the cosine distribution is similar.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    COSCDF = Compute the cosine cumulative distribution function.
    COSPDF = Compute the cosine cumulative distribution function.
    NORCDF = Compute the normal cumulative distribution function.
    NORPDF = Compute the normal probability density function.
    NORPPF = Compute the normal percent point function.
    UNICDF = Compute the uniform cumulative distribution function.
    UNIPDF = Compute the uniform probability density function.
    UNIPPF = Compute the uniform percent point function.
 
Reference:
    "Some Useful Alternatives to the Normal Distribution", Chew, 
    The American Statistician, June, 1968.
 
Applications:
    XX
 
Implementation Date:
    95/4
 
Program:
    TITLE AUTOMATIC
    PLOT COSPPF(P) FOR P = 0 0.01 1
 
-----COUNTS PLOT-------------------------------------------------
 
COUNTS PLOT
 
Name:
    COUNTS PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a counts plot.
 
Description:
    A counts plot is a plot consisting of subsample size versus
    subsample index.  The subsample count is identically the number of
    observations in the subsample.  The counts plot is used to answer
    the question-- "Does the subsample size change over different
    subsamples?".  The counts plot consists of:
       Vertical   axis = subsample size;
       Horizontal axis = subsample index.
    The COUNTS PLOT yields 2 traces:
       1. a subsample size trace; and
       2. a full-sample size reference line.
    Like usual, the appearance of these 2 traces is controlled by
    the first 2 settings of the LINES, CHARACTERS, SPIKES, BARS,
    and similar attributes.
 
Syntax:
    COUNTS PLOT   <y>   <x>    <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response (= dependent) variable;
          <x> is the subsample identifier variable (this variable
              appears on the horizontal axis);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    COUNTS PLOT Y X
    COUNTS PLOT Y X1
 
Default:
    None
 
Synonyms:
    SIZE PLOT
 
Related Commands:
    CHARACTERS    = Sets the types for plot characters.
    LINES         = Sets the types for plot lines.
    MEAN PLOT     = Generates a mean plot.
    MEDIAN PLOT   = Generates a median plot.
    SD   PLOT     = Generates a standard deviation plot.
    PLOT          = Generates a data or function plot.
 
Applications:
    Exploratory Data Analysis
 
Implementation Date:
    88/2
 
Program:
    LET Y = DATA 2 4 6 11 12 21 25 28 29
    LET X = DATA 1 1 1 2 2 3 3 3 3
    COUNTS PLOT Y X
 
-----COX STUART TEST--------------------------------------
 
COX STUART TEST
 
Name:
    COX STUART TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform a Cox-Stuart test for trend for a univariate data set.
 
Description:
    In many measurement processes, it is desirable to detect the
    prescence of trend (e.g., due to drift).  That is, if the
    data are assumed to be independent observations, we are interested
    in knowing if there is in fact a time dependent trend (i.e., the
    observations are in fact not independent).

    Given a set of ordered observations X(1), X(2), ..., X(n), let

         c = n/2       if n even
           = (n+1)/2   if n odd

    Then pair the data as X(1),X(1+c), X(2),X(2+c), ..., X(n-c),X(n).
    The Cox-Stuart test is then simply a sign test applied to these
    paired data.  For details on the sign test, enter

         HELP SIGN TEST

Syntax 1:
    <LOWER TAILED/UPPER TAILED> COX STUART TEST  <y>
                                <SUBSET/EXCEPT/FOR qualification>
    where <LOWER TAILED/UPPER TAILED> is an optional keyword that
               specifies either a lower tailed or an upper tailed
               test;
          <y> is a response variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    If neither LOWER TAILED or UPPER TAILED is specified, the Cox and
    Stuart test will return the results for the two-tailed case,
    the lower tailed case, and the upper tailed case.  If LOWER
    TAILED is specified, then only the results for the lower tailed
    case will be printed.  If UPPER TAILED is specified, then only
    the results for the upper tailed case will be printed.

Syntax 2:
    <LOWER TAILED/UPPER TAILED> COX STUART TEST  <y1>  ... <yk>
                                <SUBSET/EXCEPT/FOR qualification>
    where <LOWER TAILED/UPPER TAILED> is an optional keyword that
               specifies either a lower tailed or an upper tailed
               test;
          <y1> ... <yk> is a list of 1 to 30 response variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax will perform a Cox-Stuart test for each of the
    response variables.  For example,

         COX STUART TEST Y1 TO Y4

    is equivalent to

         COX STUART TEST Y1
         COX STUART TEST Y2
         COX STUART TEST Y3
         COX STUART TEST Y4

Examples:
    COX STUART TEST Y
    COX STUART TEST Y1 Y2 Y3
    COX STUART TEST Y1 TO Y5
    LOWER TAILED COX STUART TEST Y
    UPPER TAILED COX STUART TEST Y
 
Note:
    The COX STUART TEST will accept matrix arguments.  If a matrix
    is given, the data elements in the matrix will be collected in
    column order to form a vector before performing the Cox-Stuart
    test.
 
Note:
    Dataplot saves the following internal parameters after a
    Cox and Stuart test:

        STATVAL   = the value of the test statistic
        STATCDF   = the CDF of the test statistic
        PVALUE    = the p-value for the two-sided test
        PVALUELT  = the p-value for the lower tailed test
        PVALUEUT  = the p-value for the upper tailed test
        CUTLOW50  = the 50% lower tailed critical value
        CUTUPP50  = the 50% upper tailed critical value
        CUTLOW80  = the 80% lower tailed critical value
        CUTUPP80  = the 80% upper tailed critical value
        CUTLOW90  = the 90% lower tailed critical value
        CUTUPP90  = the 90% upper tailed critical value
        CUTLOW95  = the 95% lower tailed critical value
        CUTUPP95  = the 95% upper tailed critical value
        CUTLOW99  = the 99% lower tailed critical value
        CUTUPP99  = the 99% upper tailed critical value
        CUTLO999  = the 99.9% lower tailed critical value
        CUTUP999  = the 99.9% upper tailed critical value

Note:
    The run sequence plot can be used to graphically assess
    whether or not there is trend in the data.  The 4-plot can
    be used to assess the more general assumption of
    "independent, identically distributed" data.

    The paired data can also be analyzed using other techniques for
    comparing two response variables (e.g., t-test, bihistogram,
    quantile-quantile plot).

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SIGN TEST                  = Compute a sign test.
    T-TEST                     = Compute a t-test.
    4-PLOT                     = Generate a 4-plot.
    RUN SEQUENCE PLOT          = Generate a run sequence plot.
    BIHISTOGRAM                = Generates a bihistogram.
    QUANTILE-QUANTILE PLOT     = Generate a quantile-quantile plot.
 
Reference:
    Conover (1999), "Practical Nonparametric Statistics",
    Third Edition, Wiley, pp. 170-175.
 
Applications:
    Confirmatory Data Analysis
 
Implementation Date:
    2011/6
 
Program:
    . Purpose: Test the Cox Stuart Trend Test
    .          Sample data from example 2 on page 171 of Conover.
    .
    let y = data  45.25 45.83 41.77 36.26 45.37 52.25 35.37 57.16 35.37 ...
                  58.32 41.05 33.72 45.73 37.90 41.72 36.07 49.83 36.24 ...
                  39.90
    .
    set write decimals 4
    cox stuart test y

-----COT (LET)---------------------------------------------------
 
COT
 
Name:
    COT (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the cotangent for a variable or parameter.
 
Description:
    The cotangent is defined for all real x except integer multiples of
    PI.  The range is minus infinity to plus infinity.  By default, the
    angle is specified in radian units.  To use degree values, enter
    the command ANGLE UNITS DEGREES (ANGLE UNITS RADIANS resets it).
 
Syntax:
    LET <y2> = COT(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed cotangent value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = COT(-2)
    LET A = COT(A1)
    LET X2 = COT(X1)
    LET X2 = COT(PI/2)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SIN      = Compute the sine.
    COS      = Compute the cosine.
    TAN      = Compute the tangent.
    SEC      = Compute the secant.
    CSC      = Compute the cosecant.
    ARCCOS   = Compute the arccosine.
    ARCSIN   = Compute the arcsine.
    ARCTAN   = Compute the arctangent.
    ARCCOT   = Compute the arccotangent.
    ARCSEC   = Compute the arcsecant.
    ARCCSC   = Compute the arcsecant.
 
Reference:
    Consult any standard trigonometry or pre-calculus textbook.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    TITLE PLOT COTANGENT FROM -3.1 TO 3.1
    X1LABEL ANGLE (IN RADIANS)
    Y1LABEL COTANGENT VALUE
    READ X Y TAG
    -3.1   0  1
     3.1   0  1
     3.14 10  2
     3.14 -10 2
    -3.14 10  3
    -3.14 -10 3
     0.   10  4
     0.   -10 4
    END OF DATA
    YLIMITS -10 10
    XLIMITS -3 3
    XTIC OFFSET .4 .4
    LINES SOLID SOILD DOT DOT DOT DOT
    PLOT COT(X) FOR X = .1 .1 3.1 AND
    PLOT COT(X) FOR X = -.1 -.1 -3.1 AND
    PLOT Y X TAG
 
-----COTH (LET)---------------------------------------------------
 
 
Name:
    COTH (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the hyperbolic cotangent for a variable or parameter.
 
Description:
    The hyperbolic cotangent is defined as:
        coth(x) = (e**x + e**-x)/(e**x-e**-x)
    The hyperbolic cotangent is defined for all real numbers except
    0.  The range is minus infinity to -1 and 1 to plus infinity.
 
Syntax:
    LET <y2> = COTH(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed hyperbolic cotangent value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = COTH(-2)
    LET A = COTH(A1)
    LET X2 = COTH(X1)
    LET X2 = COTH(PI/2)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SIN      = Compute the sine.
    COS      = Compute the cosine.
    TAN      = Compute the tangent.
    COT      = Compute the cotangent.
    SEC      = Compute the secant.
    CSC      = Compute the cosecant.
    ARCCOS   = Compute the arccosine.
    ARCSIN   = Compute the arcsine.
    ARCTAN   = Compute the arctangent.
    ARCCOT   = Compute the arccotangent.
    ARCSEC   = Compute the arcsecant.
    ARCCSC   = Compute the arcsecant.
    SINH     = Compute the hyperbolic sine.
    COSH     = Compute the hyperbolic cosine.
    TANH     = Compute the hyperbolic tangent.
    SECH     = Compute the hyperbolic secant.
    CSCH     = Compute the hyperbolic cosecant.
    ARCCOSH  = Compute hyperbolic arccosine.
    ARCCOTH  = Compute hyperbolic arccotangent.
    ARCCSCH  = Compute hyperbolic arccosecant.
    ARCSECH  = Compute hyperbolic arcsecant.
    ARCSINH  = Compute hyperbolic arcsine.
    ARCTANH  = Compute hyperbolic arctangent.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    TITLE PLOT HYPERBOLIC COTANGENT
    READ X Y TAG
    -3   1  1
     3   1  1
    -3  -1  2
     3  -1  2
     0.   10  3
     0.   -10 3
    END OF DATA
    YLIMITS -10 10
    XLIMITS -3 3
    XTIC OFFSET .1 .1
    LINES SOLID SOILD DOT DOT DOT DOT
    PLOT COTH(X) FOR X = .05 .05 3 AND
    PLOT COTH(X) FOR X = -.05 -.05 -3 AND
    PLOT Y X TAG
 
-----COVARIANCE (LET)--------------------------------
 
COVARIANCE
 
Name:
    COVARIANCE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the covariance for a variable.
 
Description:
    It is computed as:
          COV = SUM ((X(i)-XMEAN)*(Y(i)-YMEAN))/(N-1)
 
Syntax:
    LET <par> = COVARIANCE <y1> <y2> <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed covariance is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = COVARIANCE Y1 Y2
    LET A = COVARIANCE Y1 Y2 SUBSET TAG > 2
 
Note:
    The two variables must have the same number of elements.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CORRELATION           = Compute the correlation.
    RANK CORRELATION      = Compute the rank correlation.
    VARIANCE              = Compute the variance.
 
Reference:
    Consult any introductory statistics book.
 
Applications:
    Data Analysis
 
Implementation Date:
    Pre-1987
 
Program:
    LET Y1 = EXPONENTIAL RANDOM NUMBERS FOR I = 1 1 100
    LET Y2 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET A1 = COVARIANCE Y1 Y2
 
-----CP (LET)-------------------------------------------------------
 
CP
 
Name:
    CP (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the process capability index (CP) for a variable.
 
Description:
    The process capability index measure the performance (i.e., the
    capability) of an industrial process and is defined as follows:
       CP = (USL -LSL)/(6S)
    where S is the sample standard deviation and where USL and LSL are
    user specified upper and lower specification limits.  The
    specification limits define the range within which a product is
    considered acceptable (values outside this range indicate that a
    product is defective).  Values less than 1 indicate that there are
    still some defectives.   A value of 6S yields a range of plus or
    minus 3 standard deviations.  For example, if the specification
    limits are symmetric about the mean and the calculated CP is
    exactly 1, this means that the specification limits fall at plus
    and minus 3 standard deviations from the mea (and almost all the
    data will fall within these limits).  Values greater than 1
    indicate the specification limits are even greater than 3
    standard deviations from the mean while values less than 1 indicate
    specification limits are less than 3 standard deviations from the
    mean.
 
Syntax:
    LET <param> = CP <y1> <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <param> is a parameter where the computed CP is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CP Y1
    LET A = CP Y1 SUBSET TAG > 2
 
Note:
    Recall that Chebychev's theorem states that at least 75% of the
    variables data must fall within plus or minus 2 standard deviations
    of the mean and that at least 88% must fall within plus or minus
    3 standard deviations.  This is for any distribution.  For a normal
    distribution, these numbers are 95.4% and 99.7% respectively.
 
Note:
    The upper and lower specification limits must be specified by the
    user as follows:
        LET LSL = <value>
        LET USL = <value>
 
Note:
    If your specification limits are not symmetric about the mean, the
    CPK statistic may be a better choice than the CP statistic.  It is
    an alternate calculation of CP that adjusts for possibly
    non-symmetric specification limits.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CONTROL CHART             = Generate a control chart.
    CPK (LET)                 = Compute the process capability index.
    PERCENT DEFECTIVE (LET)   = Compute the percentage of defectives in
                                a sample.
    EXPECTED LOSS (LET)       = Compute the expected loss of a sample.
 
Reference:
    "Guide to Quality Control", Kaoru Ishikawa, Asian Productivity
    Organization, 1982 (chapter 13).
 
Applications:
    Quality Control
 
Implementation Date:
    90/10
 
Program:
    LET Y1 = NORMAL RANDOM NUMERS FOR I = 1 1 100
    LET LSL = -2
    LET USL = 2
    LET A1 = CP Y1
 
-----CPL (LET)-------------------------------------------------------
 
CPL
 
Name:
    CPL (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the process capability index (CPL) for a variable.
 
Description:
    The process capability index measure the performance (i.e., the
    capability) of an industrial process and is defined as follows:

       CP = (USL -LSL)/(6S)

    where S is the sample standard deviation and where USL and LSL are
    user specified upper and lower specification limits.  The
    specification limits define the range within which a product is
    considered acceptable (values outside this range indicate that a
    product is defective).  Values less than 1 indicate that there are
    still some defectives.  A value of 6S yields a range of plus or
    minus 3 standard deviations.  For example, if the specification
    limits are symmetric about the mean and the calculated CP is
    exactly 1, this means that the specification limits fall at plus
    and minus 3 standard deviations from the mea (and almost all the
    data will fall within these limits).  Values greater than 1
    indicate the specification limits are even greater than 3
    standard deviations from the mean while values less than 1 indicate
    specification limits are less than 3 standard deviations from the
    mean.
 
    The CPL statistic is used when only the lower specification
    limit is of interest.  That is,

      CPL = (XBAR - LSL)/3*S

    where XBAR is the sample mean.

Syntax:
    LET <par> = CPL <y1> <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <par> is a parameter where the computed CPL is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CPL Y1
    LET A = CPL Y1 SUBSET TAG > 2
 
Note:
    Recall that Chebychev's theorem states that at least 75% of the
    variables data must fall within plus or minus 2 standard deviations
    of the mean and that at least 88% must fall within plus or minus
    3 standard deviations.  This is for any distribution.  For a normal
    distribution, these numbers are 95.4% and 99.7% respectively.
 
Note:
    The upper and lower specification limits must be specified by the
    user as follows:
        LET LSL = <value>
        LET USL = <value>
 
Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CAPABILITY ANALYSIS       = Compute a capability analysis.
    CP  (LET)                 = Compute a process capability index.
    CPU (LET)                 = Compute a process capability index.
    CPK (LET)                 = Compute a process capability index.
    PERCENT DEFECTIVE (LET)   = Compute the percentage of defectives in
                                a sample.
    EXPECTED LOSS (LET)       = Compute the expected loss of a sample.
 
Reference:
    Kotz and Johnson (1993), "Process Capability Indices,"
    Chapman & Hall (chapter 2).
 
Applications:
    Quality Control
 
Implementation Date:
    2001/04
 
Program:
    SKIP 25
    READ FURNACE.DAT X1 X2 X3 Y
    LET LSL = 460
    LET USL = 660
    LET A = CPL Y 
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT 2 2
    MULTIPLOT SCALE FACTOR 2
    TITLE AUTOMATIC
    CPL PLOT Y X1
    CPL PLOT Y X2
    CPL PLOT Y X3
    END OF MULTIPLOT
 
-----CPK (LET)-------------------------------------------------------
 
CPK
 
Name:
    CPK (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the process capability index (CPK) for a variable.
 
Description:
    The process capability index measure the performance (i.e., the
    capability) of an industrial process and is defined as follows:
       CPK = (MINIMUM(USL - M),(M - LSL))/(3S)
    where M is the sample mean, S is the sample standard deviation and
    where USL and LSL are user specified upper and lower specification
    limits.  The specification limits define the range within which a
    product is considered acceptable (values outside this range
    indicate that a product is defective).  Values less than 1
    indicate that there are still some defectives.
 
Syntax:
    LET <param> = CPK <y1> <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <param> is a parameter where the computed CPK is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CPK Y1
    LET A = CPK Y1 SUBSET TAG > 2
 
Note:
    Recall that Chebychev's theorem states that at least 75% of the
    variables data must fall within plus or minus 2 standard deviations
    of the mean and that at least 88% must fall within plus or minus
    3 standard deviations.  This is for any distribution.  For a normal
    distribution, these numbers are 95.4% and 99.7% respectively.
 
Note:
    The upper and lower specification limits must be specified by the
    user as follows:
        LET LSL = <value>
        LET USL = <value>
 
Note:
    If the specification limits are symmetric about the mean, the CPK
    and CP statistics are equivalent.  The CPK statistic may be
    preferred when this is not the case.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CONTROL CHART             = Generate a control chart.
    CP (LET)                  = Compute the process capability index.
    PERCENT DEFECTIVE (LET)   = Compute the percentage of defectives in
                                a sample.
    EXPECTED LOSS (LET)       = Compute the expected loss of a sample.
 
Reference:
    Kaoru Ishikawa (1982), "Guide to Quality Control,"
    Asian Productivity Organization, (chapter 13).
 
Applications:
    Quality Control
 
Implementation Date:
    90/10
 
Program:
    LET Y1 = NORMAL RANDOM NUMERS FOR I = 1 1 100
    LET LSL = -2
    LET USL = 2
    LET A1 = CP Y1
 
-----CP PLOT---------------------------------------------------
 
CP PLOT
 
Name:
    CP PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a Cp plot.
 
Description:
    A Cp plot consists of subsample Cp index versus subsample index.
    The subsample Cp index is the Cp index of the data in the
    subsample.  The Cp plot is used to answer the question--"Does the
    subsample Cp index change over different subsamples?"  The plot
    consists of:
       Vertical   axis = subsample Cp index;
       Horizontal axis = subsample index.
    The Cp plot yields 2 traces:
       1. a subsample Cp trace; and
       2. a full-sample Cp reference line.
    Like usual, the appearance of these 2 traces is controlled by
    the first 2 settings of the LINES, CHARACTERS, SPIKES, BARS,
    and similar attributes.
 
Syntax:
    CP PLOT   <y>   <x>    <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response (= dependent) variable;
          <x> is the subsample identifier variable (this variable
              appears on the horizontal axis);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    CP PLOT Y X
    CP PLOT Y X1
 
Note:
    The process capability index measure the performance (i.e., the
    capability) of an industrial process and is defined as follows:
       CP = (USL -LSL)/(6S)
    where S is the sample standard deviation and where USL and LSL are
    user specified upper and lower specification limits.  The
    specification limits define the range within which a product is
    considered acceptable (values outside this range indicate that a
    product is defective).  Values less than 1 indicate that there are
    still some defectives.   A value of 6S yields a range of plus or
    minus 3 standard deviations.  For example, if the specification
    limits are symmetric about the mean and the calculated CP is
    exactly 1, this means that the specification limits fall at plus
    and minus 3 standard deviations from the mea (and almost all the
    data will fall within these limits).  Values greater than 1
    indicate the specification limits are even greater than 3
    standard deviations from the mean while values less than 1 indicate
    specification limits are less than 3 standard deviations from the
    mean.
 
Note:
    Recall that Chebychev's theorem states that at least 75% of the
    variables data must fall within plus or minus 2 standard deviations
    of the mean and that at least 88% must fall within plus or minus
    3 standard deviations.  This is for any distribution.  For a normal
    distribution, these numbers are 95.4% and 99.7% respectively.
 
Note:
    The upper and lower specification limits must be specified by the
    user as follows:
        LET LSL = <value>
        LET USL = <value>
 
Note:
    If your specification limits are not symmetric about the mean, the
    CPK statistic may be a better choice than the CP statistic.  It is
    an alternate calculation of CP that adjusts for possibly
    non-symmetric specification limits.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHARACTERS              = Sets the type for plot characters.
    LINES                   = Sets the type for plot lines.
    CPK PLOT                = Generates a Cpk plot.
    EXPECTED LOSS PLOT      = Generates an expected loss plot.
    PERCENT DEFECTIVE PLOT  = Generates a percent defective plot.
    BOX PLOT                = Generates a box plot.
    XBAR CHART              = Generates an xbar control chart.
    PLOT                    = Generates a data or function plot.
 
Applications:
    Quality Control
 
Implementation Date:
    93/10
 
Program:
    SKIP 25
    READ GEAR.DAT DIAMETER BATCH
    .
    TITLE CASE ASIS; LABEL CASE ASIS
    TITLE  Gear Diameter Analysis
    Y1LABEL CP
    X1LABEL Batch
    LEGEND 1 Process Capability
    LEGEND 2 CP Plot
    XTIC OFFSET 0.5 0.5
    CHARACTER X BLANK
    LINE BLANK SOLID
    .
    LET LSL = 0.98
    LET USL = 1.02
    .
    CP PLOT Diameter Batch
 
-----CPK PLOT---------------------------------------------------
 
CPK PLOT
 
Name:
    CPK PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a Cpk plot.
 
Description:
    A Cpk plot consists of subsample Cpk index versus subsample index.
    The subsample Cpk index is the Cpk index of the data in the
    subsample.  The Cpk plot is used to answer the question--"Does the
    subsample Cpk index change over different subsamples?"  The plot
    consists of:
       Vertical   axis = subsample Cpk index;
       Horizontal axis = subsample index.
    The Cpk plot yields 2 traces:
       1. a subsample Cpk trace; and
       2. a full-sample Cpk reference line.
    Like usual, the appearance of these 2 traces is controlled by
    the first 2 settings of the LINES, CHARACTERS, SPIKES, BARS,
    and similar attributes.
 
Syntax:
    CPK PLOT   <y>   <x>    <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response (= dependent) variable;
          <x> is the subsample identifier variable (this variable
              appears on the horizontal axis);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    CPK PLOT Y X
    CPK PLOT Y X1
 
Note:
    The process capability index measure the performance (i.e., the
    capability) of an industrial process and is defined as follows:
       CPK = (MINIMUM(USL - M),(M - LSL))/(3S)
    where M is the sample mean, S is the sample standard deviation and
    where USL and LSL are user specified upper and lower specification
    limits.  The specification limits define the range within which a
    product is considered acceptable (values outside this range
    indicate that a product is defective).  Values less than 1
    indicate that there are still some defectives.
 
Note:
    Recall that Chebychev's theorem states that at least 75% of the
    variables data must fall within plus or minus 2 standard deviations
    of the mean and that at least 88% must fall within plus or minus
    3 standard deviations.  This is for any distribution.  For a normal
    distribution, these numbers are 95.4% and 99.7% respectively.
 
Note:
    The upper and lower specification limits must be specified by the
    user as follows:
        LET LSL = <value>
        LET USL = <value>
 
Note:
    If your specification limits are not symmetric about the mean, the
    CPK statistic may be a better choice than the CP statistic.  It is
    an alternate calculation of CP that adjusts for possibly
    non-symmetric specification limits.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHARACTERS              = Sets the type for plot characters.
    LINES                   = Sets the type for plot lines.
    CP PLOT                 = Generates a Cp plot.
    EXPECTED LOSS PLOT      = Generates an expected loss plot.
    PERCENT DEFECTIVE PLOT  = Generates a percent defective plot.
    BOX PLOT                = Generates a box plot.
    XBAR CHART              = Generates an xbar control chart.
    PLOT                    = Generates a data or function plot.
 
Applications:
    Quality Control
 
Implementation Date:
    93/10
 
Program:
    SKIP 25
    READ GEAR.DAT DIAMETER BATCH
    .
    TITLE CASE ASIS; LABEL CASE ASIS
    TITLE  Gear Diameter Analysis
    Y1LABEL CPK
    X1LABEL Batch
    LEGEND 1 Process Capability
    LEGEND 2 CPK Plot
    XTIC OFFSET 0.5 0.5
    CHARACTER X BLANK
    LINE BLANK SOLID
    .
    LET LSL = 0.98
    LET USL = 1.02
    .
    CPK PLOT Diameter Batch
 
-----CPM (LET)----------------------------------------------------
 
CPM
 
Name:
    CPM (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the process capability index (CPM) for a variable.
 
Description:
    The process capability index measure the performance (i.e., the
    capability) of an industrial process. The CPM is a variant of
    the CP and CPK capability indices.

      CPM = (USL - LSL)/(6*SQRT(S**2 + (XBAR - TARGET)**2))


    where USL and LSL are user specified upper and lower
    specification limits, TARGET is the target engineering limit,
    XBAR and S are the sample mean and standard deviation of the
    data.  For this statistic, larger is better.

    The specification limits define the range within which a
    product is considered acceptable (values outside this range
    indicate that a product is defective).
 
Syntax:
    LET <par> = CPM <y>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the computed CPM is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CPM Y1
    LET A = CPM Y1 SUBSET TAG > 2
 
Note:
    The upper and lower specification limits and target value
    must be specified by the user as follows:

        LET LSL = <value>
        LET USL = <value>
        LET TARGET = <value>
 
Note:
    This statistic is also supported for the following plots:

        CPM PLOT Y X
        CROSS TABULATE CPM PLOT Y X
        DEX CPM PLOT Y X1 ... Xk

    You need to specify the LSL, USL, and TARGET values (see
    above) before entering these commands.  For more information
    on these plots, enter 

        HELP STATISTIC PLOT
        HELP CROSS TABULATE PLOT
        HELP DEX PLOT

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CONTROL CHART             = Generate a control chart.
    STATISTIC PLOT            = Generate a statistic versus subset
                                plot.
    DEX PLOT                  = Generate a dex <statistic> plot.
    CP (LET)                  = Compute the process capability index.
    CPK (LET)                 = Compute the process capability index.
    CPNK (LET)                = Compute the process capability index.
    CC (LET)                  = Compute the process capability index.
    PERCENT DEFECTIVE (LET)   = Compute the percentage of defectives in
                                a sample.
    EXPECTED LOSS (LET)       = Compute the expected loss of a sample.
 
Reference:
    "Guide to Quality Control", Kaoru Ishikawa, Asian Productivity
    Organization, 1982 (chapter 13).
 
Applications:
    Quality Control
 
Implementation Date:
    1998/12
 
Program:
    SKIP 25
    READ GEAR.DAT Y X
    LET USL = 0.995
    LET USL = 1.005
    LET TARGET = 1.0
    CHARACTER X BLANK
    LINE BLANK SOLID
    TITLE AUTOMATIC
    XTIC OFFSET 0.5 0.5
    TIC OFFSET UNITS DATA
    CPM PLOT Y X
 
-----CPMK (LET)-------------------------------------------------------
 
CPMK
 
Name:
    CPMK (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the Cpmk process capability index for a variable.
 
Description:
    This statistic computes the sample Cpmk process capability
    index of an industrial process and is defined as follows:

       CPMK = MIN((ENGUSL - MEAN),(MEAN - ENGLSL)/
              {3*SQRT(S**2 +(MEAN-TARGET)**2)}

    with TARGET, ENGLSL, ENGUSL and MEAN denoting the target engineering
    limit, the lower engineering specification limit, the upper
    engineering specification limit and the sample mean, respectively.
    This capability index combines both precision and unbiasedness.

    The Cpmk statistic can have values from 0 to infinity with
    values between 0.5 and 1 being typical.

    The specification limits define the range within which a product is
    considered acceptable (values outside this range indicate that a
    product is defective).

Syntax:
    LET <par> = CPMK <y>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <par> is a parameter where the computed CPMK is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CPMK Y1
    LET A = CPMK Y1 SUBSET TAG > 2
 
Note:
    The target and upper and lower specification limits must be specified
    by the user as follows:

        LET TARGET = <value>
        LET LSL = <value>
        LET USL = <value>
 
Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CAPABILITY ANALYSIS  = Perform a capability analysis.
    CP                   = Compute a Cp process capability index.
    CPK                  = Compute a Cpk process capability index.
    CNPK                 = Compute a Cnpk process capability index.
    CPM                  = Compute a Cpm process capability index.
    CC                   = Compute a Cc process capability index.
    CPL                  = Compute a Cpl process capability index.
    CPU                  = Compute a Cpu process capability index.
    CNP                  = Compute a Cnp process capability index.
    CNPM                 = Compute a Cnpm process capability index.
    CNPKM                = Compute a Cnpkm process capability index.
    PERCENT DEFECTIVE    = Compute the percentage of defectives in a
                           sample.
    EXPECTED LOSS        = Compute the expected loss of a sample.
 
Reference:
    Chen and Ding (2001), "A New Process Capability Index for Non-Normal
    Distributions," International Journal of Quality & Reliability
    Management, Vol. 18, No. 7, pp. 762-770.
 
    Kaoru Ishikawa (1982), "Guide to Quality Control,"
    Asian Productivity Organization, (chapter 13).
 
Applications:
    Quality Control
 
Implementation Date:
    2015/04
 
Program:
    SKIP 25
    READ FURNACE.DAT X1 X2 X3 Y
    LET TARGET = 550
    LET LSL = 460
    LET USL = 660
    LET A = CPMK Y 
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT 2 2
    MULTIPLOT SCALE FACTOR 2
    TITLE AUTOMATIC
    CPMK PLOT Y X1
    CPMK PLOT Y X2
    CPMK PLOT Y X3
    END OF MULTIPLOT
 
-----CPSI (LET)--------------------------------
 
CPSI
 
Name:
    CPSI (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the psi (or digamma) function with complex
    arguments.
 
Description:
    The complex psi function is defined as:

        psi(z) = GAMMA'(z)/GAMMA(z)

    where z is a complex number with a positive real component,
    GAMMA is the gamma function, and GAMMA' is the derivative
    of the gamma function.
    
    Dataplot computes this function using the CPSI routines
    from "Computation of Special Functions" (see the References
    section below).
 
Syntax 1:
    LET <yr> = CPSI(<xr>,<xc>)  <SUBSET/EXCEPT/FOR qualification>
    where <xr> is a variable, number, or parameter containing
               positive values;
          <xc> is a variable, number, or parameter;
               positive values;
          <yr> is a variable or a parameter (depending on what
               <xr> and <xc> are) where the computed psi values
               are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the real component of the complex
    psi function.  The <xr> and <xc> values are the real and
    complex components of the input argument respectively.

Syntax 2:
    LET <yc> = CPSII(<xr>,<xc>)  <SUBSET/EXCEPT/FOR qualification>
    where <xr> is a variable, number, or parameter containing
               positive values;
          <xc> is a variable, number, or parameter;
               positive values;
          <yr> is a variable or a parameter (depending on what
               <xr> and <xc> are) where the computed psi values
               are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the complex component of the complex
    psi function.  The <xr> and <xc> values are the real and
    complex components of the input argument respectively.

Examples:
    LET A = CPSI(1,2)
    LET A = CPSII(1,2)

    LET YR = CPSI(XR,2)
    LET YC = CPSII(XR,2)
 
    LET YR = CPSI(XR,XC)
    LET YC = CPSII(XR,XC)

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    DIGAMMA    = Compute the digamma function.
    GAMMA      = Compute the Gamma function.
    GAMMAI     = Compute the incomplete Gamma function.
    CGAMMA     = Compute the complex gamma function.
    CLNGAM     = Compute the complex log gamma function.
    CBETA      = Compute the complex beta function.
    CLNBETA    = Compute the complex log beta function.
 
Reference:
    "Computation of Special Functions", Shanjie Zhang and Jianming
    Jin, John Wiley and Sons, 1996, pp. 182-184.
 
    "Handbook of Mathematical Functions, Applied Mathematics Series,
    Vol. 55", Abramowitz and Stegun, National Bureau of Standards,
    1964 (chapter 6).
 
Applications:
    Special Functions
 
Implementation Date:
    1997/12
 
Program:
    MULTIPLOT 2 2
    MULTIPLOT CORNER COORDINATES
    TITLE AUTOMATIC
    PLOT CPSI(XR,2) FOR XR = 0.1 0.1 5
    PLOT CPSI(XR,5) FOR XR = 0.1 0.1 5
    PLOT CPSI(XR,2) FOR XR = 0.1 0.1 5
    PLOT CPSI(XR,5) FOR XR = 0.1 0.1 5
    END OF MULTIPLOT
 
-----CPU TIME-------------------------------------------------------

CPU TIME

Name:
    CPU TIME

Type:
    Support Command

Purpose:
    Prints out the CPU time for the current Dataplot session and
    save the CPU time in the parameter CPUTIME.

Description:
    This command is primarily of interest when developing non-trivial
    macros.  If a macro takes a long time to run, the CPU TIME command
    can be used to determine what parts of the macro are taking the
    most time and would therefore be the most important to make more
    efficient.

    The CPU TIME is cumulative from the start of the Dataplot session.
    If you want to measure the CPU time for a specific block of code,
    you typically enter the command at both the beginning and the end
    of the code block and then subtract the difference.  This is
    demonstrated in the example program below.

Syntax:
    CPU TIME

Examples:
    CPU TIME

Note:
    This command uses the Fortran 90 CPU_TIME function.  If you are
    using a version of Dataplot built with a Fortran 77 compiler, this
    command may not be available.

Default:
    None

Synonyms:
    None

Related Commands:
    TIME       = Generate the current date and time.
    CALL       = Execute a Dataplot macro.

Applications:
    Macro development

Implementation Date:
    2009/5

Program:
    CPU TIME
    LET TIME1 = CPUTIME
    CALL MINITEST.DP
    CPU TIME
    LET TIME2 = CPUTIME
    LET TIME = TIME2 - TIME1
    WRITE "MINTEST.DP TAKES ^TIME CPU SECONDS TO RUN"
 
-----CPU (LET)-------------------------------------------------------
 
CPU
 
Name:
    CPU (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the process capability index (CPU) for a variable.
 
Description:
    The process capability index measure the performance (i.e., the
    capability) of an industrial process and is defined as follows:

       CP = (USL -LSL)/(6S)

    where S is the sample standard deviation and where USL and LSL are
    user specified upper and lower specification limits.  The
    specification limits define the range within which a product is
    considered acceptable (values outside this range indicate that a
    product is defective).  Values less than 1 indicate that there are
    still some defectives.  A value of 6S yields a range of plus or
    minus 3 standard deviations.  For example, if the specification
    limits are symmetric about the mean and the calculated CP is
    exactly 1, this means that the specification limits fall at plus
    and minus 3 standard deviations from the mea (and almost all the
    data will fall within these limits).  Values greater than 1
    indicate the specification limits are even greater than 3
    standard deviations from the mean while values less than 1 indicate
    specification limits are less than 3 standard deviations from the
    mean.
 
    The CPU statistic is used when only the upper specification
    limit is of interest.  That is,

      CPU = (USL - XBAR)/3*S

    where XBAR is the sample mean.

Syntax:
    LET <par> = CPU <y1> <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <par> is a parameter where the computed CPU is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CPU Y1
    LET A = CPU Y1 SUBSET TAG > 2
 
Note:
    Recall that Chebychev's theorem states that at least 75% of the
    variables data must fall within plus or minus 2 standard deviations
    of the mean and that at least 88% must fall within plus or minus
    3 standard deviations.  This is for any distribution.  For a normal
    distribution, these numbers are 95.4% and 99.7% respectively.
 
Note:
    The upper and lower specification limits must be specified by the
    user as follows:

        LET LSL = <value>
        LET USL = <value>
 
Note:
    Dataplot statistics can be used in a number of commands.  For
    details, enter

         HELP STATISTICS

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CAPABILITY ANALYSIS       = Compute a capability analysis.
    CP  (LET)                 = Compute a process capability index.
    CPL (LET)                 = Compute a process capability index.
    CPK (LET)                 = Compute a process capability index.
    PERCENT DEFECTIVE (LET)   = Compute the percentage of defectives in
                                a sample.
    EXPECTED LOSS (LET)       = Compute the expected loss of a sample.
 
Reference:
    Kotz and Johnson (1993), "Process Capability Indices,"
    Chapman & Hall (chapter 2).
 
Applications:
    Quality Control
 
Implementation Date:
    2001/04
 
Program:
    SKIP 25
    READ FURNACE.DAT X1 X2 X3 Y
    LET LSL = 460
    LET USL = 660
    LET A = CPU Y 
    MULTIPLOT CORNER COORDINATES 5 5 95 95
    MULTIPLOT 2 2
    MULTIPLOT SCALE FACTOR 2
    TITLE AUTOMATIC
    CPU PLOT Y X1
    CPU PLOT Y X2
    CPU PLOT Y X3
    END OF MULTIPLOT
 
-----CR-------------------------------------------------------
 
CR
 
Name:
    CR
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Specifies that there be a "carriage return" after subsequent TEXT
    commands.
 
Description:
    If the carriage return is "off", the beam remains at the end of
    text strings after succeeding TEXT commands and new text is placed
    at the end position of old text.  If the carriage return is "on",
    the beam reverts to the margin value after succeeding TEXT commands
    and new text is placed at the margin position without an explicit
    MOVE command.
 
    The margin is set via the MARGIN command and defaults to 50 (i.e.,
    half way across the screen.)
 
    The CR command is frequently used in conjunction with the LF
    (= line feed) command.  The LF command specifies whether or not the
    beam should advance a line after each subsequent TEXT command.
    Judicious control of the "carriage return" and "line feed" allows
    the analyst to cut down on unnecessary MOVE statements between
    succeeding TEXT commands when generating a simple list of text
    strings (as in common in creating word charts).  The CR command can
    also be judiciously used in conjunction with the JUSTIFICATION
    command to generate left-justified lists, center-justified lists,
    and right-justified lists.
 
Syntax:
    CR   <ON   or   OFF>
    where ON specifies that the beam returns to the margin position
    while OFF specifies that the beam remains at the end of of the
    previous text string.
 
Examples:
    CR ON
    CR OFF
    CR
 
Note:
    The CR command with no arguments is equivalent to CR ON .
 
Default:
    The default is for the carriage return to be "on".
 
Synonyms:
    None
 
Related Commands:
    TEXT               = Writes a text string.
    FONT               = Sets the font for TEXT characters.
    CASE               = Sets the case for TEXT characters.
    HEIGHT             = Sets the height for TEXT characters.
    WIDTH              = Sets the width for TEXT characters.
    HW                 = Sets the height and width for TEXT characters.
    VERTICAL SPACING   = Sets the vertical spacing between text lines.
    HORIZONTAL SPACING = Sets the horizontal spacing between text
                         characters.
    THICKNESS          = Sets the thickness of TEXT characters.
    COLOR              = Sets the color for TEXT characters.
    JUSTIFICATION      = Sets the justification for TEXT.
    LF                 = Sets the line feed after text.
    CRLF               = Sets the carriage return/line feed after text.
    MARGIN             = Sets the carriage return column after text.
    ()                 = Allows math and Greek characters in text.
    MOVE               = Moves to a point.
    CROSS-HAIR (or CH) = Activates and reads the cross-hair.
    ERASE              = Erases the screen (immediately).
    COPY               = Copies the screen (immediately).
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    FEEDBACK OFF
    FONT DUPLEX
    CR OFF
    LF OFF
    HW 4 3
    MOVE 20 50
    TEXT SUB()TUNSB()NSUP()13UNSP()
    .
    HW 4 8
    TEXT RARR()
    .
    HW 4 3
    TEXT SUB()6UNSB()CSUP()13 + LC()BETA()SUP()+UNSP() + NU()
 
-----CRAMER CONTINGENCY COEFICIENT (LET)--------------------------------
 
CRAMER CONTINGENCY COEFICIENT
 
Name:
    CRAMER CONTINGENCY COEFICIENT (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute Cramer's contingency coefficient for an RxC contingency
    table.
 
Description:
    If we have N observations with two variables where each
    observation can be classified into one of R mutually exclusive
    categories for variable one and one of C mutually exclusive
    categories for variable two, then a cross-tabulation of the
    data results in a two-way contingency table (also referred to
    as an RxC contingency table).  The resulting contingency table
    has R rows and C columns.

    A common question with regards to a two-way contingency
    table is whether we have independence.  By independence, we
    mean that the row and column variables are unassociated
    (i.e., knowing the value of the row variable will not
    help us predict the value of column variable and likewise
    knowing the value of the column variable will not help us
    predict the value of the row variable).

    A more technical definition for independence is that

        P(row i, column j) = P(row i)*P(column j)   for all i,j

    The standard test statistic for determing independence is
    the chi-square test statistic:

        T = SUM[i=1 to r][j=1 to c][(O(ij) - E(ij)**2/E(ij)]

    where
 
       r     = the number of rows in the contingency table
       c     = the number of columns in the contingency table
       O(ij) = the observed frequency of the ith row and
               jth column
       E(ij) = the expected frequency of the ith row and
               jth column
             = R(i)*C(j)/N
       R(i)  = the sum of the observed frequencies for row i
       C(j)  = the sum of the observed frequencies for column j
       N     = the total sample size

    One criticism of this statistic is that it does not give a
    meaningful description of the degree of dependence (or strength of
    association).   That is, it is useful for determining whether there
    is dependence. However, since the strength of that association also
    depends on the degrees of freedom as well as the value of the test
    statistic, it is not easy to interpert the strength of association.

    The Cramer's contingency coefficient is one method to provide an
    easier to interpret measure of strength of association.  Specifically,
    it is:

       Cramer's Coefficient = SQRT(T/(N*(q-1))

    where

       T   = the chi-square test statistic given above
       N   = the total sample size
       q   = minimum(number of rows,number of columns)

    This statistic is based on the fact that the maximum value of T is:

       N*(q-1)

    So this statistic basically scales the chi-square statistic to
    a value between 0 (no association) and 1 (maximum association).
    It has the desirable property of scale invariance.  That is,
    if the sample size increases, the value of Cramer's contingency
    coefficient does not change as long as values in the table change
    the same relative to each other.

    The data for the contingency table can be specified in either of
    the following two ways:

        1) raw data

           In this case, you will have two variables.  The first
           will contain r distinct values and the second will contain
           c distinct values.  Dataplot will automatically perform the
           cross-tabulation to obtain the counts for each cell.  Although
           the distinct values will typically be integers, this is not
           strictly required.

        2) table data

           If you only have the resulting contingency table (i.e., the
           counts for each cell), then you can use the READ MATRIX (or
           CREATE MATRIX) command to create a matrix with the data.  This
           is demonstrated in the example program below.

           In this case, your data should contain non-negative integers
           since they represent the counts for each cell.

Syntax 1:
    LET <par> = CRAMER CONTINGENCY COEFICIENT <y1> <y2>
                              <SUBSET/EXCEPT/FOR qualification>
    where <y1> is the first  response variable;
          <y2> is the second response variable;
          <par> is a parameter where the computed Cramer contingency
               coefficient is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    Use this syntax for raw data.

Syntax 2:
    LET <par> = MATRIX GRAND CRAMER CONTINGENCY COEFICIENT <y1> <y2>
                              <SUBSET/EXCEPT/FOR qualification>
    where <m> is a matrix containing the contingency table;
          <par> is a parameter where the computed Cramer contingency
               coefficient is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    Use this syntax if your data is a contingency table.

Examples:
    LET A = CRAMER CONTINGENCY COEFICIENT Y1 Y2
    LET A = MATRIX GRAND CRAMER CONTINGENCY COEFICIENT M
 
Note:
    For the raw data case, the two variables should have the same
    number of elements.
 
Note:
    The following additional commands are supported

        TABULATE CRAMER CONTINGENCY COEFICIENT  Y1 Y2 X
        CROSS TABULATE CRAMER CONTINGENCY COEFICIENT Y1 Y2 X1 X2

        CRAMER CONTINGENCY COEFICIENT PLOT Y1 Y2 X
        CROSS TABULATE CRAMER CONTINGENCY COEFICIENT PLOT Y1 Y2 X1 X2

        BOOTSTRAP CRAMER CONTINGENCY COEFICIENT PLOT Y1 Y2
        JACKNIFE  CRAMER CONTINGENCY COEFICIENT PLOT Y1 Y2

    Note that the above commands expect the variables to have
    the same number of observations.

    Note that the above commands are only available if you have
    raw data.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHI-SQUARE INDEPENDENCE TEST     = Perform a chi-square test for
                                       independence.
    PEARSON CONTINGENCY COEFFICIENT  = Compute Pearson's contingency 
                                       coefficient.
    ASSOCIATION PLOT                 = Generate an association plot.
    SIEVE PLOT                       = Generate a sieve plot.
    ODDS RATIO INDEPENDENCE TEST     = Perform a log(odds ratio) test for
                                       independence.
    FISHER EXACT TEST                = Perform Fisher's exact test.
    ROSE PLOT                        = Generate a Rose plot.
    BINARY TABULATION PLOT           = Generate a binary tabulation plot.
    ROC CURVE                        = Generate a ROC curve.
    ODDS RATIO                       = Compute the bias corrected odds
                                       ratio.
    LOG ODDS RATIO                   = Compute the bias corrected
                                       log(odds ratio).
 
Reference:
    Conover (1999), "Practical Nonparametric Statistics",
    Third Edition, Wiley, pp. 229-230.

    Friendly (2000), "Visualizing Categorical Data", SAS Institute
    Inc., p. 61.

Applications:
    Categorical Data Analysis
 
Implementation Date:
    2007/5
 
Program:
    . Example from page 61 of Friendly
    read matrix m
     5  29 14 16
    15  54 14 10
    20  84 17 94
    68 119 26 7
    end of data
    .
    let a = matrix cramer contingency coefficient m
 
-----CREATE-------------------------------------------------------
 
CREATE
 
Name:
    CREATE
 
Type:
    Support Command
 
Purpose:
    Echo commands entered interactively to a file.
 
Description:
    DATAPLOT macros are ASCII text files containing DATAPLOT commands.
    The CREATE command can be a convenient way to generate a macro
    file.  You can use any standard text editor available to you to
    edit the file generated by the CREATE command and you can use the
    CALL command to re-execute the commands in this file.
 
Syntax:
    CREATE    <file name>
    where <file name> is the name of a file containing DATAPLOT
    commands.  If the file name does not contain a period, place a
    period (no spaces) at the end of the file name.
 
Examples:
    CREATE PLOTCALIB.
    CREATE PROG.PLOTLAB
 
Note:
    One restriction on CREATE is that you cannot use it within a file
    executed by the CALL command and you cannot enter the CALL command
    while the CREATE is on.  This has undesirable results (it puts you
    in an infinite loop on some systems).
 
Note:
    DATAPLOT has no restrictions on the file name other than it be a
    valid file name on the local operating system and that it contain
    a period "." in the file name itself or as a trailing character.
    DATAPLOT strips off trailing periods on those systems where it is
    appropriate to do so.  On systems where trailing periods can be a
    valid file name (e.g., Unix), DATAPLOT opens the file with the
    trailing period.
 
    Some users prefer to give all macro files a ".DP" or ".dp"
    extension.  Although this is a useful method for keeping track of
    macro files, it is strictly a user convention and is not enforced
    by DATAPLOT in any way.
 
Note:
    File names are case sensitive on Unix file systems.  For Unix,
    DATAPLOT opens the file as given.  All other currently supported
    systems are not case sensitive regarding file names.
 
    As a further caution for Unix hosts, certain expansion characters
    (specifically ~ to refer to your home directory) are interperted
    by the shell and are not recognized by the Fortran compiler.  These
    expansion characters are interperted as literal characters and do
    not yield the intended file name.
 
Default:
    None
 
Synonyms:
    MACRO is a synonym for CREATE.  CREATE is the preferred form.
 
Related Commands:
    CALL          = Execute commands stored in a file.
    END OF CREATE = Stops copying commands to macro file.
    LIST          = Lists the contents of a file (including macro and
                    data files).
 
Applications:
    Writing Dataplot macros
 
Implementation Date:
    Pre-1987
 
Program:
    XX
 
-----CREATE MATRIX (LET)----------------------------------------
 
CREATE MATRIX
 
Name:
    CREATE MATRIX (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Create a matrix from a list of variables.
 
Description:
    A number of commands in Dataplot operate on a matrix.  The
    CREATE MATRIX command can be a convenient way to create a
    matrix from a list of variables.

    This command has a similar function to the MATRIX DEFINITION
    command.  The distinction is that the MATRIX DEFINITION
    command creates a matrix from variables that are stored
    contiguously in the Dataplot variable space (variables
    are stored in the order that they are created).  The
    CREATE MATRIX command does not impose this restriction.
 
Syntax:
    LET <mat1> = CREATE MATRIX <var1> ... <vark>
                 <SUBSET/EXCEPT/FOR qualification>
    where <var1> ... <vark> is a list of 1 to 30 previously defined
                variables;
          <mat1> is a matrix where the resulting matrix is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional (and
                 rarely used in this context).
 
Examples:
    LET C = CREATE MATRIX X0 X1 X2 X3 X4
 
Note:
    The 2023/05 version of Dataplot update the CREATE MATRIX command
    to support the "TO" syntax.  That is, you can now enter commands
    such as

         LET M = CREATE MATRIX X1 TO X50
         LET M = CREATE MATRIX X3 X8 TO X24 X28

Note:
    The columns of a matrix are accessible as variables by appending
    an index to the matrix name.  For example, the 4x4 matrix C has
    columns C1, C2, C3, and C4.  These columns can be operated on
    like any other DATAPLOT variable.
 
Note:
    The original variables are not deleted.  This command creates
    new copies of the variables.

    To create a matrix from a list of variables without creating
    a duplicate copy of the variables, do something like the
    following:

       WRITE TEMP.OUT X0 X1 X2 X3 X4
       DELETE X0 X1 X2 X3 X4
       READ MATRIX TEMP.OUT X

    Be aware that the variable names are now X1, X2, X3, X4, and X5.
 
Note:
    The maximum size matrix that DATAPLOT can handle is set when
    DATAPLOT is built on a particular site.  Enter the command
    HELP MATRIX DIMENSION for details on the maximum size matrix
    that can be accomodated.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    MATRIX DEFINITION        = Create a matrix from contiguous
                               variables.
    CATCHER MATRIX           = Compute the catcher matrix.
    VARIANCE INFLATION FACT  = Compute variance inflation factors.
    CONDITION INDICES        = Compute condition indices.
    XTXINV MATRIX            = Compute the (X'X)**(-1) matrix.
 
Applications:
    Matrix Operations
 
Implementation Date:
    2002/07
    2023/05: Added support for "TO" syntax.
 
Program:
    DIMENSION 100 COLUMNS
    SKIP 25 
    READ HALD647.DAT Y X1 X2 X3 X4 
    LET N = SIZE X1 
    LET X0 = SEQUENCE 1 1 N 
    LET Z = CREATE MATRIX X0 X1 X2 X3 X4 
    . 
    LET C = CONDITION INDICES Z
 
-----CRLF-------------------------------------------------------
 
CRLF
 
Name:
    CRLF
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Specifies that there be a "carriage return" and "line feed" after
    subsequent TEXT commands.
 
Description:
    If the "carriage return" and "line feed" are "off", the beam
    remains at the end of text strings on the same line after
    succeeding TEXT comands and new text is placed at the end
    position of old text.  If the "carriage return" and "line feed" are
    "on", the beam reverts to the margin position and advances a line.
    New text is placed at the margin position on the next line without
    an explicit MOVE command.
 
    The margin is set via the MARGIN command and default to 50 (i.e.,
    halfway across the screen).  The position of the next line is
    dictated by the character height plus the inter-line gap.  The
    HEIGHT command sets the character height and the VERTICAL SPACING
    command sets the inter-line gap (the character height is not
    counted in the inter-line gap).
 
    The CRLF command simultaneously sets both the "carriage return" and
    the "line feed".  Use the CR command to set the "carriage return"
    only and use the LF command to set the "line feed" only.
 
    Judicious control of the "carriage return" and "line feed" allows
    the analyst to cut down on unnecessary MOVE statements between
    succeeding TEXT commands when generating a simple list of text
    strings (as in common in creating word charts).  The CR command can
    also be judiciously used in conjunction with the JUSTIFICATION
    command to generate left-justified lists, center-justified lists,
    and right-justified lists.
 
Syntax:
    CRLF   <ON   or   OFF>
    where ON specifies that the beam returns to the margin position
    advanced a line while OFF specifies that the beam remains at the
    end of the previous text string on the same line.
 
Examples:
    CRLF ON
    CRLF OFF
    CRLF
 
Default:
    The default is for both the carriage return and the "line feed" to
    be "on".
 
Synonyms:
    LFCR
 
Note:
    The CRLF command with no arguments is equivalent to CRLF ON   .
 
Related Commands:
    TEXT               = Writes a text string.
    FONT               = Sets the font for TEXT characters.
    CASE               = Sets the case for TEXT characters.
    HEIGHT             = Sets the height for TEXT characters.
    WIDTH              = Sets the width for TEXT characters.
    HW                 = Sets the height and width for TEXT characters.
    VERTICAL SPACING   = Sets the vertical spacing between text lines.
    HORIZONTAL SPACING = Sets the horizontal spacing between text
                         characters.
    THICKNESS          = Sets the thickness of TEXT characters.
    COLOR              = Sets the color for TEXT characters.
    JUSTIFICATION      = Sets the justification for TEXT.
    CR                 = Sets the carriage return after text.
    LF                 = Sets the line feed after text.
    MARGIN             = Sets the carriage return column after text.
    ()                 = Allows math and Greek characters in text.
    MOVE               = Moves to a point.
    CROSS-HAIR (or CH) = Activates and reads the cross-hair.
    ERASE              = Erases the screen (immediately).
    COPY               = Copies the screen (immediately).
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    VERTICAL SPACING 6
    CRLF ON
    MARGIN 10
    FONT DUPLEX
    .
    HW 4 2
    MOVE 5 95
    TEXT JAPAN's 6-POINT PROGRAM FOR
    MOVE 5 89
    TEXT QUALITY MANUFACTURING
    MOVE 10 80
    HW 2.2 1.1
    TEXT CIRC() QUALITY AUDITS
    TEXT CIRC() COMPANY-WIDE QUALITY CONTROL (CWQC)
    TEXT CIRC() QUALITY TRAINING AND EDUCATION
    TEXT CIRC() APPLICATION OF STATISTICAL METHODS
    TEXT CIRC() QUALITY CIRCLE ACTIVITIES
    TEXT CIRC() NATION-WIDE QUALITY CONTROL PROMOTIONAL ACTIVITIES
    HW 2 1
    MOVE 5 10
    TEXT SOURCE: Q.C. TRENDS WINTER 1985, PAGES 22-23.
 
-----CROSS-HAIR-------------------------------------------------------
 
CROSS-HAIR
 
Name:
    CROSS-HAIR
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Reads the screen position of a graphics input device (a cross-hair
    on a Tektronix terminal).
 
Description:
    When the CROSS-HAIR command is entered, a cross-hair (or some other
    type of icon) is generated on the screen.  After the cross-hair
    appears, it can be positioned via local thumbwheels, joysticks, or
    mouse (depending on the device).  After positioning, the
    coordinates can be read by either (depending on terminal type):
       1) Hitting any key (except the RETURN key); or
       2) Hitting any key (except the RETURN key), and then hitting the
          RETURN key; or
       3) Hitting one of the mouse buttons.
    After such reading, the coordinate values are printed on the
    screen.  To suppress such printing, the analyst should enter the
    FEEDBACK OFF command at some time before entering the CROSS-HAIR
    command.
 
Syntax 1:
    CROSS-HAIR
    where the coordinates (in units of 0 to 100) are printed on the
    screen.
 
Syntax 2:
    CROSS-HAIR   <x1>   <y1>
    where <x1> is a parameter where the x coordinate is returned (in
               units of 0 to 100);
    and   <y1> is a parameter where the y coordinate is returned (in
               units of 0 to 100).
 
Syntax 3:
    CROSS-HAIR   <x1>   <y1>   <x2>   <y2>
    where <x1> is a parameter where the x coordinate is returned (in
               units of 0 to 100);
          <y1> is a parameter where the y coordinate is returned (in
               units of 0 to 100);
          <x2> is a parameter where the x coordinate is returned (in
               units of the last plot);
    and   <y2> is a parameter where the y coordinate is returned (in
               units of the last plot).
 
    This latter feature makes it convenient for "reading off" data
    values from a curve that has already been plotted on the screen.
 
Examples:
    CROSS-HAIR
    CROSS-HAIR X1 Y1
    CROSS-HAIR X1 Y1 X2 Y2
 
Note:
    This command is currently supported on the Tektronix, X11, and the
    Sun devices.  It may not work on Tektronix emulators and may
    require some local code adjustments to work properly on the
    Tektronix for some operating systems.
 
Default:
    CROSS-HAIR with no arguments will print (in 0 to 100 units) the
    coordinates on the screen (but will not read such values into any
    parameters).
 
Synonyms:
    CH is a synonym for CROSS-HAIR.  CH is more commonly used than
    CROSS-HAIR.  CROSSHAIR is an infrequently used synonym.
 
Related Commands:
    TEXT               = Writes a text string.
    PLOT               = Generates a data/function plot.
    MOVE               = Moves to a point.
    DRAW               = Draws a line segment.
    BOX                = Draws a box.
    WINDOW COORDINATES = Sets the location of the plot window.
    FRAME COORDINATES  = Sets the location of the plot frame.
    LEGEND COORDINATES = Sets the location of plot legends.
    BOX COORDINATES    = Sets the location of plot boxes.
    ARROW COORDINATES  = Sets the location of plot arrows.
    SEGMENT COORDINATE = Sets the location of plot line segments.
    CURSOR COORDINATES = Sets the location of the post-plot cursor.
    FONT               = Sets the font for TEXT characters.
    HEIGHT             = Sets the height for TEXT characters.
    WIDTH              = Sets the width for TEXT characters.
    HW                 = Sets the height and width for TEXT characters.
    VERTICAL SPACING   = Sets the vertical spacing between text lines.
    HORIZONTAL SPACING = Sets the horizontal spacing between text
                         characters.
    THICKNESS          = Sets the thickness of TEXT characters.
    COLOR              = Sets the color for TEXT characters.
    JUSTIFICATION      = Sets the justification for TEXT.
    CR                 = Sets the carriage return after text.
    LF                 = Sets the line feed after text.
    CRLF               = Sets the carriage return/line feed after text.
    MARGIN             = Sets the carriage return column after text.
    ()                 = Allows math and Greek characters in text.
    MOVE               = Moves to a point.
    ERASE              = Erases the screen (immediately).
    COPY               = Copies the screen (immediately).
 
Applications:
    Presentation Graphics
 
Implementation Date:
    Pre-1987
 
Program:
    XX
 
-----CROSS TABULATE--------------------------------------
 
CROSS TABULATE
 
Name:
    CROSS TABULATE
 
Type:
    Analysis Command
 
Purpose:
    Generates a cross tabulation of a response variable for between
    two and six independent variables.
 
Description:
    The independent variables (also referred to as group-id variables),
    are mutually exclusive categories which form a two-way table.  The
    response variable must fall into exactly one row and column of
    this table.  By default, this command calculates the counts for
    each row and column combination.  Alternatively, it can calculate
    a specified statistic for each row and column combination.
 
    The 3/2008 version extended support for up to six independent
    variables.

    The 5/2014 version extended support for up to eight independent
    variables.

Syntax 1:
    CROSS TABULATE <tag1> ... <tagk>
                   <SUBSET/EXCEPT/FOR qualification>
    CROSS TABULATE COUNTS  <tag1> ... <tagk>
                   <SUBSET/EXCEPT/FOR qualification>
    where <tag1> ... <tagk> is a list of one to eight group-id variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax generates a count of the number of elements in each row
    and column combination.
 
Syntax 2:
    CROSS TABULATE <STAT> <y1> ... <yl>  <tag1> ... <tagk>
                   <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yl> is a list of one to three response variables
              (depending on <stat>);
          <tag1> ... <tagk> is a list of one to eight group-id variables;
          <stat> is one of Dataplot's supported statistics;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax computes the value of the specified statistic of the
    elements in the response variables (<y1> ... <yl>) for each row and
    column combination.

    For a list of supported statistics, enter

         HELP STATISTICS

    Note that if the statistic is SIZE (or NUMBER), then the response
    variable is omitted.
 
Examples:
    CROSS TABULATE Y1 TAG1 TAG2
    CROSS TABULATE Y1 TAG1 TAG2 SUBSET TAG2 = 2 TO 4
 
Note:
    The output is also written to the file DPST1F.DAT.  For example,

       CROSS TABULATE MEAN Y X1 X2
       SKIP 1
       READ Z1 Z2 ZMEAN
 
Note:
    To specify the number of digits to print to the right of the
    decimal point, enter the command (the default is exponential
    format)

       SET WRITE DECIMALS <value>

Note:
    Since there is now a separate CHI-SQUARE INDEPENDENCE TEST,
    the CHI-SQUARE option available in prior versions of Dataplot
    is no longer supported.
 
Note:
    If <stat> is BINOMIAL PROPORTION or DIFFERENCE OF BINOMIAL
    PROPORTIONS, then a few extra columns are printed.

    In these cases, the response variable is assumed to consist
    of 1's or 0's (to denote success or failure, respectively).
    In addition to the proportion of successes, a column will
    be printed for the number of trials and for the lower and
    upper Agresti-Coull confidence limits.  To specify whether
    lower tailed, upper tailed, or two-tailed confidence limits
    are desired, enter the command (two-tailed is the default)

        SET BINOMIAL TAIL  <LOWER/UPPER/TWO-TAILED>

    To specify the significance level to use for the confidence
    limits, enter (0.05 is the default)

        LET ALPHA = <value>

Note:
    In generating the cross tabulation, a cell may be empty.  The
    following command specifies what to do when an empty cell is
    encountered.

        SET CROSS TABULATE MISSING <SKIP/ZERO/MV>

    If SKIP is entered (this is the default), the empty cell is
    omitted from the output.

    If ZERO is entered, the value for the empty cell is set to zero.

    If MV is entered, the value for the empty cell is set to a missing
    value code.  The value for the missing value code is specified with
    the command

       SET CROSS TABULATE MISSING VALUE <value>

    where <value> is a numeric value.  The default value is -9999.

Default:
    None
 
Synonyms:
    TABULATE is a synonym for CROSS TABULATE
 
Related Commands:
    CROSS TABULATE (LET)  = Perofrm a cross tabulation (LET Subcommand)
    ANOVA                 = Performs an analysis of variance.
    FLUCTUATION PLOT      = Generates a fluctuation plot.
 
Applications:
    Exploratory Data Analysis
 
Implementation Date:
    1989/12
    2002/8: List of supported statistics greatly expanded.
    2003/3: Support for "WEIGHTED" and "DIFFERENCE OF" statistics
            added.
    2003/5: Added support for SN SCALE, QN SCALE,
            DIFFERENCE OF SN, DIFFERENCE OF QN
    2008/3: Added support for more than 2 group-id variables
    2008/3: Added support for SET WRITE DECIMALS command
    2010/2: TABULATE and CROSS TABULATE commands merged
    2014/5: Increase number of factor variables from six to eight

Program:
    SKIP 25
    READ RIPKEN.DAT Y X1 X2 X3 X4
    SET WRITE DECIMALS 4
    .
    CROSS TABULATE X1 X2
    CROSS TABULATE MEAN Y X1 X2 X3 X4
    CROSS TABULATE SD Y X1 X2 X3 X4
    CROSS TABULATE RANGE Y X1 X2 X3 X4
 
-----CROSS TABULATE (LET)-----------------------------------------
 
CROSS TABULATE (LET)
 
Name:
    CROSS TABULATE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Cross tabulate a variable by one to six factor variables
    and place the value of the computed statistic in the new
    array.
 
Description:
    This command is related to the CROSS TABULATE analysis
    command and the CROSS TABULATE PLOT command.  Those
    commands also compute statistics for cross tabulations.

    The distinction is that those commands compute one value
    of the staistic for unique cell in the cross tabulation.
    This command creates a new array of the same size as the
    input arrays and replaces ALL rows in the new array with
    the computed statistic corresponding to the cell in the
    cross tabulation.

    The reason for this command is to allow the cross tabulated
    values to be used in subsequent calculations.  For example,
    you could use this command to subtract the cell mean and 
    divide by the cell standard deviation.  Although you can
    perform this particular computation using the STANDARDIZE
    command, it does illustrate how this command is intended
    to be used.  In particular, it can helpful in computing
    statistics for one or two group variables that are not
    currently supported by the STATISTIC PLOT or CROSS TABULATE
    PLOT commands.

    An alternative to computing a single value of the statistic
    for each cell in the cross tabulaton is compute the cumulative
    value of the statistic for all elements in the cell.

Syntax 1:
    LET <yout> = CROSS TABULATE <stat> <y1> ... <yk>  <x1> ... <xl>
                                <SUBSET/EXCEPT/FOR qualification>
    where <stat> is one of the supported statistics (HELP STATISTICS
             for a list);
          <y1> ... <yk> is a list of 1 to 3 response variables (dependeing
             on what <stat> is);
          <x1> is a list of 0 to 6 group id variables;
          <yout> is a variable where the cross tabulated values are
             stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Syntax 2:
    LET <yout> = CROSS TABULATE CUMULATIVE <stat> <y1> ... <yk>  
                                <x1> ... <xl>
                                <SUBSET/EXCEPT/FOR qualification>
    where <stat> is one of the supported statistics (HELP STATISTICS
             for a list);
          <y1> ... <yk> is a list of 1 to 3 response variables (dependeing
             on what <stat> is);
          <x1> is a list of 0 to 4 group id variables;
          <yout> is a variable where the cross tabulated values are
             stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax computes the cumulative value of the statistic.

Examples:
    LET Y2 = CROSS TABULATE X1
    LET Y2 = CROSS TABULATE MEAN Y X1
    LET Y2 = CROSS TABULATE MEAN Y X1 X2
    LET Y2 = CROSS TABULATE CUMULATIVE MEAN Y X1
    LET Y2 = CROSS TABULATE MEAN Y X1 X2  SUBSET X1 = 1 TO 3

Note:
    By default, the output variable will have the same number of elements
    as the input variables.  However, if you enter the command

        SET LET CROSS TABULATE COLLAPSE

    only a single value will be saved in the output variable for each
    distinct combination of the group-id variables.

    In order to preserve the appropriate values of the group-id variables,
    you can enter the commands (assuming four group-id variables)

        LET X1D = CROSS TABULATE GROUP ONE   X1 X2 X3 X4
        LET X2D = CROSS TABULATE GROUP TWO   X1 X2 X3 X4
        LET X3D = CROSS TABULATE GROUP THREE X1 X2 X3 X4
        LET X4D = CROSS TABULATE GROUP FOUR  X1 X2 X3 X4

    This is demonstrated in Program 2 example below.

    To restore the default, enter

        SET LET CROSS TABULATE EXPAND

    This option is not supported for the CUMULATIVE (Syntax 2) option.

Note:
    If you use the SET LET CROSS TABULATE COLLAPSE command, the number
    of elements in the output variable will equal to the number unique
    combinations of the group-id variables.

    For example, if X1 has the uniques values 1, 2, and 3 and X2 has the
    unique values 1 and 2, there are 6 potential cells

        X1      X2
        ==      ==
         1       1
         1       2
         2       1
         2       2
         3       1
         3       2

    However, the X1 and X2 variables may not actually contain all of these
    potential combinations (i.e., you only have a partial grid of values).

    There may be some cases where you want the output variable to contain
    a value for the full grid of the group-id variables.  To specify this,
    enter the command

        SET LET CROSS TABULATE EMPTY ON

    In this case, empty cells in the grid will be set the "missing value".
    To specify this value, enter the command

        SET STATISTIC MISSING VALUE  <value>

    To restore the default behavior, enter

        SET LET CROSS TABULATE EMPTY OFF

    This option is not supported for the CUMULATIVE (Syntax 2) option.

Note:
    The following command was implemented

        SET LET CROSS TABULATE COMPLEMENT <OFF/ON/ONE/TWO>

    where

        OFF   - default behavior, extract data as defined by the
                group-id variables.

        ON    - for the last group-id variable, extract all data that is
                not equal to the specified group value.

        ONE   - for the last group-id variable, the first response variable
                will extract the values not equal to the specified group-id
                value and the second response variable will extract the values
                equal to the specified group value.

        TWO   - for the last group-id variable, the first response variable
                will extract the values equal to the specified group-id value
                and the second response variable will extract the values not
                equal to the specified group value.

    This option is not supported for the CUMULATIVE (Syntax 2) option.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    STATISTIC PLOT       = Generate a statistic versus subset plot.
    TABULATE             = Compute group statistics (one group
                           variable).
    CROSS TABULATE       = Compute group statistics (two group
                           variables).
    CROSS TABULATE  PLOT = Generate a statistic (two) subset
                           variables.
 
Applications:
    Data Analysis
 
Implementation Date:
    2001/10
    2002/08: List of supported statistics expanded
    2003/03: Support added for "WEIGHTED" and "DIFFERENCE OF"
             statistics.
    2009/02: Support COLLAPSE option
    2011/07: Support for SET LET CROSS TABULATE EMPTY
    2011/07: Support for SET LET CROSS TABULATE COMPLEMENT
    2013/01: Support for CUMULATIVE option
    2014/01: Increased number of factor variable from four to six
 
Program 1:
    SKIP 25
    READ GEAR.DAT Y X
    LET YMED = CROSS TABULATE MEDIAN Y X
    LET YIQ = CROSS TABULATE IQ RANGE Y X
    LET YSTAND = (Y - YMED)/YIQ

Program 2:
    SKIP 25
    READ GEAR.DAT Y X
    SET LET CROSS TABULATE COLLAPSE
    LET YMEAN = CROSS TABULATE MEAN Y X
    LET X1D = CROSS TABULATE GROUP ONE X
    SET WRITE DECIMALS 5
    PRINT X1D YMEAN

Program 3:
    SKIP 25
    READ GEAR.DAT Y X
    LET N = SIZE Y
    LET X2 = SEQUENCE 1 1 N
    .
    LET YMEAN = CROSS TABULATE CUMULATIVE MEAN Y X
    .
    SET WRITE DECIMALS 4
    PRINT X Y YMEAN
    .
    LINE COLOR BLUE RED GREEN BLUE RED GREEN BLUE RED GREEN BLUE
    LABEL CASE ASIS
    Y1LABEL Cumulative Mean Gear Diameter
    X1LABEL Batch
    .
    PLOT YMEAN X2 X

-----CROSS TABULATE PLOT---------------------------------------------
 
CROSS TABULATE PLOT
 
Name:
    ... CROSS TABULATE PLOT
 
Type:
    Graphics Command
 
Purpose:
    Generates a statistic versus a cross tabulated index plot for a
    given statistic.
 
Description:
    A cross tabulate plot consists of subsample statistic versus
    cross tabulated  subsample index.  The subsample statistic is the
    value of some statistic for the data in the subsample.

    This plot is an extension of the STATISTIC PLOT.  The STATISTIC
    PLOT uses one index variable while the CROSS TABULATE PLOT
    uses two index variables.

    The X axis coordinate is determined from the two group variables
    in the following way:

     i) The levels of the first group variable (e.g., X1)
        are plotted at 1, 2, 3, etc.

    ii) For each level of the group 1 variable, the levels of
        the group 2 variable are scaled +/- 0.2 around the
        level of the group 1 variable.

    For example, if X1 has 2 levels (at 1 and 2) and X2 has
    3 levels (1, 2, and 3), then the following x-coordinates
    are used:

          X1         X2        X-COOR
          ============================
           1          1        0.8
           1          2        1.0
           1          3        1.2
           2          1        1.8
           2          2        2.0
           2          3        2.2

    The syntax CROSS TABULATE X1 X2 is a special case.  It plots
    the value of X1 on the X axis and the value of X2 on the
    Y axis.  The plot character is then set to the count
    for that cell (this is done automatically and you do not need
    to set the plot character).  This form of the plot has
    application in the design of experiments.

    The cross tabulate plot is used to answer the
    question--"Does the subsample statistic change over different
    subsamples?".  The plot consists of:
       Vertical   axis = subsample statistic;
       Horizontal axis = subsample index.
    The cross tabulate plot yields 2 traces:
       1. a subsample statistic trace; and
       2. a sub-sample statistic reference line for the distinct
          values of the first index variable.
       3. a full-sample statistic reference line.
    Like usual, the appearance of these 2 traces is controlled by
    the first 2 settings of the LINES, CHARACTERS, SPIKES, BARS,
    and similar attributes.
 
Syntax 1:
    CROSS TABULATE <stat> PLOT <y> <x1> <x2>
                                      <SUBSET/EXCEPT/FOR qualification>
    where <stat> is one of the following statistics:
              MEAN, MIDMEAN, MEDIAN, TRIMMED MEAN, WINDSORIZED MEAN,
              GEOMETRIC MEAN, HARMONIC MEAN, HODGES LEHMAN,
              BIWEIGHT LOCATION,
              SUM, PRODUCT, SIZE (or NUMBER or SIZE),
              STANDARD DEVIATION, STANDARD DEVIATION OF MEAN,
              AVERAGE ABSOLUTE DEVIATION (or AAD),
              MEDIAN ABSOLUTE DEVIATION (or MAD),
              IQ RANGE, BIWEIGHT MIDVARIANCE, BIWEIGHT SCALE,
              VARIANCE, VARIANCE OF THE MEAN,
              PERCENTAGE BEND MIDVARIANCE, SN SCALE, QN SCALE,
              RELATIVE STANDARD DEVIATION, RELATIVE VARIANCE (or
                 COEFFICIENT OF VARIATION),
              RANGE, MIDRANGE, MAXIMUM, MINIMUM, EXTREME,
              LOWER HINGE, UPPER HINGE, LOWER QUARTILE, UPPER QUARTILE,
              <FIRST/SECOND/THIRD/FOURTH/FIFTH/SIXTH/SEVENTH/EIGHTH/
                  NINTH/TENTH> DECILE,
              PERCENTILE, QUANTILE, QUANTILE STANDARD ERROR,
              SKEWNESS, KURTOSIS, NORMAL PPCC,
              AUTOCORRELATION, AUTOCOVARIANCE,
              SIN FREQUENCY, SIN AMPLITUDE,
              CP, CPK, CNPK, CPM, CC,
              EXPECTED LOSS, PERCENT DEFECTIVE,
              TAGUCHI SN0 (or SN), TAGUCHI SN+ (or SNL),
              TAGUCHI SN- (or SNS), TAGUCHI SN00 (or SN2);
          <y> is the response (= dependent) variable;
          <x1> is the first subsample identifier variable (this variable
              appears on the horizontal axis);
          <x2> is the second subsample identifier variable (this variable
              appears on the horizontal axis);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for statistics that require a single variable to
    compute.
 
Syntax 2:
    CROSS TABULATE <stat> PLOT <y1> <y2> <x1> <x2>
                                    <SUBSET/EXCEPT/FOR qualification>
    where <stat> is one of the following statistics:
              LINEAR INTERCEPT, LINEAR SLOPE,
              LINEAR CORRELATION, LINEAR RESSD,
              CORRELATION, RANK CORRELATION,
              COVARIANCE, RANK COVARIANCE,
              WINSORIZED COVARIANCE, WINSORIZED COVARIANCE,
              BIWEIGHT MIDCOVARIANCE, BIWEIGHT MIDCORRELATION,
              PERCENTAGE BEND CORRELATION,
              ODDS RATIO, ODDS RATIO STANDARD ERROR,
              LOG ODDS RATIO, LOG ODDS RATIO STANDARD ERROR,
              FALSE POSITIVE, FALSE NEGATIVE,
              TRUE POSITIVE, TRUE NEGATIVE,
              TEST SENSITIVITY, TEST SPECIFICITY,
              POSITIVE PREDICTIVE VALUE, NEGATIVE PREDICTIVE VALUE,
              RELATIVE RISK,
              RATIO;
          <y1> is the first response variable;
          <y2> is the second response variable;
          <x1> is the first subsample identifier variable (this variable
              appears on the horizontal axis);
          <x2> is the second subsample identifier variable (this variable
              appears on the horizontal axis);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for statistics that require two response
    variables to compute.  If a linear fit is performed, the first
    variable is the dependent variable while the second variable
    is the independent variable.
 
Syntax 3:
    CROSS TABULATE WEIGHTED <stat> PLOT <y1> <wt> <x1> <x2>
                                    <SUBSET/EXCEPT/FOR qualification>
    where <stat> is one of the following statistics:
              MEAN, STANDARD DEVIATION (or SD), VARIANCE;
          <y1> is the response variable;
          <wt> is the weights variable variable;
          <x1> is the first subsample identifier variable (this variable
              appears on the horizontal axis);
          <x2> is the second subsample identifier variable (this variable
              appears on the horizontal axis);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used to compute the weighted version of the
    specified statistic for a single response variable.
 
Syntax 4:
    CROSS TABULATE DIFFERENCE OF <stat> PLOT <y1> <y2> <x1> <x2>
                                    <SUBSET/EXCEPT/FOR qualification>
    where <stat> is one of the following statistics:
              MEAN, MIDMEAN, MEDIAN, TRIMMED MEAN, WINSORIZED MEAN,
              GEOMETRIC MEAN, HARMONIC MEAN, HODGES LEHMAN,
              MIDRANGE, BIWEIGHT LOCATION, SUM,
              STANDARD DEVIATION, STANDARD DEVIATION OF MEAN,
              VARIANCE, VARIANCE OF THE MEAN,
              AVERAGE ABSOLUTE DEVIATION (or AAD),
              MEDIAN ABSOLUTE DEVIATION (or MAD),
              IQ RANGE, BIWEIGHT MIDVARIANCE, BIWEIGHT SCALE,
              PERCENTAGE BEND MIDVARIANCE, SN SCALE, QN SCALE,
              WINSORIZED VARIANCE, WINSORIZED STANDARD DEVIATION,
              RELATIVE STANDARD DEVIATION, RELATIVE VARIANCE,
              COEFFICIENT OF VARIATION, RANGE,
              MAXIMUM, MINIMUM, EXTREME, QUANTILE,
              SKEWNESS, KURTOSIS;
          <y1> is the first response variable;
          <y2> is the second response variable;
          <x1> is the first subsample identifier variable (this variable
              appears on the horizontal axis);
          <x2> is the second subsample identifier variable (this variable
              appears on the horizontal axis);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used to compute the difference between two
    response variables for the specified statistic.  The variables
    can be either independent (i.e., not paired) or dependent (i.e.,
    paired), but the response variables must have the same number of
    elements.
 
Examples:
    CROSS TABULATE MEAN PLOT Y X1 X2
    CROSS TABULATE STANDARD DEVIATION PLOT Y X1 X2
 
Note:
    If you have more than 2 index variables, you can use the SCATTER 
    PLOT MATRIX command to generate all the pairwise combinations of
    the index variables on a single page.  Enter 

        HELP SCATTER PLOT MATRIX 

    for details (and specifically, SET SCATTER PLOT MATRIX TYPE).

Note:
    There may be cases where you want the format used by the
    CROSS TABULATE PLOT X1 X2 used for one of the statistics.  This
    can be specified with the following command:

        SET CROSS TABULATE PLOT DIMENSION 2

    To reset the default, enter

        SET CROSS TABULATE PLOT DIMENSION 1
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CHARACTERS              = Sets the type for plot characters.
    LINES                   = Sets the type for plot lines.
    STATISTIC PLOT          = Generates a statistic versus subsample
                              plot for one index variable.
    CROSS TABULATE          = Generates a table of cross tabulated
                              values for several common statistics.
 
Applications:
    Exploratory Data Analysis
 
Implementation Date:
    2000/1
    2003/3: Support added for "WEIGHTED" and "DIFFERENCE OF"
            statistics.
 
Program:
    SKIP 25
    READ RIPKEN.DAT Y X1 TO X4
    .
    CHARACTER X BLANK BLANK
    LINE BLANK SOLID SOLID
    CROSS TABULATE MEAN PLOT Y X1 X2
 
-----CROSS TABULATE PLOT DIMENSION (SET)-----------------------------
 
CROSS TABULATE PLOT DIMENSION
 
Name:
    CROSS TABULATE PLOT DIMENSION (SET)
 
Type:
    Set Subcommand
 
Purpose:
    Specify the format for the CROSS TABULATE PLOT command.
 
Description
    The default format for the cross tabulate plot is similar
    to the STATISTIC PLOT command.  That is, the group id's
    for both variables define the horizontal axis and the value
    of the desired statistic is plotted on the vertical axis.
    An alternate formation plots one group id on the horizontal
    axis, the other group id on the vertical axis, and the plot
    symbol is set to the value of the statistic (essentially
    a table in graphic format). 

    Setting the dimension to 1 uses the first format and setting
    the dimension to 2 uses the alternate format.

Syntax:
    SET CROSS TABULATE PLOT DIMENSION <1/2>
    where 1 specifies the default format (both group ids on the
            horizontal axis and 2 specifies the alternate
            format (each group id on a separate axis, the plot
            symbol set to the value of the statistic).
 
Examples:
    SET CROSS TABULATE PLOT DIMENSION 1
    SET CROSS TABULATE PLOT DIMENSION 2
 
Default:
    The default is 1.
 
Synonyms:
    None
 
Related Commands:
    CROSS TABULATE PLOT  = Generate a CROSS TABULATE PLOT.
 
Applications:
    Plotting grouped data
 
Implementation Date:
    2000/1
 
Program:
    SKIP 25
    READ RIPKEN.DAT Y X1 TO X4
    CHARACTER X BLANK BLANK
    LINE BLANK SOLID SOLID
    CROSS TABULATE MEAN PLOT Y X1 X2
    SET CROSS TABULATE PLOT DIMENSION 2
    CROSS TABULATE MEAN PLOT Y X1 X2
 
-----CSC (LET)---------------------------------------------------
 
CSC
 
Name:
    CSC (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the cosecant for a variable or parameter.
 
Description:
    The cosecant is defined for all real numbers except integer
    multiples of PI.  The range is 1 to plus infinity and -1 to
    negative infinity.  By default, the angle is specified in radian
    units.  To use degree values, enter the command ANGLE UNITS DEGREES
    (ANGLE UNITS RADIANS resets it).
 
Syntax:
    LET <y2> = CSC(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed cosecant value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CSC(-2)
    LET A = CSC(A1)
    LET X2 = CSC(X1)
    LET X2 = CSC(PI/2)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SIN      = Compute the sine.
    COS      = Compute the cosine.
    TAN      = Compute the tangent.
    COT      = Compute the cotangent.
    SEC      = Compute the secant.
    ARCCOS   = Compute the arccosine.
    ARCSIN   = Compute the arcsine.
    ARCTAN   = Compute the arctangent.
    ARCCOT   = Compute the arccotangent.
    ARCSEC   = Compute the arcsecant.
    ARCCSC   = Compute the arcsecant.
 
Reference:
    Consult any standard trigonometry or pre-calculus textbook.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    TITLE PLOT COSECANT FROM -3.1 TO 3.1
    X1LABEL ANGLE (IN RADIANS)
    Y1LABEL COSECANT VALUE
    READ X Y TAG
    -3.1   1  1
     3.1   1  1
    -3.1  -1  2
     3.1  -1  2
     0.   20  3
     0.   -20 3
     3.14   20  4
     3.14   -20 4
    -3.14   20  5
    -3.14   -20 5
    END OF DATA
    YLIMITS -20 20
    XLIMITS -3 3
    XTIC OFFSET .4 .4
    LINES SOLID SOILD DOT DOT DOT DOT DOT
    PLOT CSC(X) FOR X = .1 .1 3.1 AND
    PLOT CSC(X) FOR X = -.1 -.1 -3.1 AND
    PLOT Y X TAG
 
-----CSCH (LET)---------------------------------------------------
 
CSCH
 
Name:
    CSCH (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the hyperbolic cosecant for a variable or parameter.
 
Description:
    The equation for the hyperbolic cosecant is:
        csch(x) = 1/(e**x - e**-x)
    The hyperbolic cosecant is defined for all real numbers except
    zero.  The range is minus infinity to plus infinity.
 
Syntax:
    LET <y2> = CSCH(<y1>)  <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a variable or a parameter;
          <y2> is a variable or a parameter (depending on what <y1> is)
               where the computed hyperbolic cosecant value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CSCH(-2)
    LET A = CSCH(A1)
    LET X2 = CSCH(X1)
    LET X2 = CSCH(PI/2)
 
Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SIN      = Compute the sine.
    COS      = Compute the cosine.
    TAN      = Compute the tangent.
    COT      = Compute the cotangent.
    SEC      = Compute the secant.
    CSC      = Compute the cosecant.
    ARCCOS   = Compute the arccosine.
    ARCSIN   = Compute the arcsine.
    ARCTAN   = Compute the arctangent.
    ARCCOT   = Compute the arccotangent.
    ARCSEC   = Compute the arcsecant.
    ARCCSC   = Compute the arcsecant.
    SINH     = Compute the hyperbolic sine.
    TANH     = Compute the hyperbolic tangent.
    COTH     = Compute the hyperbolic cotangent.
    SECH     = Compute the hyperbolic secant.
    CSCH     = Compute the hyperbolic cosecant.
    ARCCOSH  = Compute hyperbolic arccosine.
    ARCCOTH  = Compute hyperbolic arccotangent.
    ARCCSCH  = Compute hyperbolic arccosecant.
    ARCSECH  = Compute hyperbolic arcsecant.
    ARCSINH  = Compute hyperbolic arcsine.
    ARCTANH  = Compute hyperbolic arctangent.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    TITLE PLOT HYPERBOLIC COSECANT FROM -3.1 TO 3.1
    READ X Y TAG
     0.   20  1
     0.  -20  1
     3.1   0  2
    -3.1   0  2
    END OF DATA
    YLIMITS -20 20
    XLIMITS -3 3
    XTIC OFFSET .4 .4
    LINES SOLID SOILD DOT DOT
    PLOT CSCH(X) FOR X = .05 .05 3.1 AND
    PLOT CSCH(X) FOR X = -.05 -.05 -3.1 AND
    PLOT Y X TAG
 
-----CSIN (LET)---------------------------------------------------
 
CSIN
 
Name:
    CSIN (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the real component of the sine of a complex number.
 
Syntax:
    LET <yr> = CSIN(<xr>,<xc>)  <SUBSET/EXCEPT/FOR qualification>
    where <xr> is a number, parameter, or variable that specifies the
               real component of the the complex number;
          <xc> is a number, parameter, or variable that specifies the
               complex component of the the complex number;
          <yr> is a variable or a parameter (depending on what <xr> and
               <xc> are) where the real component of the computed sine
               value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CSIN(-2,1)
    LET A = CSIN(A1,-2)
    LET X2 = CSIN(XR,XC)
    LET X2 = CSIN(PI/2,-PI/4)
 
Note:
    DATAPLOT uses the Fortran intrinsic function CSIN to compute this
    function.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SIN    = Compute the sine of a real number.
    CSINI  = Compute the complex component of the sine of a complex
             number.
    CABS   = Compute the absolute value of a complex number.
    CCOS   = Compute the real component of the cosine of a complex
             number.
    CCOSI  = Compute the complex component of the cosine of a complex
             number.
    CEXP   = Compute the real component of the exponential of a complex
             number.
    CEXPI  = Compute the complex component of the exponential of a
             complex number.
    CLOG   = Compute the real component of the logarithm of a complex
             number.
    CLOGI  = Compute the complex component of the logarithm of a
             complex number.
    CSQRT  = Compute the real component of the square root of a complex
             number.
    CSQRTI = Compute the complex component of the square root of a
             complex number.
 
Applications:
    XX
 
Implementation Date:
    94/10
 
Program:
    LINE SOLID DASH
    PLOT CSIN(X,-PI/2) FOR X = -10 0.1 10 AND
    PLOT CSIN(X,-PI/2) FOR X = -10 0.1 10
 
-----CSINI (LET)---------------------------------------------------
 
CSINI
 
Name:
    CSINI (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the complex component of the sine of a complex number.
 
Syntax:
    LET <yr> = CSINI(<xr>,<xc>)  <SUBSET/EXCEPT/FOR qualification>
    where <xr> is a number, parameter, or variable that specifies the
               real component of the the complex number;
          <xc> is a number, parameter, or variable that specifies the
               complex component of the the complex number;
          <yr> is a variable or a parameter (depending on what <xr> and
               <xc> are) where the real component of the computed sine
               value is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CSINI(-2,1)
    LET A = CSINI(A1,-2)
    LET X2 = CSINI(XR,XC)
    LET X2 = CSINI(PI/2,-PI/4)
 
Note:
    DATAPLOT uses the Fortran intrinsic function CSIN to compute this
    function.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SIN    = Compute the sine of a real number.
    CSIN   = Compute the real component of the sine of a complex
             number.
    CABS   = Compute the absolute value of a complex number.
    CCOS   = Compute the real component of the cosine of a complex
             number.
    CCOSI  = Compute the complex component of the cosine of a complex
             number.
    CEXP   = Compute the real component of the exponential of a complex
             number.
    CEXPI  = Compute the complex component of the exponential of a
             complex number.
    CLOG   = Compute the real component of the logarithm of a complex
             number.
    CLOGI  = Compute the complex component of the logarithm of a
             complex number.
    CSQRT  = Compute the real component of the square root of a complex
             number.
    CSQRTI = Compute the complex component of the square root of a
             complex number.
 
Applications:
    XX
 
Implementation Date:
    94/10
 
Program:
    LINE SOLID DASH
    PLOT CSIN(X,-PI/2) FOR X = -10 0.1 10 AND
    PLOT CSIN(X,-PI/2) FOR X = -10 0.1 10
 
-----CSQRT (LET)--------------------------------
 
CSQRT
 
Name:
    CSQRT (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the real component of the square root function for a
    complex number.
 
Syntax:
    LET <yr> = CSQRT(<xr>,<xc>)  <SUBSET/EXCEPT/FOR qualification>
    where <xr> is a number, parameter, or variable that specifies the
               real component of the the complex number;
          <xc> is a number, parameter, or variable that specifies the
               complex component of the the complex number;
          <yr> is a variable or a parameter (depending on what <xr> and
               <xc> are) where the computed square root value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CSQRT(14,-2)
    LET A = CSQRT(A1,4)
    LET X2 = CSQRT(XR,XC)
    LET X2 = CSQRT(XR,6)
 
Note:
    DATAPLOT uses the Fortran intrinsic function CSQRT to compute this
    function.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SQRT   = Compute the square root of a real number.
    CSQRTI = Compute the complex component of the square root of a
             complex number.
    CABS   = Compute the absolute value of a complex number.
    CCOS   = Compute the real component of the cosine of a complex
             number.
    CCOSI  = Compute the complex component of the cosine of a complex
             number.
    CEXP   = Compute the real component of the exponential of a
             complex number.
    CEXPI  = Compute the complex component of the exponential of a
             complex number.
    CLOG   = Compute the real component of the logarithm of a complex
             number.
    CLOGI  = Compute the complex component of the logarithm of a
             complex number.
    CSIN   = Compute the real component of the sine of a complex
             number.
    CSINI  = Compute the complex component of the sine of a complex
             number.
 
Applications:
    XX
 
Implementation Date:
    94/10
 
Program:
    LINE SOLID DASH
    PLOT CSQRT(X,2) FOR X = 0.1 0.1 20 AND
    PLOT CEXPI(X,2) FOR X = 0.1 0.1 20
 
-----CSQRTI (LET)--------------------------------
 
CSQRTI
 
Name:
    CSQRTI (LET)
 
Type:
    Library Function
 
Purpose:
    Compute the complex component of the square root function for a
    complex number.
 
Syntax:
    LET <yc> = CSQRTI(<xr>,<xc>)  <SUBSET/EXCEPT/FOR qualification>
    where <xr> is a number, parameter, or variable that specifies the
               real component of the the complex number;
          <xc> is a number, parameter, or variable that specifies the
               complex component of the the complex number;
          <yc> is a variable or a parameter (depending on what <xr> and
               <xc> are) where the computed square root value is saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET A = CSQRTI(14,-2)
    LET A = CSQRTI(A1,4)
    LET X2 = CSQRTI(XR,XC)
    LET X2 = CSQRTI(XR,6)
 
Note:
    DATAPLOT uses the Fortran intrinsic function CSQRT to compute this
    function.

Note:
    Library functions are distinguished from let subcommands
    in the following ways.
    1) Functions enclose the input value in parenthesis.  Let
       subcommands use spaces.
    2) Functions can accept (and return) either parameters
       (i.e., single values) or variables (i.e., an array of
       values) while let subcommands are specific in which they
       accept as input and what they return as output.
    3) Functions can accept expressions while let subcommands
       do not.  For example, the following is legal:
           LET Y2 = ABS(Y1-INT(Y1))
       For let subcommands, you typically have to do something
       like the following:
           LET YTEMP = Y**2 + 8
           LET A = SUM YTEMP
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SQRT   = Compute the square root of a real number.
    CSQRT  = Compute the real component of the square root of a
             complex number.
    CABS   = Compute the absolute value of a complex number.
    CCOS   = Compute the real component of the cosine of a complex
             number.
    CCOSI  = Compute the complex component of the cosine of a complex
             number.
    CEXP   = Compute the real component of the exponential of a
             complex number.
    CEXPI  = Compute the complex component of the exponential of a
             complex number.
    CLOG   = Compute the real component of the logarithm of a complex
             number.
    CLOGI  = Compute the complex component of the logarithm of a
             complex number.
    CSIN   = Compute the real component of the sine of a complex
             number.
    CSINI  = Compute the complex component of the sine of a complex
             number.
 
Applications:
    XX
 
Implementation Date:
    94/10
 
Program:
    LINE SOLID DASH
    PLOT CSQRT(X,2) FOR X = 0.1 0.1 20 AND
    PLOT CEXPI(X,2) FOR X = 0.1 0.1 20
 
-----CUBE-------------------------------------------------------
 
CUBE
 
Name:
    CUBE
 
Type:
    Diagrammatic Graphics Command
 
Purpose:
    Draws a CUBE.
 
Description:
    The 2 pairs of coordinates define the (x,y) values for two
    opposing corners of the front square. The coordinates for drawing
    the other faces are automatically determined from these 2
    coordinates.
 
Syntax:
    CUBE   <x1>   <y1>   <x2>   <y2>
    where <x1> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for one corner;
          <y1> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for one corner;
          <x2> is a number or parameter in the decimal range 0 to 100
               that specifies the x coordinate for the other corner;
    and   <y2> is a number or parameter in the decimal range 0 to 100
               that specifies the y coordinate for the other corner.
 
    If more than 4 numbers are given, more than one cube will be drawn.
 
Examples:
    CUBE 50 50 60 50
    CUBE XLOW YLOW XHIGH YHIGH
    CUBE 50 50 60 60 70 70 (equivalent to:
           CUBE 50 50 60 60
           CUBE 60 60 70 70 )
    REGION FILL ON; CUBE 10 10 25 30
    REGION FILL ON; REGION PATTERN VERTICAL; CUBE 10 10 25 30
 
Note:
    The line style (i.e., solid, dash), color, and thickness are
    controlled by the LINE, LINE COLOR, and LINE THICKNESS commands.
    The REGION FILL ON command can be used to generate solid filled
    cubes.  The following options can be specified (e.g., REGION FILL
    ONTS) to control which faces of the cube are filled:
        ONTS  = fill the top and side faces
        ONST  = fill the top and side faces
        ONF   = fill the front face
        ONS   = fill the side face
        ONT   = fill the top face
        ONFS  = fill the front face and the side face
        ONSF  = fill the front face and the side face
        ONFT  = fill the front face and the top face
        ONTF  = fill the front face and the top face
        ON    = fill the front, top, and side faces
        OFF   = do not fill any part of the cube
    The REGION PATTERN can be used to do a hatch pattern fill.  Other
    REGION commands can be used to control how the fill is done.
 
 
Note:
    If you use a software font, cubes can be embedded in text (e.g.,
    the LEGEND or TEXT command) by entering the string CUBE().  Cubes
    can also be used as plot characters (e.g., CHARACTERS CUBE), in
    which case the attributes are set with the various CHARACTER
    commands.
 
Note:
    The keywords DATA and RELATIVE were added to the TRIANGLE
    command 7/1997.  These keywords are independent and can
    be used separately or together.  For example, 
    TRIANGLE DATA, TRIANGLE RELATIVE, or TRIANGLE DATA RELATIVE.
    The word DATA should come before the word RELATIVE if both
    appear.

    DATA means that the coordinates are specified in terms of
    the data units of the most recent plot rather than Dataplot
    0 to 100 screen units.

    RELATIVE means that the coordinates of the first point
    are drawn in absolute coordinates an all subsequent points
    in the figure are relative to that first point.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    POINT            = Draws a point.
    ARROW            = Draws an arrow.
    TRIANGLE         = Draws a triangle.
    BOX              = Draws a box.
    HEXAGON          = Draws a hexagon.
    CIRCLE           = Draws a circle.
    SEMI-CIRCLE      = Draws a semi-circle.
    ARC              = Draws an arc.
    ELLIPSE          = Draws an ellipse.
    OVAL             = Draws an oval.
    DIAMOND          = Draws a diamond.
    DRAW             = Draws a line.
    MOVE             = Moves to a point.
    LINES            = Sets the line type for figures and plot lines.
    LINE THICKNESSES = Sets the line thickness for figures and  plot
                       lines.
    LINE COLOR       = Sets the line colors for figures and plot lines.
    CROSS-HAIR       = Activates and reads the cross-hair.
    TEXT             = Writes a text string.
    REGION FILL      = Specifies whether a figure is filled or not.
    REGION PATTERN   = Sets the type of fill pattern to use for
                       figures.
 
Default:
    None
 
Synonyms:
    None
 
Applications:
    Presentation Graphics
 
Implementation Date:
    Pre-1987
 
Program:
    LET XCOOR = DATA 10 23 46
    LET YCOOR = DATA 8 17 32
    LET XINC = 12
    LET YINC = 14
    LET N = SIZE XCOOR
    LOOP FOR K = 1 1 N
        LET X1 = XCOOR(K)
        LET Y1 = YCOOR(K)
        LET X2 = X1 + XINC
        LET Y2 = Y1 + YINC
        CUBE X1 Y1 X2 Y2
    END OF LOOP
 
-----CUMULATIVE AVERAGE (LET)--------------------------------
 
CUMULATIVE AVERAGE
 
Name:
    CUMULATIVE AVERAGE (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the cumulative average of a variable.
 
Description:
    The cumulative average, Y2, of a variable Y is defined as:
        Y2(1) = Y(1)
        Y2(2) = (Y(1) + Y(2))/2
        Y2(3) = (Y(1) + Y(2) + Y(3))/3
            etc. 
 
Syntax:
    LET <y2> = CUMULATIVE AVERAGE <y1> 
                          <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a  response variable;
          <y2> is a variable where the cumulative average is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y2 = CUMULATIVE AVERAGE Y
    LET Y2 = CUMULATIVE AVERAGE Y FOR I = 1 1 30
 
Default:
    None
 
Synonyms:
    CUMULATIVE MEAN is a synonym for CUMULATIVE AVERAGE.
 
Related Commands:
    MEAN             = Compute the mean of a variable.
    CUMULATIVE SUM   = Compute the cumulative sum of a variable.
    CUMULATIVE PROD  = Compute the cumulative product of a variable.
    CUMULATIVE INTE  = Compute the cumulative integral of a variable.
 
Applications:
    Data Manipulation
 
Implementation Date:
    1998/5
 
Program:
    SKIP 25
    READ HAHN.DAT Y
    LET YAVE = CUMULATIVE AVERAGE Y
    PLOT Y
 
-----CUMULATIVE HAZARD (LET)-------------------------------------
 
CUMULATIVE HAZARD
 
Name:
    CUMULATIVE HAZARD (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the cumulative hazard for a set of failure times.
 
Description:
    The hazard is constructed as follows:

       1) Sort and rank the N failure times from shortest to longest
          failure time.  Note that the hazard can accomodate
          data where the time may be a censoring time rather
          than a failure time (i.e., the unit was taken out of
          service before it failed).

       2) Calculate a hazard value at each of the failure times.
          Note that the hazard is only caclulated at failure
          times, not censoring times.  The hazard is:

             100.0*(1/(N-K+1)

          where K is the rank of the failure time.  This expresses
          the hazard as a percentage.  You can express the hazard
          as a proportion by omitting the multiplication by 100.

       3) The cumulative hazard is the cumulative sum of the
          hazard.  That is, the cumulative hazard at the failure
          time with rank K is the sum of the hazards of all
          failure times with ranks less than or equal to K.

Syntax:
    LET <y> = CUMULATIVE HAZARD <x>  <tag>
                              <SUBSET/EXCEPT/FOR qualification>
    where <x> is the variable containing the failure times;
          <tag> is a variable that indicates whether the corresponding
              element of <x> is a failure time or a censoring
              time;
          <y> is a variable (of length 1 less than <x1>) where the
              cumulative hazards are saved;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    A value of 0 for <tag> is used to signify a censoring time and
    a value of 1 for <tag> is used to signify a failure time.
    Dataplot uses 0.5 as the cutoff.  That is, any value greater
    than or equal to 0.5 is interpreted as a failure time.

Examples:
    LET Y = CUMULATIVE HAZARD X CENSOR
    LET Y = CUMULATIVE HAZARD X CENSOR SUBSET CENSOR = 1
 
Note:
    Hazards are only computed for failure times (i.e., where
    <tag> = 1), not censoring times.  The saved cumulative
    hazards (<y>) are set to 0 for censoring times.  If you just
    want to keep the cumulative hazards at failure times, do
    something like:

        LET Y = CUMULATIVE HAZARD X CENSOR
        RETAIN Y SUBSET CENSOR = 1

    The censoring times do affect the value of the cumulative
    hazard since they are used in determining the rank.  If you
    only want the failure times to be used in the calculation of
    the cumulative hazard, do something like the following:

        LET Y = CUMULATIVE HAZARD X CENSOR SUBSET CENSOR = 1
        RETAIN Y SUBSET CENSOR = 1

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    HAZARD             = Compute the hazard for a variable.
    HAZARD PLOT        = Generate a hazard plot.
    PROBABILITY PLOT   = Generate a probability plot.
    WEIBULL PLOT       = Generate a Weibull plot.
    INTERARRIVAL TIME  = Compute the interarrival times of a
                         variable.
 
Applications:
    Reliability
 
Implementation Date:
    1998/5
 
Program:
    SKIP 25
    READ HAHN.DAT Y TAG
    LET TAG = 0 SUBSET TAG = 2
    LET Z = CUMULATIVE HAZARD Y TAG
 
-----CUMULATIVE INTEGRAL (LET)--------------------------------
 
CUMULATIVE INTEGRAL
 
Name:
    CUMULATIVE INTEGRAL (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the cumulative integral for a variable.
 
Description:
    For element I of the given variable, the cumulative integral is the
    integral of elements 1 through I.  This command can be used to
    compute integrals for a set of data points.  Use the INTEGRAL (a
    LET subcommand) to compute the integral of a function.
 
Syntax:
    LET <y2> = CUMULATIVE INTEGRAL <y1>
                   <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a response variable;
          <y2> is a variable where the computed cumulative integrals
               are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y2 = CUMULATIVE INTEGRAL Y1
    LET Y2 = CUMULATIVE INTEGRAL Y1 SUBSET Y1 > 0
 
Note:
    This command uses the Trapezoid rule to compute the integral
    (Gaussian quadrature is used to calculate the integral of a
    function).
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    INTEGRAL (LET)      = Compute the integral of a function or
                          variable.
    CUMULATIVE PRODUCT  = Compute the cumulative product of a variable.
    CUMULATIVE SUM      = Compute the cumulative sum of a variable.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 100
    LET Y2 = CUMULATIVE INTEGRAL Y1
 
-----CUMULATIVE MAXIMUM (LET)--------------------------------
 
CUMULATIVE MAXIMUM
 
Name:
    CUMULATIVE MAXIMUM (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the cumulative maximum for a variable.
 
Description:
    For element I of the given variable, the cumulative maximum is the
    maximum of elements 1 through I.
 
Syntax:
    LET <y> = CUMULATIVE MAXIMUM <x>   <SUBSET/EXCEPT/FOR qualification>
    where <x> is a  response variable;
          <y> is a variable where the computed cumulative maximums are
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y2 = CUMULATIVE MAXIMUM Y1
    LET Y2 = CUMULATIVE MAXIMUM Y1 SUBSET Y1 > 0
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    MAXIMUM             = Compute the maximum of a variable.
    CUMULATIVE MINIMUM  = Compute the cumulative minimum of a variable.
    CUMULATIVE MEAN     = Compute the cumulative mean of a variable.
    CUMULATIVE SUM      = Compute the cumulative sum of a variable.
    CUMULATIVE PRODUCT  = Compute the cumulative product of a variable.
    CUMULATIVE INTEGRAL = Compute the cumulative integral of a
                          variable.
 
Applications:
    Data Analysis
 
Implementation Date:
    2012/12
 
Program:
    let y = norm rand numb for i = 1 1 10
    .
    let y1 = cumulative sum  y
    let y2 = cumulative mean y
    let y3 = cumulative mini y
    let y4 = cumulative maxi y
    .
    set write decimals 3
    print y y1 y2 y3 y4

-----CUMULATIVE MINIMUM (LET)--------------------------------
 
CUMULATIVE MINIMUM
 
Name:
    CUMULATIVE MINIMUM (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the cumulative minimum for a variable.
 
Description:
    For element I of the given variable, the cumulative minimum is the
    minimum of elements 1 through I.
 
Syntax:
    LET <y> = CUMULATIVE MINIMUM <x>   <SUBSET/EXCEPT/FOR qualification>
    where <x> is a  response variable;
          <y> is a variable where the computed cumulative minimums are
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y2 = CUMULATIVE MINIMUM Y1
    LET Y2 = CUMULATIVE MINIMUM Y1 SUBSET Y1 > 0
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    MINIMUM             = Compute the minimum of a variable.
    CUMULATIVE MAXIMUM  = Compute the cumulative maximum of a variable.
    CUMULATIVE MEAN     = Compute the cumulative mean of a variable.
    CUMULATIVE SUM      = Compute the cumulative sum of a variable.
    CUMULATIVE PRODUCT  = Compute the cumulative product of a variable.
    CUMULATIVE INTEGRAL = Compute the cumulative integral of a
                          variable.
 
Applications:
    Data Analysis
 
Implementation Date:
    2012/12
 
Program:
    let y = norm rand numb for i = 1 1 10
    .
    let y1 = cumulative sum  y
    let y2 = cumulative mean y
    let y3 = cumulative mini y
    let y4 = cumulative maxi y
    .
    set write decimals 3
    print y y1 y2 y3 y4

-----CUMULATIVE PRODUCT (LET)--------------------------------
 
CUMULATIVE PRODUCT
 
Name:
    CUMULATIVE PRODUCT (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the cumulative product for a variable.
 
Description:
    For element I of the given variable, the cumulative product is the
    product of elements 1 through I.
 
Syntax:
    LET <y2> = CUMULATIVE PRODUCT <y1>
                   <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a response variable;
          <y2> is a variable where the computed cumulative products are
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y2 = CUMULATIVE PRODUCT Y1
    LET Y2 = CUMULATIVE PRODUCT Y1 SUBSET Y1 > 0
 
Note:
    Although this is an infrequently used command, it can be useful for
    the following type problem.  Suppose you have an input variable to
    be used in further calculations.  However, you only want to use
    those values up to the first occurrence of a value greater than
    some cut-off value.  Do the following:
       LET CUTOFF = <supply value>
       LET N = SIZE Y1
       LET TAG = 1 FOR I = 1 1 N
       LET TAG = 0 SUBSET Y1 > CUTOFF
       LET TAG = CUMULATIVE PRODUCT TAG
    Now TAG contains 1's up to the first value greater than the cutoff
    and all 0's after that.  This TAG variable can be used as a SUBSET
    variable in subsequent commands.
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SUM                 = Compute the sum of a variable.
    CUMULATIVE SUM      = Compute the cumulative sum of a variable.
    CUMULATIVE INTEGRAL = Compute the cumulative integral of a
                          variable.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    . Find the first random number greater than 2.5
    LET Y1 = NORMAL RANDOM NUMBERS FOR I = 1 1 10
    LET CUTOFF = 2.5
    LET N = SIZE Y1
    LET TAG = 1 FOR I = 1 1 N
    LET TAG = 0 SUBSET Y1 > CUTOFF
    LET TAG = CUMULATIVE PRODUCT TAG
    LET ID = SUM TAG
    LET ID = ID + 1
 
-----CUMULATIVE SUM (LET)--------------------------------
 
CUMULATIVE SUM
 
Name:
    CUMULATIVE SUM (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the cumulative sum for a variable.
 
Description:
    For element I of the given variable, the cumulative sum is the sum
    of elements 1 through I.
 
Syntax:
    LET <y2> = CUMULATIVE SUM <y1> <SUBSET/EXCEPT/FOR qualification>
    where <y1> is a  response variable;
          <y2> is a variable where the computed cumulative sums are
               stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y2 = CUMULATIVE SUM Y1
    LET Y2 = CUMULATIVE SUM Y1 SUBSET Y1 > 0
 
Default:
    None
 
Synonyms:
    None
 
Related Commands:
    SUM                 = Compute the sum of a variable.
    CUMULATIVE PRODUCT  = Compute the cumulative product of a variable.
    CUMULATIVE INTEGRAL = Compute the cumulative integral of a
                          variable.
 
Applications:
    Data Analysis
 
Implementation Date:
    Pre-1987
 
Program:
    LET FUNCTION F = X**2 + 2*X - 8
    LET X + SEQUENCE 0  .1 10
    LET Y1 = X
    LET Y2 = CUMULATIVE SUM Y1
 
-----CUMULATIVE <STATISTIC> (LET)---------------------------------------
 
CUMULATIVE (LET)
 
Name:
    CUMULATIVE <STATISTIC> (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute a cumulative statistic for a variable.
 
Description:
    It is sometimes useful to a compute a cumulative value for a
    statistic.  That is, for element i of the response variable
    we compute the value of the specified statistic for elements
    1 to i.

    Although this command is most commonly used for a location
    statistic, it can in fact be used for any supported statistic
    (enter HELP STATISTIC for a list of supported statistics).

Syntax:
    LET <yout> = CUMULATIVE <stat> <y1> ... <yk>
                               <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of one to three response variables
              (depending on what <stat> is);
          <stat> is one of the supported statistics (HELP STATISTICS
              for a list);
          <yout> is a variable where the computed values are stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
Examples:
    LET Y2 = CUMULATIVE MAD Y
    LET Y2 = CUMULATIVE MEDIAN Y
    LET Y2 = CUMULATIVE SD Y  FOR I = 1 1 50

Note:
    The commands CUMULATIVE AVERAGE, CUMULATIVE SUM, CUMULATIVE PRODUCT,
    CUMULATIVE INTEGRAL, CUMULATIVE MINIMUM, and CUMULATIVE MAXIMUM are
    implemented separately, and more efficiently, from this command.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CROSS TABULATE (LET) = Compute a statistic, or a cumulative
                           statistic, across groups.
    MOVING               = Compute a moving statistic.
    CUMULATIVE SUM       = Compute the cumulative sum of a variable.
    CUMULATIVE MEAN      = Compute the cumulative mean of a variable.
    CUMULATIVE MINIMUM   = Compute the cumulative minimum of a variable.
    CUMULATIVE MAXIMUM   = Compute the cumulative minimum of a variable.
    CUMULATIVE PRODUCT   = Compute the cumulative product of a variable.
    CUMULATIVE INTEGRAL  = Compute the cumulative integral of a variable.
 
Applications:
    Data Analysis
 
Implementation Date:
    2013/01
 
Program:
    skip 25
    read mavro.dat y
    let n = size y
    let x = sequence 1 1 n
    .
    let y1 = cumulative median y
    let y2 = cumulative lower quartile y
    let y3 = cumulative upper quartile y
    .
    line solid dotted dotted
    .
    plot y1 y2 y3 vs x

-----CUMULATIVE STATISTIC PLOT---------------------------------------
 
CUMULATIVE STATISTIC PLOT
 
Name:
    ... CUMULATIVE STATISTIC PLOT
 
Type:
    Graphics Command
 
Purpose:
    Plots the cumulative value of a statistic for a response variable.
    Optionally, the cumulative statistic can be plotted against a group-id
    variable.
 
Description:
    The <stat> STATISTIC PLOT can be used to plot the value of a
    statistic versus the index of a group-id variable.  So if
    you have 10 groups in your data, there will be 10 values of
    the statistic computed.

    The <stat> CUMULATIVE STATISTIC PLOT is a variant of the
    <stat> STATISTIC PLOT.  There are two cases.

       1. If there is a single group in the data, then the
          cumulative value of the statistic will be plotted
          versus the sequence number.  That is, plot

              S(Y(i)) versus i

          where

              S(Y(i)) = the value of the statistic for observations
                        1 to i.

          A reference line will be drawn at the mean value of
          the computed statistics.

          The appearance of these two traces is controlled by the first
          two settings of the LINES, CHARACTERS, SPIKES, BARS, and
          and associated attribute setting commands.
 
       2. If there are multiple groups in the data, then the process
          above is repeated for each group.  In this case, the
          x coordinates is the index of the full data set, not just
          the current group.  However, the cumulative statistic is
          only computed for points in the current group.  The group
          sizes do not need to be equal.

          The distinction between this command and the STATISTIC PLOT
          is that the STATISTIC PLOT only plots the value of the
          statistic for all points in the group while this command
          plots the cumulative value of the statistic for all points
          in the group.  For example, if there are ten groups with
          ten points each, the STATISTIC PLOT will plot ten points
          while the CUMULATIVE STATISTIC PLOT will plot 100 points.

          A reference line will be drawn for each group (the reference
          value is the mean value of the statistic for the specific
          group).

          The traces for the plot are defined in pairs.  That is,
          trace one is the cumulative statistics for group one, trace
          two is the reference line for group one, trace three is
          the cumulative statistics for group two, trace four is the
          reference line for group two, and so on.

          If you enter the command

              SET CUMULATIVE STATISTIC PLOT GROUPS STACKED

          then the x coordinate will start at one for each group.
          In this case, no reference line is drawn.

Syntax 1:
    <stat> CUMULATIVE STATISTIC PLOT  <y1> ... <yk>
                                      <SUBSET/EXCEPT/FOR qualification>
    where <stat> is one of Dataplot's supported statistics;
          <y1> ... <yk> is a list of 1 to 3 response variables
              (<stat> determines how many response variables);
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    For a list of supported statistics, enter

          HELP STATISTICS

    This syntax is for the case without groups in the data.

Syntax 2:
    <stat> CUMULATIVE STATISTIC PLOT  <y1> ... <yk> <x>
                                      <SUBSET/EXCEPT/FOR qualification>
    where <stat> is one of Dataplot's supported statistics;
          <y1> ... <yk> is a list of 1 to 3 response variables
              (<stat> determines how many response variables);
          <x> is a group-id variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    For a list of supported statistics, enter

          HELP STATISTICS
 
    This syntax is used for the case where there is a group-id
    variable.

Examples:
    MEAN CUMULATIVE STATISTIC PLOT Y
    MEAN CUMULATIVE STATISTIC PLOT Y X
    MEAN CUMULATIVE STATISTIC PLOT Y X  SUBSET X > 2
    SD CUMULATIVE STATISTIC PLOT Y
    CORRELATION CUMULATIVE STATISTIC PLOT Y1 Y2
 
Note:
    In some cases, you many want to have some minimum number of points
    before computing the statistic.  You can enter the command

         SET CUMULATIVE STATISTIC START <value>

    where <value> indicates the minimum number of points before the
    statistic is computed.  Note that if this value is greater than
    one, then the x-coordinate of the first point will be <value>
    (rounded to the nearest integer), not one.
 
Note:
    The word STATISTIC is required in this command (i.e., CUMULATIVE PLOT
    is not a synonym for CUMULATIVE STATISTIC PLOT).  This is to avoid
    conflicts with other commands.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CUMULATIVE <STATISTIC>  = Compute the cumulative value of a statistic.
    MOVING STATISTIC PLOT   = Generate a plot of the moving value of a
                              statistic.
    STATISTIC PLOT          = Generate a statistic versus index plot.
    CHARACTERS              = Sets the type for plot characters.
    LINES                   = Sets the type for plot lines.
 
Applications:
    Exploratory Data Analysis
 
Implementation Date:
    2015/5

    The list of supported statistics is frequently updated.  Enter HELP
    STATISTICS for a current list of supported statistics.
 
Program:
    . Step 1:   Read the data
    .
    dimension 40 columns
    skip 25
    read zarr13.dat y1
    read berger1.dat y2 x2
    read gear.dat y4 x4
    skip 0
    .
    . Step 2:   Set some default plot control options
    .
    case asis
    label case asis
    tic mark label case asis
    title case asis
    title offset 2
    y1label displacement 15
    x1label displacement 12
    multiplot scale factor 2
    multiplot corner coordinates 5 5 95 95
    .
    . Step 3:   Cumulative plots, no groups, single response variable
    .
    multiplot 2 2
    x1label Sequence
    .
    title Mean Cumulative Statistic Plot
    y1label Cumulative Mean
    mean cumulative statistic plot y1
    .
    title Median Cumulative Statistic Plot
    y1label Cumulative Median
    median cumulative statistic plot y1
    .
    multiplot 2 2 3
    title SD Cumulative Statistic Plot
    y1label Cumulative SD
    standard deviation cumulative statistic plot y1
    .
    title Skewness Cumulative Statistic Plot
    y1label Cumulative Skewness
    skewness cumulative statistic plot y1
    .
    end of multiplot
    .
    just center
    move 50 97
    text Cumulative Statistic Plots for ZARR13.DAT
    .
    y1label displacement
    x1label displacement
    .
    . Step 4:   Cumulative/moving plots, no groups, two response variable
    .
    xlimits 0 120
    .
    title Correlation Cumulative Statistic Plot for BERGER1.DAT
    y1label Cumulative Correlation
    correlation cumulative statistic plot y2 x2
    .
    xlimits
    .
    . Step 5:   Cumulative plots, groups, one response variable
    .
    title Mean Cumulative Statistic Plot for GEAR.DAT
    y1label Cumulative Mean
    mean cumulative statistic plot y4 x4

-----CUSUM TEST------------------------------------
 
CUSUM TEST
 
Name:
    CUSUM TEST
 
Type:
    Analysis Command
 
Purpose:
    Perform a cumulative sum test for randomness.
 
Description:
    The cuulative sum test is used to test the randomness of a
    sequence of zeroes and ones (Dataplot will covert a data set
    with exactly two distinct values to a sequence of zeroes and
    ones).

    For this test, the zeros are converted to negative ones.
    This test is based on the maximum distance from zero of a
    random walk defined by the cumulative sum of the sequence.
    A large enough distance is indicative of non-randomness.

    This test is discussed in detail in SP 800-22 (see Reference
    below).

    The cumulative sums test is defined as follows.

    H0:          The data are random.
    Ha:          The data are not random.

    Test         Compute the partial sums in the forward direction:
    Statistic: 
                     S(1) = X(1)
                     S(2) = X(1) + X(2)
                     S(3) = X(1) + X(2) + X(3)
                         ...
                     S(k) = X(1) + X(2) + X(3) + .... + X(k)
                         ...
                     S(n) = X(1) + X(2) + X(3) + ... + X(n)

                 Similarly, compute the partial sums in the
                 backward direction:

                     S(1) = X(n)
                     S(2) = X(n) + X(n-1)
                     S(3) = X(n) + X(n-1) + X(n-2)
                         ...
                     S(k) = X(n) + X(n-1) + X(n-2) + .... + X(n-k+1)
                         ...
                     S(n) = X(n) + X(n-1) + X(n-2) + ... + X(1)

                 The test statistic is the absolute value of the
                 maximum partial sum divided by the square root of
                 the sample size.
  
                 Note that separate test statistics are computed
                 for the forward and backward directions.

    Significance alpha (recommend value is 0.01)
    Level:
    
    Critical     Compute the p-value
    Region:
                    1 - SUM{k = (-n/z + 1)/4 to (n/z -1)/4}
                    {NORCDF[(4*k+1)*z] - NORCDF[(4*k-1)*z]} + 
                    SUM{k = (-n/z - 1)/4 to (n/z -3)/4}
                    {NORCDF[(4*k+3)*z] - NORCDF[(4*k+1)*z]}
 
                 with z denoting the value of the test statistic,
                 n the number of observations, and NORCDF the
                 cumulative distribution function of the standard
                 normal distribution.

    Conclusion:  Reject H0 if the p-value is less than alpha.

Syntax 1:
    CUSUM TEST   <y>    <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable being tested;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    The response variable can be a matrix.

Syntax 2:
    MULTIPLE CUSUM TEST <y1> ... <yk>   <SUBSET/EXCEPT/FOR qualification>
    where <y1> ... <yk> is a list of 1 to 30 response variables being tested;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    The keyword MULTIPLE is optional.  The cusum test will be performed on
    each response variable and these response variables can be matrices.
    The TO syntax is supported for the variable list.

Syntax 3:
    REPLICATED CUSUM TEST <y> <x1> ... <xk>   <SUBSET/EXCEPT/FOR qualification>
    where <y> is the response variable;
          <x1> ... <xk> is a list of 1 to 6 group-id variables;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

    This syntax will cross-tabulate the group-id variables and performs
    the cusum test for each unique combination of cross-tabulated values.
    For example, if X1 has 3 levels and X2 has 2 levels, there will be
    6 cusum tests performed.  This syntax does not support matrix arguments
    and the keyword REPLICATED is required (to distinguish this from the
    MULTIPLE case).  The TO syntax is supported for the variable list.

Examples:
    CUSUM TEST Y
    CUSUM TEST Y1 TO Y10
    REPLICATED CUSUM TEST Y X1 X2
    CUSUM TEST Y SUBSET TAG > 1
 
Note:
    The recommended minimum sample size is 100.

Note:
    The following statistics are also supported:

        LET A = CUMULATIVE SUM BACKWARD TEST        Y
        LET A = CUMULATIVE SUM BACKWARD TEST PVALUE Y
        LET A = CUMULATIVE SUM FORWARD  TEST        Y
        LET A = CUMULATIVE SUM FORWARD  TEST PVALUE Y

    Enter HELP STATISTICS to see what commands can use these
    statistics.

Note:
    If you want to test a uniform random number generator,
    you can use this test by converting the uniform random
    numbers to binomial random numbers.  For example,

        LET N = 1
        LET P = 0.5
        LET Y = BINOMIAL RANDOM NUMBERS FOR I = 1 1 1000
        CUSUM TEST Y

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    FREQUENCY TEST            = Perform a frequency test for
                                randomness.
    RUNS TEST                 = Perform a runs test for randomness.
    ANDERSON-DARLING TEST     = Peform an Anderson-Darling test for
                                randomness.
    UNIFORM PROBABILITY PLOT  = Generate a uniform probability plot.
 
Reference:
    "A Statistical Test Suite for Random and Psuedorandom Number
    Generators for Cryptographic Applications", Andrew Rukhin,
    Juan Soto, James Nechvatal, Miles Smid, Elaine Barker,
    Stefan Leigh, Mark Levenson, Mark Vangel, David Banks,
    Alan Heckert, James Dray, San Vo, NIST SP 800-22, October, 2000.

 
Applications:
    Testing for Randomness
 
Implementation Date:
    2004/1
    2011/3: Support for MULTIPLE option
    2011/3: Support for REPLICATION option
    2011/3: Support for matrix arguments and the TO syntax
    2011/3: Output reformatted, added support for RTF output
    2011/3: Support for SET WRITE DECIMALS
    2011/3: Added CUMULATIVE SUM statistics
 
Program:
   LET N = 1
   LET P = 0.5
   LET Y1 = BINOMIAL RANDOM NUMBERS FOR I = 1 1 200
   LET P = 0.58
   LET Y2 = BINOMIAL RANDOM NUMBERS FOR I = 1 1 200
   LET P = 0.65
   LET Y3 = BINOMIAL RANDOM NUMBERS FOR I = 1 1 200
   LET P = 0.85
   LET Y4 = BINOMIAL RANDOM NUMBERS FOR I = 1 1 200
   SET WRITE DECIMALS 4
   .
   CUMULATIVE SUM TEST Y1
   PAUSE
   .
   CUMULATIVE SUM TEST Y1 TO Y4
   PAUSE

-----CURSOR COORDINATES-----------------------------------------------
 
CURSUR COORDINATES
 
Name:
    CURSOR COORDINATES
 
Type:
    Support Command
 
Purpose:
    Specifies the cursor coordinates (in 0 to 100 units) to which the
    cursor returns to after a plot has been generated.
 
Description:
    This command is commonly used when interactively plotting a
    diagram to keep the cursor "out of the way" from the body of the
    plot.  Note that:
       (0,0)     = lower left  of screen;
       (100,0)   = lower right of screen;
       (0,100)   = upper left  of screen;
       (100,100) = upper right of screen.
 
Syntax:
    CURSOR COORDINATES   <x1>   <y1>
    where <x1> and  <y1> are numbers or parameters in the decimal range
    0 to 100 that specify the desired coordinates.
 
Examples:
    CURSOR COORDINATES 5 5
    CURSOR COORDINATES 90 95
    CURSOR COORDINATES 3 95
 
Default:
    The cursor is positioned at the next line.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    CURSOR SIZE         = Sets the size of cursor.
    WINDOW COORDINATES  = Sets the location of the plot window.
    FRAME COORDINATES   = Sets the location of the plot frame.
    LEGEND COORDINATES  = Sets the location of the plot legends.
    BOX COORDINATES     = Sets the location of the plot boxes.
    ARROW COORDINATES   = Sets the location of the plot arrows.
    SEGMENT COORDINATES = Sets the location of the plot line segments.
 
Applications:
    XX
 
Implementation Date:
    XX
 
Program:
    XX
 
-----CURSOR SIZE-------------------------------------------------------
 
CURSOR SIZE
 
Name:
    CURSOR SIZE
 
Type:
    Support Command
 
Purpose:
    Specifies the cursor size (in 0 to 100 units where 100 is the
    maximum vertical screen distance) that the cursor returns to after
    completion of a plot.
 
Syntax:
    CURSOR SIZE   <n>
    where <n> is a number or parameter in the decimal range 0 to 100
    that specifies the desired cursor size.
 
Examples:
    CURSOR SIZE 3
    CURSOR SIZE 2
    CURSOR SIZE 1.4
 
Note:
    The cursor size is drawn with a hardware character, so the actual
    size on the screen is the closest available hardware character size
    to the requested size.
 
Default:
    The default cursor size is 3.
 
Synonyms:
    None
 
Related Commands:
    PLOT                = Generates a data or function plot.
    CURSOR COORDINATES  = Sets the location of post-plot cursor.
    HEIGHT              = Sets the height for TEXT characters.
    WIDTH               = Sets the width for TEXT characters.
    HW                  = Sets the height and width for TEXT
                          characters.
    VERTICAL SPACING    = Sets the vertical spacing between text lines.
    HORIZONTAL SPACING  = Sets the horizontal spacing between text
                          characters.
 
Applications:
    Interactive Usage
 
Implementation Date:
    Pre-1987
 
Program:
    XX
 
-----CUSUM ARL (LET)--------------------------------
 
CUSUM ARL
 
Name:
    CUSUM ARL (LET)
 
Type:
    Let Subcommand
 
Purpose:
    Compute the average run length (ARL) for the cumulative sum
    control chart.
 
Description:
    The average run length for the cumulative sum control chart
    is the average number of observations that are entered
    before the system is declared out of control.

    This command assumes the following parameters have been
    defined:

    S0  = start-up value for the cumulative sum.  This is usually
          zero.  However, it can be set to a positive initial
          value for a fast initial response (FIR) cusum chart.
    H   = defines the value which signals that the cusum is
          "out of control".  A value of 5 is a common choice.
    K   = the value of k is set to one half of the smallest shift
          in location (in standard deviation units) that you want
          to detect.  A common choice is a 1-sigma shift, that
          is k = 0.5.

    The cusum arl is defined relative to DELTA.  DELTA is the
    difference between the target value of the process and the
    true value of the process.  DELTA is usually defined to be
    a sequence of values.  For example,

        LET DELTA = SEQUENCE 0 0.01 0.5
 
Syntax 1:
    LET <y> = CUSUM ARL <delta>   <SUBSET/EXCEPT/FOR qualification>
    where <delta> is a  number, parameter, or variable that 
               contains the delta values;
          <y> is a parameter or variable (depending on <delta>)
               where the cusum arl is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for a 2-sided cusum chart.

Syntax 2:
    LET <y> = ONE-SIDED CUSUM ARL <delta>
                        <SUBSET/EXCEPT/FOR qualification>
    where <delta> is a  number, parameter, or variable that 
               contains the delta values;
          <y> is a parameter or variable (depending on <delta>)
               where the cusum arl is stored;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.
 
    This syntax is used for a 1-sided cusum chart.

Examples:
    LET Y = CUSUM ARL DELTA
    LET Y = ONE-SIDED CUSUM ARL DELTA
 
Note:
    The LET command is used to specify the necessary parameters
    before entering the CUSUM ARL command.  See the Program
    example below.  Note that these parameters names do not
    have synonyms (i.e., you have to define K, H, and S0).
   
Note:
    Dataplot provides macros for generating ARL plots for the
    XBAR, C, and P control charts.  In addition, the OC curve is
    closely related to the ARL.  The OC curve is a plot of the
    Type II, or Beta, error.  The Beta error is the probability
    of incorrectly accepting the hypothesis of statistical
    control.  That is, the OC curve plots the probability of
    the Type II error while the ARL plots the average number
    of runs until a Type II error occurs.  Dataplot provides
    macros for generating the OC curves for the XBAR, C, and
    P control charts.

    Enter the following commands for details on how to use these
    macros:

       LIST ARL_XBAR.DP
       LIST ARL_C.DP
       LIST ARL_P.DP
       LIST OC_XBAR.DP
       LIST OC_C.DP
       LIST OC_P.DP

Note:
    Dataplot uses Applied Statistics algorithm 258 to compute
    the cusum arl.  Specifically, it uses the ARL1 and ARL2
    routines.

Default:
    None
 
Synonyms:
    None
 
Related Commands:
    CONTROL CHART    = Generate a control chart.
    PLOT             = Generate a data or function plot.
 
Reference:
    "Average Run Lengths for Cumulative Sum Schemes",
    William Fellner, Algorithm 258, Applied Statistics,
    Vol. 39, No. 3, 1990.

Applications:
    Quality Control
 
Implementation Date:
    1999/5
 
Program:
    LET K = 0.5
    LET H = 5
    LET S0 = 0
    LET DELTA = SEQUENCE 0 0.01 1.0
    LET Y = CUSUM ARL DELTA
    Y1LABEL AVERAGE RUN LENGTH
    X1LABEL DELTA
    PLOT Y DELTA
 
-----CUSUM CONTROL CHART----------------------------------------
 
CUSUM CONTROL CHART
 
Name:
    CUSUM CONTROL CHART
 
Type:
    Graphics Command
 
Purpose:
    Generates a cumulative sum (CUSUM) control chart.
 
Description:
    An cusum control chart is a data analysis analysis technique for
    determining if a measurement process has gone out of statistical
    control.  Similar to the exponentially weighted moving average
    control chart, it is better than the standard xbar control chart
    for detecting small shifts in the process mean.

    This command implements a mean cumulative sum control
    chart.

    There are numerous variations on how cusum control
    charts are implemented.  Dataplot follows the methods
    discussed by Thomas Ryan in "Statistical Methods for
    Quality Improvement".  Dataplot does the following:

    1) Positive and negative sums are computed as follows:

          SUMH = MAX[0,(z(i) - k) + SUMH(i-1)] 
          SUML = MAX[0,(-z(i) - k) + SUML(i-1)] 
 
       SUMH and SUML have initial values of 0.  Z(i) is
       the z-score of the ith group (that is, the sub-group
       mean minus the overall mean divided by the
       standard deviation of the subgroup averages.
 
       Dataplot plots the negative of SUML.  This is to
       avoid overlap for the plottting of SUMH and SUML.
       SUMH is plotted on the positive scale vertically and
       SUML is plotted on the negative scale vertically.
 
       The value of k is set to one half of the smallest
       shift in location (in standard deviation units)
       that you want to detect.  Dataplot by default selects
       a 1-sigma shift, that is k = 0.5.  To overide this,
       enter the command
 
            LET K = <value>

    2) By defauult, Dataplot sets the control limit at
       a value of 5.  That is, if the one of the sums exceeds
       5, the process is deemed out of control.  To override
       the default value, enter the command

           LET H = <value>

       The value for H is typically between 4 and 5.


    In some cases, there may be historical data or engineering
    considerations that determine the control limits.  You can set
    your own control limits by entering the commands:

        LET TARGET = <value>
        LET USL = <value>
        LET LSL = <value>

    where TARGET is the desired target value and USL and LSL are the
    desired upper and lower control limits.

    You can control the appearance of this chart by setting the
    switches for the LINE, CHARACTER, SPIKE, and BAR commands
    appropriately.  Specifically,

       Trace 1 = the CUSUM statistic for positive sums
       Trace 2 = the CUSUM statistic for negative sums
       Trace 3 = Target reference line (the overall mean)
       Trace 4 = Dataplot calculated upper control limit
       Trace 5 = Dataplot calculated lower control limit
       Trace 6 = User specified target value
       Trace 7 = User specified upper control limit
       Trace 8 = User specified lower control limit

    For example, to draw the EWMA values as a solid line and
    an X,  the reference line and the Dataplot calculated control
    limits as dotted lines, and no user specified control limit, 
    enter the commands:

        LINE SOLID DOTTED DOTTED DOTTED BLANK BLANK BLANK
        CHARACTER X BLANK BLANK BLANK BLANK BLANK BLANK

Syntax:
    CUSUM CONTROL CHART <y> <group>    <SUBSET/EXCEPT/FOR qualification>
    where <y> is a response variable;
          <group> is a sub-group identifier variable;
    and where the <SUBSET/EXCEPT/FOR qualification> is optional.

Examples:
    CUSUM CONTROL CHART Y1 X
    CUSUM CONTROL CHART Y
    CUSUM CONTROL CHART Y1 X SUBSET X > 1
 
Note:
    The cusum technique can be applied to a variety of control
    chart situations.  Currently, Dataplot only supports cusum
    control charts for the mean.

Note:
    There are alternative methods for determining control limits
    for the cusum chart.  In particular, the V-mask is a common
    technique.  Dataplot does not support any V-mask techniques at
    this time.

Note:
    The Fast Intitial Response (FIR) cusum chart works by
    providing inital values for the high and low sums.  You
    can implemment a FIR cusum chart in Dataplot by entering
    the following commands before the CUSUM CONTROL CHART
    command:

       LET SHI = <value>
       LET SLI = <value>

    Using a start value of h/2, where h is described above,
    is the common recommendation.

    FIR cusum control charts are recommended for the case
    where there may be multiple causes for an out-of-control
    signal and you want to detect as quickly as possible if
    the process is still out of control after the process is
    restarted. 

Default:
    None
 
Synonyms:
    CUSUM CHART is a synonym for CUSUM CONTROL CHART.
 
Related Commands:
    XBAR CONTROL CHART      = Generates a mean control chart.
    RANGE CONTROL CHART     = Generates a mean control chart.
    S CONTROL CHART         = Generates a sd control chart.
    EWMA CONTROL CHART      = Generates a ewma control chart.
    HOTELLING CONTROL CHART = Generates a Hotelling control chart.
    MOVING AVERAGE CHART    = Generates a moving average control
                              chart.
    MOVING RANGE CHART      = Generates a moving range control chart.
    MOVING SD CHART         = Generates a moving sd control chart.
    C CHART                 = Generates a C control chart.
    U CHART                 = Generates a U control chart.
    P CHART                 = Generates a P control chart.
    NP CHART                = Generates an Np control chart.
 
Reference
    "Statistical Methods For Quality Improvement", Thomas Ryan,
    John Wiley and Sons, 1989, pp. 122-124.

Applications:
    Quality Control
 
Implementation Date:
    1998/9
 
Program:
    TITLE Silicon Wafer Thickness Analysis
    LABEL CASE ASIS
    TITLE CASE ASIS
    Y1LABEL Wafer Thickness
    X1LABEL Day
    LEGEND 1 Statistical Process Control
    LEGEND 2 CUSUM Control Chart
    TIC OFFSET UNITS DATA
    TIC OFFSET 0.2 0.2
    .
    SKIP 25
    READ CCXBAR.DAT Y X
    .
    CHARACTER + - BLANK BLANK BLANK
    LINE BLANK BLANK DOT DOT DOT
    .
    LET P = 0.5
    CUSUM CONTROL CHART Y X
 
-----CYCLE PLOT--------------------------------------------------
 
CYCLE PLOT
 
Name:
    CYCLE PLOT
 
Type:
    Support Command
 
Purpose:
    Cycle through the current list of saved plots using
    mouse buttons.
 
Description:
    The SAVE PLOT and REPEAT PLOT commands allow you to save and
    recall graphs.  The primary use of this is to compare the current
    graph to previously created graphs.
 
    Dataplot maintains a list of saved graphs for the current
    session.  The CYCLE PLOT command allows you to cycle through
    these saved graphs using the mouse as follows:

      1) Clicking the left mouse button moves down the current
         list.
      2) Clicking the right mouse button moves up the current
         list.
      3) Clicking the middle mouse button returns control to
         Dataplot.

    The CYCLE PLOT must be preceded by at least one REPEAT
    PLOT command (i.e., there must be at least one saved graph
    drawn on the screen to cycle through, usually will be
    several before entering the CYCLE PLOT command).

    Note that the REPEAT PLOT command puts all graphs in the
    same window.  CYCLE GRAPH allows you to control which of
    the restored plots is currently visisble.

    These commands are host dependent.  They are currently
    supported for the following platforms:
   
       1) Unix platforms via the X11 device driver;
       2) Windows 95/98/NT command line version built with the
          Microsoft Fortran compiler;
       3) Dataplot GUI (both Unix and Windows 95/98/NT).

Syntax:
    CYCLE  PLOT
 
    This syntax waits for you to click on the current
    redrawn graph in order to initiate actions.

Examples:
    READ FILE.DAT Y1 Y2 Y3
    HISTOGRAM Y1
    SAVE PLOT HIST.1
    HISTOGRAM Y2
    SAVE PLOT HIST.2
    HISTOGRAM Y3
    SAVE PLOT HIST.3
    REPEAT PLOT HIST.1
    REPEAT PLOT HIST.2
    REPEAT PLOT HIST.2
    CYCLE GRAPH
 
Default:
    None
 
Synonyms:
    CYCLE GRAPH, CP, and CG are all synonyms for CYCLE PLOT.
 
Note:
    The "current list" consists of all plots saved in the
    current session and any plots from previous Dataplot
    sessions explicitly recalled with the REPEAT PLOT command.

Note:
    The REPEAT PLOT command is used to display a plot saved
    with SAVE PLOT.  The LIST PLOT command lists the currently
    saved plots (by sequence number, file name, and title).
    The CYCLE PLOT command allows you to cycle through the
    pixmaps in the current list by clicking mouse buttons.
    The PIXMAP TITLE command allows you to specify the title
    for a saved plot.  This title is simply for ease of
    identification in listing the saved plots and is not
    saved as part of the plot.
 
Related Commands:
    LIST PLOT    = List saved plots.
    REPEAT PLOT  = Redraw a previously saved plot.
    SAVE PLOT    = Save a plot.
    CYCLE PLOT   = Cycle through previously saved graphs using 
                   mouse buttons.
    PIXMAP TITLE = Provide a temporary name for a saved graph.
 
Applications:
    Interactive Usage
 
Implementation Date:
    7/1997
 
Program:
    READ BERGER1.DAT Y X
    FIT Y X
    4-PLOT RES
    SAVE PLOT RES.1
    QUADRATIC FIT Y X
    4-PLOT RES
    SAVE PLOT RES.2
    REPEAT PLOT RES.1
    REPEAT PLOT RES.2
    CYCLE PLOT
 
-------------------------------------------------------------

















































































































































































































----*-----      ----------------ZZZZZ------
